<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b3918cdf9f2ba51b30f663d29c1ab73a6786d357155287d63f85484efcfcedbfd824edcef72ec0b8c2086109d50855e71098c793f78b51d5efbf4c63e8d3f8f690c624f76281c36ab8df77b45c24f3e62383e841db4d37ead3e5a1d6e26c3b26f60911c53646fbf19c1b0a377c281273069cbba929d610be0c28dc2e7bcd00eb39375ddff29dd26b4b62fa778a77ae1086ee1e89b9a1f4da4cccfeddedb3ec7e2bf50be0ddcf45a9420465f0c623424c422257c73801e4bae2c02f78c1433feeb6b09da90e14f28e1a60e8894e32ecae3c5a28c85988c134fc68c6dc9dc1e5cdb7617aeb8c9d4b0834f2d7011fd088860db6e331803aa0a96cebd9c9ac6c0aabbdab6fdb124ff9c191b7ef5da9b88ad0ee7fcecde7caf4650ad7c9e43ffe846fd5911f623649f4fda978a4192b8ea7f157945213eafafd2e9c340ad2c2778df2b9cf5b7456a44755e7bf7a31e93957cce366cbf6e731565c288fcdab8c5f707e1e30990c59e3d528bd7ee0be05d4a8510bc234bf21ea662e2b6e0d352ed7738deb7df2da8aae6914641bf004c0f0b6a165104cb6f03b023b4eae72fb6fb35a70ad192988eb357f27dfa9114693d1243d0105db2f9ee5ac75ff9c2c477433fd98985d22a3a75c5100227fc1952787a6433a9d19b4a91e54cb918ed66b6b50207469d7f6edeff1491cde378c28725b5c358d6b59d8bf497d9ae9fa9695690749e1e334ff95f9ad144c1e749347fe443b6b0a031665f62823421627378f052ad5b6e2beb170febf9a95b6701c33f9b26d33f723ad0aea19a20e19b0801c3f494ccd6bbd8129ebed6f5a18f14caa1a394c2e81bc0f711a4468d91cf30cb257191ef6fd07c40b143570a67653e8fc73df71b2afacdd81847765946b398d4df3efd9f3549cf921874850a34aa4aa42d1bf7bd8d5ffa5c78d3169286596d740d0572251bd9bd79cdaa79693a026c591d915f6ac37818103e4be9bd30e3605482edeced5c3d0a2747b9dd782a30c8e8b4c86ce19fb2132e830d5db67371a1f40769e491f3796acf71b05b63e9f8239ba85bb572cb94dd2adce22d7427bdc8e98ec3ee854fd530d114665fb46f1956d9ec71504749db73b213f4130fdec54edcfd821144530c6f5ee07109dcc199466434a98f13512618c6825c13d06471f9172c4c597eaec2ab42f33abaacb76ea595b43cef25d2aa5cfd1e9c7c890d93ec91ac7f80129cf47bb8314a87a8ef0312fc09f2b34264fc85fcf1488523bb1004e3c9e459965a81d8c963cdce37cfe8981fc9c4304f46be3e6f19d32cd504a193eee223aced720631ccc29c36d750356c76325042ca8e7607511a47ccfd40b45074aad475fa9e79b6f1fb332907e96bd0c9f914ed69709f6e1d9e3636546d5d39630474b1086a4cd887d8943b55000e2c262e81508868dc8b42b7cbbbb8817ade3e9e050e7d6f2e0569a2339497dac959ab45beda604a1a843b8cc4eccd8c5b4fc577e2c4b365057ad66053d80f46899ff530b9461fac568bb0f9fbd3b0e16e1917fa3cc670f8475afa8b1cf26fc12cbae4f20321249353ca3fabf8ec1e7edd2a01e46b83f0a3c607de35568d9e88ff7cf5ab3051dbf6f38c858ae79a774ab0a11b8903eec52396fad7b4480e574d4bbc875b801b263d24b0ee6154ed5255af515cf2f37b620294a5ce77a1f613d2078d80d151eaf48d2853b241ba030e550e9cbd3960d5349113c9c1ad987d16679387168209c319968ef4de36605d887899232a343d6bfdb2f97f8d71e64e263f2c307df6e8cb254e68ebc508aad86646ffb2e9495716e4bd036920d09beff47afcf60421f7b0868db1a28209c9a500001bbfb3e66443aec7c2bc29c79bd17e75c859808766e6d5f5d4bb57fc1bc060376bb9705f66d2cc1b76f0d414e6f6c406eda3e77f2e0e2cc2900a210cfd4a991de5e54a1ab2018be8da6580a008444355d953daa58df4ed1bdef6a06fc9404964155f864ed1068ca2ec918676237982e23c9025c68cb04befd97f568661f77f01e080342393e5648d4a303fad445524fe4ae93e106892e356220b0b236e35ce3b5f9c1ef9279038843ad13111029b84a36f70173df4f8609defac46680548e6ce37f0016cb26dd61e9e0dd4966583f1acb9ae3ee0333d07cdd72b6c1ab2ea3178911f280555dd0164f0c73d4e34c0ef0838804c5cd85da4ed60d95cf5bd27ef6836a21b82891f87a146235d30ab9d8edf5625e035c560a231e37f93c4f3962b1602c6ec24cef6c3c8afd66e67bb36b7f098eb48007b3b4bcfa3ec1d37498fffe3eef4836d266d021c3c3e63e3e409a4b60dce7f592b4ff67432b867a27948b83d88ee2130ff1d68c236e2727bafddde8d1258677aa6b1808f09c3aeb0b4cff755cadbf1640d8d50e6b9d9340c0cb52549201c340595453fb7e28e2bd7b5fafbc9f51073ca1f4d95c921cb7e01a5b4b21b349f831e340d6a4ed3782639c7b8fb2ba1e0bef8cc6c75936c260ab291ea0143d01ced98f8b98bbdbfe3b2e7e5baa95975d731176860c4d90c994f0fceced2072dfd07cefd6c5bfc7c479d078b462457195e58cdf187ffd9f3d47e01546a37fddc3b3e1fef71a7e3c51119ab62fb8a04209d3cd1f449ab0f6b41177c0cb7e2d69f67b2fbc603f12585e5be23b1555a89f59f9ef59b230c8bd89582d6abac79f7755afa50a059bff5946d41260fb653851cc72eb5719ecde094e61f5e7eca9416f27674b7fcf3bda3eb57bcb227a353b1e23db68dd52172f37f056570328d0573d2ea5bbe0480d93b3cbd9983ca0ca24fe2b11ffb85d2459c0f4feb7ce7e6993cb8e8532e6e815b23e3bb1ecb586af61bc68133e327527cf1023513e290fe38d00e231947c6b40f9170dae6633ebfca8e3436939e34f86273b57ef083a617e0b4d8bbb70761920bc252dd7d62b10a98efef4a638abd4b8d7193216926c507c7fe7cd3d1feb6085a8528071d993a7e9fff5e782c46c0246ba9eee6b3d56608600dda81b74d2eee71c567821fc8988d6c1e3d79887d1ce421971e484ac0478133d3efe9d09b9057bf6f64c5235f4bf5418db55b67376f3d00eceea6299e02bca09498b9c092e7b4187656291aa77d295512b42a496abba110d1b6ebf0745fea1260cf591ae8d4950ed47fba7833946213b9ae7d9552a542453d3ec12f3fd0df07812d04dd096488c3046491eb1ab028ab2a3d88f276ec5f70f02627a596ffcdbd5428fb7b986052dad67887f969ef74a7d5a0589b83cdb9a1c11b54bd0b9749ad5063f24d9abcc2369e7f4df00e231a49f6c7d5e8045948c4403478a7bbb617da3f85b4e189f0a2b131523427ee59b044a85a99214add60b13b29fa97d927092eb33c8ed7828a349e511099d11a9f0c7f4498c58d68cea7832c0c109eb4d10cbf4ede827627dd8d83f3fc1527b228bf11ab6366966c57f717f63fa71c79d975e56f56a5136ce07ac64db2445f4526f022f9f8f615889f44e0249e2b590e3f6282729ffeb85320c0f1431659f915d5017c17f5b01b774c9b218544378d68bbf6e3f3df9cd5246e234c4507c39a472b289ff0d470ddf8fdec16551d6afa981705a4b8b236f762ed17aa0284453eb2169205bb26d10fa6464172adf4e0fdc95b0a6478c51b7273d0417e7e24936b6e4b7ea64923945cc1d7a1dece115de9255cf15c09cc752abcb52ebdf0f7b4b737b5629508277ed9a317a58d984fe39387b15c066198175e27140a47dca0033b57c0f17d6e67c7aa05da93e3be9d159fcadf9f43beb5ad64c7569386db3802ee6068276bfd2beb6b0789924d1348b4e4025e3b46b5d44c592b434406d5f79c698fa72318e8cb570669a94ebd7021b2ba0fe7d1e9add9b03d012c66b101726e48c081f7ce9d8ec7d229fd04bbb8b212ce0a6115e5968bee2aa81038ab88764b0dae437b0fc3e0f1a10d03417f53427ad90ebda8fc713a4d5fbb986c4fc7edc3d5bf998de00bbba7ad35a30d696d659affe11f806172f07744eecaee31cc391f4c45e0d5b76c94fa19e0b4939a1033f1c1c4ade7b6e3f62d2a6de43dd0857022e519e27928d7467659671514fc2a06a7202746f1ca6e80072eb20b71b8decf02de018244be3dc69ced371fe6b24c216134cffcece80f34d9cdd4a2fb3682e55830c6cae67a3269780cdc903f2edebafb93bf7fd2eaf327a4530add6f9fd21d35e785074664e8f47944e26ac7c763dfe6c3890d4fc82dbc199fcda94efd6d553aee6877f056ee50ce7f8d3c3eb1fd25e1b72e7ef5feaae242a5455dc15da645bee15e22c5d6344076706089355c7b68d8d6b95814dc5ecbf3aba3aa894807d188f6982299117142f9858e90b3440e9cdf27c26a995bb8a687d1032dd3aa19c135fde965aa48c6a3fd88867efa7ce0d4081c3eaa27c6594947eef7cbdfcac0805aef327d6bd9aa7796d4877e16234c9551a8063e79a4ae0181cc567b80849f02181047b5182e4f090c56196e2c64013389e7396bffd5327c22ef4768ddc6adf5cbe2a8d95e5162f264ab1a330a752a445ff1fb4342f59751e4a8a99d52593b653b00f09765a7b4bf59c861d7e7d8becf307da21e757e18c3b11835960e796543ad3044454896ae6ccab31e1eca59625816a4186cffa9868d7921c5c8f5c6a03113fb192afef2879dcb008da8fe61e441e2862a5975be2c3c162c8faedf292104c14f42bde0cbbd2f84913b1de6a08c7b406d4842d9ba68aa85934279359653eef5c37dcff623719b1b3215d148358976e7b018f68033bebba075c3f2f1955d93fe8b280bb7bdd64874220bfa96e955543995f5cf2c17c931ed101781d0dfc7d875eacd96f028fb571e99840379c433ec2d864b6e5ebd6fc79a49c89f6b434302fed73a8c445ea37671bf15b893b81f0dac676b321f33090375d32dd1dd6ee036f82285ef5682ac47e4c3d015d779a169e213614d35bbfe9f81fc71f54057c8911bdd4c0b7217aa2977e505bc1e336d3b8f8485388aa2d686be4cad4fd506196e518441c1aad3d01013b7952b45e65dbf4f82e5c2fcedd12b0ab38fca4114bc1ea418b27abc387190a14fc4d770db5eb0c19466513c6b69f52f33970835f8f2b004bd200badd04a726792f223daea8f89d978426e0dc261d4757cd76191e627f2a577694850a681fc7ee27f0f8e2cb1098ef443ec3b261860f13e4b7381c19be3dc716a76cd497693356153906efaea1b195888c33660482d5f316f89e32556d56fab2b6a1918f2d4d7ff6049c419d72d25186b31dfe6136c144ace61252634ba1f113d1055be88f9967c15d720d512ab10dc1b554a210598200ab5bd16225b7d30e3c44061493ea37f3a16d4b187492ba6c2d4be8d8754bb1d9295b3be2f0ff1e473932aa0a8b6898edeb53639c517a13cc60871e3f3bffbbafd368f71f5b6ec08d239f0e73ce6ad71ff4b1c4a94163b9258a14b7c81bf0d066f497524a34b77e1cada61366613ff56175af64b4d466c1146cd90cf2d6c353dc89f6d745b04923a852396dd26b22b02d8d37e36e30c9ceea253cc4d2f99f682dcb7e0f50c684892ffc34b83624314aafd004ac1ae994fb61e9a7886a106d8c0a7e1db56a52bfbc953cd0357bff82336e869345b1ed23cddb94996f390b3b8a17e89ab8bdcd0666ade9a1fa8aed0d2d22729fcdb259132fab389af0c07458a5d5d43ad3864bdadf2b48391a8512a3abd036244091722e6ded1c019b8fca965abd47d86fc18d571bf91d92e1c2db6cdc589e1df8973632763ad15927ddf0402a6efbfb97a81488b27a6d1d0614993968ac43b380de4ad2efb74390af49f790d7b3ed4c3a59304a18162b0b336f142ec89a59187cdb00a8a5709bcd67fd6407dc76ecf512a81c93cc9b95b426bddb6bbb827d969f5faef71077750e9e747758868f8c837fedc05a3e051107c08b7e0498aeba4054dc0fd269a8c5162bf2069f57239b2bfee22c5a82fab07067d869e498f2b403f8f3f97130a2208c4020d8bc13b2ee14ba210d291aff3cd23f7a7992ceb405b583a6fc21c52ecc8bf39676415cb9980dab0cde311787050d2dff7a11c38d17a706bbf15675c3ac3ba30f144563283db118f31e2488e1c369538d67da7193e4028653d2a6a129f2e9197819d8ff797ea2e2d02d7c01027bb26dd523c57680fc1f2bf46973768dd863253135507731f1b0d28775b84008d4bee6e46477296d1824e8208de3a67411b8d91ecbbdc12f2c12dc8dd2aa44d50f12b5a4a12c5320c37c694ebc72ff97004d9c887d1801c6649c22156d81065cb05cc3f2f23e8f7856763562f7eae0d1da0476964e8e8ed091e7379f23763ff768004d4d2a404a1b0a2b6e5e7e382580a7e1f1944f304f08380c25b66f5b944f3270ae904857a8d399e057ba06ffdc242bff330624ad04bb88d71bf0150bcef716569db2c748f703dccb0a832dbf5a098781197af07ff1a311260f802ef5f09fc17e63180ffb85232b9902febdf3ca0301d82bf08b6005fa1efc4a614c0ea40381321fe40697b644115edd51377a6f6954de3b7b61c82eb33c76d0512c953a770bd1d93f974408d1a40b34b0ccda328ce26111038c8595c25d3f3f98a21a0ba84ded0e83f3519895eea2f0cb033b8d2ba4bf6eecbf225835ac8c5e6c63badd3ba3ba2b32402f98e05ef18db5850405ec26a8a768bb5c00ce7f4d88024bda28f6f5f97428e2719586232c86c43ec29658fd1751575e3fa071cc1828bd1ddb55cbfe6d31b529b04422ed21391faf6b750256c9a0f13a8adb6e03bc5ec84999c8ae01cdbe6ded9a58546c28c73e7091f4bfd4ca9119095a11deb5efc5ff47ad8d1be28a50799cdc0dc5103e582c4dd6b84f99cb46d7a4090e6071595bf8c73a6c0abeb6d01474951f36e5622ee29ad2802c546d8aab5bf70c15c2325681c748571254df21ecf5ddaf2d4102c6683db051b3859d5b56d3d759853428fb3a9adf67075f1b3e1c73bcc284ac23ea36ef5f9adfadec3dce5299e24982fb17efdc9f522cacdb0a866d0fb2fc01bb4ac1d0c422728294bb1059e563e2a00765bdcc88b6738e6166e23a6651c743ad835bb11d24a53795301ff7bf61e32d062be88b90a0852dfb96a2767896f6772e36e7a2713205dd3cd1430438b8e37976a165c9f141e1c3ad6cec8363abe6ce0eafe36f971672a69292c3eaab56d8f0bfd046d8bb494dbeb4efc988c83c30a7dee8a54e4950d09ce39738abdecd33156e4607e8d5b94597ea0704e4fca3adcb5eaaf76dd8ff3c8a8372bec4efcd0fa8582cebd812a68682c4e4805eb11a15973c11f68c9d45a3ba2131d2e9df0a792da41fbe6712338fad3e46b0c75ecc0acbb736c2b012c3e878afa518e0a0d09593ce1691920de1641dafdbe18e57a26b216857107438016608eac0e7c1a0cd433fd54ff96e948a908246a319e9957c565369649f378bcb66700faa4fd5ce1492192c2510f40daa7f6c48143cfca86415209db5ee9ed7426c5969fd37ebf03a0990490b609186f25e68dcd6bbbdb2675b055de87c304c169924612244ad68fa1051cdf084f603a05a131a7cba184e41efa78a332d0fcfdb7ae57f42c8f03a71fd2cf9c26aa2b549910a975357e36cd448b87887fe76d582fc2843ad2af7629a772990e225f1f960bb622437581e14c29cfd841cbed115a8c7de93445b73ffee445dcb3435aad4d3485b59e96b0d3488fcf18abd77ee37700edb2d319a53b2a63a58eff18a3afd985612be6b1a4fddd2e19a846bba35685949a6b59e7fcdfcb9b8259f6f45132d829ac01cf6fc584750b3ab864388ce0f061213761551684e44aea9d6973eae99e2017ae96a4e105032fcdd66806a89079376453b378343bac6c19021f64bb217a12a784fc5c213df99b1aa8fed44ffb73a6a29f7605818a39d7649158d70e606b80cf251a2f90bc4315c4619b22271a88974cfa2584cf7d6628bb159196138bad02123c2b42415435240025372cd641851f124713ce4432ab635dd3e1be55cbf5c74692457ae0156acead533987bc55e4e11dffd0333bf500e3c94aaf0c18f217fe0e67992470b78ab2e3a2d548278b857aa82141d85db2d4cc7a4bc3681a3d37bc22585854f3bba38d987d0a1b7cebc56f8a431dc271ce77b6b3c2317eab9c15e525b83a2ac77f208240d8ddec6bd5a886394cbd060c44c8aadd4e8235ac31291dba4f1a954077435fda3df6021f22e4e34f68d19ab0e1c41247381995ac3aa20016a640fa380452310edc3278503397299b1d43cfa4451f87171a41f8f0f1c709daf5d4db42244f6073bf68a4ff0184f9a5e4d582933e1ac88c6627923d8c233ec5ae72feab46455e5090dcd577802b4eb9ae8986d1794a46b92def078ce3d73434c4efbd54ebd64ba412a9354502de779e2a477d23fb11cf8bab5c5894a552c95e8984661c26b57495a5c6b50a8d664303818df6987d6a23c6adf7862225f9c8d3b8bab42aeeca6eb7d97f7c5a2ba75a191760409b23e2a5ae041012d2a93dd47a3bf91864c761c93a09f418922f92cd5b0671d67ab6a299bac77148c9f07e335ba512be60672772d7e6b5203f32d6145450b74924d0865d7adf81c5b6a8753a89a17693b61506a49044da8c8ba7b518d89e3bd5d9a223fa0052c763ccd95e3c82f1bb8d0c57f81bf560079f5639c8269349c8f3dacead66943b8cbd6df459efe9b4ef14866a748c9c000a7805bc488fb8eb16058aaf16eee54ab3ea4108770d6ce562bba8ed3919fbd0fbeb96e07c46c4a80409def98aa2dcefc8153bdb7113d0a9d1f1243b1b01b6e4a8ab0244a75162959316771b0c7b1842bba531b29b73de617bb01e6b7a4254d78a5f75893eef9300d6a83077f4b1309fecdb88ede2cdec822e91bf0ff8f0172213ed8eea1cea8a14711379b71932387b85e93058d576e7083b639d591e2a3629d32e58821dd720ef180c303ac6b6ee7afb4b9b896c4212584d8865a33d86d9b674d8aa5df0028d5bf599d2e51f5e74c6b98a06a26f1980ec446ef4cbbc7cc15f15cf96bfb38e86d2df3bce28bcb219742308dac77f0c5f23d55c3a8252a1cd8631b9ce1e6ee3adee3d93af46de91daef83e5fa01d9031a4c16339a7f94131d442a7866b483dd81ba0b04f6139eaf2245232b3e37194deda0799fa7d978695dfe5230b03bf9f81a5ff485d34dd59a18b5be5b961ca76584179d997e21388faf6494035ce7f06392e12154370bf67600941e40d6babd30b9543a895d36d0970bdbaed0d77828fc36d1cd5d0ccbf8b9bdf06ea791cf7c91e7e5ddc1a2f511eba4c95b73b1c3790625a3427ce2eadc960a27100b33a8b30f28f697a771fd17e30a4d5cac222803d96f94ab35d22ba0a5c62dc37afca345d66f4f3bf446b729ab72b352214b498ea9475b8814c3c6c02840fc9d02ae2d0c766c4f831d3dbbc3632279e4911263411f72735a6e3891191b69ac87fcbade6cb16dd406ee07fe5864d9e17e4bf79702cf8aa885ed296621302f7f6a32874553c6546b0be1712696294494770fae489c5500195270867134b6921846daeb2be7bbcb6e39bf96d04a49d825304ef51277fe81ebf6e3647230384028add01cc7df6a729ab755bcb59abe84ebbe5f98526105e19d1ecca806fc306145e7713ff0962e1e6ec27d786dfdb1752d1926a6ef181e108e6b0e9b7046dcc8b1b2d15667185e057bb822822e0913b8e9e19e506cdc202c42f69892cdfa0834e60b7c8dc41d450682db03fb6117dcb03cfea5a6f4871b1669b901ab0b7b38eaa94c2afd82cacc92399097ce61e14a994326de7bf8216874491b75197a6eaf9dfb2b45a2f16671a48a6d5ab12758cf76646ffbffa191fa2b54b49acc55d18cc2b4de757427a15b48d9a1cfdeb6edf5ac6af373ae8ca39afd60aebe90d16a3f6db94829bcfac586dc5af6aa4ccd62fa9dd613decf04f497022d8f366c23b1bfa62d3e8aee18485f9de77fcd6847199affc7d61da9e3eb9f11a0a089928881a2b97c3a57022807a7bbe37c8f11c30b9acdef0f409a766c31fc298c6534f638fa69fc40c9cbb9406400457992251d5766d8773f01e14e7f0f319565b1b6c7ba15dd7eccf35a45cd4126817d8e6d5346cc880172dc95098776991dbf76a3e0c50c40fd3a16ac062a5dd7adbb109528406ca40fbc595e244bb4fca66f1a7d42ba130ea58573dcc5a419b23e37db49458b0da86a4e5e9cf6696772df224a63f472b0e2f78169a710b40aaf7861d0da91eb531a86b0cfc835d758b242d23901885895bef4ce352f64e26e5fda4e7daeb41587bb50b0ece1d6731b6e02ee8c6e711e0231d9daf069c0fad3c4860727aedb7c0cf983d7786f3a84a1cca6805453de17dc363e2c8311e4d9fe6fcb93163910682618cc30876cb9e3ee21c416c6da9badc754b46fa3f4816758adf4739dc5240e5b3a42674ed617a17f1fccf8f7027109817e942b1deb0e22c34a7c7723fe068f2b36a5c728e759c830f3147b8e370563d90fddf2b14cc55036669a3f0933cea470ed9725b06e23242daf133b96d9432aa4f3dcc7fcbc8b4f01670358961fcda52d3ad7ec40bee72bfb15220afa626eae4878aed4d47d3893fe0447f4e102631b201823692d38b5ee835317a29e51b444adda372959d25b3052dfc776e51fc650b0b4cedb4f97bf96497f6265c1c059816bffe63a7ef48f211a6732b580ff8c445c1dda1ec5aa1a16e98ae02e1a2a76570bba32904bd989810db7303c6bea6ba6fb323aec4d0a8bcb9030e2b56190bd3d33e191bcbdbabd44012dd58386f30b3cf9852e48637f5570e83b080412bf27ba687319d99b9412b9109b727625ea04a7474761fdad9bb733d476f54e0d6c85104688d999ef936fa802bafd2ba690d684c743abd2d103dd43d3846b796f1fabe17143b193d1d1654f410da876e34ffc4017ea3a37a6cfb2195df34924c6d1de94d9f080e82b52c0fe663f6c0fb812cb5325cebb6984e7db732fa06a806578f8f28b02f5042373188514757ac2028b288a57669bfe3f509ec6a22e4644b9b848abd0f6741d18558cb367644fa8f42a714adb4b247c52fbbc0c00a0e643ce15c3daa51d810910eb7ce26c68ba7c7d0f55c3e0eecddb4329147ed2ce9c0dc12bd4be1b12b68e85e2187b9b35ee23db32410175baad1a1c9df8ad0ea6ee2d5942ba38519be50f441b28d9603a796ae94bfd529fd504967af760e54b5733a596a13de31e1b11c2ad47211b0efb8d0fd217daf85d4b4f688df3d632a843bd198ecb220d5b8a9a0880f1e8f2670c81a73406e81c43a1d20f2adae3763fd2d0788a56f4b28e08b80fb0b08ea226e244bfcfb0859d26a7ea83e8c7769570087072925e1a7d2a680e2ff2224c2fdde6d1852457cee820b900beea4f1041e87ad8804f7ec75e02cab949c7f4a94139da3ac96ed50d6833f705005cbacb5856b1e4fc2797e76019280db822ac5a0555e64e758c1a06dcbb6c03c3fbfd70f28a42fa20d0d5f4a0fcef3b732b85e6763fbf3e61f34cb30b718226e4680be6540424944f2a6c8abefdd7ed534f011d6a7dcb2cfe3de53a62f8e5f81a060cd95cfb725382213a3345c2b4cc6230f4afce3aba6f3b2c39f08533c462a6a246ace1813bb8c08293ee334c76522bd996d500d4a744ad03f42bfd0c3379827a3e880f4bf4f5738199759e9d3107c722c1b6b415467c61b998be5900f0cf9fac81a74428242b82f12bcd35fefcdea34a12ff17c073c30af8685b5584833c6c80ff496a946345119b34c2a43e58b237aba12c1e9739442b72ed6722b049313ad8cae5f005d83bb045e90efd0d7195c8ff9ed78a1e3b7420514baf56b6ef1f22f487654aa2856e045452f86b6028e0a8bdb7174e413076b1489511bdd4eb97e71053e21c9b48f52bd0182975ec3469c05208fb536336fc450bfbbef7caa2f8ae126c4d425579496e9e356ce003eefb03e38bbb8e9de5c600863141b52522778632b63c04dee91eee42ae3fdda629437a3d6d9d086e454f27a346e59b4c4b0445fb889e17488d95fb20de8541f2df7c1d5168807dfe9edc30cef4b341c0e5ff644fcf7f72c418fc9449b63c0b1b426c41b355a325f6bc8f7d97080eae3b18066f4b088e490d434dd4279bc3789e1a2098e40d035cd5105c3f4e5ed572ae695c6534cde621457c896379191828cbb9c3033f27dc03d12aa72fc74b55507f00a3541201ebf1bd46b4b0ce9fa8ea1beb13ca9b9514403dc3c8c6923b795421593d6027a93d67e6e5e82ed1fada68778e01b61a784ac979d5f2f12890430ce9d28ed649ec635f3d48a8fb182eb2d4003b0841621cf95581124b9604be7dfd825b7498d5687e157e619a65b8daa0e020615a9077ba1ad94409e223087fdb0ad73534f7dd1272863ffd4564dddae0c150c8df102334f91eb5128250eb5ae7a89e446803f0d7fded9591925de10fc2eb47afc83672e4bee2feb2b515bb2ee7a10c16220fc1b649ed303c99facf2319caa95b3687f8943b9476ae6ce43a07d63f25a27fcef387ac390156e008a3183a151831a3589a5e6f94139ba52c2e47923799e59b8ca7b2e3808aced0b3700cc62f618d9b5bc1dcc4fecad9f906c73eb15022fa3a86987e2811d6ca28cc256ac65cae28ecd108540a5bdd4adfa4acabbd34346c234b67792d54865db869655a2f1f8270c2ea33747a35d4f633074399182b4d4d5e1868067382fba70ceeb0e5922ec4896c41eb9cc50b3c16ea34d0f4f71c2f754034e366ed12b6b8026305dc8a4ae1f26435a90b9273760f3ba7bc2ad40eaf3ddb98e703c3384b7c092a896cdf729adc25f5e4775102ba303ef5b76b4f919d59981af49328e31142af311f1a7260083f5404199de7152367adf2109a46e6fda9b8f244fa21dea20815f561ea08f53de906114ebc4c8f9bbbe774061223e374376db3de0e02378ae104a0cf48cacfc868742b6997af8f5d84bab872ab3b4aed203606021c5829fd58cf060d9b02d4ec49bb2da6b54a382ee0f6b757baaa264ea5734a8c15426aa0c17189641e5fbc26bb205804373d0d11134bf1668e76470298d6ad8469cfae5cd1efb75de58b03f92298d7266aa3d760ac56af218fdb73aaa7860c4738c35146c061d2787c8f53d27581ba9fe471c434a540b1c44e7a3a7ee5d08b48fe19f6c94cb78c8bb6f72c6d5c306c5d3e985b2af52398b652ed6b1b6ab5cf3ce265b5336a090e55a241a2b1558bb9352fe664fac432af60b9c1bd695e253c0577ee90198222ea046657ac892367be3c516118474cbdb5f62e04337baddc2fdd1f5e008dbaf748bb1bf7e75123d7faa1f08ed887e73cbd00e690693f72cbc62d1d41e9b1c353ddc004048a4ea1599314f39395adeb86c6c06d1149ca9d1dbbd3579c3cd857712cb7c2e7499030e04e1f6b0b57c1603bb46100125b106d1cbf00623f6b91ca0feb6e186597b318062b8704737056da8d7d84f66fd259f978efde388ff6927c51e7c5da0359fb9d6c87f3cb4a4c3640d8d18342ae7324b42eae6257b6db7272700862ce42f565c5afbd88d71c0093295aae23d4225936bf698017c8d0d9ebd9419a7b7df76e08efa4ab3f327fb8c6a722edad9a5d4a766ac06da1c0e297ebf52f5ec32dd2dd258a8b45d75846a0f85eb664cb9f9b0fc5e2ff571a633baf8f7ad53194c393a3d55d98bf85289e6d5a1236799f26c606e20f8e8a253cc94a5cbcfee208edd2dc5a44868924c0e4459c37474f7513fc4214801895b7d49f9c6b3a36b28ca76f13a900ad0ec819d014df1e3cdae9806e2c669d62b382451ab2e7ebfdb94f5e3a6a9c0b02fbbf88a92fd8e718fa72c94e9072bbf9b22e12141998c999b17b2cf302af68484b57eaa4e23f8122517562f545c07933106eec552eefcc58dfe6382be14d1640d5b7241dfc724c938a7ef48456e8a05eaea88a58aed48b80bada86261c8b74a088f6f40b5250a910b1a7f3c39de31effad4b94f4bbeb0edab7c433f9d51e25d99db341934a4e18ca7b9df35205049b8059a45bb010c894e0f5bbf71442bf6011a15eb53e5a3b5ab3077d56b3ff2ba14eddca3baeaf02ea42eb8d0c07a53ad3e0155f2a96145b82a4a230a96dd433572ef16766dae4e8a05a3d134a9a4df9dfa6f36057c48b317209e7621d4c3268ae34990dfb7c01544251e416b769c09532a1dc436745b42b295e8036198c6eef591af2b1798e574ba47f9f98e5c398eb6c50fe9c92f73623fe2a932cbc5d08d54eb7bd9d841c6fd81d3004397c9e2d7117fc2d026f0a53c2f7b2e721b405b320a4bd1e10b9eae67f34ef70888869bcfc45b5ff76e394562cad22625bea2dbb3dc25f19efe01fc9ed1f704048c6037febfaa152b820a380d8c3f509f51d417586e9bdf569b4e13fbf363cceaa33832ad75621b82d076cc80fa716e7f96e6721baa91c132cf8b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
