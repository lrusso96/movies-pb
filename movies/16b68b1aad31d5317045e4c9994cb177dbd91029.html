<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"aaee317f1c6f9adc0aa7b5c0ea88700ca757ef90a83980d05809cd05fc25edec65427caa8ebf45cd3933342ae2da1c5281f8ce70721d9969bed86d2cc46624194ac085e0591be87607b32c7255b960ae3f399f3fde333091990390458f1aa36f29aadded84e4a0b25e5f65c2757271fc96b4fcf364b9e69bf5b7a56b15d91ddfd3149bf2ef378fbae4dc4e3c10ba24ad6bf30eea74d245ed62c6e04d00b162c10d33fe55c2d9ceb8378853c45d81bb73662bc79025b5f2c70c4270cb93c5f5a21798364fbc22f1c76b9e59041dc9d8d3bef1e585e5d2a587a628c624a7c1d9db1bc8da00d0e61093b89f679513a70d0970383fb011f23afe32d67149c03bfcd17f2c0f7e5a6c2ffcbd356b1febc96c3cd05f776dbecb43c2b37004fc36b5ef26d8aade6f5625219db17164ddd33badcac586d0523772b74ba73a99188cfc16a9c8f88695f19f844203db8f6b84a40f63f25f27999245b342ebe2f1343e1cb5cfed82041aad40ae6f8baf043bb9529c81d6b6d2846408f54ce7424d3b7a26b0c17ce29c27a26baba129121e228e0643f4bac02763c0c03309c0c0570c490c2a04189d85133407dbf0651f7a2edf5d5c96071af350552a455ee88599ebf48f3e3d9a44b2e3f0b2982297b21873c83af19e607fb27f32dd71a5f43e79004dc8c249a43ddda686b84330d3bbab6daf37ee95bf5bcf0a9cc7be04ec69b31baf765c603cfecefd21e60e9877b25e9e62ab47b7c82086814f3b36ae000ac8e98e6746ad604bf1d41935e24991a3005ec55bafd78ebbe1dc656ab9edf397d9a8ecc4569bb2423b724532cbaa7821f52bd017b26d80e233ad48362a07069372df9a8f7640db6a5ae6ce2a52643a3340198a9aa8cf0c6227e1888c16dc6b697dd1d587dc8c5691e8d2210ae523489b04291fa9e5bff419110b6abefdecbea3dfc2760e765cf090c80bdf8299cd06980a5c78db6a1a9f491047550377eeb24fbdcfbf16307b67781b87a1c72950cac90730e3fd51e0585af8b8168c29c3e1baca671f2a413437d08442face0daa88c8ffd9ff1ba7ead88aed8f6f48297e6a9ae3e96ee668a8b1a62edbd871629f135090a0309f905d93cd4d0c50cb58f91fe08d51f09108c1698582b375e2c5b2978eef974e07a20b02e3ba5aeb801e2f9ddd56f78a7369a8fe50edf4a67cb9611661a3126d4d13e5a5baf685a02a40e24a2785d9e0a1e1a6cec1af873ef1caf4725fa3210e7cacc29fc6c6383b934382a42a60dbb27f8932c4f64d50573cdbd35234d450ae7ad526e9874b01cbc583acf38a4e86cbd4f1d0133d8ade029725b3154172e185d2f36f83691595d977cb1df2fa7e9b3630ba9f94425c7bf6da4ba42be4ac79ff2de0551214545bf4a796afb92825ae08eddeacc98ca307a3abd97ac5ed78cb758b8f27da1e559be29ae7db390c40c73c47e6655555bb2d6e7b172e4440fb80ba2498b42636cd554548ade350f0fd03617ac1197fec1017366734c2ecfabf71364fddaec8a7ce837bf1d48e18fa05bf6b44a22dc6cafbdc8d691cb42bd22c3a29156a07af535db0341ce7e3be10aa8fbdb4b7e8d74f309168c594da277395ecc961df192710ff8973fb9a53d54afc2135e42809d1f958a23f8a5882d76029737fcf02dc6e0af0350d8cd956cf260065b97ddc61a9d8ed5b9cca66d13b086ed50e650bd9ac16c1ae7df0afb4cb31e2d6e394aadf530991cd575855101fc996b351afd2ecb0705bc3512aff6171555b3c30a16e202ffe587a1490f553502bd4e56640aaa51a33e92d7a25d36cae40f7d55b16306028a5c07b94c422ef336da1531c46bca74f19d891e57359e7076d9ec69d7474a7ff2fabfe4023d934c84c41bcc0454e732c784edeecaca99c566d71457e97b063c8114f7d3ad1883878c58525e09a559cffcbd760de16f5bceff652bf866041362902fa77c5b8e90c7a2a1cfe9fcb0761ea06a63596dfbf92a1f48c096013474c075fdf2ba92c92f078cb835676b72e517e07cba9e34751e1aacaab5dc48fbb3e0e63fad9816a66fed7acd777bd0673264be75ce10cb597d2661b38aaaedc9f036c8ed5e11d319dd0ef5719dcc92a7b53ec4e38b69f396249655114e09021bd319759ad3a67fce63a8ec5f3acaec8163469d1342061dab05ee03ad9028d0e15e78e278a8fce3c4628475c8b2043803544dc88322091b137c3eae385a7e9d84eae461f20bb6c6f603c110eee99395dd5a25cb82b576a8a5e3f1c258236a0e39f88ac16ad4a89403c0e45f5161ca3f6343872e27f562828cab167bfc96f5581088e4b2c785dde52cb7ce9062f800d9dc1736f0813790c8f78f32a3309047aafbba32e859f38b220a8e0697a5d2982fe500490b0cfc6126e56f0f866df7796c334f3722f042e84069861323d3eeef4955bab43114029caa71a24e8dba563243886ceaef83cf701b7005e5e3a29a0fcc0c0cad4f916af9bc34752bac8d13911edf8d41d8a30a00a4d8e1d5bcd598b5edae51c32e585c9660f54abaaafd76157d289619b8eb7acaefae8666510cefc7d9a480aa56057bfdb9de2242aef93e48f3afd99d5deafef9971cc0b39f7ff1a7cea79d2a579d031335ae3be98f3ae8be61974456157bb963ec95a31e8f2ce710707beba719d2329e94326ddc3c536c137c215c46c26f228c46708d0945463b38e13d701a432f7ba79aef8081989c50af7b1dcb11adc895a9affdae3b9c80f262970300fb46bdc493dc14288d2d90cdd4e6a1677595386ae40e51b557ae2909ab0ca3866674731cd85499bdb36ef7631c8c8e50c99df88635aaac1c4e46ca7243ccd4572eea91be8aa9cc489bb6b705e34be6278770911e2847c6829602bbae428da672f8b124a1a947fe235c767e65c216834b20e542208337fba1867458eb142d49bdaa370992beebb83a12780326b5081f43d8cdcf3d62aa81e5ac1072ee196cc2bc5d3bb9e5df7252eafd911c1d54d71e4f87871804021272900a82afbc60716bdaf92d65e15104ade4de3ac25626f3aada835d1e500a31599e38f2c23be5a05febb7f34d87b9c3daaa13685a12a4ffcad625639dddd6cf0370bf6a2816f45ded5e0fe9415c8af8a82a66e48217b1e27b0984a825298d44a9c26f6a5a519209e9d448ab021c114b50ae2bc98dff80e04ab63e78e6dc1348306c9ef302a9a572e4e722e8d33a6369228aba6b51c28bd15daada1238b6b890e40c6466e9ed063963b6231c90bd514f60332d4f1cc0b4534aa0ca8d691941cc85104831018a020d62b921bc872b3cfebcd800a8d029b44a8923c95bdb0de7429a4dc42ec4994d2793135798e854f4717d5351d1e70647369410afec14e786a0ee96edecf67ce87aed8fb982856db58295f86de6bc54eef40722088776e26911894454dc75f4f97038b33dae4cf7742d2ded3a57065441bd100a6adef0fef374425571059600b2bcf4ae75dd0322f4522bebfadab215732747d558f9ba5e7c633ec4e752a8cb8f5bbb8ee5d24a54f482a6a11a85f3e95b34f798b037b37cede1ccdcb61d90cff587475c90841a3184a07543c1f4c393c2d5f180bef191c64256b4941d9991eac41d48682fdd0b3c0dbb6636e85034df4c82da8b6d50c172ce5198d4daaa05d9658bcdaca718d5456cc3ec9005addce7e27406390dc75643fba55f0eea6728cfdcefbaf3e2f02444d59e729c6cca0fd111813c754593b729b3e1180c445d792bb132c7fbdc6396ea00a9762fbce7da961f2433324fd8d1ad679fbe0d8b212d63e29e50df7af7fda1f2566fe8d69f224bde7a5c5da8cc6703409dbcbac1b745e1fe7db8dc09d0b4a6f931300d49d467d03f72bb6e6be8725c86d15f069c9e79eb7c18ab807db8cc9aa306796f8518a226154143e20dfd0803e879f419da496e8c86c2a10e566542b3e964bcc6367551870629d2ecafe7139a0839bc02826a23cf54a73a425d9695289c34f566607785df429794e599380f3bd6339592b571583c865f8555389a198170e0186d4f4b523311aa305ad028822723e802c4c66caf49bb6e47a4d079c364746483965002f3fa99e4ee69ad97ecc8fa5484f85a2f9e66b614f218b00c40ed6af7f2ce5d48864ccbb723f2e95d1c4a7ef0af4310d26c9a0e2abfe889e3d66a57530d66993ef5fa90e8aeb56565bae667e2c326de8aaddf70d9eea062f959e4ab4b0be60a318ee5dfecb70ccfce4818499a0f7bde332d43470b836ca911c1d68e0591fad916be0a9390326493d189f35e3f5184d5d571d73fc0d7567538e2e567ce6c1e5bac196c6146fca9da1fa0df1eaebf8f020b46da4673fd0c36b875ad4087597c65ea6738a944569a06d58d26ec314e592f35b54c1333c2deecd63fb5dccd3e5b02400badfaa6a95197eee988dfdc9e5228f164f162589677f80b120d5eefcc5b926b3b500f511c89065f06950d783c4f91d2040b4b49e7e5edc90ff0d5e4259a03bd830896548b08448b437e6eb11cecc7c1184f22bc980a0288ba500623423c786faa785cc8a8c3a0d3af06c8fdb9593f463a89922efb803031f7f0cc1dca063e6516c14e8343c1183d4bc136a5f05554967489046da49ce4501a11eabbc7424384dd0ff19324c50231cf8ac0e07c50c663b674e11211d7b511fc88aa7ca8735025ead62ad255a61cee7e8b477c08a3da095d7b4de1cfe40a253624e9661a3a75d04fa2e4fa4758e0efa0ae881a7f4bb94c96ee0089bea0b79dfe1b0d3acf0b2d864787793cc6d8cf74eff78ca7cd0708a468c5bb351a097b4def6aac7fe7773cd89accb5baa934cbc29530b529f2be7564946bbd28443d1c687544b1387d69a21ac2b7ac06f8e82d7d8d5c80f860971ea4be3b62cd010b48a5960645cfa29a4e63ee4032f82c93c458a14374905d517a905e0c3c0230636856d797750bade322b5d588a80c5d5c46f867fda027751f9628d589ad50116edb2293e1ce8f89f4cf789acc9a2825f79bdae60be8eaac198c11d0eb34ab075e7a5cb90e6c50deb6e031de14a195f6e2f5c55ea931bd598bbc274efb5c66f41f41a0ae09f14dad9b6808c679568b6359e8356367f65c1b87362e1f471822147efdff5b4b81372b555883e0e2038f7abd0e968f70a9abc33d8bc4ff48776ac7fbcf7dc51b3fd3643fc393764b43a5bf127ee04e7b3cf95ba838e5e12ce29d255432c78beedb10cd184011e6b17fd79418cf1ee5c825f6c57bba8c779bbf8b9b9cf0bef4de7f9eec014896ac4869f3f5e5d8ca7f4ce3614b4dab36c56374e9408f2dbcd4b22e5ffa515b02294c36c81ef28ff21cf55912e3cd2f0a009223af39e9f37857c342204056f08f399cdc74c3222de6069bdee4e0637fb37fc33bb298661f6ae9ee6060b431a43bc40b9eff12fb034c5a254a1fbbc3b3da3ec490d32a41f5965b1a15c530b6e0fcbcd1783e1f5af92c86d140e7f075695d4360cb6fb33e2edb6dc8f236c74b6a11009923866690fc42a4ffb16b31be7d180036b34d7ad36c4f3bf43ae6faeb0d289f80528b20aa3e5f5e866066057caf252cee24d6f7f8fcf7a64b442c457aaa09e1e0adb31a7e85231faed076ea8b4c06c75bfdb36b1b50701edf08f59051d152c8e14392ce98dabb16afa27c9f8cb833c59f78a8f51d1bf4d8e8c88cc16326681bfe62f99bb455d224f0ce001efb553368c98fa0a413a01dd5703d07090cda042bd7690ee5a9e017a5eaa42bd8d4b54ef97c82675f0157dab4f45209d32493bd9202805325e3afc30222ab33bf927f34b19cb3ee8e28facff5a3d3fd90452309fb8aae9469ca82a50cc5daa08ebf8ef3d23797077d85468ea181c2ef6ef920058f0670316c3d4c69bc37c0bd37af49a7274107f4e15a06baafb6ac17e8c7dffd56d7ab4e92c196a2e2649446799f30395dee6ddaa795d6364cc518b7a7acdfc09ac1f3c9be2abfa1c2480423c0411d01bc50062becc048736ca581ac25df51d95a7be06e72fc5541d073dc29eae227ed29d531e3d17bec10b5080cf28ab2387d2a151b38a4ea0ca72740fc1c7f803f1d46f81df0175729cf1fdef24fd56bf6076aac7a09f4ac0fd4bae2938e6a0b444929fd3082f46304ee208426479cf98f49bb1b147cc9c0abee10d38f65f2f02b4eb6bc0cd49317548e5ad7da876b52724763d055bb0d707d8568bd529e1d4f2c4edb50370d9aba8fe4428a213405269ffc050e90858389d24a105191c10bae8f83dcb5c983a7da08334fcdd796777281367063750ac80bc84eebcdcb9309b623be4e4f69e82982dc9f848bec3305e59cb314323939862a5a2dc4345a9892f17b13a620eab9572944abac6648b4578a0e9f1018bb9a0f11b1fbe2c09384241e5bb1cd59f4f1720221b4c44a5133a30d36c0038ba56d96d762ab12dae2147369ac5a22e1e5081ca89ed67e471194d176ae7a1b726712d01bbdac40e02560ea9d20f40060ece39d6bc6aa5b0c64a68d1600633ac891e5e3a6b1835c491e93e89f192b9a6c808006cc0cfdfe5c21d892718cfe2ec19d220cde68f867543470ca2a5a676562aeab2cfe6a67366bf28b89ebc32f4b8aab2c740bdd1fa40b43d11f6436bbc7610156dfcfa0f449e330c4b2bb358054f252c949415195ea3bb3c0ba5be38cb63bbd12ae23df94ee5e17dd0768168f667e5271d81c78e23260ce869911dee4a2b28c09c2c97f2366f51066598b82c4e952bdcef9b2388aa0b502c683ad2d12c008571023115fb17eb6dcd7a8b7931cbe6e7e8a328cd93ede0c2b5f580a44339cbfc433cd57f33e898a44ed7576ea2c3d2d1fd82948e325bd9bc2a5ff09884bf2f2b96ccc67f071825b8903561108a9a297eb6b1cee5430ffd95ab34406d570042af85dc0882da18a5d75fd97a9483a037e02c55b3da2b25b8035b9b088c7bebe6d67a0f6c81a8881521af0c1d804375e0233049a87b9380859f1f653513d0ef59609fc294b865ee955ce09299f2a1355808156e7b3aebdd08852d7276793bc82166d5c89d5748aab7057a150f396fa5d5ad8f96640da50c1524fbae7c27255e5285f3676ec8c391799358ebe269eebaa95179ba8dec997dea78d08134fcf2dafd931d0da727cee5242116e4d43560dfc1764343f4cf99e824ab507084e1d1e6af39d174ba73ac6363b2906cf0e0faf45145f54710f204f5e18415cc3faed0713dcad1f9cdeab80ade5f1ed2c83e5073d1ef290b707d3df209d83d65b0e5df5cfb88d852984b7d80c4b698fd16e4654b7f9f6c75ca7ea1e64b540ec4ac9bf5455b54fc134f5a2dd29eef95c8501c12a43a51b4c6e4da3ebba94d66a8377901f3c04fde30dd4e29686c83f035275d8ea170d88fad4b716d3211f151a2297cb6e20fe8baf040c2274c0c85c6b2cbcfa078933806d98054eb8065243966c517e45e5a7d37b4679bba3cc5cb847ef34015d837158e20aacac14da13e565a3ae7d2338367e8ed077fbd10fc185ada02913e9fa0d43ed1275cbaa5df6a590ccb878f33da1bfa45d871f6bd4f47b0c0c5279ef2b89818d90cd862881add31dcf3d60b866fb5ae24a413434ae186fc007b03f8f3ad3c74e85f01992eab66c83bd7e204222708b0ad6eb0dcd1326964031cd6d61d120e66f6f5b184f11b4ec5171a2580cf4fd2fab4c4ee42de05ce096c7a79efcf7ab81635f50d289c5a77f55651cf9d41ee7d131d689e8e499af530e0bad81dd4b964eeeb9164d6bb1c1fe23f7ef12a8d2da0de31b1910de968389a7ce3641f335d47e89c71be6007ef7bb84dbd594571a86f1d01e2a7f4f4142e6fc8b15b5ad65a102bb83601cba53bd396c3bcc18ecf980ada9e1c71f610a09f3fb7b8f4260142f54dfb44240512d342530d706737ff925cbf282b00dd4265a1eb51362dfbec357f1c22c2817e073aa36d7839461393a9b113c2688d8e64d540a2674754fae703b6cf5f9a8da3aa895c3707e2faedb6ed0898bc5950b53bca5e6df3e304ee904da7cb2e965656e3221ff7157d2e896c3707f029b2396a89e93c0314adbed5eaa3f63cabc70d31eb5fa084974561024a0b0cc7863f814f696a4d73019808545f345d4563dce9a0293ed137444115327695c78aade7a3aa933b82c360ff6797ef51f995416e2ef86f62893b0143ca1003d28a1ece3f10540b16aabfd8758e5305c2fe9eda91bdf4e9e967ac2d2d5e005e2bb55321b0203b561a0569736df42e220413d8c1e01b4484c9610c2e2d0c02f4b900046389036237e8a01d471e29a60b79fa1f20e48b3ca52f6586b50182a3274eccf388decf848fece1f986b712fbd7703f1a909139ef800c64836d8add33002a7ae77bc0f150eec260398a07bcae72504286b2ae0074af6f93bb3e1edb438fd8bcbaf2a920fc27603d5358903c3fa7ff66494f10ab1701bd9d431c8954229b4d5671f23edfb6a4bc91916a51833c3fd9bf9338ae56c715e03f03bc14c5aab75b196a620afcf06a4e36500d2d57b4e867e47adc71bac28aed4f3e9ed08698c944ccea92da1a2b631d26f4eb37b0997269b59590c1e0a15dbc8eec66b620fd521a3f047100d89aac7e810888be80d84cf669e70da16375f921a9ecd66c5fc3b6d72f6d7a7a6f59afcceecc05300f58f235bb4d653b703c626dc5f17666200251ddcf8347d290a4fd673a58fe04f429362e380f465dd3d3384ea67e387d8bcce2ceec7402fd2f7ef9b2b91de991ab5c2889548a2553678529beb1acde7317887157ae2f93a1d8347bcfa27e4c81af83f8f1729fdf3fc9ccd29fdc2a1e65098b4a746c993c59bc68fa4fc61b79de3aa864f49e398d845e5eb057e16381538d9b97151b7af29420a2114d75c8c60001f94acb2fbf52413f1822552be9b04eff17c4c687c50f31ab3ddb007fe2948a3c64465c52581f5f0b35995f8db771b608d121ec1a3077b9a2396f82d0280d54a306bb66740f912b3aeb951a0c445f9d928f5498c088ffcc7d96b104166293705722192cbe14e4d565155e0c59871959f4f6740ff6f6fdc0765b0d1564241279cf44b66115e341f9417fc7c47ac1e00403f6a7aabf3f2d926f33f21f6a88a93042d8d4af34ea3712dbb090f5bc1e2350b7a0414612201a41de7467035a47e3d1971b0decf5f15f502047598b2c8036c6d274f373267d23d9e75c814fbfcb734d61c47c9d3c04c2327f96bebc759a4ff738dc46d0a2f90bff5be2a486d82fc0b3996bbf49de1b52254624604fc9fdb979c8d9b6ee72299f44c6ad3a8af7edcf36a13cfd45d7bae96f89bbff2f14c731588ccfe0ac6d127ca587413066e2eeb54340c4f14d02194676a2a46886f79276e38769c80f28cd8841e6c8599e60d12e1babd7a51cdd93cff6ce5d7a88ae346e806c038080f7e09c804bf546792e931138372bb90be60d2d84f9b6844d52fd317ab7d18a2dc873b3f7b06083c2ef74370fb3aa5b56af6872b38bcedfc5aeb76c39d5b107f0e8c33b60bd12dbd2069748f850a39ca21326a65c53a3c3120a3dadac1f111e225614f42b5c8c4e4296ab3ad670d9bee06de7d21933a95931c22cdf8f24823291f53e95ab8678e677f72f881067b960978ddab8e9283f2b47fb2ea2428c26f742449ada62a09ae1cd02f048f4d770b591530458c6006938e4aaa493f22bec1e708d856bc4ee226a73c9e853d304ea457deb9728ad367c09eb4fe93010778e7372ef3a759dd9cae3d040cf37a5cb869706a5f5db14564a300b4065809f3dad5adfc2c92044f9b9799870c4ccdb228fc998b5d4fc48b5733ff919b2b5633642e0e18f1d7066f77eab93b3e58ac5e2a346acfbef8a38dd1f3d56fcfca2f62b9bbc93651d176a64082119bd7aa7115be4c7ca7fa73fc63306f89f83ba3fd94ff3b051a19a3961d5b6cf1d864836fbe643359fdb388bd70080315de69700a98a8128869d667eeb0b0562a7bf152febcae303a6f4a89c2bff00a32ffcdc1bda7d9263f16766715b08851b6240bf6c398aacf407da845eac4282e7aa08af73841213b94cd50030b37daeb25d4d325ae59f0264edfa4744b2d14b7e66b24d7fd0091ed3012089ea74429a4e273114d04ad45b0be8a9cbcade2684181459c745f3342f90f760f29fa618aa505951ddcffd29f627b0254925585bae3e0f11f25fa35e72cfed2c1d32ada665122e711735553bee5deeff0520b8dc31b7cbeabfc3455f19a251fa93f385cf4e79f9d1c8107abddf64bef48db4169bf135d05a95dcf36f8be82b3c2d3c2d9f3dab766d9a28472aabc566b7824892348550f66b7e03e47d9478b99eba1755a08ea2d4b16306255bf45fd392fba774a24deae550e233f04aef0d1a09b615cd09affa417444bb8c291b044179b5a571de65c369ac4654c39e43865cb48b12dc4a530edb0f926709c466c54bcca123710cf84c6c620f71905a35d8c71cf772e87b98f81ef05af7719132c4611bd7512427bed73b7cddc82424bf2a6d89118b6bcf653f3776ce08ed755502e13c06f891f608a9e03191beb24c33746b0b28216010838b55351eea69b4c57c9824fe279384e3a9b02aadfaf5fb450e73d1e039d783e857aba4a1a0ebd30500311e7d38ca6aaa0b68e940b91cb625687ffe62f39f09fc5076645d552ab7cc15dea8207088ce94c21847bffbb8806b277010b61f748bbb0508e7b518e8f427780b34c91f575f76ad106492e2119f69ccad48423441162a6cda42381350bc0031fdeb807bfe85c52ca82339f5f20d22a917babc97a245a79519f150ac3a5b8495b5ce89bbeed5f4aec79a60f29209b720b6e3c6a9710092e0ba074cac3abcb8ae598763cd8e5d83437b6cb4922ff0b3c3706b421aab77782c0af5b59d5e9232d541f9129c81cd36abb32b696b4a83d7dffaa1846f53eb12af7142721eb23a41475fd2ee17d1340f43cdb73bad81540a77b5000a3e22094681332e7c037986fef4f6010e1548b69c35f0dc13b4ebc14ee4a520ce5db76728362468ea6f5a3740e4a509ee43d11c191da88ecdb6f022b1d896ada1d193a6f8bc86379cd9d2ae0fd16c6c4bcb6c5e7c429b9a0002dcda377150474fcc45d353177c7a8120c496a7bae1c3b855a285bbc53bcbd2ab576a6bffaa4e97ac21019bffc10b4a2aa1f9540ae03c0e4023f4d5510dee533f3537fda37cda043d8c99c68c8015f33cb707564220e72db71099a0978e355a123917828604a7f3fec57f7039209fc237365a73c181ed2a558691cc8fc39c3f97e8baec0e2c0ef4d49f4e3c13714f1b68f340bafb90c502bef9e2770a509a02af74eb312fc7ecd52999eee3352693657c2f3b83565a7ef99beb0d85ed954a1535852edd89e8bd1a72fec3a1b0a3741eaa519c8210a930b7626fd37eaeb32c9f03f40cdd84fe959b018495fb9fa1b845b29e33df85c2bdfc3b1e5d8e7726dafe10c617ad5e28ca662734f2157e962f6104dc075dbb536bcf3ade0d34cd8e2e4ec2af01a69d4aa8ae56887d92aa970204b9ec49b9ac910349941a7cf746e34c9ac9a3b760ac473c685dc2c113416a8984259391b001753ae12c0888ad590f25436d0716447ab7bea5fa26a4231138113a5eb704d5e2ab27e6ffdb7ad61bfec1b2b4b167c51c3444dcdfd676e89c1468363a2038881a01c7cf392ba624a0e262a8511662dbd98f93df8f6865afc99b5a62b767c3f6f86bca6c358f78b6bf4412ef85d0f696e827d17ecd973a95c8182e90c6991aab070cda50ee993c4fd3fa97e09839d0124e9d5fd23f6d9d8b5d004e45d1490e510003b5069df1269b8eff9049fe21a1b058a256b29b65e31f64fbe8eab5f83da39697134f38e0122ad0c9dbb177f13ccd6ec93167fe8f697b57f27106e871a40f8a1c20beb2ed9613eed2e380ecd7470a462be9a344104ad8f58a1a0e110793220af374f8535a8dd9d5e91dfed9d3d52213fb48675e45225c00f9f8d1a85ec9f02266cbb3731aedc1c491f00e0cb8ed3ec209ee1450690d9ed4ca1b2e8c6bca01b8e03d3dd67777903f2049f1640e30ceb3c4f73b1eab56db559b0e712e345304bd2bd8623651a258d44ab7b563aee60f994b9f093fc71b418e9efe90e89489a6363545ef406a7e1421bb9bdba2c25146a993432942167719af35cc1bedf4ad14dcd71e0790e1f61c524ca52fd2c0e670a50f56e59a14c2b6c8998a4ef74233b825b1fbb3c4dbbb06c04cc1b1ed37f3041c7dae32f12e1739e94adcf0422769d6853f1755794a0f9278edb354219acfab5e367bb30827b16b0b8a8aa6d073acb9e5ebe1ca0fc160a1ba3d1054c898a2d34994cc8961522badc35274c54cc69c74e07821d68717ec9d10bec5d4757784cbb534643ec07be1f615cefe7fabffc95261e096a0c924900a9f7846d984bfc88c6b9dbfc6468c5b749fbec3e5d8727cf98e91899e1452034d94b5de59e42c9940ddeba7015699e23019109cdb9363f2e0cda90716d4dbdd256d23b4a85397c109d7a198e5fec1e09adb6305df2108814139e3803c3781bb283b12cb550e693eb694f515496c4478a59f7f3eb92d8c98ccbc8093e30b1bcf3e5a8b9184f4c307eaa6100aedc5dff6941220328e019f987cff018cb736d048b5b59f60eda2f8743a646e0c609d2f1093d80747137b0bc54437739117cf865ec69a7b0c937b0071a1d19ae1b43fe3315382f3093284deba54114297cccd4fc0ac89243fdd7cd7f1b32fbc42d595a43c2c99542465e215f820b7acc4d142be46f7de906f52be79e48f64c7b0cc717791e99c12a16edae8a05ba87ab3e5d723752e28046d48db1136cdafa7cbf2e988972ec588f39ec339b5a8bc3e8ab662dc70d60ab95607917a22dca4c29f68f25dec2a2bb8cc447e7a559696bc030b9136971579819f22d4197ad22645e484377772dce778260a6a59524f3ea727f3c6f615df0d70e8811800e81c2a24720a4027ca5230f5fbef9fbebecd742c535048ce44eba93d15d2955e109d9b82021e8d08f00f4ab2f5722f9d4fce6e605f3e984918","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
