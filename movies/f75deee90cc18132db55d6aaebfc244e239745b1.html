<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"082c68f892826a2c3d903aa94a9f54f7c4970950fde510e00df3622fc684d46e76a6dd733294c0ebdf2dd484b793bea2f99a3fa824b3dd4a41e15609eb7962c88b0833e003a0626c634a90b8700347a0b4588bb35dcf8d5573deca02d96dac19dcf1201bf9344efc2d822d82dafe12a934bd9376775b730f321fb37eb5b4b145d2a8a6297548bee51faa2dd5c8a2026084344fcbfbc674327a08a9c58726fc1705296904b5eae39e5799601194aa7ed3a5667d1eca14c37f1e2b264aa49cc7a4bf74abcbabb61e6cf9e6d14a5c89a9bd497292f043d60f9a22801e511e99567d5a503056b19e70a7263eb154ade2feee2262a9522c913729aa6fdcf81d478c1a5af68c1e737e8e13e92ceac4c4d004b902984687ecd78521fb55201bd2691439ae599fbeed4de1f300125927f1466e7d148d22a479831197a8ec398a9961ce9afa39b0e0cab745933b381c9fb81f09e9b610b8675f4de34d2ec681855d04e82af359bf89bb4834863a484a28623f211501b2e93348dee9d4c9a20f124849a8bbe646c0c7efa315c0f35822015b91e42c87953d1c310c529621439f95acdcef88bd96d70056b7d4c8c1c2a3728b4385a52e670637b603074946c809c6353bd076003b1fb1fd924ce14f0c82774f032c3b665f7d18694a8e7389ab36cc6613572c308e39d8463c5326928be6755c1c1318728f904d91a48dcccb00562f584889367d9be545648f183d943204d663ea559eac9af56a1caa027f006e343736593fe135bc785b60adb6fa10fa97388f3325a3d4ccbc62a0f012983e7746c0f911aa946e6dc2bea067edef9f656e725955ced0cc149b73183ff0f46dbc28b757272beba7493785734ac22ee3628ee96fc0c89d0098ba36defb85093d4dc1eb36671c5683c74d2a74e34d908cfb0a54ed9f785b250fc42891a7e087e03db48b2eb76cfdcbd36a578977e032fac87d8fd33380a30717848bd07ae8610e9f35cb5ee1d7fd75da131432134ab16467b3d7cd8370c214b346ff16962a2d7c19b8606f4100612cff00f81846b1c7d1c7d2164ccfccb3be17de8c61474bea8488b98cd680f03bf4f67d7cf02e2494d7b1271b5ac7de0e6d56ca4235cde9c854574850ef33531c3c21963d158ee28abe1eb2e03103262c584f8ef0619333719467e5c604295102e5ee856dcd8670f197b1e8ce6a2c18dbeb5571be58b7e4618206168deea3306cc680490d532c0041ab8a6bf2aabca91d6133ac19d7840245517d15a3fc9bb60e9b4e670aaa536ca7e0ad7184798049cee2a0fcbd3adb8107f22650a2d5a412f51ee49f82dbcc0d67ae5fa48478deb8f11ce2c84f04f66020e69cd7b1d2863ea80c0d98adb1d53b6773fcc3ffb1840249f5522c3792173256cab1cfec470ea4c45e45c14b0182b77a91810d81065cfd8b15b8037b88867c14f84a7defaf926f8b17421c9cb11e3b8d5c3936afedbed4fa884e0f1daa3d8fb739346a7d04e4dfd39a5c79851c945467604ed48b445db4d65f8db072625aabb49d4364b61f4e3cae85be40fbb16ecb42096ef3fc2dedacb6c8bc5c96749e470d7d9e79eb0338ac4bd20ab77a48cf88cdb9f8af8171c0d049dc712d520d1f6f37991ba569ab0a67f2679003ad8b523a50a584c5bde3c346f2ed1a40e4ca013c13da1af818e74db323c84a082c50722fd6b3d7e4e2cc099f2ad58b3e001fecf85c727c2d20de7d01f22f909702493af4a569ce5bb1764944a65fb7a118599bf89f3b60e2d2f2137302c651e28a01afd1289f435914d5e4dd39c808ab3766c782682e98a3aa04ac0f0ffb4e3d4653126e966832a358292e66ab7d855e1af949591564a3fc400554771699139a1c2d34a93fe468fe21e71fb203c5900827772f1f90bfcc0f478b8971dd703242cbe38e78052ec62b08888d3d208543e1cafc0c00f6cd54255d23566811340d9ea611eb4dcf4b3a942aa80aca8cd474a8e676fd9e8472b7750942f9c171ca35b188189672607a1c26ff0b594517b827eba0da37b015c92f26edc6e9758fa4bb1da3955c9287168dfbd23e76523194b377cb5b809040d9dd423abf60032f7b40d4ad0a5f042b9a0f846f7ffd4ca377819c83bc1ad04e52f1a9966003e9eaced6fff11b1f3a4c6fa0be76a168b5a2fd1b6369c3e6a24aef87169d13fb8101f2fe40171b5860b9b59082ddd2b5da57751e122730cc3d8228e9bc1d6c3032c4d382bfae05da9c53ddc04fd17a4fb51b196ebc58092dd6b107ba8a9d1624cae9045120e24bdbf3536a113a1ae5ba81a2f97c591ef1b1019eea8888f4017c21367c9f7da93952bdd6ae877e855e768ac8f5c47ccb28ed83d7b73d918b2c35e1c4242181e606deda9b49828b9d1d55463074cc8f40c1a763da69d3381d408e5e78ddfe1d9fb49aaada1393bf3d540826bb4249556991857e3b6843ba9dfcdb550d169ae11689b57e2b8181f8d6d1f7e00ce802a44abd228666fe506733ba22ce62a107cca8e9165fa8e3bd54ab848167fe1e5572efb48a82a458694b4820f9ab40e65563a5a15338c2ad2aaff0245927a2735a8a1e3e5431ec11667da89afb6f64e5cdebbbadaf47457f7122d2484ffe0fa2c77d07c566fd988f37255bf70d777d1bcfe5dd903e28816e819b00d9ecd2a7369c281d129b04caba036afcccb23599bb4863e57ed330147e3c6f9a8efea0199bbf135a8ab3c3c596c7399767518c670cbc242bd1f65775717a777804ad64a6ce8530335b34947d20a0568f0fb760bc17af5d73f8cb998c5adb3a223daf47a31212a109cffae3c928c3638b305eab803d1bec588655519de0f4b58567f0403dd7d6377d2f028f31302219f4b64673cb8abfc9b867b0fa78caf11ae15933deb29c79746084c6568e3e1c43b1971f06d770474275472cb87624fc53836578b49cdc43480f4c13a3b35952904666ca550ca5d7973cfeaacfc68efce6b6dc52c28df92d054eab47e2caae3901f6f7b7ce6051251167d2810a25c0913ef68df9fdc23a35d3120653442872b3b45913674d9e20d3cfa0a118a68814a02185240496340a69c272389374b115fc0a7a1d4ade8f5e3fd14326d79779474407eacaf82f17688c685c999b97f99f3102c12549f49c375ca3eae45ae3830ee50a7fe0ed9d4e9cd9780a66eccca3572889a34e051438352d456d10b86d3d40082f0c76933d17290627a9ec3bc47cb83d5bbe555efc5eba0a8a8941a65f92cc3cf20aefc03fd29c628f3314c0ea51b58e500fa3b6808d165d18442ce609434902bfea84906877e7cf307dc23375a8b95b00ea2b48d31274f5aa25c0a192316a73462e6372243b1ace7acaf7a2e742a3505b435754a83b686655772d9ee153c5ac55fc0e8e5960fc9c851ea4ffa2e232cc52be14be2bac98cba13f7170c492ad69efa8d9d4c54408792ba6a7da0b6d71cdc2b70f9d54db1aef53a395171684e873d41da2416a0341b96c4895173bcc7a47202dfc6bd196b0f7ed44eb055a940d81a2de69cc138b8f25e9f0082f947cb706aeb9a15bdb8e58fad6422b24c157a4cb176afa678dc4c65f1356244983b6338b206dee9024ed9534c8a923bf18302ec0e6c05b609994ac60891d154e108bbaa1b48fc216136632ed5b758204716b8707f644f3de4ca6c342466f17d60f9fb9ad09591225a5aec64f796c3219167d8988e1c7bb2b3697ea5fb948b86340b78ca16041c8070144f209275bb806b2e746cf36cdbd009b62ac671c40285bbebba29da0eae756808a03cbf567304bd45351faff76738261a053df20cbeb5dfe91fe0d3607a04feb63c1a683604f6343f1e27d3b0b61cd801f341472d233225ef2ad98fdb8fd05fe8d3d1ff250c0667be0e7539daa1abdfebe5c502f92d32d80b0959b19ba9a68468ca79246eb7a016d643cfa39a4214d2f9271613c33401108e34a5babccb14f88a76aefdcd24e59110d2d3b1913436f227edf9310abbde56c9148a503abf6717ce5daaa6a8b842fdad27ef419999cd061363847ce33122a1518416fbae9cb65fe619593ac37910e76297f7683eabf0d45e8ca125c3285713b533ee790cedf9a2d90b48529c68ee53623a008603e6c15ecef0fc81bb78c0b163b1ec52413286f05992580638d2000dc0b9f66df3499ce50b065e371b862b452c5a7b3f5ffacb2523cc7261050416b697bf516b42b73445551ae02bab171145741580b3efd2ca141d2fc8250f75850854af8d8dd067ee83bfafe026af5b40d454afc6dc4c651688a4bb65b9963feb404a15c27ba3006c12c38eaedffeb87da4df2ddb9abb1e9326d6e1e9124a7f1a0278ab9598245c5871212bcedf669ef9078059b4dd94ee5fdc1993973c62d10184832803d1d358e674e08352e875775fbd197578c3848b8d3972f592f277f2828bbd4b5913fd3a67b512c7d59f2a3af55aef6923b9f0f4c070c0609ec0b8b3a48d1957bc81215ac7e418184e493a047e404e7ea431ef03690ad9a823222b3d553571ef3ca13a5ee488b8709f25f9142158952496841ac3d0173cd4cff3e0ebe5326d7afa7b5ae6993336bb4ca380a9bc2743c142705cc2005a144fa392e41cf28429ca4fd3b2eb61d25f3853946ca75749e16335e64d62c736ba69dce13935a8ee6c28417c9792686e5d404cc51710c9d4000be3445a7925e749f3ee3032a77ccbe7b46f676ace32eff06e305cd93f5379289a956dcefbd8dbf8ae88dccb66d03a90f01b9ba4c70509d1e018bbb1f63f1dbf9189ceff2b848289d9a126553738519a239fbce87b5cab7842c45d797cd8752bc7ec790f98888174b3d42dcb57cd1c917041f5ca83e0e3321eb542a6dd042fe0f8a2868dd2f02f73ce91c9025d8b70c3dd5874f0a21107da311db148500da135e823216a43860fc3665f70bb6a156ca04f3dcfa97786ce8a1540242f139a450eb0c91513d42e0c500848904efd9825369827aafa802c96f8a4ee2312c96d0c3b71542100c335398d1f87270f439ddbf89cd5554b25009c04662fb2add524182ff4d05543d422fdd2553355eb104bb6fe27a58375cbaf7a9f927c885f201111fbdbeb5ace170f14173c257f1a03a62cdf1687750888608a1e97182654cc1cb5835e26b32ee0bf48240afc2c013be5bf1397332a4839820d5067635ed725b22fc93a104212d6736c93b89551e4fece94ed8b5958665bff51fdd99b55f1cd8553ca21f80c048035384f6e86a68a5ea6ab1a4d01f94cf67b0fe30636073e356a46f0bdd12ced4227de90d6f26cd2a24e3228729c5987974f1389a88862d4c7fec80c1f90fbbd8969c7960c142952788039dfb0feb968f2dc08f248b92298de4e4a0695b95e7f3e38b8e817fa6b1861eee33fb07b9d8511530c26b95bf60a241b76fc9b9653e0cbfe55f5abddcfc56f67612b26b4e035f0a76cae7ee0109ad8d8513902f3051ae1af710a19cc9c846b2d18d1913fe6182db8d7df742dd5b88d5e7283e35f79784c084fa4d6b79e8c58b8e4e55d8989180c81ba4dd84ddf23b6db2ba486b9d770761e73111c8b061036e012cb1d152062a67652cb76a82d928899e73c45d94df53f3052fc7f4bbe547fdfba8c21dfc9014b9e3a64ca57389034975f2c3ff1f89d4756fb23c9c46b7946ae19705e7ba41654d0eefac43a6d580742d054f898246d0cbeade6926f4e2ad9e60b3bc6fa869077812d862d7068dd4c19d022db4bfee3f120cc0f43286e2430eec6f594262b99919129cd7e2b185b87585a9bcd1c9043f5063eb9bfb2aedbd12820b6a67d14b08671da2ecfed7a0812c16929f0fb4a47aaf960a1cdba902ede3b82608da512e61c35858723cd19ac5b17cafce01e1fa173be4fa837c16ecdcad6ceea0626ef59627fc8c4b37642540459e43ec2eb9f24a6c61e05f348b3ee79d5fc1eaa71075fe98233bc6be3a18b41b2e5c5aeaf8aa29b4cf07ee498f42a7b7a2c6b6fb99d9730cc002344e2a7d09d86a6405bf07c47182470d3020ca9f1e95b75533928029135d970723cb3b664c8e24da8c0ce85fe47a8bbd2137671c76a22fd65cee12a792178cfbe9aefb69ade915e27dae06cd51b014046beaf5a76f34e2833b83b8b035ae9ef0b83c26afdc9d0fee281e5a67861c6e2671809dc98b6c0173f05ae4eff9f3eca43a17833c4725964d26758d0d7bf760960adb8dbc67aa567187ca3c3a7447ca5f0ad19f9062f14336c427b9a3a7a5fd7e1aa7965f8b33b238384423421a519baf88674999addd45f78e0325a62f329fc2998f476477d63418f99870397e9bb38463a2376af94f174ffd19c4756581efa81b807c18b4f0e737e092fae170e6ba0ac31033c714412192ee422a7d521ebe7874fa3e05e1e5a8f99b42f74e569ceb453ef75e42d9e7e18207c90d89918dda64527680485ca790faf06d9b5811d59c2bac419babb9333963ff30745b8bcac3a781111b3af0004667ece8399dab4360c8a79005b016f960b8287bcb9a9ac5a941549003d1bfa4115393cba96752849788001f6a431630e6436e58a75155fa20e002e8d0449f8ffb395b085857435907b404a0fcbaf7275e6662b56b4ffd0f49900f4a4cd495e59ddeff2e2d758453a8b8002908fd4008d164f30ecdd8e9c9e821c198c4a108dfc083913d61d6dfe9d3535d8b4c9aa5ad54daf3729d66e3c10bc9d8ac0441584950f956740e5e2e00e48d3fef5af2124fb344e1c7ff91f944514067e258b173337e3c88ffaf9869f4d6376f6299c7233477300183045e98a5c28cf8522ef0fa8187dd6a1d79046f29f8a1e70b52c2843290e54ace97551a731314d0e68024d9162b9e14e2ec8ef6243745c615c7d0f6c8fd5b935c32988020ebcaab6541e093ca82cc585d81d43364a6c9f4d4c027e880952546824088e53b438fed358eeb1fb6218048994619af705b8a150a3f824c7697521853cacda1710aa28a714d4526819ee3d9262b88a042368f94ad87853b195d876d51f5d6d7a0dfa9cadce571a72343932de3265f5e4ee181ca1b6fd51ce3bb40774214f348563056f99e79ab36fd9a50e35c69f27f6419ddd16a46e1cab8936a0c93a40f1ff48624a7df620b30d9aa6d401ccbf814dd0de2b4d7ff6eeb80c8b5cd7a442a7530bced2bd5bb66ca180b9a8156075ea01579c4dfdf49c9956eb8e318f19fd1761dac786629d392e333e15a98e11ad923e470a8b7da76faa3160c313fc20809ccad6594f55cc3491bca773ac79f1555ad7d3a959bbae98e9821546631e4b8aa17fd848287ddc230c67e3b07f4fcdc4229cd967ca5599e93ae361f69479421e3516b9b0e2bfde70a6df84a98fbc25641016fee68cd8fe7a8cefafda19aa1852433c01e487fae3f45c9cd06472fab19249394e4caa136a6b925de3e8c099160a850c3b3db3b420cee2662ec9221d7c8dab3fadeab646db57145da8843a6afbe4769d933f33be8d60efe8e9d07f8c5ce4fa59e40b92c42e9276a09e62e331823f1054d2c1ad7f6e56f2f844d900354e1c8f23701b69cb3ecec9d87cf8099ef56b52a25d8b9f4d3b25f6f1d010998728ebe39c8f5c42a62ff0193fd4bef804ce250eaeca66f3fda6356e467c9c5be29b738e35118a533d710746fa1b035d10cb289b3674e30b5f21990d12098adc0b625aceded074790d28015367ce8ea865600a43ae783f7bd3e1946b9abe1757fcad913ba9ede1e552808effc1d52218cc8e92faa730867eebcf0a78071c34415424c681e46dcde485506fce32fa193617a980141e4e53b42f36ed6d9ea5edc62a5c8b2639bc3267f71e6e81ea6cf07de927d181b49912effba89b6e8ebddea5a00813520aec4de12395f4dc117eaba817c6d1c21c6176a15ae6e221c378d068a5a8fa6e28169f301ba17f11211dcecec01ac10064c500ae7f1215f20dbaaece579d6fcc289b0a40782f0f93c110265596b13fefed38ce54c1b2958b3c363e04256d4b7b5a24694537efcbb086bfb692dc6cc9593b103d6b18c12b89c107ba6ee17185dcca694369544d7161448b4e6fb0cfe5402b923331b100600897d2abce6d73a345feba65367d33a089f5546c2509962f3a1fc1030eea480c016be274744e99f77643631855e6943239679a8957b463bf40e0b058837ea87f5dc71a1c0bb42502feb8225875d8fee3e1780c76066b1bf13174a17820385b39c3d00874587c3582d9074f6f8df03a495c7a3692736547a48886c6272c978f08f8e5112c20c98f8b14e6802fcaadd057e8726dcdea1e5946f16fd3ef6b644cb293c7b4cf662f1cc41ce1b03941bad5a6bd63ae145ac65fc0941372fdaff7fc30d7804cd5cb443458841a8547f6ebb668f1065bf7c31e8ac3f165c617807e3c018fc795d5961ec5570853f53e6185ce6d4538b85c3bae40d8c69d1027dcc76d2a6d0b6cf9d46117f8f7bde245e73948772033d7f00d76825633a0ec4b51ab24ec04c9376bbbb0ed06085d7636efb3a63c267a6995f48b5f64a998321a4b72309389fd64b3e94e070e11be7443f7da4afe9d422c75683baabd6ed618e245294c1478a50a8f503b48e0dcc2e66a53fecb8ff02338f97d10c673b3f0d7de274a82d570947f397c2b82d7157f40ddda94b6f87192409c491057c9b9046927cc84ff7ae7b526b7d02f550d3aefb8f80040e7a5baab8a265c8116645f969f035cf237297af9e42133a7b52903e2a9a57a511721907f6fe5cb42d9d862aebbf247595c3469698209b746a7ac432482782b88a2b84add003f6806d5c35c4a1cd10e322de3fc40e9a0a29ed45ea9e8079fb1d392ddaf2588e1edbacd17ad43b574ace5b5e6da8dbaca0aa886343a7eb1ff20817f5e11132cbc87843b5b2645cb250ac91da7e079902a2d978b7b98551dd76bf240c23d130b62f28cc224bbf8290220f99639cd04191114ddbb7b1899401fb5ce94a32f1e26ebb086c1377a2bf18088793795fb28fe66d7f51a0148cb4851924957f41314d5c1cb4b5b62b181c66df22a8df68765868f66efc4f8f5e5cbf816a03c8c83daec2943001d3851145a7aed277a9a5b29596ae9194e361bcb624da1cce2245a96e9536dcffcdf2f80bcaf339f8a9b11bd5b27e74a16ec69cf606652ed869108b2a889deec218e187931e6d15a8f091d3d3f74f382161e6cf088d1c6e21843552c3ae6f72c0939c2a48f162f8279451cf3186a125247e28ba1115130a84d5e190c800006c7e4da1d019a27012ae74bd55c7f5ce7210bb2bc7cf940812dbeca9ad0e3ebef5ef16e5391f5a563a318e0d7995bd7b4605179d631f038532ed1b75a847501c8bf066ccf83805a05108ee58724b42c70a8813e8a95034e52ee31f1798611314ae83ea0e82599ddc57b7997406d4612aa8c1e2458b366ddee71ecff85513f54323d8e6285a5d16187c5706f600ef2e3f42d9141bbc6d3479131d7dc99caf4d4388c6daeb157b6ea6cbe5f19db1828cf66e6c512b600bcc571b5b259d06285500f0ad06bf6f668226c4d609654368f174d7b23b120ad91097d450a7bc2fa5104c6b5de47a1f8f13d4acdf057c62fb5c7db0a13793dc32feec3bd87ad4ff9398bf4b736b7c88b195ad4e691e7d43a1d925a77de5b574aec22a39f9666bf5d3ea5a3ed022fd2d96a6467cd8ca2b17b3587f8faa48b85c13cd51ae903436a6263a566b07bfbf90267f518ad43412b4ea1c4530db5e7d6f18f198a388517ac01618313e6b84b82d11b53f44c6e08d2bf98dc3c08e47f39aaa11cc3e6a0564cb33eb6d957e484c1998add0779494338f61f6399cb02fe86d2e1f4ee4fa0b22f01d96626eccf79e722aeab710fb683d081e9c088ed1134ead6d8b0d7ab635bdc733fa911d4981aa0321a3d42dd05405d61b62c73d306e21a9a2badc3f9e8dc46c0e5f5b3aaec0e6f1064bd160dac4a892937f59eb03290af57b172133dfe188a9fabcdc2b2a015a8b53067a3171ea96d7d092412f93f928f4fc7e5d08960d25515e64734a0b00c1ccf2910db28659206cbd0c60e2f3ad559e42d5d0e488f0b88cd4d9c6426cb5d3df4c9200658a153d9bab0dc83b9449e5658314f3137cc19e4e0794299b52de8da4f022a0b18720e76dd562c9f02f25ff0c94ed257e39481f19ffab501dcb91f28f05c510b70f09ee6722e452b54d04b241dc364116b950ad19adcec26a394341cd99f30023a809dca8d0eab6efc0f212112fe2f190d17cdf6337b808ecefc06da6a30da594a81d5f5bb1861fea9ee0c5ace72e35531973b6804c46b8b481c71f82d71a9a3cf9501a5e3141cf48238f2750cafea38d9d46b0db5fff2e3567356e83c431090c0481ee4143e588d7868f70770f5fddc4dbd9f27e24b27b97aa285c62fd79d4ef49f6a3c2a1a8c48ff21030231c917b82f99c328dda53bb943d4c4fd32ddc4b65230570980a465959fded5cad771f7e113fd42c8f44330a017da2bdac78958c5176ac76b3f23a2d0789a7bf70e866472c6ffd6f9bd93787bde3d6c5503ba0dac214d26d643893671a68c24559cf6324ff426f810186c89ea09031e0b3c1809e5a42b25d4af567734afaee2aabf8394ab3e32f5e157d9576f6ca96b5bb2472d3678578da2282efa6e1351cb865e31a4813cc05aa350b56e899e44af67a047deecdc9f5728fa95f2ce881b9c9caec1404034de81c4d4816cf546eb7081a57a2d6a34b78af3ba1f081a0770ac412f75285fc9d0bb9bfc632a08718c3afc92cb7c0efc15ad540e3cec3fd0fe5810d498b0b1f83b148f3f00ce9407652f8d4a50f233204beb66b79ef8c07f654df4dfb03a6baf96e27d853b4b6b4144b583792faa49bb091340cda0d0c482eeb8e8816811c6a964871c0b78ce47abb5c0e5bdedb05ff9817a9c657e80645a1a3ac93c056e6b658348556ac9380b7fe6ab30b3159f9d4ec3b49b40330775f64ddc6600fe870df39b2ccfeec3e12d51255d4bef49a64b021d4a76c8725dbf1ff26c6cc5cbacb387ec14cf399aef9cd16b9c55855662b3b003c5819fefa50cd6e2368ab4e91898a4d7f835511404129e11bd7c5b4b46e19b7479ce9aeb48e8895a3e598f5aca6df002494433e76b71a10ba02677841cb0293e8b03002cc754f0e5371e146d7b6a7aeb9723d09908af082d095996c0d81ac2a7d0ee64f716857af9fa94ee5aa13c105937a8ebacf0df3a262cef017a2981bcd81279521ed830629a70d89c6cca0f393691591782ae5984cea85aaf01471b8bf5a029b5bf7973acc759ac6d9c9a5ef2a33a43f4376b65b94446e97b377de2336a7fa82a7730da257f1fc59e7138748d83daa2d3e2e4442cecdfa8e7fdfa5cf8badf15ceca25926081899249598b22f4e7e4aacda85143f700ddbb898819970fa34d613144163088278755bb83a26965dc0c9558d1b3570e3e4be979fa409a707f9de4cab33d876f6280373528428e3c69c74d533185813d430aa1549ccb04cefcdcc14fb44359e5d65530d9630514b7ff6afc1fc5e99522799d50480ba22b988e657ea52be9dd1e6dcda13a87b0124473821753d0cc413c09a09352df23b0f754d02205589e2341bf88902dbf9ada190b4d5207b82daccf9d3959c9abadb9a0ebd4ef5e62213b6f20af399a14a3ef3927995110203f39346465e1298b9800864a61ab6246c7a56bbab6d85a1ddf8b3be3a15604d66933e519303847bd122b169ec78ac0c587cb3519e841884ae065292907c9b16828998e6fc0724ea0e497e397610abb3b894509efab37a27d2770e03fc8546bf1ffcdfc308791dec53052e51344ceb982a5ed7d0fc32900532519c499d3b1096d6a5a1d1b8a93185b02416f23b4a92b42ca433bf8897249983b16f85d81cfcd74dc89edbab17a9d679d5d93ad2555233f55f445fbef71390ec9a7b6f5046a47cae565ac6d219441de55ce536916f27c0f315a59c81b0655ebc225d1d770671d42f5e367c8632ddef7f344642ed34f1117c694b55f94b6b2a772e88c3ef756f6be960dfce5462e6bc5daa3b084f68405a308ab0c62f1036a3340a9cbc1e6b13900c61ce826c3fa8018568e2aa520189f6f025cacaf53b3892809c47c764b49cd94f702852b5b1a1dab8390466e873fc0efb8b7bdef0e56577af10726aa856e92996cec3c0ebd7842c0bfbbf11668b91c8724a2b3d1c79e74943db2de8bc0370b43175de596b9a3b42420b8b311082dfce04eeb7aea987c49823e9d8246c667fc5156b23c3db77b1fd5d0325a9d082eedc9b12d2cf216018820e9ecb0554afa75ad574dffb9bd03d6255c6a9516d0e9502f48b013b73319a920c97245cba94301dfcb9af7c89fa2608f882c4ebe02056eb2cc9d840fe230bb5716958207b7d22d426c9924f1d5b5914e562fd60df6b9fbf92ef1e50d21bf474ca97f526a264ddc4c22713f2f0c6e9352f31f901037024bd28180778cd8fc9cb8e88f00af9e8c96fed309768cd1e91df4658de13fe2fa9fa045916c3fe26bea4d456aefcf4cdff061e4dd80416d36a6c45cb0ece4e32c88ca1d16ea8e66ece462c3dd2b3fc9772b37e2e730ce6369d96701ef53caf80e88b193775fee41d7eca006553d2c248f0b8b1aca789f6dd7996b6322b798defe5a9e5b517b5188f9946dc6b0cedbd6acffc94f5d248e2b28474df94477c94ad9f14a4dc656564102b37588598b1d05e8ba42cd3c5681a9d1b1ca64ecef9627ee0ab6b2f93f5668219d90cb1487f69cd01993e8648c322a742c41d82bb777a64b419bfc87db16c3bd50ad4ed6368667fce6341543b9de7152298ff78547f800e380ae830cc10b8c6a363d00c9c0bc5bf6494b4000466ccfa74778cd079743d4d6557ad5bc264b038c50091d49e7a3141e3c2478ce27e536042e776b5137a55cf69dae801d746260084fd332dca027611eeaf65d5328f1ef9dd1ac9bd0323b9b3727e3f39382b51e7d64cc629c1098eb3e229d64255dbdb6e1ca39dc64879301679a965a01086fe0ae9aaa67d4350e2116f73951d318280a2ca9cfa5055","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
