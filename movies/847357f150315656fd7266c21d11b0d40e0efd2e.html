<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9f68ac129b205772ad90222aceb4b72fc4678e1880985f227550f170e95e993d112d619f061d46afa3ba84a0c173ce72bad5b769d52fa8173dd620338fa58386aecb012de1f5b69f373aeb36159cec076455a4288a851269a468d0e7d14d68eb6c6bc40e2909063d2b704f96003ef1bb980ddd1d2c0f86f797b5787e5b7f02088205de5c130abe5c269d9984d91239f1532c5397920830db55a41279d2f6b89ff2db2fc58f2767ab88f0383e67ade636d2f02846006cdc759280983904cc435eda187293bdebdc67fae7d26bf5576a53f33c6576eb337533068d2ea476b63f11f32611fed44c10e8b3a3b768fcfbf41be0d9e5a70322db1aa8387280eb775f4f37c2c9ff0df4287b20c053e45debda8eb897c93d183eb503ac218ab3aef8afee34810af1c0c66288fc088e962148f704f78c1b3fbeb95cdc044c3ebc2ea42e02ff9fc6a60a8d6eeb96f9e8c1930bd9aa7027eb9af90f148daa31e26159723872af57252084a429286d47037f9f14483bbc4b3f5a0aa9172d4356b04740056ca3e2ee76b6dad6fef08528e74af9a3a8e8852103af3417021802397e947cdb85d6485978094aa39e7e9a3673ea44799acd99ac74fc4f9b5394271d970e92240f9d8de176b74b809c4dc0b03c0885a2f5ec9f74eea47d233278ffd865df0203cf06a58810e607dfec7a58360c17edbe5e39b3da71e82db1aa6b2311a6fa2f1c479810e7582649cab3d0bcc2c8eecb2cbcabd37782bc62486047e46a5f577b751dafd8e58a05933e8d606ccfb1cb17e1b453a98458471870c04f645bdb6696ca517826d2d22bc9e76aa6a8b1977f1554e88fc4b545ac375c8f1bcc7faecf6392ac61b6073b3dd5980cac439167e2715992eec393ab831c3ead62cd8eeba4f9e1f75be93a95aff6556691b4bcf6b7e2e722b6697aa8a0fa1b2e721191556d98af6f3d98008dd7bf2cd82f1ed15bbca291bb856d5e2a1aefdb975d24d2bb601c5920cfe39db7a611be6bd5cef321efec0bec22bd2ff9a3fbb4371d3688eb49a740495868a1a90ae607d81fac84c101117997e725e2147c57bf04d5daa09e91ba9213f5f5501392bee6f7d34eba39418513e7363f869ae99fe184c55547d9a3db885b27b25c4eb0cf69af482665e42de71dc37fb4352655bae41de0c871cdcbc780f1d5ef86b82860ad6ce5951b731539414ad1de929d4601e1f3f478b17d4397ecd0dde65ccf6617196bc1e11a15eeecec74d382217fd71a5ae94feac1a0b76efe8573972fd0de34cc67c88a47bfabf191138eed7e38a8b732e4f8679993381a1f32a1bb055a9fe810fc3075d6fc38d7439d410fdc5ad930ca382bbf41b36639b36d90bdffcee11435b72a3009d4e6c9cb7c5c997ab82e08b692366d43bf9fcaf71c288916fc10674c8a724f253e99c9591984bb62d53f65d8bacb535bea34fb7d1da44171db35066f49f0543912d3d505d6f0784da7196fbf6f06c4eede3a0e80cc70bc6911d0610f5055171e12984c5047dd645cadfb28fc5848c488d492b726e1d246de781150f08d927b737878f95acf81872f2be34cfa3370b89143dad138ef3f1a19683968a5e3d47983ead0927d1dcd5bfda785ba97d430d361e2a6e6e49e4da841c2486f2b58a9ccd85c9bac4f212f84efd8c750fef002f2206d7bca1791928fb93d0ea2eb7724f74d9e7170e70ba96a9a60a11dbe8aead88cda1f9d53c56a1adb3e97f355160dbd5745b7d61881996cf1f1ca7ba07315a8d401bd589bd5210941edfe1884d3c63aea8895532d5468459743718a66da2ff989fade5e43a0fdb755d50de1adfa9f200cf1bee391dc1cbedfa5b5e7db82d71d8ecc2bb5650294036d974d5ead7f7a64955616bbc16786d233e9d36cd497efaa0dc8bd3358d85e566a3528721feff3caabf02886916a64c5f41017aac13b9c3ee08004b0d96ec5f7b1011149134b4eef536bb86814d2a2e50d0de3209fdc7e55c834e448fbb1937dce9715fac129ced81827d9e8edd0471d1015ec9179ce252af84ab4657eef9539edbf76b5eff81dd4c956e71f0e4e1c4884a10b53902058a547526970974e22a982a9ba26015da448b890bed58618459916803766954557b859a5f4a1a41877de454b6087b18d6f6377672181e0b52af29021020a84875ef5a3110c65868cab16ad23dffc90ff1df54b848bd6e66fea57e7b7628906164a91fc2b8470511d315ab12aa2c381b5373aa569c5367066dd49cca26970af41011fe47d21512417f0b229dc815ce4036faa539eb754e2b6906112f7367bdf0fffac7a88adc1c7807c486bc06035e6255368791c190d697d4cabb1f9f5e6d93b4529a41c6be35fb2941288495119f5a469f19e28886efd632b5d592619d56620dc4a8404cbb22f6e874cf2151409bc21910d71d9404edaa0a270705cdaa19fc61aab31ed0ca46f24108ba76823a51039a24ae9a920950b51684e084d5a57efe7d90e9dbea0b94d2f7b8255502342d74829292cb79449629bf717508ce891cb5b980bd8c1944ad749c51731dcfeeae996131c29eb4dab8b8521a7e586dee8d082f4a2954d8c7d16bf35d3e2e5c7f72ffa7395aad4f502f04363fd6ec557ec143d1574662c47b01805733b214d3a5a3da8dcda191d804467928be44c58f26bd67ee56c9e59146d0e07c48a143b5f1f73df3791ff44ce5ea5b6f0beff596b1294506ed125237aebb8a3f68855aea2415ff7ea6bee64c364ae4c68b0519ff6ce3e9240ba73223c97a7095d1aff6a843d9ccdf663ef03f02f29e1e3efad7209f608117029fc3153412be73d1698f9ec394a0663a7932952530413a397ff736071c44e44d62121d8866716e00f08beda9dfcb20b8855a9b1b6efa3e8cd7dd9600bf4524af0d774661ff9da0ac62cf3068169455400fff47445670ece254d6dc17a165db66080566d28977f4ab1aa8fad6ae054ed6c1649f2dee244561c5ff0522b3f22044ba48f39f1fb5e2e75d56f729dd4ff0042b8dab26142e6ef814e5249ab5135b5765044248afd992b81877656a9ec4767b0c108bd7cd295b9a4089d06bd5bd27599205b0251e4d843dae117059e63a0ddffd1da38848b1bf1ed93842a01307c12ce869c1a7f043b743b95933beeebf625292cd655102333fb2c6a9b89cc90f7d0f04027d21c2b3023aa16dcabbc384c63ef8d2aea1365369abc331e0bcc8c862d0e952804bd62945f58526d80150502d6bd5b1f3150e07df6d471c92f4b05820945ca590ad9e8b05e574e40f17d4499a157ca48d773733abde5b24b336079f5a138655a4407ea86ab9de02f0933aeb0b695df1fbcc5b0bed0f6b23d7adb2a0b50996cf8e9a3f56b45f4dc6d4e62f79c3f207afb1049818e3c6c78d71e1d3387533b20564003e4b7e7cd062ce78bd8830ec4d7d5e2200e5c21bcff7483204d0b0d21b2c0ff06e30616509df6a8429a96fcab42881f7ba8ecc0d5ab6776247fa56bed715775cbf7e88699fbaec1a72e91ad098e73a49c02d1840838272e17d1dc9433ee1dcc45b2c96c519d3c637a454e0d7f1acde6be7ac423620c34f96526af4a95a36b779b5fc9483d2677e7c447c2ea79e753b3f27eaf10373f6b3b65e25ac1a389a5a72e70fa4c4375d70d6a4f4abd61b5f0a31e2aa24151496a527abf6b7e071941dc9822d14e3e82a76ee044aa01df05428bd5f67dbb2dde7c71c1a0fa6ece607b209a95ec08158b156f2034e0c7c901a9fab3e21eaf4f3a0d72c16c6140d4f8a20b8ed9436537f550b61babf08f3d9d22ebc1863625ae0e573c5ccc2722552c84d9b9a2dcebe9e82e0df0436eb177f3b005526b38d37a682a4200117ed77d4b3b700a3c7e8b679f342a1592a4368b4397437216e401c2e2c83c532c82a84cdca0bdbbc5001b9b7db6249d5761f5d95940bab4368850f44f2e631398287e02f6bf214a11378d0f8962604391dadd3a1ccc0e9fe1302acdd55c7546f32285972c84fd12c7efbb905d4168661a090b023d86bcb0644e383af9ad45b8bb921a6ce6282a44e1bd7918e16fe65a71fc6787cbdf131968801428e007f4a11f46393044513aa2d78e78288f95c4ba64f2a243a7bcc259d9092dea9d96456c2f667f270c4be7eff1d2bd9e0af1dc724023e5c40b7d7d39e47df6c0bb94ae7d96b8690e7ff560035ef366da3c0f7f66beffa7454ae855c34e518f0aa0e2bc6ae3b97eb7651dedd629dffc37cdd0c976690496b4107ce24bc69565e21a4c3158c031efe672b0aab0d1779c22c41419365e1c8aa23bd55ea6524b27c00923b05723eff4ec5a12b8b242bd489ed8c10be392148bfbf190b7b290fc9257e8d7abed27e81f32e73f0ab21407eddfdd01dafed8d1e530ff648f52b2b5137742abbbf067da04c00052047000ace4f9629371e22ae710ad0799e1da7a72d20e9c7eb852cec0c1317db4a472380b7f0b8d3bb828c1c6f51b9ee4118ffbd890dee45e76cb5ba758b196c1aa613319da96ec0fc2053b64954f7a17d6e84789c927ca6a73beca00fe2e2470ef5edc2284e58a2467f6581ba99d2ae234719d4fa284b4634d7f66293e9bac55d384d9b8a1e277c029c4739b699738c6103981c0d3654332b9a21d366a6b235b5b76c853e3539d3d5ddc188cb50af827450963460b26df878a03c28e0c07ae0948426ac8d286f7f573186c59aa7c905a7ffde739db2909a06cfd98b2cb6855e919552357e6423812d96ca09fd7faca759b5739709fa4121cac865e986cd94a0093ca74e2f492fc7bb497a37bce20fba5c66ab5f156cecb380bde62e9ac9a51d7772d1c805f0bb8705a87509a517533cbb351e1d53f19a7cf0fa786ac26d9233629705c25a9ca84ef58ae49da7ddbf6a9561ede8bb56c2b94a1b23fc9855771c82a9fb5fead3b4b6272c3750b42e27d67dc11085fdd068ecad52347220c97c852fd3eed28d0b1a6006f536ebe995ed83ba7935dbd3e96b7a85300fd692eabf0fdac8a3177b41f98129290516944df515117cf0b5f469dfc35d126eca165f30a7a7ba4c0e54ecb787cc8c4f374aeb25dfcf7f78dd3bcdef5983949130f00bd68f68d4b44c710f5eada789b828ff29eba10cc454382e628de2b2c91a44861b1a524923221ccca42776d2985c0785d22efee7f9e0d756bc968378e5d8b8139ca37b1ab1cd6559a0a5ffdd83f4c90a524249ec0228228ed2047a7d72c44805e8b2ab17d5a71bc788e8f5f7fe6652e0f9e5c0abe5edf71b63771298bd04b8d8bbd2e9f18ac360f9581eecb41a5ade72e0bb772a667f1670feaf516902d07f7f221b8368fe7bb120aa24a4c3b70ab6b42c5dd091093d39fa5e5f6f24c12841f3f198e386570956fb83d725fc228e411b83a4130329797f248d0917593390220bcf603ae63f9e53d100b854743caac7d80e9fb22435cd9a35544797d410e2cdecb2734f57057f22bdcb1f70890df84fc466f305fdcfe1771248c8c9aa5b6a2d02d29b540dfbb1545bddae82c1cf7f7259b282900c0bc799485e997487410aae0134a0c8e5526c46e2dff54a971e7adcca7882a03c0200ef823d7a350491b4ed15b979dddb12e7796777221eac98e1a51156f05fb41cb15047c89fe22c851349ac0ac43e0b12045e111c4a801731e459bb6259fa47f471497a8dfc411f7f3950e69155bb6675fa901937748ba3b63f44babdc68142c5b4c3380001e2eb96d6ee8509417bc2088914d057c2502de1af68adff5f4d2c992ff831b54c51880928df5398174826e825b25ba72084229b48d34ec9ec26e35e88fa310c9f5dfaec3250a4971a42132d78b565d9d060c0736e7d6e2e0cd8de70b58efe3580c5106660e39692b50f1d6fbc5c481484d6cf07f32bf863b0b829f211cdbe27866fb476dd631f4ef10db7f6aeefd52913f5e19040c7be225d19fb01302072a4911a563a171b9073c84b4094b62215bc1e56eb0779d218d296aa6263fe4625f944d598e91d45dc778b58313ba0d8bac8535f4b99809ab99aaebb1ea86f5120c4fc00a20b66c61702d8087996ee074f18704a042b1416ed78a1af0bf75c83b541df6a796f1abcbd73ee2f0166785cce867c44106e78b8431a5621e3389f120d292c78331093ea9e993af5b42e40b9d30dcead43e1c3873a486038eb1cf0e7af32da2c8fe77b16556455ea4ff6bc224b7682c2c7a922f9d2ee2f4b886e941417072d597c2a605675009ad207cad365fe2c2e7470ae662bfc22ff811b810ce4c0828aa3c2067bc7a6f8cb7d4c2253bcecc8b17ddd1323938da0ff66e6e4ab75b316b263580ddf3e494e5f45d57f26d68d568e8c3261b6add9f9928993125c9be48ebd9cf32592211bdd343798773b6a89eb2f2d5210312295e503ce678fac041e3bfe70a46c7f768e6a3fc8250df833ae2caf01af144298a573576e64d9bb9a19f3ee0f90b838274818108e5743de41dbc40b5ecb6e7657d713a996ca8b8b0d2063e02f27535e695029b9e82efe3b75cea65f4be922f921df81b5509b2a705094c7b133c6a2e68ff148ac69f858bfee659e82c3767749b761659563e67776142ed26dd1415f52528ac8d0397ba5ae7235fef15fc50cdabe4cef858817eaf8ea858bce76643627cb87b4d8158780ba6729d14ebd85551b89946bdc6b79fe630eb8eb629a3c16f1885ef3f0f329420f5bc6315f33f18377d42d2a684d61b7fa7beb11b2d48451f894b9e509ea08864a3885a8b314fb720569d27bcfa23acc53747f426356bd9e8658172945a00e06b036b38077541a3a95519b623379e2e5f0cdf3db4530b2f17bd73dafe64f7319f6e40d9ff915210ecdefcd07c14efbdeff59d02740c1ec13bc88a2b84f27df1044b28ab6a692919660614b5718f81527ad8adae36f4856dd9fff79083e5593e2125a9309552d4e629450eff0ae3aa8e0932a4150af688ef36525a3113dcc8982c225ab41c8f6158d6f18a1da8a88afc3eca99308880e38d85c7f792f6812a9545f963a93e645e37bb2563abea7cd085d7327b6665352dd653320b458695e193f7d6c90729d1f0bc0574c6bbdc33504c4efcd939c91ff3178c9474f62d1158bf94b0875eed878957019086bc73b3bc943d99554a40be62b1d4ab71a281519ec74fb578a4f2ab8e5205b9d29d53238886f823bf95fe627f85ccccb4916a8e9a4d44e5483c4087d1106e5274771de081fd13b233263ee2947a375e8d370d18402ca5a0fd44a41dab9192a68c18972ba1c05c5814a668ec915061a43ce458c095b1c976430ff6793f86802cd28d4c890814cf77ed1dc00d6a41f9bd7f16e8decfe776aad25a0ae94c407c00031dabc2578c5c8989d05df572bf609ab5da13e67d6f836d6c513f97ac9b0d181ee522eb986cb42a68e81fd1f8b68b3a2ee850372165c6369e2a543f913f8cb733b061994d1691d41b0ff7bb18b920e8750f31ebdc18f60ca94b4855c31a5a4553a069ab888ad1f2054f42879c7a1086f4768c1ff14fb97e68e2242fd66dc395cdf38fcd7fd09ff4cc16d18b2aadbe8f19b69635990d787d3789dca18bff3523afb2b2d2b234c8750a9b804f50e110bb66e65bb23761a39461d1cb9988d236fc282e34d96156d9e12afb0eda1f1ebd62adca05b16d6fa368ae105ca292a3fd9a0f00dad0a39ccf6dbb2186c93852d011a3d5b46ad6e35f84c996a2e6cf6f8718a8ff24f0891673ae259c9005a77329ae974d08b8b32eb1bcf838ae706cab23dded86469f6dd7b52931772605a5d70c8511a5ad2ec139ac89a0d7c17f1b5e9aaac3eedc2b9e3458f7b2c1f59b25ac04d819c78746986301365c9d07399419602e933928e198c9c66dd52fbcfe61e4ae934d9b8b9934fc6f092618d65f83af2b9caf7ce1e72f2e31830d4e2d6b314338379c0ef7ee0f11ec3ae5f1ac3f07971d26f2038a877b1ec573dfbeb1c2dba802e73739c8b46c94307617075c58be9f012f1ccf93401a726400ae0423d55a31a3cc38325e281ac1d39e00eeeca415dcc754556edc5992e0c9ce4286519c86dbefea2745ed3572436dc3143246fcb3d507fea8aa7a471786f4123edd79d7b29ca8f40a5d4a4ea83cff8cce041fea48d8b5bde1359a14565598f57aa8575fe8d0a685aa13e93c0e8d6c9f8aefc0706a4066796ea3bd102a55006891fe560a4c0f63c2f22b2854a434ed9f17d8b9ba42853ee6300855e65d668d4872e2151ccc204505fd7c4044c8576a490ff47a9280cacb3ccf8a25eec74d9c4505fa48035c39659afab620e2f5b88b0f7ad2a30035f5a0aeedfec158352c18d19f903e29fe796a69633dd4d2ac211ed35f8edb74fda0ec63d9e240e4eba4016939b11e2d6e53f6bd41aadaffdac3372a1cafacbc126ddd7cbcc3a982a8b42c566a90c3520c7fe1373e47544d40f86ff3e8b0f58185fe268f3fe583ec8c12ed36095addde633754fe8f44547ea00935b915256e15c0e78e777b66e0ee0d0781b10e987adf4c74008045b6d9e6de4d7142498952a943989a7a27801b52230077bb4eebc2e261998b79d2cf06637ed7eb11af67ffd02c12440b0f3b66e7f8030fe5de3e74b99f3cf3abaaae52e10b96b7cd5dcd470b086add12f0cfebf55f8771f7bd247e81c634a40db0cd6e18164559762b5a5267c47430dddd4f35c3c13a173312b2bc0fdeed219f700e9aafb9a0fc097056f7e5b475d6819fb8436644242875deadc1c68ba10c6e910650705657e1b3b195e246acf21228d04fdedccc4be7e3dc738f332fe9f46faeb8459234ebb42cf9e08e512c84a5a4bc2a60973c2e18829043164d6bbd220b75c5bb4cd75dc16066c05c1209f28c1ce2f4c9778e9114fca77bf97e30763883b0f459840402bf00daa65683bd021b2033de3dc5724a0bff8a018542f43253b8e3094e1e6e20a456363904fd24383107682789f689d033262cc071ddb1c746bf2f6ea67afe2225bf5522e88ab962e43111f071fe22ccff1fce6fbd5e25fdbc1480918c043c91ed98c9de5ab693912327974e99d90042eabe1235ab6a3b8d543fd797e4c471b73385d7855bda4fd36324f703e49230cf435fa9b7e9b5ad6870366dc287ad3f3d694b9bb9f58aa65d86cb0234a05c5d94da751001a8d04fe182a6210d14ed0a2c0495fb1147c2e15fb62afaa56544db57e46d5be090c99dc231aacf33954b8c4369aaeacdb01840730a2c53ee346b5269bedb7a29cea94938bb065fd1bb8284fae1581c6ad072f9cd642981089ee24f876d322658e40d3c3f0ccb1ae15d30731143941a04a566fb6a147d2a0b25a8ac29fd2816950df8c38fc8c4b793cc76fd8f0575ce4969125b79e2c88311c6c75579105598b7ddd410db9591ccf81ef99256c63b9e594f201f27f2dc3218e65d1f3490e5ed67f1fccf3fba1c079dcd08d50e20c1d88d26456acf469e8db86ccaad7f50692ca7d64ec1dbf40cede2550446f5fdf0f46477617f955f7de5f3355c4da4ff9beb5dd7b71749c03b105272941acc95b64812645f2aafe0d4e6790da47de71528d20fda3b7ae1e2e4cee9f655b18668ddd1e6ec8828734b40f06e60a0e47f9e07119fbff3ea11fd02683df8faea300501521d6e56aac8717df69ee7b0890f25a87c82a23ddf6ac8304553003b567938935d6c936e31abb048786fe31d5177780dc82d84610858a20af9917b4b43eb2022ffe445405bc0345b0cb4d06246075535f2001d754b0980e20a87f0f9f6360cb8c1e00f13de505112176c21bf57008833ca2828aaae71962bda074dda6f3bcbef9a69734b5223c931fff7a0f546edb5bebd80189375c2cf06b99ea951135059b7fe7f56ae9bf0543e1a328dfe1ce775d2c175f8a1b209366a870a9ed277f697d9c76a5a9c39d37dd3bb0f4918dac76ae30ed21e611d5a83a149acab20e00035a993e39dcc5da6cc6d876c37a1d6481bc6241489f3f8b3fd9726518471fdf2a59a229cea415b8fdbb38cdb200699c9f4c8f65e870375effc30519fa8534166ebbf630309da28f4db4ffa8bdcfa3a9b8a9ec3ca02f6b63d93bc36e77e78332577c93fd7dec8aa9ac6cf110f82a38afa7105cda852bc3fca97c20177ace31932d7691eb8feae851cdaf0fb1fc7b1c3ba1b9cb99feb630e366719b81e1266d10a838a3e2cc0925d8ee8ab1232bd231693076a51b266b32a950ef4bbb6ce872fbe4022e5bd15980ddbb1e478cb0e87ffda55457b17b0b9682257bd7b10dcca711e2582d8c457e0eebfe9fd5334b554d47d237a952c00ebc860b003a307f1762185ad39e488a7b33ece6cf2ba87c28f8b3b548cd7db7a0319bc39980e1b684dc3ab2e23cdfdc841f706c8e1f29845acbb860e5d80f1a247b46037b6e4260bd5fd6dbbe1bed27f11daebe60b86c53f3579f2894fe50e71778e7ea047ca5bac8488156b326d947fc3b080dbba933d1c4ec36544cc96525046791a962d09c76e480a241f1dbdd65f10d7635b70646c58ef4d018091f4bbbdf21ae0dc1bec06cf9676b817f14948dac9dff59a0a814c47582211ab41a3e598f615f305992ceb45ddb095a9162c070079bb7eb2e776476a6b8978b2fa997e887c71d239028de3b1b08edcecb62d4110f0b6d89b1eb8896644124dd798f5dce72a128a064762c8522b487e7ae8f5a803812cf4e88d23073412c0bad2a9fc54661ce88cbb759f7233ba23d0b02e729591b6b277979b393c5d9e7483c6bce646997c669dd69ec26a7e46062a56e82d9013c10210cff531c6563aad21d68d8e63f202e86e1761dad41ba9d5a39f1a7ef4f5b146518c89be46726fd9f1edc5c78f86d3e09d15be3e7b6597e5c8397d558c35ff511f9922ce31bb972cef9cffb6223932f2ea8c23a57adc6b615ebb7c2e9aa51bb0195949ccced6b9f205c491caac5a0f44a1ea20a633b6b953ee644cccd77f8cae332055efa6b0c626f941c81c965d487d59581f1fbec8eb9a8639473dc648b6d261509652631d2e47dd27684198f1e5a0715d009d83d7d81dfa4f9433962777010c19ce78ae8b8daa86223e2e22f9a987dd15b73483563c0dbdb636d004fade6fb89149c3449efd0111aa371979d5697a5eb1a226a95dfe537a93cd0c72ed5c329fb697a011f3b8d4d08959550ba3f176be7720d2c26732e2e6b0d2ab2cd1df1feffb7e5d2e3f3536f0bf944b16767bf89e5899e79e9c6f9901b313a95582ea94ef6d383381051163fddd7061640c214fd3dba7eebf3404abf9805c1a1dcba34af44d43f0b39bdeadccfe24f02ae274a549b1dcc4af0119906700120138a45fe1586c3932fdb0b4a06d3150ceca02effdd861015a03a1a003c8ee91328432a5e6f5c0fa334b4a8d1ebe893692efb6fd8fee08d4021c71e5b481535ae30d0b0110ee0c0a895f8f3121048518968abb3ea05404e476d80446d71f605a46e185fd2231d43cb80f25445c9e84ffef2709be831fed68da961ca8a2ed963f73b56fdbf87ee9e153c2de5fd7b10fd0a7de42bda712e0e3303b3136bab0a926f07b3222d428aad0045625e0bbc41e2271430fbd351fe1feed629de26b3535463f1c0c32f892a3096116f0bcf43fc558ca817e299a24dcd1c871c3a7cb8def8fde2d91ec942645b646f9782ef097fd1224054a63323ce7685901586a0a81673678988508e339f8820c7b04d9adc3317d92918984fd2b88001d53411a8d44189769d8adf58e98ba76e965761945a235140ce784208d4540a56a022add9dadba406dcc61b6111ffc06c3856cbc8079cdbc5ebe1ee5c16e5b611a6f61319eaa0aa4a17782558bbaeb9e09a9a9ea80ecc32c5527c1da11dfa9ab3250ed74156301f1b8ec67ca1fafcaffabd029d466da92abb6a6980fef4b732a3de83670c7b32067c73b286902d899915eac1f2f716c69ea93380dae7feda7a0d361955ae7fbdc9c06d5f84bb5b0b5616ded352495d4cc27bba7df2ffb2d41614889b67661f5a6609e3ded62decca32383df8d342f93fedfb8feb8cee3b92d26ea7c6b6c4741cce3418e599a7a191bfff6bd26b1132d7d3d7ab1f98b2b39a448f1ad7271ceec42f2d33c764a35c52f175e8aa1e44f06a9c26a407889d1db3dd8db61170324011b23934d8487b97a858d2862a6e37116a4d66a462b7a38aecbc33a45f457eac6d2699947463c8caf5323bba7e27222efa6e66fc7e1c357d6ebfdefea444befb56d8a9e99ab1e7ff9e59a218af11ca125ccd09ccbdd8e02c90029d2063f354e3e14f7fe328bf5ed904d17c4506e651cc039fffec2cc0402723179081bc4d11852e42eb5b5722f5b669e8d07de03f579df1bc3cf26681c30d518a45660c6f8d4ae9aae37c3f8b447a0875d80d151710aa4ee400731f95fb4d7b3d0e0fc1143193324fda1f923418b94bd4c56a1527abf7cedee632dd30b23e503ec5260dc5fc5a9413793a13b9c96d963dc984533d90d29b29ba45c19108297a3fd817b9ace766301b56a4cfc8f4fd3e1eedb654c93e39013c55f1257020a9bca9a320bf13ef918c82da43b96aceb309f52859cef8b24edd38166fb3f71ef7b50fb60eac8d5f2024867c5f43cf681c6a27d414afe30bbbd14d36870f35487f791e5673ddbba854356e9faf9cfbd032ad7164d052bc6259f920665ade8b4d24276c04f4a379b6719036665d8b2a3edd4b11259c045388e4d2dad1210eec530678a1df85253d6f07e110c3575dbfa69ebabc3cfe01f961975923a17aa10a090cb9c7e18693b9d92b25288cd1cdc10e132e7897ef690bad2e4d28884337e497bd2e4377f67673654c7506dd361c324b46b62b3de37d985837f004a2900af938437ee71750b0ed24ffb2305ac89c3634b71e1f4ded0d5d1ebae840339054b00f7a59564ebc72f433b43b259fc0ea6ba6db98ccd37dbe74e67da93458bf57d4735fd4832ef1560a0c86dafcf0df43aeaea5306490fcba2d368f042af58d10ea1007e0f77c381106663db885d387118274dfc50e35284a1443eb6054c850ab6b151d9950daa712a0c52e4f408a1e553fdc6508e06dac682e208f96500df205f3ec808f19c8ee00bb3bdefe5d8e676","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
