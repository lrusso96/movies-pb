<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f890cfaae45584954786660c7dbec1d94a1ac6df35fb513b75ce0693f44616e7e09bc1ea22838305a7d3166a82e1e3807e8fe41164982df0f2e879252ce5f05c1cd40a8d6efbdd07fdbbc9fbdec452d5ca33633c4178ad1affcb595bc815d63098396d4708329edb8402292784be7fb60a3fa3fce24581d403d129a65f5d513a19c875bae80450085080ed07e8c73bc45515c4d9eee1782305e157fb6e99fe027750b9f8ae53cfb531d788f0036fafdac9c8382a39ac16beeff24105db674c4215ad3ecd2e34299bdb87f4383d36c7e4e0084b9a91d485a40e4661a875faf73477f86ad21fc217ef4ce64751281cf3638af416d41daadf7508f38ca12cca89706b3b5f72548eb71b7889c0df5fdb68a5f1468215bdb9723c03c3d61bb56cf60bb8262154ddd9eada36cce1ca20836832a422e2a019af81a0e198f97dbcf6d4712a381b77fbd4343f6f2df8f4b0f5fcbb4ebab5d95b12ae07c9f65dc1358cb692bdf25305f6521c317c4f4f1ee2bc6c76b2a0b7de580476471fa509710c6d817040ed847d8ebc2ed1cb69020c5e7871656f5500d0f4509959f590ef05f93c01cf1c3a55adc2b7b9a6c2d03f0bc1b8d6a39fd575f39b8f47e4a9efacb82c37f8f64adb6c36823415553ce1adff12705f8384232a69700c0ec98d9dc3f71fae09f2a801cbd167d3332c965e16a0524ee1ab6b68ba3fbec965dfbba752e8cc87f1bc9800daaf251f290fe85307370eaed3a8d124497b6b3627beb57929bf77012ac6e883d22355a2a2b68e3a242bcb3804a22886799d732243ec1b203927b770c17c04eab1e0716b82c7da453004ee59914f16f974015b5223d62e499962bd660dc62e0988aa17128a44c2997bafe41782c07a1dbf598c6a665b671d245ee3e3bef4a9e7c3532bb4af7833e0e43e250561b3e37e4c9fe39e07ba4d24efb5e37653fa2345001b990c4d13ce56cf2d3dc28e3f9eefd07494dd8b6cb9b9dc709c537335a748df84c73349fd8df13f7b98f66bb0ce1d6c181c81e6aa954cbd63d4f8f2e2b2043bedf1c08d41d01147d1146d8aacba7398ac1afd977f3c7041029743da06a4e0c5a0654476f5b1930893d527b257e7f40198769230cfded82fd157d10e43e221fc30cead95e502915f4b341a2839bb926426151c6a827848a9b7c4816c9a6c9e4417ae6170504de8a8f9962edba6a3cddaff6739299d2dc64119d08de759e43a5905a7089aa5595367d1956aef9234ca85eb4a0e15516876a2a144b334ab6388c2b23d297e64bf8fbfd542fba9f1bf679f971ea3998244ef8e6bac6fd9abf9b245882d99a2e35bd0ac2e87bc5c87f1728868e1a16319d1a0d77c4c6d38dbc67035e9652696240108cf75deab643cca5d03dffbe8fe21a99955c5d2adfa05f67c0b2286329197fc7a963a71287a3407a102be65bbcc1f6d92b71ffbd5c2810e5550f4220c340e2c10ecec8da189ee574072f33b8d3e4aaf48a385ad1099c627db0937a5685166d21aee25a60211a0a4169359831f9d56b8d12c8fce6376036c9287336064a20a8b8be50a1160acdbe45820ae56878458cf37fa17666a0aae0807199bf364b09f29daeabc5dd5cc422c3610cd9546e37d7d57104a53eefba986c8708932dd7b479ed8af347ca082a8aee33a52cef089f21c7fad64e46d761202f582036c1532a2990431de5a27285040d266d3a69feb90a9261e8b562a417c0e1f3b25171cc0162096f3406420a3131d67d8ea340aa4eff7d55ddc07c1e6d8ba980cbf1da5020aa81d554589dbeaf57c8c870c54e6b9a5ff47d6ac04ae1aec3cc0255684374b06f5cbcd629eeba797ed26f5ccecbf82ccaad438ae106fd91b65f387881c7796d20c1981b2495881bbf3b8b2d393e507ba8e6644f38096561d9ed0eeea60f3b7d3399a82e5c6e7ac0e2853fd6e357bd05f287007cef3af32150d375f8692026450ffe5c4c031fb04c51de56ccff0412bfc7935d220ba2809537bb0ba01759ca00e828ce4a9cd2e5eaff66753eb751742670dd53d27d11a981fbffd4b966faec29e44b34b5f7318a10dc049ffd02e4910b9cb29b46cd5db1e838a714f7155e633beb0cfafb6d3d85ae7e915f6ec64623f3b9e97851023eb192173316534280c64c8ab0c512214f1ee0a8f2972198dbb9a3c1201fc6daea618c115f328cefd9088e31d2f20e15aa51dd2b8198542ef577767bb2034a6d6f3091e83ea983ced67ce65a03589ac3454b67944f4392dbd6a5120d353492c5baa51d3f0737e4fb66b2cf61dc3b13b6158c0128fdec03532568dae9f668ca3f1db9c6a4c0c3885da48abaeb78936f35f740b1bc4b0152240398102be9b69c3a8165d02e4aacdbd729085a35a0c4b0b3687145c28a5cff5ea50732509ed78eedd127afa126d5f377fc1d7dbf7190be02ab4c2f0a80b7f1cb9cb52197be646749d7d46e1bc5b5e83dfbb7fb66beb0648a50e74913091ed39984192e46879e2cd9350440c88b1acbb342c3f3dadf84fa903c999979a5984eedd6941f13b9f0a71731bb3dbbe0f1a0a03017360f39705475e0b0562580484fa713fad86c4648b9bba05e2cfcf95c24f6c0811dd59bf21274600b9d28cd93c81feec89ad50c6155ff25bc0a77cf3b321b4a0b7a55d8b3fe20b88f71725088416951504efa1475da24ef2d909d16d4b62337ee4dafb6b62b5691b87b0a4500a48bfd4cb72fe250dbe327b12d9252ee7cfc2bbd989b0863be8e4674fa401aa7c0c37c684234a1ede78971eb151bbfaa9df786829bdce5b7791a47354d8f5ebefb195d6db55cd911fcbb757ba8149ab17bb3fe70e8fcb69ef746aa130e7a7d720f4f0c0488462a92f95325e73b9bbd5579bb60d5f0ef6a38a8ae69244fddd27fbab82852e1432ee071c65be18864a4f59e12789c8ad687dac6a077570da6bd350e85e21f32e88709b0478e9528aff1a5a99e5a349a25b42ad72bfb2002b4a403126ef8da4207a4c8ea8b75fdeb14bbf7202d09976e05762ad5abf6f99ef2fe5d6ede00924f1cfe33f96065f09fa3865d100a589f9a1aa2d0c5a3e1c69ccdbcda205de25be895a306aadb4f145d0619493d24780759183e6b936759d2573703c917f2fbbfd0c27f757e429e365fc7982bc9cf3afd40319bd17ae1f919fe5bfb268c51f89dbfc5c8a7c49ab4c7de386c21c83b9d465964194dbc8ec6c22fa1dd49d93990a025ceb504fe853521fcbb16d7eab1d9a4464ee0d3156c59547bbe5c734a0138d9c8edb23f581c591d89f869149e63e3a3ba3b70b15368cf3f4bf7b937f5e67669ebaee8e154855b4c95b59f17fd96917c3e1656c9b834819680009e72ec20f0ef9afca08f35e3092e46ebc4c200e73fa83971c8021ddc15d888ac1c81bd72fad3e9a3419a93865068a7079dec12bbec8a6ee3a062eca05525214c71452ead64de065f44b2cea1a080633c96b51a97f43deefade46c4d03f95f52002f3aa1ead9dbe5e448e3783439f436569571079ac38c869bb1aa44a43541d64f5bf614736b84ae40d1e2db73659074d11c2e8b107cb6ec56945991d13bc03ed7c151f79848a27aaf933de03c010028eed5845690bab8eacd1cf80c8b54ea8153c6a565eb696b01f4888b9a1eff952ff87edfb4a1d012eb58ed02068bdce245a8e770f9450580ae7c53d726d989bbfbee98d92846fa2448e7a46e3b7597203fa4c38056b2a81553340a7868f3f52e8241bf7040a5257888a1c7009b2e359ac3fd1f55f8003627de13b842725446e591efca942b05307a7e177f5129bb763b63f099eb734272854840360334a85c9157250ffe983a5243543c54adb3f0988b27383d26de6417f9c9ea9b4757705876405785e2bf4ad9cdde09a61d07c6467e255446c851f73d9ea86d77a57352445e8b88ff5b5d3f62f4145b5c785a5ab45fa5398865c980749da82a054a37e71ebefa5419aea650bcae2dfd5ab0b59967b9dfa26ba3dc5034377dc67dfcb68791c50c6a166c04f2edabf8df7cb93abcfa5ede32edaa062a6a90abc9a7b9486332246df784104b54ebfb3adeb43fed1e74b31e1101eb526ea4935f6d2118a91255b0acf53e6837ab3f401bbccc30fe7230be6e24156924f201d7e6e3ee4c5248a30191600cda6e825cbbb477ac254f1eb772f6b124d21270e0cf13a48f610567fff2e48bfe972e95f31017378e612ec6fe1591e1f86e26c13088b49f97cb9844c8f61dd95d500b2b84667100a399ec6ececdca15a992c4f498814bc229bba8e8b1a124fe166842f613ce6f4e0de1e4986b1ea6ad3497830f38ab532d72e5a01673c842d713c7e642e5b58b3d4de5ba17c17d0236b18cc2d58574610e43c97a256d48508569b7ab3b1099c35492ebe43acfee4f6ea10ae4e03de1bf13eee4f9bfb8607f9b187f8b081a3719c82f5b294242e617e59f3cf00bda0953c82d72046df002b3ea9d69dc6a7fc79da17b9e8958a715ef43dca3599c4b02281bdcf60e3cdaefc83342e987fed3f3046f42eddff940873cf0742fd14414b58eda14098cdec2a6a065c2f896e984c80396e9050c160eac7a987ce9d24a5ba927b0549543f7bcc3e0dd7791316a840df3a0057edf27bb7ac33ed95f9ff74d33eaa4c053fbfacb4ad312c4ac2cad9c178b2dfced4cdbe32ea07dd0c4010864220694a2fcbd286d2afa9d48b24c7ff69fbb21daf780780b03410cad58d317a6c1bba3bb10c6c0639a38eec927f64bc48193e0f4a9256c07ab7334fe3fc01c270eccd59293829a4dd5dbb6e30d17496c3277ca32bc2e04bf8b80b65813524728aff3c38462ad77137b9984551cf37e43b869a4a4d3b5a1785a21fb8f50556ff48d5baab511a91bba6429136417cb09fddfed07024b0dfef3bbd319dfcb1b53d9b51786b876b79498b8e3cdf7893cce4fa5fa805848369906836a73d788d5823b19f681ed923783a9d0616a2d30eabd5a1697a8691470d786bff7c4a685c6c35bf46feb9688a59482fdec62e3e88b3e095a22b6c398449a82e8a306bace3f819a1a9ed724c6fcba110584633218d776bbb47f78f85110a70b0b3e099c223709ff21bd4c02f2495eb6953c07883eedf58304be5b6c7ae77c137fadf44ce8b6c14b825c3b041154818f02f2967cbdb3c86f8b1aadc3449c204f289ec75c8d044b0e8a52c14e600e603b2ecac81f7d26a074028f011fd8f15a3053f3866194101a3e598dd4049b35ddb1d9a481fd5b063331661aa04cfde0b7837187a83ce05dfedd8b5b2c3799024fd3d9ebf9a238b47e257b60b36d1f339f599a3ad16d4acd90e506d68ba4aa35d84f299954095531d75bbe4f0f3cd2aedf849544fe0be7825092e6a9e29d7b98254c0e29d0d235417c2adc79941ced7d6bda6c2a21d542de643cf600a8f0ba7ccff6804b7c683e1b67eea1d92bd5804447c9db475b8270e28f7bef71e0d4f4f216a3d4fe79eb473a5f502741523250c3d9c1c58fabf94297fbc17d4988b3accb88b39c1c0c3406e25d366a12c89019f77ee270bf207ccad0b024e2288c8ed7420ece794f63ca92a3a3283bf1aaa9f4d973c9bf91ced5687326d73e9b543847c8ba4fe175e5717e62264b8bbad88a6a3b840cc5cdb8b4886d723fed0ac5e2e93f36eee34c05a8dae37c7549faed5a5f213ccc379a4ee8fbde71e765e7991b8f17a36097399a51a71caa5096f78b6ca36dceedcd3b890d5c93935ca7799998e8cec1b9321be8dab7ebb840060d32f3e8875cbc41c7099506defcf4349199a8d804f6401c8f35a4a261cd7c39937906e59b5048f0f13b77f3edc79242120e80a8a3b97e1ea91538c422fac0dae76c107091e6cbc272a1ba13efeecbf3a36a4c21bd1787177fd4f20e6ab5cf51af34cae636d2405296ef82d547fed60a760b588024a051212fab8430a050a84c209a459572dbce42ed51c9d2e39e96c88cecb5055e7062e28ffc786c7d8d8b820c72cd1fcdd9fc9ca4b45cf29840e8318903b500729090a97e4eee51e2cd210d6114fa92caa7c9ca91401316914be425ea2ab5132cbac6de90578e6225e5157edbac7838b4d55a1316bd7649222f1a33d62e13ffb6dfdfc37a6c65cc958bfdbe1fbb2ec808a07a9113e667215760b26b74ac2c5e5e184b371b7723b5bde6833538f0145479ea880f49359b0f518201891d091d48200994ad8f5be640364fd2c7cc54df6ea57bccdda231a4da44efe0fea4eb1d85f7887bad1df9d7b72a99bfb04263a40db0ea0d27f35497ef30a58f765c4bc6106e4f10ec9f439214a48dd894766b85a785f36b2dc7de48532a5a9675dd144ceda922080afbdcc0b5ab582433a43256af87e4b135da682aa58707543c2348229bfbdf6fde6f91cdc7e603eda1e53d6cfbf251a1e534046305b2c5c9767b8649b9281643364fb262ce0944b20b9cb0fed7681eece151f3fd529f650b3582c20f769d239225b32dd266a63400bad18b8264c9ec63de33647156f9cf50090a3447fd88d250a7db3616695a22e588086842c5a723719d3e432e031a2e659d9ca7f5d8eabbf56b41aa871b789ba2f249bef67b60c38378c9e17f9b92b056b2981570855385df2b63b04f9d56cc3662de9928b6a39aa7091f58ff3716a1d9b02dcbcc056f53daa0a270ece8e6075f07a1128e23d5f788bb6079c971ff9511bd5319a56a2b26de615f920137adfc3e037d4574cd3800505173b70dad55ac650b0a233649f985bf179fa9407fb9bacaa24ad005f1504ca16797d9821b09ab13f12e6277da4c7570b45866b1c804d238205ab367281cf917faabe6dca1730b2440363c90fd44fb80bbe4f97fd3cb6e33d5d1177d8e5f573399d65215c81427ecbe14f2792d33504e6c68bef3e491be60c1397fa707aa54c6df59a01b9bd36ebe32f94cd088f4e4e69a9dfe561850e76ad14f8b7792a75e7a878afd9d67b0d195538335b84ded243c3237ac726e17418f75919f1b8de4d4effc4507f47d0e6106e59e069279f08ead85a157012d5af189156a0a8942753f2c96a7d1b1b32c1983f1c68493e73d73469b19b6798a3834a7389f5fc0f3e59c1272e027aee94af2103f4d4a33fc2a0f7551a53f9c73be98437273e9ad5371029ca9cefb46b642fc93672eb456f7f882bcbfa23cce67be8afd8213d3a01f8346bd15c39e4a951bb2cffd08c62b54a11f6452d634ec6463ba42375979bd52c73c7fb6d09e2efc3eefc9c80159bdcf655e69cbd7ec00ec443a8776a57fc7174c6cc6b12c13e482752ba6ad5342d41228bb46e3f305598c527a5777e6c9bf2a1cd0a7e719643b271b5522e5d497883cb5ba80e17d06beab6a84508042f20a4b8bc6ce144b10443381c4d2017a291d8bc8cf26d728b9aba037d2280bc98ad11e78babaead2b5d064e4560469abf507788307c182a6562c7b1821f1ffcea0d1e3ea859d8494dcbd014a37e03ecbea4def2d80e8daa6e226327b48d0eb849909f205b4c9152bb96de552731f935410f741d21370f06bf168983b799b34251adc571bc672b9af8621e204257fb5dd113fe34d13ee475b77697f8fc2e2e4ebec1b46425b25a2c6d6d4fd232bd9d27ddda3a376a96fcdd61f1d60c7365693508080c7cfd93172db58b878e958e6bf220ef2e3be86ad30388ebcc7f3b6689343115338619d3aeb0e94b1bfb3586dc03f68c9542bcd412473bc37f571bd5062259adb833d2dd4f8cf25e2f9c5e3f993c18a9ff99aab0851b29488b1a1d2ea5fe71dc5262ced3f88dd55ace2d7af9e1b1559d1f3c47d5dbea97db867676067691f313d7a02a8a36a7bf7fefc07b15aee59f7fb4e32b22ef40892961ba3fd7e1dcb8860ddd48c3065674d1c437ede22be36f2e0f1b803df69ba56aea95f51bf41dfe9942df9b8b0e98cc1dfa546571cfdfa16a06326c624228ec94c116469c3cb2b519b9adfb3495ae7c4407e62c61d8265b8f8443b0fb286bba4323c8cadcef67190d1cc577a2288a4f1631e7eca2414c26888df029e23eb749d03eb990b4a07f935619539e4a93b1de16e3fe54cb2fb30c3c760c88526914c1a04498dce99fff4c54487a96d765b8e6909a425100aec14e742e0b85992be0867720f88ef7300e471a92da911d84016c2c44da221b73eb1c602a13cece676900b8f66417005885a3fd7fce0c25af6a0e4e6f26d8f1f1b6c732f1ed6c82b644fe8c4533715316eabdb1b377f5826253add88a6403499cb3cccce63a2cffd2e52be509e509ccbf2ba088f4c1e4b60b096af1b0d4403ad0a82326f0b34829a13fbae9844853f3c5d617feadc67262d98927980c3db55d6e901a6a09f54d24ce48473ccb12614e085cfd31067b67691accdfd692ef3989a3c7364bd7353c805e4687ba77a2b0fc947874c4ddd8f1b7cc5ede59d3576aff8f09597992b5a9e6f3f2fc4005e3e8257099767bb78163ddd908d1adcd8b974f63443cf51f806127bb91c2f1b703d4c308a58d3df59714d200632eb692ac8ce5ba69197a080dbe48df62f9ba29c35f4906fb1808dae7acebcf958a9ba531019d5927e7e25925c763855ff69c805a491708fb2e53aacf5f49c50b2cfce083c39bc9023a92a705ca201e598806a13129920f3e27f41254f3193d35f350029c2b327a17912bc76214318eb97ab05895ddfa776cccaa5a3c82a196fd91b8a5f1d457f5ccb1b8b9187121a1e2888bc72025967d607945149d13b3a5255ae2ebc9a4c7f1cb9a3fe18a40f78ea834f2c9310f94aaee413e9a503c7ae847f06d5505f0f8c6bd12b3d6fb10ecf8b70046ff0d6f318b612195ad80423a45bc4467f0d9da6700cd13b1d67edadca07ecc346a28aa3932a00e8c663150c3c8f7523682819d6a4aa84681d505c70808b09f2091166e2437d7227f91223d8d22fa7333ae0a3caccadd7c2d5d87e61a7a00d8086e280ed11a5b666b087e7f274f95abed51d7e9b5f9f6a403e3e190fd80cc9d3542593d7a51cad869158cf211bfc8668117cad1f8e9c8b51004869f5f55a596e90f9e9b444172436c5d06ea0f37b06467ee41cd17bdb6e22e03b4b1be178f6d56d5d3db6316eb1e24c8c458324b0e1504232c681c0509bf1d7542577819326407f164e530ef3c64e4e0ef0426f1b1d4655684a465a47a477b0c165e1ee7b0fa53cf7053d3c172b6d43ebf60d7fd0c9d10f3384650e4370492a57909e43b7953cd789e5a89ab534d1f7ba20f29bce9c824f6c9a9b8ab6b3eabd35f60d115fdff725e11ec8eb559ad1e8308e2b352a4a1cd30dbe2378a8e9d50cd31f182d3c2d25781c68970ee1bc1b32db9970c3000d9bf28f84723680102b4c464129105c37efc58257c4796fd23d750bead874238c8864e554d1e03b69c9ffc1efd41ec09b7487aef0c49d9bd96a43c6197dc381a74ceaaba915909677bb7766a10ee7e51cb5aa2a45a76466c9da310a32db37d2d2231196b48986aed8016727b4fdb914fb7c0a61a11fce2beee0d7a7041c5fb4085cb18d8a2f0fabc928a5a679734abe93dbc2116058dc2a29cb8dad77296878a22d4b113b363ee8fba0b3403d74ca8843e1e2fa84717ba4a8c7de57e18316c5b211d14054a5ea508fe06a46cf8c1d6f35098377a909a6d7bb78156d300985bf0ebd3a5983edd2e03ed5d659cf3676cb5ddd5fcd43306c6c9fa2178277f0b388b65e3916c3ae9c3052029b9094e1f684e705e94905b93019c9d3a03d793ef3b991be4e1ad9d3064500178f9cb89acf1e755e520a54d9897a02761d2cbf4cc65153a6b9b1f58fcf0f9d9da7f74d728e81ed42cea5373c6e15eeb64aad58a3293ae9c266fd2eccb82693926504bce10059da1d46ae546a78bda5cd5e98176e26a547345c78146d64189f3b9523281f4c35042da7840e188cd81597dd17a48932ee86767118d62a1b505ca1c7f37cd4341048684522d185dd9c70d64015be6571b883137df6e52fbea13f8d9ec35db55d7552a2c39f5b0e1b2ebf38721565f6338bdc7b364c8d970ea4ab3160cec7d798f2a3045ff634cdd67a93b1152b4abeff20d9fd90390802a4095120d20de0fd27f4ec18cbdc7573f46daf54fd6d2a461334f7693310ef333a3e3c8e5a900b4779af11e9a984760c680f79f20443512fc3ee5cc2dbea265e260cb281aa93964d913babc2306fe6603a463a9c2844a339572bcc5f61ac616c663e13555d1ed087ece787dda8e36945fdffcdece8b951dd5610baf54635837c89be30d06e4b4529d98551c031ad977300aadcb8531c8e5dcc4442e47eb7b563da297e039609cc77b97ee97e446d7a830dbbf61a57f27765bffb9857615949d613b18dbf2e9ac150042a974785adddd6d17e1181826831c2fbdf41e3c88d385587f6a838af9c04451ab9ac46bc2854f0b989ccb7fdb30d6cdf680e12632536e2e234fd540fb335bb552bb5632b00d836baeb0e6a0b4223ebf0f65218f56679e2f6c015131b94c7e7a7c2269661386fa13700faba9ef89bb44a85ee0a15cd70a14972fecfd571fb53ee850e11a5ebc09219caa006984cf6aebebbe3eab0d836c1e59dfde9d4cd6e7768b267fac1e5306d28b39c016e0e3968e043a6a30c7935bc46b48e6453059597a62fe512494aa7cb4ac42dfd520265605be944c878f2be936f63ace15cf0bb971acd5fb52bd42246942ee9b68b2327a3f3cf6dc6d0ace9ddc0bdd282ebcb41c41023edb5e23f3846d89daed304c1304faa57c3f9f427e13f7278b4139c2eb9883b6eacd2e5632ab5505d6441acb0aa255f1aa459e44cb69dcd372832e000d2261b75b8b411627f048c33341b9a6021c977dd33bda988344be91787ce905afc7533154e40ac4c907c844af910bf0d33921dd69a9abc57df680a2ed37b23ea994fe9ab38991c95c6d4038aedb82251395250816db3a16374f998d0271dbfc84350f2d3aa80549cd1870e5cf0888bc0b7bad43aa5c7200b6cca11999c2e46e1a735861800ca032753f959327d7f135f6bda1045e23412b22df97f2afaaeb52f8ac91329c79fdf6186fa561bd8e52669e0c0f101d935d19d783372c2955e397c62ae5c051103912b74b252b9c335eb96a1bf4a0ef62e783d24958811db00245a4f9648f9715af0586879c24d80f8d894341fe35d24fd54526dc6ee7c9430bee45e4155a4b013f60addbcb5e0ea033f810bfa06813be4ca31e3c50d1316928163debdb7d83cc7980738f4e214a7313e0e31302f9a68afb3abdbe34d0c61e76b6465e0d1b613834bfb1c223dcd5864d4d2b8cf57dbed781cbb8775399aea14b6be2580bc6c8e71369a44c3d2e6a4af44c42863525abdae6a212552023e3ef9097061fb9933ae80ba38174c572d87739c2e15c634c66a95d5d7cfaba140482c8826942b39c971d20e97fd87448cb164546820bbf4c2031df18789ef94a80e25953d09397ccadc3bc37c4da7f5b11475ccd55c32791642833cdba64e3e7907c50148d8d6694461be25d2c3ff79cc3f07a69c414995472e57a08987e1a8a880ed8ae5bb719321ab9bc1bd28a61e7dec09070204cf6b95414245954b6f9aecd7250cf3b09d1c50cc1465b808720d587b35b8edb0ba2b3fb8d9cf8d90c47c52a7f92438771741254d9534e7b7d58a38a9a6e4371501183c533d2381715ab8b4fa081815f1228a542ce24a4a18944127dee4102b184fcf2965377662f227c181c22c5eaaad17d4369001a3f5b12aa214c4f57a210bbd42923e65561e73052b2bf410cc67cbec35c9ccdf149080497618ea6ee27bdf3243a2b50a81f9bc0e7da63dd1710f32b0f0d1117265deb988f509935eb0fc7c1f9fc686a6ac56de46176067a2b10b67ec1f86f67a99b35196f04a7126360395ce2cf7fdbf864a97f859b8e1d929b955d46facad70ee5950c3ebcf333c8a67a938e7d021c558921e3bcca37ca478bfb882bcba02201c71484bb1ac909082b0aaa093978ee2d2a6cf61727a4d4262202011d75c47a97fa38d90c8f5ade19211e62f7b00987e8a18b4ad0f3554aad1232bcf36022fa85cfd388fc6a2fb8c8dbc2bb804e07cf2d2df380af7f3a12f2ec10f1f75e2fd8d85c0e70d5dd0056f48591323c880b47796f96ff2fe306775d7875bcd3a75a12c246fa9f77a14d1a35825227cb81989392b54771eb311fee8df464f3777bdfa34b24294b25f56d8c993d50534990a5d651a72e70739213b02ce5b197b67d870a51a78eecaaf4adae6291c2d43ab18ace83eb0b3f00f25f65744241b3b004d0d740832b1c8c48358f907124617fc194e9b3e58f4a1e16e2774603a606c3e2a3ac5ae47a225a4c1fa7ac3c80bfecb62e1bcd6493ad90b71529e1829e0aaf395238a4a770ad841c94678e4c24f21baadf5de4acace3126763b123c4d6e1fd8a6510fd77903d8be9c1e3c0a32a37fe046f9dc44f2c4d8acb62ce27f0df0fb8390e764771aa0aad210b0e99e742ec91435407ad2e187738a9f32940d8e0c94980a6481c7f8b155ddde0c3d320e555fc7891e7cbc2e64f2eb021dda8895364fbc93027b5b3ea36481d2619582920321989422fc8703f27d481822cc38ff4be7128bb027444aaaf08b4709954f7298ea1df44739db8763373a4102497eaec9c9a503aeed1d50776b0eab7dfacdab88cf21baf518047f557b51ae8126bfca49d5b62edf3654ddf1cb819c904256d07cd49b2ea2439a1fd8fae518fd48beeb4ab0baa13ed16c09262af6a2ac7e23846651359393249c9eade3df31293097094c129cb2f0fea21f8abbc770c47fff5983c5dd6620bf0e1e4cf43570cf81cf5983d2682ec8edf745cac445a47f472107174c4aaa45d6c16caa0ef79f02ef0d18657e2affe585e6f0ed2167e191e37042d1ae20932d2e47975208b2e87d627ac4a1d5007a927baee408636f8683f0a99bf5fca76fa308222aa16ecba4b26b0910ae22a0e8f162825bb4061a6e9025bfc7f8bd1a0192d2c37c5eb9f1b64698d906cb9c202734265ad3af59473b1961506041d4ea8937","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
