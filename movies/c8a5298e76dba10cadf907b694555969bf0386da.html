<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"28a94324fb9fe11b0008e3db9e57fd15945480d920345dacc5496f9d3dee14710f0b2b2e72fd05d86afe619ceccb6da7cd13a0971e65728f7b99fbeabc6525ce00ca633f8f85e2491a039e2a15b0f3f9c5776a15837abf231591f29afa94e92af763b98cd17031658b238cded00328b10d5e197bc961a91762c64956ea51c3671226aa1501d36fc9ee3f1edc58cb1474342ca71bcebe2385681bbcfed183361d67d27ad2e89d0ad20dbf78aeb96bb63a950e05fc262e25785ae100b7ff92c6c97d6d2323e378e6b0317f44a5a0ecd1e44fe3bbd84a81bc7b3d28bda6d18a8ad18235691508999bed128ec0811e437c7a8257b42c7601a6ce26adf6b982d566c07d488ede3f292dcde89f92e67a0534ab15ca1481ac01d62928bfd4bb6f84766b38953ffec5f14b7304c98237727468399eeed9319d934c930a0870e60bdbe228b64f3a81816480dd1ba324e2c9acf6bf22c75aba11db04b5cc0911e91911ff1b51af1c11f081a40bde86367a246b9602989213840fd938189dfe6275164f683ca1f63e4733fc8c5a418b806c74f74301e1819bd3cef01f04eed361fdf622ad9f429f331a90f28290e9749b9b466bb93b434e4ef35b41f48fad7368dc6b66e2ad7c5e017f5f19c67d84861a0f89cc48a42cac65aef54f3b183411d31c5ccd076239554b5e51c3880a75f0b1af91cb5d411f59af4e6664acdfcbd364e5bd70e65d80d696e8b62526cffa65c8918d84de9c780b521c2fda08900f2ad7586b781407e161f7e9125c673b5867265ae434951998982180bdee5a4d72ade9a385f8eadb8a17d0fc840e496b09a8736cccf6c0e5fc815694b177fcc6b803c8d216c08eba136acc6e3f5296713e7c9c471cd3780ffeb2cfe9259cddd54290991098af543662c1f510eaf6ce53889685f061097d6f22b59570b9d89e14c0655d9671412c92ec047584c44a79bf4ae6ffbb3bcb5978b2f7b5f76e86c5475862d080f53317ea39e10032601f5bc5b676e7500d6b9b59e80e6ce56fa58e762b2619312100a0f020ae1526019882071852882a7bfbbb883723ca377d1a40bb452d8cdfddaa0fb4e9a86ccf59ea572fcf387d94991c46c290ef0093d57307e992c5fa62eef8edfc79c4c930474c880ab68457024b4989acf6b4f29e670bbd54b81728779dff930db33f247d784103efc371550f3b34b07543dfd19deff202fe41f5681ac37acdbaefe6026b9a019c595e1ea5fba1b3e0ec609d4d83bc4e56852e16c8907fd27cfd8d24fcfa8ce9d1c2a0e2a40446ded0297f451e237ce9fceb8b13d32f5e67892d3586e734c242a7b6c06ede7123017686aed3c050f43aeaf5233e9d77a99c9c216010197473436a643c80c7c73c15d83c86f213ffe2d74f7dcb781cb6bca96f62f989bd52ec8e0b328a414f2b74867f330771d4b40165c24d3c3ffbcaaf4a07bd846ad76b54dddd63aed7c77f21db74ebc07f49dd88402568b4967b22fa6ee6e6103b895fd1f6040734cec3b3607dae568a7f61ee6d6ab35f2b09004b6b26cabff2a142c867f1e2d643915d915bc9b094237ca21c7c570952514d1a95b6a972e79eb451171e08111db1c12be4c689915b8ddf4f8d04e04783de57cb9170b3761198235d4ba5b3c0935f596791658ce54d2f9acffdc80ec33b6b8dd6518464fdb05277770067020b12c417b5448b4a494d3be4f732faeeaa6f2d5532d61b341083b9a284c82a766f59e207d1e9b3213e6b8cd607d45253a464d5468bae76c07691b431c8b712eb2dce621fdba0e65049fe8f41b99ca27f187f47a1fc6f90c68e210e6d6b646a7eea67ee14cca3c39a7a734f9761ce5091be37414c705bb87e8be20f727c2e0966a67925fe3bbc49c59bca74427c72697a66874fdc662589dffd069043748f0f100aee6ea1fcc3242d30fdcdb898586a6a67d054041ff9492c8c22becedab05089ffb48d9fd86f4694c066a9fda7bf10696402b6c143c4dacfe439113d2856f958c74baf48e615ef46be7bb005277b8449916bcbde67fcc5e6ce16ff1600e9e5932a79fc85c28f888528b37a3c5e6e0af0bd6c5322f293258a799da41c818febb076f225a411d1c74daf352689332cbc636fd189142b610f5ccb32daadf8fc405e28efa2e299e72aff18970b604d4967f31b9cee7e34d13724e8965f010391674df3fc99a2ddc8f374892396928e0222b6ef67fd857da26c2d2a88d6beda760a520c23b3265d2023b13576665f25dac5ea97b3c7dfc20f5b24979ad6386dc04025e1ce1992d2fd6ee78cdbb076077289d1df074c58f8284047cb6725facd07efa4da874977f0b48ea96b7fe89c756024c1805f5b28faca2d38bd0a2e11080d08d1a5b5df52016133ff7cd1d7691e87a6f48edb113de7bf8e0131f3c87b5cd05102168285321fd065218e62011fe0a96a47c19fbda46e73c59aaad4c5e41a80ca04bf034f0f5559f870173b95299d1673a7ada1e6c4366fd1a2be2709eef658a5707512d8ddeedf7268beed02880b94599392f508ad4dee9f0437e60878a7a1ae201ae8b0094056f279fa5e44c8f6d26e9fae5ce63a3ce2f4a07bed32cfefa8270d4fafd8f023db05ee59bc0a65e9fc98f53b69074d436a5d5ea368579e34dcaaf110032cee4fd616ad09da844586c015111e2af9b3751e00e29e859f788c8963ca839859975afe741f94671f90e5ede80bf6efb5c0045272f15031b0580121b1847a06b0f865bd199b5a2e71cd2879f896229ab3153d206227ba0c08b4a56b905c67d4e6aa51288c61fe94b3c5de7e9769200538431f57ec86af337096421e05e30737049c163bb199df24a6dd20f8d9c3f105fe948e406bd14db12717d938694934723b5dd4d763cf561b6f20b0f70dfdbda39cdde236fadec17ec5ad52577561b0b699d42a766b7768e6278db9c2020a1d5c084af6634b23c276c6ccd6c14c339fbadc38625ea3f6ed1d3cd1bebf6e55467f2a6638d44d38060e8bf9d02042ec81436d68db040f22080317cff82b3e04de09d0e997f44d95a25e6786b7bb8074d850a6a6af2b984d2bb0a5b475a4c3a576e7def029619d27f0aa0be61e18824080d804f6f2d5f2aac2a09b7e331745ea1161ce0497ca6333979e5a6461b07ef0ef1ae7210a67e766a6084c47d6746168d6b2b8652a121b53d38f4b6aefcd73bb7f9982929315f3f9834f173e1f34a88f5fd2e326f02e922012a8cd82da61fdfcce2d05304a5b0256d9d989ea45a5b56e6021fc37be066147d2eaf08f9aac6b7772ee20712b177d96665f98e30b7e70a8ec97202ccfc10d2779a598d7ce36875bd00eb775590980985d6e5def65143c8bb67769d88c3c27bf5c74dfa1af715bd611c2bc16d1a0e6dc118669d34982189a406176a6d821283abb48c40602ded6441aa10adc49556a4d5280beafecb6ad805191f37226860e69ad5edfc5b506bd46b1e97ac2098f2e3b7d95725e72f649a572a98a9699a5f2db22d4760c7590519e2699da9af39248db38eb3e468ea990b324b043846c2bef36445b05a92b5a36e5c67c75567a89351ee5f6130e0cbbe75a5a8b7d6b61110beb9b6873a23b74f92f73bf842e00b6424d29b338c913c6e4e80b8224bf64cabe941f62af0f50cb2530029067787dddc0e73ffad5a4aac673de0b461615b424816a9997be0acf30150fd4a0940fc2a115e401dcb0c0c91917d46e4a50dc2e15e5480445108ecbba16b90561a6d0f5f8e3a901d3fcd045f3d22454a152a9d4a7460ee538706e939983b5314081817bd44805caa445caa00c69137460ac81246da66773d4c89a5321a99e7228971f13aa1a13b58c9b240b33ae362903411c59907ca49c3ea61b407e8ce7426bb9f18af9a90a9271095e032d3539a4f85b353b02008cb75db4c6d1e97ade33dede8f5194939f161c46d682040d30dca79e9eaf0f77429e08456359014d360e16e4e77cc5a7374e9f66f7170660f8728ba2c55851a0a31a5bb13d89df85dbe5c235a025f7a8cd34d408c5c78daa9d45cb99d3420cca052fe2e7d3ae80b69b39eb94a07b52065a4c5d33ea27b8b25c3abf54c1280d3d67862e127adfa27eab8ede402afa65853e3af2f9341a4c30b6d6fb4b94f31b72db8d3f1957e5460ac734383e6df8603c07e24263eb27765b09b2d7dd6e460e1db3b7e668c3856b9049b68596a5ca1a44ed3b4f44b0f2c8b7ec40229ed7d7c571c206601558d2a073ce260309998adceaa21dcb6e67b88a985c421622c9ce74a05ddb4672800071d52bbb79307d84f2e5a158d07ca2588ac8f0754ce67a35b5ac9ffb01a3c09145f67c9fd227bf353bc63dcbceba3b574ac359d5c7ba07f3b0d8971c70a8affbcc87589ac9c9e74975dfe81e8b2dfa0d2476b03a916b552728ed9d53fa5b1302ac0e78b0ded29e3d70dede6fa1057bd60ff413a4e5a10a011565c5ce442d02569b07ab74a936f372b59cb4dde98422b657ce1efc0daf1d703d1cff7146e1094fc77b52dd01de9db0ba772d27109ff4dcf2ae464bd03030a87ce0099389961fb075235c2a757c6d0c7fc3c1c19efeac434b1f0248be1ed621a4df8119550864b90bce186e55e1e6ed7fddeda87c960d0cb1db6bfeafc6cf41e9ba4d2db8a100fa9d8cd7521b5bc97ab11f99ca3b82c1303caeefc348a776b7266e0ac37b026f14fd0a55090b45080e086f5d9da5192accda818dbec66b7752d4da087d41ebbebd4d1d1ad79049dcb7f8b05e57414c7963f57bbb75cee5849306c8b506078ccb306cdc5660bcc42b6a858583866fe13cad32cf286bbdbbb76127adc9cfa0d8fcfc57222e96bceacef6a2fe31e67c28bc343cde3919eba0693c2244f3586a6701b5c47a1f3e4d970b6f6d7e02946db635ca882c61aa4f670f39b184cd1d4ba3d39dbd358edaf9669c0adc97514573c5f7d396fe0efb520aefe7140ff98390b29ddf7e7a321909afbb6f6b807ebdc839d97c163455b496d53527cdea81df70fb1b2159efb4a8e723b465e392471ba7914589aa91189e7e6652bf66a4689210e79cce7d8cd0b272aeca1f28c68004d3b614416dec630e45c4d39d2d9d3e58d6c7e00f65a34706dacd911578c70f4c33a89ce2b820420bec0c1f15c7ff63c787d9672ccc583d7deb1dc49284f68876edd48d33a74b9e13fca4dc78d2b7013649b4837c8cf65d304ea7aa05fb90fe55116eecd0ea2041244c7c7364da7f06abb8e003d30a1e68c914d8526144cc11d6c1b8970fba6f943742ea30fb3b360f78e031028912e5074d4aec0c6094744a2b9f05d584c6ad09bc8d950f43fa2f1595dd45a6434a2003febf4ece73f95ec3e305f07b68fa938456e9c6b1eca16a1fea65ff6b6a25c1349662645e56c4190527026c3ccd3aa4259a8cd492912dc3f46defe1984b8c6d4082e523614de9cadb397c2f1eeab92c5f420853a4705d546a5366c6d3283b6c8334eb64fcc3c65bff7eea745e63a6be49f1640b376b7393d5be8c2856c70be3839675eb35d5660193b2b7928b486e0cecb3c4fc96d703372b1f3f74b4031db3fa21840da1403648d3407444f5e9c17bda80dcfcd40990f75e2919926ee2e5d46d0d8c9fc05a4d2df5508b27843dfdb94e7c02d709596d53765a6edb7273630601e1ab0367fbc53d55de3e7ae77cf5952b032f55c665f44ac7ece1f6464ba5c6b17c72eb98a3bfd6af5f08b3aef07df912a79b3af242e3a75d90ff5c2a6d020bcfa01521b145c3dddb499a641ded14e035af604a312fa36b31a89b263606f9ddccb356b61002cbb12e030c92b8edd2db841f4fd72ccef9aace2b23d8e9ef55ab331df6ec7424101758c984369eee706e3da237121a878ca3977cc34e4fe7b46c07c74bf0ea8b8aed5c2a81f93aa23aa4b0b429cfdb029bd8ac0c03d8acb541837a6783d9178e5727218a7f3a401758fc5296ffcbf9180388f6934f0a5ef0d636ab3000043370ee7efbc8abda7656817e56223a875fdfdaffd97271ee710b6b1e1a6f542ee0a5e2b8bcf12afd9ff6a75d3e974d3b85a4eec3a2beab5c23e17237422cc4e9600ae6aa552029a653a95c567ae8ada6bfd5cbfc042fc443cd5f8587a1f5fe4f68d361e050a75c8c042d578cc87144b2d0486091207a6f8dfe393476cce49ce4729fcd1c5e7366dc2a12a1d631e33c061407356d2481e2e94d0d3f6f9426f29422bc8caa2e3bdccdbecdf4fac4b349a6313bc43b7fe5cdb8b35dcc0a7af4e5f35006fc72d77e7540bbe74106db1c05f4c8c367c8b2f910fc49103c188ef707db095815cb4c086812c41f929235bcf7d8622f60d390fc2bc9f7b980c2faa3dc35951a1ff219cdfc6a7d089bd6066e84e2e08eefb9e2f799862dd942b67c782ed7c030d194d9a8cf3efac6b4f32c1fd4a34fc2f7da5305d9f1bc53b516b2a3af4ea21c35e0f897f5b4380099d33bb3bb2a81c06ab72b704791a22da9969bb69d8b2f9a3f12878f7704636e66f52ca01acf622b69d7a6014257d5e71c22eb4aa517aca3a4ddb51ed18b625b3212a35804768ecbaee8c00f2899ab6570fb6d85823ccb95db56fabab6092479e08767680b108ff0066e1c9a21fe41839b10dd983dc6da2775367578b6e7a467f41f17daece7b0bcde96211da463428806bd4817431dccdb38814de2f928561c4fffe40d11710d99daf87f8f176efccd23c7fb31961685cbe45939db517b7bad957f80dad84a4a4ebec68c142057a672b8e520d2f94b221d92edd7d5e47adc75a1708e7a441d184187538bf0234235ed6500873a52667ac3654b6f1bd392c9f02cb957750ae1ef1704996961957f1a22defb284d11f49a59d85b54a99ec788d52eab83407a372403ad2a2fdf8ca278b6630ed714c43fa6c3b232f66e79769d9c04e3622acdbaa21448cfb16dda7abc191f3134635ee44e03269a531f9743bce4c6597baf23618a7dcc76ac69c5f9362cfb6e8ffc98341c8c53291f84fabcf99d211248c0c4b5b35cbaabb5f63802e406dbc17686a381c6b0700c560cd80ddb5103860f6659bc8cef1e4115f914736bb51365b97b4c3e6ddfa94a08b1cf0131cd3d18c5b2484b37139580a31321c36c83bc9f96135af68d152a1cfac7937d6dd36b1c45226f81f9401886923e4ab2673b0d9fac4340925bf63f9f8bba955abbd47cc6b228ffd711b7609de16c37f4dd68f0d712a1800e0a4d1ed5361194f8dd1acb4e9786842968d3bb32e359a64e3034fa7bb5388c0038f76ba4f9f94e44f461a19f9613ae78022e2879e2572e697c635a39b118e16acfc6b9964d2fe9662b182e0b0568e6739b716ddd4261fd719bd5b376a430125ca06c5d6e7f21ba65cac6d0dee94f2e2aa5b4c6b05e670bdf50f2a65d44ebaca942d6c10bac714cdd5629025d3863c621a6acc30de1cab8017be1c0b1e116f7bf51c2fefab9e618305bc8d7961206d125ad0fe95883bedc9bb3f58bccd48800d7dd63dfea37da070a04bb79ed980e6f8a889d9ba02a6b70aafed37246e0ab79cae15b141810b178e76ac918b010c771c19897d35fd067721bedfc56554fb57a8865b28307a7cf3e58f86caffdcd5fff7fb3665249c0b3de52b15df8814058d8ca684294cf600df1b488dc1668d23073830dfd23f6efb9a6c9e597bd51f89cb2d66b70de624343191a870221a798de832400c636c73dfaf83ebedd5be8cfad02ef9ac27bcae28b6a4fa8e13a513a9f428fbcfe242e0e523303eae7b0b07edcb3ff72c8c7edc3b59ee9eb784a41b982dc9aec256e63a2f3d6b382d5791f44f3287dfe32b2611009253748cf397319efc3f61c8d5cf7e9fbd0f37e7a313aebe27cd39622a68ed7ebacfbee57a4aeea83ab8826a121ecaef56cc74e712cf564e41ef4b2a99c37bb34793bfd9474e01fe2c01657c38c99b35a2f306a2a685e96b7aeba1a12db03dd7b045ee54b6fdb96ca75d364e9569848781b6d2f851e321894ca2426e451c23eec74e336e94cc7dfc8debdaa4b1211a617963b1313febb64535738691423b55947ba65a26d1c0cd6b9d6297d6006660225d69f1f81925d897cac2fabc68bbce474c6430925c376aad4389d4196183588ca2c40c13f610f7405e4f2869d6a47638e1418180e8684deb6fcfcd17fe8a6174f2ade1f5e49eac1c209a695f6384d6407ae3943d6cf62c91542a276e79b3053263902db9505f64ddeb194e0ae1e1ddd544d4fe4e77ed5a90551aedbd2446bc6f6e93586c0bae6d3455ade898c01aa74bc5633efa0b6fa68289067c7c87cc791c825ee99b58def8e17926413250e13843dcd3e398f567f3c96f152d573653089be57a1ca0f5185d259794b350046aacbd3b9370ef99f05014d5f40483e7942e4fc4b0ff096e32ff3eda317815e4b53af3124402e5ea11b3aa3369d4a4ecdd8c5369634e79ad6673b84de865f613dd45c499ef265a6f5e6283b6f8ecd4400b80351d7127319ca1d48be824927ff45f556d476f58836bd9f85643abbcee6ae69fd6942b7ef55d16919598c7eaadfac7c669f131d4a669d1acf35e484fcd4959db2a7b093c595fa21b8fa1998b41490c4e1b9daabd96183783e1fe94098d2c486da491d5bee12a36756053f64dbc05b95a361e5e4dc201b8b090a562d01d4f97908dd0a421f2be77b9a462ea9f577d9d4ee147c9377f827a02a581b0213e11d3127fc5ebf4542c15609db99ad42f72d8c5dbd278e8197babe6671222ae6efc3decd9ee12ad318f8e74606a62c724b71dd2cae1774558334f30726e0d5047b2e1c0dc46225e8f19764c422d8343852adf7f0c12040f9a43165ea5fe973ff66db3428dd702b0234af150c3024d04c863b098f7c19a99fa6a81faa54f55991f6101085977e3207637ff394c6d4740d87e2d4b33d44aa01a9e707434df5243d07698e894335f88de01778cd32b238c27819033d67416c9e6f65db8eb459894e753ab37b172fe52d0b44ca9e59a086940e90eddd6b84272c7f4e010c47a51574ed7c7915d51d811e53a4c7e67d1319cad3e06c369dc92aa692c864696daedd63af667c36ae852ed89610fec62af131d0b04655d3cd3f87a34db7c70f31024806f4205ef0450f41aa6f3b48327b55a0f7c79ad412990b63f0b8a3d7c24c3cc193633257d79f91712555f4dc5b9cdd8f9d12eb79d076f08c675aee1ebda9762ed7e6cc8953123cb2e84a95e7a068370eb1c3512fb1a1489a9013d673ee37a904e041fc0e2e149277d1108b4452a11f107f5b6fff6d94fabd44e52ec4c3dca038ff867ac33ea034f753d67e1edcd331628b046ef10d6e68b0b34c7ee6e3150277a839bfc7b1790d7d703c6100777559397a8ce9d277d85424fd3a17b9c006bfdbc5e2c7b4b192ebac2d5524bafe9565a3b739b7288bd8b44b47e31a035aa952f868ee9b7f048363e19a7ba01b71528a4ec6638120227453efa0014a46047170dd943083df51ce06c0ae80cdf91d12540b0820ce86b1ee98a1861d13e935c1e3d284d1b2eda450f3f5241efb633256d4b7883c1f0d50adbbe55ad24f6c0ed863f4a8eb656a393d1ca3277693efd02029d3441a6e8d5937c073a430f267758e1ce204edcb9e7a81b64d46a62b073e2d453c07cb1ce1b503c33a5907a72635639dfd681a45d64afeb7007ca219afc818661a4917f7a1cdb8a95118021a53d9b86060180cab0bd15b10c3a74d49b597e6c60caa47f4513c3b434a7e256de22207d985d368c061f4f37af47deb0b07584e76853bbf77205efc4213ab92e540a5f5495ef884df9dd16eb4ffb96316a655341f41a6ade56d9f373aa812f4d27fe025c1f2c5379a6b8eef7f74e1cc38cfcf256690921c1f2cf0770125c7b296ae497da4353cf67e7e50fd819f2de350c7cc6b6ae9239cc04ebfbe78d9777bf09dbe56bd3195db9d163c24182eaadae4c1b45d1ae5d8af3472602e9b1fb9e890762df7e88a8768f9c80e5d6bc868eea4a36e614d8f45772ebe2984ef8485a75a9967b6fc76bc3f224c74e65ec44887292609b407cb799223a6ad664e9cbbd592260852cb2c9157418606a8eeca0ee0277a9d92e89ce0e7f1fac7da8e52ed5259e493bcd992ddfe222f80300f8c92e3e5efd7a2a42318e4f34fe4422f7d5f2ccde9502fe12d50934e30603e115aa33d3d999393e90015f90cd3b91459e9d839613246eac271c67ca5d24ef8dac1cc18735a551df740ebc24e1744f11d22a79089ae5541709e0f1ab8af100aca1aead2786c88f6f6a1e5f9b4ae02b30ce153dfaffd76b24a9cf55932783a66832005d6071ccea7a5a18542e34cc797ca8e6c05a5e11783a2a21e14bb29925be412f82bbeaaf8004d7f390b93bca64ec1af8a4261be51a48b55bcffbf76333f0099991f626fcca36b3606c7711739b13b1d5eda07c7c726425528afc2cc6099ea56fb2dc5c35f78fb528613b579719a62229b08d86b91ebcdeda0594723b287d23a6bcb5239f6ab40f7c6a8d11b9202146ea93563d24d277ed87bb6d1b2384b67354dc3ea6d279419edd761a6ea8b228a5bc97072e00041cf6c2a6dec42e7965813271b051f8d08625905da058527d843f70a7d01fe7d32bf09317eaf963a20987fb86a6e42daeedf4bf689b68f6f450dfa49538e3cffccf6fe76466bcaf46081bf7a09958f1a2006b4d72b1db2dec84043196184c7edd1a89e199f4b579ce671502ddcbc561297e15ade0fe3f28073a9ac52edcf764fbae1de82be7d5e919ad3db2496746356b7baf91bf19cb5ccfbf9d72ff3187775b7f705ea18a659ccd8aac97867780e6352bb35461c5f95e27c277db1d41385f397685d3ee7814342e098490a483f975f2fc269f1f755cc31c2559124151ed1668d9da9db8b55d45df85a1a5de277c2e6afe901ab0662a2d3720d1667c0ebd0a6e63a280b45b27364ce1f7fa2596fa7acd2d0e4e3b18fcb793e02b1e4d32a99b949d183cdd53b677bc50c370fae4bfcc16f1491646ce74a3f79b0d6daa96cd3830832b8a561b2fe49c1d081c2b24bd02aec5f62ab8bc9af7840fa34865d964e9a4886bc9d2e0a1f8150fcbc5d88c44479c9ce2e93e277ebeadfca591dbd700a08b73cb6858c39bc9bd792db165501e348aed6df84c8b17cb9fcf09f5358b876777c5b6471fe5e2a748df7a0c17704daebfe0ff074a9d65057392ab688420fc67bb4d175aca748e9ded48e92b5d9bef4380e79378ca2154b7aff366ebe0bb980fe347e6f83d15926878bc1a6ef0ed9e900ee1c1775e68d74356105689aee24f735d03f0af554aec96e0da7a7c5f47540b68dd14aae273c8664e577441e318cb3294c881503da15844e0d12c7abcb686df0b1f120efee188d8fea4bb8fe996a8eb54145f9e90ac5a453924639c592eb1b872dddec16b02b6451150582c06e360808d0fed50e42b1f1466995ef890391187d96cc8977f1de0cc37296c6395a8682806b07ca8e6e450b72281b90c0275d8c9965c2b1f549b3fa6a4bafc40cd085f7b077f58ec797957fa26dab52237df33106a0b4218ed70fdca455aac8a5865a2dddcd4808a531bcd7472c4faa4089ab50dfcdc55e2d2eede3ec3358bec3b6e7ec1b59814e1741dc69667376a5c20af17fd17c4a4af099929ab72aacc50d2fb4ce05558fe173e85324564df505f6fbc4b2cdb3a20ffb6ec6d82eb2f0337ce2a7e515eb04507695e63cb5b88aaffcc67cf259761e68eccfccf52418e84ee63459010ee067d3256894cc30c094e28d7726f68f430bee654e68ec08813529ccf1487ff16a11aa81ede570f2246eb1b71d38181d7d5a93b550ab58b17fafa3c4237d98766fdb68555bf9992638dcca23d007797842931396c8b6fb6bea98e1dec00d447cd60e8264fba7d378bbcfb1d770122b90b293ff8217c335deffc8d2168f34151ddb6a83ad62a1cd9c75b081c11768811f51eedada36be0a829ef468b7d8e3e3bdf437737219ffedb2c7bb94eef2521f36585da16db42e7250d004710905c3f166f7fe935e95236ff87b35f343989dfcd379dab2327d6e16378b5d256556019d2144ff7360278eaa05aa28c7afca098492ad0dc706d5dc7661b9a5bef8dfc088e5a86d46bd80027391780438364bc9e71a8f66ad324341dd50f129c99dc78c5e053b041927cdbe855ce53156285079cb9cbb2ad5867ca6379403c64b4695d7fbea2d38b22b4c51d8a17a643c36225e27975b8b8986bb6e6410a8632dc4c2bb357aee671bc18ee0d4d75b738cda29d148cbd93aee80fae948166644bcf5b65b9739672799077b87236d651d06122d3636d1ece61053c60a3a785535b4ddb658e371f64e557040a841bf3535624f6bda7506518854b273efb5551e2f61a0dd5e4b7db0780601bb91532f1465f00b272830278d5640cce656193b1a625670a890fffdc50a9ccc6f74cddbbe87ae287a5ac3ecd9c530514c5de350eb99c7b2a48e068ef538e6381410700eb8adb7b0a60f10838396b1aa6ac8723450f5ece04e35f7c1affb636dbd52489728a7bc97eb00c01e90eb78fe760b828f754ade5a49763e3e331a601f91346d5385c732bb88542a32429ac826ef54b54272f6175b18bed951195d1672418d96b919f0b47588fe9bc75f0d0ae36ec228a17b12c4bfed0b8a3027edef1146d9f437fb0b06fde2a07730f67a5468b9b2289b06ae4ba655f65a90770e10092debedf9a048f7efeab70017f0c0f0b1fa49b89dec2a969ea9469fd569dc7e78cdeae1b806ff2c5e3f6a09d9a8a1d24ae248feb9df339049191b3530b046db968493f3129dff802b62dfe3ac23700947d47c21bfb7a8d8e9827a1fcf45a6e977c59b4524c74ffa3d378e625108ea0b578a20807f234b64122841e9837bf40ab9bafb829e8e5852aefb73bb7394de9d27b837255acf5032c0c091ecdfceded296c89d3e5fdb8ee6257963cc8309f98166625808495220c9446eaaf1d724725206ac91c1f54eab665a9bf7b6b7e0c984d12a41f07ecabe","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
