<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9126adc18849205507a3aee4d87e38ce5aa4c0f1db4d35be6df4ea13f13d41537dcca459afd2a2a99caad8157e8508db4902731d1555541e0f3f7de40f3a0c200ea3cd62b0317e6277568b69ce7056d24eabce7c8ad94caff7784da2ff437c4103fb590ed3a1ade035e0c6682f5a4c492e10d55acd2a90021d110b4772d5658c363c70a866e10eb9a504431f65266afe69650a602ddc6a44228bd9ce619aa5e14e2fd46e3f9ae7fdafe2b2f3112424b0cead2b3059879d1ac777450492457521b82bb1cdda6a994e4166ca6f810b34dd15c820a8f9bee8a3ae5e60e369c3d2b0697c01810a208f3a74cb25447a8fa3186c82fc366dab3c4e503aa490f6395e4b3980c196be1af54945bcf856f0a85f87de88ee0bd95c9539442827807ff66912b2195cd08b1d4bd6a02792c0b2aaff9c86953c2e1039e73f7280553e72e9444a46a997c9c59d871b3935e144faa264a24fb98c20d3427613c1fd2891e6075d0a2b9bd07afeed7ced8376db3479fe798c39f684e90c1d770c457e98210b96a624210bfbd5af0c4843168a99b807f7c28743ea8ae178688d8b2b8e3cf35137cf6cf5acb5887e6a43621c1e1e6ea2bbea94f5bd161238ead1bfb2fb79f04d4f7fca0a2ac9d7e840fc1021ec50bc441e4ea8213681c11271938001f90f58d922bf6ed570e94951073ebdcfee998d219e76915119e0def780d40e2bf63c0a04cb6d97b46851ca6e8af9e7e4b8045b891505f5d233589802b09dd848a584fe16f3190f250e3c998b6a0f280df713b9081caeaf68e6da739ccbfeb07e3482f11f845b2bc99b2996393fcd74c10a024c2df1e0b987db50672d259c66629123aa49a86ca40a52a88ce7fbe10f63c5f1d23b586e82bb0f890374a9cf7620bc1d6d76afd44c4d88a60ff74a27c6a8aaa272a6e60cccfd15928e9d64b9578f92604cd5af2ece0319d5d12dde215edf6146b0a4b957a6ad69fb7408ac5382423f6ec203264e3814f9e1f3ed5d5aae2f2e6b83b964d12650cbd743ae25b6773eaa14bc54f7017e32ea8e94a772a1395140f66465046104c60375709633b9b980f716edec37f755e895b332cf8a79181fdd5b8e70e68a41582847dd1940a3bb8350556e229332f7f014bf2a7b473de44492f0ae4b8e2389ae2d9473cdfb521ba9fbf1fb8c2b8f48b1de395921d057e044110c5d34cbcfc0d3b5aff14ce40e6663e75642670d4fb2784597dc83df989b788a321b5c7a24d34ecebcde16fb2ed7f94e736d4bee6d0d0cbd504a81e67de71e5513ac99d681ff3e7646e452ed9b6f92f50853c1ab4d1dd7efefb49187aad73487ded40616527991f7617cdcf9bd6ba57f51e68384c22fb47a760b79f99907f9c184f0bf2e0a7a50821f1996aad563a26b5d48dc86fa27d61b00f7be1b3c8576544940805c4ec7983c98dc616d4dbb6385c699f361aafd33bb956b660fb45890b11ccd4e29307848af429d8ee0389864c779de80cf01b35cd55b40c7a2bbca3a524ced2e94561ab7d41b9b858e3c5964cf84698fd5f7df4e06ff48e97a76237bc65ce2cc05e1ae891048560cfa4ed1761fe829a162ba2b40e72fd7672cecef13fb24f67ac2e30f90ad0444ef47d8a9bae8f32074823262029d24d8ec9c40a2527d5cff51d2e9cc6e2e4a9ff0c05b453b349942029d9a220791bfe47f1348f4c9698f5fbaa112213c8c4b2132174b2d1daa01edeacb309e289efc4a8f86774144e19efd89eab59e72bbafc6359c7c87604c0fe53f86a2025c42073a2cc1a98bfd950d5ec836daf0ccf9e8f93010c362a8d11ff1306c5822fb0c7e74305252683d33abd0e5f76e18c2120934b089cfb7cfda342c534ed3260b0ef115dec69be1edcd4156bd336c59b216af5a21a84fb66baa99c25271fe20bd7eaafd9ee9fc9267a1dbc600550cfa419173a21fd18d7e6eb83fd01f20896c6ecf9f39c10b7a6def9c36766a127e2a4b00c8fde207a0a22db88caa5b8fa748d2ef8e90a09c687b99bfe7db0401f719762a8f2cd40328a5c674ca8ebcd2ab6b678d0dff33ca438e4d9afcff20f48cdab1c8b810b0bef2a4f02968690c69d49e27ba93c703674bae981c75f54c5d9923575e491b591760fefda4a2341b74f2cdfd546207566ee8779ee037bcae236a8adaff3d1146a4df75ea840c2b06356edb7be1d34d3aeffab234a5a1e16ad017ba1002a25ff7c096a704dae22e713eb9b10a203251a29c206df87843cf03197cc92201d0e794583d214c3b55aa7ada01c5ab77f7e2a562fbb99210ba07fd4dfc819c2940df5c5108ea879c95a85931b18270721376a9688dcf9bf3d2000e98117ab3b2fa6515f1d2cc0df658f954b9f3c65466866e6cf4e9455ee897e0ace203056b397fdeee435a70050ae176b338a5d4f296714f9cdd0a12e2f717c3b90c56289a40cd5771bb2b9f58f788c330040ffe225c0a4161fa2c618604a0b037aef5732422e332c7da594c0181b8de75fa430ef285618b43d5a83e030e2912212ee05f591482ad2e66c062465c76a605b5e94ced0a8b9bf9bcad45ae25d605bf9d0327db9fa3c5fd32e47321177d3fad2293a896369fe7e5983ea333d8b7ae289b7f9423cb74a0892652662f8008b770913d42623e0af0dca519e3ca5ecdd51677d07dc2d6daed7891eecbde2f8d46bc8f704b4e45c809c1dc97e1d8bbe83004670a3de00d73fd728f6bb9c111a15db36e8c9d5fc439ee862a966b60001d9101f6ca71de4c4e0656e2a8d168e177815f4863c91cbfa584e930f6251f1ea5a55e5a3c22e2046384d205c580b167f77a58e1852153075396dabde1184a6dc0588b6cf6739ee611e2a65c82860cd504033c98d41996f0f25157fb067a322208f05b77f32ccbe9ae4ed8951966fdf77de363525169f7b44bbf440697ea54b06d8a7ca50b82c8640c52eeee53ae2c6aebbeb22631847f9b73498d41f13009b5db15e34874f0fe993f63593541fd8f0965a250a4f2d824b0c23dedfac5c9f53df05cf93b7b2b3456a95163329fafbcec007b50e68677d2265747a256b8a465b841b47108ed51e82ca13ecca5a30395cc6148e43a1b53d4c42769e9992b5e6b9cdc68a0e953a1b18acebfccc86afc20568c20c5bb4df6162524681373f8478b6ec25cdabcc60712de34cac914b6e596221dd2e54838a1c8311dfd853086319c44eeb1069cdabb04b7e9f4b817fd1678dcac8f7701bc4c49199a6b873b296403bf3f75f39e5fe4a79cf4472740af510a67a35f4597b6120ca6f185e74c127fc32a7081bb570079603a0775032c9386893f7449564e9e3a8b6376bd2170e47073c73eb2d7df9606879be0838dab34f47d26d30fadea529bdeabf984968b3f1c3fe6376788ffa4293e2470e1a0b021a03b227c6c0e22d57304691a4efb27dce0299c6e0de48ba75e5936867463d88e91358125d88c0fba744204378a5e0a1d6126bec8697daf17b4c3dcccf57cde1372043e35ebaccea2336fc159a5c78bf76009f6a372e1394084dcc659e0b7b4cf849f4a41627a58d947acb2d25b04bfa52a6fbec73208b55026ee82aff5c133e5b13bafa48af029b5519229a44bcc43a902e319a4f788322514d2acacb14cb03103f107b9f9e0f5e9cc94442128b6a8ba422cc5cf419b88f38c3ab5cc03c1bc0116e5e11b34b8d87c8da915f373abcae440ea1e2968ff3aca1c09c418d9cdcf1659dc9665d0f1955a535213a952cc530cb9b98b6aca1a9907355ebc0a4d025b4b531a9de75f20ccd5640373f85ef13d6bb5fdaf1611ea4695a22305afa8c7fc00087fcfa85c2b20cc7e67740c36e7e903b82108eb59e7b364e05a24236f6ab6fea08d4d7e32ce57252b7ee05a58cbcf140a3dfebd28999420e2786e585089b53201ca221d35ec86aff36f5d2dfe837736d5334ce0b538a4631e459dccd5957de037e7a9a5478214df0641b8bead5859dc6a860a64df02227cab032f71bbf308de4821409b3fad9eeb278b13bfa020eaa411db176f062c267d65934f70c0704a1d9a84cf43df0f314a0b0500c5b4fc11426c7477a3585d581e8253a2a544900f90219d34d171d37e5c0808a4dd657357e7f0d0e0d234416090d6206e172710e1e9ee94f0ba93732df048470189d9f3629bd51428ece97983aa9865b45739ee91542222f558485102b086594675e069205ea84d57d136d6cd04381592a5356c5105cc078c1e35743bba68f214eba07857c3fe574c9f037e502884bfe1c37ad9b73b79745c195e4845bcb951915c6b02a924f5d9c75cd6b51f23b98e01de35e08fd1ad051845150efb94815c7bb36c274b08c29ff4b73512056308c6e46cef31334da6cecc6b7f07eb053d89afd8ca428f46f3a25ae5cac8ac7aabd06ab9d652194b26b42f573c6907838eac371c82b34918d63bdab4d23002e20fbcc0423587851fc64c5de2a6e1f446491ce64af4a82070434ae635ff809b71740e02adfe0511878077e9399b9cfe6550833857e95c4f6c38e21454d8389fb2553ba0775dc2f673df1f7fbffbb3b8bf55de72264e96ce591197b38514bfc6e22022f0c10472efddbaa8ac9e37a6672e54d608e6d01d1c081853fcb06fc7a3f8f86e61cd43db985133c8fb634f0495951261efa89a58ae2e79ec770f47af98c677e893e5aa3916044c20ea1969a71ff9d4c189d27220bf200400439e0c3066f8610e631ce835a94adb132d56b8d7cdbfcfc3fa40f04e128695e7bd97dee48c4d60a927daccea42beb24042c9df4774eeb2be8deae46dd61479eed5192fc06f7a9f2a06a8929882c5a1526ac0d2e6c554625a47fe4e3b31b31181c673ab49d9bf1acb0acf565ccfa2738e11db545bfd57015bbcd2a7af2f05654e222243d93dbf13c58955d9a32ae61df922dceeab919fbb6fab26a6b1934faf92f310d91a8dd7d951c4a087433f9a03026e4217a4175a38ba18a2153080e3abb3499b6ebe56122522fd6258f3db87c5659c52cd12ad1b1b0d3251912c318c42db57817bd3a6e4cc6b2fbbac5aa43a2a327088b48f2bcf663bd88a5aaab62103e4f4ecde136b76c9402a18cf2d249bdfcb5c1980b082a878172a804140280edbd89d130fcfdaf01b0e03e5075b00419344e3de8cadbec5ed5fe3e978944bcd074abc672e4511402dc21db96a4961ce17d84cb371aafaa82a16402689e5757d9bb02cdc5d76eb8b3dfc0677c020f9e59f93eca352a875dff09a43c7be79d802cc0c4b6e9dee577d6c40c4a53f415e32c52755610c0fb4b8715c12917da57e2459916f97c0a1118b32459fe05b901db6bb41a19182d60df344f4a38f8c048e9c0f90b5256e906c02d6338c78d5d29d4a2c8a3ea9d48edf61b2c7c51a8280ae2b2460cd4c732ae128271257b4ae8a5fb847dfd90ca80f28f87c49eabe6487e4b96d78c3d384babbd367825ec6546288ef017dd2f7f66980815a9a6216c7c10349a45ff1cedd85ec9fa7d809c0bf4ada1d3b59ec88115ef42e44df5f2f85367bd7e8f09839ae6f0fb659832554093b2b22593db29c63a912e524adc1bbea13f5a1a61775502db890ea8ff22993f42f0a4589e4583dc8def2404754d9cb8233d4ad8d08e8ed769c1aba9bc19eb84817856e6ae66369a897b33bb84a59a77ec246b0a6fedbfed9f2e2cc74663dd914055222a8586c3d5b25e6b3e56ea28892aafb70eaf3a19dac5ca4978a8bb735366b753575abf79b5b750cbd9ef8379d0dc457b7006b393419ef07dfdd0b165a97b99dec42a81ea630b674fbeba4b7813f7297018c822d6cdd6c9a5ad6874ac02316a47d7e87ed7ae7c620533c445de95e19381bfd1e7d29c0121dccabf5a3a50a48d33359db0d3b93608353f1d7a3dd632b6617a39d2075be17f1a8fc3e5c87d5f9bb22fdbd5e04431a8772639b9b3a855ef8908d81cf28b25e0be01abd841b9899a2713bf365f840b0c923fc68f016565e109b7006d1a0612706b31a35db7bedbdad45150a1b9ebe2d374bb2dd917c0514e0c6a712d35f8edaab507736bf2dfba2dc37f8ef62cd46cf58617c55bce4f29fc29c94296bd5aaae38bc2485752af0cc3a10bc5c3c61f76425604d61ecf33f5fd87a510409ece9a584956932558c7b3c298b9664f1a698f9745ee26aa1370f8b62e52764b04e5f3386564929c0a0ab8db36c5910296e22cd5229efe38a5175bfb678cceb4e2d8188ea6d6854d9ae185d9516cb4d4d0e5cb2cafbe7929192455e1b35f32967a3899ec549e39ee8a3087444e36dd2492d6e94b5341bdc19cf6fb46e8fa1a7c128892ad5479ebd15dd05bb8c2e58a85562342101acb8945b8f71e6f33712329c501ad72c79613d222b94c99eab8eb91120655ee477303eee6c711af0dbc58d27ac383014e0815e0d2dca37b28fcce0c3d19ee4765777d68a816029d8051aaff1bb0f6e9e6918fb8ee6147002178a4a48d8030ca79dc86e3f9a88e5f4b1fe5c4f36500ddde441e230dd869c2cb54f95a83248582a30508e68b4ace1195f77255f300cbfcb6f4cdd11fde63c82726ca82680e3349eca2f875077e5f90879d9cb478199ec0f9130d948d2256bd29d6d9cf43722ce532c8859312ebfb7ee109193f5ff3c2bca69c4170bef1731339533c952e2fc32c663a416b8ba5b2d3ba6158187166f479c3034734c1bc8ce3d717c8513f12129b063a208782d50dcd310146a3445f2bcc3c008125ddf79b2d2e4e626fa011d6622f5399d42bf2fc83e8eee4a4389ec85b80b0c22dbb7caf50fa0750cc87695ccfdc5518fde9bc52c44a0bcf7e9fa95dbcf112b13317366de4527a37c09973b7bc67b3c73728446314f24068fb012f9678a9bb1b964357bdd85b7c03c739fa11ce7cdfbe05e7aa3629d06ee1851af5c65b19fa6b56ee702e1dc0d5378a2734b84d64833d4064d99ac255e5e795d90cce103cc46f1379d2f136603790081e03971f3f2ed5d6377a3a8e7a4aa148b008b71bd2defe6d463634590e83706cc53477bbca79b72f744c7c375c1a0a023462d3ef60b5d967ec5534e6f1801d28d74ada0a482c97525f7b917a1367cd21d6ec27c76cd8da361ba888a9cfd478bc22d79ef9fea0fab33b8632eae2f56e5fc88993934a49fb3103a5851e09da4c6509eef9e658f05e8727a4d3e57cbff44914ae5714223db6a8a3b5e7ef250303ac798e117640fbdc2ef005ff2b1585b56d8b06b4504b3938f274a88d25f01130db3e03fbe6675b42c7481d7cc884767eaf6e9bf9e6da40c554e6808b29a71a2d5983d7872267fa4db2b6e343affc8e5b4505ec8e837e103357244fa9bf51b71d02d9de54456d80388448081fc7694bc6512a78741bb6c1be6026b35e73a68e7a8f17fde3c487f71e401bcd4d56d745a915e7673b5dae52f548996787cea58e6b2ae1788af9963b118a13fc29f0d01c65fa30133c8de93d22f788e6422f5955048130e5fa9672c167089be0a98529cd5e434b3f62b296a9e9395e517db7b327586e78b7be67dd8cf0a93f46ce190d03fc351a52c3b3ef34318532be03dc065b7f76b3ff241dad003851a6e92ec8a193ee7150ac59c190431136c4cea8aa862f982703cdc359eacd4f7f024ff1005312402b3278430fe0009d953c8a5677897069e94e2a4e66f880133939d9bce81769df53cf3a8929bb4bb207e3b9c8a0512003e4b5e111d2bd9348b46b03ed471635da3eb9129827e4ab5b10067180d429368595922229c2c8d284d51317bb2c8085496f988383507c10f70cbf8da984721622985a5e813882254a93d16bd8c8e3129a284a43be7b8a75ab8044169230a4dd5724e1c0c49c9d8046285c1bc8f20a7cfc5ebb2d77a7d1b8dc64ba2856feeb8634af54a4631be4bdca5f248be1271c876c5fc59babb9be8738d87b02c2d45c21a86863c3e1cdb2ef8a98acc70ddb4b2ed12b603a92679c0ab3b3d390124a9e4e0b1f2acdad6905b8fef5711bbfcfa33f68a13fc159584db523d7eedf4c7d8c6f85498049667d69b196ff180bb276ed713c4285251142ba5c044fb92359bf153f9557a5e13639463d31e935d551cbd795c15dd74d366ab260458b9b32e92d0293eccb088c88195e1c1be821447f8c35b51a429f5e59eaee9843467fd2a079c698835b60f931528dd03e7f77303d3bbb20dc92141eabd2396375a22c321e06ff784a4129fb5042c37dba094fbe9e8c7c0e4ef6383d1968c4580c27805a63f06e8c55c61d86fb910060c8777ef435453ce5ada9a8962ee83ecf3ae8a1ca85ec1408b2dda6251562d7edacae98c2bfde6c58ab787b5e57392eb15665ba5d6ba8426ad8d0af83a6ed1b965d96282b6ace1425f2bc7dfc2c742efaeb78e34b7b4f42dbbd681c81ddd38d6553e017654f0054c2b5bfb8f8220213584395d44215e34873f06da9b16fc5ba3e55f32eee7e5557cee58c8465d2141a2cf31128f798ce419f50b3e31e0dd97d085d24ffc558ece85a6a1ce4d810e333e51a65379498b1f0427074d658bdda41c59849b3fbf4bcb98eed2a62d63969d32424882ed066356ceeca6ab0f2035e00cfa22c660c4a3372b07772c28118d034bc73c1e6dfca1146c5c741845513136e6917e9bfedf32f8712f853925e77a2ea22d2b0820d81b5c992c50be774257e17d2739e952a6617eb8613032950673549c579b968ca7d59b3a821c2e738e959716b2a93b758c1d85d1848dd3e183d8debf2f33ed0640becb3101328c5ca003cc85bd0c60ce107cca94b7f22a91f3a902f367cabf1c276457f7849fa2e68b7bfd3acf0f4b5b2f022a70a867212c2c49e58c293224600cb735812a17a11cf58efa541cf5bdc169b094ef7b0d55180ae386f14ab590902b1f78e61bd2329ca3e14a6f525a13dd93bda7afdbe62ce26aac2b82ada266c47e30cb359f35c21f506f50ad7eb56a95e97570897f15cc0158fe463255eaf3877827daa5b3ccb542c300f1fe300e3b3e1e5417348376a7e12ddbc41546ffa971f482c2f3a453b8cf6104362cc9892100b9ad83f69ac40ee08fc2032c2ee729e4d5216195eed9fdf77c1616e36e3e2bd1580ef3bf9db300243dbd39266c8b6c5cff07e001b4c9bbf7d69cd23d2fb4dc033341024df237d7c5e8453d41ce238554cb232b8dcdb1741ccb0a800ef51d517bd4a186c740284b675465bbf29a4083e934bfca7e6b7306ad7b4b381f0e4da226db026689a562c809d02e7d7eb087c07bea5df192f127f8b12dd4fea7d94e24a2556a18c31e0857ab0beb9fa9ce3ab62e29dafd9a45a20c4111632ece7df5b1eada383e2542406d14aa4ad8b4be6e582e670d780f2f0265881ce3cb972d48be4f3128ee75da5d75f095b8b6ce286db41ac092558acdc11685c6cc5cc50df4d0045e998af7544db8829abe5e3a22a355b443fb669b28a2be95b3ba4158d3e1eb73696b2351e75e30e4a64aec058988b5c2ddb0756bb3f43f86aba2dcfbbab91563f204b0ebeb1737ce0d4d10f95e5875c7fc9f93c4b132119ba1af2be1d0192f2c9c19c54513ddfa161269ed1f11eaba49ddf45ea1ea5689cf97033f8bfc0c799491e68d5e3495426bac8be74543c36d493216e189d15dbb2d494eefc597884c7dc252f24190b8128a2f2dc27ef5c52b63e25072439a7401a33aedf68b314103f3af2df4e3e8e9c0605ef923d54ef2b8a13a02ea506d2fff0d3403c01ff8adc287e2793446927fdeb82c1f4169babc305b45d27d7f8465017c43fc31913ae13e8cfc35290d51f038174f5447983695479a86d67d18515d5dd32ef1831f456a32dc5b0a04a45a9c33d330d7cda7e16f04cabae4da81363acbe45eb64185b29be18ad54ec2e2025a1514b80c45c0d0eca17c688f468d33c12501d8ba5cea653967032641cc0269ec6e9b9c8e6c3155084a372f70da46a6678d066e4450bbee2362fd7c2ed174f6a43c8d5cf6c938fd6261483b41fe33a4ab93b10ea175ad3555b46d3fb27b178d5629e2ab0f9dc8dfabdbea3f06d97c3f6af968e47cd5e4f7d5001c009e32f5c19b3efdd76b49d290134d8a7a957bfe5561d52585f1f1338d5730f6bc5e1ffad81898bb9d2e7e1c9600ff55b4cc9c2ddbc7fe0152a6c684bccb2d148228aff8f96ed6b86db6d49abd551728842b5e7c6d0ab620d08c17f5b231d5dcb824d41b748bdbc7a4b330169e55fc4aa977feba5cdc29f1173c1974921070d361969ffb04cd824bdf9a844e52d7dd8ab501f9d8670736a45a68d149b53c677d5cfc4f64963db130b4a51d0f541afc8e070fe7b7272760d46466f32db0bd1183fb050f46a80ab7b604580f1625f35207e9cc1c32211c3154032ddbef356a47a7c0bf8586e3033180b62c918bf4bfad6120e848f2e1cc2ee247e7408a84e386fc290ac3db9ebb69965fc4a16fdc95f6e4c681816a4e3e704053c333455f183b3c017417639295188af69f03e6601baa025b79dd52770a74e10d29dad9b769fd555a28348870939f9f12a01724fd49233e19005747910c35f2a8f87abc9142a1800ac7cd0dc76846eada39151cf1ff7a6e0ee995b6237c0d5f9b6a98b916d15505835fb7af1c2ff9bc16328850fcbbd96f4609419c0cb1bc462bbe37120ff0a31a8941ebec30ab4555c787b8f84cab3cf782f758aaf455edc8010af907b062163ef9e531be9eed60c3730217079f7576d520e93cedeffaef8de7bb3e08cc709f98663412cbe39e921c80433a1d175c0a24d0599cd05766da9e0ed0531638af901fed10a6a5bf9481dd0fee90b4e53839399496d5af04e0ec0d27da51f587ab3f26d6be9023dbc2adc4221f7f059fc0214cd8d5e376c5793e69531f48324a4ea1f468581b520ac81be82f43cfcab9e3aa1522213a10fa615b0a4cedce14c97679ee934d4c4ed7620bf0b7b974e70cb153850c920734912a8587af1314381a488c368b353a20e524ffa1d7ba8d5456f1c7ac350f6cc644e6f8b82aeb904123d4da9f844f065bf65e2c54285e9d87fa86960a008d5ad5ebdd66c82da2928762e5a23fb1affaa8241d46346a136ff17729fe9afcb22a30c97a59a1fe46e0d229d39da60c74acd6e6db96c6c0f3626d75130ddc3bc6f8793159b563124c436bad6ef713b2fa415ed5134be9b76bcdfa492add608a582b3b535c6144f0b14bf4efb1cd71646e33a9ac3e0d55ee7eaf855e20c1da962b9653f0917ac535db3c725797d800326a555769b991ed80c791bf8c2582f788b174f44cebf7e34eb7220b0e9ee0888cb951e581060cdc6149fc6ddf34fc603e5c4f025ca98ece2f6816713575e4608b9e2b22b079fce712a28f6cda4debddf99eab2a81f3455ed1d121218d97ff2be9ce1caf10e634518b5d82f96110f195042884e4b36322c9f5074a866f31dea20ecc93f625cc84ccf41c9c9479f636d83047b1391edf8f5b4efc5ed27ad513bbd3c136a619675e53a82baff14a6bf49668efd54333ebed2e72cef9618a00369deec1a8f3bb831136c16b3e3acf5aa49a1c9155102b3fa55eda720af9ab7e8f1ff643b200e8de6143f1d1449175e72ca7265ed8a891f695ff8bdc948c242d140a1d5a5f61534555699474a32394d7133c8276bc8c487fdafc9370005fab338af7d421596f6e3e4cd99f4049d44fe6fbaf7c4a85681f1b8b27ac57817390bb26447a7ebd2d3c2b5dd0cb257e9722d8f2a3df3a5c7b27895b0c75ab17f5b0448774f78b002379e598a17f1667caf2632166cab87b1ee6d6a09465f263a2287914475186a7f580e233bc23f29096aa7989fe7b1c74d5c3e5b29051acf066a896da4bff2157fe03afac0feb30a627880f769729bbce4ed4a24d49e4fa8a84b68cb9956491137c81bbcebb6935b4179bd341e171d7472d30dcd3bb0a7778a44d1665b7e4b684d40503ec7033236dd30c6fd33dcffab37a2ab19905c013eafc13d372dacb42114f6e239f68ce36b0a68c4f281381061ce8dc6164e3a8e70283b5336ed09c3eadbe4d531d47fc3f2cf60c59c13de147f9df602f313c4789ba9ae3868aa95197d33064b648dc2d19fe0c41b909112d8613153d570707062eb1a9184b567c6e8dd1207ea7ff1930116f78dc99f0efbdd1a2ccf8cc96057cb09a0f3e3b94078848593e75b29320e77c2015882959e7bab32d17eb89f52766644bbee766e02a0792c0a1f9eabeaf1c3f5394492450662e17f13b1fcbcdb2d9a1eef1c22ef7f37084c7a1c5e4be5bde76d65f141d4a35a96f0c9baa67c190f11af77d4b3d693e205af527beba1a1bfb451a0765329d9d725f1265aceb1f0ca5e3ceffd482c594f49de2efa2ad436740db0e7d6c7acfe073a277730f44e3e2eb6b3d913366c921d5a8527835441de333e2c18bcf7031c1cccec9586be8e1d7ab6c62b8c52a1eb9fc2c7f6e46ee0f4ae254c96fb04328adcdc6e710c6e9a15de23a8a50dda0078ca9813aead069ea0b893e40f63de6ae643fe2cc1e1a96d3693ccba5f51518dd57a410d7a0119dbc68ba8c3b836050d2db902b2c2c15f1f1b6e47f4d1c0681aa2c795e24946c6ecac8818a999e2b02181e4f2ec3a4038c2cb7dcd7c0591fc899be707cfe50239c773b87089c6e17599551d1623e9232a1975e0640224f0df94a7551140bab1a5831af833cd3ccfa3226659cda2e52fbbe33217af47396fb1e55bd8f667edf1d08153fb8e69a08f87b4f9eb917bf259e747b540d7b333b1145d908f5447db1544ec0bd115ab6622acb87ddbbd5ee7d80d0022c39c2e8b98dc79da34190b35783f782d92064b0d3b712c152727ea9c5172de86068fce8994e11da84e274f935bf2c46227ce069a70dee0e7a7f0f447d170f88bf55e6aa2b11daf1edd213d84fac09969a7b58f50cc13134050580898304a35f4e652e0515e42b38280f3e779d9e7d85e2be2073051447a49544029ba225c56413e293180679a6abad5abe325a3dccbc6fa9a1d9b382c08ce83a69b1dbdeac4073563b6d89a17174ced2c283dd9dc8c11b78614c16e746bea01802adec1699d787d1295a09f34d1ecdde0f80cad75c9d9142e1740659a13ae1bb857640fd62dde7ca504cc9994aafdefc4df11a407f74ebd02d322c052f7e683e2c1299139cc935a5ba0149702f6e26ab65d54b0c4a3f3a0d6ef274aa8438c0de981b04415c636f1c347ceb82cad94630605db1085be5ee271f650436e6a6e4b3af45b5b6df66d8efbfce4c9dd928560563f15d989f2d1756e489b50366a4d7d69fbf56738d774127faee2b8d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
