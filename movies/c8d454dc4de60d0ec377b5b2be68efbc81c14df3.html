<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"71464be7e2dcda69c7ce665c4150ed3b55074ad76005e631e187266f186ba7f2b4073f891f5f35cc69eadd9b4439b5d904826eda3acc456c4f120618382ad4e33244aedd8e81d177ddd016f0e3ceb0c96b9c74e744f077a728164b6358d548815a77da8e88be7903493540af7c654e4eae62eb35b159f70575c102ed47a4c5ccf52cbf4bae2deccedc96dbf4228c0433faf1e40a0fe101a9b603bbc8c30d544ca2386fc054ecb261e35b0a2fef5a0ede797bf7e8f203f7c32e58d8c2b3d7e3c76452d346ac11217a51a57595841189d6737aa78d0450300e45d8fd97c04e0bbf6a9247a5173eba715b2aa4962d8e9e16645a6fa654fcf70267a0ba04493da1b03e922d9e609679ebc5715e9568f2f843cbca3b49efb22e27eb1aaa68f3d688b3c1b9028c5cba223c938c369fac89c6b2b1bf8606de8cf8b6a0dd8281c88349b570f62324243deff8f257233a9f231982c25c6234dbfcfd371900c8c953eefc1d3fe9751259af91e1cf4ab914a855440fc7b2746282cd2c26c8da28e2e4c195751ecd76541e687e18a31bce92856faf9a9b0c4edd7f7e42817151de10ddfdf9420393a0957edf17c923b551d80c2b2a12229d58388bcc9a72ef4f434d54e4faa5bcfa2dad2e4ed4201967a19a2ec65e514733902a37171765762d536af82c1fa1f44ae016afd674812049aa97500c38b82bf3a052f39d29e952ce4de831744c65af3bf8959b2c5959b3c73de4d22531239fb15ac8be33f66ec9ac8160e2561c6b1c633ca1096dc1462208ab420a9f5398b77e97687ef8ecc54565f69f17b75923ada84c55ae6cab4a0673a562d5386584732fbb499b9cfd92ada6826323d789c2a74cb5b2e915ca5487d98bce0983338cdec8eb671bf492cf55148278827797c5d739e320c120468cd828575d7019017e32bec7c26435c86bb10888ba78878528cf797214900ea560cab03aaa5594c1208dfa3882caa057c20ca214db1187d0d0b41d0b03188ae06a1ac032f0d0ccf064a06214b16d00bb65293236a016de85cdb6a8a86d82a9c5fb83f55b0aea1efe91a19fe3538a8789d4ea8190557da7650fb68fea8c1b6b41bde068d0d78f5efc1570a829d4345ba39965be297474befbd3295794ecadae19bd9185351b1775deb9916cb204131cba5724cb13706582d297d1555b0c27abce103063caae2deff0ce4943ed660ea92bb86a1408935d80c92264c0ee586e3ce99e5677c60d636218bda3ba3142439e43604b4c237adbfb9389ad5f6a5f9f8bdeb31021b460aa3fe467d71a05af84c1709d76571676751687e3794b56e5701f082c586eaeb5918e874d82b9b36d4c3474555b1e29a83dfde3fd8cd0d99bd285e2e3b3e53e3a251696891ca8781fda5c1678769f51e0ede19cbf9aa1119d9dfeac388b69aea5b5d836a78d5f8df85f800bccd4114c6d717de5aa88b825835160825bd2cf9b01ad621821f6af58d21a8991d3172fef5478380b5cb3bb2a623744f3aa53b6b903f9e68f92ae450551446eae87d623680b94a03a32b0fb9b78ab2e9f41ba0f0b7e27e520cccf426baec1a1d7ede8e10de055a26d13838ad320e0a17600ba41cdf3258cfbaadc6dbc66181f8cc132d7d0f27bce078b83c6edb28f2ad80d747af8e9ea51a57e0c49cec62c75e84c85d7d6bf68cd53a17cfe8c06b61763bc603043a5539901a1cf2742b7f6261db1d01d8d0bdc618c70443db9ad6f3ce39755b10eb91795b1d8e3ef95a7c795ecbd2cc69eb7d17fe64466c2f4fb30724a419cbf425c353807b1ed5a6f1f4ec2b4cd4e32f596aae7cead8566be0121fa52984ec008fa98803ff37d3bf69ad93201be1b43867e599828c055785ff2264d6e744973347032d03446330645023dc6e95af7baf0bb44b84f696c3a58e34892f5f3acebab8f79c63573adb0f1a569c41529d107bfb103beefb04131a584770fb70f3184ee0551a99b9ca20bf34f2dccdd9e9c976ab30868610a7c7b67130bcf2cf01cf584fbfa2a884f71059c619b02389e1dab6af6858bd42f10e335a90b90a47d53424897fcdc6d1340effd0573567b34d4c6ba68dcfd412a4262ddbcd653f283704e8223f44e314feeb626b7f8c7d0043900f6e8587c16df40031bc710a7a164acedcb25cdc4eb2fa0d5ff5f66cad88783992b55fc07091fce68a2c49f2786d0b4c64206955721ac228900f38e76870cbb152ffd1d44388cca185b6057fbef3baf9bd77c20119679cc7614549d8ea6347baf5d359132bcfa77921f151672adefa6b5d2b85616f8880cc59ddf1076eef7601658b1659bea0b01e7d783370c73900e47e76edd5abb42ed3491b970b9d1f283343f3799bccdc78fdc8e71c6ac26ac187fbc8976608d7fba7143c37635fc3430daf58cf26a899c2b088468bda1c78b12dcf4ff9af003a09de6916ce96933c6906af3dad8b8077f0e5785ff4f8971b9d09c0637a10db18fae6301975eed0f92e62306477371415009a1542985a42529725d93fe0aa018dd3829055e9379db33e7ec11d123b31ef5e599c41910c2f62f0055ff86122c06652d643f739c7454ef37147de1b6c75e56d047fdb6eae7d1bb59d9cbab955946867a961b73a550c362686ad4a49f6f0ac256a861099efee2bad23e49434e58f900e10cb8a4999e75a13f36504a8b331c1599a0d06411abdaf1c02b2e7843af2c86e5d2bebf6753ff32ca1f5f05c4a5bf42eb6651d01631016a45b99ba78333b8b7b42db7cee52b2aeca2f3956ded9b657bbe6fd211ef8333a3d78eb083a4be9eb91e707506e7f91c94ba7d2ad14bd26a4256f3df421998c617534d5fd8d525bbfd65839d5c35c76f1e4d74290565ca13126100f78045df25b59fca433f04b71eddb2ef5e3356a1df9e311a71925468ed862305c5796b47f730831e2078098a5a45d61381cb6789a02ba7fdca29c5b006923ce8b4fd204b8f721882650e13b4bab4a15b2041ba48bec9e8b6c5415e339532358d52060c42dacbf8ee947357d2140cca31649361b008d2694a3e48e1a5b83406888aade24eaada53714f50b2733db7261b624760844b4d7fd7957278976383b9a4de33819f39d3ffaa5bdee3caef029e14b98f1aade267af9025ff573498a3f42c1a6ed1381083a8e4e4b98333c54d5a8c5d402a14e9f2f307c403ce99a446be09142c1efeec1dd8c1f29776eb566d6f04073478604d9d612fa12da370c88c26e8b81ca249b70b98203999a5c86c99ab01d8490cf9175478f3f98f41e07db24788837f1e771de118f63586c4f58f6cf220dd8a4f15fceb7bd37f0da625a780398c0b42913c14b67833f625a47b72e4e6ff83051e81dd172401b1bf407fe7839f7b1c33ce6bc73ca050017e32f588442938c29414b45adf700aa2308ddae43ca063193ab38720a1ad30afe2be88a659215a65f8499ab6636936882da5c70ef01972b02385aec11bfa4e9c785ced0b2af18d76f147d0b5c58326282111a2196626eb05d315c1f15930c9fac619f5471b07db1dd08fe408a1a5da1f29ae03e67b21a4994d4c423b2c285ab1007d1a907068a1221ae1bf6dcd7f8f9a503c6de117742bf5e01cd123876060928295ac74165943ecf2ce5925495f7cd00a7d7e4ef948cdf1f737298a22ee6ad36e406be66812d8b472ac69b191b06449e0eefdbda55770669e1fd0d1e486ee653b55bdcc65fb7894699385f2e786fe1d443f91986b08ce6e7d62af803e2d5b74399edadd33c232e8827e4f9d7ba9a8a6c57d53ae497771857173659b3eb5b9d44f7d0e51c91a1efe27b4c74d228e9254135a67e21a946903766f189acd38b9905126a0a6225a999d77bd512aaa838ea4751152305b727298d1588a9d5be0be9e2425f372001cf1e3c447db64c4402699d57941a2bac612d711cfdb01189677062de4c9a84f0e56484500f0067caffdd0f3b670c31d699c2da055f22b40862f5d1f166345a70e5c206410cde640ff7ffee1fb6ae1a276f14133518beae4c7282c8741ddf005e9803cc220bc96759c5574c9e62ba1f566dba76df0d139d90f8b13247a2850a23156c4c9ec321c0092e5c02efca38eeecf61740d97cafdacc48d25bff84c3161fcd3d1cb5cf17ba55bb4fcebeb545951b35adfe99b72c36c3a28bea9d90275c0efac3209252a94afc3667012bc9e840bb128b8120e3c4e0b63032c8bb17f4c304ec353d17efb4ab5a07bc1f9043f90091364a98d741060f8e7c2ec407a63b144537fb13c6a24232972709c8b749ba924d75e2a8ca70973f4579a844f78f10f2e913e4edad97adc3ba7ad00255268193d09733b801448ec92b1e3ccc8d9c964c561933591ba1e70c8caca4498bcf069b6b69c505b9bdff0750ca84e8ac9f68b2d8ed9c0367a93bed7206779aecc6ea1ca46f1c0d0e722df45128effa086a0416799041496022bdc727ac52277a8d7ae8a9e2ad7f2f4269f6885b17c25c5d84bac6483b466f276feda8e13f00eeea97488211e66b1a1408107e6c038d7b817b2ffb674a47b0a7ff10267869942f694bfae873e51753011d7c597794c97292d88c14da11e717b86d89695cf7128a70555142c5c69f89d2c9ddf5d3384c51541eac919a20dff9d59af61b22845999b8549b35640fbcdb5192dc22220d0af563ae9f0b91ac5be0aa63ae1e0e5b071047b3debc86ae25c12fd03b1e066f48a1c0e9529a2b7fb603f328633b5c1eebf11143b28acce9322d153c58f5ec494c98bb65a1c4a76f99ef3da12c6dda7ab7c5644225b96763c7fd1fc749574759e178e3042755262607a25c4a6077f5a3f8b80e85c990c75949a2207d3eb83d4f0e110e891bb5b10383a81dd68f6592a98c95a037a1c6c25015554e6efae94b4ea72d28aa2a4f1166174dab58d9f6da2a4aa33c5f756dba7c70600e186fb076f53cf8f27e1d3ba6b63d0c134f46cfa6585c6a35320e95c052ace870d64fdce802fb908efb7a73c8648b7a5e9f2118c171a5e689bb6c176d94b5ab3b1f8fee031ec8757963e8fb23d1cb22fa7d14e4964c4cbd32465e146317c77b8c2368c9685d1e71b8abf0ecfcfe87ed743ebbedd47b6c74b43f53919ed8e748077f8e53f92337966bff3b192c0097cd47326ee656e0202f3b8a66d71f2c7f632b40c6fba9e03b8fc2898bbc9dc3ec68e7a77f6e07aefc5e56e3956cebcf40a89d9205d9447c18d4392dc8b364074aa047343ff0e9bb03ca984db8ac42da0a45003950c48e32318bcd5ea05865c8fc9ced7a7e9f3c6acc2236a2e99f71e97a0288a05462d5039ac833f8b1bdc0e0b15f9174734e86751f7a44a96e358913c0a25df990289f93f189df013cbdcd187d834ab78114bf76937ca718836eda1dd17dec77ab45961fafb0568f143fc94914bcc9b8f9b89d58f3c6ba9b6d83edf2f715802e06ac38fde6cd810c668511cfc5c6fb450426b7dd4765c10e035257a33fc1a78cc882619986f16d1ef83a790b099c93e75ce054cf610c2cf6819af8b3f92f8c7949ef746ee019253fb383049ccc8757f274578eaf09fbc8904c6c248bd0d73f372e5ab941606a215f3e9ca23c97c50db1ae7751f3205de607ccdfc6c9fcfd7bafc939d3c092cbe3773fa9f8d8ee0d75097b58b48493853e35a3a6d807e15ae0e83a1b525bb25bdcec9e0adf642900bf9e20df61bee6884ae2991a021bcb3908fc47158e10b46c5e76a13b3e56d7ce8298f8386dc3326320ce5c18d0951502a88c4498510210516ead1a03d75400db1e0881a8a78e8d63677536099af614fdb7c2aefdc0058e85fabb487357fe68d399048e2eded84933f76da432dbb2d7a145d923a25fbe3f75231ebc9bc0eb9b38a30909610fd0b006bebd16352d679c8a45a9862bcfc213be215a2d30d8f63cbf00b526ce28e9a476ae4e9e8c265a2bc5f780df331f0ee8f55412fb818096cbf1cfa30994cf6097333a74188c65bc8487a8ba9fd1d37f14b576de71fea9628285c88db20ecba6bcdf70aadbc1b363b0f3b566dae1e921071a2859f7f746c26df38c24b54233b122e27524f7bc87d7ded02f442dd1eb5a6589f9ad627b55f3dd10bd4ef4af19ae4cfe273be3fa8712476844e078421c8a59a13ea60df8be66474a69a47bdeb5c30e9fc405f297761e20da7aa52e9a7b49bca26de944dba0f94a3e3aa207cd5e5714a25872fe6c8a44ed7dc22708915ba6ae87a4cb449e7cc30d5297a266898a327992535a6c42c805aedebf01f4a981da5383852f1707d5bd97888f8c8dc08f41cc4f769abc2051354a4714e1381ae080b191b9b5c44953f17409e1a25775dd547c7f8636c78567786103755b82726b28b1739ebc390d9176908cca30dc2158f2a85beb9f198ea98cd775012dedf0e4aca45311152a22d237a827f17001b636a4d70343412f1abacd1b3078b21e75d945705a4929f9f4c7e765431a2a9a8e21480b4992bf8476b2431d551e9a3cb35c4db38d73b29ce17a119690f1444c88361ce6fc3027dcf8f3cf141ffb3bb28914ace5343814cb06545f4ae4675844434be33d7a491f2e31ec176f1b10f0621dbe4a511eb9b3aa6806fdd903e2db75842116909e17facbd223b92b1f945aa4d7155ab1094d09e332dbd4689a3be2e7893e0dd70060ae5f6f65cba410f1bbadfa1a5ac36b46cc57eb825526626db64c105063a5afc68a2ed04a73d5f3e5da30a8a87d704aabc2fac788b2e2eb8751e5cc64358d0fcbf74738e21921e29c30c7af21838c8052dafdff5d0dfa87e104a0fd3105705449695c7b929610d9a7faf0d828706bbf47bc49eb9a3d7387d9e9e70e03550f359eaf5865c7d62433170f5dc39f86100da38686d628b006654c095c7a0dbc5dd7b3938a6287520d5ae1a658d6f5bcfaf68462176b332a339cda724915b318ff67913c572e91bd54ae2eed8dbbd0ff6e0e5c1c552ef211ce0a5cb8cac4f9703b52f767d8a1d941b3bbeefee0b3484ace13c5e906e447232b5a0975f676c5010a3d00365b7f204c73bc886d14984c462391743a54a506c3860a0b66408dd7f1d5936540460fb187f76b127403266568747c8608e99762b02004bd80f5b6170985be773a0c8452e3b0d058ad7273fe074714ef08f7b06498d78c7d73240670e5dc6eab8770a288538f907e0fea6f0c62e9bed967c0b14c80dda643fdffa963b5a47b5010e2661cf68c0137862cd58497aa76da4a4f1b930c04620ca66f0c1cf19b231066cb6c499c481e8b6477e207e4c3286d3d535274749a2f089434511dc30608feec2d4db5ec76e687b1312418ef3eb27bf80a288be20431c4b874438a6a48ccd99d215a9d8fdae45b6219e6ed0d179c40fa5bc6f5fb88dfc38cc593f20e3bd70ab28fbe33b0b6c6c0bd67cbf29c58a34d2e119bfe68fd18287b9f760fb0e78c732e333a3302bf9401bbf9da29e739de6af2e6b8e8db36a32916f7c3596640ca18cf6655b1b9ff5f343b56333ee6e6fca75eead366f957fa1979b1698e4b035572b91cf090599ebd9763bf1499b3a3a53788b073fdfaa14d85bf223a1a63d1e6ba4b35c909fa19b965ce7eedbe90c78e285150bba9dae7a8bb8e58952f738a994bc7017b2a014d5dcdf5223d23014bfaf9d5509b0fa5e659c5f42423b78af2ed16d706af3f4921beb3eb91bfdc8853412707eb375089acf0a27ebcc143e1eed103c2f2994944608e5ba7c63ca18f59f17f73d911dd0833c9960d81fce533933a22667330b343bf7a8f94b6337633b7980055e2aa0fe5f4bf643a8f2af18e367611fd9e3ce9087eb0b2c4d5e1948e8282b036e28970c125de737979c3396af2370222f04f0394e03cb499b4c74b088955e7a924de423fbb72be838e30e027670c9ceb928df0ed5b1c6eb5c84ba2cd6f343f797a5382b2a58e13861e983b7555ce049feecbeb0ac6659c11cdd9b5b205fa2f1e3eafef4c6cfa8add06bd8787f59d12b84f2c564e1f6895c627335a13273bd3af6f44af48c7a92966bdea287cb681cf2c1e9074fa1ad9f23e8fd3a213dd8901fa4d5b6ebf9d3c026e2037635bdd13e84fe55f963c22c1f21a10310b02d8682f162b98726058ea51da4f27577d798ef08c74480a285415732356a81022b5a10bfa09b6794bb05576db696317b81ae60ddd1be88f9626f93d9eb8bcc79a023928ede6796d534e9991afa013c1cff7b9147e7634df1a31846ab47f9ee402816400ef097a776c32f996a45d4cea8edac3ffb6df683de408b775fda6092961a056b0bffcad3dbadd66c7025ef8944df43050c2582f28c0890cc4c37066043f5f317e1e1ca60174b4e4b8ad135a0bfcecdfc7845077d14f64b0bcbf07b2b84e55b8fa1b7cecc2aa4f41be86107508f02e727ea4ed0eecfe6af038b38cce36e1775eb95c4f1e9df24bbd8950f2bcb252c3c14d9827dd4c1af03c2d11a1e6208fe1f12fbf84808f6f4da0bd2740a8f9b669c2c3598894d2eeb241f418ceb9f99d5cee96046f524cf977aaca7d79216e006e6ab4d4d0e889ef656e670c2ae0cae0cd41d4509cd1dd453662f5735239ba0076ace9d015be8c48976e028639c23c6937c277ca9faa110d63719782d072a1f42b140a55e3b602790967f77b4652199415793965c130e56680534044e7fe0c0a5a4cddc0ab65f435c7a8d452bd934af8f7ca9850227c0e5aa2ddadc8bdaf4cb912ee25f571972787aeea0e6f840e0be574ba1700b8d85cbd955f5765988b2a42649753abf9cfd8e55ac1c152a86bb1ace8fda92982b5f9b2bb6ae9534acd48d804ab4a378b0ce1203e8ca2a178d39c40906a1c28d1658e9af9446e513b4c4e3e261853b3294901a4d01afef05fc8188d0e35cf35b54430ebbb7e7ccb8b3c4e1ed7b1db9b7b76949e1ac8d565587f359817961999c8ae2de2fa2a3a280d428479ca0ba92f7835c7117b0f0ddb44e150a44206d1448c748262912fd8077e37eb71ddc286f3fea97788453fa178cf5a43a62361974df077363b5c03ff2ecba721a558bb8ab095fa0ca5d8ba13ef91dd87c903a77f154ed2fd119d984f7d4f8592a6e3b66f275fa34e6fef9ca2cf0112fe3d4966661c8b3371db5e1fd80ded88fc96a06a1c86e84c1aefdfbf13acc1c099ea0b24a09674be603706bacf536504025228130b4794aaad885d830756e4820e2459894a05ef114b3aafe5e6a2fabbebc9b6064fde1e816b6f077b3bada8be79391fceab67259c1d3a8906438b243bc1432604abaaae8d3445e0b3aa511b018c9fb12a539a259ae084d8a28639a1bd8581c54a67ec03474f50409a257062754db856d5769afe3e3501cf4ca055f3c2da0f3f7aefd6194649d57208878cf27407b0e9aca36d85ee81fcc7b7f92ad93f9a7ef35c22ba3358ccc8e5595db5b3f0131fb102e91c4485772436345f8af555f640927f18360f00496e9d0815d1d64407c5e0ba4b3ba2c16e1d2a272261d84eb2220768e545aeea3ae55f890ac6d68981d62f76b6b3395cf0e1e51a88f0ddd1374a43e34b2b88c3cd18a6aa29e582ed3377718f373622c6176566774f9491b920c2df30659a7c89bf0b4665ea55aefe01b3e9f3716e31234f730ce68fada0384009781e2f4292fd7246b53abb6c1b75d304198ce1324bbd888d2e0ba4e9270fc68ff8e08350a5c31ee3fe0c5a06651df141ea965f6b246a2852a05d61c1de415232c5a42ad152c132eefa9cb6f1fa549db420015c1d41ec266cc0a3b4126e51144e12be3728ffadc6ecc1114ed379ca3796809824f307c31ef2519c7d457dc60c8a40c55778165739b0caa9a35ebff23e5520a420596acec0831d6755bbf23bc7a20cdbdb4159bfd49ea3d4eb1d340c481a7d04e1ab8f9b6c2817cc93473989963879d13d75c49e6cf6fcb6045506467c85e4753e8043175328c1a83b4d95f63c3be5f3d76e7f05da0f597aaf0d7f4d11b2bc257fb99667c191293d874d068a208e9019d74e5189637b106a4875fd938f35ea2c7dedb3c70a00d0814f551938c50231f44ebbc0c5d746e2f4600b97fa2369c836e0674ddc5a01b35541565fcd8af5349004b1504e9ca6d3360b8bcb95ef4e72738ccc54729f7ba6e2ef089be25a69345a2e0f546e52812da740da3266fa5ff807e995fa9614b23f62466287fe9c35f1533b22016717c1c4f322f017dac70aaffca456c326b3422550fb31b5e65f786e95ba7e86650ed93b74804d6ad06545a70f0c5d9aec70cc974acef8515ada256949201e18a2261445c29c4e8f3393756d98a6c782aab1523567555ff9e44646455eca9360cd099a04f0ca89649fe38c8f7ba9031c5f42d3475b6fefbc9320d526a7097a65ca9f58172a989589f0f3318e1edc13937117d073e1e66e7f2f277785de038435d6439c0c3ec37fbf67449a1d03088f61fee9a3cbde2351db25cc116f19ebc92cf2a10235ad9e768c6257e94de22f8ecdf8cfcc97e854062e3257646e344d906009bed9130793866f90cd64c1c7bf8982dd5197f7c673d8d31d01c29296160c30bf9104a67c57da5d8210e79c683198f83d8e344885e5fd5d2c43ce8346bfdc352866f6000ec181b4d5bb29ed6180b6e9f03a54b314565601c92f612dd76522c3b62510c8ae0aeb489b902b60957abad54873f41906e26f8122565a339ab6857cab02e0f5d241ba6d787fab3daf420f8057489507550db67e0f168150e8cff42628b7e0c4cbebfab8021a926264c3902d1ccebb8bb24e87cb2cfca303f2d5bd72b415ed950176625b875893a9587f092500eca76db31c306979a42c0ec20c44700649f8f2c3a462d81f9f6b360b2246ab94dfa6efa111f69cd80ddfd7f5d0c989fb59cee2cb5b0609489eada8341eadaa17df00c1918879774c9048492739e7d52daf772a023fb3d5ac329b996a6b45f3eda67b17a95a10e22788644e471fa6acdb7a5de9fa5063c981970455b5429a4eb31b6d80f4a0603aa7df4e29604f9930ccce668ad7dc6dd84d6e59c55987b313cbc0cda313285bbaf80748a3215f36832c4eeb4659881c9f395909f4d8fccfda2252a3071a3ffa22a2c06e32946dd81ad0b058687965301ec0c75d162c2afcf8270fdbd989411db2def11f5c8c17b7fbaab647257a051886448c4c458034c7c6e54fef92f54f5f31d915d5a4fd232ac3b25fbd9caa29838e42d1f52b21f1334f2bc66b99efb83fe33639206efd9bb7777c4e2706f7e542e29a61ce5d691c90e3c3dd415fcaf39225c1b1c0fa8c2fc32360da07ca6bb7f3d8c81bfa4d13589ae7f5e57af0bfed9c329203e9847475d5aeea0f4afb632f8d658574e21e0024acd30373ca0ec2a3aaa3618640ac9baf36aaa5d87d755ee68e38a1dc38f6127e794bd7f7c59523dcd1a20fa01119204dacd5d2afc05eeb2116ef96e72e6fbb5c30eaf446afba372d74b86e60fade934f44ba82f4b75b954cc5934534f6584795f03fdd29a84f7352c2c702705601086e1004a5c63d4414153d6c17279b45981679fb4d631d0f10d844087a6b0f7db67dd986ce44443776b99d35d804a93d6f5fc2eb1dfaaad469269291aa6716fccf99a4bf1515d38a904d9c893f3ce7ac8f7302074f08b6b47380ab44cda447d9c7f993a629b358bd0ad810172195a33ef5467efa155e9bdcf972002d4f488ec2ee29dbdcbc6b3091d6ea9d1dd635a6cb45ef1a541c1b22a50836919a70ed57bf6146fb3ee87437f1df97468b14a05ab70d04c2a228ac3b43b5f87a5ae5173cac60aee3b9dbdc495c9a55dd599f51467b1f1b07d559972988a5006a03e6a555d93bf6615aadc66b2615f8450615cd7ca29e688875799886b2b838dddf2114914bc66f62a3d10a3601e3f9a1c9ccac2cd26a27f09d53d6d654f8da92b71567b16e06711b77a5430fc4972d613934fbb900cf6ed016bdda71fd6302a21613aac4d2d05392eed6ef3e0a415e61fda0768416b99ba57dcf174fdb3f19dd94aeb5620662fb021cb6bf2c1c5e9a721e2b6fb56c7d84f4141044000231237872a972c515620efdf2044ad9fdf3fdc6c2fa23d03a8a4f3bda8ebb994a89b865c21d4ef63eb51257527ddb39636a31990b124e18c93944581104b9017e4b16c7a78eee13ed7772604dce83f0e5e2340326148d6b9324ba8ae2e22872bcc6aee94aa725ae085fe43c1f3608b7c27b0df9485c3fa361bcd120c16b0f8e3edb26a521fc79181b7d8d58a58e63986c9b518e8419f7c3f6a3a40a3bbbfb1558a8493308a21851fe84ad6e8f4503674e9d9bc65cdb552a65ce4719f59eaa059884aa95b8bc89627e26fb365ff11f31d560d065f14dc0c22c8df7c80410bffdde272d37345419301976c86a4e95104942eccbe036cb196617d6130a097ce93d748d3858c057cfc7e29b1b874b1f2956ac0d3a1f8e5f756a86a13eed8ccbf7ef720eb912b60e8a5871bdc6de01f56be6d64b84456f103ebb1401ef238b28ca81ae0f10614e21d891fc2ae4d7cd5ae93d1d0eba0c1faf844d81d4b298d85e81293fa2d7f9c1e2f3f9c81582ee87337728c4cc249a053b6c75ce94db526cd48a0d8849303621fa0021efcf93347bb9e80793ff2464f640d7e72db6d49fc22afb3326f024f126f3c8823c4ad00e9c9f6bbae7beabb276852cfaf10978e0b4caf2658ef3b3d768e60b05358c11ce4d1546511766b0c097c814e6a95bcc5a733210ed4d0bad518afbb725b001dff0e15b00f7723036dcca55de5bd45f3ee179760862b4372a9414bd9211a48a67efe2cead005f7c4cd51b23ed5353b9328e3e96cd4728f5744fb492e97a08ac63fc1a32166e24f20c870b58e773ea330b2d5b15d6ae15c52cbbe805270806605835856f65efccc11280365961e0b6dc477b9677237ef4d00c7ee41ec93f7b57e1c0bdf7ea8ae05103fad5daf26bc8f37a58ec8f731484a26b266ad8e869c154cefe826a6af386e792beecd38f88225cba22a04b9245b74a7078548e092638077adee3bb46f3f961aee96afad9c0b9b87b863e2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
