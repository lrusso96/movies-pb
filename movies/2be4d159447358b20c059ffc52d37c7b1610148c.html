<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6405265d008aaa1f6e926363cd6ad13455119b190d94fbb25ce7ccbd23a9c73d5dc7357f515d9e45d1a22c5552a936dde3a4399c72dc80ede34b450ba7bc82db0c3790c6cd7f8759259432619af554880f250cbc114c2e9756dafa7d0b05b7b533a58a5240909465a36cf7447cb091def5d766e7724838e568d91fe07bce1602f1ab7fdb5944afa675ba165faacbc0486a21cba7f34acf26c913d016815344056e3b594df92cbab9aec1c719b354a61c36e1fc20a4b41a1df98fa6e3f313a8eaf160e1d9262a9c5ca3d7987f474669f9b57cb5d15b73c409169c06cd1ecf26e305f7fc7b256a9767a2b50d62cc2073d879ee4f655a10854c9e643c10f7037b5bed1b725bb659116092e57f6435812b2d98386a850ea88132baf90cf4ca2a7b263da157b43999538f687507ea9903754cfe2a725cb8cfc9911f8601a0ff6c5d9fa2194dd83bdac54f230dbb832fae69adee2fd0caf482ccfb2c4cfd1b432f371c00a37abf18b434e36b8559157d4dcacfd1a043355eb59e2f8a50dd2244aeddaf02e9a12c34309769bab91b07eb5b565eeb580b7c89ae7e72524b3762f53320df847109ba024558ac5b28f5e2107f2e6b122686b5476184285bc9b91aa4367bdec8056471a5ef6d460a586486712f089a6cd27055e7b79d64aef6e68819fce1e64712959dde038980e122fc304bc0cbd95a4c34994a527e2eabbb81dda9ec56381a758183e1ea8a1d36543ee11cbdb278ef069829a0cb9e45d7d33f43bcdb03b60044380215e589eb0d01dc3d9095cfe3421cfe80e78bad16449a293cb14cee003137a8a3c4b0247c2986cc0e59b33909aae8325c31b56162f837d4ce5701cc1a4faa3c5595d410d7407331df04c4e906436aa1179ad8a04456e5808da7ed1c56915d564205ec0e833b22e6cb40d94a9ccfb1081856781d45100bc76de3de92b97aa8336cf0c9887afd69ba9b322264e4cc0ab64ce6af6583442d655ba01d5bd58fb55cc43c1369e9bdf4d78d8d4f54aee58a73830a1e420e857a9dae04e2f1ada0b5b8fcff6315951c342b9a24c5419d73cc5a86eb0bcac1c35403252cf01b99bc01d07d8b8624da3e687710ac21b143ca2a7e9e9c54326cf62197a542a440acade99a27680d04f996111d7f7985072340a268e12fd2d3ee3c5630a9c31866324494c69cdaadc4fc5014d98818bf694ab852be14f38ebc38d64bf6336c387a34989a4dbfdbd60ac1a5428f0e3929606975d323558fc8190a6a5b3e65f57c1329e573f6619d814d570385cd86b92cdbb5954961e2d8c9941abb7703f1b2f9f169ac2a8ac84a69922bcb8b102fd74ba3f85172c50c1ac4a4e01917adf589abb77a6981a7c4609c4efb780e57a4ddbeb2c5c8381e78e15732985ffebae08d6899a2835582171cdb616e97d601678185e7d54cb57e8c4b79e11046fee1b91a99df18b7b029a335ef39aad4e676478be612a5461f36d4a20416725ce39b76241d41b956877de902bbf1c22cd062a446ffa941887823d795aeb7f053108fe0ba696e7f2a654a6ee958115365e808134f5a67456baf0486f424d0f005806bcf260d9d9ae19772507326433e308a9cdd0706715273351a169c73d1fb9d63a8fbb50f8422f5e20692a9004125a2f55339756bf57df21255e61d775f84d71b6262e6243ee15d4337711115b7c5d29309009db7079c06cab51164425141d2350f52aaceabafd3fa28403e793ecf82f75264ead59d207275ae98398ce8932f5d34e75ec97d0e8619c819482d8bff1c52c081febaf88c92fc604a8740e69073e1c207b97c3ea85d7bcb5788762b96511b55fc166afdb7462327451a15af22c57f2b7c3283fb11d38c37c6ac4a556429325a1b42f53ad17fbd44136418691fb70a0ac4a1231fee1c5c2945a059d14758f8529d8bdfbeebd45444a54f509fb7b5da3ec0e32e9cf6cfa90242a959b4bde2fedea32075afd7d62c61d72dfbf29e5d01e8f5251da0f7745bfea848a58ed99b0a334f75fe8640c1d2babe07ad681dc8e0cc37fca26b37f2fecb35cb3624d2666998938613762f3ab637cd119e317398a3f1884a7e10c3f70e82a2dd97456d2083cc4216136e24fedaf70c21375bb0b8cce3b609884b74efdc5d5b750217be57a64883f55245ca3037566f7110008b275c4e4f8e193c4b4f06e488036c1f371ca4c39bb58eb73847895a017ba49f4e4db4b342ff4901cc5b5647f687b68230621b01c68ee00d195ee2544f70439ed416c3a15dfc518b1dc29a05906b2a9cc5934d7cca578e72874ac3b23b10e326d724dd177e72cec9f25f20b7ad9421b27873d7b6b08668ca2e4a6709f0bf379a7684f522c2a181ea6c9da7886b55ab417953a2ccaaefb424c975560fdc9e834de53f522db85fe25aed302f3ac727fda6be13266401552a051fdc49c6c7ca02b5732c7591fcbc4c71dde2edbb776410b6e7d2128c3efabdbc01f7f091e8cd55e8b206de79c97507cb4314da9be0348b08ceba20eb9dd22b7359d51afb9bfffc07804460dfad8578d94aefcebec433a2d4b9430180c60291c552b6f8991647ed83a1cdfea0b9910ad15e552618782798989816e32eec357f192994e070b3fb35b8fbf82c95599152b4233301f7338cf332364ac536233a18afa35f8fe2970cf113a435a34786c925ce0535216b49e54ef2262ff292e5a140d9d9586fb0ea58da8dbb1e16f1a3bb2cf4fdddc848e5d06458c684f01565d09314e02d5546758dd2f8a2d249c00e8ad14fd439b2c20d0fa16929568cffc38175579b426acc85d5b583bebd541da435ad6643e4a37a23873fe01da7ac25b099574894bd3adaeaae75cc1324a77fc08bc8713a55f2621411bc460938671090f37c132af1b026c4b233b8ffb2114e16dcb9f6b43edd8ce2f9fe1b4401745431cdb6864717f86c397d2d7ecb940a66c240392383ae8e619740e62fcfc758e971c1d6fd295ebedcb15bbcd6ec1597a8ec1420c06d214e54a0f396b2765b342442f5af15bd2f0797130f4adba579010974ac819768f5ab7f8c665609a97ac896c330c98dec378a7c4bca008eed08674c9fff5ce04869353ff023bc4c4c518f3bfe64576c16818890ec37c0b7e1eb9c47e4e101dc08b1708598df46ba60d388f58f1854433989c372f582a96199f012c819ed7c6257c6b88465f867b7916bb0d6e9c3b2c23666b85b45681d48e9267151df4fb5d1eb5dc518b6ce44e303c4c6a74f9f3bccc6f9a3c7d248e7164c5c406c3de45f04d98ca62ae9dacd8bab3c468c32ad749955016a3a9033c1482e059926247ab7bd5dbc89fda9ef01986849aa2aa3b64eaf0ec6c9c1a06ffb56fbdfbeb2aaa1bfea4cafa90c693ffecf41d50094174073c0f2ba7673b54dc5387d7ae3b4713dff7057509464579098d763a028dc4cb4b64a94857ccca928ce5fc0da6759a24445fd63a666777616e6959a61f057488b8b7f3922e4d6c97dc1349180340eaa3e22cbe323f5a8da813fd0612ef78f556bf2c794c0afb08e582a63d5cb920cf151a2742a6e70a5412982226b31db24a4baeaed9f7d2a8327478a1be807c4c0e376ba45deb214c53c1cf23c38039ecde9d43d959fb4d648b2bba31694d999fb5c41b965fa4089d185953f9c84f990dc2ae7828390d03f93be8600c8f06fbef2453e5f60e98309c71c79244ac607b8f046deb6118a25832bed9f416eb30136453fd4bf9b2824be2925df36b9394b46583f1189f81a8ec240b816e999e1062e83e788a25c9b1589298f3857116eb614e90cea76748646b64c3af58f14715f044563430f633c49fdc9d1f683a2cd93de11cf6bae805ef648b64921b105c28bc3dc573997ba3b7b449bf70d5281edd5f7af35fb82465170d08b7875dfe5a13f59a46ee790ae7be089144acf7b2a4719dc65736ccc71630acae1c59495519dcee9e91b1813d164e0690d072e5aec9ec7f75cc1f35818e528ca836ab919c87ff7cbe191fa070b987931f089ae9e74fb770dd9212ac3f127750731f7ccefc1a626377472b254e2f5f0c6635a3bff19874174107be3024b440b20d26ccff14024c38dc645e6f51784c691f78b6810305a7e19e87aa20deaa7e18748b5447b2d1a853696e18895f50c1b351c675fa7af08a2eadd633318050d4952da00c7c96132df93ccf66751ffc04f97989875d6da153235b7a9251b190081b9f4d4654369f016c37da94cd7bd81624e5478b5e64d0d04405cebd5207bce0521a61630d6da199416b1cfdb419c20d93312552bba20422ad6d5388a6be430999b07a57754da69074e6e6c90039ed9e5fc0860673aa2505afa2907c781658baa825bf50e4fc8aa635fec5f41e2769ce4552d024e3f768406c391c9c3cee9012b1dc2efa363b4b983a1d2842b1841b579a6e1b10d69fefa149672ce076b63764881c27f666da7465a3cdca76323172e8848f913236ca9f1a93835f202d7ef6b9b4ada44f2519187e4c1d36f87b5924c8c69664b14c876a3ed1341764f26399c0f75ae0621c64404b830a0cde27486e644413e49ef720e9a4e8e2483e4ae1425fc967509776c12e84f0e5b1853c1310b9326316420d418333146408a203f7fb6b79e5a670242955c1321e73f850e05cf989945fed72105e14b994f7a4ec74c5b82b69d6809b1759f5530e7ced971ea91161b700b733815ff68adbae9cf2f138f3d67dc24b30b634cea43416bf56fa2f4221929416d5ad1e147b751f508ddf8c7c3a710ae3fec86a05650a47732a4a0f20405f93b97e160c9dcb88559d3cc082546ab26c057e422e959a667cd07989e9e646aa993a2677d5c155d141a07df463a568c9c976f9d866b3db044fa77b71dafafb8aeeddeefbf4a94bf304913c6d196869625b1aa911418de0103e12ddc0304956d0a91d515f3d365372ab7354717f68e69f6beb5d8a46e589de5031adf82a3ffc39cefa2ee238887b87c44a3caada6625bf65b83bab36bc17e7c3c960a3e9e17b7682a6e3f126b3ab3520c3c24bdfc00d361c30deec35e00c4e118b63881d4bfb6b9e7d597d8bb2149b46c20f6d5c669e23f521c4aba15f39513b278db739e3a487cf8a0beef484bbe788c351fe77c065cbd2b53205045da74b90fb54354a184cb1619014f3837639f185565131f99c40e598a5e93f35268b6d0ba7e1a9a1aac6e279d75cebc4839596de28ccc5e748eea63040ad695b078915c6e73b6bb270c34f20956ccc2867f78c588eec527fccfb50cad6317337935581f061105ad7127335f4f57ff2e415bfdc9faeda7dd62b225c9da3cca7e3b65ec38028bf81492ef1f413779f2874a156836f41e2a1ad83e182e3533f6dfdd4167b01d90199a4e2e2b425561b75456421fc07b77b4b5eccc8dd89b3c4ffd660d52e8aca651875ff005dd37351683f4dcb9b3fab27c8993f29b78755a4a4e98e5c1f3a61980d05d0dea90475e49f36674c817ade51bb3f860a1fe725dbdb52e8f8ff68069438da85df407167ac90c3e8404a67a91e31816a6375d237b89c34daf71bd5e3da3706034a6142a2fa5f428c5d7cd5d624a2801632008bbd1860d35941c151d09c4ad0d663fd7a175f2971b6158572d7e4af94892afe11920a03a35368b7924246af9eaa6e27cc4d579f19d7247b0c74a99d0cd6521d2447bdb812571f889c83cfc00b536ae4af8553152d021bb3cc2604c301539a313646c01a73767518148f0fa7849f7909cb1bb93bba092d9a810556e88b029ec7c9ca4ae769a3c70fa74b37a829a8b1ad19a18a6cdeef5c685b71e807d07099bd20e718cddc05302a748c9a73b636d566bcab27a3825bdc63bcd875c53d02e777127295b2ef90011aa5020ca2fdc4eef2a38e8db005fa3e917dbb59d5ea10d32e00076a0846e897737fe95190083bd2f915fab71f664bec33cea9c89bebc56c898251304121260d605c57f62df9aa28784efb1b29fb15c9454c1aa2024e4ef726c059dac7210139896ece9d25d8d74f8db47ad6941bd58ad7220017f5eb700bbfdadd0cb23f598d62b9ccba2317b69271fb7f7542849d9c48c6a9e343c95899616b7c525d9e8abe946868eef85676138023e2b6cf164b4b29a8e0584477d183bb3bbd8370838ba78886588201a85ddc26ba620d66bb50cc96ad4bb299ba4153413935133be2a8c07bdf73f939c2b6219c2ce3cb6b2308f613f1371484c9ba71958c06dce546b5f073b174761653ced5f486e4c0cfa144cba09ce5c7b6f81adf5de2bf04d9536f5214753fa0c861fd5dee3e6f856e91ea2a12015343b759dbd90cc0b6f3794e0eea1224ced322538fab756f98a2e4901bd8b6bee30548cd653115d669440f8ce61f4b83a609eeeed627f523069f5a797871b42366ff44cf3988d99f0cf4db7e51d05c18c171f9c7d8d81cd7725c7a0bd9dd13ff903e9317cb8a8f69e9cfe0a909420d67acc65c528ec2836dd19d28ea2cf3215250aec23d0018c0dbaf0bd9a937c9779dd275b777e7e622c3d45a75a715d0cdcc0e54425778546e2396f59f9afd20b3c7acadbbc81d1339261d6e3734e7852d4d3e0f16a5412c0365b6a56d5d2f49ee22d2cbd564bd0910148a7e599e0d2eb6195572e0050b191930de43d78cc18109c0d489c8a6a26a3f9d61c19d792c0ab0b86005fec86cf6e1081dde57d21ddc11aa7e9a76d40beedff2f817f9b58ee2d68dce749fc4d5ef6984b75dd4a3d3ea562c482228d80d02c88bed0f90c535d302b17025bd157327bed301ca5a61cd8d4c4d7a74a617c9a18fc9492eac490f88d45695a66b315e168738635b830c5ac1d1abf2fe6621723acfad729b13d198376a3239369acdb23394cbd1d405cd14732ba1c51c9d4060468869a07054078afa8e2ebef628f55f56df684b80d8991dca70ea2619597fa2a0c5d4358696daba5ef643a70976808f00dc60ca3b174455636a039150e6381b6a5532f9640e216f27482db867674d6ae5815dbb897d8cc0748af8abbc39158b6b2941928482229da3abdc6a4baf9656cd87935706514905a2068172e43629fed905c2528d662aaa7e5c94b1a54e319cfaab82b3a19cf01516004c44fe97bdc8750043c04aa38a6727b6c20cfaf5fbb95ee0c9b1e0bc62dc991cf2b5108d27b34c7d6b0df3f7017a9369c5b77cbd6003b1156879d8547ea5b60274dc99f647c7d687f21b683dea9a038cfc8028d423950a0810b28086ffcc7dc511ac2444e8fcff7252b66b7c7e41d4dd4a8ddb683f227105c1cbdcd170cf47fa586c91c4ed1c9d4232b25d9d3235f406965d8a25f58b47df288f14d9f9cef40b87db94f79c9d1c25e37f002839bdc4921e2c789be9b8cef4ed0cec3a9b1ba2f0228629082e877933207a3d2d4d150fa18b05863b1f9910e6653302999615c86bf53b4c38ba9f0c0f9317965d2e4e9c18ada7054ba096d3c3ff7a0b379254da83edbb0e1c6703c8ea08501c63105b3639e3e50170c91114d7205ee05eb935d10f8f1ca7b3334fdcbbd847fdbf0ee860bb3d298a50e7cf19f9e888eb8988c5ebf2779e78dc6d8e9814f40b4ffda121edf59a280580f1e2dd6a6aafc6deb877814acc25cfda45f26a8021d97c181d2231c2d58c9dbb60606adc9d4bf98b241a48becc9207de5332751c9b6bb228bab5494a5cfa74c565e1727ed2917ff75c8dbe0e01f62b79bbd1003892bfe7b9406c767cde8adc85a071fb1623a7b3187a34084be91a8855bf85df588c97a9cf257f9d3155e322e41169562b8158c4892b6ed23b348ffe07b31aaa51b0d7ba36bf0673a20c757a89f7a982f6bb23bca2a1aaab85c38733a9e00f6b82686d376d9209cd371170ca92f14b79a052aa357284a0f015ac42bf42ea2906c689522b53bdaa101889043bd9c0adf12a41703dc629f9405c6ce381c6c0c9ba13757e1d8ae81940c57323a5607b1efc0d9f3dbe4af1d01dae6c23d3f84ee7f8e6d1b5df1f1b2437fd6cba819fd9324f8009ec3f1a1e48c50bfe5f925c5d704607088efb1ba314ad77687e848ac020cfcae2592e252c7a13931c809cbfcdbe67f56dc2dd5b9301c24639170c87454d3ce7ad59afb77164897aecf42d97f8a9971c8946c9a16150f7e606eb720211d7efab81c068392586145bf039abe1d2755293a7be9689f18375aa8cd9a9547f101249a227eb6baec85f608052d86962364d837900ccbca0097ea613812c64f8581022908396a4e5b88067d031d65f5cfea7f0639b8b463b6eb905d5244ab09fff04a2bc45218cc4abc024cdf88381fc853d94b55b3d1818d0f50e68911a47d5ae9014bcdd9abf5fdbb82e7d49c622f25c602f56f4feec7cc8140c54ba3f1a1f2b9d881325d7fd8cadc17a9cdd0c174fc031ce589444ae3d7c8dff7dd5d611f98fb5e04978715ea93d0bef869c4cfc213b65b58bf399c2e1bb574e7a699cee63a10d4abab7b4680e44ec1caa8c5deba3df534cca41e02881ea263f2ee725a89ff41b226dc73eba045c3cdff528dde6cc62796ca23e2e3d60be9b8e36a086f44f19dad2225a886b9c0ba223d0ddcecced077e41bcdabd167b10e24a0d19f291e533ebcd6f2b5f968a93f8967db3b089b8022a57a29d7f033bbaab9502f22f6ca97acd8d9bdb2e30f74d59beb11a481768471931199f7fd2722f18bd2e51cd16830073f8b27ef51ce00013912a6d031826407be49346cba20b49a1d5f4e924b04f4f34e05299b8054b37b981a347ce69036f483f132295021156846fbc85f7c80d81575cbd08e669a99b6d8555803412f29bd1288e6b7016be7e598cc52e63a0bce2d1c8c136be0a2d1ab114a9e17285f37961adfce742ff946d953399c247b618f49f59520e1daeab0c05f04e26f015bfe1afb8b7e8ab49a4d9e121ef69f0ff54b9365a3bb8b83af6016391845ee37c4caabc561c0a7aab84f6473f69e16eddb35470cde9fd593de1189f8b6925843707cd5cb92ea1809e8ee55e60918e115b4dedba76de7a9a075b9d2ec5bbb0a560c7d1c734f726171fe7ca57aeb594e6a0c201ba45f0bf9c76ef2eac67d15bd95884101dd9029a7b88bb483edd63aeab060a33c253275b2ec194b63ad47ba71dc2dbd067e33e6ec91fbebbd634239d5efcca9560d32b9199c4608eb07b46c3b5572f8a9366631e262802f5dc5b6a27046cdd10d00257936d8ccbdea0436f05e9cb7e833770419d4bcaa8447242d48494d0b4f478be932d4f96215cca510f4ab5d448d0aa15993dbf80066f784530001fba2441afa23ddcba58dfa3fdb2419630f00209de00e3413e72b100b3eaa943b42572783e38397be5f65acc8de01546d76b3e5ec974793f271a7f7dccada33d1730fe093c4a8dd11c942cfcca99ffb95a0cd605fdb6343909c8b1dd294a4f609c9ab0b0de5a02a689b31adf733b119c2c8e4b45897654f8906a7b3a968fdc11d1d518648045fa51a64fde400961eb06ffce42bd54c10d388200ec332c9f4522f589a88748e4771a6f5c2861acb75777e0d7c550a82952f4561f1781d3d81bf617a307b7caec5e886c3b79a2be92d7aeb85f1e760a1d51dce17b84e976bfc496da702ec944ca5651687369148b31e521e72d6dab1f80b15c0fd90d648960362ae6fe76c7e6967dfc8202ab15078890987af5342763366ff32d93870cef8362e2e777e629c344e372bbc29c0f6759a151536ebba03025d8939f40d8580470cc1447a44a3613cb2206f7c8c4c99a1632c04ddd0afbb48906b052f784480c9a97b07ef91da9c1bd36c6f4cb688a0b46d1b2b16bc7845f07708bad9cd44d86b86255bd97b5e1a9d51d678ce650d2d5e0d8ffbb1736c65450d768ba7fb8ea37e88d387aff909de9a70172aa7794a1f84a6dd3584638a5580d1ad34327c1ebae928d9fcf37ac278f7370b9266db66e3ec9177fab35983fd7e00c37680a50503c11998e6ed8daa7686f5a0b9f6242825f7dafccfc7b566e3de9a1a781c77d1ef2975f61a4fae305fc37e5c8a7323324d9ac2219d69fda208f45e72c9d60a8c2a5ff4da9a4e91b5c6229408d7eaef776f501a21b5022e8e0c58b4bf93d2984b4e80e91100910f346526eb8a69024a877ba5a75bbbd5b37d6ae12702a2c9d044903b1ceb94381d6e5a2620d2c584b4c2777059273631c2861fc82e1a646bef8c204cd2cedd72f6510510f0217e66bb1d8d436ead9c8eb11d8aa2665efcd9ed5e1ba5a0fee95c8fe68a4c8215daf4dceab23c91a49b95b46120d88078727ed9e663944992b3733aafa3757b53248ee0cfe5b364b9c04162b42aeac6e99e429ed7eda7112f7318e71294ce5b027fe34c3409e59e409b9d3c84414b53baeeced0e17d0754e11382194afdbb3ab264487f0cec6ca2a81f91e3c8aa9c8364be8e696581429fdcd83031f0a31748b9f94a5ae45e98a96685fe4c0830c5089bbdd027fae4cd3dabc19cbe640115c054997b8af4abb492406fa82262d7b4ba60830635670a0a7fd41d9c2cae30e8bdf495d81758e298922cd1241514acca95d23d1d190dfd59d375810446062f4d14ed12edfaeaef1c7cd871856a8d306477661f3e460fa20107b797e8b67f04cc4ffa3cad9577ce388dcd03ac4928ecc550cbbc269de89c30bda5ddccff0f09763daaabf80323a2da6aa5761f6f4d33be8a3aa100d2abecbd45d4863b633225faa5bdd2152117bd364b2164031c8419781213fd102374430601ccda4bd8e26905d19f726f661214062e495f92c38a37a237f489025381e4e14fac0eeddaa9f3601dee3534085e1803a45c970e1f154869f55593720a257e8f99d907ad08b0470e4019e9977249c1ebb05bb4eef7e4ca6c002acfe59b297fa64e5e6df12d7c8b07a39c4ba2743f177fb3c24e451318614191ea1b76a0e13881757e7916f88adc5deb638cf22ee9c3dcca1cddfff1e99f4c8a8436c5bea6bac1024247d397fc5eb386439e9c43095691ac807d1539db601b2dd9cd0f4be1c14e0a721e5387b25378aa659ff55ae2cd8bc6304ce13bb3118adf27afa04338bed8a10e22ab641af526b2fe97fb695101d9294b1c9774e4b729b9b5bbe14f08a7398a64ab4c159a948b98dc258676835300135f7c3ea98296a64bf13a60bf60c36ee12d47053c8d9d4cdee0ec0553f81d704163eeb2c266a0d74adb015dd917df6e97ecbc08826fae8e610757f8d643e5dfc224a492d7e8c6e8ac5a6a95973501f50d5d2c04ca8792ac5397929de9400a720578a916eac4de02ca55354595a3a9bd8ddc7144620b0cc644e43cfcc6e352b65c0b524761cf37348f2c0317ec108628b7bd12170b769bf99b315c9349d17a7e06484534e6ec87315a436fd3d27d8adfc5a2be5746ffbc5a3be037ff372af092d31af844c75287ed4f67ce7e578d30dbfd2449ca66ac76737f8895c4addaaac05d4e7c6451b6d301824be2e606a0fb6bbe87e7b20ae929d4eea931babc0ff8807114eaf54871dd270a4dbab60effb39ee0a523473e2f2673b9ba12185d9f5890d768cb4f152918126ad6102aa97ee3651d1727d63c24c665fe16f11c44824c6d78496590e3b133c21764002221c7bf2fa685e9c09985dc6e3cfa29d9e3dd704c7a484db2e84f90744eb65669af5e6f6754291c49994aa967960a3459a1c95e043a868782a50bed95665b01201b3624374f3b0c579c24eacb38d7b1a66be9adf0f46f9e50879e4f56c878a51450a2a61e8565c3851135f1acbc1cf5fe94db0e10e60e63facb897f613416ffc11a4bd06f7666d1670a06244f524e38ef913667df6cb1a71802dce9d9c09bf49daf6fde96ca8a7bb9f7033375044b28e870732be6afa96a80fbefc54e91513262e595eaab9a129e8ae580cba819b39ae40229f5427c097ae21608599acc88c537859245e8cf2e275205b5dad31cc059136a2bcf9b921e0b536201303fea06c1b33da2e3809bb12010762807891b1b5d1e496c0ad948a3b0168b0bbc7a14ac056a6792c0bcbdc4b7cc77b04b66c392088f9cc5121794c405d17b46253a8639e87e468ed328ae4122a737ed68aa8f4e1b471a5efc25d0cccb40279b2637ec48e63c6be09c7d742c476ec2b575d4dcf08d6eb8c5f745675dbf2d3b793c284416d6edc20c594c2a3bba1af4c4eb59851bfcea045deec807822d7c094588601f2cd7a85833ff1779529c4edd280ed242641646c4a6b83124cd2ffe1d6ca6c2404684893bfe4b37a37c179872f551c7f0160e417ccd52a8d2034b30dae217c8ea53e01d02fe0c1fdd8498dff264461af58efcbc4e3e0f4be80ef78828bee4b774a9f8f637224de74ed140fcd937ffd8b5df241987793d04c2d47722f016b2b4c5e7652100fff553364e88e396dbb4919ee4eacf09d8b642dd9cc42d2a54fb7b2279134192e797216bcddc6c1f495cdd5bedda42bb6c3ce47703b17835bda48b6aab995ec4724391a0fb0b057e0815ba9ef4474c7709aa924323dab646d3f55403f5980248cb725526d5f0824e69fae1e0d54c01a33e4e59a07174d672392fcc459b3378b41684ef31b74b3b01bc1106dd2f1f104ce0af18d0f94807224db125901291912759326e35a3b90f7b5dcd8a35689fbbfa576ab82f53c052f6ad667d132d24a784c69c8020ff9e1eb6bb6b3a116432a1860ae2740f7e37a930055737b4d8981daf864c86f37d08131e0469eb2a14e5f53d60d7b773226ed5b23417cf88e480b1eee2475c27b36d5a6071eb75da5895b63a0d307c40dacf9b8b2ed0b19f2f12eb9c949b09b8f4b29d2a564033842569a515afc4763e9960ff30087b8e0739ec4cf320463dadadd093af4f0c15ad68bbd17cb9c36dda4ae28d7162d930a21138cb5521ae870c49b959c51670291546bca5be1c75faa0fcb13270d67ee72d5190da627a9971460d530bcef5d6371222b3d846e8c1925f764792cd109abed7cf351c5b5667b1d9d0588ddf15ec9613cdb3da7561d7225d32b47ebb33984e93ac12de0cdbeed1775c5a3200e3eeec14038edcd6539245643688dcf69d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
