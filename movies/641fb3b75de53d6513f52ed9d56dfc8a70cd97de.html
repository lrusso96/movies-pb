<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b97c85c53d66c4571efb1fafb9fde592e89738e63e5bd6df4d736341f5f429ddbc0a4fd4ac634d75c7ed1143e36b260c876131eb6e9ff9220ad7fa2ebcd1fa12d7f36b40df1e155ea223795b25e73cff28a6d1321c90f0e0182ad17471c035294e5b9b1a6a5e4b173c4a38b0b808a798b6b08813b7331e52ba5c43cc3b3066609c937c02acf51d0acb006124e1995b6a4e38921e071e2f6abacd55cf8f33dcd283ae1b526a963691790d1ed08acde318f96df24c0fc1642aa45b81c46f5c4179fc1677bc207ee23dba16d4f3b3f227e8dbda815747c21eb58510a253dbe2cbc8165b21a7277b7fbc66f50191a3cd2fc81f0f7b1ea12c9cec537b0b313a7f7629a3c449155f419a9ac74a4ea20163dbf7e784f0962116cb8ed0c86f7f824042a25fbf0a4022012bb6a9523bfc4b940379cb8179b5d8e93a47dd7db6358d3bf8b100eee55a5fbdfe8f7b958b8a5102473279fc169d67c2f3fec7e6bf891dc7788a2a5df2b6a0937d1d35343dc88e147c1b0a441272ea3bdfdbbc803c86f708c7110b5c0c2e6189b326d4e6aa0a0a868ec3f87b7fde79b28944c89dc6a8f0213a0a1210ba1e0a0c84d361bf48714e48c5372e50c4861a1203a87390b9841519d1f5d7aa3fabf577e423f7ce4560c0d6b05a0805a645d37438274d98e16b0b42d67bb1bf16b61f5d6511067bfceb54f75fb73cf4231e426f7fa73d0d9e835e354e7e49a9abad8c11224c0aec6904321d4520cfebaf06a5a9c4d6f771fbd9b092d0cd03f5a8dd1bc83130daee0ffdd2b07ce00e786f8f26cd5f56485e0b9e7ce3bb9ea02d60593fc6c30412476f7f63385331a15c2db7fe6088d876b505967847264642ef4cc5194885f77079cc9dc78aebbedbf5258940ec96a873acda5935e91513e7e579c2960a23746d611ebbcb746cb439648d3a6791a4409ed14a7bacfca1dfaec446b7bbe54049667f0c4c9d7f4c24f7ef9de5650391fd9430b85115c16953262875252443e67162ffd014eb221ee79c07a1790c4250212e061fde915b50308db32575a72988a812e4e1cfec8e311d1115ba7419396ddf6d503f5f23096b959c1958bcaf5d505ba2e14af3fe2c79c8be84a73242627f8f04e0732bf5b96187ab90bd46f249cc1849702d48f8579bec7d1ab1360b94f4f616c94dd63289f463d92ef823b158bbae064f063bd4e6d6db94c1159db2306a615f4838ff663b19315e2daabd0f1d258cddc696d1ce62d61ab80f9ce7087a3442e12e765ba16dd93213efafcf17d8dc4f31d6e2b010cf8344c123d2806ab6c1105f1a663788984f217a533735a82786e72f768be673d987427267cc30bcd38c4e229319353413cce799553d05ff455064842fa1d9d6179af793fd5eb11a7a9779c8058acc6b7e7381870bf155c1bbe4dbe2c02f58f51137a7cef3d9bf365cf8d9e938877e1233ca68d3c7134b60e6754c257f18c71e905f040b0d3d951be4c5eb3d8368d8e57a0f255191dee405cbc3f38232666d633f9d7d17678cb7f4c48c7bb57f4ddc5f72c034bd26444dbfc246c9eb55cac0fa29e6bfc6ec69c5f82ebdf591878568c506118acaf71a4906ac61aa1e258c130b7e3f9ca17e2f4f9bbbf279412f081b7ddfe413fbcb43aa79f3f30b18d72c692286bf36ce799da62b362f8eec25db3e791bc3cbde7ba0ee37f5dfb19fde093ae3bc866ddca47c146bb07282e6b91700a75b6182a2794609c2ee88788812c4c9e763fa52f02e2b815c0b60bfb5b26ea2bdd488304b6f1ade31836befd5a4fb20c05cddb185ec1c05b2cb7857551dd37f6051cb9c67ac1f8cc89d628b2e815cea84d52764dc9b483be64b0a23c5338d466135349ae7eac3f5fd148d84681225e6ced692020aeffe1dc9743430d9282cf0010f01225cd3deca917ef0caae82f67b147f9dbf7029f2766f7c1093f26b17f7145204a7e55e85dc1b874f6f7a0e7640e2f306fde24e0e5a32121f1dd2430a96e84aabd11237bbc7e6ce033de958fa67947e45c754eb9ea1ed70651c11d87f716b6a86868212cf2ab92d9a7eebdbf9cab81e6411340375680af93516b9e53020a0fb5baef9227b604e5d56e977f3750c9cfa36e60225aed6e55a4599081152988f5c1d2171cbb24092b3cbee8b409683d95d8035dd938f4335cf58f0eb1e307c10cc7abcff093879c052a1d85b2c9d4ecd77b7a81e6eebca35da6cdfe529f062774677a1351dc9f35b7f3849dff1bc4d031307debf8cf710b0f403ce6e0c26e6b92ef986ec8a1d1189fc283b97eaa1595487651c49c4d371da46eeaf68fcda2082cdd605829aab5153428a1714bb41c3fc217e7e6cb878a4198d43a79f58fed6d32cbbb8e274afafd8575d1689ece21a30132355ecff210a6eaf1d330ccecaa324ad8f2ff44515ad5ea4df4c27fff2d1ecc64f1213e602a17752b7f6356bfb0ca84e506828377c87f8f8e2774aff909dcd693de9da6e3e986cb22e2ee33fb2ed86185d21fab708d1a247a88b4ee290a4dda8ca6f8c31aa1c3213fefc71b27e292b557a2bebcb933b229feff8a7818fcb668f340f060242e2c9ff030a2f790312971f6650bfc5220d29913b4147fd3f6b1bf0eebb84bbcd95d79da0d5cd70e3bd9ed5777bc359b20a28ed06d15cfdf5854aa381ffbf6b5dd67856889ad75f5ed1e8cddaca809ca5fe434cc8932fdba72e5addc754f35e998030ee2bc4fc3453c1d2bd55692ca0eca9830fcae25e81814b8da6acc2d38a4145fe6fdaff563dd5bd4da6ee3af52e92357315fad87ca1f5cf364d16aa1d5b0579822325734985c579584ac34413aaf65b7c28052a5b84cec3c71ecec1dfd748a448f26a85c89ed5dee2916204f327b388423876be5c86ab119c69d974fbefe6cf375231c6d748fcc61a0d0f9514847b9ec07bd628a8de9850e30efce0cbf75ad4a4e75bed2776f14ea7256ab2ee881c6a8e0ef0fd8bccd48e96473a7e0f3fa16b8567f738cf2ff627bc4618a719b524fbb0c98942c93a6a0b291205d29106cbf2f9b9c345c52199fd6fa99fed3dbcbc38c73235022e65fb387873d9df602af8767c00c7c81b5582605b120581e687351f349eb2825a2e899f6447ae080e258e61114abb065e718d014a0e334828984ed343d1d30813a5a72f319fd4ff1971f1ab6c8b1fb6d56cc11094228ec9c2995995143ea32240191228cbe482fe77831d1dac8e24ead56499b740bdc7338c08fbaf2fd6a01bf0a1d3a3c9d442b4fd096f87ce2205fdc22831d7b71ddc02adcca4ef992ea01ed2b16ddfb7f1b0782d0e3e136903da71a555491aeca4feeac41ccb9363d81606d47d67c3806b0085d8dd120f22f96b6cef614127d4c355d9f9df00fcc147ee1e1fef6939add19f8b790565bea72296090cbcb39243e956279066cd70a3fe92a639349275cb7cf60a73926b6a5d2d4b40ee7c0705e18e363dc5d8ddbc7efc1f98bffb39cbd42963613897f7f9c348a8e46606b4c5274bc65ccbacd853635bafda8c40697d273fa7f5272149c36337ad0e0a407ee3c2c8e29d7a59085fbe7fd3504d787272914de5d02ae72573a4917cecb01f2dbaf62e831b0dd202e4eac3f3ff4bda678985a5a624cec86b73d81534411b11eaeb506dbe66bc326a9dbed9ad62c5fb2e5907813e219109a999cf49cb642656db9ba785de2a7cde6fbc2cd85dd647d6a169cbd245c245a141475facda4d125aad2b06bd2f0eb8fbe538170d480b7013cf20c5852d9da1891adeaa76f53b3aaffb0f33ec30782170c119a195e020371390fda99ea81ccf002e5a4a23c0d1bb3fa79bfb9f05aa2461fda403cbf2e150d876f9c10ca4a824f95d5fb0f66512b21187f72c4a2ce233910859b979704d1e5ef8551060c4251f0de364d6545bc3d27ed8e973b0820b622fddafb00ef3f37eb9930310746868703ffd7b67dafa00853af2bbd189070a591f19b4c4e498504350abab0c0c4626682e7dfefe6954f560532da0f2026734f42f40784599ac575e8e95355ded979817d08b54f08379db5fcdf2f3dd9a30173caca11bce343c8c7c775df384e522901bcc25b2d66afe94c6b3ff250dbfa3885e1ded37095ba0027a85aa118ecc678a2d2ced2c2fa492b44855e47efc83236ef079968bfe17feac30f1f3129b97a81b157cea2a6ee56bf6e4c1f61ef33a6dbed6c1a444c4a24b4ae172e99ee32104ef767a2e8ac605904e1ff5a081644524e0f74c518180bda1bc61ea153fffc48d5a048441ec6d2cd8cdcab1821f380fde90c41794eee3c1a5a4e6ada02c17d74aaa60a3509f55523e7a0296d594460c8743ebc37e67a6bbd45fee0acc72b4c99c41b7b0de3165520e6d107af9fd27a5063e80a6f198f49f59d9ce14ded8b4a9f6afa23fc5013448d6641e875d6a49af94bc77da4d6e7074bc8ce9a77b15ce87982656fd27ab68d99ffdae2a081b5cec524ae00bf12e723eead34d9c7907a3a661db435a8e3585f6be998f80f13d62bcfd076a2a4118b68a5ecbdb427fc576fe9a0fa03dfe3c741c3bd5048cd18d750f16d100c8d4215ea96bcbae5870c76e114f83a3b6cd67842fc846ee0a4bb686f605266c2c823546ded3ff5537d31cb138f15b6b4774f1ce687da78a435d6f40b441d0c10d8a81ec208d87d4aab8a30fe76d5906d6d4e405315e78f87786525100ea729c756de041a9c38ceefab57f6e51cc455f16468b2a5b690d3a63b0a17d857aaa3528e3cfd967ba8d6e6b27c2a4f5e8787a2521c623072d62daaa3e3281a4ee524d30bf6727d918d6d3835dfab4c739cd7c69c2198c0dfb448960c75eabbabf20d845766ca73625bbb3dc19eddf14b0e3206b3dacf5d9d1d52fbf10114d6f51b4f638fcaf595ef3dad7cedcb124e9ca8cdc21d3dd1335e8c0c767a9b6431f81117c5e0165c7e29b5f99656ba22c6591e355ba65c7a183fef7000ec14a2947672c3d43231310172c80f42a082be8d3c79d3f061d26c460abcc12f5d8021d3e20b8d2165e5fbee6db5d32d0115f8e0eb1ac52f9f6516d688c8d4124a3c6f7b598ead7d26e1e301b70793e4dab3f6d0384d461f93b6101347273290197ebb87a224fcb40afc69b08ae8785578d70696e11006673728424c21bf93334155dacfa2a7a6eccc8dd5203d8cc9ad93c5af6803d0066b789f6de71f4863ac8c9ed6d5912477fec592b2ecc267bec7f8616ce3370a65ddb991b4aca7d9786b2f59aea3ddf0576059503fe3ca77518f9640d19bd496ba4f99eb7e99d756557bfa744fe4c53b97c17e1b597c86f3ce969dd1163f7ed90563e5b4afd2f3cf7d3b98d25b92599eb2c956c68d5d0bd4c8ab01129805a78752b6d9fa879db0166ad4a1e47a6daa53d272a83dad403b3258ea5121c483b6cb41f7c447fb0c418a149ee231a1f337bf0b79e7e9af8e3f56344c30f5d4b6e718ebdd8b6b74945c310817208b6bd627a6ac4b545942a4f1a6143ea877c91d28cfdf86b3f952099cf2d7e20df4c8283ee3d51a102c30f7fb60b71392dea48bccc9f5fb3fc7a86c86101b11d596dd912caa1352d552af1e2c4067a7d1eb677ae716bf79c28c26b7d4bc9de8dc2f0f0a80bfc94d67f9e983fd9c3704a7b910697cd9f708bdde196484c51194cb015bd7a975f14656c32d217b9f6e58e1fe28c9bdd0d04a60be33ece6c830e804f6a007775e7cf049ed7d9c0bca8658a021ff2b57d346ccfea869e141fba7fca61a1b507b6cfbd356e0d6b60a97addd26eb788091455971aaf91eac09dc445a2ea8790e6e24cc151aa768edcc9866a1ca0198289c3f1b1b1224b83d3917af9638e787bd172a2f59def4b1887b0e9dc6c94cf4c9ba797ce0f329bce5cdb2c647ed84f3068562587604379944e39cda7d417854169fad75f8c00d339d56875b414694b0aad59710413f6a989f03053ab7f2a2c222327e69f78a842eb323262e090ab7e5d2fa74b755c4aff422a4ac29f7e0ba49a758d40172acae2b7c397a613e6044d2edc00b14433975ad1240e7bde8e9013d6a342bbaeb1e0ac065efdbc1c9b70865466e17f3a2c81a51b7578f0aa8c8ece79982bb2e1673c290c8754f758a6fccb78d77b860d34de1ffb7561927da42554a748d1a1155ef3063770dd11cc2eb4c10597c55461961b76aa33bc18a6ef91a9f3aebf01f777dc58e5f2eba12ece714d0795e6a7e46aea9a846f86037d519200e767a123e8f264e0bfe547453e9e56ad60f9f4aa409cb6dc8991b5272009f4c7edcbeee65cbba2fd886ed17e3c65c979a6964f872bdea2ef0d79b5e2942b8815f00b6c2745720d0bb956aa8307226f250eb47e40189c98e87ad4965b64e2b6b8b146a36763280ee4e1546bff22d723b7707434251553ed2101e0a8cbcf0411d74fa2cb067270af27b2d3385b81ab0fb139021e9064e2087a807c7bc4e8c8622f8353cd6f70e34c9a989ead0515420e515fe60445bd39918b00aa1a3cb543dd36d7012b8e0ca73286d31014b6a3f7e7249970cfe85c84d71345969802a93e94a3f418b3443be94e4986ce6b8c39125d03a2fedb9a359cb6f6a34b20a47517108dd8ba4695d7ec2e34793bbfae4ed5bf37a43365e080c45539699f8335e5a1706ea8eb75932ea5951de8a72039d544e57aefa9aa240d2c4572f6b237882bcb37d42c551e11bc9adc7c5194534346209c78364823c779179d53f957aee8ea886965491556bd03ed6eda04f649d0e4e695f30e96a302912442a68fa0e6144926b2a3dfaec7b5bd56551a9eb06e84ed06c128d51e2bee54243a684e96d741362a2395ff662fe16814761a4cb3b07ab8a4dfbb1314b25e2f05d99b5ce0f316ae035c323c8cf2959fe1756157dc8b747103b8485947fe5f9e64c702d8e1b80dd4e9742dff93e69b6bc51c1152c41900cad1145122e2a86bce5355522134accfceb2196e7e68c81a55bc6c63c423f37610f41434a22563453f7241a3d97123029ad83424afd780f3f5f184affe0ab4138060e5506816debd2d297498ef0aead494dc995acb95a5adcc6e3820b33199abdadeb8d743fb62d43af0895ceea755596a5f5bb62f7bd6aa7262346226f6da4267082d75337ab00812af7cad3365adb79fb40b7455283f42738fd504b609c5144553005b05b50df0081c1c6ed60289fffee8ba7fd032cd005286f0ab0c4d5ff7010c2e00980ab15626945975654fd669fdafa08d3c9337629e2ab3ab21bfc1418f72b4b7d8d308b004cedf762fcc17a9d3ebb580336e291ce771c54aa6433d51c356e7f7d85f62599d693a3a4bf96f0b182842b292129bb9e1e13c6adc6a3af07ebd1a6be3d661c6a044595fc052ed196948be9430e68e8517cc31f4cd3a5ccef34dc1a4a3f1127d587a959da44ead7ed95c5abc907bb15b4e66d445796c9e41e33cdc4ca8834350c85f2c5b57339133a78df26a2ab6d3544aa372779a59f2252dac2974344d395d16740d2e7a1b6c9cc39b446f514e4a18fc005a71733a8be3ae2fdc67e91b43d675cb0e2bd51d6a8b5cbce9dbaf7e66529a19e6ae5c2fe45a4c3b4a2e7d5ce295eb1c98344738cc22582dcdf094d2e79eca5d807ec617e3ec4700c2405c8ffc131d9733d0d1729549cb7af659b99159b0caeb7ee52c5984af8470a6956f066e6a35fb0a405ee22e824851e251007a31ce9513de9e2cf917711fd23220fc3b02921ec135e5435e504e6813a2471ddb4b45f7cc253a637bf64158168ac58bef9dd6f4093d82500604fd47e61614944d66a2f6b2e27523479d92ec3f6255b80257a83f4e467ea7de271967f70acbb95b277262a50193d62427771b87fa1caa0a65b641c9b12fb8f4a731a55fed7d861aa78ab8686d9b38e52cffba2a89ca8183d1bab97838c52c754a473cdbac17356ad634aeb2ee119703b21a637a0e605f88e6b1d24abbfd6a8c1e6960e2617c7a9853ae5bd4ec5b4ac49ffc89577c902caffca4d3bd5e55c537cca1706b9b1df35ebaf357a9875753fa906e3abe3a4435e941f731eba0a3c229c7b372e553157d5d1feb4337e0363541d9408aad5203ee43a7aaf13983f4ddbbdce620bbb599c4ed8828ad37e4626ce0094d8af28acf3f13950aae846d0086b7832091b355080837bdc8098cbe81931446f23d0c29765a69275788e945a99ef201bf3e6219c460d501718679c66c537b78900a9925293e318e8d12ec731c725e2435b316004c37d2ccd6852b8ddb7bf4c53407442978cdef9e01a64f10c9fdd4830944b75bc3952b73eaecfd0425f680d2135b5b535cd822591b74f16fc0849240e15a18587034bb64a53573459877b9c27863f91206bae6e800c2af0b5b1c73b3a7524c22a609c1cdc8f17888c26d59835700a3985340ddf448f0d53bd1aa8985090a6ed22230b0edbc33339d3645fd4e90f33540871739baaeb74e8c0d62f7ba45a818dcfe179b314366c891a821cb852126e210b987a0c2edecf3e7304ff7c2bd68bfc755f78517194bc3d6dc1351b9a5b2a96692b2c272f50001af581e912ac8d9fa589bbf937a5e27c7b0e4caa5168fe2a716854ff29b3e5fae0157f46e76f441ccc6e29249d53ac26c7f1c096d27462009aac64594471d0250e31d023f7a65f1af07446cff0ab451f6ac9503801228d591b2740de54cc1a71d9fee4eeb5d42cc346632f16750a5d860b02d44fb08be354b3fa65a34fb4108366216ee80645f8794956914fcd91ae66cd8853a9239f9d6e5e79c5e0eab2185a9654b979cb578534740017fef9344a6f201eeaa61e5374f044a4ff3fe8309189c77de717ed2dda2d931a1647fa6d55609aa772ed2d54146ca7f6666cc35da5c2b74328730f9a0b5c1f66236e2f06616f841f0678de6d917651446d5af82db0c949a04ee9c45942340476862a0e52cb1baea6f9d7bc82eafaa82852da0ab590735f3e2f3023454e9605d37e633e3d56714bd2168e4a5213c414958490a21b64472968efe9e0c08310a217e38bb4ef4d004ac2ac25c39af74a27c1ce4656ea0b8093e356de1becbbf3eefc854ddd1045af62c7a99f8225ed7224a59c8cefd54dd2df3c380ca50f6e252995c44e45e225640390126083d84c58d14ba887f70602cbe9aa9267a5ca3359b9f63167a2a3fad881fbeedf44246020200d22bd23238079f40b7ab9a5efb2bed6d05c073f785cc1e9a3b950dad3d093318414923c499a9bb553c688d8da3aff17e52e2a686d2d44a7a6477c07bf9773bcfdd827b74e10dfa1d0e99358ac6306a71fb4c90135011a7d40e39bbaa994112ef134e021da9731191c77845dab8a3d4e23bda8309529f65f35de28d50e8509a1031fdc80b17a7c3105509a4de346a9e5272d25ee2fd62c23374610b055d3c339613cec73cef03ba85397d442fd3a0369ea52dc97b8d5340b7ae579540cc13c5cb71899d601f087054d8d3892ba9ee60b374c7aee56b41cc11187c543105324487b36ea60d5651977bbf9d27505f1937eccc2190e28203c4153b0cc8c47824248ea62750b22bdcf91cbcaca5978c96a2c3b8c68df942b393e8dd907e8ccac8acdc09b01a789d792b512840df8bb07a7043badf2666237f5bac1b5b57e28ca0bb2b4da3d1eeda5a1bab962fafd622570a3efe151d2e77dffe41ff434656c99977f7ca80fdb40a28058813a7e0af018bab20a038435d5db9ee17c268ee34d816793e9310e86a3e831e91577b27ca655916c79e4c180ba4839bc4058a3902dd1859a68ee9e66c6da1960d2ab9297b36702d4b72e3251e2a5ce6ab0365a08fd6c84b7c89ee8cb26095ef2e7d291c5bc8d62b77f87103858c4a33b3b2e981ed87e823dd792b14f88ae7387cc3a5f3dbbef7167293bb6ffabff2ecb2bf673144e9416c4db4feadf6deecdff4daa611adb0b607688b77ee68cf64742dc6f269355c8f2c38192224a1b58cf9ab0a500ebcc74f31460e9161da12e5a194b93aebf2b128abf89c089d5dd1ff021481643944270327f2d522bb826e2bc71aeeac025243b009cd9d84748380a9359341f0af42652c6c1089c786fad6e8b8732e127ba9491bf418cd59c83d18550b68eb5375f73d5f7a2ea64220c4d07fc5944d3b7dcaf44dd94c2566440bc080cf93185f0ddbc8bcd7cb255a4075d52704f54524a2ad6ae70dad806f3bea9efb63417ade930422c8b13800d633dd779924dae2559fda52012f13379f74e99e7aafbe5adf0a9dc264f314a32c02c41f62a0e7eac192b027bc9507b75656e0e5aa1ba2c13eea49b8e31146e16abfcbfe8be7e0f3ca22c0303e232762d58e4dbb056e15da22c1397addddcf16c798a91531dec9b854cc3f71de23f7919af74361a9ccd73fd8ec430274cfd4570005cddf472befa92ea02dabf6b76d99a43f05c994d21951ac8516ff82f197dc4e191ed6300255a051a9369521220b87830a2707a90ae8d2f625d7cb344a5b0b77858ae0c7e6cf56bf97f9e59e09cf89ceebd873dab8baa416d6759259d9fadf397224ad0d8067b37b62a428c1338aea26971958e3d801e03f1d42d6cfedcd93bd9335d16b784abc7d3b1e97255cf162365a5c5b4ed3237d10d5e10d09318d91de30a0a35d9c192f1f04962174d183081d99e2f56adffc985fe6174ae66f17ec065b9aaa15746cc00b28c6525871eaa2d41c2b6942d3b84d7c2105d3b92cc45e42cdb66c2a79d08a304c232b0fd567d67c1fb851cf3182e063c16597144c372a24387d8aea54044edb7112780164fbf2d714223440e6b5179264d6df9cbb346ce4e0fccaf986a44e02211d3f806081a3207ac520cfc91e89a32b1b36e0a5baeb261c14de643b44de3213518484df9d2b1f0522d731f7dd582eda8af2185a5cbdb1eced3370db4cf5ed94cf484aba581b387a16831525d32a0c52d3572261f37b6afdd2e42abfc046baa89152004b64ef140d1d4d002d198f1b1a7bfe91410f0f6bdc0501e482947adadccf608d21e1a05d24673225450744241f46cc54623b9373225a126f93cebee4c0d8c9af961b41b10f9db5cba878a3e6d896f6b129923cef9d9f7469f61e433d97d85586f41a583aab463d38509b575b04f46f927f72ee69cca2348bb6fddd4efb5900017eccaa39346ccc137809e3283f3222c0a63b509465b0e5e66374f5f9effde6058bc0689fe493ceaea78abb9e68cce88415f3274151830397a884807721fec43bb18ba0a3467ad45c70f29e16d1cd365568f4aa724c4451eada215e2c5a0c34b6d9a54fa7f8c00bd19a2b971f7817877b2a0d95efa971fec5df5553a2d78c89890423ae52dcb0c920ada68a5313ff4bb159f382df7dbf6278fdb71c371ae2bfd69f547ee115000fafee175cd24b5e00d5f58f51874016048a593a470ed7202bb141925ea943c4ed8deffb3b98fe3eeabb8dbf27137754e515d16ff5128d8e476aade6dfc3cb41b87d9dd298c391cb10e3d6d08a16d47099da7a3fda5886c313942fe79cd55c2f1a1244a4f9b9bede88b2b6e3cbcbf2fb1239f28989c1c8411293e5e01bf7151ecb8630bdc2a52cbcf0b6fcd9d3bb2da3da4a897104c7a99eebf276d77cad1848fcd99ebf67d0ac996f620c943a3f95cec9862cb4de366b86b6fb5dbc01cb8a7221592397d2cfdd254f8a2a4ec3e39df6d8730cf86d1740d99ed64680f6627c1479afc4ce089bd241c8aa841e8ad801ae7c7aab3bc629f609c02e1f6c0ff8f89f09943f1f66a5a922e63e17502db79c821d3b8a94b04352f4c21b06002137e230311d97e585c9181bbc4bd4f8faa7c7ac25c666a3e925ecf5ba9644fe9359d176ee84c7f53c95f13b3dc8461b04740a05bcbe7783ab6540f6b4229207e4bf3b6729b62b4bf00c40b58e999f683dea8a88ce9d8f5956da0780a9e01575efd8d4f7022d3a75d4d7f7ae0adda7e72c82bd39e7397ba8b0d3bf548d85bfb249e39c219614379456e27f5870abc2576d342fa49c2dca04c4aac2cd154b79534c82052fcaaa4929eaf662c3b83c3a15798d8a9e481040be450b59f4b948fad2f01f2c66eb73e7041d321774fcf8cc4870d5431a7603a7cc698e5f56344b727931ee8ca3e2cb2fbf00e76d3c0e3d5d2a72f1de5371c166bc87d4502208375985000a40b8fcd3e6de6bb39c75c1c6dc31f898e18f251b27fb7875a0528e121ef30a2b9259e161309d82682196bd4bb81967d67fd5ea62ef73efffc2ef01b4d859bdeb703006bac6a19b608ac7764e2f2c7e4ae3124754c9dedcd4f205c2bce274583115f2560ab11735d7821b16bef7899248368184685ca97726bdb46f7fe0c5fb1f5b4f87a03af0640ab2ede14269a3de86f179210f067fb02b871fa438f9f911a416271e738a9e992b561e8af6feff1f50097ebcf9c3de9c290214faee704a40b7e9a4da8b3e92cb4daf6a506c77966d496ee62b26828beab59a2eafa4f338da57eae36bfba1456332a78ea1baaba07707bc75aa8dbb4e31dda7f81eb376c6ac882742495fb800bee2e1cfe5d08226ff1b9f391aac6dfced73825a3be07a1db3881104cc47d09d0a9c30a0a0c55640acdd76aeab497933b09022ddc3e2bc07a20ddf2f9fc13f66959919f437e18c45d5b17485f80ecb5eea37038639c8e76906cf58645b39b33e0c7657f81e983777a0960ee776392ecc7b8b561020b25397e1168e21dcbb666829f2558cc4484b1ffbefcc34b544c0d2d68429d472988b189ea39f9dca749a153faedb80582b844ed6b27a691db87f4e0e108a79472b19481939da16347e716183fd98530ca6da669bfb21ef12ac541b7ccca030126b0949c23c2afb7e45d2ae848fcfd76e092126f88f74aa9a942c62d1bd6b65691894d4ad3c9aea30a9eacbc3718f4d5650289b23bb4220c21e58438422840d514ef28679334de71e40d9f67d10e7ddc75d302479e5ef2e73c95fe70b91dae889e45c09e06c0687e8d4e139ede07dac25ceac58b554e024bbd0fd882143c00d4fadf3b31aaebf89efec4b996d4dbcf0fb4e5dbe75dc1f9c42","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
