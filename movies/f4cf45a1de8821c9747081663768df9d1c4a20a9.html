<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"43b51be3aaeb98472d6cec8810b47c0ccde6b038785dc6068031371e0987f2b8edd752d23c182b6f19ce059f87c6061a0ef1acdab2ceba1ff0317db2b021ff8af7b36f7244501921f88c68c904ae28835a2e5a5637df0316ccbdd3ca6b43c3b3952a3edb9eb2885e714a3a49e1ed8e1e508aa96c0306a646ae09f86d28d0d5fe8b4baf0f39d93b982f273c1d2a07b10931d63eaaaa6bcfd72bd01dce63c7fe62cefe62c4e7e4cd63ee5901375c7e2f0504ae72f5f3e994b3b7bb2fb3bed325a5c4e73f729e6024a676cdb50c7e34c0ec9db26b0905a03ca32c0d82afc06fc502e96f1fe7c369a748aa02c6175a1088d2f6cb79f2a585c1eee515b5e71bf504b172ad04db3ef0cc077a80c2bc53820afc9758256db01bc632d4c49c6f6c2af4c00216386ff5a5fb5b19027b1e120ce3645213812e98d19e9779215a62c15b6d051d750100ba1d0bafa231f646b524828d8bba126550b4513187b13ce3900aa1a9a5cbe6d12e4aa28b9f57435fcc4f4c04f51bfee1914c1fdea0e1459fc88fe4eafb793a47d13d4cca33c13435e72dfa48d737cad08b070d6a0556970586941074b482a6092bb6c6473fcd97209b9a6ba0207b31ac5ea400bde7143fdb6ee516d7f2d456d9348fced1ecaaea9c691979d9f0d760d3ef2d4b04d010590172d4c299de119291da75d2baf6bd659b3b29bbd05edb8ad90ccb066310e58b5602b2860738ff3060c750a22cff1d0eeb1d3e92099b7097a83139dd48035b3fd789327319e00e8ce212bebdf25da3b05c907d6551d8c53a89bc52811eae673bc0605c3413abc5f38a8ea9a5c82129f67b64a1395338532bc46ebbd62242884072b8f7faf9db2f9bfeeba931c61e80bd49933b5ead8d38d302247de1f49eb87be67af9a42be361ca1207271447a7bada0ab8401e7f827726e5bca7821a1cb9a90b829e17efda9920dfc374f96bd9f78c4997cefbf0b8d59b15eb9f2b9fafe8fb3ad264a530e1b640a2d9305223be6843860496d5b8abeda2825f5a6778dd5c95d1f978ca5fed84ec676e2545eda46ba232c5bbbe069daa897df9beca354a142ff56c42bbc02ab2a7d8908d07d66129b452d960d5aa0bcdf87ce42d979e70819b6e3255bb0ca7751eb4d4069b7846d9774a0c090b30afed3fe5bab35601d27f492dfbf80a5b612094b6068700ae5d93421cebc9bc53a2f1534b32f262d839342554aa94bfc3be64900ef385253cd9ae0cc23c162fcfcec60e40737c60b9bb731e2114df3b5034e61e1975fe6c049e9cba4295bf5aaf12953cbbb871ef6ddf7cdd7bbd864b38a598882e21be0547fd009c369eae2bf8b83b0d6cbecdea84f8f70832127bfb1d52bf17ff297ed5f41266fdba8cd8b7f7dbcdb9b6050089bcf4f85bee8e2372af395e692950ffaff5eab2273ea21626ddfb521e31cea364b04f10cb0e38fccb4a4c28a5f76f95ac95dccbb5cd77ce2cb6f1786a0d2ca05df14755718d403a0645e8eb4e7b8746a2a8b644ece083319f56b01092d1ae62645b7be27db6d717073589c3c790d8c0597e143f51c601593cc6ff049a09179914d4375c5aeaa54628b83b89dc483ef2eaaf064bc1469d88a28788f77e06d5cd137c8f1971edd591caa282fc21df8be685cca7b93a2cf7390a68f9c667d297101544b090110ec0a7cc7bf34f29c0b022f9ce6df15e5aaad5c21b73774455ebe9b8feb7301f1a209fc7da90bc4790922cdb827d4341aa5a7ba704f232a54452164438df3101de27067f4399380b5dbe7add7fd87178c0237ca9f98a2f704f99d0fcdef7e6e2ec97f3055ec8c8e185e6209ee236ac3ecd84ab300298e50a92fdd808530ae9387700a58e45c47dab128d637340a43f6471d4e1d28705253e66c5d035a9e525b2ad585363fafa20a05f5e59b0c493a5a6f447c3dc0675756df64776fb471387f5339d018495376f97c8298d89e992d0fa2795310c9ca4bf2f18052e89d2f8f1bf1e890bd79f0cc8e339ecb7bb44a512ae906712c22cf54f606d393768bdc6dff180e6bd200eaae5116d4099b966258b3af71e60cc6f959e3211b6e3b782a61667867fdbf4b6f3efd047158c12075ac45cfdb7c40e6634883bad608de99b405fb23f35d15660d49b40695a072f97c15b5181cd49880215bd1774eb3b7cc082e98fa06e18926e613fa8f84c8b2bf4aa79938e07435f21e20e8f9c2f344832761209a3290b02185a24c0b123e963a0131d8053d7f9f08e050a3ac149370ad63528e16e279051357a3d168edb0114cc9e350a4f7900244a2ba22ef157791f2d82425fb54ff72f37acd79f23c12c2a08d80b53d4902a11f182a451a23f80ae4ecad500e2b013db7157b1822f0d6cf16c424573dcd6a54202b52bc18e939a72b78250f20f41dc9581e9f112ef1cb038acaee639453bb0d5619bfe7dac459fdfb634b372f16fb8d8c14ea5cf75b9eb0974ccf877492da21925e9d2970e59b128fa733d047b71b0c6099082a9f03763136734fb5deb611d3db8db337f826c27fdf47c1eb62bd68fd53350d9b65c70edfa9255ac333177efcf2bd5bba17ba12afe39468d813eb44660564bb034fc32d42d2e81c800306352fb953d8060cf52a65e4c52eee1e836cdd5971947f8a2bcca105d73e75acbfaef6f6cc09084ced9ea7ad3784f1a3fe75801febf0015905371787fc3cbbfdf5409b49f8827acd4f65768e24b71296dc19512a7d652b04b69c3aa2833d8c7a777bd807cc7e57717a2b411ec9752d42b77208b2ea91f51b34940545155b335162e1a4f3c3cdc5c69257a38d32ca7e5823768fd48fc771f8e8a926b2ce29066431acf42d65f4c4a39abc536ba0b972471c9d4e5ce00c3d5603615aacccdc24362c1dc8440606ff78c76f4c983b6e1ee4cd6a350b8d888a0f773565d9d352b103d40c338d6abd0ad2dd9de4f197f74686cdfb0e13bf3245859068e5ba7cb2bfb04fd56ec1df32224a35442e2572bb90eb26ae4af50f4cae3dfa2b0d1e9c3d22a6b14439d43f699e986dd7a3722d70e41aa3a13129396767d73ebf4210e0c7118d422b977d100b27a4e4b6f6dbc6a3ab89c592106264d5c502689840ea082495fb0c9b29a4e66e59b5c52d0a037a7c5ad705a2f52a715db3f1a7ae26472f6affeff8cb0d9e2e17f548ee8ac8442c7ba103fcfde31ff1bfa695efff46f72401cf3e2518b553aefbda75b37045efdbb0ac800e0e48bf17329686c3b7c14219795ae18547d7da2f780733cf7e396f3de0ca0ca8fb1e221593793140db512aa47861263d2461724a93e110bf96889b743090b2b7e9a9a4904ad29ef3df1e099fb03c32d1129b211ec78cc3e07dbe5af1ae7a75969e72945bcb04c9efd114c23fc2911762545fc6ebed90735a3e26a53e6f9c04672cb257363ca926d5026c98969775156ee30c4bc76ed7660475534e276281b980765350032288e78573891ece678deba5ed652dc8dff67948dd53629b8aaafbba29fd5acd8f908a1841b3692c1d944d15e57e1b463983e2f54673386dbdda1d9918d20b05042983c63896030e0c5b2962b6e4af2e27ba6f65b2f07c941a42dfa1e6949422be9784d05371cd032d6699401cb89703fa048113c03130a47f54558126bba21f8b2fa3e212d582003c8554b20e2a91bc558f60b7847459f7db6a2a9818e96823c5126ad4ac44e2e8fcc59650dba7ffbce33bed9191c024d470692d124612043544383574c5c153ed030ae2c57ce4aecd8c4a040c684bb3e74e2b31a38c776523a8194609d79a81f30620c672795e94fe346d239566c85da5699a507c95479b1e5c996ea6eed9e6ef589b1a38bd01e1510ceb6a740a2df180d55081fae93cd56b87b785b01d0ea7a311406d396874f80490e3523e74816a192e66b9752533015b66b19983b0a3b08aea2b94f2a26d1ee6b5f3c307fafb17e288ddc02a2e3a6140eca407a9f5f21c5785fd237bedd90235a5584909b81407ebe9610cdeb34826146586a2f216a63c27d8c161f3892ae4e2245563335fcbc70caac25b5a04179fbf797202f0f01c00c7315b2b623ea9ae513a66f61a70081658621d2a7d2e0fe20d250039048ea07b226ce0f57a2d6a4e2a154d08cb2ea5ecd64369094db38ab0e5a9912faf7a03ecf3b4bd99dbeeabb1f7381f825089ddb6132ecebf4315134b7b97103a66c7786f49a8562e61d6ca664d92bfc22892b6b6992ebea30c2f294f6544a0f34bf1b27ef01ab267c8accf42ecf60dda45b0a60325d715bcd3a649abb444160b4a7aefc17da4e07bce1d3cedea52c24cbaf71246d31091c75349ebd4db28fbb9588fb5a4add91a3783d4b314b06493c03b2f15ed83cdad38018cbd3b442cb3a8589e5994815267217e1de698e7e157ed789022a77cc29bb218d94ba39f29d32803efb1f215f06ee758be59852a3f4f3b305d551af3ba6274bcc8eab59165a2231eb6dc253a47bdcb85023fd0041aa1f64b987ffb488495e92095bce10b2363139fc58efd83950d5fee273dddcd077efd8ab60938813867547ac0a9784edc5ed1ead615a7944cd5ef803c3d11c39f453c9721a3c315cf9c0e811a12ca41fffb08aecf2f06330eb682d1a6a7434b6cad37dde6483bbcc8d4166d35b97323d10a95224ba86a4d571d809abc8bbbad5f0596777e4d48fcda200fb77cfcb84d842142a7ea01512d6871b48966884482f9c0fbfd7683589b0c8d3d55ca91ff594a19ee1c34d9bc5a3cb33a173a5b8d422016265f5c2e94c844a7ad5fcfb5ab5056a3d5bb70f983ab49ace7844bcd930f4472dc30b9058197d0f0a364624d8090a754f561703e4d9218f21fdc0b874f0b480f70f5e9efe411f3526686fb3432c0d30aacb5d7dc954c807032bd743006ddf83df182747d433e45e6553e31b61a384456c3b46d2bebbead0c7b0709b37a11bfe188627999cf2059320138492b1a0f770a50cb2a6104907eed7b17fb21e38c262f1da88b903ba8f21393785d68aad57134225512a67124cb1d1430b84c79e95ff3a34b1b4e91343ea610dc3569d2e3f1605697764bb143c90ed3abb57721b37d2f5a23c732594ba3aed7ad0c6ea104f9fc01b2bb8dd967bb7aa04009cd72060c62074259710b487e77a4ecd10b3df6d168e65821409c6b5512dc3f2a33eaf387214a6acf14b0dcdb484b73a916f28d7f1fc98a365311f2c933b005a65da35ced8e14e35febf4d74e5befa5e18d94a5b1cfb267dfad6882e96a4b6738007c4b0005974e7ddae91723c12bd0e2630a2c4f9f756f9f3514205ab755362e990464e5288d82c2b37ed89d287445843b913c2d18589408c6111311900716f433997e4f0b3de6618e1305073dd93abaf9356f4f33acbb92e0314079841b36ecf471220d11f2de2629d8896aec10b4598d549601debee42fe5418bf281b99a96573297a5f378b7bf402e292dda34d958359e1a6452d228fa286ce5e473917e945025a3f4b0de0eb14bab79f16f343e0cd24009d20609aab792d1afbbebe97e7b071faa0217aebf1c0b41c5a6d0364f0b024bcf48e60231ba8c5dd9deb882372208ff2a502f300ed2ba7f517ee3e8a0141babdeae1eae9cb1f6646e9b0afafb7ef7ec79f1a240ef39342d702f78cf41c0c37665cda6f859fe556fc9eed41441c57b0eb70f86c76e11a62fbcb246cce2686da9942778004f8f7d3d07854479e0f4f4749104a839f9d15a100fe8f4134c4d6c326e197db28b963fe7dd56e2e413445b0e9741c8784ad759fd229c730432679c322211336e5389b1c91ba23af277a5724f8fc1cd5e6cbff43ef30cbe5873df37213fc9198a1842150558b808ad01e066a0c59855259325e0a5de5b877a0719be083c6165b1b777303088541faebf5f5307747491635a54d6b7b048ca8753dd1913b31a5b04661d5b9b51a4f990a39e634bafdb75cc5f6929b3c97e30ac5823821bf979992f5262b9aaa3e49b96fdda697ba6ca813857e310719019d14c6ce78eb1bef5d09bc1e9b0e2dff20c99a97e135b05f09c4f01710801836612c691e0bcc3528f90ba1b5780e4f7e13a887dea5ce5df781d98175d70c545bc7a840dc78354942c48a18812c2567ae661f38169030eba9efbf556abdb878867e5f325059dbbce53041ca3695e610b0f226a6e8ffd27da0be3443c3791ec65f4353f0ffe2699de3848893484529f66096223fab24e5ef94ae00c44ccb9a3800f9415c2a276df7101f039a0b4082e2f22a607b25ba90531aac74bacc2ed8cd69b00d2555c9a40fe9a2c9d5a1c6a9fa0fcd4e71a52d966d7a30899dbcf8799ef091a6c5fe123e3fc3bfa0eab3c4b7ddfe8e40a6f0b97aa9ef9ded13c6ed7934d8cd06b09c20e6cdbccb4a01d41df777a9bff949d64c23f87b1ca3e6513ceb3eb700774bf654890eb1fa25c8961868cbe3c9f047e8ababa20907f1c321969d655c77cda54a7ef2764597c4cf97a73d704fe4271357fba07a68b090f4b7a750caefa0569e2f0d691c80da0e5c30027e4d37f0dff94e97c72251742f609718ef5ea58719ad6224b8292cfa42fdcfd043e59d61cb25bcb38f8c4abf071e26a971b6c0ebaef786b8783bb578208ded47060bdb9edd909e363e79a61691476279d67f880fed0115e941287c0d8fff579074619c6f7431cb49cc4227e15efe155975dfb0cf391f59d8cf1ce8c5efe12e22994e23fb9807a474f5557f3aaafc031ebbc49fd98b44d6bc606cace6e39bc949dbe27508a150b1cdfa5acf81aa00b92f20a1240639ac7b3b9c555a2c2dc20182365d2bba7aefe102838fbd6035ca8ce3bb3fb310d10d25127df8df5bd6e4e17c34161f253f4903a73286d2b2f3cc20e4c1e4b06046b50dd7a80f1cc13bcadf3fbdb5950c36d0648e292f001e15bba50e3e4de569ace23c42ce74806bb4b8046754961be32bbf7e975de286d398ff3e2a615bae7c48f541ef8edc5b150c2563c3c95af54e4ad4e18f7afb9d0bb1ffd41765797c2304a5f036d944b64721c32302204305cdff7e4f828cf1ac29875cd231e4fc428b9cde50ff18e70c7ba6f7f01daa1e0b0042c937874251ee085a953a4e0d0dd205bc6e47965693443e71eaea2f4362b70476f098cb867646cb6fbf69e8525e555a5d1dd6d1b02bf7c2f6c65b162802b1da7eed14e9049ccb526b223a2556e377f2a7a948f82664a45a036aee10794101a0bfdd0b073b1ad9385d4fe410d607d9c5c637cdb64ecc3edfebc0930fd78b635dc8bf0452a51d42c82ce2b337790bd73110d66e8e815ae9098b3b9ca074c698fa0c2b0cc0e6355926da9a02375d79cf59d50beded447f19e59389986af473ff39381bc9c69b815538e1ed04956197db13cbeaae7a89cd87292ce428c437b207d11e80408d3b5e11f4e9134f95b07089bef6e6f81d6989ed752b9ea31bdf63e538c293c87c4603d4b9f3769ef36ea41d8a288e69f10889e96efa97e1959becd307386fb6d49863349c95b211304e8c32561fa5163c1cafec87c6afa56dcf745d4b16a3bbeff9fd3ddc14bbbce06407b86954fb8907bf5c6860ac5bb62e9fbc29255734142cbd80aae8e3fcb7204e7e021445caf1ffbf1c115bb66e6cea34cb24c724acce39c6fa8a6604bafc97120ec93ffca4de8b10a9a76b1751955cc6b6a3779ff731c546919afb75847f9953531ab8d4b0929017093ccbc2dba9964671ff6d575cefd1fbc720d85eb9c6c26a930273f6650350352a2929cb13478e6d881239cb0d119f84536b9b9131b5e5daabeeb6ecd3985e3a7bf5a31711506ab7da80d527fc51af80d8f787ea2ac0b41433fdf2759c4e9923bff2eb6bffacbf0ac4771c18fd11b1930671f2fd2295d050ed7672e24893526f0719c2ba918ddfe1ec1a4a3ee166a2bb9c87322239b3070e39d7a983943062e77b987b375c6af9126162ba2763a36932139626fd40b2848bb06fb18d4a0c815bc1092309aaa12938697131f3ffc60fbf5f92f5f288258f9cade22ee8435f5e3ef7fcea28e660d52a8b7964888723c95ef4f69ab5b8e1c68459e9ca704bcdf846ace7cf4e7a696cf23b7fd74e4c98d2a686cfd80e7ce930273b01eeee386e81bfe2f334ed7108391f3879de240650106c0ac59bb47edba04311005be556134b2ab214de3364b0c2ab798a3098d00609143478a7e4d75372a9f0e726a2af2c921a6a8657baf39f2e3ca48eb30619f0af6f4ca86eac3e534664b9767ca094102d030d2aa5d9a5aa7eac48ed2fa50ec7ed5e1afb8d7bb685f7eb2b2af3b02a7b5db9afde817fe31c891c1b8a65d2f7b8507093dbeb5920af9a7529fe0b02fe759dc502e6da94ed2d3ed1ee6c30fa4ba1d54de76837ff42ba004a172b8154d21a9771611498cdb84136bb7f0a9703ebce88e5e9c72b1b2bd4619b3a32299ddf316ff30077cdbb5a0f00989732b71a050a59c12c356e23f94103a5dec03c4e7d42a288f65f0ae4e2f0f60936293b2550274be8cdc02fbf15ca7c52deb15a218a3221082186f0661e017cca642c1c30808f5eb08ee6e0088b9c1773e4ff8c820abd716a0a8a9b3f5d92198dce398922e25f4cd8359b9229c3c8c0b36bbbd3a1947963413a86cbc0ecc466009689097ed2792c8c997c787b6bb7b76ca254c664dea2e7b2aefb3c6d5b4e764ccecc0360bd9eec83c3ee4d4b8f958198ccdc21c08c0c7f748d4f28f7166742e69693b91b82109157c3d099f4177700f6a714aa943335606382c92bb9540e293ca77bd167d057c58d7954f44276b9ef99781d236fa5bb7d4fe6388f12d8ddecf81281be3d60f8c4e3ce5d34c2cba159291ed0a864df25cb554050366e815644d1b9f7c59a4af8f3831baf3e6cdbefb463ec229d00d94bb522bdfd1773c7b7ae697ac638218f729542cdcf416b5ff3d3df7f0c6699b743e7c12c10c27e12567ca2700cf5cd59ac68d0d7227cab55d33bcb9694b8cf3d4f0e565f7230b25d376ea2ebd4b024b4cac59e23c9b5b86ba05401b44d11c9e03aca55d2850c48cf0879a9a4c8218c38a8df54d53754ee57b0bc04ce9bb1813ab657ea11caf7925997ff08e24a45898fbe010c1a3e48c0473036b3038496149d4fd9a0100b5a665832269b207278bd43fbe797db05e4303a72b7180f18b2c248efa1a2799e8e48c52a306c4bb9d1e6568171309ef5f29cbf7f24573061ad1a1e29f9e80ac1f7841fabfae7ac33b8f381cc00a73f74042da81135263a5be9ce650511c2d4ff841cce1edf60f9ba8e59687b50324c09bb0e9c0bc489afa576a89da784278ad9e419cb6b70b752fd1d6816a1c43f58a455bd0c7169cc2375a426a41b5928ed41d4a5c74b4b8fe227fdf4d1514ddb570d4df358ef4e9ebb4f3af2fc14d9e33ba85882449fde2b0cd51a442a54cd7819e5860b40ee43671aa8fd2d0950bdfdddfc854190b71036fdd32169f7e45cf44cf7d1153ed071bc598bcdb225db2e90d8f34867dd414057a49b8cbfd6d16d4b491a73f474dc8e040b647d3362f596275f5db0e04357b447d25a1096ef104dfcdfdf800dd756df30f17758932a3b2f16346dc60bfabb0f9d81c29572c0e8e0a0b99a61399a99fab7945ef6de24e48754ff0cdd383612da167b97bc640e88528e7b7a275a24cc0cb5e12cf8eb3cbe4e040fdf92049949fe7d31757e76f0146f97fccfebc57dec95fd191a6c2c1edce6a056cb45c1572a63658b5762f0e91df75562e74f006d5c65dcade661f7dd5a533a5826a628bda03fe8a27c8ef532955de220a87e993f7fd7e690b59f45381651c74f9b26de3cf6b9f07240ae697d8830d772836324862d05b68ffee12a227766280264ba283586a9743a00836b34b1372309366392a3ad1e27b1d41f6d3394df5d385567303e9b329dd51aee85e6f6d8fcc9b1c0736dd4e98644903954b8db07f8871554b9d6e1ef129189eae540068a1b020e59c0bd62be23421d845d51931608890c640571f97fd5e0179ae23b4e523053149223af73dd856e7703c5b29a4360cfad81e09179d001a0247844b37ad9d485152bd4c887d83c66b682d865d8953de2fdd50f4a0a9fec7340af22a3b160377b43068f612947e5c18b60a6b23cb5ed0c65dad2bbea4df13ce4631fba26e7e10c83d1205d7cd74d087196dcd5b6dc7ed20a34291bbe85e7298d6989b87f4ff28b825612e3f8e78a3e7114e6be3e817b86fa8a1284acaaf82900c8143fd34220d8d8d5090a4544150be6560e4495005c3ffa1dc6cb9e336a03470ab21fe64c1026ba464fde2f5e5b0f0214f7dab512ac1d5d58832dd2ca42ef4c75d08a691f133947df39b0a832a5061c893c055bbaaef54662d79284a6b2d84c330b21a63f19ba4a8b157d35717cd87f31e1cec9dbaa31e81179ebcf81ffa4e83cbcf52223242c0638619e5124bcb739c1eaef3fd1b22b98b901ffe7b8b688879a6d729f8f3b8ecd20b9f2c64af2df7c156c354664550decbfb8b9578838bd2628dddfb39d2b04e34ebeee79b313bd94d1eaa76100158c94695dc98c3481194682a073b7e3ec7f010f96fde7f4e02b20c117d031e8ccfd9afd9e200153a59ed8a9eeb3da55772fc06fe902c1420fc7d3e53ca4e7a98457fa79d7884ca5246366bb2b8c1398d1b8726ba72c3af84c0277acad6f70fdeb2e9b51ef504e6a3a367b1a4bda5f351fdcc312486134b75f5b1dde14e21dbb00f3811ccf4f0c09dbad30225898861ba19e4c24df57e67248a5b14959db2025d207488ff545aaab15cd30e8c3581c3b81210eb2a63505429cbc809f32f0c11b9f30b34f0276d4d53b1159bb0d8d3927fe13ce286bfee5c8ca9f6dea824f49e843b76d31c2a482856425412c3b6795989d8c8d7263b97feddfa088c40b412d0bcf8421afadc396fec70f0028ab556c6c9179a634e0e1b6647540c4c02445b2c7cbf73540114bfc26f55f2c28e41dfebb463054cc89ce4212b008cf2460dcb48d1a8b52360d13f538180fceaf6af11d452d0453720548f70a31fbd686ceb2bdb8fe9f7f01307a2321232b36cb1f5dc9bc005a41322a74000367c96fb0a55f91d987278a1f7e9fdaa5accc92a235004ef43489d405a00ccc0a2ba252e5cf8514b61a0fe91251bfd0d44094304526c9fab181ebff12a825c3b33d2f7bb5ffd5d61b2cc1cf38fa298429547edf168c8cc49e027765db5851d6544d8e089f5128084486675b2b853893e2b35ab717ec9cdcd07d33c96a6be52597d9879f6664e566d98f678b8c4e918acce7ee2f7606da263fc72a06a6bdc107e9c420c6bd4226f81b351cd4c40617aa598f19ef3adb2acf8a27be5921d075326bdf3c01662f98e7f01e12097f2b03e4926ed9f0c61b3ef859e7aab34b8180e9381ef545c71ddde653f835290a351616519d28cb717dcf86e83211c805ed755453608e84f3945aa6419faa8217aa7383ec3cec5899029f864bfca705ec743ff3db6dbe6a704dae8bc8fcff38b266395947d90593c72c69be10a4054e7877cc0ef0a364488648ad117290b1deefa514a2581987dcc660c1fa4062d8555fcc1c6818e79cbd843641c5831e05cf756f091d9e5b7a9def0f54513eff5a94a169f76a57092875271019fd0ac558ac86a03520081c3eefdefda17b4302761401f59b0ba4f31b25bde9afbdc29cc9452525caf36a06b1da86d12a8e7c4ed99fa475c20020b41e2dbb1bb95f315aa6740a923f15df829eda4aac474a8b0679ae0e775e3591f1a0d9d1ee2dfdc44a32ccce06cf90a4360db241a75f327820afc92bf09ecff52d82539749d2844cf196b39bb6058a8d4f433461769a2dd009855728da6ef98b3c6627fa82d1d0d0387e13540ee7bf22429b220a3c1f3f24e2c734cb377c0ef8ac30ccfe4438107ca340992d14dd7f74300888c5e2c1437d26610501ee0e916f3336e7d7ac87d55bede6d27998259a956e21e48495ccfbf1146a2318ae4e25c8333b6e060d8774e3a6a3b6383675070d176944883cbfd100f2d1753321cdde90a378af1e8ba203369db733a5f89f39876946e21ad16cba42de8db6356db1dab0d6e643fa378cce45858125e8c060f34714813311097f5ce2adc5e474af9d069aeb1db76bbdcf0f9ad2e1bb217b275fee719a5ef328130ce8f4882e5c1cb45a48354b13615307b6fd653574f2568477a110915a827b3e8e893a723ae8035ad6905802245be776520e6838aa43d42d7e45ab0de633ffb44b57676ab45a7433ca62c6f5ea91265264628932fa504f613c554d5dd85e828828a8277459fe7659e98aa8b0ad5f09eea258ad0c5bf1dc2cee895ac0c19ab9ac68125f5a5b025e90e4328b44b16dff74be8078bca2e649ea1dab96070be71f0f63b9f946a28f9a694a7d93ae5bc7a6c9bace459e7a6add563cfdca47116bd1b9b672b2f2e03ab1cc6f7686e9862347f9bb181c44d692f886306680b8ce2dbf667375cbffa554f68da02c86cec79e437665dad28d92f062e776c6f39bbcbdc6a25302f2911db62eef441166651c77ac2596321dc96f66c953a3ec3bb6d20b65322e2a044a469b54b658cdffb1199eeb09009df2ba4058cd53eb95e25321d0165a156c519fd4967a94e35d0d23fd5d355edcc2c8cdcde73359f58206de9891944e92b90160a173520f53bb64aa5aad430f58ecf85d6ecff7e77f2f046fa20e30ba5c18b8264ce85014bb4a3324ca839cdc8d06a0890f1510e43bb64ae3d6a4a3253b7c209df3eaa0a168041cb4f5c2316db9a229b04d52c9f8c2f6392bfb9477c12ea6062199ff92fb10990ea059af927291bcf816de5be10e5316f1472b7051a5cb225558dca031062916a7bf556022f1684ccd38d8bc813d574077b5d8aebce2b5a96bd5f7f191c5f3750fd953210e1e8da24a4525c3ead423929e8f582fbe95e228ec95a89f73240dbd4bc3bba92c3f079458374fd2413cc6efb3465d914884e59deff205eb7d54b0942a310c3458b152546e760ddf7ce6f31bd15e7d7f555066529224","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
