<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"64fc75bf6e0ba49feef3043c6a028f9bddabf822c966e13b22a80b9a04fc0baed4a7b33e13766d80d3ca241cb6983fbe372d7c5261fa9f211eb02286db070b5429a50ba03b4b75b0de9dd978485c0997435a41cff9befe90981cf6d7808818c35b074a3d591b81ebdc9ef5e8651849b303894924eb300e55ca74709ba52ce210caa58a74a607fa4efc9554f1a119c3ed68c3b45b16fa86f4582053696ed14c8f259185ce88862a8c290b77495b4a76b71788d0803bf5d10b746e1c1cf41da7a6d3fb0faee39182d9d61e39d1925d681d604986592d4e5df83d88e65ce193820fcb6a245daab30db1cbeea5c78b961caa8ef37717f204dc0fe22b179591243e1110c6c62cf4ee5a266a304296dcabce6db26525968a48ada9497ae0e3cf590bd95a7cc7e8f908638d476278998bdd1724664f9916a60a11438cb5aacbf3a3656f063b84715f71b5999ee62e28e08bffb844282edc8c39d2448e33bd4fc12e345a3e9323b21d9e1598fa91db2a142ec819dc69e4d3eb54cc2d09371323de82946dd6d8c5c9366721754fd2bcfebc66d01415f1e6a4b791cd55b61df273498f92e36589f655658a4d5e28cf6f1b2b9e8d6b3022c772cef4f2e7d6f2a9058f068d79b1e7cf7ed2155f92d1dd47c5dc16356f93b7e3f867029b44f8973e256ccb10bec241226c64b017571498891377741edc48098e970a552c39551491e6bf1a2eafae6a284bcc2668bc9d6f9f2b837b6044162d4ae4362f5c0f49f2ec5c744ba4aeb2ef8a4dd6ca85f079bb3dedad3bb75fc4fed4c6af490d3e92742878dec276b048cfbd1fe8eba81cbd87d072281fc6142480e2ca373a7a63e466b2ca6541440549568382484e58636960489f8d8badce2e7fed31caf23e5618c672f8b21715cefcee825ca9394797069e55c37a09e17d9de3af25ba4c5affcc9a5976765b2efca82e340e0ccdf55a5b390be9a582f967027e3771b0b19f9f45ca33b47d38e53decf5e2a6b19fc17253238ed2edbb05b12bb237a30ca07ac52da35df8431e5ccc4fc773d4da3f084c4bab64b0eee053483aab8b12903fae74d8443008f90dacf36e57bb975f737de4dd8555923fd9a454b2a8a395a8b39d3b8b1eb0f444df23b45200f7ba9ffd18c71a236342eb8f5bbd2f1fe9e106f5350c648f206da84ed927a3e3265f406da098866785cfc4cf5703153b3b289009d4b91e8dc458e097316d7bec4ad242e3c5eaf3d9d0529b09f471b89f0892ec24492093b9a91775d3788b4dd3be9b25c9ec02b6b7fde98e62ea89e98860c0c08b9c97b782248f33afdc8ef23eb2e927af62c50d4fd63b2287bfc2fa805306cd6a0d3aeecd9b480a28a35c20eb1135ef011d2a898d668c18fc053142ab36bbd3b91ec25d238adb285dadd17bfc8fc05e99309504d25f4b03a0a46de8c4b68deb4ebebf468a8b63b2883037fc5fd5e437424e151108778e5e154b7b9f4dfadadd92cc31c21c860531eb3c57f7ebba82211f22fc5202a6b5c45c5d58eb3ec9b446a870315c4e0ccf1ad2a4b6c1eb3b225dd9b5cc42536bac815666e12bc7d5809471c2f5e791b047018786d5834e09d9c99a2f63fbc88d83c7aa7151b83e9a78fd60acd7ececb59382f873bc836dc4179671bef150d8aeff014f22dfec83542f2aa6602d5a72f4311cddb4f74e76e86458452770dadeb5f51dd78b8715ebefe97a5024dcbc63399e170f3d3f6f7026eee7e71190e394cab32845a56da5bc9d47eec9cbf960d3802ad3c3c8a2fd339e619e8f369aacfbc8d884090f3b515be0707b0b073cc3a91e98386a37348c442acda6a318b6f0add5f7f64089abc9137acc8aced3509c7f4eceffe795bb5318e5b401335c58b64a4394def23bdead0fdabb082ea30598399150fb1c1eca34fbde324406c5078f68a0b4fa3aa9f65271860f2523f9c97152282c025736481bc736f38f39d5de250cfe884e8b8e4f5cab1567d58b6e0be83876a7a21c62ae22ce7ff650359e29078b7e1ec416d3fb5853464686bc1d90e27153fa281d4a23c9a9f6e65b8c78ccaf9ed5ee600283288e379b7cdfaa2514bcca27aba2845d08fabd2934cc5cf8c30588ea8351df9eb9f70ebd63a41ce20fa5e10bf6e436c541815205a1cb39532d27e491ef5d126b942de24d58a982bf80ceea6a002f9bd03e3920a702964d61003ebfc6dcf5099dd822a5fa74fd3ce46f172a1aa0b8b29b94ef98f748974504c0b6289a82d9f4688eda9061710385f944dfcdaee3d47082250424c006147d518e6ec7b94bad22b6addeee273c1a2d3f90dbe2da6f1913ea011d0a83261560cf4112198239e3696eaf90ce4fe5ace0a784d9d1339f619f31ebe556d79b44bc2be5203b91912d4aa5862cd7a4a235775c500d7d39db222c69b84f0d23412df5f97ec0bdef0abb27140ac2ea7523c241af1f60c09c6e75638b9b3f1619ec8853a1d7dd2fc9580ec3a9619eece0bb34c2ab98b79f870f3e38afa9eb1170455e4ea9f9707d43819cecb643904362cada946cfefb2e55f2cc5190fe176d5e52ec33aada01e81764703062df7ca9ac2f6da2430cfde29d1d8aa9ab3d90cccb81903d904d93f5cda76d32cf96df9b57bcf10fd55643fa73a69ec3107a3ed63d31064986539270f2922caa3351bbca1dc8eee500660427df67275b51961c788b5b261a49e1c6e66139a156e2104a66ace6fdfde19a2a8cd7bc02456d00bf2ba1da3b7bb6c8c851432b5c3d226cbe753f617dd293a143b289e8a94c1c5bd23e0d6e8300c5fc4ef468112d2268be7cb6ff3fb4ab07dfc77adf2a584a401b7e8cb028d827207c134e5dbe314873d9b76efae50e22b5a61c54b9e8a741305d2d106c636e6ddae7303764b8a013cdc8b480d0c93898967bafba69aaff468eaab94effbfd4954d3b0ff0a8805fb3fdff2643fb2ec0e56449ba45ada6c34d10a30ac2157a4c4b56ae4d39097993170155c0c781b2afca16caa3942ca05ea863a60243943cf1785652a7de52e66e42c0da1610baeca8c61860e7905da45865a8d199f73ca872a2b67b65f594ffe1b58089f4487d812cde9e71104614cbc4977bb90b8cf5811f983b39b986f30d5b46e616963d631499197bbb9a915b43a86de010c8164c1f4f3f4bd86d5eaef781a9cc9e79d1ded835096226104cc8c5bc0f4215a52697a4b360330d2bef2ab3c4f018a3cbc8d118258e41927f52b915093d29fa4ebce93bb3f8c4458b33624e153dd0ac4e9db098de7c9c28808d8533e8a677e40911485e34bc1cea02bd6edee6ac49e910c7d319e219e00e845848cb8df12d7be070a04e2ef512448e1a63be6acf7c1230f6fff7c3b4ac1381ef12d1c03dfa11bafd53bf99b739d4369aad35943bf0ea31077e2bda3f312ece9ef6f90943097062249cce0a6883deb82578c9710949a9bddddadafcc2f31b1f78c3b70386fdff16d86b2863638db916dc25952dc988ea455e1294cd3490396505f29bd3dfe559582b2a31ed61ada13b64d8c7bc8f8823c80fe5a675a50cf61828a4003fd21ecf1ba82972754f11d03d38d909e6d2ebdb990c3a473eb4d6a7474b280cb400be670fde9e215a44c87212d75ff7673ec5dc51515c597f76a342a498d9e92876704bec91f9e6fc6db2e9e2004d06295ca444a281966b14b42ff2ecf03625ba9d2f1eb129f91551966bad625748d0673f5e6d28ae913b5fce70f27f51d11d3e2d1aff9baef063f2a80afae3b3b8148433cb886be3e96273aa120dba5f73f1007c0361c090e78f202f9021d1872ed8be1052cb85f3f68462a23227923f208c0ce7fc013c0e8c2308b16cfe2a36612917698ced5ed4f5fef4affc81fc6f3135a0e2ac8c0cd26973e8df5fc08638a840c6ce1b66eb70304bfecadf15d6629ddfb56cc7ad57b6c76a932a9a5e21d577552e441d86a8b6e71c639017999823d384cf39229824ab173db950480f02676503ec3f1323d412258de7fa05a3960d60a2589649f914a0875f1cb618483322a1d381f0568b17e2ac8a802d973d2e126e2740491d7a33404759252557c6fca075c2db74a716c47215c32804ad8cad0e4eaf867f2e1c1ab888640593174b4dcdea2da888730ed4b956656f42db40ed2708f2677cc07282902478b7d9198d590d0720f722f3e6104088ed77534b5f36909a27ff7f9159ff8191eb4849ebf2c343af0f9532db96e9afc1e24f9a87724790d9a318d0785b4a50edbfe04eda3d1a7fedb2e581b8e969088654546be435147edd9b0d28faf486f051c442e1c770c9303f39d4368cd50fa50f18f009132cb893a53b34f4854c37e4aeebc1c044cb1c26adbb23f57c4c03e94e10a2ea02625ef19d7eb9b49d5d381dc3b7a6678471229e762b7d10674396e9ed1ee3270afd97486397f1c46867046f2229623cef15fa339e7952bf80e7475ece0f195f1e4fe15231ce3c2ba94b53b8f3b3ca724ad03bf3cec99777171ca36cb1890582f523770df11efaa0821f75865050270134f8ef8b6b0aaa7f39b0f5e798e85a24548957b330c3d4af8f2e6f469546d5ceb130a4bc49d49d05da9e352bcae868d5e09325b7c43757e4a78c657343eac18d2613185b3e5ffee3ac2eb9555c7a14295131bef1cac5d18cf7afe73a26f47e58fc915d8cdf096cca409c1f71ffc41dab947890f7964f0b1b2f4d8c0e626d275bf800907f8af6d39e383449eee95b122845f924c7fe588a1892dfa789eccec78b2fdf7e73303ca5590d9bc5a8c459a76cc500528c660f491ca17ba073822be8bc11a27af156888b4523d44a2f5931dcf6154be1e52a8a563207a93f65c5113c06d214fc09aa0c0b492c5ba476a88e95dd33ea913e7680ee881d303c52f519579e385a99ae3838ddd59b61bd50d479db4fe272c9562c902a2afc7b439a7dd6c341b2e51da48f3e5cfef27150eb76fd694cb2c7a4c2a2fbc4e3db4fe01969c8291aa7471bd617d654d0b148f665ea1a94ba26759723c6d391c61a656cf806bee98c7ace09464b2f0d982f12634f4e3349dd087f415edc07b2a820d2524c69ceae3a76423bdb7a0297b06568d86fc1564fd1fcf14cc0de543b4cf3aef334c84324661ee14990ab60b3808544252b269ff55040790da8d2bde13e3c49a51a746cfa57a9972540cd6526e062369e7268fb1d2814211707e8ab4fec1e893b7cc0e023c5c4c4f98e187a4f7735adbf625ac28243690b5d322738d97c9b3b7f44e4d7c078dcda9a6273198148ba7237602cc90447f15fddd81831070beddd2c44a06a8418068e4f58e696323b3dc73d262426d8ee48ba0f88eec9bd660fecd4f1005d8d762d975a59e9dc6f4605044d572e7c4d62f04aae0773c230f4249ae3d53869d2de68aa9a16ff737e0090e3096df9be11140b76dac573d21f0be33fb2baea9f0e4271d01716945c1f33fc2b53c999bc337fadb1146bd9040001fac8b33a2d804f23ac6a82bf652f9d0d801027369f900274b425f0186fdc99037810a8310fe3f9926761a758baf68d54a04506d011d461b9964813ae0d9dba267440a3e275de38b62e9ca69c3bb69da209d750b4b13dda7e6b62ae80fcc4e1f6c5f1c2988dc6cb5d209160d8ee71de09c752c496eff5957ac516cc1289db02e0fbe1b68604a04ee44328c59543e1114a7039c5ee6d439146c479aab532c5825ab5372d8d37a3045ae72ce4b89248c8f811a08161f8be95a6ad14e87b381906019b6ad9968aa0b8a1905a2f45a3570680390f419f1dd8930f599fa7a1684b40ada05b19071b02bb9a7058575c9db638650d23b0a014acc9358ca449daf26d3b5e87b40cde1b3a22abe0c8fee07ec8721b3f249c22ae07db427e492dc2b2c2fe57629d2bef42f164d550a8578162c85810bcf6e4a1b1d27d0ff54557e37629f208884139454b1972f72ca8259e87accc81acd4a434c7126c6c08812f12584e19d6f172427cd28d073fcd5717a12ed853bac0222a1eb148bc3a654c423d072f741601de36142ab53e3b0b62b5033dd6a3d011d2e89da7fc40f1a44e94a4dd2eba5126dd87045bc1d41e95a7411b3c18ce599ce8a5285738d51a7a0531572a7b2defbd51f0ed5a0620a5ff242f0aa97bd797e1ecf11f0e8e0e0ea0d2c65b2c3f6c7c2678b8d5499aa1bc35fd230fa3384b6ced1538b705bf99f4187b22d1b5030cc5e214d5268d84b1a8140a23e52e3b901f42cb79ff1fab72260c6c10be1b94f43686ed07513cebc23749cb0f230c0a4fbcebaecadde9a8d11945716ab098c57d9f9812c10619e0ee42fac72a9d056f5b4b0377e328325e94d5c0b8ef22b4d6a780b47caf2b0dbed669e9f3c6517cb2a0d42a284efe4c59abf5e73f73f4da12ea36224fb56fbcbd9de0fe59bcd75a7da05e480c58412666f49d6a228452b1beb7b56b5233ad744a3778d16c777ccf89ef2e22b55044537748d01e34adb78ec6e16551aa86d630fbdd29ab93d738e847480f61715518ff5f476f8ecb38299ceea1602b898d6b6ba4ecf164c039ba7d5b47be786788ad40d588ec9396160c0d86dd1fe021c615de511723be01062a617069d1d5c8cedb68d5b0f1f91ba7c468006dfa8ebcc316833b48c45e78eeba45852707d6cd6268f3390050e92ae52e968d6687166ae0d9a2504ab713c5bca89eb4c0c51e1c7fee92d476d59dbeb6be01c3390e8e95e0aa416cb704309f4c4c110d8f2612daa2d35143dbcb3dcca0ed6d1547fc8b45bad297e418a5fa09c803f2d1b884126164c472a7287f5d8afa267f16e543d78ab0a0d32b0f31a9e3f0dcf212450a44bdf6c3e7227168689db6e1602beece18ae6adf0a4ab2b1b72b4692401bd927df24b70975285358fbab0d524c8a0fbfdd9d9d6b190364637ce117f9c721a3503ff3078deaca95e649812addc89c4f44a4f96338d5713c05947cc43b56d4291841ceb102b9011d9bbcdf2660b9bb097b2edc0a18b6c2ee4dd68ab74537a45efba93db587d303f27ffdbe2899e1f419d11f5fe36da4203ad6894a48c3921e66b244cb70492407888a5db83fa9e1fc000f54670a8be3012ffd1bb98872fb47ed26307f27147710c258d4e79cd21ec87bb4ba8d14606b1c7832012d586d3c52bbd76cca82267bb384d44d6af1f94aa9f1c095780812e1189993272e8a95feeb11a48369cae920479bf659776718daee1a540ff30ee8976a61ee4ad65ccba6d477a984f41a3e726b1dd3f41c5eb4532c09cf65cd38532868d64b540bc9b61b38a57067bccf2aca62765d4746f58fd82eaf99b76a5d3a50a793a68613050b5dfc7eec57bf4891905a9f01eecc98bbe884a6faafc61c56f501332eec95ac96e05957582c45525df2550147ab361654414eacd3a1df88d146de43f03c8f77a5dd1127607ad0d610561e0a378e238c249efe6365f6d7da3ac1ef07bab3e188abd3faaf074c6182462ef0e4fb9977bf019436d1da28357e2a574725f09566bac346c14038e12a397fb8f7a8fbc1675277bbcb3c185e4847e21776a5eb0bd3ec36a59f139dbbe78c86c7d03e2c62c7d13b1903fa0bfbbf6ad2a013b0aa2722b339590d86d91d3aabfcbf696936942b9899e78224436986178d3dcd79d4f9ac8771e760e0a6ca92f24f2b6558a4e0835fea9df5c6b4a703ff006b72ce2a50d76e91f1ce8268e51457dde7d2af9c5e37d765bc93aaa48df8274cfd68e7f5e3f0e704bff34213cd556d9e329fe286ac665ae2dd5aa650cb756a270e176c78761dcc10ad148ccd705f18a3c256cc8a5a4b3d83409ef3f468c4d1e565fbac5b5bc3d462f69d849423b187078ad434c8bbd344ba8852412b9665e087427bd0429f3f244774af935100381d7d0c59bc9138d4b24fd5612834a53a03f027ed041be67597a71ed298b916f9588fd47a47ca697aff889583e2320cc6b1a6eaf44ed1406cd135e61af25df789e17321bcfa1c707c884f77b3742c75da320a2be9af974f5cf3dda9057a1d8ac768048087ca7e6c0601bd17d68a6b9f215cbb421e71fe5887cb98e00e6e2ebfa203cc181b15112fc28628ad469a14d1fcb0e67cd6b38ecfeba4f054d2249209179fe63be5ebe2082cb52a5727eda6c4fadc3e0928e7216e938432a5acd6a45a5723e71c3582f2701c88c0ecd2e4af1afceb657462b5e4b6f4396c6c67fdc008f2eeae0dcedc9e645a62395b2b12e8403e990b2b9b8587938f356368c41cae39991f1ec0f49b01ddcc6f55451f9bf80f2308b13fad75db66b3feb7241197d2b5aadfb24f7bee01bfc8a950714274025cb7d58b4191182a9c9e887e99ace085e8833161290a13296080b0953ad8a6a49009395cabb9dc1ee9436be682dee9c774eef5c68a4e4e4f6f4e112a42e33bf8d3afa07e82e6291dfadab0e9f3d76a43458cd6426e96aa91c89c8f421db0d76d2f037a51e113d96a3e369f032325c59eb15f08d4c3a58c3922716703c409115da831032254bbf6e5f2cb6620491ad06cb3bd3e194815b7bf5edeeafa6067019ab6e2a7cd7e3594ce9b7460c8277061abddc636b760513b140d6c98f6f1e3490d39be31f580134dedfa82c803fe67d040ae16d2b1bf1ea8c01159a2b322be82f4a70769c6d220a92ba6e1aa6b4be2de3228aeb2876f40695563b170876f35703bbcc8217e24e0250c5a15a66987eae1e3fad6e73089af2e123afb5c96e9037071a3def6e1d319d12784bc7b066a8b6fda1a84efc40c533d9c242cbe1935ede6c88b1182965561df8bb48551fc968d080574d813b4acbfba49b6a3f626964c51dac2ea1fd2a043c4118bf9932fbf4a0725e7170681fc1e31035e598de7a7dbddca41b16d1fc876a472aed7ef776dfcca7063a888466ecaac0ff7df2e794ab2715d17d0f62edb3f96bea81563128d55177d54016fc8e7d7d36ccda46b8f8801638ed9afe8194f258c25dfd94c053309ce3d3cfa397130169a839d96c167085855ab6e9888f1a48568ba679e3326ee20d3e7944504d0096a5bf62ac95b5d876d3d1dffc330384bbe689c0b0aa2c39ecfaf782a412a13ca0b5cdec64ed8494764fdc72a2cdee668c79218fe3a5ee66d4ebe5113f18778413cb4e8508523face1c995e0e3ea392112192f64bd3fdce780340863fbfc0d5ff2e143eef08ce9dcd1cdf5cdf68cb5de899c22004554b2c812a8079fa953ebae508c5425da31c0e82ec79d4e2dfe12961ab7e2470f4ae9f43720cd6f0f5388e5e2390b523dad3435fe8059dbaf658dc7da00b641f16d2fd45ab56c7d080c1a7d0c952a76b01c8aa6ac977cc8298781ca1c4b53c2cd328f571901b87a019376ae6b064f0ac5472ec1352714ca8b31f184eb831df3cffc53e800eb1f4516bd480bc4acc48a2b302d988be7f1f99f1e636095515bd07893060d6d921a30255c3b5af34ef0ad0b4312e629cbe48fafca9f0fb67a6df25eb4b47d9a5c3253de7b312bebaa26ef0ecc09e5a9be981e0acfce764d27349a50afafafb44471c23bc5e3e276901201ca4b87ac3bb0c8cbbcee977354175d3020bfd8eb6ae6a44b7d589089a7c8ae2e62f8b660a11f937a730bfa2ae326416ab18aa73a800ba715941609c38c1b5c4d11660d2b707b4de5c15199dc5bb1cc31b709467a057525c7160768ed57431906560ddbdb04c56f5faa673788435a8a89ce4a0715113dde021f3e32b91251ab0b3d7dd3cb04fb7d198e939ba794139afa54867f8add160f58766268cd92808a493f53bf48f8def9bd97e64fa7e7a19a40f2dad005e2b188828f6417351e3dcc056bb19beb83819ca69f69191e077a0f82452470b08e576219457e6a5664509ec91e41b40d97d77d593303b3dd54e905d7a1d0415d8e768de71768ce00f8922872a7973e30346b6657a91be395579696f8964d1adda6b2ee511589b81598129ab7bd98f54ebcb21e813613dee396e27ad5e5a4149339e93bb101338a7e5c550d2593bea1b7fe8aaff3f130ef73ebc8a41bb5568484e9f49cdbe5ad5bccd804f8ee373767fbcfff5bc1f7d97092397b9fe5872ed1bfe9f2f708205dbe8224e76a817be4f268350010bf58111fb4a96db76e33c3e9d59f334d7db4e41686e810bdd9be9cc1455134321be01b67f0f84d5cfb0958ea62d830775ac31108a6f5af5fc15b006c96632e65e20248ca938456a205b14e380d9c68f840be0ea7ffbad081dbdc5244b729945d5823d6f2aed976f9f6fc1240c7cd87e43aa1f9efea533052dff547e51f16c446422b7921a4fc22e853604e361ded70c6a6311e351a05aaff50b0cf19ccea821006b1615046d98e665d324682bb5e34112166da9d89eab03f16d1e0cd1280686c5bae3adc68e2c58a378692ad8989b073ab24e1b215d6c95f10cd84b602e982f5ae446bf95ef3667fdba10253e9a1cd93d8cf1c93d70bd71ee007e836ce76c65b8696275823b78cb89c7bf30ec4a0f6abf184de293d6fa96dd40ecec3d49bd29dd97e4160f697c49e00529c38993986709132dbb3eb540c2dd703dace743c998b92333426ed90d6b0d6698acba7b15f73b2bb8818e2319ef2006ef48a6d8cc5394e707c485610c8b019eeec9db509c6fba16a78606817aaf96b8fe4e1ebc8cecb5593f4fa862e572961b05805067a22fc2cb46f02d92c3794425f55a6df915b952018e44b6656a35dfca0b9f30b85615e4d4d38df6f6e0c10e0c8514966fc05aff6ea71d3a45771ec704ecea2c9e2095fee42d4c9159d285c10a31c79b25ed6e5739f1718c59c1ec76464892a48164f2894375030e7011d279b87f7fa2b69dcbb3216bdd236f51bd71db2e33ddb005459daca46275d89b43b56bb9625d54ec2478f6b1601dc848184f3556c8976d9ae1b47aa92650882030a310464b5c30a2728ac08ce7f86b535dccf7406bbb7806ffa7cc8d7f038c124d9c2e5597f1ce1958cfcd6431e0d6643ee0ceb9913e795f62e1d5abdcb1341e4db35d97ec56aecc36a3504b803fc8a52f5958b765479c53418705df8c8583d40cb6fd20949fc1ed2e5a213d51f18a3149d68e6999e725561e269594bf1cdb3bd063629ff8dc07aa86a72c52876aebc23347f42c047d0067d98e571b15bc09de38a0d697b77dd07601e29c2096b5b61ce76a791c260b06d5edc6e2b30030fcc68925fd1a23d89cf62cd53a815795e6514d657cef5b7efe9423733cb69aaf4779c2056803c850365de9c028ece400cc2d4683d10d3902ffaf6ac3ad3864951735162735cc5db9fcea2623522dca6592b1ab4de93d4c0c0f87e3186fb841e94ad852c75365f5e45ea705a3f83f2db9af1778b2c50067bede5f83b92dfed0a67184f6efb49c13db84a40e0d35e323019da24d4f5f3e2ab0cb1dcafa3a72b04559ac7bb788066e43a0b7262ae901cbcce00ed77603d0c5347809c82cd24bbddebb89af022e4a8462f3a41555ebdc0d78544676ec6a2c8775e1f9ce88ea54cbc26ab57d19b3a6ce8ac4153f07aca5e03da1114cb2ff417adb59ae621d234c021c678d178df9ad4268ab198ff46b7b015344e18569e9ef1394d68c12d026b186646061cc241c8dd3f2757f8530239f9a5ee07fd6fead44f0340a90a2038cd0f94bb1a9b7b0648bdd367300050cb35da1551be36bc863107bd1eed1dab6d1372d816ce6c040b769226e060a5c181e195983e767bf26dec9871a5a37323907cde91b0843cc8bfa9a256f534faf010352a088d07833a1f2b93fabfd691b448855dec41934dc5ed2ce426918f98960e0e437ab1bc71fa2b29dd64d3853bd195ba78fad348e6f84649c6450da7d25f456dbdf9112fa5ad90ea305e0d7b195ece2c9afc67ced9c0c0b297b5d76f07b6345ca57d9348b7c96b5708fdf053aa9be63f81148220212573e62e294a40055b389068ecd74791095cf346581c18141d20e970cca4723c55683df727f4426c7576cd0bff2623eead909400bee69492ad0468af635959edb2a4d9b27005c66f4fb5c21ab7efbb9aedd4d234718bca3c2bde6e61616950057de37dd1d3a6855a30f2051ed803e5d75b32eefdcbae0d6edfecdaf99e968b54edba5eda7a7d1d574fc5142b92207984ce6e10f8d94dbc166bb4998ffa3e578a3bd3fe4f3832600a455c24d944ddd2800be84c911243593dab4db0aff48dc468473dc73a75cf0de2419a7330dc7d1757c356889b6ccb3647da015fb71dcdc945e777575d4a8f8048dc39a98bd47e81e2a51d1286cf86e02e2160ae0ebcb9d193c11d8d96f65ca4b247c9d6f0e57cad10a53bc7837c9ecbe2de60b173ca854b7b459e424862f6671ccdb493eb255ceaf67b252850b4ac9232b228351b97b50a5c3cae5ff1404b25fa80d26bb19cdce3fb380c329a70fb9ba1d9c6b2bc1460be2be3011b189ca118135fbe7ba522ca3d354c28d4e7681069366844a634028feafd643c5d3f09229ee894e202c140fbce075906ae784f328b821c0e46c4f78dc924739acaca785d636402cb6a0c1eac3b23fb6ad8d6090ce8c70e889aeee6f089d3bcd5e8845101a05e9b48f13fc8bba643969ca0f76173ad95916d738a7ca07cf46dfbace2dc4950c220a0b7c6270b431e408d2e8fbf67773c9f18daef9f6b5d3a2c1ec58ac4644e05749e1cf232387b56c112ecaacf0ca5d7ca01070aa8a8a3adb6adf6ff7c232bebcab326f676b08b462fe23a8e589481253c6fdd2723cb898e1cce5e5fe5fd8d35e24d21908f0e7c015ed27c9beacda19a3d83fafaa7b449edf48b55224715d4bbb136764e1623b1b3789d9679297a1ab4216d557a418de29db2951858570b00fed3e261bac53d72f010ee011656988791aa7412b9e71ef22b6b8889030cfb2125548d9698bf559943a520881e11a63e98317f727954ab9abec7d699d98450246b67f5072e498e080bc88bd56ae04006b8afb15f455b1edd2edb7ad2b3df5389f8f2187174ee8f19e9e67f393e49fd90dd02913af297871f570f0e5f14d87d19ac2460ff6231a81fca1f1096683fe04a23ca22438375f178a63a98d2edd72b1464b85107a46675bbb59d3e8657a734579ccfe5a8815847cf4b138ddce5e76ee80fed18be2c3d95717bd76512a5d03a3ff17804caf978fe442b6f5db73fa681fc131efc2f1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
