<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6c4cb0d993b72f8aee6c5ebf6d8da1c9b4840a1653a9fd4a8d8b72b5953edfda62f76a5c8a95e24c848b4d190c02bdb82631700182eb5ad7545bbebe2792a9a601012cc81a28c49588cdb21cd3b8dc5f3620261671b43a2b70122d0f15d84d4e9cb76ad76109570f9e4c972291e3ae9cae7ba0a0d62d8254b477816c223493bc1d33750bdf004b75039bd99238f8d6bd3c6b6e57bf9e201972e1b6c9df10ed172a502924a5e6edeb8dbef14e48b4f2c94033a4b4d8396ccd52b39896af67d4099d1fbc6e64caf0fb959b3c42bf2d79ece9c793cc283b1d67bbb5d889d65bf1c3846573bc9a8f79bd1c91c8708891a601a0a080ad6be535130be383f3a706d196757add95bf9f9701449c1015aa248f8caae79255684ab4b21b4757fe799f5b601babc9aa4235184bd44d7b48421315d7627eb5bbd57b383c68b4b35c3eb4c153cef0c29c08810fee8d657127b776d283d55417616d2dba5c9487a6585ba7acd30a0da4979eb6f9155edba70acf4785146fa6a92d5915322736fe2b4fb136721f572d5fa82544e72e65a4889c752f44909c3ee44a7acb1af8a603114fa0b92ba4f15580c5d0f0f31884f084ebdc1a2fd06d09341d7416f407cebf4ae6dd2322eb11ba2c268ab98db3a6ed21e88e46f5e22bd8807fdfba48d81dce38b88f565a92a9f9614d968edc8bdfe3e5b7a8b9fce55c3fab41a8d60e254b7dc6744ad6ab3a9d40f0b68ee86b00cb796b5be9db888e2237b36e96e682bafd414bdd9dac6dcc115f7e622f855011a21eb3d009e765976e36a301c4aa4415ad4d9dfd489f2cc4809201dafcdaa6bfecd015595e3de17c8344cb4131044dcd44991e04e197bb39d4999f288ccffb1076e00bfecd7594501187c73834bb1c8b3521ac3a4973e4d490e116ce7f0b23072a3322ce63b69f203de1588814e702c6f3ce3535edbd22f47ae78c4ba572bc20a00bf79e9749e242161045d702b04e6fe56c60b4009bc7ce1a7b65119d2b9021725134a9dc36d48fb4d0556dac72ce93feba454ccc362aa4b4f5d1d04ef6727002365d565ad6f09b276ca7e3f975230cb2a3d97046a2bdcb87a38d0466b1b6167a6ed15f2c69189d5ea07edcdd65f8a1f50efe0fdc59056182d7c79a2e1fa52c8ce37da7f0573c03754b9bcf9a4c5a3c7a783970385f5f00181a91f1b3c3387d60c909f7918d7ca1bda11d1e305265bfecf19fb7525ed6b6e5712d8066d01dc1fd621ac86b5301e19c0534f8b1af911ff84aa670d9c93cfb71d6f31d407f9a0160af8c39d0a7f619b66241fbff4cb194a3ee414ba71caf22536c072732dd84d99e00e0faf4d4cddbac4ebaf6a68973ceb2e9b5267d75f3a252769fcf04d6b7912daa972fc6d51a636185b83e70c11dc42d415bb488c1ef877cc51653e59d56e0f8f1b549aa752566d7c2c22d203b85f304bf24cf6b0c53335dcee35a2d80bd7064aed44e45cd8693b2a345919b9d2f3c60e096d54acc6cb94379b9adb1bb35dd76846eb413a28e70ba88d2e2f49bc32c1e57adeb42df9cf6eeab66384936b3a13f707c58f216d86585fb7f1e1e269a591d707a50fce4b8b41ddcc7e72f508f7af5627849af12637dbcd3e1450f8884318244a4ede4e3e90369bde09083947856137d5038a2b15c1ec80e0825e57c6210b95c770b244fc5ce038bccacfe346c4e3764d40bec6203e2c499837b8eff8e849bb0e654400d6b56f76fc57a44d746a90d59c77fbd33b0839f49cc8e7cec360ebb2c2645a1fb3e1e75e4d3b3b4e6aef7fd9cb2fc01f85362312d56774bd420f75e60be314169efacef49d6c7a940085f76d39d57580d6f5138037111869d244b55926e17f635806e45b521020a71b029df9521640f35baf0f0b51beabbbe9516dbdb36f8f53e97858b958c6e31195aff144c45df7711103affca4b327dd59eb04a6679d4d7b077417b1c962963838faadb2d605b67217d91983b8b8a92cff1097b86b00be372e9c188574191bbd4c435a8cbbb6bf7b127b5a2ba6f9fb2768a90343c79c5a5b01cceb0252e892f126bbfa04be75c1e77905571e621048037aa2ed79090578761014e83033a48e03ec6479af4efc584925c9fb95919a60a89313cfa3e696cef195e3302e267472464b2f6b15973aeb237e1c5fce2956fb3d5871337616476b13979628f9e50bcac437ea2c180552192ff96a177e9547ccd471cb37743eec0b5f52d38710614cf71c2831c0a12166d351d5279ac94648030520024bce7754e03f13e203162b5886fea44253edae0562e6a6c9e7689a740c6f69ba2ecd9b38de0dd93b850bf56d5d3cd8a49314810186229c25173cffc97502d0caec5995912f55cddd31d2413ee8dfc5c0e66f6199771dc6615e1ed40240befd209ad56aac095abe397e1924bf93173cffea57158df5548056ca8c068fc4fcc32861793694fbd0cb6ce27b22e030047bb76d0189f21b43638679987802ae0d48428a5ee71664ae551845a206c45715cf6f00bfd968a16709b00ab542ba9aba3383284fc345e934e7b324b5b301c226ee09bd608751a1e921118ae9882157f484157447417e685771c5f1bef0d15fc9b88f1410890ccfa575cc14729c2af6a9df8c0a31ce3431d9efa1af2548b9b5c8bf039333a4b9dd96ce34b28e49a8e9c193907bbc8cfcbb7b6930f81e2fe8e593e7ba82a4d0df6bb8a0c36a1ca418ecf6205fb9b68929507e457b2c3835db4fd178657702cc012a939049a28a11bf1f12033be23c4ae267ec7784b5eb7e0569b7a8fe920c8a65020dc18266dcb5eb4a76f7f90af6f93b136d1229a0ecf90f8243abd6561dd0398f208297d2d1b093c498bc66bb0e21c3ccc15050c6d3ba0f8e7d0b7486e52679a19e489efc44b472cb825c254a7d0b15c41abb5c7956a8ed791c0df3fe315862c308e46a26234dcb233a928e54831a4c5d2da981e1b1b05ba15c2dc4429e83c29ffd3f4a215bdba631aa95f4ae83c115359f23770d5cc79dfff17b60f2c04ab8d2312af690d89bd78e17c9fbe5b0fb1c32b583d1ddd70b5d8aa30e991f69c84b076c0a87dad0724c3a6df0700f9c144eeb61a16d49caa698ce4de5939ffa7a969197457674d5752ceb1fd8d33288101ab6798fd639a72d5bfeb79a53bb5594e2ff490ecd9a833da92df33752ad8d29251d86f165323008d1782107c2d312c0fc47f171909cebfa96b238f77e031082913ae20b6afc75f9a07618f8c8579b87cd243138f2065042cd9c99d0a5cab69a0833cfa39899919b0adac4fdd5cc3276742c6b295a144ca8fac90aef739d3236e10e62a73b31c39c79492f1b402945ee6fe2113bad81ab3fab555fc0383790cfea1423bdca649cfeff32244ebc2cf9d45fc5e1dda1cc54c4ec4aee5496f73e62ca9babd2cec343154b3ab8d18452ef443b729d2a00e797d3af72df24bc44587701916b69b228e7310042e868fc73769262da11ddc3c12ca5e599ad87bf047bd669d8e18f9cb9f9ce1d82145e13102e1a9c2b0f5c5a16a931169284516834fd96e38d91f402cb65fd48d066041c2789556022476bf5271282507abb47c7c8f6ebded42c590df7fafba93d8bdc97acdc6d8810aef14a2ad0227c3cbbb85b6fd225d46890fac8c927a4d61bcf57f4cd7abd4027c6144ac461e3d82f2b1ea86e1aadc5bf1661f0a4fc4323942b16156ce8e6f2570532840d47b30e3a1655352a46b5eab157ae7bc1da22308010dd7396e7ad07dda87077a27c40c60baa00cf52441076f6b48938b796bfaf7fd4f398b8e3858e5eec49cbdf52b9418ba18f331b4064c28206711db13453f7cbb096fbd084f0dbed4677e1fbc74d1b6fe83aab78268fb202f62344603d8b41fcff129fa61621967e38066c63b0152ffaf611a6f4ad1ddf5f2cf8254792e1cbf4b9f0e0f3d7be62bd570ba4db5abed65a7263532a8de4c0826ccf59cbdd36efaae275c2c5a97a4094eede0e6515bd48773e2d7ea1fab228015080df2fee28299be436a57414fcdac226ab404fe9e67fb75305b5c69421fc42bfd7cf93c8703a0b9c7190c6cec39160a8e7dab94b65c0c54efeb913a915f7ee88c5691b5f03f208d7037e06abd9e4819aab03b75edbfa5043e6a91c3e505d297b49faae302f930b1bdef9fc00e44e8ee1131a639970079fce24ac54558f6cb283c6d8a4bbe0e544c1968698460937d6664842d5530f9cc9fdd2da22bbf1d62b67296d5b820c1223f82d5823d090bf629d593d60e0e85bde8ee170f6c17cc87ca5b867af0f9306134532a61084f8f5b7693eccf272773dbc71a8df672c6cdba3adaa2ffb725e0d06b4b3855fa0e4f9ad64d88ab01bfcf014355179027cd1687747e8dc1473cc605735b9b8ba998233093894a2cb6d1f839679db348690a2455bc78ae04d32a48325d38cbd93b0371aa396216e28a1fa16ce11613a95c3edb1fb28f2057f91f5b996498d3780d6ec9566433ddcc80d2eff6db3f78627696ec293bc271dedb69de2cc525afcb121c5bf9496f3461c714406e7931393d7d7fc4b3333d5ffd246a676c6c73eac98508fbf10b80b3c07e6e91b192a6cfe26e067e2fa09f603aef8bb811d1134e402c4191619ecc2b42705b054f2a2b343c26f7f63040d250202edb92cde2957613a176f1e35a17e135d797ba9fb9eaa73b0ad90ac680dd9db8d472c610555a4d1f1fb862db7c24dc31aea0df6bf91a8c69cbf550da3ad81ce2cf573ec82ff45befeacec33ae6f23e9190bbae86653979ef40354eace5e0559db16df580a0e68d31846eae2bbaf51b480ff3e3fa185e51437d975c3d2c25efa81a68ae2b54263a8303eb6582bfe92977b446ee7c835f461221a779c70f59a77c8a638e35f2160a1575f8519e5bd8aa18a3a821d57a70c86cfcff4496fe62bc9d9c69869429acf09716515a7c35a02fc0de9d0af330e9e669be693cb130f3b63cea8fba818153962b2c9776a12038fd1133bf6799080339e866feb36e838b010547df99ba971b41e4789b6851df7d87760a6e1d9b0c6970363288d9ef9a036e035d2ddcc9914d24580380818b404bdebf51e31e2ee009d9f2ed9ad0fa727a4b2b4706de2f6fb2821a23a83c1d67e570650d007b3ca0a2d9cb34525eac3ce8ac77916d0d4345171894284f2a86955b6dd1bd410415b9a15e8557ee068c3958110720178a119bbf9da6436912147992292e0fa6d46f0a92d87125d88b0cdab692d6874f63eaccc4d000c65f3ac118e4d59ff05dbc15eeeae61e14babadf1bf54e8ff8101fd061334e5b4c73713de9904c118c9b7be123c4a4ed070acc31a0492e4cfb063085723730aafde4739f2663608225111cda002fb79731101c26556d4d11e92f7b367d27fed26c453cf7fc5eecaf22437b8fb02c70de29fdf1316f8f443479bd0883eabd8c7edb4f2f4ae43e1ccedca3808e1575609dd920b86da8b617c05ac1f34a8912b5b82b9d8d202b7039084cb45b9d4b437800baa04055a149a09fc0a0f2983f84ab9f6e2495dbb9062cf798a2f47d7a215b0bab56ae3ee1c810522af2c63c9764ca6cc9d2a1ed1283e6f5e03e8dca41897a9644c15c3d5076376d1eb465f6dad664e9b332422c1f973421ade5993f31626f62956b78fd0f6cdf293650d854c8ced113999089b9af15126c01feb3490f64f007220deeaa47344ec59a01462f8a4cc620441a99b773143fde05aa6b3d42b48626da7812829d23abc2ca288de23153d8251d2bc8925bb2b4e319bff964fb5a792bd68a29cd2b0cd699b16e5fb6e9177de08d4a6271cd4201a31423c76629e1f7931e079ba2b426adb675e91f7dec42a0d5f0e887a295313d395ac89566f7d128f36b8cea56f864978503e0e4dab8629ab85d97ef8406f17f36d12a0f5fb5739d06678708a4f050adf10a42b84ac53aaea923c42eea7937620c2e3d826450b743fd6e5d52f689a0166ea7ea43505493597b80bb11de8532d71233ebcc69c3706e61b2b72ea2930e13f7bff418bad627f0522f3d90ca7e1b98eefb1eaeec0e590b0105fc41ebb13b996c14b6a79b5a2d16044582ea9af469091418af6c3c5bbdb879d15a4818959f8ca72c66c11c74fdd9290d14e896b59ec53deb5b86d1133489510633c2226096f960ea47773e356238829e2756821af7bab2d9e752cadf0101cec4ca90bcf8209e3540191b8850ae02203c2bf5cdcb1a69cc962bfbbc89fd80de4f78bfc8a268515a2a9777bb2c233944677704fab51d057394704d3caa39ec9576f22afb26f81c21de98b1d1526c6fdcd4961fe928d497aa571d048c885d6e685d2d29e805a82544ce6fa00fcf2860cb4dd3b216e5827a77927c420f1cbbf268968f51adef938eae87c4e91e136be0eaff8845ae4734edeba6c4ea2190630db46b200a1fd7ecd6eebe740d638cf80ae2275aea26be02ef46fe4399c0b9eaabf4e5fb324234895d17ff98e696aa26566def306d8835067cc37f21829d1a44fb3763ae8a50e7509441736564a57ec5c1b30881e7020f2ca651267da572d6caa36d191e9e21448c1bd976538859f6574b22ea9785b98f8de3818158cf1c72b101305b9d876b335b4d1dbe6e647e69daa4ac928de73a5b83e2c20334c5e109fdf13a4d635a5df6a804208b0637c4662726a182778b7ac6fe44dd1fa94efd83dd3576d4b7a7785ee9904982a4ca79db01244ae4c0128e58a6a82fefc9024be2426e483b4df5a734b6bd509eb56730f353b3127df8247321d38cc534547fa032a744b6e8acd81f5840d0714267b21a8eb08a84b01bd8b5a6ec838540a0d3de57ce3e594dc6704bc11370a2cca718269f6135e492559a52ac2f46bc76e1966a29a4c97ea1cd8e05292040178426c725b3ba26599503e80b9282df21ac3ea054a27310455cd71b53be51b82a67c3499bc6ca48937370e58231eb0dcda99fae57b500094198300f5c8f4cd34ed4411fa2e1987f591e32e68b3562b21671623e09f70de6d35344422abbbed0aa4979463d939a58198a97a7ead06058fdb99b14fd76c4b6a3af6d3514db084c00fdd9cca5668bbe8e07fac75365305e56e9e2eb81fcaf51359514995f57e1e716307f55b4660dc79c0d2a9133238a58eabf5814870d2a8c6f3e90b36ad2993e868d3464cb47cca0e5cdbabf5a4788afcdee6d2450844810469616c179624214f50e2dfc1c5de73c95d2573d6f2dedbb1fad61f9e707cd50662a41899066d4868a2de46f26ad6e6f907d10c73417d7d77be4bb0587564f3e39b832c20b38e06f17229e2eb4b194b79351ee21e882d77c5073a0b1055b8dcaba3502b612fe6cbe1e0710c3da3b1d04bc544eb811010ed9491689a8dd1da3d5354e7df06189e30dae889e01333c029b0685ba273237f2c302edcedca1b36d7042e4ba68250bf52871714d3ab655671dff1002a56ad9b60d96729e5aba35b5f17f6039a2c1b8dda4d6270bb2a294fc9aeaf261ecc66997744fb697203964d80c7c785d519152aee4e3cc4d5b96a3350228502fca1af97b86b81fa62ee6328317ef21691aa59959ff3f3d4f9298285d3acf37032cb0be50e0cb0afb4d24cc5c2603af0f6822e1be040e9ad39e29de44d9dba56daa793e2249493ced43e1fde97d7076563d3fd1beb34d0306b7346ced2c23c9be8f09af4e356c27b809d14b546770d3585b2fb7f726db1fce456519126f17453c5830fa91cd129bf77f08424e46bff988dc87f1ec8c265a1765207600983d94e0b9c2fb2ae02bc98f5a9b05e5247c0b2a89234babb7f03d3d2951ab0fe3d85baadb00ebc672a09f21a6ce91405004aa6b71526db0faa18680bf2184080f21242ec2cabff867521f1f3b70b5b844158892e79e08eaa491ba174d03908e0f0384de66cd748514929fcab0c152f44257754e37544921694fc7dacccb75ee530331ea8e451f4a555d341d8ddcf402ab2e46eb7b114bd2760e62d6b9b9a5b4c3bc0ce082b6fe526a1d6426a8c9da553d9276f8d77ab2f55863a95254200c31027826aeb6c8dcc898a949273ff46520f08283eef7a872e56e3f63d306aaab0c745dbeafec52b761c6ec9088501f7d07a3476f777699dfed1c7bcda544c54f224af0dbf7f738baae1b53d76e1e75411650eab33cab8c2e300fc27f2533adb0953672e20bba4eff3379474b6bc85ec7fab168e5c17a183816c234d2a2df7f3eb5005eea7ebdbe2a065b9245b4370db8ec1487dedf09009baf4a6afeea95b047918e39dc570fef8f035ec52dcf33f1ffaa929ebcc99db37744a8549a90886078363c2f2c8c3f9a2e2b77d2a9e9826664807b8a2a5abe3d1e841308d6e48df3ac1cc5b698bb516c1c5df04ef0aba00d20ff112b78d5f2c50b2b0ecacdc71d359660a272a5944aed6df0cafd592803cf9cd12696abeb2fa993dcfdd11804d2527aae839dd559e8d7245c22ff646ae993a9777f28c608dd4fccc07a698a41d11cda29d91761202365dd85dbcc64d1328c39ded05f9e3d97ad850c6619ca419cc5e40180fa94d2c425b97f7b95c84e2d0894c048d5daee911732bc3edec2e81e617bc46c29de58a6934f2c5445dcccbd25d74c3276e3f362467eba3cbc65f0bf44cffc927df30e7470a7f4d8d7d258511975c762d986718e088d1c0717f1df521a6cc2c4de0633cf591d020212ca9f5f3fa5a1d5ae9bded22500f85656f98705b1345fe3abdc81b92bd420895651a5699e8166ef11ae31d8a30105ca616f60a4f62ebfe6a69663f9de9ee93b8f25dd0286b5cafdf96ae80adeddc1713bf94b6013b313b4d69840b49ea78b743c2ba74afe720d3277ee73837373e4d57a053364a71d45e959bef4cf7a8c5db80177c710a1121ce49089b01f779057fc6fe58c66ebb6f5484f3f5612c136df8763878b1e7a6db06d0436f745f5306a74f4cc3033013deec2e17373d5b35070602ec1fcf12392c2f91bd5eba4181ac34e7a1bfcc0382f3f2e3e46ad447daf09152d7840f0b4c0c3c2d3e54299ad86017165975de427cb0e75ca30b5f1872db6778b847b409d751c44fb3f1b36318f104e52309d623554c4028aae9e68a62d006280dffa723ec3da5c268eb1c7be1293baa9065472207f36406f111287779b932674b34840b981d605c85f789874bdad141642c3cb53c64fbe1714a9d113fa0824d94bc44c8e7521139d86e1e6df0a70edc4f6ec69cc6de75aab4df27ab8042fbd9d20dc759699fd8038464a531af5cc1e8b7657013a49fb40a2d76fa1fbe0edd19e96e3445cafb376636ba554f2a195fb941949c174963ebb4cc8ba5a22579f2d1f8131dbb10e67957d7f1b04cbd7135d0042c3b204c240473df9a40c4a71f021b7aa1035a5f956029c06939172ad9d7fc1841d4839abdf9339f4820f1f5e6a4b52c8362833a48f99bfa5ce4f36a3e899bc1146ae1c24fd27a16b903751d5a02640350997d7e1e67ef3228ddec36dfc5cc925118d97c743dcd3539db663da671d00e028b12a7ea1dabae88227f25cac61a0d116a9290982149a8341e7fa0fd31f3bd46578c5284f35914f0a6f95f59c937239c71956a8c1aced7728dbd1976f52a1474b407c6c48ee9729b3bc8ef26bc104f9c80e679ff8ad4b3f88ed0d61df0926b03749d7bff926c21ded308e009974314b5ebd606248d08ba410c2799204e9f012b4cdbeedd6303ac7d52eece635b77c0ec88806816fc8e595f82d0f24c5ef47f8efc10a903ab736e2ac21402a8d3a4f08c3752fb52f3f0da5a2e47d4c9635099a8b87e8ffeacb162b4893f9bc4daad6c99b3f72fd9a42102e24324d2217b61693b7b29f9cee0e4ad38d1c790e53859375f935aa4231d194ae3747b868ce57eb0eaabe4b904d94cc8aee6fc9e133e133ef9e16f8bc0549322e11a9d740c548405b6086d1fcfe9e05fb37f0f5b504d38ba3c4b5b82a4944aeadd4e3b0e06d7caf8d9c6da9e7b10efa5b4957ed3b62ca579ace342b930031686b61bf90b89d49ee16b10f6a71b36fd6fb41d3d0e10f26416c63eba5b4f82321fc7b8c6fb6e164c285a976b5525101645bca10ae06cb75e99b99db52f804888d95e7eb673bee58ffcba4e62b13cda805af54c83dfae923d39feb4bd572202beb085af976f87830270ad06913840b8505f464155c5cbe40eaeab5b276f8c037ecd1cc8500ce12dc41060de41f0469a4fe3ae741feba9604acc9d921c058452cea74439173b19601724e97c2923c1b98aa2c09bb6c62a28eb3cc3651eef40b3f625a3f4e0ee626e60af7df18a4f32df8cffe2dff96c0685030be15be8169c0221988d0dcad41654c5b681b8f1794772747c84555ec1a6931428141b355b9bcf047e4b011d91b52b345ffc5d8958a6113f189b670e6df93643f621d7925f42402ebb8f8be828353925a651787f7b44272b565a33ce6e7aadfb0be5e31d6204dbfb85322f286eb5c5ecf7d2db1cb6221d978c7d9be87c5982d7e7e31b95f730f7124aff31b0d17f57b86548e14900206165c623427c6f0055f59e792f58b39b878f0f66bdd08bcb8d44d5d0207bbc1703aaf301c22589c6c910f0e9449aa07c777e889b2a7fa3477f19f7d26e632878c7ea00518361c5f8309995467675df6be9a4605b9a194ab4d6d92e8d59d73c19841a3d49d8c07f777430420c79f57aa6c1104b52a9956d3633c1651e7ad56c12450ede231c865ddfcaaeb9f2320c69e940ee0f4ef16a8c038273ea798fde192160b4f9f9f90a09b286bcd63a26e3f76c2b33326c418f051b5ca06e0c79a7a5bb55f0985a8c601103c085336a1e5f0dd23152661140877732a08127250b1b97250f3b35112f7ff86b6b8021186bcf7a30e5f1d88e76d2ff38d59a9e94d77fce8a897cf92ae76b9c771a894aa0adb5afd8fc12ec3e5a7cde4cc893db75534c6ad9dc6a93136b933607f0df19177008daa3c497b5c1c2e43d1b4bbee7b3a0777b544ab3cc8dd4b76bb5d1c973d9119d53cbd082a72c8c8bb669f1f60be28de9c6ab6948bb0ff8604dc995c117d494a422426a9e59717568a0965f431349f826da95b9013e7344cd2b4562761a4079456382283552df22cf1c7741cf20f382880d8000a5a8bca988098ee3c44f0a563f7400087afb6bef2b63d1206750c31257b08116fb6f5de885d6348dc93cce2b2f9370a61d02c83e41de2c762361a967d70d2fedc7d40708599252d6ae7f961ee01795bfc4277a2663974c1d8a77240664a02b0c1e70fd6ad93370c351054b6f853c213675358f74e247057d9d687e07c39d8959458ce881fc7aee83ea867c8cdf869832808a3b40ef786fcacaf86475609888212e114b9b431b20fd8e42e5618f97b17c03de7cb66cd21511a53b578df3c3feaeafc0a1e4f5d99872a44a8ad8f2d13878ec9f8faa756b3ca110daa17ba07fb445514a9a6885c075c5a029223b333da4a0a9c23053324029a5e229f95d7bf01b591b33dba64cad1e08b4af5b7f275379b8dece9e10bb38c8a5d7a47f9e4bc84415fced3f394f52ebce0e2410b937f613befcbf0d7a45876b33bcc8dcee87836c90c9b850aa27d1c9b58128e83d56264defbe9657ad72f0a6d57f3fa227e082f80ab2f76c64c2f908897d998e3543158d8a768bda111ac3b16164f15c179ca94edc5eb25c4a2546da6c5de834322fbf6978aab6f6aaafdc4e2efd71dd3cb00a199e5bca8dda44fb1b23bdd7bb2fb3cedcfd5c81c90923eb0cb8667975ab014143476b5b399c52dd2cd0c6c4f888669dd5bb09a382494c189fa7dd43f585f8d7a5e4a29df9761c9d3e7e30d852bef6834e512ed0ed06fd414e65b814f5582e2fc0f173b66cefcd2f60c1e05259084407e97e373d591d6dbb18c0c12d94832380ab4143c4df9d0e682acaa0d5bf3d76445ed9f6b3b99946963701f7dc79ef9b542f9189158a0ba17e842853990071cd130c1476bf0559ecfde4a02348bd300950ad341a29afb5afadbcd15f8b90b0d8fdca831839dad7dfb314aa87542851a0bceededb25c91b81790f7bef2e1a2be04b2d38fea9781b027f285a37789913576adea9ee490ebdd5636aeb002e7c89bac67cd8cb2d041498bb0952afa54aea683e23b5833ed536b5073a8d3ca2787ee9b8c3f9e0704695ed52d05212f61e50e4c5092ca0d97b1f8d79d85041c24489dccf9c03af309e6a564264786a2883ed58f89e67d1ab0ffca493a576d288d8f8392c04d2f28b27497e312d0fda3f84cca876890a86f2922c81839717be18428a9488113216d0828df57e06c9dc4b864bc4569d2a932aa2983b8199cd31d6fe040e4f0e16d1a1df6b8f9011763adf6d03203b8304e033afb0af7e05a7d538e8360f9f6099e2b2935887031d9d62620d1859a4ada30ef7b2b73811f646508984c4beabb878e80b009264f1a58a23aba91291cb9103c259edb6da464c548b5ac4387f6bc1515443148b8b63e7f08b4f852c4ba0f5a7c5166a445a8f60ceb518512bb4c7d911eb492091aa9ae761100c117329ff0d1a617ef71e3e16dde0202f62d3626eec07e7f2ad87770be2e6e4a4ec0be05f0ad3a20ff30ad364b24427716deb5343938802ae6240eb41eae4c7d0b574402a9b8b3f8424d721a0c01a259735d4fb1ee336582d90ecb065353df5cc9f4a574c63e32db4c62a2d68e057e409bfa7452eaa9e83773cafc692fe3e91593c09ea5f141a49740b06fb92746aa28814fe0683407bacbac063adc52623d8620158d75bd0aa0d1f8b6f66f320113e728d7feec1c11647aed726862c93663606a84fec5fd61142c827f53f1519679689a1ba1ccb0d2e49c4deb627aa961740ebf345e0b84a8838c0a6f6682cd56a9e86a8e0d1996df8df90eb8bbf84f79bf93ca7cc8207aab60af6dc46dcf9474060606318d52d5a200ac89c71afc46c13d2f0896b31c7de3d479de7d6ed0e0c932602d52e8d4b1f9195744cac2f0bc974afdffc23eb11d9d6ed7a74a97ce4ca4c09f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
