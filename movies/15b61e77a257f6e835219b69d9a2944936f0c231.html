<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2978fd468727d981099043ddc55659a06fbec01d8defe23b388d6102f7902b23eec09f98a84f71b33d425e198f577e48204a663d9e01b8c08b2bc37d07a2faf9416d97960f01d6d708cbc38df26f676986c5f17d95d676c13071c26bcc8d71d897b43209e9ecec1f11dd8c1d3961a92740f356ed32c1c7ec1ffc90895f578b0dd553dd71e5e6ba164ed556168756536f43e8c3c321d42b8ddf7b790c2129bd32757c210546a77956b0d134a3db4154f01bcc077542bd18c1171561ec4f7fadbdbf8db349a5c10cc42cd7e71ea4bde9e4661b538f95d0821ad98dbc56e06e06ca7c103e6fe1d2b4520c08e7a45993e69f248602afad56bcf1fc050d3c764e91b372070507bf79942b22f5788ac6c568468c8d6866b060872e8550cd834c1e4aba30d3227480b69ae4a787b60c43d45fbcdd9c07b85e7ef4080e24508d4bb3e4813aaf0508d1cc05f28e1dae0146e62515526013126fd4a3b2b5d9a83ff42a74729efd95398c2c4949398a4818d3ef52730f65fdff17c3d5eee64bcf278ed9a8c99655520d0e303b6c4a18fe134b82dc1c4553b802dfc2eaaf7f7b1c0beee3d6c360f48db54b637993fc5979f6aeab75ade2cf46aafa6966624ed8311a675c959693115156e268b5832e09419b336251f1885026b9f506ecf823a2bf7e48080777298bbcc6b58bc8d4cd0ce01d0c7dd2ae4369b706f81bf01c52f8bed5578ef390a17f8d6eb2cffbd4b3115e1f31c2e27a06ec34637e04f838d0ad25e5c9107be60553ef763f7ae7f631a820d26d4e38dcaa561f47dc38a9b64d79f39a15ccabc4ba9e69ac118beb27d636b94b679a959a6591ea293ea139ce3ccca92b508432adf9c270db3469e9172c92d764624cf399e3deefe31fa1062801b359fc2890d34fa7275ad91307025e30fa8590c794c0c9ae82c71bf8d2a5d2123e9d048022ec161c294936d746cc72b3d9547f1eadaf6b9cf649a9bcc16b001cf61feccec7362aa415f60ebb77fc4ff56da0aae43db9d390cb816277bedd77af42054ffb25358e530b1f0b25194d95bbb391cbb60224d7bb20da9e8bf86308ba53353051ccebd0fcc445c1606fc1ec3357d2cba71f7e7fa8beabe6a56e9551d6cd31b9ea9f878ea98bdf73a36e402514fb4415a105bd9c3c9dfaf9666979906a2a4d61f0224e66435aa9a8098a3e8708578b0afb21ae415a9a97f221e9e9656df0ae2dff30316d066c14ad26f1ccccbdfcb4712f524795e61d7dc064d153c38b6c4cb655995f713661e1c04e96e201933e82a2495c871792b90d5be7fb2de84a600b448ff7655f16f40473a61cd86f71ce686174ff618eb627f538a1725e5ca2f36211749b21a8bc3c8a93fa6e504acbc25fa4aa150d0956d90cdac8d6587924524fcdda7256e9624e4dc7fceb2b584b92170ace06be5ffd6fc6d54366103ad0744f5d9c88a96023049eb092ab97759d2bf010da2a0aef0fde21ef6d48c8bc0fae6bb3a37f8dd842406db9b743439e377489ed2f403b31fd49d09320f2b20a0493449da3be78e110f437d6cb6ea2deb339d3116276ef7ad31651c721be8882627bcc28e7da585e9163928b9b77aed8248f31799fa918c3368ae22d8e1f2def96f467c5bfdb8513888b472e7d9fcb217bb5a3f81983cb5e0cc7f61ac6c988792745ae7447c50fbb2aed99c3f439f69cd1b855399acb586627b29135bb9352837e54f95475687486d49f3bb2bbf3affacb78c50c82ee2ec3f8b0bf9938773a3bee719cf08ef883da721bbf9229f54eec1126f60c2b096b2cc31d9288e01b71dd47b428460fb1dfe19951526dd5bfdfb89689701b7e1d8f19bf05e5ce292372260d7ea3970f6a016d22e0d1b1e22f47aef35ccfa1f1c596544234a72b6f79a16f6493214e28ed825d88846d5ba33367ac7a9a416ad8a7e921e4fbaca983a8285682124f8042c8d5076d92cf9da5503840197431d7772201c514b36774e8a32066b7069b506e501bc08d9d9ad75937f3ce8f60580323c43eab2a6ecff391359e5632da31c7e1b1312192b059cacf9293e1819f4dd0aa95e884de0f439cf20806d6e2070f51727158fc97665712b650b2b4391b9c591ad36b6dba85a437b8129cd876f9b1874c6777c8a77a2292dfd498fad10440a7504178bfd63b7fcc0f1312e38710cdc4deba64bc3d4f3d243d5193acfc71886e7f081bf143f089d177b5119bffe894c47a78d0b1298659c89abe5e1fcd15791d0bd610d943d38d453feae74e76d1a34f2bfeac0988284b31c221916dd9549a0532b27ac5cda9e6171e022deed1d40377456c1cbb3aa19cf26b6b7ba4f54bd1f8e646b048995cb529bb00144f09681676f9bd630d3a5b2fa97e742c434a00690058bc727d4b8a349325ea8b42a56113baa70065247388bc7fdf05122fc06967cc9c0ca81ec99c2796368efaeb80b8cce51c6276566accfb4263d2a8117321dedbdcc5c96db557eada326ec5bda5b99500f2ad1470023d2f2d6422cb27d085a528119968c3dd13dec2233c29f4b037726bcd450ec9be6872785a3e23b8f8d17ff13c2ab6712dfc66bf526c4d6efea071adfb27584a3c1dcd1534c86785bf428237af767bb3c83d3d1c4d5d13d8e69503e6b0bee50ef0769f11fb6dbc0468e7737fca07f8b81126ffc317f7e059c708c5f013bea66191941a7df1b5fc07910d87fc44691b48a5257df33112197e1a3a5219b3541d7f93048574b609e8576f4cdadc965bc890409ba67a92b4449b2b33ac7d7eebec762b3b493c312b8cbec701609988ad9575ee4c7040eab484f50a1cf5aaf52f08e993c170d9f449f09c53cd58032a9b78cd694d18d0353269efb244874357ffd2a4759695370818b09563782c033b377d9d18571194196b63facea1023cd027d33090b7b121f75708867a83c3b370ab9fe6781a9298e27668ea0c02bbbce162e2e3e1c0fa5efcf16e1c0f8c6e61dfac4a2b4e044b207b97953bf98a110f2698cac88ce2899da7a1d8e6de22587f23fa1e41b2e08e798b859e4bf2cb61d1db893fb45ef72d0fd0ada4c69562d69ce1db4781286e54c860db58b295e0fb215aa3681dfb657544109bfa91205591e7919b3970ac61471d67d9746307abfcdd1c01e80eb1867cacf9cdb97063638c7747709014b8784b12f7a75e2fa92a01b6d7e66a15ebf3d8800812e7ec3dc89cf299ba4ff3f8d0b514dfa1bdf21aac31b329660e08d0f84d9d6e11f409905b7d8385d7fafe786805e1b497ce65bdc7c558db82654aaddd70e7cf191519e2be5b5b23903c735d3fe04248c53ee53bfec123287740a804455090974c19f339998440de5de1625bfccb21bc516c0492cfdff80f493b1f55c9d0b896a59e37956e7fc24507df9878c6ae2a7a0aeca18d999d7e68fa0cd9dce7d06a9868c76122820fb53db8993f0ac95169d231fc2e88c6ee9262be4f198309e354d81da3b8c092e29eb91ebf59ea983e3bcb4506b3fec5b8200e5c00444fc148a50142178a140862f9914d2060c91aa2589beef74a25006de6973fc9718fb3ba6bdcdb3db1e3296d8a90a5aed501d9c1c3c40301bfba5df531e11c55d8066d3f2b8c5ce75526d3017696bdc7cdc6c01170bb233e7c816a76279b6ee2ab4600fb59b7c9975182117eaa4c68bec447296aeb9aeb7a61f77260e404361d2f71bdbee3f599ab6e5e1e7cf966997ca8d36ad5fdb09f11fc1f3b65ffa468ca042fbbad5f5b7e73e3d2d3bf7100377a1c7d3e020a8bc2a0c4d4e0e4f4d12442d5f90800ab450c5c40705901eafa8563366df27008708cb52f4337f6df014d613308d6057888ee5d554bf1b0e67fc5aff938ae027f83ab4c4a4c1f8c9551e48c8bca9fdce4b37c522f5c76b651e083bf951884da48ad0adf2d32201c7598f740ff31f5f00cd75df3f0e45aec56c88057ade9cece869c957206b8112f8299f495722ce4a0acd7e3ed86e01acce45e63e58299fdf77da95d6f90934f21595b727e1b92d9e0a989c71d91370c6c05daaeab35027487005c91a9775aa83956affccf3df26060f691d64efb3b8412f467adf73db370652aeb6c48fe1539b983fb6b398e8af5222af06c35cb1d347e8f2f4b868f63f9be241a33da8fe291c8afa892c1a3b6879b1ec374a20594e016a16978b94ae9f6983b9200ebf13107619fb22f40821e25a4e78ba91ff01cb35fb5b5f5fc85bda2c0826747eb700817bd9f72c8c1d2222be6a23f403ad0c6618de19ba572f63d46ecf16e0d0d7c6fecd821019dd6eb2bceb23da48ca0e5fdc15a3285e51e887ba41dd2eba5fd14fa7b154c3615697c90ee3b53bac85e8d562285bef1fcc06a613b1b8105ed09e3e2c3ef548c05572d4905e6d5bef6a27ec988b76cbfdb0028198c393e095ef83f184a37f49d8ee04d407800b2757d8d9fa6b9c4dc70fed0bfb6960e8080c9256e45d45818652ff696d5f7db2ca686a9258a700a370823d229a01aa773518fe88fe53289fb2eaad45dce515f655142d0cac0fdbda58f7a81bf3605277be0b8bf0769432e432b3a090d8704f34585632317bab00643a30d49229874b1b522472ca4a2a3c3ff15fbcbd55eee70ded916bd12f3b3f2b1cf2d6d5ba3572f3ef8d580bfee8fc8ad6dc3ced362d75f98adecdb2da4b016f921a381ba04eea9e840ff664248086f828c2939459b8d0869de4fdca9252c38613bec243204bbc5d2fb5405001f596114aa1a268b3df94bd8ddc581ff927c4dc26b0e41498b70ec0f47907c246c541fbe109f075895c2754e33f229b54d1bafccf051b590f6a8bec6cec0bedc80509601ce1b514e549d481afd4655b1210a9710d6632d65482c945b37d81833380347142a35cb9e30090a9fa76894f949ef5c2834669f50c9bc111c9fad3fc2699cf2b0773181033ed81ee281a948c0ee8c24a21637903b6c01d43442b60d9b920a568d4e28404a31794c001c91a1aa92da0429c8aaf8e67ceec130ab0027a79f6e1c3fa07811cafb1627ad70854163e523b4786352954fa2ccb1de185f4ecefb54110cd919a964bd4fe6f9a17b4effec0471573e395212211b5329511402c7d961af32517c70a0fb06540082be3b7f2e9354b6df3d9ab29c0f4fb811499803df15a5bb9f4062613d42410ead1cf4c6feaba6101eb969c0d125e73a2a17ede7543a02b07a4a6402ad8dc6ad22e85fa2e8a4b0973d2104b53922474342d90ce6cdad847d76bf4db872b3c2c960a24713d50e09d9a89c0020755c0bd6f1ee805ae159c00e66ed3ea12a95cb67c983b4f016d4019481c8febd299e07211db9afe4d894c4e165da3301fad0718efd6ebd2c6ae18ebcad46c8932967235dc563990fcdd58896a75c566a383bd539d1dbcc75d0eefb320a70d6be8fdbb6bc9a84369942cbaaad0e5632153133d79514ea31b05dc6b10ad71ec7db05907c6a39882f12d3ecefc5f76a578044bcc7213e0d4e378b6c70064f8520ca84aa23e46da7360e93a373bcb34ac788693721dc46f89c2b2fb49bd5d3d6dc2fb6f15ed3c61141e3bdaee88c6f21afdd89d5769e2539aa15402eaa49fd2e2d05125e42ca1c3a9fd791b2dd2be3164619f62803d6df1a978b0338adf1c59d01dbbbf682edcb3d82c3e18a738db4e5e5f5e724c7ca35cf0c7a66ba03f81ba1cfa5b56a9163feb12ac512a0af4b08b27db71e14423f613722c441712c80c3d4909dfa3e4df058229a99bd3862c7c6b49521617e33c5ee07e53f189bef5f488e9635c47da7138d035af35502e867dbe0052ffdb819793bc8247793f73d6e059b6e90483a7ae7bdc409d66bb0ef43f0efbccd4839e6ec2595d3986d73f7d50492796198f33a6901427d0331bc9bcb522d2237cfd127d2b1bc52fcd41ab654061790d45beab3cab4f333ed8db348241955d151a23d6b415ed030a88019f7379597a86c9d0c099a139ff3aaefd0d2a7e39127770a861fbd2d5b70d1429d7658de306d6b6688c936c5bf4b13099e7a855308f59bb1e5a880b83a336da49309a3f190524974444a4eb49d5e9fa68f1f23ed154b5931b6414e680f1aa1179800d90ddd6ecafd2742ee35fad2c6ce8183a99efcec883fdd27f86187e0937103392639d3d6d09afb04d1268b86bf4c9d1957897fbdefb74852aaac50a6eff45e3ad45c312a308dae36e5fa3fa233917de9bb9223f9bdbeddc32e51b4ce5e9906caba18ead568f86418fc5d25b42336e422cddd27e6d204ada0b7e34bda7fddeb84f09293ad8be6db92f09ed0d9c296abb34027f84e29baf104c5041bad6216b0ac81c683eaa4149e03c79b92027b35f0d20102308b89453ec2fc5e5af11ea7b22c761a8e5156b631d122101e7820ddaee432ee86d9afe7fa5f39615570baf7131f36e7d7162b0ab54cc0814f37f78c520239825f850bf5c65add93e3457453aa92a7f83054b6ec01e0c90cb20cd3570684c60990ba980c98376394f0fb17151872015020d46b257e17a3b4d2becf6e055d35f3f4a9a1709fa5fed53b650c22ab8b88b0859d614cde0cff2a0c0b08b9d94a1a4f47fa92bcdc72d65ec59d844f1558cc0aada740915448a7fe51a1e028e748aa90019b969221d4e1cce3aa78bd006bad66c353b07aa79ce3f6dc8cf1ab1be7417a3683fc49371187377680462e707dce6aa2be9d6ebb816da60930ed6487c3c5ae1188724a79b033281e4b7cc8211d8e0ff254374455adbf6df75fab14bd6c7f40408c6a2dac12d12385f4be376295359343cd7285f319ce679e72452a03dac484078a73fa437dbef5abd013f59cb43185a68ea7804fbdecb53338f734734547ce1a3dd0878a69c7fa7030409a7564e6b683a82d56134d6197cd1d24cc35f71a144ebe62b1893faf7edad115ff76653e8b8149bf10c001363b75e36f3428866439a97f439644beb152b18a204bd7f98bf65afcefb46e91581cbbdef00426021b819d8616fa7c5826ca172930719661d378a0c2b912eb10bdfa27aea0ceba4ec8ec3146c09860e4d59e0133284f1ccb8db2121bb2aaf5ebe2a7c4f0815582b75d567f206e08c0ac77cb248cb43455ec4b2782f8777b708472b6405bc729f5fca8c49cec26ceb680dda7704a44a09a87ca7eeca7a1c6066fec1080f8c9206cdf47bc5634ea1fc507884c878de98ea95c56a58f440060261b95fdc0ced3dcf822a7e7dcf009a297cf83e93ead0dd0cc26133397ec4825913e8625a8fd652fd5d562ca02e5e19dea4abf074a2d11d6764717f364524ddc2f8ab9f7046d91e3c8279c44a0688b815c8a257732d48ecc87d620fae47c263116e8f8f9db5e7b23f1ba71b62545e0bb46f2abbaba78496149b149ee98f6b857d6869959c7bf43377b1c3a74ef8948680ab52c1e001ebe211ec8d9fdd45e62076071aa4b3afd968f501e5c07a3d11e788f121a4550f74e6dafd79710d8e5518f79bdc1700a51f24284cc30ac3abb4f3ca574321d6aa613bdc37eab4e246ccf47f65b97ab55bfad11a28bac427d245c7ce91e7ef1b2df0fb2d728d804834a6d4cf1b99a749e90d50199c1b7dba2d7086577bcca274f76f1a34d05e93e3ad35404370add2dbc0f0f30784a23752e0049557f21f119207fd6ef6838fcf19dd690eb316eb7e2575904efacd66fcccd38e4552bf059f1c9e19986ace3cf28cdc22c0b8882a02c96c2a6af27ab903f91ff7816a0488c5fd16cc2808ed98ab6c98373e4c155900b497aad839b6a948f54075f10f4dbc1bf7fc042dc3a7ca2f50fd2878c4b14aa41f57a8955de3d33d4a9ac2566547b2f48f62b519ad1090067987db871ba11c87945f53cecad07cc87309812cbf3386efaef2142197f4df4f115d280f190ee21b0c6aff333517a2de93534328e54e7e14461773e086c97fba9ad27f62903933e19d483f6b30a37677041fcc35ecdd0aaa04772783fc5dfb0a46a8e4c564dc7aaac67e2966ddb97cc50297214cd1a0e6f676b570f0b5b2a1ea186660997d65f763573c2bc634e5117dcf46c5c60877e245e199e0405e79bd91ab57ae9d39aa2d4ff79e8bfaa7fe464019ac53b974594a17458f83ad17f5980db115718dc5816ce928f11a3eea53c239b07bc0ff2c70b67760652555c99a5bde149f5fa7ff6bf8a22147babf65c92ef5b5c9c2fe526a1f878ec713566ef5c3e97ccd722e64547fde4004f75e5ec2f99e59ae30482907e38fbfa6a6c4d7947491c50c0ccb295942347dfe7fb0fa731ba34abd9f1c0870d542c75421db07672094b7a3670503c44f5cb620887562e39f60f81778df1864a0282b6f1fd213ffe0bcd100a85bbe84c3107a8457577bc4f04827bb05bd7e5b3a4ecf72eb04539d6ceb95ef75f88ee0a1a1f0ba19fd3416d6fb568dec2a0de0d4af8ef51f91bd61116e70625b4c2441b601806006dc4a1907c7123bc82c33fe4c57fce7237a3a61d3dc74da51e507a9acf780335a794d8ab9c7e099ed97c7e0aa7c96bb73cc0d5c82e1068ba858875986f6e01ce1d48b8b4f0a18db171119abcadcafc7b0565fbf82563ae69016f391c95e0656487e52e485f471f26875ed312ae6e8a0bec77deb5c9f0e5b237204ada42e40ff6cb0db64ab17ce918d82b6fd47fb6180fdb41ecf50639957c835cb6ac14a902b8c60efdf3bb38d3f24f77c9dece66aa9e89605444fa755f65bdf13f85bb6a53a946230f2299b11f592ee0bd38c2864f772262b73ce203f6de0b061936e571b4dda9f95ef24c52928285b0c5c3f146850e54adc0f0f9e8b5ded92cbbe154950b474c2b97bb41f55b62cb3b3515851a0f2ab470cb252871b8c66aedf97a5c7ef5ef1c57c6e58d7ca74477dddc766825e6c9ef748c82ea1a61359c7118ed8b637a6c728a3e2fc669c1e19177787a8b31c7f59e72f5771e7d8aa772c7b09ac7624c9b3be8d9fda2ec896024c178f83cdd1ddf95243d3aa510bb0a069663b73a8e02c8cf359d2a5f334a3f1ef7f59b4a081c1a8c31d228bc562664dd72a6eb3365908e6b80b987099d85e01dd0372bb1233b852a5b0cd59131b2a59eb0cf8ffab6a786b80946a8ed1789fd32e17b4a2de16272c85fe13b6742d442c3a916b69bb6763ba038abcc355bc4045dc76521ac9902b66ba7400ad437b6f52ad549dad61c1fcf8f2e2460c153b420ffc15048066adb4fe4912a8b0bba63fa1e69d9799f7371766653557dae7fb2fe73c54306a46585599510f5f3078d072616a46d2b94fea465e9d29b88363876d89fdbffd7f39033e4625be1284a64517c91742e8ee33c84f07e9914d3a9fd5d136ce5928156c66ee7c908819d0183327850e890a1b45b7a2182774a81816b5ed6c1e3d7367b8ee6c49c9e90b2664944432440d04d37194b4c4091fbaa0aa75f1b73067f800b59e19b0ea6abbea118e513175a87423d00c687e831c34b9c02c5f326035506f842b55d507c8b54651863ecbbc841771f1f7e62896467bbd0346f77a4e9461334f002181a0fb9624e1b3cf0bbd1ce3499b97d91aab3e82b6a0412946cc01474902f739cfeb8d28e2ca78b4f0683d927d0490c93a4911c7197645aa9304a105ed4d12ec0bb2e8c28f28a6d989f93cfad590e24ccbbf985bd916d0cdf578b56a69ec09b7c16129ee37a7739964ef46268b722e28a426b7f92b487a5121322b3c82c9ea210995c4c25d4ede2af4199e6a6cb137d315389895affe682180d7c2f5a0acbaccd6faeff1270a18d2c95bb7ad7f42f40514f1c9d0119bd9ef8e2595d7c6d4cb56091ee42924d53c8c300c26e3237d02ee7fbb0236b64656893bab23ce1deabacf924e7e706a2cb98f52af8fc6b1f04069ef7974e438cee770f288eff70d2bcdaf8856b6c55a7f9401ad880872d0ed8cdd6eab5c3cae6b8e2a14a416f2f8ca0ac774ec0d094607ba1f999fc67c0d377d2cbadd91660f859caee71d2f1c6c4751a1e3e6ce0a369612b0908a0b7758c5b7164a3d8afbe1f310a6c79049931c0a053e9c7394e3140f93b2f25987f751036f332943b8f15e3c3f338c1c38e23f9a348106388d309587b3b2fa0a56b5537f4c8acc2e7ace6ced4782f5de6f2087e974badd5a6a6b7e47549d716211bd97766f8ff063dd06cdc784eeee374da2ce02e4c727f4214885eadeb3541604ceeca6bdbe59c1dc0690e69f746f7e5cb1eb6db066ea5d120beb5bddfcbfb98e6360e1eec8cc433e29962fd6861f5288620ea57aa5c4c8560377f6a4520420318d2c905e9a0bdf909c1543b16599186ba9cf3e1f31b864389399d76d0aa4eaf0e6767048daa6cb6959b59e3a4ab771487df7f72487a1eab0c7f5d2a0f871abc97f562e85e79f1aa952903032320035c835ca4b070dffcd5bf69a885b97aab4c7c0cc3e415b3b704165db9d8d9f47addb4b1685da22d1280a642a05f2c0b8e1c032345050e21b7b9ad8cc2e38257cf47b2107fe25ab685af7866005c81fd8529ed94ffece0374029979157d23d6bd76febfee47393e9c391b0efe2aef4304d9563dfb96a4f8fe175b7161fdbc732eab0e2c1ece7dd6874301877dce1da200bf006592635035170c86c098106bca4f17ce7738ddac03626dfa185a13c00ea950fe188f887d2175cc873556c76fd8b5a89cba11d27cb3f6214f7261bb8aebe1a995f2ae91b3f650834046de90b23dcbdb0eb5cdecac5b73ad7115e82c9dae82e4e99bb4240d5e97e0668e895d1ba0747b2c7f4ef054e83ef97a2562aa8d719818a02d38fc6860232fab90f3c02a1361db100ff9ba88c039c53f7c526865e027a546f2e631a556fdb580731912843dc2f1da02b1cf707efaaa6cdb044be42977807ef0398b677195262984820831dbef661cfc8da19db9f5e5a763264c0c472bbf353ac4614426c0ac60955619c9cb4b8e20c636985087f1da4033b255f948be736124325479be8d97f019ea83e099a2961e3134112cfc7f2d217f1811362d43c16a528731441578e8f2d46b6213484c0920d2ceecf2d433c0934bf8a4510e6a5a461de3e27223e49ea0434ad76cce56a18a6408e0607928e08260725faaa7d9a48dd18e7aa58697a93401e3c8cc107089c86a8a705298bc5a0a99299f5a887872b9e813559c6a7e4aeca4123ba787455eb3b30f6b87b5ad5af6bff6bfa8e93aa7ecb01d754265fefa3c5bbcf680df63952333e38f96c6a0460eb959411c4589c1da25c3f4091c27d8db24da28fc64e411d5d8320648666558bb7952136f613f8e60e53a11a5eb5d03e1298c7f70da5e2f574b6ead1784e528fe3b12a99dfa8aad2ebaabfc09299fc9e3bcae9a755c5f3b0a4efec913f367f81ef23c72cfef7834d3a17104603d2523a759043ed12a5dcfa9708753f5275385831c80867285bcee494491e93a1ab8d613e59f202fc1cee99fe47aeca3f6326d3000c4b93a241c19096906de3cd67232505c6d0fb5db89281db973d1a0303d14a2f1475a7a6f78415314fa052863d17c4e8c6139861151ec11130021834188f3fb750bfcee992a81e7031eeeca097381068d7e2e91432dd4ea17d11e9ddef3b5a6f4b05829f5adf1049b51b0db9e387f06716d9b3fcf6cc7c11cb47ab411d0cab75aab5cdf067e3a3370d80dfea5fa68c1e150301f91c9a9c2dd6f251142d6dc6b2aaba5101e6007b1881caa470c0c40051f41be7598a226f97da758d34c41f85489b279df55c29c737f7d1e09a8e9b14f4d6dd6933a93d2c669003e74e25648c6e015e892129b3aab49fb118731735eaeebef3d509f7da432c1f15362b8384d76c29936180c867382980ceea179716370488f25fa4e1503a7eadcfe3940442f636df2d97a17350e37149b705e904037d4df5b581b2805fc5853215f4dda79131951199d38e2a0249e83cdb2f6a802777914b1a4da3dee008e4b649bc730bf85fa2fa25a2c8c1253d08882bb6d8b1b1ff6b97c019f0274c6ef6d22b9eb71567582bc728be412a83bab7b11871c4f33a8176401f6f4776c7832fa57fe209cae31ece45254f1e7fede2b87dd5311825ec98b6b7e80fbd879dfe30299a29f3466e9435600262f9433d64de9218b146d426122035c3b6b50e8c05a8c493f545933e7a929b6d32b0bc0f7feb803b8d9a0a1ce371ba02d98aae1fb03bbc4d1a55a377fb307a5b99d3822dd4d90ea4ac01801373048bc1efb3c00b984c6723fedd180a2dcddddbcc98a32ff0e12efdc73dcda8e85ca9835d753ab236427f346d3f327f3ebe07f74b2128a16a902d44e5597b729808b37d4ef29069d5b8b1cca7e529c26fa85c1940e585bd2727b94bcde9f080758f7045d6bc695b0aad1c584ae9242f8abe9f4b3aabb343e1d90d900c1c294af754d186b10b2bbe842c2968f5ae22f8d5bc6d169c6a26588dc8c41562842b014e292556ee5d1bce2313f9a91523535ae31568500ebfe75c477974978a7fd53327ee4965d5a33d686fe14fc09074fb44c75447dc33bd515e74784a15b38294229b55ce7353a2bb56dcb4419238c70ce6f4f0f94e998482db83abde2870318c2b2697153854d68f2e977807fe6149a8d5dfce35732f82fe44c9179034082a16b859349b16f53d9f7d15a6fda4957464594224296a10988e98e3d21eef162aeb987f458337d7e979c5d875d3834d0c956ecc6008be19128ab17f02edc7ae21ac02f0d11116a99f18cc9c5a290939a959fc81b015598cd5618fbec1e08b193e62ef3a0bea68284a87969d34e693dc287341156709e74e49dcb5a0f3234213ff2e91253e8c495bd86fc94ff1d6d9552c209179beabb371f27ad90f6faf9b4e4364033de3fdc699364a60050099823ab56fa7e2745c40f5f86e3305259946cdbe8ca7ae8221a1d4f11e4ee2a7a0e3832d9f6a93abe94d44c0436c72c4ab5727515086d0e1588e37864dc888f0eeef8e5800cddb4d67974d3c8fcf023663618eff66341b9025d030b0ffcca93a5f9fa6a4342303ed235901f1e152a4c07bc4831f72d721535b6ae52551791227be10b104004e125cbc993f90ee482e3b7816bf5bb6c5ca14a910c680b7fe2c6fbf1cdfe9454c42f9434727cc2b1f5a5367a2f87d89a67b1634a1f686b08d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
