<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bcd3cf0bd45b83650fc62e90f66ab4757790ba1c421eeece7dd9e1aef4a43c23d2b7681d3350b945cc5f6541d6022f380d3ac07b4ceb47ea7241a468e615c227ffc25b932689403cba7c762ccc98b46f6e8f36cb57728324fd14e2e664a6d1a192f09916f44186165b59c7b72833e2dbcb473380f94e915e597fe753790ca8433791add3878db5d07c8f3b44b5e674ed6a8e7a1adad4257c083ac0fcb4b72c5eb02322015c38bb90b91ffc3c81c56f03da507bab078f79b41e8ec3ae60db710af6139ae08a59c15b15a2f6a7492c4ea9085f6833f429eaf6838cce334f9e5fa366bf2d346878c0264af770d5d743f408f6a9694e45fc30174b97e480a43c817576303735f646c3be09c81f00f230c827924294d87fddc1201b8fd00ccd3c00c643689bdb31173b17fda88c52877c81d76c0fb77ffb3854fadf4accc7d1c5cc28d31369a37d9b69f9691c6cd2ede798d1c030820f1f92f46b1e5a53b5bc16d0fb677567217b9544053d2c4628a1de20d90fd945e245b422f206120a14129c98eb1a8e699ef9101ca2e6d2f9372f6c8f8396328a2762568620a33ec38d6dcb89690f85e5a3cda7f26bdd2da615b575ab9abaab8226e5497e434289a3cdff802dc8d6edeab435697b91701b63b0f1d22395e75231f54ee0a32f0e86d4cfd0f4812791ad03c79f59d51d11a2f8c00034474b5d1cb9fb366e9ff42abc53e4cc6c030398ffddeca7b42a69dd130e2e8a463f1bea305ec6f68a047ab7632b73026997b32390f90cf795c594f71543697a30ad9e993e62549cbd30c0871287e8e005c1a4a2d6409ca0669beb03bb2f6790872e584d7cbc7875073c086c7d3c4567116653bcf6bc533ba0f1cb004d1814aedcb4d79fad2b456896ff9aaffb45684982f24107d7a478687d448f954c840dd9135118bea97f21ec3e84c8726f47f800cdf24fa48df67233909c5b915d77d758c9e00c196a016e27ff215aafc6dc0f40d92c95cb16749d3d493e59a612b812015caef682466a425ee9ec1a4fadfa6fb8f090ead85110d47007bc93b6c281634244581c5b48dde8e3d6203965b4d15c7620462bd336ba97d325af0a0d540eae1adfb640f35cf4135f19399e6bd0dc1bfef1e02a4f8d334cb4c5427c8c7c0713fe35ab89c60e5f17c1390aea08ecefccb7772eb7a1f44df6ac75645fa7fd88f6318507211367151db599124f435df65101891cc0a8f54e0fa3738a465df9d9233d6cb3fe6c20fdcee2fe2c0d8ed567c1bb33f2a9c73d20151d71a28c9d432cdd85496cfef4ff52d07f2e0e4a7402b37838464b5d1dff340febfb2119076aac54ad2773cbacb039d9224b159d2f9ba70e94a24a74f5a6a7dae11a44f9cbc63e8d7bd0373c3311edde8385c24c23e63e1af1378b7ca3b03a8167e92d9a75dc771e9918486a3dc74fec0439067c019ce0a71f4a71e69d313cee00010d6302d2e5287efceae9ccfb011e7a0878c0de931a01f1071f58d8fd568fce92459b5cc394fb060ae1c7da196f13c247ed4a7bf7298e7aa7c9f448f43ac879ae3f1c68d32208d80bcec964d51cab034cf06fc75752f0b8651fb5abf5668a1b4f9efb077a233aec3253edad00b9da37a81f31feff8b04cb712945182815ea4ae708cb36cfc22b3f7e36c75f391fc1a5dec66f15289577e8ff8b5df46412b24907e708f22ecd9f0d3f59ce20e5a5ed80c764d3b2b7bb6160363b150a359c36a1961b237af11a34eb7cb8537cb237710677394be7b28854f2e7bae2939a425219ffb6fa2251d9849ed05c85677496625ffaff757605eaeb96e4ae644ead7282f7fdcc2405454fa85c787f4e70cc7c60f923a9dad942d9744e7603ffb83a63238b58a27eb8f3769b0b2ce56b4d9971c8b0456c80edd33f921861ec31633ba5bd27e8747c6320513fd0f684eac41436a3ba49daf70656314fa44cf33874de9c13bca30a60c65c2cd7fec06d5dd80a085f2349aa84a76267cd83ddb5e7dec53d57ac2775b4b8725318fd2ee2fc5593fbc2511918a8b41a75ddb0f30e4730e2f28f92bcb3ce1f9710f4f3d61c443a16f6bef8dbda8d0277158dca0a680f9ee6d4371c856c61f3db19523f11b18983c3d8cba80ec4a3bc794be18aef42eb396437cf456a96144e8cbe97d4f087183fd67c2894e54394a0485432d3c35952b918d64907e6b2b71b97b90ff36c14753c471fbd746858c1eab2611c27faccd4cf0c74a730a583cc131a5c6b2cd49276e02929da0935f8627853689c405041d03fb4730d552fbb0c45e29659cbdcf4d0a7eec14173db5a4afb8de0eda541b0db17822c7257bccd698c8fefd1e4b0bfc218fd98233bb08c348d51f9bd1680a612d391d7f422b0379758fed3826c4bd461dc945533e303a111a4478010ab379c05e984a721368fd3191c501711e35d9dd583701a1a68318974ee5088aaa448715e4a46cc2b2b7da3ad69a2b39d8c9153d9a84cf1e42d388a8c2eee4652a068b51187956d5e41156fda55ffa6288a0032ec8f95f2291ef0e6ea0b7d4b3bf66ea160175fbf04f56bad8c321933e2501cb761b767d770687fa82b080f2f9da69a3edd44d7385e999c3a3cc27eba7b6aeaa67745a5c2bd86a7e561bb7f80183375a33af71a16118a1b377ad668ae9f6c3a4246bba3f5d4d570d3babfc3b5830ec7c90cb481fb1a10cdb4ddaa98c0a77931c57aaf7a484c503ffcee73135066ba677272f6411693bd0d5dbc3f82d7030b7f30f242a2850a4779d55fa9d93e0b886599b06bef8ecec9dee78d11e792f38b9a2629bd6d91417033d18f5b2d9ead18f91f03111ebf38a9271c086ee9841203039a85ad8259d2d64bd317e24a68c59d8a3c80871684a6875f92b896bdd5ce402f90f96149ffae68b2f5237c47232f3f3ddea9971467f22398a8934d76a749988c68df7999832868f227eab075551e2bdb5e7188c67cf4b275d18243394dd6e1e087dc476f2c47215fd5c12b8354598cbf2bd87046fc43886d685aa082103723b7c179d515387f271e8a3d2d3ca4800ebaf1e92c6b09f27c015c01ae4d0424051011641108a88a390e313726dc76cbffd6f2bf9239cdd7ccae1a792251e637512685d2846fdb81177b7558c4646f3d5ff8a93c309ed60d39b3df9f5398474c5dfb31a8c206f9e90e16fcda7dc7cb4e5ad332ae4c01a9a1fdc970137e25d870d2970043315ec9114baac3bdb187a0a1fa99633e74ddd769fef212ed193188e8d421036e11b0b1d844c9339b858f34f666538359e13d2c4642862e2635222f1100cad38763cf206851036e19e8be2310cc887875e6513c84eb919cb57e0530449052ba386d1a106df29c740ee0ec267785108a1d1f2720b600c1244cd0bc52f73855796c9e8fbbe564d1535c04a00eeeb47328709406aa2d8c03155f90f449d07ad1fd13a0503a11327ba7bb657e086c47b7bd074c74c99569bc73b8204bf91f41c5fcfd5b2ca8854fa89ff931f1a62d6687b9453877e990dc56e0c6c6856fabd89cb9d352e8a54f5b16d86d6b848cecd9301a99b9f92d1e6fa5a96d08fd25f6ba0b2847c31e72af0dbc09651c315cc46adcd62c41cfd316d062515e88ab37b45760546c787741a9315c4a09945154f47902edd8c0127026b1c2b573b202a33f8976d24d02fb0aa6b0315e25f3be07d2ba45590b89b2eba5823334b363dc643543486a03191b5d5b29f8561742eea5ac437c6b9c6fdb4e23b9e6507cd7558b2f70572eb08c789006626c3ce0a63e1ada3a13414fbdad990ca3ecb8b6aa2560f3cb9eeff8434fade40f38c319b588dc030292f793735dbb6503518b77cf08a95c1c2bddcfc78a5020b26b899455ddc2fa592f75d4777d92418bd197d37204570f4b02176ad892b8993263566428c768617c84b546a2619205fd5e6df1d1278a5abd6df4b7a8ced9eed085d8ad7cd262f9a57bb726b8e6c3ef446d44d34102fba4eaabdd43812a5f0c31d9a26e8592e62049dcf9a9fec3d3d30de65aa76a1bf6c5b0812c913c882bb562838c9d573a02bf9eb4e7a2f7b63ef42126d5bca6e61a41a0826f7656a9739f88d76e0ea348bba7647411feb2bd48950bff56e9736eb30ddd591d187de316f2f8e36f9771f3bcbd723ac622f183e3ef3e8b172dfe938f88b9c9da8872c99a62b8a15ccf6c4eacc67ed2505689eaca7ba2db05b389effa04381c9eac16d6c8d0542e39e47248364e9022b37ee0ca81928560ccade5c9300220d174ee75687cf716248c0256934011fff498d0fead145cae3e1badcaf999d1c84c90322beefb0b75eed6093ec1c2bca41e1c41a57a1f1f20a76d279e9d5b808d0c48d9361bcf5f058eafaab228591b8d937ee336a2ad531b97576a7280d47431b812aab136fe50fab52f4e863c627fcaefacadba06f5882515268f3cc386ab5db1638de1e9d82dcdcb91ca44213bf73839353e50ca7c2ecd1ba8b024ffb7f42f7b557e2e504b8dd88ac04ea27fe155f78874c3cf5160f63568ac8764e5bca7664418878f74d1ceb71fee338693fdaac3b260cf17abbfb22fa73ebe7d0631fb7016ecc15c91d31c640277a003690b86a1db5c78f089b8098e757ae801755a8b5f5ab618959473fb0b191b703f7d2fc5c495ee7e3870375c60124c72ccc8394df41d96dcef0a9188850823fce1a2e16c4ad14a3c6bfc6e48843316fef0392c26985e26813d82579ecf6dd1583adf5bf370f0229ad3d197e838603a26166373998b55c001acdbe4a5d5d57f62da416b84e67a441cb72f9818e003d3bb35fb3582db67177b690d79964f4ff23e158a1ae94a8ba2689ec3fbe049580c9b79089ef78970d1648988d19d2f6550407588b7782b1860f2873638c5d58706411fa1e0eab25d5819ce3248c72818d988539a968ab1b05702db4424400ac09e39cb49b0feb790901ce9fb66b995c5af5459dd234c60c4079754078e62cbf81f8f1030daab63f90002adfa9d9513f8a8b73bbe3c99bb1db11cca266c0fadcd56ecb1f8d9143823bc091b759f5b7d23f425b90ec659fc70dce4e57177679eb64fb07f22e746822b92ab7786ef4f618649da204f40b3fcb1c16a5f5ae935c19a0cbde93b1a47e537b4b8a01f83948cbcdfbeab17575d9ab71e4709f91d367f831abb0502fd53d6386f34c15bf22ba6263e4c553918d98b14bf351d02ae5e7365fa9d717c22f822268d05a85857be56f6afbad27cd96c63a02f200502a1a6b4659de04acec09aac3d460aeddb542da6e537a778e92d89b6581931fdb030912fab2e425a37fcd582a5d98fbe2e2deac4819e1efbbfd89a2ff1a60acb45d760766801bcef58a0d527b58e8646bada86305bbc6b38c9d2df05fb832774193e5ae2eb6f72b743004c217041a464ae8fcc0875f57cc076ddba6925adf5aee13cc25cdeed42e3bf6d86d41083ca04627a6d0b7d00df2d2064555ecbaf7000d4fceae34c3e87e8e78f3370cead8b0a0ffef861aa0cb690cbe6c74113d2e96bd423d97e1f3d55836c03cb857ee41a4df5802e3f98807b0108d87d937fccb100208167e8ebaed8f979f1c2412799f12202b53ee988dba093fbcbc00e06ac5c33c80148b2dae0674725c27d75e5d7eea17161cea35acfbad87f21abf114cbb92e71fe461ab39e0f2d2a1ae6f7777b5d15d87c4a3779632f0677d868f0ea85fd35f962896c02b32959c07d0d59bf74d2eec1f6e01b6d6ef51766fdbb7ca05efb1f854ccf595afd280f27f26da2c98eaaf05892d007e36febe7a0a7b3e8ee45b40689a4867768cc0447d0deedbb2614e0314d1fb6410aff92f0785f813e947d380831b545d875bbcf0f8bb27dfb6abbc8e5aadbfdd65eaffcd08f75c9571cd2608e1def3d4bf37ec60de8d0883a0697bdf91e6d20b9f8d053805aa32d2148e3ea9420d973067a943bb609319aef2cf8c60946f2e8d553e4d01fe4aa29401f9cd0083515b3d221c54089b186889e456ae8e890e32e4b0407feecabe2cde15e2707423b9b7b684493c85cef3b29095089f8b538677dac1e8c4f3c4abd2adc570d795db8252686679fc1c96ee3eb0cf4d05de5d62299656cc75310dab1c537ce10fe7caa7cba29f4a535f3b23d770c88063051622f17e44b368c3606c586ae04d9fe5b9cd46533dc7d8c1507025213106d641fc05655ebb77a57d190fcb1eb51dfe5aa160b3fba35090fbdd1bcb9efc2ac6038c58bedee5ebd3502687878f844e08fdd629cce3d05d7730aad7e2534267e45d016bbf9cfb36a278d7a3557290476edff4288305ffb6c8f20d8e36fab6abd014ab8e3da06f5031b2affd7c7240a98abcfdd7c333a91e3c20954c029345193c18f1688381f6ce937f6866fab44a76120056e136c2318d8a85fb33162bb2f98e65ac2d55541155c13fe9b6c2ed1cf5433a2e3c959746e26c54f86eea3be228d7aef49aa9829269889ff2e06e61f7ede1587308b0c0b9de2035fb741ec7fee2a310f3fe5397be74af71da2dfc43ee0142acb0fee0f8ff2662daf9b0cd632fe1b10729ca3253ba4cde781baea4ba8ec0e61f85881b352d8663311cd490b41e685a4d24e69904aa1252f91ea3f1a5fc41f03596ccfed2932471183740f8c0dd0dc188abdb933132ee1ba909d2bee69ad79f0f389f64fadd0984575009046c0b35b998192b137417a9d7f6fcfe4897c87ebef709219565e98a86759cb785803360438c3276bed07af4954c9f7e1365929f201c3e2e5f0ba4565226e6c1f2c0c4770dc1d57e7840082a14c8965f8e24167283919d0432612c44b3bae552ec97d0464fc1f9781fe61eb8880257dec63ad55d9800a264e1d5e7ad95434a9eae0250154b8f4472d40e14895a133d92b197d6ba66a95df26323d5c364027b896884d25930fece969dd28c22420ef09908b6ef10ebb61d64abdefeddfbee3df9e72f485e06b8c38b8b4b98da8c180eede811088e0ef54b3a9f02b3db554738d51fdea8fa7dfd2c06af36346309065b3c6d0fe9ecaf094285defa987dbddccaad101ea9e1e668310b7fbda87a9085b944727784838412a04173cca5c3ce34812c5146174c1536bb03a3fe25dafe83c7b3058bacce0974d3a615abdae247a2fe05c7cad23a72f0c449f3ab345e6cf07d28b1c728ea4d9674ca2c2172d281a28c1857fec637cc79c51a467d712dc1907bc95725e8e5541b09403787cea47920162c98eff960c03248ec33c762db94681a8f402a4eabd86e84daa4ab1f1ac0fc6b0110e8290325bb455840c13add1c387259044b6f4a239382b44da353913b243b91bad27aa05ccd2875952c0de58804f348723869a4bbcd3b9dc5864a6c264e82a3c25367ac0f8ff6c8f858805406eb710ee48269288444662b0df48c27294d758ab708b474cec32b351c39dc0b2b6298b7f9a414602681244359518488d1e36912da2642f0e5fd7eaeb97581bab3391033b1308dd5be72c3c521453f73dcb646bea13dc72e8f40b3dbead9e493a24556e59617fae24ce1c5c068d9954793c3fa6f1b5a51a426d776cbd849067e48e7560a7f53fd37b6956dc309abafeaf0f5c7e64b287ec08d4d6dbb88025ed47a98111f1a26e4d44b4bc43a7cf0dceb34eb7b337630670da9d34218670919b64a9fa3a07c7d7f82aea340fac401af5d095461ec6ee642c5601748fb681c63383344a47974eac52cd2f97db06534bdaf9a35c085065a8fc527f44b8f1790e8e239f17f92e22c6b35c696d26c5cf1f91e59e6e7260d9d2b5efbec1b596c77f67e591c45cfa74f3e08cbec90dd1af6a7f02a7d80aeb4a39226d7854da6b38f292bd2dd080f2c7129ee17a8e6cceb14b3adf557ffa8b7110f239760e324bd1f88f36752998c1f7e343d0133325933e8806de236e8e1f32e731d36d1d0ce1b37fab1e5c5fe29313a73d51adaa2a24865ee78bd9317e9d2e601d6566e46eecb5fffc7ad4af8711db07e64035a1d6b03dccaa2a747685860c69020f7e84c0e7467d6f2a894dbef73d29b08e2afb8d2ab59cdd259d814bcb5b8eee469afcdb7c941da06d16f3addfb0b25f32bd88522d12614acda3dc7035209ffe33105aea7c831c94f32ae8e28e2b3031de906faaf974cd35916452de295cad834a9781348d701a47aed0bb9ea79d10b105f0b835b23ac0ce90938a185d87d7eb3b3aa1065d52ff67980eb2da4612e2702e3196d426e6ce388668feb29d489527417b0f94b77c6d56f698c513965abd3c8e0f9105a759ee520c589a724b56b513eaee4e74fc9463d83b6fa95e2f6d7eda632afffe52303f6691babd6e7fede8aba70e37bcf39ed45ae6f1c4f9bdcb225f08f2f7863d61162813ab89494c86eee715522c19f762c8343ef02162fba5c07e2c6ff618424da6ac6e853ccfe00bd3cdb29bcb8a1e1d9085a662d1ae0829f714f9e45cd8929cae2d2af45018ccd56f275d7ebdfaf9ec08ddb507d276beb392bbcb4fc6922acb9003a887f4eaeee032c1d998c21ddd826b733b438d66082d3b425beb8b0e10d075dbb5c071399306e9bb02824619d86b150f921a8ec5eb87cef879a32c7e56bdeaa3c986a81f73ded1607329c7d894e961370ec675b2bed200dde7f97239c6df6ef8e613e765b44c97544138862f1ecf96eec063d13fbb3d41bbbd20716a64978ac3134971fdc5a98aff30d4e96261d332a3997b10703e6b0a490332ef3c126f45d80eac154f24132cd670770611f46bc5e026f06b0cc30d9ef6d8b998e85a154601bcbba941aa0af294808d019aa9f07a7e80cee53afefea1c449ae110d581ff728ad6e859f15caa1f4df234abc9ea657b91c5125a0c6749a338d57e49e1dae190debbeecd4b8ae73293a21e3059c087478a425e506c1ec6caee99f20bd5b56f7d433abb52ce6d2fdd355d9581bf5aced3150b09fb1c99924eef9335e353c9c0c2e4267f5621ca370e7db3cb54183b962c6f8b04ca98e4ac01b3681d8639ebcabe18ff14cd5b5c60856803b6e2341f18289b4130a3bd383eee17ab94bbe154368bc7d43522ec600fce0a9f2b3439fd11c8922ed1e928fed55a739563661a9d49cefdee6284cab84921fa1267db5e64299ff9b6260245952e12f4cb222112d4238413615c8c958476e5d5839580fb9f93647441e054c0f28d175d503c40150ac9103d7de3985caa823961e6e794cbcc4b69c02d27a79a4b4b51f7fc5a05e1e46f3ad7aba7173c42d90848b4d500803a3226a3cb0d0fe79cd8deb4e411c8eed782f2aefe0dce927d4557fb2b1340d7d1dc38958f16bfed837215d93ed967abff9cdf69c6b4dd208ce696443679f67cf069349e7eeb18f68b33b4b1fae40ded9a4e0a233ce2831ce66e59bb2ae3aed38d4959c8fb7b31d7dd1da5de9fa08b154f6a59af511a05a83bc308b452bf3aa6e3e65c4a7e367e1bf8c658192a0fa83d5364fd8dcf60f7f9a12ceabdc8dcf6d08e1270c03a393f0f95a85116f8225b0dd3450f19c663b035488cc05f41818c68db3ac2db536333a33cd95b724cb733977a9f55be6fb22e84eae7d608dd04cc3766f4281d8c62b5b62501d3646e0477d7216fe234aa98a80463ce9eb8d6abcb319d503f7dc4f589f6263020d515a94b899e06b0929f388f566734da1ca36ff9942a80e6985d309ac1f375b439043b18e48bc392467ca022b643be8e10a15832131409ea20c05f014f9aec0511a858a8aa5a23ef495ef15a7ed9aec07d478164bc067776162a346b51d8f8523cbdea21e0046cce96ecd9cd545b1dc69715887e730bbd270ed0bafb8cf24ff8476a3abe87cd9092b6b9135b80b83a8695cfa2fc66915248b8109929b3a51316ec1f712f754a2e9c394b33acb6c494591bc4c06a7563b3dbe3e1ab760f23b619828bf564628173da8a1d60993ee8e10bbeeeabe21cd06052d7561f3be31a9c6d1b86b778b2f394c1aaa51f7af02c3cd2bdc5b05e513eb8c7a0c6461184e39c3355d41bae7998137cf55c18c1fb40cce8a5728ee33c16edd7fee3831d69c9b1ed2daa721217a06e5b7bf3d45dc2bafcde38f5a41bdac497117aff86d3d9268a7b1be0c9c5e1f010afaad7278201c4ded6280f6080ab841e00c91169d9763db58fb74c5da47ec12333ed3992a7ade07f9730fb75526ce6f65579c6a7cc0af6716fbf7fd059e2bc955f8ecec7f8a6b1148900f95c3edc2ae7d213d3f39f8fb620b258c2ec3ba19f1254478e66d778cde51db2bad3256ec0fed439abb86a93d422ac3d6903a178a0f93fff967e070a0ea9ab3786aa53ae19254cf19c39aad7dcfe3be62d5f116e28026fb3028b12dd3857539d468690c57c3e9954321754b5eca00d733fe5543c505d29f9a6274660989738c3c0205dec88e319602806147bcb7bb2b513db6ddb733465981f627f42fd04e1a13dd4f9ad9fd5215ceeab7faa3dcd55696f124253fea804f3f79fe8175ff5d77f9fa459865ecf4868a6bc0b06f67bcda9d76b5a6fc27bd7ca08b7ea8b67a7c824f112c283061337901b1ed5fa29d89391a57ab441f159f2fea43bcfdf4b491b8328637300bf6b33ebe82ede9cadbe163fc44b73d3d8e6e407643c7891573c4a312e90c6628d2515af5c9ce007f96b060768166659f7f49bb437cfc152e49884df1dcfd3285fe89a94681f31787b3fed8a269c6885cfcfb1799604bbaeccb78e140cd2db7881390d7750dd080e6044ae34875548ae0608a08c19bad9a4642f5e855ad0cf432d131c1147727fb80cabd01bea81b9415309d21ff99d35b36f5b3a9481882fc782db8bea77954ef5d52828ed70b7b3ede16f1acd76dc68d063637fc036caafc1e79f59730ca1b50de3e6a154b2d523e0a050b91f6c68dc5730f94a7849e6150e3dd303f883b6378546d82ce207c168719ff0d92fbd526c0aca073f0436fc910b194b7c2f016708f657430c412e49df3cb79e7dea49182980fbd16fb81e261d26666809b428e32a1fb6de1fbf51de63efc6460a8338e2635c871fd05fd76828817ef98213bbdd526d32672090bc62f8f15cf75db096e6d17b36caeed79a316ff55da930ef8445e44191de48883377c0d511656203723a7f7f2ad6f3854206ad337d6ebdbe1cac4ed3aea8faa4673c7e9702e18a76a69bdc30b1689a10e0cb164a53313c0215a1668013b58958b8f332f412763cc9528b8faf37d1ae71a987aeb198b30acadf0a9c8434fc6b5e1426af8c64433d992823bba22434e4576f3f908703d4c52a041b2adf9a9be0ac4bf51e18ba814febed41bbf5832a130d559a7313105e4f991eb08a2d373bf026ee622e8da627bec5d1420f3b0f1b76dae9e7f20f41cb8c61eea03565885b7b6172527a8c040594e8b22fe2664e020994e4f8e975d1fcfa6b2cfd34b1bddfb0243858e2a0e5d747883f35e93e72cdf6eb6327ee8c237a55b09e1de76e7dd09388b0e49bfeed2bd5afecc2541af1c7dedfe31fd45365c9d6be2b2042cd08c3b6cc9ad455b1a3a91d04da952e016e0d1a9c696ec55e498c40e1e5d1e10d8357ca6599ac02761b1302944a7a093add896d0fba2d0720775529e40cec7b8a39a291ffc4bd18bfb093c6f1198f27325fe4f637ec9848638b1021987d0891aab4e184857ace8aef3ddb5dd28c0e57794eb1e22b42aa62624477e0a583ba529fd57dd36fb934f3afba9a2a02059d275ca0541becde52dbf1e3e540b9a266a94377748412c764538c1cba36389f12162796351191bb98533a8b8ed0d7b6ee61638ff55948e3bf84400447e8b97a05f0befccd2c887d9550722154c297c4a4efc367ef97bbb60d47498e70410bc31b48bf05ad8911cb4ea536fc6d80e82158f0ae6453653f195316fdec4c833b27033a83fac2d5a162b2c0610d47dd815bd24119a2171769d0528864f733df3b5ce18fabd7d48fb5a09dce4ade3efb355a5f3ef6c8acf853d4929be24c8c10796d0b76ad8c9dc3910d075d61113efb467aceba41cf399a3d2adcb434902826739eb9d13f9538de4b14e18949a93c90054e731da5c9e2dc9a738589bf7628e91727a7d39539cc18e8ff11a80583a53ca7ec2b16e7c4006d84b029f038e25d3618c86f90ffa7e87a72668a2313a2244cc5cf76fdf071ea4e5369135af3230d915055a1d3a142e03ae241aade4c0890e4ee4c49f04a95903c57d318ce9c4fab7d2ad9570c79c326361dc4287884e1c2bbd44fcc1808cfd96ec639e98a4f575ef1d2692f904902e1d01dc003f6517606751ed40c9e55f232ad1d204fa441f1f2a0ff10e8462f2a9af0332c11557bc58b0266419332adf0c006b594dde5fd85a4e04a90d8020b2becd502aae0d611dff85c2558bac44ffe71687500712810de4ea066bed89101ef52a457c86ed4ae86e9c6fbd4b0334194e039b975c23c4b93f7be9351d7b8c2c3b53c9f5882d3685693f6ab0f459e4b7f9948dd81f14443e33f02176dd1815286e6bbf26bbf1ed994c4c4c222d64aa7b737ffbabe2fa60b05ddca77f44d4acdcdc716fd19868daa4a183fe9d745c0134c8603ada0d47622c8099f5954a0186b1e74fc1d96ff41ce211ee07bd01e4e9fce701ece665340c5114a0e2b3a767de2b9715d15e7ba8a74abdf8ec91f66f50a8fc637162f0e479ef743f5975b4b4783a5a17f2ecd80e54899d3d0f02a490dca2023e96ed41fa55ae6b598e6ece56b9dda9685c1a015430185399adec5737fd85719ccecc761c0556c606c4bad0d6d05a4b38c42f319ca87aa00d49fcf64518afd7165d413b2d6f3e6a0cb75b24f306e9dfd5f9546685e3d9714b880d3d8ecf955023f98432de70ba17576ff27885be1316adc70b9d27f7e3a411ebecbd5052dbb7e7e6faedb556fa05de57a825cbd506da2d8e045ab555a8ca6b39cb53828527caf9067e6befc288a0741d104214c17fc6c5221221b4942a0067f2988e52cb97dcd00ef53694dbb64ebbc6e8021566ab55ff8131917e48e32553b064f18bc8ba1bcc26a2e32e80792b98930ec216dd8a002aabc4be1f8c849956d3e9155b7366099bca426cdf330ef02ff49e3d426d82bd34abc362","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
