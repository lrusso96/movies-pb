<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4de4a96935b8648c9ec759f964a7f87e376121dd3724498021b54ea7ad03e71c285c77c2d54c66606200e84f6d9b816437f1556a2d4fcf9836d631d8e6a15b84bff647ea733d100fa1ee4c0334437cbbf00764818932bb687b5cd110a8001d9e9c8740d9fba1d17628ca20b2ab0de0ad6032a7403c37b924a006b4cbbae9526b17e5c854d175116420663920f3b00854f1faa123d6651ecaf1c31a798975477f21fbf44d20ef72b8d1146d432d530b235107d65237e5732d144f4f153fac7d9b3f92762904a32dccc8c12362354117e4f8ecdca670426b0853f9cc65323e73559ec7757de756a6762621e58605806a7852bf56d9347c786fe20a3f952685d1a222f13a080b5b6847327180616968543ac2a05909f3b93421d1fc91d626c34d42f6def25c359edbec96c06fef73555252cdfa6c198b920a4689af2a8b8fbe5cd8ce86085db2442eb6165c01144c49c9248aced15c3a37a68d941e055d7f8341d0c2f9d4f9df5a601d0396271a1f038e51bc7cf5f6c0d5fedd6be130a46aa4c1264a3056ece6494925d60ef6daae8c676abf45d9c835d89a1a522047e5282d41cf8cd4cdd322c75c1012cc7adc9585ac7fc8a5118ae5fae6d9a790ea90f23b98a43b491d9b3e4033e80295605af77191c6ac1150f41a31d6fe638587829f16f71872de4b833e018b8d793c669811d9c4b55aa5f41451b2f0cf3012f98461dad28b8dbecb4087b299d160246053502b8642ebfe9c50ef2aff143c78a39b9067c32fb9eed20000de7c5a1062d66bde6e8b8fc956cb0837ba0f35cab79e75b0c4af83591bd9af0de0209298769c5531f254eac967ce06d665ee2933be9c3f64e66fbf9afb4fdf58ed8e279a697f533519eeed4774d7588f3540971b46caeb99a6316999ee1c47af8c67a54dbd64241e7d1dda4b0b42c55448411cbd74cdaccdb4d19adca195d335f5a3ce2f36765f6d7df720a05f1daf4c2b7de1a9065b4672e4ade42f787f12c94d889b3ed87ea62216a4611941b064b1efcce1ccca61d3e4fb0d9ef26fbeed8b8c6ccb553cf042830aba55dc50a17616d729fb4bb89ea4506e8af00e6502afe619f2ac67876268c2446d0730bb3b5ea937b2dd93dc1b0c1671f98d5c63e71f4b150eba2249347af602d59c058d0beca6c6789cf795a4b835526dee51ad819320511434a3598d2036df8694eee603f00110d6d21568ed4652f2213b8c888806163e4c60313cf215ebec823cee23b7c4ca672bf84fb4b39ca5235e7493d27f38dce4c6ec3c0ea8a5516c897695b763dcb1b44bd57d6f809115db2f75be97fe68cc1b1ef79d95b646873b732462a3d5d0c5b158c7e205952af866e7d756f34bae7050e039e2ea9bce7427b95529b6f268996f5fed404690af7bb825c2c341fbb0a2d1be62030dfbfa79ad4256b376cf4730e2a78f6c68c1190cfa317231620e6a215fa125033ae38831898ed37b062dbfe0da3250299276a7ee414b5d608b0071581c8297f0e8596abe5cfa1135cc2a8483c5c092536f2fe8cc7b00432259f2dce3829807a2dfe6e6c0677ec770b47a99161ea4799aa92098a87454428ba590d8bc5178bc42236201e6251430e921a876956efb56e2decf168e4a4c5c9b57034bbe336fba28261cbcc50d95451ff92bace2f3f75c2783a3736544fbe2b707208045abfdb55bd84b8bb35bfaf1e785c3fc26dcb33c3a7771f229d1172386a92145c04b5cd3155f42f77f20bf8a1b86978686537b1b4b4eb0ad94d46b8302fa22abb6ba82659528192f9a8c8e86dd7fc4e16868f86e87f965c096c0a6313bbe33af70cd784f6facd57aad3d46b1e0b71d319b56ed2b9cb9907f3c4a7fffa49835c0cbfffff9ef5f491e8990ed47a4a921212b6e103c3ae4046303dc8aaff6026429b3ddd6d82d038893f414db106a122dbb5113cfda53ae7b26fdca4acd97ed45f257b0e8df963eca0c65ce6f50c04d7d27df6f05afc596d47486134ce2e0dded259d8922efc7c1c792a40e8cd7138e3c6e2cd89c895f3ab5a4c2b2fb69b5b9f22d708516b5eebf7f13ab5d9fd00ba40a8b5de09fba0309c5ba58a8d6a7e5c27a90a8653ea990e20b57bbedb18ae8779c35a51cb07bcfb6bd615921882001310eed768781b917e9a9c5dbe6f05cda2983745616d9dfd47fd2bdf6b853335031f644012ad12c6c51cfbacc77753afe9af765100dc6d5d2f42816791d0af07d10a83d13d5e7842583c95d569302ee5613d6b95f53789960e68f5b80c48d55bc970b590cc812fd58001ce3adf1483620a0b38ed8017f59a0cee93e54fe6c16590feb99fb22bb3e023b469868e50cd1b7d88e992f342c01b46820b346fb77b4b0adb4b739f9f6728b249eb186a3211395ed058f66c0542c79556df4f45b4e7e844d6da79ef7c82fa13294e9107a07bbff1e01f93a42260bf13759149e8c5f304ee3e16c07ffd922c7595676262b899d98d2b23bbe67ab478d352f41082c01141310d668f53167652a795013cfe9b4e6f3e223b2edba7bb6892125c35969e1343521028aa42f0774b997befd27e6374926c5ea496f74e17cb38ffb202221832ff44b67b480adb243c1ac0abffef660132ba69a4800037cbf2d4c8234c2fdb36f7854fb92cfc84e0c59857711f53bdf3992eae111cdb55826a3f5a5d339cfa31459403e19fba9503027bbf068f701149258a72cde869ca738b90846aef28e2a87565f3f0657af1d2e2f390e09d04e992946c475e18f9bf4b86aca4b9e5f7616415774b8ac797bd7009d9daa804fd3c05f26ceb49ce5a3eeadf475bcd2e71a52c9bdfaf33d00b92d96e6a80e2c0ba9d0876ae253b79458ce307f82d17fb4b30f577a5fa5941fc275bd2a69f1dfbee50c58d4bb1eccc7299eaea442b558568cf80197a01c3315d441e5777d228ed499a7f71b84de44bd6e1e637f0d674823abfeebdd315554e653290d15778d140c71e4a4fbfc156053bf03617c2a53c43785d5f176d10d625abbc2effd012b11be3def3b144f5a9ab8648c38799bbcea051a3a361613dc5c8f54cb64095bfeccaa1d9b5cc031ec649004418e81c9ed7a889b48076bc4a57da4b84d62005413ab079993a370512a6bbab0d85ee319017d67df1197fb3f41e236d0521b4784ec2f15e06af09a6f4e85a2a4555a03f1a6e40a0efcc108587e30e0f04865277792bf0bac10d2e7a67b29e73f5433639972ce8fd54490a22f381ab95d41733f08fd13f419839107d681cdd199a0a8204c464871cb021d7f5cff71077f68a2adcf2bbd3b44e2118d580131c05a2add8d67def941bcdee266197599bf35ea7c02b5708728f1e7c57a067ced59ee97c0280070e8d00c081c2abe50ddbb4863faa595033262635c419e21208391d137cb9d7c0c4828d91112c6fd8d9641420208a1d5ca049d991092ef104fad8efc3e6f7abbd2a7d1a0697017cc687db746a5c1cc82a127ff3e795bb1a553984b385147849d4c9d8f1832a01bdac124d534d7c44dbdd0e01dadabd2564668ee7c3c16c45c54fb7bd683a0cd21f1fa2225279c3950e42a04208f8f30ad00fcbaa055aae627ac6a441eac7073d574d61da64c741994cf0426250f6ab8d5dbf7a0590c3f15613bbc0fd9d7b1952fa74987e13390a4aff15428db9caa9a45c573b950a7491a40e8b3a4c34c2b4be7231e5b78acad7c236e612d572ba89fc4687dd2d165d25b24e63eb95a69146134017658d4b60587bf55fd249e1262a0da3bbfc2a6dcc2cd27766fb593933444b176ad3e1e32c18e8cfe1aa0391e2c301f0048d1656f2e9c7f0f3ecdca90b3a90e440665125ebc80297a482891b8053d5b52469e88e1e3bfa683376659f64ade0f46087039867a08932d898726c7cefb119cfeb7b9b8047c975219d327a45efc7027842002e2528a7fb1aff7d4c1727336db0f21b9bd9221b0b5522a756343ceb0b5c4dfee53457d13b939c12c5b3a24cb820e93bdf93562f105854b246d6a89ec7355034ac89e9dc31d1558816fb5070af0325c5193ac45b870f6d6c03e9295140a0b029773f049f7b9f02f564110389b9b43b8366e68f9d3e5de6d97d0dd8e83602bddfe3e10f014c276f53c55638d8cf3cdb947393756dda99e2f9fd563926f82118dea38bb026da22aafc202afa48ebb42117c83b15206e9c84954ab24f662795dd35c0e43d90239032a9bb506c0103cde874095f4b5156ea8ca7d8f7dc29343656a6e57b0537758c016f64e4b4c05d4b88ff7234f37180f826481067261ad6ad6ca32bd3ed52bf8e57d9f5aa245e900353dde97838d0b7fc3b10a67e43408b4ee932d86f64abee5a04b43bc5c55182a64f2b6c0379b89c3b30116ec7dd38bb697db06410279cad8ea80e6875abd956679c663438f2cae2434221544227103a6c076d565a3ad3b4ab23063992f253ded672ccf3aee6266312267a7520f214a30b85d553a61f019967cc39f8a80f083ac932b6c0b9e4511296b6e3dcd759e4c79d4dbfd7539ecf0a5ba148bcab50e10a327f00f9c7cc20c30c438aa8315d4b773ff47a44c403a707fd404da7fbaf7cf23d44035a8ea91072eb260647b32ff389d0fa685476014c931911229200dfb3bad0f03d6b055ab85b6e7a7a0e93d32d3304f7ed7096b752be0c137ed28bd01f8c6920ec2a65755fa44de9d33e8a0fcb041d38c5ce9663272d11574d443ef6cfd2ddbec1c2c0ed14782800795d744442b4e2fa39386808243d5885f6d4d3bc5bbf8dadb35b3abaf0d01d5a823221aee8ac32333091ed925735f590925f81e8562b32d2975f6bf4f4b67ee34d72e4c4630c420c5f24e6ae2241133d67e82cb779de8b7bcc3aaf46ac0492de13f3c47d1537e720d6eca3b01e6c99e7ec15f73eaf00b7cd5d33b404485910377ce261a9d8b7a2dcc1265b962b968fe438a65f15e6ba639a97be05fd4ea9b41407fca4da22ee9b3754f1aecdbafb883283ccbceed1fba12f157d85c08ab9f903223decd029c543853ad08de796a25586ef4a0b7551dbe7123b845b7003f1fbce5fb6caa2f13997089912f34d376fe120375e92cd132e8895d3621f82e0f5b9087afcb9524af99973bf22a3c7b446a3b97038ca9fceb150762675fb4f7338f01b7eb3b0c3af484f115218acd79bbbdf3d63c578a7ee4e4555d3477207ca34cc93fe87c9dc7203b49978d9c02a37320698c709fe155f519330d45bda54a718224f3e0f63ea429e15210cdddd90df9de32c7368ef272d3ad87b35295a6362e33859f532e0621f55555ce156d0f43aded4ec73c5f8ccff77723eb10ea43356b7987a9c06647cdfff13b2b61165c2aa8ff18156aade0bb3f1120df441e176f99249df16bd1b6959687a0c49ba9b46b0327618a5eae66d2db62eb0333182d779ca5772d1e736521539b789fed2d6a381d863d700b8c46ee80b3390cafb2545c1b91f7bc9057cf5e8af0af534e470ef07fb3277a7cd09894a3c0caf2a3198ce280079ba027c0552f33c06896f06b64a418148875fcdc96df55b40322482a0f58defc2edfe9034a9a82f8bde6b13eece7d388f7a506bcc44feceeb3843cdc7de0520ce8f20dc0344b81de065062c7ca985076ae24b14e6811af69849e857867f9633cdb63667d5f02b4641f59f1c0fef5fcc8c610f3331de6d0d07647a243c2d07e6be937048d078e1cb39ef2530a044616465458e646c987901e9da8d3486b50eeaff46456f5e410851adbcbd60f85964d9c65ea0931bc8ad30723c34fc3df6ecae88071476d24b0602cb0b94edb297daf314726cd5c1de8b9cbd0d42dd9eaaafebc6bbe9679dfd90229e5d9d9b1368c86c6571e92913c8ad1c8aebbc160e58fd497af2aaf09b34ec90cd9b40f1e8069471c2211648c79632f58020e291d415b5b69508ab82cbf1066dcbf0bab22c193fb8ac6ba2ecc9bedbe74cd24dedd061df08a506bfe9b6cf1048bddda6ff1168d2d5f338c6b44b0f8ac8aae453f0d0ecaaa4c0920174783115d231417ac713540e666cd3ea843e8fb721bca33a1da7c283b226689d7a434e573afa79797e89ab0f62adb8843bdf3aea816f898060e91cf8232e2398ba224fd9b8833d11d88d32ba141ba248f4492dbd7839ef15133c7e10c3861f6166a1c4b69e70c76711892c9c80adbce15f6f88034fb34e1c7c3ff4d374bb3dd6a661eb4a04b50955d0b335816ad7e80f161d1d8c22143cb60f484eee3db1506f807d32df71b0bf3ab86e77fab42fd583125a4c7107d36afa2f384621f9f941d7a7ba128e30f3e3511c0fd88997d95b9217bb1bb003ad7e4bfa1627071335e022e2182546bc57f6f1f790441c5ddd64aecc9185db17e9740ad55f215cf194a39481d3ef40328a8a40234068e58f8a336dfe9292e1647f35de480d98dcdac73ac323b8873c870b1105551b47dbf1744491d3b734a4f1f8e22ab8442d3fdfa1e7dd7eb584396c9eff6c0e7060f742f1c70de919f21318a40b05a203628f85287f59d0240141a5efa12eba4058a5f4e9d018a8862d778ec63c4b7515b104ea82581ebf56364d5e8a09074b7093f09bde21b8be4f8a61f43587407e0ea2cbb37128a5cdda6452ec0af3646a0a492da7d938ac2dd1598ae77d2def0a1c24f35f3efe1d02c4ed0fa5d3a1adeb955f4f9230f6bb63371af7d3ee0dee61a96a3069db66cd523954da3b261136574cc53dfd8e783110f32075d6c370e4a3e3116400f8baa7ec24a7c7b680420e255c39e32bc0fcd7ccba2f1d0bc1afaf58d25e4217d8d9ac7599d1f2806af5a1e508803ea4ae1f473c59eb102275c490c6c018045c2d9515793092460df343544c0f71c1121a22ddb119b49a2701b79c3338e6355c829d9ea65a4a85e73e6ca62476f8505e0f2041d7a3dbc163db063a6f6a2984637bb3c59bfb1bf23b8d1624b3a54b36a339b72fb27cec573f86a47e3e12db0b29691175b93d0465165a44320d87e24b642c304cc5b7e7474844c2b53ffe0a5a8a6f02f9d86a52bf1149b42d2ea93b7e391c5b23804cb73d4826f4cfe01b3f617693052bbd58991390aceeaa35face5b34ead360bb1ca042647bd4eea7b2a5b3e24b5012dc01ab9d035f6d51d3d835fa4a46d97c0fcad16b9fd318238d04f9d72a228f4b3314fc3455f414cd0192e809ade70c972010e6b0b1ccedab116a507ae598990a43008e543e47571fb4618e72a8c92618425d975d32c243c4a1704a4aabfb15418530c7e58526c76b4b6b6803ad9fd66bb6c2c1814dd3575042c44473bb05ba7ba96a3bd27c1ff257bc1b92fc65208581ff72301ee4315a211fa39cdd5628f7e1d40320353ee7751fc851f0611d766dfb130fbc3e963e8f08d81ee631cd962e484c51348d57281ebbe94112472577317646a04b69b6184ff05238d1b6f78e512b32e2210c075ab17f7241e36ee69bad405ea5aebbb46e6fbf16059163eb8f46998567a0d77a2f159aea34e5d8bccae07a043be36c40ba8767cd650a905df0c714f4bd3d5a653fb4f13fd8000557a39082ce81c8c86dbd387f397228a5bb4916d9223004e4a2a5c1c8e8e726ec94ec08306eb2566697d9438fb2837d7015737bef68578eb4b08d27ab09184892ca0f8803dad0d3c01aaafaf04f9f06231814d870e7a6cda5f2a7d828cccb6e552307affd26753280bfb5fd2704fbdaf5d010d91aab80c4a379bda13a8ca5ee2e0353a1cccf16bf86ababa9a918781bb7ef360b064f0f74123e85ae0e4649f81f997091f8f83d0bd52b999159203d56a7b31b28925cdea1fcaa9ce023004ca40d664c64887f17fb683825e5fb0dd2cf317bf7f15a50cac00020edf4982d13ab82b5670ca578e98bdbd94d6fc1bf9cc2aafe5754c8e826d4bdc132523f235435fd56cf9f14a7c1b29ccb8f286fb1def9186d1e107e0f99f8fe48fc3bc9f119f644e40045487734c0e8afc37e95989be464ef25e3566f1fb8b87da17554d73a1ddad03fe05bba399423171181aa72abbf6de82d9be067026384edfd0b65b4ec4210d8b5d125a5e51aadd70d3b07910a88cd9009b9b503f0f34d731bbf1464648c99e1816f6f155d42ccc976738f16454a2ddfff90cc917958f9f5dd8ceb96330e787df451e2427025af82a67d0ec42b96dafb12d467b0216522fdce28be6863fc2ecc67077ba32570fe1759e7bc2dd7fe2e3188358da4e2b59e42129feb7beb3ab83990718f7ece23a1dfc808f903b04dd704ae958d3f581ed942e3452372af6114baf292e1731d542a7dfaf7a8f7db6bf2f774913839316220eea8cdd9948e900878291f553ee123d64977088dc845e3291eeefe95936f22306c68097212fb70c2b227edf9fbbbd877ee24e15bc9a72c1985d187724c5c733d0176d39af724eba4d9065d5d09c30683cc5773ad62e030ee259da907e45e98a7dff2b4e6ed87acfbe0146897bcb6687496fa500cb9eff92d213eb7ada6ac3944b291646c35c98628f664f8893e7be64cc6230ab0219979cb5dcea76434b4a7783deca5b8f48be0a416b1753e6c65829767019ca78f1400d34b5ee6c5d4da408aa96706e25b5a5bdbfa707f9ee8bab99d223d8ae52f83b423a94410cb25cefdb8592bfa554c66dd2c0bbbf565667ff9cf92ded2c303719c327777ee17e3983b9fc6fe490949cad21e13adaf086b38670902cc7bbbfb24a483fbcd54a30e775d36b31db2135cd7bd5f0dd2343f063e9fed8cb64dab9a6d55eda7822162b2cd789c73894c2330d917644460e4f7392f5f8a68f25cc9f3d11d735ebe127e9d90a055bac6797cd04981e3542ca0febac42e98555662f05dbe3a02913cf265bff160bfdd1525eb8f0f64c83a86b26a2a2f387cf9699cb01548c445abd4976b3fa48cea1530a3e46feb12797dd5071a47e19c03ea7cbf1e8ece4d4e350bc17160e66f32aea5e2789803f0e6919e5513709ca06de78cbe8e8ac0739e284f754b8806b2d8e6228214ee70ffaa50991831ff617295415309df68c06a030f7b64fd6a4e241d2ee2bda3ecfdaceff5b3ec89481ad42d0ef65e794425732c5ff201acd3967f3fabdc38c4415dd45d51a0fd29829524d2fc40a4b09bdea6531a487af3215d1637da3ea59f1a6404f524227d2f027f315e02f72295843876736020be335065dc3377ccea66fdf5e47a788c535f22bfa388c78d7c9f4bfc4c5bc4f58316941e4afbd057e54e8fba346eb3cc7f2143107476ae7a9da36c8d09076fef604b668bbd25b21f912b8cf22a026a325f47eedf33a5c8e30a5836917378fefd46098e5df03ea491fa90f6e97de6832d2b05d420e0737ec1f20959403c3bb9a4eff1e3be2c72e32effd91988de834b23a60c2bf826316162346e1dd6de1650e517390b5273a0e604cc456c32dcae7ed710b59bb802bd2fca7b4d9065a3c747bb6cad6d90ed0b1f3bc50ce3538573c00098bb13c82db77b96d5ab19e2fb804fc974f7a2e82ee42fea77ebded0c54774e4c2683cd05bc06ac92bc0a299f8b10e9451f1f2798c36955a96b452b835333966b78015225045aba67892e310dbf827ee5233dee14e7746fe61725b940a5c3342674cbd836be7f796bdb10857e1154b8d3a06a18ca062a16e3da815cd707d76db8cf7ca4239924a8129031ba1e7865eedef31b8f9ca152c994afd339a3d4a53a768fd02270ef49575096c5a032deeb37a194d4a61eaa8e336e7c7538440fbe594a2c8fb65ce1ea8e68e99f2b3df1aa9675a25aaf1464f8810ead4efb21bf53280cf645dfa933055ef35d68659b850f774a5f941d09c31857d188bebe465827c5d02c02fa90bcf929ae64969c9028b9eb62e392300fb6e6384e6f5cd62e872fe7d0c53b9222d5138c40af9cd16dc3673796bb4e6da5615dc2937ed8ae24cd922615411ecb9ab873f02b999d7efb8f7eab79ce049705a8dbfb370a4ef35a021f1bfc9923878cbb0da2e3d122f1851f6669bb3904526eb8dfb310381dd7b9e72b261a88488ae35655fb9603190455a3bb9607de6d67a52335108dec015c2585b0497628209f233049f24ef09b88e6315184d628bb9593e80e6f67e0f05661ac299bce7cb219f8a4a6631de542c8b933ec21ca01c1dc99a061d0030284bd0df4e59daeffc14bfeb3cf123a6180fb962cb2f6c623b871ae49ce77b1f4eb44fbd1f0c9da90d6f457b0ccdf50d62a790c0e90f71eec9ce6fb05c4d40ac53fe1df0766be2ff104ac129ad4e7ca36e01649ac8f2d155d64dfefd01a5290a8f29cc77d9fe210d958803e8c71b920d9e191425ff79f3e3029d613fb13f77c4def80fa7ce66b0674eb8887861844eaf8c2e7b934af49f3a8130c7b408c970f187b683ea557074b0f227af72b0932f09d9499f59141f16aeb3566fe587098eedd7a7fb0f04195b21572d87b9bd54c7aecf0b2e29673190afac90eb33aee6ef9df4675ad7e3524202c27d1612d1d07a4e0b7ff1914731b732d4bcd56805a8400f35babe98a387b71a857d6c7a3329972c77c61afd4371abeff2e2cf79a3fe0aa00d52b978f96d0dcd8659aefcd0cb75b26cabd22ec20248ca9c3c0c75157caaa315ca9d7ff7e813d2130e0fad13588b85250cd461546a375a50bf444ff4fd70bd4f9c252efe7b164607d5465e3f9978a5a8fa6d17a44e6dbd82f124ce6fead67c846c9dc832fffe1d4767aeb6c2918d18c823a939f6ef1f0f2f1db7029fd9348243590246b52f6d8ba9f0abcd4820fcfb5cf7c5e5576599db569d016acdc83f91cfd6f550ef0ac47716a46bcb0c1483cc01ff84fbf1bec56f1d19adabedcf605b47da5afcd69b0fe7cfc2ff31766ea3b05389c2958ae0288d131fa67fc4cc9f53468f6224ab8e4f597eb4e3fe94159306b5d7e440d3048c49ba62f9a9115652d41eea85b1d75f3fab6cfa5e1ccca6a08384b74c8151325d1c98ff98d7dd99098766a5464f2a44587d4601157cf39e966d72c1ff283fe8bb97f73a3fae8ec797cd465c260124e837870bb08ac684906523cf50dc23b6e5f595fe3d2baf6b573ec2cc2f2d39d1e44ee0373082e9ced2ec8dc67b3d326e6fdcf55560602f32596f42b0bc9082893417f86f31c5fa9bc3e5d8d63337a32d89ee27ebf7e9039c92f0e269997d88004c143f5540383a6364a8b1a8d37310f04031756250dfd51d219e96983b40d63ba825d3f2c9f14863b069425d8dc6c8d80e285b835f0ffbcb5b36e485258c10808f2a2d967710e16922e68d7d01f76bd51d50e207eda40cf6321c0c3718329720216084bff1feccc99c718929c0f7703340a8f4fb8713b5247e046a4bf07c76b71ecd27246eaef62a9b7d873e4b7746e60ddcdbdc3d5112f9bd73046800ebc9cc48e65784f8e0a0b75615780037deec314361cb50bb24dfa236bed3e24067cfbbcf0aba9cd828595800e2afc423b540016287e23a88d87acb30e2e140e61c547f0634f8c58ee1bcb28cd7d5fd4e61de653bd5672c1372e140faadb533fbee4c0dfb86912119685698698c2350403b44e96084b5d72a2d712bb0a7e2d286611ff304cf22ed2a1cff464fd47cbc1fb790ec40819c9974a05165f0c7cf5d7a55d8b5f4f21b3b4439e4f8ec541ee40e97e1006e0b3e78a4c2e86daeeef089a6a83c3bc08b7a358ffa21eca9ee15a7acc4ce9fd413e053049c957e5d0e55f896bd40ce0cfc763a62eb8af1d82f9ffad7b6eaf1bd195ada8776dd2f30c6552c578ecf344560047ddad1a927ada4d02ed9a68d064441fae61370949f8b994805c0b4c2729ef0f4d8f0eb44d2e955bdcd47408202856ba4b51aa02ee2ffa635f50d102d4a3992c34462106e45b944f40d01edf8b7e0630e074ec531f5996fee7e6a69b618fa55514e0ab374d6fdecc27838715c4a9c1f117eb1d40dcaed3abf937959a61b677abae3c2f1fa8c9e28b635bed9bc916f7b153ac7fb520260a34c5bc16766496c09a29c5c6bdaf7b6de3ff04e0084bcc23c17c526556f7d453efd8ffa922fe3cb33d002a9c05712e5d5cc5aad5c723f6c351673b982b706947c5054f2540efc6b466e751769d48a6653aa270b6f54422f66122792fe83a67d348a53ab2aa5e505431af90e8dce7d789b51ff086cf2247f72a61ea6accc22d3aab9836d2944ac413c35829707135e6b22970b6039ffda13e869a11235baacb4d194a7cd0e3e7441b676582e6fbc85248d5985ba05bfb9856991e9effe294a4d246583ccb5ab7415dd826f632d4167ee2a62da0ff9bd5e4268acff7e8b6828713a9fa0a464bba6fc8adcd802cb9d676791772b5a14f7a6861e4d351ebbfbd90684b36ad64fbc75cd6607ae74e31cef70bfb2f8afacee7641e6790fa5e1fd10eaa21264ee9b15ca34db20c34306100a30f00000ced62ff710d9d35cfda57ddd57991699a5e080fd338ee59fe8b51422afca3183a7b7f251ca712ef9abe78278d765c10f1fea6131e1750fb048cc4596f0ef77c0a7fd7278dc61df843d8bad4f59983cb41917f111ee21f5559760394e7e6c99917df0e52bad0ee93b3ea11a63228eaad1dfcf6355e45a53e1686632341040e0816b5678a852b5d9cd266639431af72f25adb69f6cc80ca5e293e9560887001636c2651a515a8675abcfa478740d4d40b8eea60a9c5e6d87987f5150d788b305faac67a7bdfd49efa9ec3af683c98035819ecc0add09b2e678ba42dc821377fa56c9eaf03929813f652dd51615c0cd27502716f173fba8b47fbe5b80ff2d74a48e9aba914525ad729bbde8ec0115de5844c912f45b95bfb0c8a133957bc8ab6f52bfa0aa818a2f89b257ea80d6c1fbe30096ce87c0f2943640d098633bb73e1d275bee2778edb027287846c9f087bcc45a6a46ff7bb39b26a95d02fc9b63a958987afbd6e8a8de8030efb222f75b3e955161957559b6691329141194756c0944ecb79af1d59b713a1e2bd67c32238fca6b4fbc9a5a4e2131cdd84122d3e8f1bba564f69abc028a1393aae472f680e4b0c53f3eb29189df6fd41bc06e61cf64887a2a5eea4bcfd53fbd030b82e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
