<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d09b55ae2f6f43ad03e694996b9576403d3c27e9898eafca4d851571e077eb3411d3131db45a319a83ffe144beaa66e1daf185d214ba867aa337c91a228f91c69a2fc94c9bd0e0c50af0774b31d778f69c4827df68bc63048693f1d6296d4f22a19ec9316c9eb301b9a27b63620033dfc30ec23b627cde980960381c35e80e0674de9bb44d141388b3d4c08ff0a4b1aa46c626dbccae8e7485b30f1cf331615e465aa77a6d552b97dc53f7df3655b8da2174b6864c9f3a43c0a7a0b1c24aeec223713de0371188bf3273e931870e268acf016304b82ca19b2486d210122d16f079f2c8a8077a639e2048f45d2bd36d9de72d1bfed9186d33d877359997e40df1224b1e06ecbbcdce84701916d41311bb7711023b4b1468f01e62750fdd8a60c84f6c0bffa43d534b9becec3e180f208d8a5b294cde7cb6828591473b76d8430500526fbd781ddcfc834e45c71eff77b3b3a658bed7b71e4e54ed6f11f4e52f9e832774e4248afbc9eb08ac196ba6d08e47d1a9257d2aa77078120a5e6007db441a69815bb6f55ff7ddcde826414a1fb80cedaa20c8e153d303d6a601b21e8c4ef934b8f9731439b836c3e87906081f66cd007f17e8fa483aef5a5017d7d4cffaafe44670c06b017609f3155a9f7d3b69c5fe487cc5b282d3ef8a0ecf28e9c5d6537798b855ce697b266fdc7174206649ab737d9cf7397e6ddcd621575a644c99e3cac9303a44e050cf6f82f5386ad95720bfa227492a9d201a58974892c6569914a7a633dd192f7d8a0cb2648e1bb1e024811a48bb260d49c6ea50182b290c5e8c6ffcf9a7229c403914378daa4330167e1375e14c56c42e8b1a3331b9da7c5fb869b8a5d07f19189ff6bbb7e52e82883370c2b42e0cbeb074f3d040774813aff5674eecf3f101c10db0534a1f95893ff24c54815b8a7d061fcf1983256f0733bc620d60c65afa3e2fd066d58a056d3cfe6960bbc1e0fba2b724681ce270845b1577e150682c5890d945ca43d7c9b6c91459751b1f6c7d95c6885d7ffb174a6d3eb2da25662dbffe04a690c0760e5abb54aedaf4cf598795d0d880831fe8ee36b680e8e245c6c37a5f66ff3e56dca7e8cdd437e0530dd0ec049a096fe1851aa7fd844e138dbd35c970de09d9f03b259baa082e7646e131a283331226811025c4fd3196c7b8e040e15e6919f3dee92fa96b992935640429466987311df08fe9e386626fd4642dd2a5cbd1c14586305be17c6c9ea77b0517d18b65d46c2aadc535c48f41a695031a869a86a8216e654c54416ccf0d6e7aa017fa8e8b9c8fb75c28ee1345da428b216edc1ff2e097524cef8f6b1374b3db1afd266db59008831868fa27996f8809c50efd0d0ed8ca933b0e08879433f576f13537217676c43dc632ecdf0719ed82bf5714dd5815796b6fb4552702ca13412eed73dd9c812ce0239c255000561f25195c918b204c7d2bccc7d51a0c4b59de99e32ebb2236a8b288f118406a416edb874952e440b4dad94391704c01e06b1a359d27a588d8e5735056a5aa5251d6c5c7c37765779edafbe3b7b5ed258d2da7c6acb57c3d4e4a94540add3f3b93e3b3923756b1a914551b3e6584e3f68070129184203be149aab49c0a256721069e94fe7163ed3a6e9888d4ae252f5322b547cd5da4a3fc2a51c9721ff4767c0bead2e08e357f66256b15b044a2280f1f7b16a6a4cc0d96b7bad6f987f4d23b4d3379ae29b919239cfd06a0b782d1ef97298b0bbc0118f7092ac025474135520cddffae738acf4f885aed0bbcb5b749b8928d910af0d938d768207bb7bfd8e9a5a7aeb794e2f000918a3c6564192b7c4fbe641d6fca00c64cbb4607779ea4068c3fb8bc2a02fa687a3733830fac7c268800dff4df7cbfdf5686e93cb459107f122a14560984f0ab0c801863b5fe277e6f98579787400742e47b456549c350000d05ceafc0d4d8801dfc550d29fb0c50b9208dd521f95fe7b72f8ae9ebbe555e261fa72a497fc9ce7d199a52725b39d56d01f19d2ca8bb8b7062e658a6a508da81d8d15b1f70e533183bcf2038b661678e0f87a47fc838920539c2445e96ccdd273a205b7429dd79e54db83815031d885b6e21fa669e2b3b037cd4d38f7b7a18ea85ef798367190366b22cd2c7c147bf132e8bc2a7b3af09622a06d10a5076459507a31ababae2e7cd84600e55596f3582b4d5bb25e7fca4b2f9ab0f5bc4a99d4f484af6478586b7c8d489d2ffd8283bf0578a4e98d93dfaf0caf02cdd5321c5a5e1d7ef2dcd04d62ab57d85c2c4fa1d5b8c225975dc65e0f335282437316f73d36f72ac2f789ce2996469b6088182cef4fbbdaa4f9b6c433e40165536e3eeeb2eb0a024e4deb8369c52374cdd11e407ed73d30f7d1e7b0bc52abe1f60e3ff2be7f6bbec143479e0b377237f0ab6b94922625aaed16fc11714d6adef9b0149dca02820587c7a389d27fa3993d2f7878976416bdd45c4719a08688361f6353f5a3b403af1d4c8be9fc36e901afdd8298ba3ef3a7c042e57af7125f0287ca2af9a22a65a4974274fe5daa9ef1ad88a58850dfa8b35d09bd95e6e67e5f1fcf70fb9c55b3f220d98cd56254b118884713b33feacf52378c03dbbbe307dd168e7d332d4d5db5812a99202217f8b872b31f9348970a5d648e917d718823c177874750b946e8583e4a8693ad6ec3c0c879feaf9556d95f7f544e08e36a131c54d23138f52d8d0220aa5eaffded6c185469f5ec0588ed83368c6125f29b5e7bd1cb8e1ad94c3484f738bddd8e309ca4759242676a7bfa8134870774859258cb25abb39aee1e4a66fe064d62547d261f195b1ff764431e0e15eaad230b9590ce29644f67fabc9aefcac2cc1b864857dbc390dd95ac3b24308870b1390ae17dd5f451c8e74b341f1a72fec3d9e638518a0f82898f030046a4afc5cd20170d056a8b3b1f6c69e92bf4875c2c5237e1852b4709d9e338506fcab7af93439afe372966a5731f972a2d425f9543a6954b6990843ad11b3c8ac11e4c7c6c9dd238993b5c5da0c4effb997a9c870cfd39e6a893979b73bf8f78ea4fc278f1d9f3503ae6c03ad362b89cd13dda4c23652d91fae0ea9bba61e16d0cd8d5f1c8004ba36d0732fc4148a8f9fafcd66dd142d34e5d31061f1b7f2b12a4bb3c4bbb1229d31c381cce28695b05dd2be469427f6b5ebd061d5cad586ee52a5f400c592e1a75e6a8ba01563b4d1b332b96999d1fe7993ae0a3331ee96a57a392263ad0731f0e1256f42825bbcb67fa40bb91910b8f99a583efbdbffe23a9cf98f9770e9aaf3612289fd53ec8b8fb09e4a7db47fa0b749c4cb725c3df1d805df621465fac4999c8aab1a7e919fe19ff7e63ba575791c3e7e724edfaf7c4efbafb3dbc5e54ac1b2f4ac94668b057a463a66a517fb104b9b38a5acf5e86668415c79edc24f65a13161bc80484f4792dc54544af3478a158844ad53bcba859e143a8b0e94894b30a34a72492d1f6a6b4818cd814f90af2ff76acf340219c3afc68346f4318eb554e219363bb328163e9272ca822b0ef79a2531961a12430c061a7ba350007037fa9b926a0a79b61a6baee3e7f46d9c85633e52c31e7572c7d1654a8c5852690fa4cc632e15e0755f822310eb7fbe9aa921ba64aca0b8146dd304ca0e2542e908e377f73b7f9788398bb8c2ab27293b09719160d9220c745b3666da8f83d151c5e9ce55cf56ef7f5253a985fc63c542c03d3f020b5c9bb4cb119ad2152ab71b7150a7da5a79adec28ccee714a28dcd228443f907c0ef9c11e1fad31ddb1c986c0b952e018dcb9e2cf8bf7c4342cbe9852a2afc8e80e5fa6e0368b1e6324759c199f1db8bbb267c096ab6618f4ba26cd2b0269ba5622e73e47ee50d02ccdfdb3286245aecbadcc3b28bd70c136496fcde2f5a5c66c986f7700c4e62b8481bfad8ce94ca6e03f0a667b57294dff1b55adb710e3e29a09092ff16efc6df4cc8887559dfb42a87052b2d3e4d5c2d13e530874957365ed26c3f97f0a8cf879a2273e0bd971daf1779802f2ecbc8f9d64afdab96aa233acc3c362adec298430527ba31061e1fec9bda85606018cef6943a9a1b8f685dbf3000e8502c8e5312d60ce4c88de63af8f68d1c5dde702b5d8b071b963b81c77251313200571b56add909fbd2b416ccd494800b1a4cbde3c196e1fee6336ecd2792e972d55a986caa2f8cacf374dea6783ccfdd69762db07172c4e3afc6d9ea41340802fd1b4d2bc1e5727c592755719ae2d3c6f5af047be0fb2a3404434758087a012a5853a95dc17bb3a37558c1eae32fc6c3e70cafb79a744c7e11ff6bb4b2126ad56706f346feb4f9937c92d65e35c9dc02c5b3d8297176c8510427277dcbe558004a91f58d04f09c35ca62c4a04f1beef78a9e26d77f704183cf08d33d7f264b1e531c4bb5895008a07789ec28a6aec43f515093b8682ef8c7e11fd11889dd6ad54462b3d5c29c3d742fe000c69df9ffb7c21adadf5872a45b90a2b94cd83bc8baad30f65accbbb5c0352261e23d9db1399e8777ae43705aa6a2dea7c27bca3d2f1bfc812d995eb7f558521b5b4d95cd103dd3f344aa00d3848cccba885bce88481eef6bf35da4b361bdc1f007f791c3e8cbe0d2313747ef59cfe30dcc30368e5649e38588152e30106731faa3ff878e97804db64ea7134dbdfadb16e7978e275ff10c00e66bc04332174990fb9f4505a480cbc3b7dd6432b384f1ec60e4cbff69385c6e9d81c1603b59d11bc87fa2139870f99f4674c57ce0cd504a68bfdc42671771fe74b9f95ef06e350ecc5b771439abaac9d50888d80e1889329422bb27da27b46a7de9617c27c765fcf18c4e1c4b82e8dd4aa8fece0afd5eb685844da9128342411456dc97961b1fa591597b85b99733c7a65a95213f0964c82c2068df0519e48be8bfb8a3ce4d2512c568598cab65fa8247f0763016720bdaf6380915fb958e0a7b240c7a41309aef5c8f923f7f98ccc0ce376441ab08e72fa4bf47773c9f165fd5fa911ff04b4992421ea3128e35ea98c5a9ae24f46240794a8d555437c018cc6711cfdd6858a701932eb689c272564dc6e72afb41fe07039c98e1a54676db50d2ec06b551c6a07bfe08aa4faa44fa7fa2eb1e7650c1f02c60698e5923c06f3b4ee522f8b1711daf4e998f2f4138764a57da4d5fe11592b806918607f12634d08195361907cca1897ca0758b5c49756f4cbc94360108e134a433f72f71d740d87cb1f161aa3239d5ea4843f2061a82f3a73cf4d29a50772347c307b42242ce2b112243eecb88c50377ec9f241052704deb2283643bfee210feca1d3a918925d1eeb270beb6b5237ebce737f170e592c04592c75b0583f2b4772bfe719941d26c5c1713cd6abc4421d7de4c5afdcf2dd48905583c751e719b811d4a7f20f835eb3f0dccc7c9f93f72f18c4efcff803d0686c011ad638b8aeaed7c0f0ceeeefbeba3cca8fab1e4f873b7dc82d547faf41a2238b2c7a904fe92df1767aced5af7e18dd9fc34b8646e0dfe831c493aa9b822d41ab1378a6a40f77ae25fd1c9655b7ee5b6061cffd14be41897a491ba4b204a75cba1513e4c21546aff5e3b7c2eab05ecb160d06a4d7cbb0574550af799d8cb06366f3e6729f9146a5c59612e1714d33b9c6af3ddc0f9e17d8090ffdd597886780f8eb26b0083343efda62f570bf0dbb795def17d16873e7d50c9e497f5879e7854378b03a6b0b00b60a75a0238ee0891808be1f54beff24615a5af1234466f7f300ce2eea2676f8a62b1e93819f8385ecd006833a6c0ff3c2a1dfa3690619dd6d0a7f831edf5a8f1eb1fb0fa8ed84800096f70defbb3ed7a74c1ae0cda91abee82c816aa1ca3ee55412c6fd3817ff1c2b07a4ddd021f83fea420273fd64d0e4e7de3195a65d9386d379bce7672bcbac0c1267779f2c2b335506dc6c8909d5e354d2cd55b8ffd322a6bb75d49fbc89ae167a57b1382546142b4e7e829b8384a927223a7a467479522d6f9f2d7354f348b1b5b258513f388e54ead0c2e18e43ec079d2aa25f258751a91399266a1fd17407136b0eb21865b2f1c46a63d995842efd55533527252e4d71664ebb056e15a4b0f1e67eba6c9a311812a3bac06a1cd06599d08ad328d73f902c414145a802f88bc6de12329b8d14068591df9cd0c73cb4c81dbe0d4e89923584dd90d8e0c2c672e329c4635bd909dc37d47789761a6e8eb724ba52075d9a1ca20a498b4aac876fd2ca4e959b5e723066b01b9b7848e1eee530f5cf2a44cb227db47aefec0d3220f51dfb0fda0a7d74b2e24d3df085885034bf340b3988405e1e0bac2d4bcf7d5f4862e93aed842d4eca15e2409363c5c9df3cd6337849627b921f5af60515e48e9e0ef613213fed639da4648dd306fa9a4a19df890456f71b7985e2f8272550bc87f4d15aa7e54c9e6bb4f37518b4337de6048bf3a21c6772406d79b2b5d7639f107763c9da2a3e8ec58bee701e5b403d8784a88bf2f4df9c4993c233c43af4cb78fe3e4d9fc51945d8937b43c205295159926c6de36801be450f34d8ed068755447dc53c1b00c02c4059c09091568af6783e4c9b25e81e0b63915bec8eddc398d690a3f30bb1381365fce1574620609aeb8d11956fe2935d4cd69dcaf1c0dce9853ad35fd4962ded45f33889af823a3d630c0f4a26a441c7cbe6dd6ba7f458b03bd5f97e60008f22569da7a6a3494c479131d67f82d1af51efb308f7961cc9892edc425fd722e3624fd1ccf0212286d0db1b105e8b0ff8a002fca9df819e8bb16e566379a397490c04ad35198d0f42b5fbdd132c9bbc11bd4c62f397f8a1cd30e80b1d282613d42d3ebb073691ce7ff12cbbc66a7653e577d57518157bb6f4598d50245f6994d831d7912d93afeff0da8fc49e0aa5e0d03b147d034280e33e279add2c7a0320c86dde997157093f377a964660495201b6e356e4e135157f90f8325749e7005865af2ab6cf28aa4c06946ba82f3aaa1dbd9cad7bd28f346d1ee76a44e5d79ec8279d72a1921d8f2136dee71252805fa333f67f8535fa3a7bdba49f57221146410b532bf9b4b915f73fd728df356f89d43ad240da28994faf5d6817f27c914507f0237e8d99724125e029f801e2c83c30a603e45a8fcc2b24eeb398d0aa41105e351ba7506abc536ca904e8a0afd7251ff1bdab87347fbc65f0567868faf1bde2bfad857613ffc2bc23fffe3268fa26ad81e23695ea235451120d803adda6c37171f977d719cdd2a24a9c1a068040ad91290d970f84ca30ee510199ee9afce5465977dfd12d5f1f5ac7f3d6957465aedbb8960f5f7cd58b286c2dc8476022b7ea267c7ecad51a21348a0fd81e3c442e9671b2f5f38416d766c8f6f6ea65b3034722df89237c180265ae22ad0f4f5c82c122b7e925cb1f48d8eb61260da4e9873760654b2e0a08f58a3fbd315af6801e263714198995433ae40ca54f6dcea970498eb359ec3fb87472bd55663e9def3ac2f3fe8df9847d072696b40473dfb1c385f7b8084904e620af064ba4317d51fcd46992e626f46dcf63bfacd09814683a4e2b3ca3d44f331c4f231bca5c4fe097b1a0df0b9095ecb65638ebe2768111411623201ed40a9f407de890e42d2dc2f31c4804ebd8d53f6f8eecd0999ff0d1bee492ea937850539792866dca0282e840d0b1ff4773ab4848b5418907ac1839d99ca540d96d59e93ecfb28b3ebd2e24aa253576c99206ac2b4669d2bdbcd59cfc74e010acf1241374d41a3005986af7a88d5262118f621a7a026707811b67732c15f37c34f5cd8c3bd13306965adf2a1142bbc7e0dd8bae283a597c0f381de3bf3ad678f60ef4d422240e119057e02861a98eff70811b6514dd259444fd592ec906cee91e86e78c041e4bde433af0a38a0180b59565d293b6bc58061e2a25e5f38f718bd5d89f8946c6aceeb8f228feda2dcd404b48119071c7dcfe5bdebc9d5001b28d67d49f3dee52cb053df63d39e223684a1eed57ecf8f15e85017cc0e3e8fc762ac1f086794b0d37397797522027e724fc1aa19572403ed6c4bfd6e7a41edc5edab22d3cd1843750bc70d3dbcf6d88a28d68978e64b2053113ac81b2f3a59783243832d5535ede72d09483f48f2df50591c5fdbac11ca06f847b93c2adadbe3cd96839a583b298fe17e37bf1355bd97800bb648bfa9289a27b2fd99a02b3f2c9335bb5be35c8f1b74889d8b87f62bc473e03690ccf5306d1f6d182dec0bd708292023534a6bc8cbe7598e5d3d60bb0bb6007e06e985866a5190224c36805be03196bbdf602be27518f55e01453812644d832052e3bea6603531ebaae05114a309a45c483389e925ead76dab561cb6a8a45d6f9f93de1bac6cf17feb77e27a73a3946ae9e3f6a54eef7934d2f4985b61feb8eefdbdfe22f1b109c17a202807690758660268d78e9fc5b65cf42201b1e7dee9bf09a2e3c6ad7f0a5792c333790b4bfe90b28ab57cec15c3f25632b6899ee36adea71018a17fac44dd8754b597a32f379d55d9ee1b69cff076b10d3eefaf16d0eab6e34b99d5bcbb1ab15f3fb7d35f702354c9d6d3a63ce0e69844e3e42b5086a5c5efd30a04c40e79c4701d81ddd2fc8b5cf40f0502c0d3b0be2f09009911d26e2a6cc4bb302c751724c3a416b8da89fdaacbba68b8699db58212a0db512f4fddd869c31b76bcc4968605ec1fd85a1b84b846c6de373ef0f9a6dee730545c0270333e94df84909d1e43bc803f141623cabc41a02a3db96574eaa9433175cc8c994000c9ad82cd8618939be436197a3c617f40091a3a8bd12ba40855759eb448ed821c8acbf2477dbbf789b35b23182cd508c20cdcdd731ae6d9347c147c41f547f22a6e7c3acf3d20e97e57259ee401214af9e1e668b711c40d5df2d8691e456906f783b70151638916be20cbc65216b85f3f8561d6118c3e05934a8ec0b437a0cea94a71ace519d7524189f2aff9913edbdda4acb1a95023c0751287391647960ee60860470c380b18dfc30cd8faf13ac56083c4480cd7fed95453a7c87309a7ae6d0745182797f5c9431f078014355c41357d2b5eb8d8b07015cacb6e67742aec95e54347e22051255197987afa26a2407fba9400e599525b80513cf65e37bc9a22353dd12ed9e2f16d3faf065d2bb2927592dd8cb12a7e8714628a3e7e971e80830b37171b289cd9cc34b246837967d39576f6507c02d63ce85d71e7ef9c580834243c5b9e12c3101e14c2708d9a18a1964983acf9d8c76e7dffc968a49ab3500028d6cb0ee1cdc15b713c768aaa45ad000c6017154eaac37749276968f8d8f613a092656e488e2559addef1c55815f04678b781257d3da298647146252204a1d748d30792201dcf7fd995f3593989b8e66d4f69024d4a2369ee857234bedad75f432f913bb6f26b19f163f4e186cf7787278d0f054e88f21a84bb8e65ae64b013c58d3b6b91b530ad3d4d5fcf9b7c95c87c10b22cb68512351a1b8fdfa9f0434541fab5b0b287ee4a48cdcb2add55497f65571e5e670788ace5bb0f76cfed23f4ca36a8e4c3ca1386280502fb0670adb331d65ade66ac806379ffa2f33a9c0d3d3630334783b3941df724c31e78f01a81bac02a6e373d287777c423a0d904a3b8b66047faf81ff7b86cbf7bd7770baeefa42a9fc1565cb93d64a39302226cae6341b5d9c1b7cdf61cfce9829782ba9e25f48aeda4c5f154903ac3758bd16eaf7cb66aafb18bdff44ab4f5cd7748cbde17341e480dad32bf79bfa7cf915e3ac5a58566a3229ec28f85968da526b261ed5a4f6d9fe51b45a9aa37fa4e99f5c4f2a4bd31e0374715e191ea5827d258eca861e0fabe0350432aa669b0d2d27ba4c1b485ab730d44b0da147e8f4689ce879478e1c81014180c2a2e90fca89de273fbc7322c959a6302d598bb2d6ff530029b9fcd6aaec45fefdcad796642c0a7785b01cb09a2cd1729f6c5c8f17a9238bb3bd6625bbcbe991dfac6e6e53c3e3212530a4c7ca8cb15509baa9c946843954f355e2a7a4613b65cf3f046536439b81859af2e4ade37fe3576ca676dcf7f8a6f5cdb23d30833cca6f4a28d07bfa592e77850bb46c64147501a7f2ea3a93b14a6aa4b999efca962fe1eff23aa7be68fe3aca8e9d09fa5d76b4559f6b5048f943648ef60e8ffddb3ffedfa6420bb93c7446f2ac79f48b7f564eb265163c5909e196f2c291cb011e8fbe3b2a35ea2acb74850a4b87479041fc9e14571209fed01949d0928ccb1a864760b441f4cb9e80fd1f177bb6f0f01b6fb527f2f045d231f323203be84914f577b180b434f8a23a5fdd7cf03f62ad8e92731e9eb1fa16995ceb94f9363de88e902d3c489211ba310eea6624556f58e39201e243f5c762ad3de3cbd563b19057897ed4013c36ce2a8867c5e21e561683719ca0507f9f269fbccc03a85420adbfd15d015306b85579a1049d7b9c70773767cefd18695cc76ca527b2d29777935252abbb7d6a4ca16f757f2c53f44cb4d7e9888c0ea7b488a983a89284c302a5cbcae21e09f6e0d885702ec495b08c3e53f99a2603fc5e735e503eba1a87d26c578e92c5377df2a682860758183fc5e0a786fe10d83cd9085490d4fc5b96850978a3c18b58bc065b59c48c882a127bcc5eca6b232186d14f414dfa43f64c41895213a9940a419be9faa8733007ab5501397dbb8e8e2c70d6c7ef71003da5d36196135b889c228e2cc2651f57823aafed00fa9becd92e53cf9477814ff14f6cb3caf1be835e743fc1921b08896544be06c4fec26966260b1e333b4f7e8a1edd9f6733cd15673bd1ffc460c2d686157e82ad186f58a2cc5029e08b187685488d62ea6a172a9bcb59ac0d5805e239e7de7da412654906528370b93448de820a68020380e1c0460bcc18c69df2d2287bd70e0da6c41b9ba356665a241101aac52cada109ee9ceb30d22d84126a8e5792807e288e54311950531a860ba07da563439e27ac360fa2fc207c7f2534f3360b378547a4facfa1fbdfd200139b33d20af49211776bf054c3e2a1803b447f46203c58cb9552418daa4e572193ad9860039a89acfbecee649c26fa0f3b505d933f95c5b0c5f918caba0babc5c49b0907da90bade3c9c8834dc25334288798dd9991974c88b2784b0b6e32a4def2475c7e22c395b821ef07b5c5ec2b99f1b612fe21ee856af69521bb798a691466b184e294cc2c16a41e15068fd190e55889aa725ee85a9fb178525485a1ee2f95c1dad932827d93333802e2516dfa6697d53d2c468a26560433556dfe42b17665feaebd3290cb026d0854a7da70206ba3f5a3df833e7ea71cd75080c1e46fbfacf9e2d344f61df85c9c952323680c50febca221e63d84682e5aeeb163b9b65ff4b40488603f549161f8eda6e9cc02ee30ad3f8f93aa68f2fbf410a1e7eefa3768e3acfb25e4c23b806c0fcfc87526fecec234e0e280ea7b49b96d0290dbfe4c8c25b969a3dcfc130de73cbdcfd855bcee7d59f7516739bd55bf0997fd3a28bd42350ebf56bfb9dff0ae3341193e85a19e21843ab30cdde970c02a7a183b675c7f1699ab1cca5578d6bbca9dee5f4118c6ffa5c66d39c32060a7e70e8afb91d755f79dbebdc4d31a6f1a5a9eda97234d1ab7568a425ab3ab1e2223e7f6096ce1856a24fdcf759b228602824f69fb4e98518f43add703057cb504ebaedcddb3e90aaaa909d2adc6d21cf5aff541e6a8f271ba552a88ac9499357f01c969e3d4f1cedf74c7b3b65661308aac0ee080c393fee5ae39dc5c0525c38f3c6547c5b6f1c4dcbbe7658754d307c9d7f8a493e1af211af2113ab85c3978cc08c9c543b2f53ade0643cc72abacb1f78e4a5adaf072fc920b9586c3547753a1da2c311019061b1896a0f4b086d30ccd297663eea2f898e03df4fa9702af1ebb9c1102abd033642ae5e1ff8306975faa88783095b448a1c5aa8ea09d3a37a1ae9b7ce4439c00f1b13a8fee562657be68ade3c068e647e15234cc194416c4d9c4edbb224919c2d6e4d14726073bec3635e8fa9793ffe1ae2f5471308b8b0af0a6b09fa2de1806af6eea56187238d4a7cfc085e45a4a659d416356f33fb5787e698ad03fc6e72a8187993029315ec6bf1de8dc08aaeffe7ee54adcb3e3ccd784e8ef3cc5502a5f477ca8983402cd90b98f63d23faa8a03ddccdab19ca34204dc1d0aa06cd840c64c0c898749a8029d4a2550e356e82ac20c191809862b2f1acf0bef352af1ed92460118d4f8e762964b529da3581429da8e9c6b31a2c82ddd46c09645904cce2ed9fcc8fb8fcb4b4803a532421fc8a4c3f5caf36011f93a1883c0e30ffe68313cf9aca7838a4a7cdc8f299f086868b6a9a3bcc43d9512c1077adce280b1f9979aeb5dda1c1bb731cb9e15f2d86b3871c7efe36c2906ce042e92a98270b2f949a60e20e51247217bb3ef170bb0f6d8d81efe6736555008c4882e330b58955c671265edb3185bc3de1d98c230d950a8251a2c03f5be306c356582654ca4eebf07b435ef8e7fa83b991bd9c6f3b7be35c0c0ccfcb5fa7e3d2c22a4e9ce26b680f6a1955f82dd34b5772c6cf155dfe442a41f035245d5f6b1458faf7bbc4d9f8e71781629cc8238b7854b1507d1277009e62cc93d933f000970014698a04ee1af61044e8b59ebf5ed0e8ce46d092c7b77c34c24a90f6953144b10294a5d1f787f5d1e5a262a3bdc3e410fe2d068ba5c4c41e13fbf272fa04a31af6fa1f1607fd513f5d900816916b7455d317077d3523226e62e41bef21ea51008957e8320a65da9b59f521cbc8c50e9ad3781b6e264ab7bd0ac3ec45eb42353ef8e565f985e21b1ab7171bf9b7f004c01f721e9634ace9787f20ed4598b1bfb9e840608cdd9a013e8e281c983b46b48e00f62dd63a3b5eebd4fa104323b6b5a5f09dca4ba5d6198db625","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
