<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2cdb7fb4746ef1690b4aabdb70a8c0eb41ecd47d9ae31d6c69d9d02b4e85eae0043afb2bce984f56f478a791cd93388d9d15c7f731aafd36765cfdddb57a7f01dad0b1563e5153c507c0905d55f97893151ba205dab208de8f8c07e6483c9c6cbcfa9eed1ab4d873cd2e3d68c26240b5e5d28de6418be196c167350af1bfb2787aa89f54b3ced440df9fb14a91edc23f52bc939cb5026c1a75f0ca67974ab6e1d4985711b8aa733474f089ba47e0cd672094e47bb8803d626c0959375108809108a7f288835e071e14c8b05c7115e484534fc193cfa68f78ae4b544b9ef828e3e2d9156556c9c099ea1be51c2a337bf3bc30ad3ef7b84ff4bb2875644df99f95c8addc5470e51e9c591f35970d81cbbc17d3d885d2caac79ea9f825ff233b86d049e1570e98413f07c946495f92694c916e1276c0c9c7abb1a8da6e72439484e7c9517f14b2d6453553dc68de32284115aa6c5963c1c3eed9d12888470300d39ce1f7f598892ae82ac69faba6c79ea159892696e6a4c0e8c7d8932df16385fb0751fce525c0cb373569018700e8438a7187c30869730c5cd10d66e55723ef56c25b559e1a1237f30793e237d49cefe4a4ff821a11ffbf0feacf0587f6fe4b8a25edb4e054258e40e83b00e6f310c534a0653d01886f9c6777c728bfa1de6da656639bee7076f42af9cbcb00aa8e9f970422488ed65099a91c7802acb7f1050a9ee052928a8d8913b866bf789382c320d926d08909380b2058166fc273b26ab8669d67fadae09b1a9134edbf0ad8f1098fc77f51e918138d8190e631ee9c7501ce5595ae22d05c6bb9d3f9b4e12e4e8235885e745b6e2cafc1c04544503712eed0ab79a27da4cb5e2b8c6926d7baea4e823b0655053747de471c61a49e1b25e0bc20128f3386f84c1ae9150276ab62678417e89111a685ddda78fe22bb205de0bed1c955af78831384d0490924d55adaa80e3fb78b000c6dba0cabe78f9b4029a7eb2440bada8f568df004227208a1b14ba41548ba691e0c06d3f225deb31c2a010ea9bb5184d8e22ed224cddfe2f850f928bb6824aead5b584e057932e7f94d5083b006bd3f05a589365e9e9cd420d0e753308802ecefb2dd262b3078e51ae6f1217ca2fb2d493134b08999d669e06b6c3c0f972cb15ae889bf619b4cdc20986b78c9c3c9e86cef1b9ed9828209acbcc2b002a69f8a84876379666b3c9653bebc7455daa28ed878eea0e970873044f2cf5ff3186b635e6a792f941824ed2f7b4a874885920c295ae851df651092b91eba6af1ec21b8d8546858188920e7858ca6a6ba6cdc157dbcbb1ea8c4c5c6f7a6bdc7ba2a56ec2526eaec6061044f465fcdfcd1f71fecff261f9b656aec5782efb653a5f76868989cf70cf14641c51b48a8af86e3333e3549600bdd2ec89b6899964ab1cab99d78aae09dba372d751e415742dd7cd91f3b29c4362fcf04afaf059b757c12d46f218ac23d5bcae25bf1a868bf7510efe1bac03109b3465ea28025beaedcb96d7cae79186b389187c442426fca10e14f6e82376265f6ae1d5d82b8570e2364053c21946afd409d5a955fbd809f236c21bc868c886a2f9938ce0ac4dbb7e94cc7ac73e2889bdaa2cc93e6d42a3c33f79fd71ef0a60e9d7301d8e4263494390f51a5b076601fde8e39ad3dfe185ca23f515d6ca0f08488922ef2301b9a351a0bca3cafd6c295ee4bd4fa97ae1f42bea9990076dbdd702d2d4b177101218a7c0e133f8c4139039d511832b935f7326ad4a5e408393fedc3a7b5a99d2c5fb8c3886b4046fd2ddb7d2b4edec8d63beff9eca29bc2a40ea73d6cde268409c6d419f1134e928c2160e36405a95d9a46bbb061fb06cc9b88886e54ec6b5e7289ad6b1dfd1593f66d1a5cb6f43ea04f329726475207ba303259c77db2fd083a33f37a2a677394e403aad43a400e996ea8f8a428cdfe5aa546cff5f642d6e11487027f9a81cb65029a526ac2eec08806f16081a3fea36a3f70db6208001676ec8d135b2fd78397ca21d146c13c0a03875f0c1c63a48c9a7c6dfe8fa3c8bff2450aa1634eae2d66ddcceccdb1f43ce592ea3b2265d70af45011dc8cedc565b6cb192170a39b6ed75bf47baafdc63c3dea95688536626072a7c4b009ad29d0ee7876f3b49435913bda9e1411a690474933ac56f8018260121125e8665cbfcded156aa7a57a47fc9b95f7fbd4186da697aa164c96e7a67e0855ca7a64bf9d23f61b30567b9c1d158cb323ba9ef92f9a58a384d521f8fa2fd4215bd8a42fda32b93ea988c8ac3c7f5206eead95e7021d8cd67aa0c1633118aa46238d581f668bd40eaecb468efc4f2a72587a5de3aa99abed65b3393344bb81798f3506d80f9219647900f9ffb5aca3f3649a27844c686725cdf40ff21be4e84082b023ff2ea2634e2654d1d1b0f5bf96d1224132c3c5e8853702504540f770cb1dd83f2b0cc9d44184f2c33d7629990e6c196aed110fdb098d1c4cd39d271cea441e3056bedeca1f2f58dfd2e0b86b43b8d496053e181e49d019299233a9f8489f534049216bf1f3338a8696c990c0ac21a4441b62cce4db0337a6c972eee756888f41544b39e45b199703817989f13e3ebeb8dfbda24bc6781fd30a7624fc6bcbec1f30e6a05173dd388d24c24633b067d40dade59e0c04ba5d965b704a3576d353ca3284bba49a80e21baabeb1f5f9bec26d92b24dbfc8346448a73c144f03c4c51a285286dcfefe8b63b5730031bc67bd8e451b52a640be3009fa5ea9e6e389d26ee8cca0ddb06d867967360cb5efcc5bf5c862f7b8b7ddfa0ac331e5965c2a970014c709b4181190e24d69250a24b31459a03d64802f7de5e0fb6b3a7afe553f416a2767b916bb7d569464f2165b58b8b1ee474bd663b51acb0c250e33db54c1040b669a7c632b9e7d8dc1fc74285dbc4c878a827d3c124ee8edda9ca3040577da7302b38295d10c6654c563b98ba7159bb2ecf5e61506e2bc09fd1e612db58801c66e138d0d8a0664ffc988b533189df070c9f0f836e35e16f87e7b37774d0bcb93999c331face32a14279325058713dd55a49f69994d411e74634624bd8961920949be8b0eda188057018499c2e4be98d947ceecc6f5ead0e80c10057bd28c6c3a22706223235be9dcfa297b3c2a9b410cb20645f2bcd1c77da0cd6a17e52a1d58954a4713a39a0e7f58db575b33827e82fdb94f82c2bc865dfbe801f9cd942cec3538eb18f07c0a6329d67694ae342b1be691d7e8ca4c04db683f62bebd3721c293ab70ef949f0e515bec8b5ca46ae6174b4efffdd8dab5155bd0f531a44336a5d3c4da2c5f8daa96215a98b87b388c2b94477d0afd5c59d84ad4bef65a3d237953523a5c8df42c8a9f613fc0b59884d8b999b357ff2d0fafe7cae4514ad8430e0ed844c503ca3865c9a9c86cb448b63badc806419c48793e2f3c84e7f2352b291ca4e2c9203bbeefa970e341b5a9d29655905a02e430cd5083eaf7a07a1fe47b0fb2023b7014aadae605120953aa16c008db814fa6ee9d0dc38c92d88825c323054d6e603e54aab344d4dca04e6ebaf74a91903fe62f1c0112702a867abb7c5ffdb8e04473ef7a207d2e94ba8c7450f17a11819db2bd7a8bf26971b3f16d8f613471ab2fe1dd40b2f4808b8993aa6535370a2a1680f9d5b9187c42864061ec016bc5369752f2c09621f560f6e75410f2b93aafa76c6e7eb98cfa20f3b0a8b9939ad28298e9cfc518bcf96f09fdce2c62e82ce5685e378208d3a58cfdbd0e7236da914995ff8ccfdd337ab0a17ee31ad6379889716ce485c4a855b84a5d5114c3f54a9de3803a564c4540e46054f4877f94a246ba40e68f87c1ed6d1a6300ca0f1e34a34319f6814ea2f7a666d41cb992691fa74b4280c2c7924d0ba7702d56d11bf3679ce0d088a9adb2e350e44800a4d6430ebe2b932425169a7925d87164994a83a1a7980be82dc8595c680516e8888af5e1e63ed6cfdc5b24be60e259af86360b864d110ba592ca785e62245565b12f2cca244d65a8aabb6de3ed5cee14a0cd663149c5342fbf0d893a6429648964a534e3f341767aa2ee092eb83fa17274b1ffa62986c98a2ebb39b29d670bfb5e6d1cea3e77b6c17f5a42dfd75707c8fd4ac2c0dbc884f0dc4dbe0345fed3936bc3b18409095ab7de2ee22c81c50f7532e2a9ec1eacbac5f9b1551970c41390d11f9ce17f8dca2a88ec017a6fad87de07c1f66281843c45a3656a5b8d4a7a24802b45e96e754cd483d829806cb8fe5058154e19d1cedf42135e40de90ef891ae2a68a629f2396d39b3297077944c5e6c8d3fba319eb129c604c48d410fe404d59c4c10c983e79bf43e8eb5a4036219c251250a5cb4124194b1720966c0118014d03d5f6a7e9f12c2d2388918e1339145d2c98af063c883e036ca345f3c6c72c594ada4a7b82c109f37a0dc824bcff6315825c513cbf380703e9c50a2566e28980adefb2edbbcd92af61267b2d85211764889dc523b9b22a7faa1c97ec7fbfd2e06442bbb251de4cc83792cdf168b2109ed066ee6515644ba8b8981b234ff1dff13104551594dc8edfc5eb41a4a936fbcc0b77648b3bae9c8d64489f9a0b21b77e9e5c2100a24aa477a5e21bd809ca7f09bdf8356a55c5174cd66e7773a8580b37e83be80766b93766f344498aa2188698a75c5b35e91f01336e9d3cafd81b85a3a00fd1784114c3e7dcf91b3de2bddb800959c7f0d283f97fe75953260f2c2019da2fe6a2b6db1b93c9d3e27835f8e6bc6dc6fe69d5fc82a26d6e929789221069a8cd6235310b792d05567691e756cf6dd20cf873ccd0d4c3b48f9413e0d5b502844c9faf2b0c6f2e75898d9aaf308fae1fe65eccbae6865549481481c18ffad5dd12b31bd8084a73229903fe1c2f75f5a232ca0760d796aba0b0832abbd851f9d424cee48370f1777fa968ac019302821e0cee2756d7eb4f617050e990072a9c2ca55b0af7ff7ae18f73bb0fbdbdb74d8ab710dbc6a5e375a4aea585ac240bf91e1081896cf16319df174ab114e5c9bb60422c62174a5500c4927b295fe19d72a531beb3cd049d5820ef3f1fe1c5327295b886caff55c1a87abd3c206d2a9c2ff5557143c1f9592db614398e7f240118065acf2efa00c14fe10fe0efbbb4840c611248453a0ffb0f31860cc355a1bcec79d444c81796a746cf54e8493859f123aed1f7a126ad841cdc82b7d61a7a1e271fb5172f51733267e7cc22fde21b92fc8e332c4fb1b0774e1537280083d8bd60130e5d5d680e33c02f439fd818ed021c82e24ec85a3b5512d3557506ee65c8ff3a9f2c48703b9421069176133335f6ea0628dc8ee18a78af2f146f3964bf23713eb692c9c3edeb1fba7cb584a16b55665207dac32fba012e30116faf6d23bb463087431b2d9cb1e3277fa17b2c2bdfde29b14c14190629320f7a68a8548f2fd38b626ec3e591e03b082a2b63fcfc65e0b4f3b2169f845f17ce61a2a899c3785c9e8ec7f37bc720c051fddba769f017457b6a926cdf0115a5fec15f6df3575a80e53bd7a3594162b70c5f4b5779bd6c95e1675ca70b8251228df44c313e2f96806095cedce206aca3e9ece020eebaeb44798a2d4bfe9c3bebf5eccf3f899635d82c9647bc747dd0fccd9f0e50ddf2dd7805eef9b5caf25414ab2b7b252bf12e7e6a45a04938680c7b27f858bc3efd00d7c6acc3453f1f75e158b58385bc2ff1a0ead1a1e9c7418f1ecf8c20b4f241c7d38d5303b848c41d81490116ecf1745e35fec35f969006dfe06de5cb85515bfbfd3752fdc5825cd6248bdb2002a032ca9b90ab9b54b0272bd8031907d11b41612bee78e4d8ff1e09590350a8ae68d174e273faad6457818ebafefdd855dd73fde6da207870e2bd3fea6c995d53792603b507de822de4bd389dae559c3442b7f7a00a20fa46fc3f036ca9e42200e369f02c0fc640aa66c5dfe6b850655876684349d8ffe4f21c412f8b4ec38e01761f7160bd61f4d462054d89b93f8da7425901ad3ae6f47b34df64a1074a97f2e949fb5447cd9c729d107b0dfea51cfbe369ced631b1ae1627a356648b625e241113dbce7217dcb84a96060be023b8fe5a68f5fdcc1a2829a4beabb7601dca78fdd5c9918c2f2ac397fafce83ed25955f74bba200ccd14662ba5d79494d81124c30a281f3565e774e81a2cf93ebb508599c76d013bb785ab662bb2f5d36ae4cea7b24bd3f08d2a5a2c0dd59d977dd6ed1ecd7ea7c300298d7130ea7455bff61aeaa47590da589dfc086b8e4c4e6cec0fc51ec30877e42c9b2f3d9a9418c03505e439d129cad8d800a6799db6076fb28c5de148b61cba87a65f19064dde96ba6d372650fa65d13618f3ac752b2ad09e3dedb61b0a4b9ac8d5fc7933fba966fdd10b3f6f8af7731a6f0b7ffb742b6fedd93d03bb75d507be0f1aa62a473e49977f5a29c4e8ae5c7babdc3f1e824a82f8eef3cde9823d8062f25988c0aceebd8ee35c6d249a6c3208a50eec06540d0875733ab81276c1d8a6eefd80036e4fe053f0085dd82a351f226150f5dfad07782baaa7f4b83813efdc8494ff986bc9a72e76bcaddcaa413845b2b12f5e974bfa693cbcc674fbc104a3c156ff3f0af66c77f77d56dcb111522d761fba3cad7f2730ab45177db29e1f42a17288272885ec8058b61e90e2ea79e1f1cb141ba545d9aef5acc59a2ae009d3e6bdf7f60beba1f85bca9ca5ad1e7fddd9a19114b7b13e4976542faabdcf30a493d3a92dfc0eb6d66f854937bf509a9e6a84bf61aebe2e71b9135f21daa0c5d531354bdc1b6c532e8768fdd679e4dfbc1f7d03af45adc4157544de8febc83bac8ea773236df8ef8303d17a4eddd250071d597fd662fc0b90ce908b7d19297a5dedf2866af830edefdaa6fd9d32e5efe42855d243b1a9202041917753523d299d6749fbf8432442123521216e77910cafe82fe7dff90916207886587575c847514b6e7b272564080241198abfb45160f5543f8f039caaa9e5ffe9f3db587061ba95ef915f7bf7a593a11b6012c3f59d3e337d25f68c9da1ceed630591f428e98533f86f66e9b38da78ee6dc9e22149528658e6779afa4ed0c743b85132fe9284f71d913ab92c8f4e1c10488a48e10fa6944f020346ab5aad440f8743e69e5c508c30be2e39a8dd89f4b62ae6950d4e58a93f95ae098cd12fe1be196ec5d0f37991b0eb7ad60dda6008d6b9144fe392253df004791a2f814b56cbcd1d39ff04bd118b4721583541d66a2c6734ddeacde694bc052093ff35feb9bbf3b700f58b6666f499c4ec0f4b63198ae4ab85be75578f13d130ec45f28e5572538572c6f99dced63633bde27db7fca92d497d32bc1705f44257c919cbecd6f6037be9bef949ae697d4cc6a04dad117863435a424510a52b9196bffbc729597b7cf49c903c2796603521001e084c07c11f1344272ddfc89fba45db6a8b26b0944c1fb88ca03fdbff68221852bbfcfedae0449a093e66b8bc7ac809845148ed39417e444ac76185368d4c7c4eda8f671831df2b4ee510cede1c58773951d5f82b42761bbfdeae4feb04d11f49dd490d72bfb266721df1d838fbd91ec712c756d0b4cd4402b6aa2645b295247f279c850ce16ebf72dc905a15af6ffb1a4704b43478576613f18295f55481429b6a02290cdbc34b7e1ec97381c9b6178b133ca133d4ce7293e1a4906b5c08f12b08a758e2b5ae47bf465cebf951883af6b70d0802278d87e2b09527930bdd1397f226de385cd349542f28d689a53207cf4d616f6c891c03bb92ed81d0372a2856adf4c2e10c65ab594fbe7c8529b0edeaaa8760c203f10b14c73f82990d9e0d89b2f11f4361eb88c73857b8fc08008d018e48b7122a43562c5cdaa302d4c32fbe8ffee170113d810dcefcbee20ce84271bf813332254a4622935c7845a370a225a6c0c4c690b21544d423a8f8180b8a724cb0cb6e1c0c951cb1a2d9fa00ee21e4cead0faf0debc93054100ff90af4eea03516ec2d55c2e415ed60fcd822fba0c56f96be7b8ceecb6558ac91b15cd642641a673b1b86653ca7239a119670390f2c5724083d4ba535fb5fd874179a5cec497c7baed5975d068dc8f94464f91a1362698f9f53d80f09c235542c3bc1337734734c07357393928c3638ea50b97fb98f0e45ab09a8e221c10a80705575131ce98d45aa4c0f334f46742f6c8ba8f2d905af84536e614e887b99d93eec9dcadb5d3ea57a3ce29d2a35f760d83baad5c18112896ba887f9ebb3a9aded8629faf6d0b74d61ca03a2863ad4a4133429efd8e91d3109c74b9400a3e3c240eddf6ecd9a2bab00d9a1189dfd69a9777bfcbc40adebd76f18069750deba09183e7b18b7c14b9976533cc2c302a736072deb0991da40a1477cae18eaeaafe4e7110e86a24e7002946cfee0bafc0004961d0a0a5ffc1aac21a462349a95ccfe38f364e6c85c0ba10737d5669fc6a3857159772950760ce4dcfb0fcfd0d8a1d6bfe09fc545dbf26612c74c42c8e7ffda9b23403d4d2f0da1260c1db12c7c4a694c9afa2105fce329533cb520651f1b47499e533e2a7a1f13600838c416fd511d467a61c5904b736d0b69a569ff75b26f315331491488141c1727649925d063bf3737c1f7f73ca04c4cc916f4310a51a15f0b5695ebcffe1a664472dd78b0fb45c5a4eb358ed7bdae32ff21b3d4e02ee250572d2d6a183392759b2b6549971022e336b89f59236dba0627ce22fbb40afb7f54739df212ade8134388cbbb3b18088c171b0bb1aee2b9d7a86620382abdbd5a65db01020dca85e33edf9198a6baabd9abc5dd2a5b36e7b73c8c0e208b9c09ad63c555107a5a820b75e3d40f1d9d7affbe731b19b943a93b755632b880780d94b12ff3ab451f6491062f03f9ae407626c21b047ad2c00cfc579b67ba091b0c4d6dc9a0a553403ec17a3a28af663f208b30bb0d8c04642e85385009c04e1e1c62b6d7da6131f92cc54c8a1f0e8ac72240328123620a3046eaacf7857fcb4a50c1d7346a0aea4744f7672f9ec60d124b1b4d4ad6733fe2bb87f3a9b9567fd9645336d650eb74e8ac0e8d644ad2f9a711f6c2677868083ba7a7f7be97267571e5078d5683a59c7696baf2d0bbea72d51a008f049be465db8fe616a7a5313fbc13b6dfb633536bdd6de242a2e0a8690d73844fd7863d55ee46e9c4062485e3ddc0311319719bc4f79a014f013d9cc0d6507290fd91323b0f18f24fb75310d76e2442c992f586bc445fb38f982949644ecf0079cb3ed6bd30f7721a973955e840f90701999996b5b1dcf7b1fea0c65dbe5a2d43ccb75787d1b134e94d804fb6ef747667dd3b4e62fe60e695ec2e72a8e3b0c8dc3fa2740206ab61ebc577bf2673e77f9c6e9dfd0e10c9895894463018e7089153f6ca991d6137530326c09312530a5e414336aab8b21fcc642062aa7c230475571fbdbd16b01c700b8d144d05ec3f5ab51f5f6de7cb8db194c91d9627943901616f1564e27f3968eec50aaa5689b82bab63e4efb7d0bd3dc11eb6a8c61aabd0ce594190367031c3043e1c64904fa0ee37f55b3e3f7d1f19c8134b3506534c2065ac087fd91b010dc446ed81ce306f1d0a9ffed177aff82db29ee30b6fcdc4db49f19d0f66e4b7394b90d385881d50283fa37489488b237c467e6549f43b65425071ffa10af87f10f03959dad88d623d026c20d095617c2b8330179b5fcdaa1627e375711380a8fac501d94cfe87dc30b5d4b68ea4bfe38f6a614437d0a4fb59d5976a5d0c2d390f7af39ce1a1c28bcb5b18cd2b8b5ab05516a309c1ede5197daff357171f8f2c900e472cdb332480a40350a8a76552112a8a76d878e90570838e7165812dfbfa57b99401271ae0fcc5ff59c54d54e8410cfc721d3b036251f7f4826470fcb8f0e932df47099e80d4c41e35008f6de57187a11a0544df787b9207665bf9a69a0e625f666b0c976b60466c0f631ec07f2acee7e3d3aca03131cf730cea4ec9729cfff7b46dd47d3a2e63e98d996898ff0736a8af84502100f5c21c11e56a216f5b2d1b58c90eb5800e9788f89178f144e919491b52230a54fb875e825c64258507ac6444c20171b0dfb808897f9094221384e88e9c037f49870fbb468878d3aa5a16c68f0eef97479b0482f652fd88c23128317103bf9678a3dc36c7e7d1cf07b5fcc4b4ddbc8bc017a952f565fbe97e74c90b9efc204793a1388ed6d5be67c77093ef17358056c8b4dce7266ecb4a31c67b94ea3304f1896adc1a1edfc03f7fae3fa2414b9e651633335a106f4e41bde3bc1f2ee3cdb641b68ea5e81e8310ffcc569560f3e84a23e1d21c67d75cd3ac28138f53241a9d1a497d2835125223fc4054f8fb49a4ca7ec3e587d1aa85acd9e095825e279153e4d88a750ac52da11b253410cdb2a9dd1fbd7f10ed65bd9558d85770ac8e7e869ade7da1fcd7ca7be3f1586149daf1bf3c0780536d1c6b20f09f192ff00b6a7cc53fdb22424013a3b2dd332604066ca5be82291ac882a55ae723a28feef59f1f25bde3cc204714206cb47682b38e2ff887c9373b85eff40885c8018b2ea3f1fda5b57119d7e9b7bc58586720694ff34fa379c607095c2806c496c42a46a54ad3b18bae298e485530f3a2b7205ce267802d256b94ee287136e933ad8db51e55b338a4dd33892b2c9b9573b68aa1bf89533ffbb37c90438ea4c170be9f6d2a3db0da7528cbcb469954d2563660fce981e340a3b9a4d05a241ac42fe2732ffe60e8d47a8e3d999d5b7f459750eac2af5a678489f6ef0406535d62eb8d99c9d68c0ad836390d654d3a48a7a73aadd70fc34d2e2c92dd81da49471303f45ebe6c8cd8b804a0715c7c127ff226e9cf45a020482c8fc83c55912008d68a1b6881927f04b6d497b45429fb5bad38cd6aea336f44d37af90989fdc7696199d6be1f5ee4cdff6149582a23524d11bcd02f119e8248edde7ef0487be2cbd8ea669b279ce6d71e5c19f3d12292218efad4c3830580b87b3a896019d112b18b11eafedffa0049f949ba014b6cbb3de674dad6cccbaaaee0da4a32cad09dc6b1f3e67838833308b50211a337ca2191fc0236b442ce725af57904efafbcf83d0eb1528ac87830030d91eb26f2e98fe4b6f097f97bdbdb5ebba098caa6143d3aec1aa3aab599ae37abe45e3a57c972d6cf054d18a7d69e9a3c41068413cce56b535124dfa3a5ac5e41ef46e6ff292322435612de5b49f4463ff337f0e3bbda097e5213cf775c28614b5ea23b2edb9279da42bc37f1630917696675bc831b8bc2007b1c8d3a789f1dd41a407e63adf90c631964f45f7f83537d441a213afcd51037f93ad9219f8bd25bc633f86477abc124df3854e7384c809443b4b548df9b66aa4b2f63c294f26ce8a974886ef16167bf30b491232f1eb170e2f63a51687fe7af3dc1044d518d7611b645c94ec6dc186a68e60730c7142763a403b1fd8dbeb34e3a2572839d40b670fa29bb9cbe08d681f5a599afd4003967968bee488807ab627df3810c91669c98904f0767021566d22a097df19a51ab03435cf1da98a362134b644cbbbdeee3d8feffe1cae54fab62bbe6884d6d42385ce2f46ffc94a9e93aa851baa8a78736dda53f3d578e8db731a4eb8a418b33276411e247e4f34923d6388b8a8d90bc652d578cc3bbd9092784538640198f1ef8834e6234b6169bb9d697ac8cd14db5ee6ec1eb5cc793123f8144cf574fbd461f493c957a00efefa27ba4ac8e6428b0094e5a1544b1bd2b328d116c1969348db158ef19eaf4f79a4add445b66145e92cc40f9eecae6bb70ca49db93d77365c562956f88fb3a4e374dce76003a9cc524384e79153d814916ce0b209af8092e3f1ca46a93c86aecc46e1118cc1d61c4f6512cc2fc73d838399fb192ad96ae2b2d2a77d94b8e24103d2b612bf46645ef16a87b5df01674bb8ca657eff5c237c91340d02d3fd24a35198d0e4d8e67377f6019f31b6320de361b730d2df3aca407ecdcc32f6a052ddf29ccd3874989cbe1c61c6403fdea7620a580b02c930d110235474f8feeb5c3dbc85023d986acd7afb09d68023ba595e5552233488dd3341968cf025c317f19aa5d688344d4d84334299b2a4f5caaa5a5795a46116093d4d5886a33786c1b3dc28197cac305c23622b4f68c761f943a1be3f7d5a09fa6139fac35388e37ea3f534311e8b29eab1b763489cd0661dfc48a763427cc4cf5ac7241eac4c5c1e23f0285a124d5d19a9a0b4f9869c9a7ddaf84133aa70e53d0c229cd79957a15b53a769fa078ffe3d5de2e63c2ab257cbe587fa368618401a5002b92661605b3b30774514b7349f18c3e953862f4436cc7361a4c392c680336a9601129ea8373a5025770aa82fd7c3ac86cf037c0a733654ce7ba505e4c11fc46a9e70968c60ab40f36afdec9f555e3d8ddf5194aeae17df3b56e554cb55be1f9c9fe445dd0317ef2dbbc3b380d319cd8e3cceee0471833da93d37364228c7f42031453b7782e0cb612f34ef054e822e9661400ddb96d9cc6c41ef4425b3c5bf383989e99f47c479599310f6f220bf360f2d8944ac8750ac22fa533257df4f18ad803b8095950e553847b90c1d383bd183fe246c3dba8e1b125010d18f4b199d09281bdebe4ca4145343f192d6c9d1f9d42447f0be23af52fc0bdb0aba01a38ca6436e5e00a3f12b4ca613a615279777b64d12741848aa938256f0af2f6eb1f8be3f72361321c18d6352e56ff983d63d679bf33ff154a091d64732ec9e956a1ac292eff8ea6a8779e07576a8d9c91dcd373d4126060a3e833f6e0bcf7510d16b2b333c6d3059bfb44628abfc468fb67ca5e9e7270298efa4d67318f2018c6479f85ac78097078e483f0ffdef8807889091166895c16aad0031bcec749fdb6b83bbffff7c8dbfc8fe0959fbfa5cd55ee4450a05f1b07ba7a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
