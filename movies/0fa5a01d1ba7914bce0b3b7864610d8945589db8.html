<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bd33d9f5cba2a6a6b477a928e3a2f06ca2a58fb8b9cdf60c0c3b4161792d0b3a1024f13b9c4778837b6065e3e5077a5520b84e76829c9a5993aad746b6dc274218720cef05559c544d3b96c016f141cd5fb5efa35b9d3e2a3e0b9fa45bbb75f14b1666a84b59a27a77f3651447c22eb05f01e984ea8a57a054d2a4be95c59fef15e306475c1a5786e4b8aeaee3e812c9c9fedf838c5f9e87bf8c81bf9ab2da9c82d41fd7dcbc2302dab04b069f73f61cfd38862108a4d7d563180e846e2f51df8215cf1523c10a1d9d7ad1d66408a5191d3713c6dd4d0d9b8590eb12b7fbcc7dc269c1475775d79db21d5455ddd089c36036a354f1e8699459b52ec27f9197e5dcd3b08b876ffa60ccab984d1c43c3c35e70675b448dc89002d84828355220249e7fb07cff15c08de38dc0294dc9f8ebffce4ac7988c017f9771067144e7408b520a2e0fdab7927a7cb9f8f25186206eb6d2310762b471f9db0623c5b1449882facbdf34aa4dacdf70d0898605959acce34949866239a1bf2c6b3ff17f598574260ee29ffdd53f0e8429d0506e11bc030d1bd898bb75785f06d029dcf30a4d7b8c8c86a83dee048a7d8ca6b14dd6dea82af040bb3e7b07844c646c021c013995c4db21d65ad0acc36957bb9e9a6cb5851b36ca9ecf65fa69021aae29735f5e752332611c6f77c587746726a1673feef7666593d5e5595ff69d341e85be2b3bcca93ad6ce4f4467f806096d6105f3cc42999489a2c143da465a7726999a19b10769cca57ceec43b987d63622947ae124484dad630ead5c555eee28c4e2a97391c5d0c9ee844b7f7ae22e7f10d44164a10cd953ac7353fb999532dfe57bf44c8f6f8cbd1cd7aae4b9f326fe1c90a30c806528ec795008d90a86d92c65207f5cdac9bd424f561ad51cd182c4e2d79752faae559aa19235fe69fb3f3dfe7edf75339e655212e0f374de8b267ace76cba572e77f8cead065a9d899a3c3642893166fe1b0dd26a947e24bcc57b6f13a044a7859fa460359aa700077bc3361fa26805c06a397ec93fdd302396a747d73b989350fc8467b2103311e5b48fa89ecb71a30a39683ce944fa7394c8b4f7f8544ad64bd8d24566e0d0feb855382859996a60c3b35cd085b0e5ac87b4613163a86cfda631d15207b91a79d30d982008d516d6e0d29b3f841814d93092e22fe62d1fc9e63ae09ecb866b66563aa8b6b18dcbbc5de29fd47c68a000bc645662c2977c695d057fd566649baeb7b3a9264743a5dd8e6a416be116c991ce569c3984436fe602ce61f9a0fccba8f5c4308be423c64e0869528f4ff23b0c13a79a5d818fddce64f1102d2bcfff82f5cf806bb9e27f2a699e7927b051914e3845bb166920f1a2f8a5c26110263cf03362d7242ef582b52e80e0568bb70e144c809fd37eb62a2edfb1b56581367e9d88b0ae257210d9fbbd8cf1450eb32436841f33ac754638cb4709c897fac1cdd4475088da458e7fb086d849869782088932119c84d9f129d7764be0946bee308b97c265e59ffb8f51f6e27b44d5c48f82285b6d8f144903f7c39f5e8fb51b6504699915dad2936cb7aa563b28a33c51a78b0b8dea9265cf4e8528417da5786c8be234c2fb8c34691e1d308f9034c052ca9836da4012c498c9200c5e8489bb88698019ad8acf12597f46ced62fecae26190350280e9d95fc4190917c2701001872e319a017df73c7f4b13aefa626dce90cdd3f219ec031f3424878babbf1213c0af4f6da81d4ac123071c377bd30fdfd7fc7bbc85ed91776d680e51a1cdef066bd8961fd9b0b6614765f68ddc68cee2438f70539687e28ea593e6702b2a6eb48750ca809e74f319ade027ece90b3953b2b22d12a53a6869b4e7f7817b666abe8615f74ba7754e6425fe12bd377101679782fae4a84eb7618fcde4ff24b1c73b84182f788d58d53ecc0b37088d0fe99472e7a41b1fb1d6a3e45bbcf88440bcf3296aec82a60e417c19bfe6c84c6808b9f769269488238364f4ecda63ad87f2fe59fc5ba8ac2fc38f918b374db4968b9a392d7256e8648ecde3e40ab695a52d25ff702b90477b0aede5449f2e4762518b3b2fcbcee3504fd399dd79c451ec2b3e72d6acbb44dd881ec89c533eaa905f726b40758f5d553d4ceb23251acb2357d891ea16231bba67f37b67cf26a347bd66d51c5538e19e6ee19ae004f290866584d38a415df6fb1f51c6f26459ec680c3c7a85848ad7417e05a3bf27b64686cb6508774b44aaf6a6f5652ffdcc842b82d46c4d94bf9d53377ed26dd6882db32f9638b8233bc2d4413db9537be0b713475e551f9458a2b1bccc4f96e38c0c733ab0f11a6b6312b543f31cdaae11939a2a7217e677907b09e5a7aa42b227a164627f9e9cc7fdd4667aa1ed7c9c9e0c5d46c07ecacebf748f33129971367b9cfe74e168c689daca5fe5fffbfec1d186b34d0f85a1de87e1f9a4261c8f6069e7adf2462cd1db3bb212a0846eac9ed492c71fe3941d2b37be3fa8d249e42d231a5e43717e9c043be3af6536896ce2422ed5e8cb0cbbaf9e6a342a5ff31b8467b6d80888c4628b06d1bd76e95f6e099fa035b0ceafcd42b618a0251bf16b52b4fc4efdbc65129b71e2a318987fd16dd53b566e94ba5ae562e51abda79d4a7a0feba688ec5f576a69e5dabc149d59347d1e1f1fb80b93bc15ff4ad156802137e6a239d6a627490f0759dc8c50f156145f806450e140bc22c24491cbb43cbe3ac88ce110a71f2344f5a1bad70b4a8002e5d0f247cd4b67d7ffebbca8aba5c23e9eac28b7a84ca92f4f7d92f6eaa7d8c0399e995db4b65263a0714748b9b49c9ad811e64484b77e5dc922592390405738b1cfba7506caab2f9965dd77f14f22464804a7f10d889e003d1cd9a8e74007006b30ce7ec087dfb348953e0d588bf761c14b83af6e8df36f518682045113d7eb5d1ba48885bc41ddbbbc1842989dc0e75b87c092485c2db2bffb3fa6dcd5cd925a96ae49f6e2d59cedea57880ef13dc8cf47116588313f37953054cef700294899df828a67217d89bd8f49049e4a18e57de4b82462299f6130f0d2083be0923e3e3c555a9d84d9522aff5ebc2d82443d7436f660eda57552350adf6910a4dc72efd4c77db7082fdf1db10cc0d6849757abd608221e30e1fe3156a5aaa212fd35ee23318d43e14274f02022dcab5cbb83af4dec9390e14ef8c316fb404cdc247bc496324091b3b9e39942b1a9d0e09427b5f4147c1e5bdef87f3a8b0972e8a6ee5f4e0139d8d712062be58086291ffe1122d652335833df0bccd81cc80104002b7f735aa63a82c65ab52feffff14e936badb3dcc9e279b480571f4b2bb44c9a8059c2cd7891664991583a508f09dc5170ed1c5ec7256b2ca16ab3d6807a66e8fe7fb5a0ef5a9fd608738991e8e166a642e0dce73361cc669a79eee8bf6b102f7b681acf6e4c5901ef69ea63f7c50d571b3e17b93bf3d474342379a6112d49423d17b3335bf234f8167c85f97108615b4300ba2d1adf956e5cdd2b3c483d4ece361b0bc5f79c4918b65ec10f4736da8bc0ee6c5a5357b4ec6826fa1f15de8d61273dd90a1644e31e813af2e23f7e1843f6a36b1b34aedadd3a2848bf52ae7f0491d2a9f031aa5f4af4a18ac7bd4724407a49b8480a980c18b8a45aba149882f0e8bf1f606d38cb554aca6fd2a254fae9b2d8afba247be06a99414412414209e1fa37d502b46c807423b69d52d66fea3bd4eccbe321ea6773ce0e9904614ffe3c5c29eb2a7e20289c67329d06d42204cc8eb3739b5b2aec9ef3001009de05f74613832043f70a9c8df1865c5df2e01e67c9649fb0e601490e5c737242fe2406b8a1c8307d1d5e6c7fb074985712c705aec9d361e7e2bf8840243e422291721914671dca7b6dd8fd10c3803419555a112f4acc298eb304f12b5de08b9e4f3cc8e9ca233550faee0d51455ed2bd6dc63d035d2115e1e6afd9869471d3c160eefe11f59fe1c96cbc47dae6aac0264fb98d86979d633bde0f6eecadd01aa06fd7fbaeb4116d1b683e61fe209fabed4118908d4c37a1695c88508f674709114c8f7303026f88cf1665480368868da61a0aa2e26b2c7ba58e61156539ea06d53670c9873940f954572c949f97b475799f72383e222e2279c08c43e8b9d759df872e6ed14b9b62b044a956dbee5dce53ffc75fb6c683222eb4cea395b291c7c2c93626e7b9ae66349ff6397785617203b17c11f71f6e6b65ad6fca1d9c288cd398fe84e0a89ed24ddff1a939763d107fcf3290754168abefda853898be9196e7906ba0d3dc163a630e8ff9268c6d4770c1d595a9077b590b47557035c18326cce74acaf25d485880c0f1b8a3bd9abdbb29305482411964b76658f3351cf7834dbdc961e8a99f673c6ffcb9603af87910facc7025a6f4e24dc9cccddc419af69a1b85ef862d8e671b6425a76ce5ed9cbc628c0a3e0c360091fd949f828d515af57149ab6d117a6a3b53290adb20346f492fb430a961dda46d5927f510905f36084b5e79d3e1d0a12a667162138ef658ce173fe95ba06af90fc03529e979d27be107b63a8ed470bb6b71f52800182fe7abcd436baf67e26f4ef96a72cd25228a5c6e783200464fdc96eef66e0110e4f95870df52f50f7ff85e5c051d5fda282ae4e1b47ed926fe8c8e30f42009d350dc382f5a8f90806cda3cb344105d94e944b9946f6544cfd546ceb45b49e02717b28f27ecbca589acb54b42e7cd1717d27655cca2d0748eb54094d0837f592fbec788f53a3c1e986e9cea5e4c1d5c880fda67607972bdae1d105bf6c05ddc96b264190155346dd1323ed2968c679fe661d210856b47b18924f951f017675e3a2eca972b68f7616e7b8128d05cf74f9434f2e594864a56d92185ed939ad1a764ff221ac0bd2fb0d117bb0a469ef1f42d138ce5b64e7ec7cbd1c63fa0ff1f3a7228d93ad867d272a66aa46dbbb9ee51e418b15cd48326fe8a3f445f16bad3d68d83c4ae08fa085ec49a8d61036a3df76a6997789ba4d00620fbd294d7ffaac607a11fa03ed091c8325e6f1120410740db5f2dab56f702dedb2ce3130bf9cd54bd8d671f238cd54c13f7679f417634794998a8f28d7d2cb1ed7d2ebfd2717e091194c24952c21d411aaef5b7671c37facaebc621dd23aa2e7e7b98059b63d82903a5c2fc9497a10a2abad0f3afd78ecf470c9cbcc97681802ab29ecbcea764141171f8062969755dfb2f2c2f25ccb8a958f62cd38ddb7c9c402c0b19bcfea95873fded74cce292e2f71a9ef841ad132e406b97bd1f4a410bfdf6ec325a0768f5b698059b16751bc18fd4ffc96dd2d0ecde64a63b1e271b8e6d415001381fbda8bf4e8b74a330e9e247f26dcbcfca4d355f2a5742a969dd95e1fe9cb25cfb40a1c43f5edf01ebd006a40eacad7e334cc769a384d38e3f23184a875064b80dfb618774e04c27e58273bbc3b381ccc70b6fec89aee6552e023639d6cd674d4aa1598d277f073a9a825a4936c86da59664ac559a1b9caf4cb77d64c7c6cb432697d90797956891a8e4f6cc8b0247968e9fff8083547d7240cc5259bfdf4a3d6afc4d8cb39fc613baa8b452d146390355c2af9f96f816acea5bf4dacb61860fcccc8bbe0a5380f7fd7cc033f2080ebcd6f8cecb23a7c4b62f1c7857029816d0b53d28cd0851a49ad70a9d4e3045cd0106a3d6ca736bac467f47dab32c7fc765ad00d96417a9d07acd1e878739a69f63fd5ed180ec9a8972ef7182ea05cf8b7895d35158ccb3d18480131308be85ad216fbd15303578c932c02073142462c11c23a73fbe54ed19b90c382a3004e521149c8a03cfc35a4b85d43cc99c3c95c9a555436574918dc3c19c07ca93d84f6a88246ea42d04fa8a14efd54913c198d423ebbd4cc3dfa963f7f1e501f27a4ebd2fb2058bf0cba53f73d6149ffcdb80ce3dc99395050347ee518db0de8cb3a9e5df97524290b7da13ff3f4a49520542cb5e45f8b12caa90028a70c8680e6070b3ae5543758cc11b6d51e7e9940e52e5d35727f84b5f205e3d79ec9fcffcedd855f890b3758e9741e2a1bacb4b1cf4234cba8b21d59e020cea1be96f9042d93d8770603170319740ec941e0c71fc4b05c15492dc3866e54e554437a17c069d4b75aec98e1d8958bd11e8d412e0ff1a22b3de3c5f6648470c3a21071ef68c49d5a03d95ab9ec08122a94f7123cd71395fd4da1bbc6804ecce079e2dabf09cec5497cf6792a7a38402618d779f178745a9a36ddd48a3d3e13add63f8c6724ff2e4050abebc45d29a319360ad96bae3d19342197ab36683a28a6bc7b423d66291dd7c1ffdd87c40d58b9c73a4ff83c6934c03024d3e728c86289901c2459b92c5926a29d8955d807ad06b982ee5a02f83c08e3757ff26a58d7b927a7d29bef7f3c168c8588ed3c4dfd96adceacfe6a5916a75ff4c07d8038ca2acd5fcd4f70d1d7a9c9fcc7dbd88099fe5d2b32878f9d6debd0818666b4c2c120ac50aeaf8521d0d9717e58365a44f4de7daa24dfe4c6062d4994b7c74a21f9b4ed7be9c6cad2f18ccc7323848d678aaae9b23d641206a5dd1dac51bf89c03e311ba32f1843c7cc9b0abe53fb89f3b8c12bae94ef55d61a5b2fce479558ba9ac35b3dcd4c0223c5a8524a9ed99b06c5d2ee7fd63fdc07b6dd3e17463737931117efd8a6b78ca1b2fd7edbe998a45b5c8155cd227d934bea2d4efc3f7f5e0ddb05e54a02641c057cf5a207fa7dab62328de0f9e96983c489629595564c6839766753ebd14a59789e37cdee02bf6da0a6a9b887ada90a17770644d562b147f471a54b958b3a1deef2cd1d400a0096419da71e0951c99c52e275f5c71ad93131033214419b2c9af7218aaa6a73cc7acf4d407a09cb7351e99db3cdab833f8fbd17a88291e6c58648075b70bc605734c47184343620729d31f22aa5eb711aabd33c12f0450de4ceb8cd4b63fa1400e875ce1e7755bb9c8b813f6a6b836cdb53ff5c8fafd026e91502f9bf21bec439ee21caae18c79b5f2cdfc9749a0346b07b901ff26dc8d14341008601dc673808873718fb4ea39af203c684a5947e1a5aaf4a4ed775a0a3739a62e1c62ef43d20e0a7aab146b46ca25d6f85bf607d31ea592f69d7490f830b39867ea2e1630413380004a24b2eda02defa4d440c06c473c7a6dc9e2a1378e479e7f1613b726711d5462ae85268ecf2e3905ba42707657b69ed3a90d1c6165e18d671633ccc5c22b646245514bc9369256d67de22635fb2bafd17359d13780ca69d2eb10f8de9e8138e2c200c06b9857724b69c4a18e2a178e4ff75f223244f378bb3be7a91b85dbde40b73e80eff18fbe6c9e7de89887fee6ea4f1007f5df54200bb1dc6cf968e2246842e5eff2708bc1678ee8fb68e74bde76a510f96ee3e385e7bdbce08cd94abd890bea855ea3b9713a993d2415eeec1e422576f463cf9a9d539ee4c446280ec312fa1e61d8644290e1f593c830a5f41662148d7adb7446a0ad6c155bd5d964eb0685b05cd51409f917a339cf657ef2ba5e378a8f0a31abdb490a120e59af3e9aee61db3fef07de3e6dab2fca1b363624d940af15ada88e1f018671a48961bd7fd7788b8eca27dbfb3b6d503249f555067ccf8b8282265be82e20a238efc218f5cbe859c3f15bed43cf83ec669002e7586cf349206a95853fbc3efcf045cbd97db7419f65a5ac951b488c1a085d4c2c7fb12146bf994a9d045a01ba8aabca98a6fe990b9f8b4238d575a9925e1a57a4c44a95484c5b33ef601092df2e8aa124733f91a5c6b93cdee35bc3b4f7b657497831fc711289713e70d4d6b7a7fdb255f9be2c0fe24f0fd5e63bab79e504ed12bed4725133be80503461b4999716c1c5202208799b6d46443251953b94968f947bfea0f5407119cb2c6c3ae8fe514e53e8d5113c52f5706dc17fa5f6b6d5f073d367f13648240336b981ebf83064d8845f48de673bf8eab669d28b7938dfdec334718171168811850d3cf4d94cbf3a12f1c21b47708834d3d0bbdb5cb9762bb2ec96fd9c23a23545fb4d0fb59e842c6025a1ee397df16fd03c8b950b4dce00c90c4d80283508e5c1e5f90ab41f76cb1269e1778004de93de4aebaea0b5c40fec269712376addd9e4b528583d74f1d6e799de6d1977afc543a9408716c7729b2ba45a910bbb627363b6a81440f15cb7b8adf03ac8654d4b17b9a78cfac62ccceac3e5828f036e6b83dccaf41d0c9d7ae7d0078aa4ae346792df9018ea24f6a213840fcf4e0b8514a4492d57d9f9d436e0f2ac014ededbc448960c4ff452091f4bef7106cc097626a7a16cd9835f9215ba97d0305f27bc336cb9148266a27154a65841af27dbed8f9aa1620b63f9d2e3cc42e62ef5a70c08e9280e99ec262356aa00d8261e73f5ad3bb44e0abf990980acd683ecae2842f613539dd9c7899c3ff612f7fba6a50545b2d3bce52930cb2453ff47a0c3fa82653a7e54afdf8e5e0cc324b0bb5587e964737c5966e8198d2db2a1f510738ee52c75c71a77aca18ec6782a3f9ec9073fc524eb213d03e65175e92a85f1844898094bff0fa838eab6946e623d10b55bed08a1d0830921e01374872ab9733b976f758871e295be7df423a18533eb4c778bccccb0bf4067bbef540d22328a6ed6a46a8b4fba6823f5f04760b77be696b8aeb29958939a6406c7100948ecdc86aafb0ed82726f5cc38f9a1f49c22f8bd92d1d6523341b5d1edd406ac125f82319357745b44c60abd19735a6aa1907eb1e6b73b45b8997fe6c91bbe20ce841ce82e2ceeafd396390dbcb7c18ef7437e814450cad3d09f4a0c49f1bde8e0d92b70eb874a0e140a4b5634390291b107084ac4aa375fe40734a4ea012ed5f8c4660c4d010489a9c70a06387f060e56e256efc4e6bd77e4ddd733417c0e044d744e7c48596690f53b01c1d84937d19579e248c44ff9d1825af4be29e7b8faf52034b4f62f6b6c89e5201602f184e14a435821c3c5b8ce03aa108ee34c68210206415afd32a23da792ecfdfa299d7997181afadbedc824e2411b612017beee64f625d7524990422b911a7f0f720f7e239815800baf6e673e633f7c44559f8256fb784f947d5fed9cbff619638b0badef535217d359e18baea457d1a474c4b70be7432c2f9cd8eaa49ccd828c35cfe63e231e8051eea3feb5e55fd2c142f4082232e6d046e0c6c7f8117b39c0b7d1ec64571762aabd79ea9faeb75887d72a67f71a11eaccb5d12a82820c64aace7a3de32fbcb74b2f45a7760365df4f5a743a12b6cc95fda0e3ec2c888d8e2359d955bee47c72c14b7c1aac7338ef11a9f40650a29a7f68edbfb6bb63a59dad8f92d9804eee67112c5863ae287bc6522a0023cdb6f48e50559dea63f1ecc7152bd355507deb9658107aacae585780c3c974337c8471a83b8f06209aacc9cf1c96d7d983059aa9de3754bcb929e3061ce141903774a7fdb54be07fe4b63637b77582c0eb38db982aaeb52caf0191b4ab4cd3e7bd7b4a4ed6d57bea5c97821d47546a4759f007d24cf9052c8e2cfc18f4dd5ce111a418c75f813764ad46239734049e451735d03be15ab24f0eb2a5915332d66f8ca14957f3cb45410f2f454f4bf2178e63d87d75cffa022fe5c9c02d6535958a236a8cee5eb7f113e833a8d9c2042de27d3e9644046813aa54bf2012e8ee0907fc1d7a3eed0d0aaf9c0d7ddb4bde91d36efd3d148006df89ca4ae35b5a15b1c94e7ff7ba93304548fdbf42314dccac2ecbbd2c07c40a8e0c485d230bb272d1895b6f9560b13131d4856d73926f9cb968d93f997268f8f2a1989c93e3b3c2592803e004654dfdcdbe1028d66cd435aa6df001357861dc8138f9b9c3eba64a4cde230d90d5847cd00513f2ef0af175a27b888ae892b6b4e96b1164b32117c83bd9ffa188db8c1873e6638b451552744eed0de1bde733bc6545fbbb569906753de9d728ad794c7e069e6951f4c3fbfa0018cc554b545acd31a7f8054725d86db511ed29cdbfc424c25c537d5ec002ec7e9a64605999e1811f67fb93576c184ac3f6b73716fec7f8d75511a4f487e0de40492f9e662a2c87696e7b77960e060e030849a551cedae52b44e36e71dd78aecef7a478ad83413152dcaff06fb0b9e6c042b32701b36024d3f2920f8c673d0aa5a5e7b6e8bb9bc8cd7e587993852d006cc7e81a69919dfa6b26dd222fc5671e8d7ec3d0b7a3918d9cf6ff11ccfd225121cf40f1804897a33854d6435c1917c48d8abcc4334db4506f69374fd44191cc9ac56ffd5ce98add9fb01cfc44b412c9bb068b67ad80babcc41646889ce99aaa514605da6004627bd50fdc95cc1a39f2a386df51b55c61568cc5b11f2191ce3c1b687e90d4e0e09be12bf0825addb0aacd8cc5397ebbb07cf27044c77fb2435295f7d15f728603196e4a91938ba79c5a17baf381be2e8f49cce4ee027d91dd6eecc61c9517341a443353689f11e8cd1eb95c362205793aab3f9f93b101885d81c2615289c5e49d660a6f088c27e654259e8c1604ddb294c9d63141fb1cf75da1ff747cc5dd7acf613219decdb90e458403d53dddb790226506d882105b69078ab390750133ca4a700e45bfe85e11ff987e7cf23eee7bc8b8138806d0950de98c1e02a0c69cccd5744b9514d9bc6493498fcf166b27f0ad245e5cad6ad0112f6e0357d5569bb6165c49bca1b8b79177909885da5d33fc345ebb327c4cfc8c01105648e58fd724a308b96420a788dc6d18b3e17cc122ad37fe0170c88e913614dca0c82057d7aae8844763200ffabd634acdb812555c56d50e711eaa91f293a093c0d149f16fe8bc3a8a3ea4d7409e40aa5b48892f332487a6011bb70ee71b90eb8628519ff2a689f13bef455c4efe6f88ee55ba1f40aa85720cea9d5be4708f4c0053b68e8985a1e1be53a5739e2b43492091a06fb27b98a23872dcb45dcc8c544be69fc7b341aa0b6b0132ed4e58b70dabbe5ae3acf59ff64002788df8e1da4f5793cb2dd1493e643abe2498300565ebf2b6623af03b5ae7a67ac2077ec27c12f41cc867477d1e1c3a986d69b909ebc6e631ecc657ee63f9c3c8af0f3eeedb200a0aa8605c962e49ecc145f022a880998b6ca3abef7f35950db28a177a7e2006f6bf0e2e50263e96a38fdec57361208eeec1b3961549adae28ffd307550d1d34f822fef667bd06de5b6eaaa4237fe86e490ffd9e85d0d29fc5a7faa9dc88537e31576c1f463df0e461f7fc4b2f2beb93b4ab3dc42718caf259e340e9151691027bd1554e6b78560a79aa7d502b44ead71356166a3003df9e15e14ec8eb2ac4b031a2fa46110c59d444de494cd593b706495815d3c7a2dbd5a0c2faecfa87c4420fc379b65de5c4448a5f68e704c9464ef0084c66ffa4b177d7d011d8f0845d6d33b3b25881fb7d34784eebaa4aa378f44aabaa93e2ed72ff0d91be9d276da1c5bd39e886107ac2c488d2d96dedbf184258acde177cee8f9a1df6da1d84b62b63ccdce03d60f1ac8a3cc80a58f11f60c2d706f753ade3168e87a9e76bf17c65bd432237499c4755eff3f2898ee3dfa106213c26b6fdf087517a540fca85591d1a5737460de778ba98b59860565955200a27aabfac84fdb2e983cbc5adcca3fb7e8db56ef74fdfe0ad0d166068e7bcb7447bba0d6bbde5d9e34417f578e6f4cb45b250563d2f08635259e863ff12b23e9eb9ec1d706439f56745dd1080a6bdd746f4b25fc76554f4a5b7528b3fae3c1fc7c303b5a162115ad771e141d6744d7be72c481da088ec81fed551db0215b168356b184e0d65d23284f62e6c7a05381b46f03bfe2f98e2f2464541f48e87f981f8c062ea2fccd602df52d39c4a75cced37d675c43b2209a36513b948980d788653c9aa1c59d2b4489530ba488c4fc070c145b4cb69941e5bcba087127f89606c75d3a76229b52ca09d9bb983dbc9ae510e12afaac84ba36dede2860bbf938be80f68b79b5de879c7465a516bfd0f9d1bed6a9eea9e928108cd1cd66046f513300560b07e335c55b315a39ac4e09ec5c896b4f385ddfe7735554b66564dcec8f2826cf11d8b1bf7f4bdbbf0bc7bc85a39a7a5ff429c8c901e461d6ae218ac8560e670c137ee5c31f2bd1fa59f72755d9b173da339ed724a9a3305ace4c7d1081405c8a741da3f171aa5cb93028c0506d7aaaaec09dc76c02f3e939b69523786ca2feaeae9c9d118f4bd264b74bce2010062fc11375fa0ee239fdcef0522a51fe5ed814ada47f505010e1e3fd9c7af2cb80461f20eb03f58d22089106a21854cce7d5c720b959c16a43bba79666b0dfc9a84cb4f697c4a667fbb96dace6eec569f3a2e44df9ec5522a54cdd8af2e186bbf3cc80eb85cfd4bf9df07ac745219452120f17b63f34a643d1bb634281edba23a10905b1f5070c61ca16eac80dac5d29efb279705a9b431f14dd969eb8ad1394ecc1851167f8db6ea57f22ddc56ee6b14ef056c440ad2352a652113b6b97c364edf467a991b0660d2ed54079c23bfcf3a6add87ee49f78b44686fdc9226b03c7d133a49ee2473cbe1658bd813f42e533501ac86c00f092a0d787b6f80a7514a9ed64f15829226900a2d9db56180b3e2864f7c213873ffc0cc8bb049e34518dd541c40e3631d227767630b4bb014bc7792802110c5a8be6b88a17f2356ce2d14a692563f663761c2bf3ce6cab795e46d243975caff563f3a472852451aa67b16802e7643515e6de0dd8784833dff6e17887aca5d599cbd4da9946181bc17e437dfb45fef0c4948f5493235ee17aff1cf19d07bf35db6ce045c6692565b4b69667638ff98d89f892531d9db89607de0984930f7ed23746cb6dca4ced08a220064fddd1245d12cee02ce9a3da9638494c9605b447046372dd16b3a38da25d1749cc96e1ca019175ba9661087a48100c6618218ec6d162177101cfc935e267cb200cdc0cb2a271cd63303e202794","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
