<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1308b6de90354891ce8f60a26eb816da34731a1a2afd641ab19bd9778b94e0e3085bfbc69b7ec7f7b126309d9158abd38c23c5924aa4b68f0296b1c85c8c6801f3b6001b8af59550f88e166dbab1215c4d959f7e28d18c4457c18de77cda81d42600b21acf4510185563e44b475252d73351cc380ed55f928e17ad46b1f6c79ff932108b7c70ffc094a699d28f8ade79a9fc3e0068394ba96b0f230e7cff7d4a252df1092b5ff4d4ec9253c64f19e750c8fe2212a81a241cac67433fcf5336997d9664fff4fa1ed9105ee7151ac9c7e9f1db616eaa05d50976358503a50d180254a7e889f7407d1667f6a610d9f35f14757742b0a9bb9c89e5ba4920a489898faa4cc9e5e483f5c48e04dcb86986d48b4b60bd0e558b4e62170af81844dcf5d547e29fc756591e7d86df9426ddda7e292615995a3441ce97524846b2d3e4d8abc81a676a67c6aae54483bc4cdcb45b56673dc839109b9ecc6db99e0e43366251ce1e78d9de24e988f1458126ff1ea20b4e723966760272b9ae37b306921118902e3c64acc525bf385ea284301bf46520c18fd1cdd5dba90e812d7887bab630133ed48288de4c931f3f52f6dfda77adac6e8f901c2f1197d3619145e1b2d446fb6367c823506eb1309b0aafabf97a0e715ac193686f27fabb982ddc2642f646d88e646185ed8a93c069b94087bc75cef13517a858e877f7571d4e0e6bea97b1ec8090fa637dd1e75e899c733c1f5f52d3fb2c4aebb89dbfd0d4ed27a048265bd9b136f1eae8efdea1fe6fd63e83e5b206e420e3ce88d511383e6b10264cf2590d5f9a59e93301689c2592859d61a3a149b262f077acb225d5ee84d80fccf30a6b39d2be09bda2c9d463a014d82d159437bcb8fbde12c90dadf2d37284e523490e97815a5399337a3ac67137403913fbc72f04e2ed7d104940a4fb0ce7bedc96b4666ec2cb67bd65541b77250016a32c306445788762ccf1ce0edd407e4b4b6a0bae649a8f45ecf14dcf1d39165f315463427c9023e0eec8893c3eb948e222eb9daf501baa349ec069f74f3d78bc9f4deb99725950cd09a70a3801755bdbeb03bc0a0ce3c8a134ebfffdc7039c1050f65456e3e45d1b6a2e378a25a7f2caacd179c6562d628971ebe9a148a17df4bf2b56161fe8c965b4a51796c4cd24aaded2066aa1a435df9698f0e1adb7dff51a81031bf207be7692c3205eaa17aa4fa55dd31c6d92c1540c161ee4d91493bb49cf263f35141b7b459017408ef0bcda561ba0125e018fb935b68c7c3f60da566aadfe17ed8929387fb55e1540b4a7fcd6cdc6352248126958b5bf4ebf5253175c3ad1436c5fe80d8a4c9ffa5f25cd999cd675bb79d4d8eb728b1416c9722da5811e61082a05778d5a5a7bf07ac381ffea59db35b904afa8e3af2bcb6d74784b422adc217065c54f874706e90f8715e39c129a1d6a2a1b9142d4aea7e3f83ab2935bb6d14723f8fac3f843818c8d67abb6f692734c60a9f9f7d97d9033cb5efcf3cf399c0f4c4f9b04107812095cc50113ed1e2ff11e92f53b5f864c22fe82531dab7795222e38472f5ce96fb42c9a2dbeaf8a9971a26db1561a7b9a9016ba9b5c78c123cb96cded397a26b5ca930c0fa5cbd926af467b49a44523d6bd27382524b2fe90474113afb1918bab33aa9c557aab1204b62ba752a5abaa5af14984183ae12a1698933a2c4c812802965b9597204c26e10ebe3653e5514735c5c2a31f957e2f149350bc3efaa9a8bdc71ac49b3f43716da5ca405131e1bda40e7404cf5bd73fa36a40c2051d339e5ad17f3c3a5b0ccadaa0b09c1d5311b94504f6440e59698558dc4bd00c1a7e03797d49c4da9132aadbe8a5827f1c4a09ed08c686e4c4d2dffb4c382e8e26f8dc457a1c6a3c75260bcdcebdd088ed565ec815758552eafafa20f71dc0c6f7c1286375ce3bd6d0a707b5c25d5167dd9310c2d8c9587aeaeb8b878f747d88c2b620c2f98ff1c209dbe2e8be895d357ce0f088c7aedb00926019c86d04bad3833050f53d5c5007d83f227f8253a285a812cf41e95f63a70a3a1fe892ee9c0894167cc3bb4427d49e00c89b747295148a8bffaf514fe8fbd7cbc1516149e4f7081133d573bba2e54291d6083336c397a951a3e5ceb053aba425030d15d450ffa42629b906728644725be58d013e58110f6e5365fb7f68a9e2bff496e958559fffe98162b5b8d1db9bebb4e7728a545ab37f0f74d6b0bac24883330eb268aa4be977fdee77098fee9d22edcdb94e9c48d1e24815536288c491b1d790e78bd2aa7399acde51d08520083b69bc0e7935d8a2f096f51091c781e721c09de9abff3e03c0883f5a4e781fe51f3aef6de941f397c2842fb784d1ea1202aebc40ebb27765de65289eaae5ba5d9f7049d4139efe9b462f86ca482516a0dea43ea355f81b3b8db838097aefa0a5abe22140bb7569415552806956962c84e2a0d0ae18c1251ab38fe4921087773797a798a319fe3b8e9440c780c4b4141d3a0ccedac870ad3c42619f16f58522f4bc993488007765a9e39ee6a421501562620ae524ceef390695099e74e9f11951a964b31ebf5a313d0d15f22ffda4e0905f6b9804f0c5bfdf00eb28f8b120d6c7eced0343dbe0d7234c0cee4127fb533008fc552d8392153eef183e12f2b5696f88d0837bfefea2398174d20390ce398831bbd997938b8783b66620715d793e801c5c243262654aa834f3b249b865e211d01dd237e07297194db0e602144901cf522aaec4872dfb3d38c82221a8c28d18880c52063d1e28c36987818c864d5b03bde023a4352f405c770727f3f8fae14055d43e66bfb5d07b1230b7d3f1f4176360f707afaa7e0a5fca137baae9035ad205f1b5e0d81735ea13bb672f8e77cca4a65a6211455cf52a0605f40aa209fad96c1bb7563c60f769b91d7b8fae7e351a24b97386d3cc703223e67244abb60f5e703284103b2179f24d2a3d8a6dc5c7c1764488206b921dcd2290ee8d6de40ecaa0ddee67fc447a81f406ce422af8ccf0363fc49346fb5728441bc499be484e04354c172e41cc10cf1775aff340a4b8bdc9dc0460aeb44f3a5977719a90a8f1f9da7d28856771c7c54b82d7e680068606d67383271d4453d31719c4b986187a32dd0f352df993c4db2108fdeeb29d56b280edfe47a4fbde215883926a43b32319b123527de3d4dc5d8dc224da50500311df41b6506ee817e422ef92e5e5ee01c1d3e37e7e8ded79efa97e4bab4fcc58c16c0816eb90d244148cc41ed1ba0e1ea863b00b63237c312709ba47a8f83b40abdb7806f0be6c79559cb7379f386bbd7c8f0d4f2e7dfd09e35307236f09cdcc7691f2c6f3844f44e02da75aca38def6f9924bbb904a0bf53e095d07b4638c2698cd91b565e11615fa7f107c3f6d7689f4b2accb8ee1d5bd1d00493f5bd3db15874ce9adb8f8c56f7654f6aa6b7ccfce4ae2d963f3ec76f3a530784879979d7d88da7ffd765abe100f90e395f885ad4a8e37dec8a73bc375287480c3d4663dfab999a737eb38b7608b1523c4c9a5c0483e0c5db181c9bac89056a412a648237659e916cf27a21e31200576376a673f938149defaee09ee82d327cfa54b92dfed2f9c3b9342b3a5b1000ed4f833955232dd70bec266d5c8b8f2e7a576593193a0e3fb284b36ccb901b856840964fc5e0f8f806b06048a92c486d0c79c68c637a1dfd20fb532f91b2bc6ff706126c88e3a39bd73e408017ec2e34a1e794890ed0239f2958eacd006a65ce3fa270e679acf1c0d493b25f2476eb153362a7b8425609eb77795182c9a5dcfa74cc248317be8f52c574da2ffa7dfd41324907201c4c210010144a09bf74d858dd3f3b29233db0b5039f38cfd918a8e0571f6c06b613e9114da7f57bc660b8e4401bd5564d6e445df9cc9b13cd5834cb2f04a1a8b294586aeb219cf62028f86e317b089f4a771f43754e4b1b8db188abb6b26d8fa4bc5b6238447581f4082d519cdd81f204af28f5036840b7fdb78fa5ca4440d2d41043e5c5751a572f90f6105f3f2b3a4fb3322ea9fae6d54ad151529cba9c69b722a98c3c3b2e0b66a5e3d7fb2fb0829a6be532bcc2b1dbaf5e1c0b16fe77fc4592fc7885c6c8a069ef38b9331ddfe57849e33d68b990e31a133d8b75abb3b5e32a08846687fda7284665de64fd5ab4302bf500a3d746e40e0d86736785dcd21f39ed40c0ed5b787c41bf7bdcfb89f7d8fabc583bd4956be33823242e5ccf1e47e6a85d3c1e9eb7db5a3b1665c0633dfaa3e58a4b02ed2e291dc22215400d8c87299b5fb3d63113900d95e8b5707095bd5099685f6058919c48636691c9581090b5345fb0faa32a43648ef1785edc21d6eeba8113a8c3574ef0d52cbcd509d6e4916384785681d3d8dd928995728f51331066904ac0c0250c8ce3e9a7ef7d7c8ca8b7ce619900f0c9c2618d98e7ca322e218b6d2c852be53e6e418b1f888e7c4d954677ef9ce9599c42001232a0e6a07d48e2df3bca8655bd3582ad824cd47c5cdf0042722d87577775ce0eb843b7bd9171c7ace675f54428687a3c2116123ca9fa9a0895d3b6ba327d33f1d3771f70cd48cb7c0ea3de613b399fb27e297a492644190588503cd00a511fd51b6a960a754d208190af5caa64762e863f8771c55bd2b1707c830f1574fadefc5f0e46f5bdd47c687f1a9ea6e82ff3f9fbe74aaf856f94a835059aa6d447adcb11d75b779c5e9d15c7378bc81dbd3cc69ba634179da0b3e467908ff36533de2ed6b223fa7c72e3d7e6e11a9beebb6f9c518c7f40018558f4d26c5c8e4805e629160d6712a0e4d9b87a7455db3683282ab6cf81eaa35281700b0fe4852fa157f23a34355e60760f89af4dbc50ac11d1cff7a4f19c02cb461b53da42a28b8193827f2e7d491f0e9edf7cedcf780f740608e108b305dfb607dfa3c339a722c19fde5f4f508dd10d874e1e905c9421f6cbd5ca1813f0e8a9fda6bd330e38785fee62b1db8ca002700b02907b7bebb969b918b1b46a8c7b9cc84760bd2bce800cec55925ffe523de2c2a093b5ec64926610a9116a650a2a769df11a10a50c5b0f09683000c50382945b6404330cfdb6111a78641c01ff4eff9687267d0411c40bb6ef07c8d58b7f079e387fa48f6a290b677fabae3ed6569a5730dc8e982b34d1a8272709ae4f9e437e66f13aec133bacf3ac0672d63168c0a952e1aad4c406b981215d02c6e2231809ef24413c03b50ac0eb3f12916de971092c7f6bf179d6bc7d255b486d083c1007c742825ef534ec53a522961d1ee2c6f80831104276c431b5e9f10c4f1c67c1ed4970f8e18a42c1d65e6e8decf59d16cf91939f0b5d9bedc509ecc851cdfa924a5ca71beb00630929e51f24fb051f67bb888fe9c79cadb107cc0ee9a8fd249c887573476144d4e594ba2b9af25337c006821a589d2c1a10438d7530db9aa9f8bc4884fa770880a886f61a065a51b4a572929d2e881bc36a3f0f6320030e1244f8ea61f85f3662dae6230e306d502968ebd5cf204b4b0002c423aaf7e98f2442056cbc40abfbd245e28f7479045781c9e7585473e95f4342edecce4bcbbc4f11061ed35335fa3e8a6a5862e65cbc2eabc7b73d62e60e5b73a49ba50dca99af169c34489d7984a48213a1d1bf7dc552c44fd402f81b36a70750998de5bd747186baf7e6f6c5933f5587ca53e32527423388c6ef631d1eb9cdede8e524adb784fbc259ef426d3da6022f4fa7df733ff3983858685820147df59fe8edbe60ace2eb6896af181cac132d9128be2f0745c577ee7fdd65d4044e4a051599e29fa20f487a2e3300746207be67e55ff6e72a56a3221c94e2f142e97f62d962adbf2aa738fbfca09d52b9c58a2694408288bd4b81f82498b122cd56a6bf491ffbf2f0853e195ba15d9db74f4a66fd74940f5fa43afe39cc1126ebafc1de2ede6259b102cd18453087db05f4eff35caa42de05b5344b421f4333afe7ae810cd0a7419b2bb530c695e00d3bc5f5cff8ac045ada791b7db309a3c19f7455d81363b775c1510679021a18791b493dc490a8cd4ec95328534dbb13d3052d7a02d108f077d0d2ae2d71539782fd954b184d73c70c639a05a9282f10aa642d37a9aa6c46a96a19331dd397f308c3ece18ff66dfc65b74e14f8c5f5e6e728827e816fe38fa50b83e490b772d05e6ec90d0a0928b4bbc24b34ab09e3ff1d69415b4e3737f644b5bfc32d2cf244807e5effeaaccee195876ed79843865e943838ef609d6b4baab90c90522ba09ec54ef36769d700754ed983b55ff4cbe6d7bd9e85c2089d1538d0a2ef4abb9bb26b50b6f93a97f72a073e2473c3aab7b220976c79f5076dd0e2a0ce4e1a60ebb59dd56e39ff8d2d7713591995b8dcefbda57d4109494dca214fc88cc5448f22d6b29348ee6f567a5b49f2b50d8508b2d9b4109cc51a59f2c69058cc57ef06808feea7433573aa88b2406976056a96798278ccd103dbafad28120e3fe62ee1b7a64126da7bcb60fe9ff288e827af5190c90c7f8abc93df2e5a4247e2fd4b0e940dd5ef0997e2fe5fd90dc76b9783454175a95d19b73ec627f7366186d7846c60d0a55b416c9546027cfaf407444869435f078fc30ffe37369ffe9448ca9af9f333219f05d7c7d27ccab92a1671805658e4d5a3c4ca7c9883c8237fb7754b7d0c3205a5a970d6e2c9c4e9bed85936ffe9f0b4b4328b8c39888bff1f8f851fc6e56dc321997a8f6819c5ae0ee8c29f70589b689e06c45d71c066b0e9dde40334ee003b9a365a92a93c59e86d6b1342b576eb775f4d233d0fc7bb985921c5dc836392199812c3a1053026af7ba6978a12eb99a584f3e03fcbd4d5c8de107092ce0685fac8b325b017cb5385ee4183763d5ecba019d0a7fe22e67f9e8b7979fb42c4b7ed8403cfdf82debf81d732f537d9ee124c264b01a29b2f25c14e577cff33167d5891847e7b6decf07014d56db99d1310d73514462fe0dfd7f5cbb07e29d182ef621be08673a75a96ddb4908c29270365e8c6926714b7321c928bef0c88e436f7e81d2f0d843f2cf973d6add97a0fb9089a4a9b5252386301c4149cabce0cae728b0937460b29a4e06971c9369db625e1b8083b3c997e1f32ae644b81a4be9d251c0c875494e8650bc5cb80a128ab9fef66c32ce49cc9c81158d185bb46035460271ba3c2cfb3945cad010f4474925e09fb6c0e938850b4e24e07a7f61922d339cf4ee9dcaba3cba27d76d841309b65af2ff98e8a8f5d7a32c2ae4ab4c7fcb53d227eb467ef6b8b92cbbc3a5de8a9fbbaba4e261040ef9bca5eb0c3ecea6038125c9605459dd9996846e0011fe56145a7de7e26cd09c91257a49e851106e4efaab3f617930186c0ff8a005d7e87c054d05c29147e150bcee442500a689f39a2dcbb979a46080a87595cd3082d6a90d508c1cd45ff9bc5e380dd809a5bbd405769ce44a4427512adfb0e3fbb62befa2f7e10e0c9318bfeeca745301f9f787032b0479379456b84763db85a12ce252335572c88d8e478a63bb95d887553c8a686a5051c51737ced5d8b86ab2de8c693914ff786c2d673faacf05e45fcb03e7016d13eda16eaa7bffb9644cc4862f62a0df7d77372dc05d43052aecf9bc4836196cfddaa4eaaa3e497991fc10949f1f9fb4bf9f4988fe87bcee31784fd4e007bb35617098d3c8496e0e8df9db9c2933571c472f590ed23cf7d9fcbd217641d0aed24421bdd52fcdc3a43bc6ccb56fbe49960af439b34d6f49e12203c55eeb99495eab679f2bf62550eb344ba6a44bd881698ef43ea3d2b60ceaaa4942dca4b7442106bc11d67d4ffd858e19562fe056da7c90dbf9662b5ba8560b902d4bc74a2b0b85a3a802a42de4bf67611ee507a922ec375e865974c7dbab0b650edaa5ce5ada55aee9856f8c80ecadd8550613964e3cb6762513ae5a77167f23e28ba1b45df6cde3378456f42cd8daba7e654e504c7fe91a3e6b11c17ce539f82e6dab0fed94239a80f997b1e8f03b24275bfbb17107ffe979a98d161c35bc7a9f415afe1260aa4da8a1be73fd98f9ec22bacdc22c632bede3cad305f0f6513c08b124e56946a75883f0718c082e892b636d362bdce97a4acfbd4eba761f83421d59df3ac48b3833a618d4287d7949417f7d1c50f331ca7b6946dbd1ebfb08804f1af5b813b46b995c7889cbd1951ee32719c06541d8812791feede75c3dbf2b028a749752bea3e0961dbcf00e53f65ed3fd789751cf670a42fa6a086a231e356b68db3ef4921fe6ce570bd3c31b81a629c682c3f3ce424580f94de000d734ac4ea8d45829ca926e488dd59c000cfd780335f23054f9a8bc9a21675cc669962d1f787095faa9364837e4c47189aee5d15cb84d6302dba304552ab23b48857efb9c2e25fa62570cdb1aa22b52c080879708d2ff0fb6933b072364be91f1315844ec8684fe1682b3fd2da5dbfe10881bb8532d3bd20b32b79f8ef716a3eef55ec1cdaaa2c09324a80af315bfca440047d8efca404bb5e3a44fa57d0fdf3cdafb4c709eba614634f2448eab1556bffec070bbcefdc9eaab1e2da2e22f05fa8be89561b7fe570c775ce92e622df07d13ebb4767c7b8d6689b737334ca72c0eb722fd5f22a3430799231e17a4f6310e7f1c914bccc3e6a92b16f7304fe4f1ba6f8a6876b242c2aec33fc40fa636787efa18ea454996b8ed4e60e70b78f161898425089cb2fbacf0bcdb89548d6d7c1f9458204a6171c7b23875efc00221743497bf2efc3188b6b7f3fccd42f1778e0ff7e029d769e46ac3c138678947b85ea3012cf780eeffc2b4aa092c7a02799a31b32635005e975f17ce82877f5fddda04552baaa612491a4ae317c8d7e3f30cd1273ddbd9967f6052b997aba254f563039ff94c3f915a9b3637622d7ba2b0cab6df9a217587fb7343d9231586c05ddbc6793f35468847baac3f5c4b6d072bdb49e8284f7545d5d7a95d720e2cd9a8051821db5f85d9c61c95146112592e50dbb4b3d83f5cc539da4f7fae9faa8f538e78a0dfbc8c1822dc1de3ffa52ffbce1a090d5ef0acc0167088ec04d6ef3a88fd75128deaed93781835ce899da4e46b36cd9332303449d9d430376e8ba3d3a2fdb5ca4f4009ef2d519b1d5546800180084956af1f537671262936f2f7cb62cb7af6770514841f20518d86ef6a5d4a6cd5f622be30dc4b2292a24435d4a2ae31c449cc44484ba27ee6d424bd7960e53dba0f9635f4a6634e56aedab91309fa0f40ac70321a99b6ffde2ceeaf6a11aa6b3cec138f781987211524727f836cb10b7cc24fd520386682d4910e74806c2058b7d35344de06c135e316c82cbc35645e0c193c05c001e0907750755d637230d2e20d33e7c00aed720e5aa9bbbdff1c8fb2e22c62e6915694b5218ed19c08f158f227cbcff78f61427f8b2998ed874867f2f6380fee7156ac9cdbcd4d287149126f1a77080a6180318523ec7346bdf869d6b34b0724eaada8e3d6949816512ba58d488569f527db6a3fe47961f23bdb46a13c8a4a83b8bd88de2e4938157784a3968d793a54583185978cc013548a53ce43ca3edcb2e749908b03dcf8d96c3ff97a5c04fea37ec37337102cb61cfe644c912bb245a0ef4160dfbd458615c83e6c1614a15517cdae1c9d128064da6d00c58df56711a9dbb51684708229b97c5303e476e4c92ca6697a416def54b82f5738a80d481dc02f2277429fa2ad7b967f77279256a142c4ab2edcdcfee393067ff9ed353c9b382109a78d69776bd6ad1a648a4e27ed7d2efa66356276316b6e45285a2d2e22b6845793ac40420af7ff22856e40f8ee5ae38ec2e1b2a77e63f0fd78292dd6405419180f42d21a1c7198f5640bfd9db752cc6c40beba9d681d69ce4a963299dc6e6eae89440af1485079a375f03681443e545ca4f9f34668e1fecb66ac92a9cba5b059905a89e4e1e621c6c66f60cae46355d00f8b572fce7e97413d72bcfb99c397507011bcde86b9857057e7a1f8d62181d4c964fa95d733e7f470bf75b60e2dfe8193a3d9a1f934b5d1f988c53d82e5a970073f290dd053007e5816e180db5683b60aada8e03c8140e887a6f6ddded72be54b60cb6522ada361a846e9a886613af2687b57a09931d5bcfec520772c054309d51ec79536cfe7be892c01c8186c0a04e5f0d988c24bcd96ff45d7a372b7fc0cb5653741a4a8a25599543fe8267bf7aa0f91603776dc6889e528c174c75a3274e2963b3c59f5db7abada9f35ce3bfb35f8d4df64c981004b1115c1062a1cba20710e01fc43e1179f1accde6d1aa89bcc02779234525d4af726abe06fd59ef441a9eabbab1c8a7eff01c7dee4db143bcf6ed4b80b054f354b6558d558f7fd339ebbe00bce2e0892ce9e5beef1dee3f07978d28f44fa2af7fc09222f9b3d00b7ed20035e08a793edbdfca0f395eead3fed778b166279f0e781dd5422e2b250d5153ae6b4dd096307deaa5c06f89f2432a7878fb79e4a82e1b84ba4c74ac0272d55eba10ed35cc038a827c175d384a95ce3c1a7258ff5afa1cca505e8803b10c05e8a86c61fdb44a35c164c9464286074f156ae1bdc97080eafd98db2aac709cd2615a0e3944fccb904371428572cacc68a0a3fdf85907ecaaf9ddff89f77deedbfb378903d37bded447ac4db1415d0207bd3b33939ef4bb127745aefc8362e6f0125b9c286c2469960e69bb16c2df52b4f7100318c31295996947fdff4fade2c97d67d69fba4ab05909460f358b7bf47f4f0c081777e2dec72f16c0f8422725c354ecd2450badf71175760a5efa4d8adb9307792ec10ad00f251a0b1707b6eaac52e21f72329952c859d28cc7586571aa627816062072f2853af10d8ec94b2d048ecdf51b43487b18cb3b01386d5cff97d7fcd746b54414d5411b6f985319e6e44f94061e4bd53eb76a70a2eaa645feaabe6d9f0e1234cddeacb877d55bed419639c39cfed6b0bc521b5a02822452d34d6b1db69f3178e43c49154a596469d6827fc0e38a723c485ab6c3dfe660a957bb446086bd7fd6d3d3a16ec2f3dedf5c437470d63ec001eaff384f9a8613fa4ad120e0fff3d131dcd05be1fade651fd46a00605b42562e21016e5efb47ae52ab10bad2235d03f5d931a6d57647c8a650f723cd7ebc01b55c588bc4dfef5f5454cb5c2ce20a7a047e0c44eaed68a06e379941ce9e7b28d25d3c9056252975896ee1ecbc2c2ebeb29a1e52dfc48a65b442c0f389d4b48ccd64a474cbd5a71d290c5438d0ff7c3075bc777ecbeca5daaf0f598a7956dfc12817a74e5a88efca236fc362047e4f89a78c09520fd6551653beee906a049f8096f16ebde3990cc7722862d1f03085f493e51c63ea2ed70653ee12585339c36559e62324ea9a0f487b4d5a6b2f8985d7ff7b1b95d99991ee7481c2391a888e33d8be97ec7855a88775ac843aa6baaaee5a28bd752ed8e4e4295c50538f9379f689054c839d96ece6f82df7a2ff005bd33586ab01be3dbbb0e1ebe91a28f8fe2fafe017a09339afd153500910ed5a30c15a9966e2103dbf8462cd22eb8bca17eed8935d5c42454c76e16207a2b272bc8c23596b7e23313ae779114f8ec02cc5a24e93cf3c388357bf96693842eea270a3d5a40bc5f2b77f6b74d1c5743e96428fa5b2194bc042c7e3cf44d8c712594ca8fe43694d1b95a2f312608a9207208e74a6798e6e47a7c1fa6ca9b1ab09711e268fc7dfafc3ef582597b5a21e06b8d1d042f5991992f763e3dd8fecfbe8a6fb19fee9a1c7630a38fbedcf79cb02609e53c5e2f1de4f52dba7e7d7f1dc1ce05d61a856cd3091bdbcf52e8b9e55e26b5eebc4f316186ef3e0474215d00296f1937a604c155583a2034033ff4bb5621a17d3ec4771f62d37c867ee080472cf608707d8b0460680f048090ea637c0a1d616c23e4867b144e92cfdb0a9a7fa15481e850858327f4537ca494278a69b128dc855337ab2b4858e9228d87686a7769b1919d0b5ef4dc93e77ff720c92cd21f54ad845b1daa38be4057b01afcef1e59dffc1c9bd2cf1cb803cf928cfc1e535447d7b308d17b44592e79b7647d38054f9859ad06fbba1ef5836047d798a2a291eb3df1b4d29f2d3e60682deac89c6cb9575be1959ba58cb81c5ef0dcd992c11966a18611aea8837359729b308b4252d992cca2755fe914c5e698a25530aa205e18ab33ee23acd02928fc030e218be24420d4f9b2b2fc45237b175e8c98949a1013fc3fde314fcc0a85aad83b5c6a38a2737a824a2895f6bd0b9586e185419f8543f9b20f107f62762ce62ee0f59ffa426cad569046ea07231b7f123d00407e78729e1f077319ee410675fb96ed2661511edee2e9b7708b8c6cb9455a67ca9aeecb081a5de6b2518a37c86ff0146f6a631f55972c45beb83bd25b27e73929eaef4aa94acf1e7737301502fdaf74d1c68b81f1030bf19d826d5c2f977db9fbecd0def557647273562481566cc7b4e1d00bacb72a102c44a7c018ff057ce911a9f05bfa633835ccc51892562798294f760cd5ee47eed675d493e1a1000b71be903062803c8188873ce873bdd6be9de260f3fc820647ee276fa7d706bc535145004c57d87b8cc47f4a38360d1031a34c52a1897edee820ebe2975eb57aca7f7ef6ded0cc65c5d4f5a92a73d428f35398d33e1027f4b590149b52798544fe52211162d448d80c731da19e2ee4d80a87d569c585133da85cd894920fa4d3fc51c9784ab6b16e7eb688fd896c01c5de33ac8937c336c49b0abf35bd0ed87b5c30dc18a18defac0fe6eb71604567794a1985108cc6a612deaaaac2de1a0d3a6ecfa66e3f3c4a380abf23bcf35862cb7cd30ec1eca98252469407170e50441f7b6b41d34417eabac7490193683b13915c88ee7237f0b0a54d5f77ac7a6102e7434f6516f36e82ab609ac9114c07d2e84568af319af4d63172dedd340f9c0da9a1b7840a2d926d2a4dd70e979d129f2e4c85872c4e629196943ff9c520d5988666c0b95529356fa334f4dab4d87d9db341036de0532ca7d058f9fcad590c7fab3c9fbcb0c46ab36fe4664cf458b6f9677c5ef238a8c5d222a81871e2a892548d59f1292065fc5a911b322344c0043af9829566a0550234ac0ee90bcea5efeaf97a2b8cafc4b1d9374eed8a4fdff79ce3589407f47d5e0af64b7ee1c76581a516a9e0f9fc52a43e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
