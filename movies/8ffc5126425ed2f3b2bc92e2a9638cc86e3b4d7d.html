<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"145e5d79c87d696e0808e02fad7490dbc1a85a95b1748a2aafa4455a3b86c7e59b650a760f753d688f84b00d35d39f11b868fa6692cc385b98d66f08bdfd4af3d49027f77b149cf1dd8f15e864e3861b1255695b077b9561f5575ee9453aa18016488bf307e80427db197f8d20a7dbdc5375e64fb94762721eb1e7cbee8dafc721238657eed82b2c49678da4b43dbbbdbd4194fc6667838670bfec1f769a7d81d96274f274d3faf5cc52e90ade8100c5ae1767f8d41ed4c6e0daf4d2032c718640232f52f811f3fd98fea0c75857d8af3d15da350eb21eec173f8e7c9f2973b458c6f178c07f650414b58272ad5d3d2a0d4c3b420f99c9824da12b32f31a165d51f5a0f9cc1156b11c30a75bdd6a4a2196baf71f1316dc059869448872c2d328bd7d7894861c5854ab151bef72f714a1c99f2a5344765469cfb56b8865855139eed5e65a73508a6d8dedece08d2137e97c75afa611c0202040dbad0b4cfc4de97699c6611600a71270cd01bb05b6e3a4d30d7d8b955c837367a7cfd0eb32173b53529f30382ae49d2c8167a53124c2c32c408ebae44289b7c7affabd44544b7f07c864c70ad125dafc909e8a1183c2505f99476381e6ad1712964960f014c4390d7911df27a087e489eae2f75b959e6cf2f5602d1bee433c6f12fd762298051db784a41c8db817ecdcbe5454b45a760718b1e77a6b8b20d13b363e4b695aea79db26c067a0b615010fcbbc7be6bd5327033ce5fa4e638becbc92214ca1a94aa3019062dc0dc75155333d9f89809c2f1f759a043def22cfc51de084869446204dc8b216a5c139004e0dc84338d7aa18f04a3d998280304a6683e01c46c9e5ee2c23990c1d3c822c8b02929eef5515415492627c87323d978da5bd71723348b4f4afc0bc730aacff35bb52300f8a939de4659ea0e6ba2ef373d075ec27762b60babaeefb8e0e71d635ff2bc45ad609be15074f49d1ad18024755abfc2842211cc72c72e852da262d31e60ea879af6cad3f136dc517b9914db2adb1dba759d7d1753f6e3f2c3dbc4f8b45697f8e04bdcd375f4711954b7ee4c8fcd6849ebece39341297dab1ab9146744e4e23d02750879b1321fe3f435486e1dbb65108385b3a07bdc8bbd9b04aaa6a14a52bd89ed275195573af2233a44c4133ba2e8e0a3996f2ca5028022d22b3bc6958fb1b3751ba3bf58d7770cc9b44ebed0a6cf15dd0f51d81f33b3503ca47609a3f35e817ef7162f6de59cc8b28ad1648c174072715eaac44e5dc97c5a46866f506f2b1b405bd165c7eac990fdc9bb7ca6f6d63d823e751ad2a53448a7c0ce856ebbf366c4136937454343e3318147f45ea030c6bb89f557c90ea9b3f44dc7336fded75b4bd804458f27dfce5c859638a71ea06c0d81c4d782ba3f9e3e8b513f7a3f36e310aabaa59e5318eeca38e2252061e2855ebac3539061f960af5cc458bfff99b268eb4ce825c26d3850bd0e6150ee375138dd1660c912895fdfe911d1184c50813a78fabfb0ae3010f0a7c25f2a277a72804250ce8de7fd6b3d55509369ffe7264e9dac5af08b72ac3c8758d571b81cf92c8e7f2b3fdc7bcd858af2e2e077e3ce95bbd8b17e500bc53a0d90cfa0afa327dd3fbb31ff23d1ac6e5403985476169fe392929033a3053087bd84e97b5b1fc2fad84aff7479c308e4bf0d48410397ce980c4e2e124bf009cc42104f283453cde1df1c61896b86e221d745e5f452956a6176434d516ee917b00353977d706683808f2f0b6ea0491204d602570686ac43285658acb0ce72648e09b87bd3a14049c1fdccbca3de5bc43a0a14b0ca39ba1b42ed060d14556ca176ad0706ed3716028cd1d74cc29bd655e8cbd5242fabafbb8e0eda479e06d465794d03b9b82d53ab01c918b1c4d5f707951c51756d6bf26839b661b4469149691a721f9187fe2129e83851536c021e7cdca74a3624a5eab4414c2735f76434ac1c687f98a9ac4ee2ab2dc1f4e3897539d1eae75fcdd7d1a6d10742913d94e1c9c08af6ce15405a065681a2fcc7dd038537e44b1b5f47aa1057707c94ac27582867d57e8b2ac3cea33fa9b1363e28458a30e8a0d35601c289457e4880467375735cdfa1a4db73b29dcd46f55736dded459a0d9f1287a98586f01a4cae44ad4677c44b232a0838e156da3a02c7b8f5bd8f343758534835defc7d2458671b178cd3d9155262f16c25ecded4873376e2dbabbee33ff81609e4c37c6ac9b67ca94c6467b05db47cc5c16611fe170968d7e484b56abe3b2f75c9e5305454e9ead82ef5bbb9512bf1ec6df662a6ccd485ed8c661920f5a9365b928b7b0e18a304ba62631f7e53c6590c8e5248c138031378ad907fffa821842d0d5cd813765226c8fcd576d529377e403b68d700c87a95bdd23e392789a7acb2a76a07af3ad6766a1b73dc5eebef2f894da9893f35ab2b40830d6a6cd9d5c8c6ceb79c3353f623b8a413516a5092986d8ed876f02e6521edefe077edb2c0d085535fb97b6873de82ba54cad248067bfaf2e2625542b70e42b88f1ef1f90ad928423dd1e450d75a3819ca72da6514a3e38b49c147e0e092ab73b2a0e79bbca1c995099abf516d7baa5c195f1c08c7113b2b956c3fc7f6770857022b27b252d6c22071c4e2e50edf3ca89f1bcc7d6da084481648f1de046afbc3f1616e398cc2cf577351960d36b3bb8d58d5750acfc2822d31c2df89990260b8ba6abf6877c695d3bd0452f778ccaa91798c97b6e57415dfea538f989a14daefd8bcba525830ff4b1de857af635be9b402c9596fb14ad1d3b88464d30ac5360840315ce16db2051f49bf4554ffc7ef0f273b7662fb761adad6675593d78edceaf24113cc9e22250e99cac1ba6a8e0bc07590cf2a99fe84c4d9546f70fcae1b6179a03781481f8c4da61585bd2a4532e096d9a5b6f1ccf0da4c1b59ede1f4b1f8e623e7f93091cd6e9802a52f20c3c36f0f7cfba898acb21c2da19fed507b67cb5e7509eece8c5303ffe8e6a553dccbc98f741612fb24d8d42c05bdff79e3acba3c2b906a93f2e11388b159fd46c2b7ba182f058e683942a7a92cb086233a0b434fe300aac374ed5424421ea98019500221d9c8a8f5df1e99a62516102cfbc2affd2e9bde0c8e5fdf8e267e5601a5a7b09fb2b81a214c6f4dda44330ae45e84ec8f37a8040679a2326a2c3fc6319efde7b0d77a7e9e080962c1a22c4fc5612be4d5d691882c0d0127af26612866710445617187d0552cb56ab2bc42e6ef6d20b7c895ec58aece50366d9e2f334f0f58b809a3fbefe2a5774858a81def8f3062e8c39da321745239c418f5881a3eda1b170bca97505918f8121780f54a48a0342c163985deb7584af3476334677a3062ad9466285f7b9e952541e0ee8fe27b472ace2cbf3dec3f0c90a2a50fe3de95b0b5b725f4484306de4653345be066d9715bc48c05d708030f5a852ee3f6887135fafd41943c7dab830e63729453cb2bb89a0b14bc31956237a82788932366ad2d9f0d35735ceae73afe38454d5227c2b15502728c0b645f934cfc727d3641b62c1d520cdf24414ed209ba7b0d869bf79ccf274f92dc8028feb76b40064143e75674e4ade9fca12980f9a5fcb20f91e8c57e53622c7228201cd50ba74a99fdfd60ca5efaa54b27ad50c4a939fa8d6c941609c840e784aac729e69864516c907a0aab4dd906cc4869e4d9e3d2139b5bda897d87229962625ac28da376e6861cefa75d7c03ca8005c7530715b42ca5386137b008952d0a7c38a2860886c11a4e233567db5cdc3eb0ee9fb1205e8729e8ec9e1fa902cd2e94a3a2dfcc6976ff11d9f69ce339fd412c62fe99c031ea9c9457a1bea3e85e2c6ee4a89dfccf9a9b3ba0f28a923479e74241687a874de17758e5ea2eb099d743fcf9fd9ed5ebb4a6fb55fd891fadc84d2af164b104fcecf41da447c180fcecd92414e319f7cf19ee44a3ee81c5a45cfd631e06b6283ffce185bc1c9dd1aa9a8ea935ecaaadb7816b17cce946460ec651877fe59132264d2db20670359d04ae2b2389ee5bd83a02aeb707127017449fe4fb6637a503fa2ed0eeb31b586047a9e9818bba44935f5be6b854bed810135d53886646d75bd834461b46845483d5b71a5352bbf826fc466e5ac3d4ad5a854a00b89a18bcf33008ab2d8aba1b2b1bd352e3a8c81c96f3dfeedb31641607cf7cfc6620ecc8e355107abbab033866dfe75f8bf41cc6908eec861456dbec35f92d3b07ce4808ccc72a6ab37ffbb6482c07cf38ef0e004a8fe6e8548c169a74be86dede5ea8a39db00ce59b32464220a4f60f49fc93bb43a3bf3c99ca49b4a8db0b9905c6762ac3922498d62a73a06e570b8883d0d816d7d97a4a11453e661cde4b6bbf73c1de5fd32ba560fa0eb86078da0bef0c20822cf878d85df5bb05e964d7a76de0465ed7fb661174ee4c601a2655631a5b82b8cf5b46d779b59d3d22735df70f5c7c4e28371e83e9941954a1ad65bd3eb7a0fcf81e4648dfa75c8f042cea459b62caaafe442444326202c7a2ed1a6a3b0817842d3877e05fb329bb792f7ceab336f5f4d7e9d80793960dea4708b021ee9fb5f61ba7087e4a2fcd60c6d268a23537e0ad23d2932c7b3c81aa944f90ae707edb58683c7cbc971bdc2471109a0dd4b22bd39e74d0b1ecd19f791f78010382bb4a7f516ed81d362322e6b8604c93fdbfc8f461d06305f8b99fe75299ee7fcf575f8d84bc3e6129bdf903de6ffa59aebaff72a2bc9eb72b4eaabe4f14d943c7b430c8163adf57021cdb767d811139e84351ddc4d4d91b41cb4407bdea2824b876c5bb71d749886f80b890e008971cb7292413080d3ee461dfbb8e44dbd5c921a398c95ca952e2cac0c32b3c782f2c4f0ae77c4ed39bbd8dfe4c5bbeadac0b424f3dd7a982cda5137170993859a333278c10e1b058326008134842675d3073d199764133289f0ab2ba8e34d6c5468eb2daa3224609634ab534ad7d5716a8e7897a76129182284ad1ca001ffda13c38a6e30c1f5c47c48e924c7ae76e1cd010c65d1a43ee76f7640e02c89be6b7b64fcc2b13051254dfb8d2ef550641caf8aea9a2aeefff56f5bf34c5bc8f96afb798e5d0fd7960d7473334115e1c57d9730e12d1e13ff3b27e43f02c112c84f97953ca45ff275b991d3b9321b683e79019ba4c5235e8309790c32899194c2a69ff9b4e56fa9a91b6461415dc8c8ae0d9bbb399abf255f80043134cb002c7d50e277a23914717310487e1f749f849c241e1f6897f6aa5c1f8f9e91dc394e1ecbf18896353bc32e86c45e40817de7deedc9a4cf755a6121a84644e1fe28f15e7f486e0a1f2a333bebdeb25a3e9e2728b430fae3823e20fff10824c12cd2205d5dd91c5c055fa7de4430d19dfa1caa8ab0887d5019049764ed72676025727823bf685b6c2d2031136c13953c3694b2cbc1a248c827be3f3f3df405fbf1c8e569fd22b728d86f7dc9375cba538cdb1673d29d9ecfddce4128a68b84176d37d923557a96edc6ad32ea5aace440d081f831c4d1e8f99ff86b3b0504356229a40bc1c0996f6a060c5b10cdbad267b0a2a9613655b8a60e42da63d30bdf9608059322a00aa69977e9ee628d3e3e5774055ab6753435744ebbb2914aca049a419d6992c180910836eb2ab28da771b2c6197ce46479c46e7691682485be3097b3d6661ad2cb5149ddb800ea0840561dade00d2fb110112a3c34da5c71880b15123657555d4887ca3f671f0b4a3e729c73afd29f39e0d31c606ca1a7054d2433e05ea1dd3fad74f45f903f97ed6aec08c78fefbe123e0280dc07ba3d123f5abf5748a685831718ed7ad8d6d4406760500c3e792ae3361aad984b2aad378d0e75a71343ed8c7cb60c5719552b40d736261d9614874e4bb53836614c2517aa937fa260b0b47f9069967d24124581dd59df20287ff67a1e9a431701ba626b62b21e4670b7d677ef1c5f8b5bacf98f284518ba94ff320b40de69a9b30d055bfc2e1b7e45b89eeb3be59bd389857a27f63d7b85f7d7506dab83b350128c8b35df4170cd5f581855690ae476b129552b2c79ba15250e1a3b19f0a1550878a5b8e21bcadfa73c330fc1805edcacd2095fb375a95c54023e9a6ef971ba1fba8812804ff5baf37299f7370e91e48e74c296f9c3f0735755aa3635a50052d4388232a6dd2be5baf1c8e9a042ced90bc1edfa575e072f333218475b5b5d978fb05217ef7ab834a6e00e94bdd41dc333eb43bbaa7f4550b11f83c19a830ffc0618766a1a79f48d503f01159a3f0e0f4a9f8e894bee4c1fad71c19ae6a711772db49c832874def07c14feaf51917c1926f58c4d304584b37cd0662c9b376918e4dc59827ef45ba6770fe3b33fddf63e7da9c7c184a9b8960b14ed0a2d170e493320cacc6d09e2e94b19542b2d61ee5df0e6efb33d3c33349b5a73a2bb03f33d708d021baf651c42b165557afd2c0413ce11a92151a9f9e597f515427cf332ca2de158295741c99879b2ce9ac1860102429469a934e816264a8d22098984886042e0925042863ba4c95095098ef18a9b335ef47fba422cecb991847799cf2b69519aa37ff5b340ba99b25d1a4aca4644f7c710b03b8a3c88ab4e085492cd8126ab2155fa9bd3b236f9a41fafb8961bf15a5a823c57a713287920188d060bdb993e6d43060346a709a776929f5f32918bfd651401a01463cc6628d0bd68b6fa6e301d3f9355a76a03e121ca2f334452b655cf79dd86e27c93b2d85934b4e2aa12bf34f1676bb814edf034f79a4473441bc36529b2f70382f40b4442b12d599ff9eb32c00f2607a1558f71bd37966942d04870cea5196231096c1adaee97c22b3a011231d76232f6ccc2f43fd374f9052b303329b6a88bd603da984b88cc82370942d244493c1229c43cfcdec1613082cf06bfc60a8fa59feb43443f86ffcb76b1c141cb1bbddb8c1ea562d7a615cd226a21abeb4b3e890c68372fd91bc81e2cdcc84d5343ec04c685b7ee7894e6e8782e27c6d4a0882b32e66bd534414f0f5b4d510923fe2df323488c24d278ab1d68db3a059713f15f8943a8635cfcdb267e97801dbb39ad031747448ba56d3b08b197853ba05fea22dca1f0166e491b76b298d6e68334a4d2347e993d470155207854bc09e7b6f77aff06fc6708775f3a9b7f6c1b76f2c05efd660a8ff1bfa282392d06c7cc847774725b488b91da508b98fb9cf950291b4a1a51bc103bea3d427ade0b46df39aa402d7a47f630163fe81ce79017f5e34a0508918a20e9eb8c8db3461e13a0beefa2ec0d7a03875f17b871a68d8a03f555f4da3135cf8f2cc37c260507d064120cdb34896c205b0a72fc1fb8b728ba45badfd324f494d47491a05f60a532b67f1f70d077035c275824c7dcad1f91a4e3989dc118a52320e7910d38b3d7e935499de85a41fcf81561ec6dd8e6764d2d84a1ce1cc9f09ca2d585c27429bef27574ed6c9426856e7906c139e220bfd9e1d0fb17e262df7c8793bb43d88626f122929570c56b6b7dcf7b0369b8553e5de0a4689a3aefccf5e9d2a1c10bfc47af8efac9231b8c9ee3f8cdd9ca9b089631b52b6da3a53f3508bbe5dddb7362d5cf7fd53f98e9561fd2b6f479257042cae7901ef336ab1c76cb38a987798369bda9291726813bf677f80b4a8436b841d46e60b76b9265fc4d64638634c3029feed0ccdb685a093266a6db2ed3cc16ea48dfb43ae3dd6ab266cda35efd25ed0e36e3c82241acbea0f204260751632ad34d8afe75f8e549556fbfc8618aabd10872bb3397a359e013703b7e1b7a31fc116ca723d201776fc7d05198af0f74d4548df699a32fc7e1c6c0a80fa6cf48514652333a2bddbfd0996c82855d902a05fcd04ba469830d5d57d553ab5061bc364f26b9fc5b71ee36e2c7fa98c7942211724264b5a334f13734666b6f98e4bb9087eeee69d37188fa3ab463e9a21424f282c815e4443636d3ecf666a2bbf3781cd96ee3e932e45248821a6a030d83fae382953abe66e119722dd253fb041fe283881cafa7162b3fdc457c7b791d2c3f65fd5874fe1d0801bab8df0a47454772a066fb15dbc1c7e2e4eb206be26712582dff4c8b14733115f5e8e3bce0db560fd2fbd1cb549d0d94fe0190c488bce47c169703700ad587f0e38803f6fd327a1595860a750fb5fc3078a818e6f425ebdb71489f19b39be4fd4bf35158ee4422aca9f4f7ffdde726222536a101cba4d85e07e8bd76b49bfc5a61421193a4cfe832b175358a35f7fc741ea58877b436a890c115f57018749b75326f46410b667c287c8a6ad88e37fd072b3b3c42e4fba2469c81c43e22c7d28d6cf10004ea7d8a7a40faa1b197ade65bf40cfb4380072c4cf62b9b0d03c13073cdabfd477ca7ada5015f201b56c6825486c21c0aa08b0032fe815d0b334abc1a04a611d274a3f99ffed9b8fbf70e064bcf2d5404e360ffddc7c1af84e75b3a326a9f70ea5afadb811239b6a6a5b34d7f5358bae77ad581087a003f9e8176e1b7d1255ff72e3d6049c7135036d30084c78f5f42572ec7af22490fe49d68c1a182a8e7c1018bef96f5aed6c629e6f22ab89afeae2e8fc27801b483ee15c78e98ff0669cef355098d0fd5907e7027b21ea9e47f38bbcfab1d8f0484bd52ad9af659da9c6b17118c1f934c8a39f0d465e863be13537987107e448ebc175e6b98d470555c4599f21559d367a360f16f48dc9f103edacf3230ac8c42de9f8e939eff1c1279a0cd1a937546d4595be2f5ab303aac80f96df6f8cf489bb800aa08ef27c37ed3b41f598a4886cf1547c583eb3f9288debdb992ee3de9718b50eed787a6a4dae99a948c15a77744c49125aec342c7f35d6b080788b07dc8ced9fffb8bd08b158938429dc9abe3a354c096a4e0912ebdaafc73b77aec10368a89c493d3a95a4f3d9f0d961760582746b16e222213beefeae6e2bd5a1018578d0238d2cc376d402d82ae9d77bf7ab786f0e07b181e58f559cbaccab3f3ee2c951658602acf38cb3676325875d7fcb9d0db54c1df17d4a9c7a0d5beb1d4828a44cecd94f4eb8457392a8d67585987cd70e3742bb9adf9a7611fd825ecf24725de982b214d456862de95a25991469b49b2d743b20c977b78695bd3bf8f523c3e554c85dd300350fa0711557eb61e7c6fc3fc6f44cf0891d0d2afe811fc9b4625bd958b8e31448e82154a9f5b6b1421c4e8023cc55975d29f3c372f5f39cbb7544c6436638c6ec3dc71a57e996f47d65a68e829d24304a601a03a0b50663686865c2a9207b0bbd321bbc04858b03e30dddd2657470df09526251a8e6208c2bfe68c999aa29e2ef9efeb25e7b82fcb661b6c15b57c8e686edeee5dba7f145c769c926c85d28626fec5b1910eb36dabfb6053b19d84f2d44f5d7904ac500bfc40b961a6671443e93a07af188a939668a45af91dcc73a32cec3fc67daa2b0c0098d0a9021b05c0fc25b8c2f2907b0016ef789aaeceed1fe9df506d978b17f98d47891758e2b6b14a4fbb547284f1bde90fc6c9128492c5ab59ff5efd3c2b64026a7cdf29bac66a85d84289af2bf53f3f74d145aebfea788e3fc59e14a64b9a27f997d5eae4feb9cb087372317a8f466be1c7736dc865dab16617eebfdd83f014288dea9c22920c6d9974ba4f044f6f08f9a90d9961133e57e11f43a7d8309bf41ad4c38dadb82d9b04c65ba14d328aa303f0cd9ee321852045e9218cdf393281c6e37b1c88219db7b223b1dee608887e09fdd6752be9402484e90124d7ff5d21b5c69f2b78a7ba553d3479610474f06d1b580e78a80cd91fd7c47682fc0accdec944c2e41029c504603b2f2d6a7420a6f623e1f0528c3bfeb821bfcd2f3566ae0545236ce9b37933d92a6f9974101a2fa63d4e85b102978ee45aeb20818bad4d97fadc97d600429ee3107f218ae6668b752d361c317205e83c78b9ae9ca98bc925136259d116244776031b3b4951f33be56e3edee5f207eb73e0452fb0ce54dcd6bc194bd1dc1cd5060a8f560f06e336180f85ee52b43292a512b75ce4de7b2d0c26b467fd5219a78968adbb93e35566421dbb65c1d1a81ea0499fc3c8a36f4fe3151555e24a089109a5ede2a6be8ae938c11c49dc2b62ff597cba43f02ced115dd25717d79ed1eaace6eba46f04e2d657537c17cc00a135f0061735f3c729a875ef9ccbe587b9908874f2d9cb163cece3b99902a17580264174d7c3fd5e05d6287734794cfa32a62a1c7142c9537997f3a243034c29136dbc98c2a90f09d57a3807c31e1b204f9778806591cf8d6cfc475b164061c54a2a075eb453a745e8ed8266b9a8e0732b780a7bd412451a3cfd4b4e3a1e8fc588f407e9cb7fc5e75d02149c2c86ae0469cec813f1c2299cf8bee02e8cfd9880a28a4b8e9f40af092144ae7e2688b9f0c78d925d97368d365e15c734d2d1d90c6657e2458057481ac383c2aef4667a3b19e98c9dbb0d699dad90739aa10d321714959e89a55887cd56a21e6b9b44cedd8cb15690304286a3396dbc8f3fc150cb665734042c72c446117d4a682b9877b7c6e98568748246dc35dbddd790b464ace2d0ec6714806983bd7c6de21fa857fe34d9de3d7a588e43b6aabce42176b54744eb64e54252ebe36ed6c59b3702081869186c9f32b41803bf96eab3959fcb6b1ef72c6f30f81eadc23f4257083232d9b40800b245aa49d0060bc9dfd2e41a9902114499af180f3f2cce973fbffa3949273dd5e8cb193ef6527ad55ce9f7e23886214f99b9dcf4d592c080fc4c141059418fdb6cbcc7e5757358116576ea936f445ddc117af6ab982e0d9e592ef5af74819d34a27f5afbc2dc7634c60722c92b0b895b03fbf9bec9f56f30ec3a24e7efd6da473c6d6deabdc2d0f754300ae29c7e069cdc00f44e3ebfa8e6e7115ab30b64b5f16b53358938162478db0e7ae5d40df8713b57aa5b853a87d1fd10c80a66d4bc3fd2feec72b750fdc6132897562232405cba1ed4c5f985567f54a4aac3f3a6c5a23dc4798466fd3d17f9617a97ed372e36861d0d1ed5d2d3b503c15f1788efe54ad842565b3e5b5e62be8ae66108a2105b0ddc334d4d9f5a2456700b7035361881e92a0519fd7eb1279f427bb2eee6c11ff82085b58189257c0efcea67dffc3c1db0411e50ae3fa5651d47ea4b8cadea0afdced721c84290ac0a11e3e288f9e21730b5342daa2535b63072d4385719bb366e7e8bd5c192a842fcfc7413f407da24f6beb720d464ba67694c4a10004cc0329f3602665d851d764912d01b0fd1a654d489449f71ce2691e180cbd02d40f4ae411aba8d68f6613cf2002ffb1383f095853e690b9a31246bc8bb816ded0a9456b6259730fe2842c30f5c7c68613435d94bfa493fdb95d3b392080bdf033ca11c68fb5b72ec1e173afe80b4651e794b3fb740879e08a177cf5bdfa3e218b0c7629bf4bf39ed65b50eca27fa090915d76dc8962b258e840a2bb47f851a865f05db599fd7359287fcd127a1c5c1d2ddb2aea9a4273cf2e55848f96889b43587c90a1be6c812bd79e804502d29433bdb5994cef2262b4d969f90549bde512b768b51152deb279e1f26ec32d2e33a2603780effa7a8a20688429ca14bc425b02c76986a5b86984328127c14e1eea4aa983f313fcb19e244a19bb144dbf23e56d79c9052549179ac92b482490a4cd06d7772eedeba22645ccfee7deab705adb74734d8f4eecfe8832e65d34b134ce5b5ae288879bb0406a7d7cfc46234434446674204752289fa614facaadbb60a7de5ae8e5d28a672753f7258288c83406669cfba85242141f823bbc6312c1084f95c964b7980549f10f3ed50486bcdd5e7b28d0f2982dfd3e9b62f977b716e2d88bda3d4ab21ee1c752362e58f9fb0880cfc4b5ce96db59765ac6841cb6a82c00ffa5583dee66c0cd1318c8a89477f351cf1dfd2e70e0e26cdbff032fdf70f19c5b3e179da940090ff75f2668792751775c43944532cd6b1912222c0a1eff350da393c5bfe28b0a629ad6e77f7ecea324c269e000487aa6b2b2e8456d99759db8fb760f7bb1bc52d43dfe3c066c5e64bc7f66b6d61ed6ed3ad054c1f99fe44ebd0f25e2d3df7ef45b2906de2c03bcc4f21495520cddfc385c5276215b153d9732d9750c5f545f4dbe95930d0384a9a6ca316e58f8cfab40c3853badd46339b9285ad2b5a7356879665dcf622650a67cc33eeb81d8ed2915b766d15f8a9e3a3851742bd2b0d747fcaa05e3999bd8ca665ee7a6dbbb9e3a105d694f9b4eee3dccab03f7287ea0c45395f521f13815b41c116c2dc269f56e32d462e321fa9e3159a81e402d1aff08401a8a6ca167e614eff521d550f4a0a52082843ed583b3633495542c27d551d7b3e54c35fe603387dca4e65c587780725eff6b38e1e9de525bb33c3f0f3f367a870daf7459c95727aaddee44f10ec239239f39e26d0b1677917a1b96f232cefe945e4eecb7d254b8ed7f07e81bbdf49ed8f267d36e2c9d7fc56f2aba8b82efb5947b89a78306e17540fa559c55443e561971006c599b49c893da1c6ddeae7c34d62afab5e887b2f27efbdca57e018de677d4fe137c14154e782ba6d0f98430f1f9a62bfc8845a594b6349c0bbdded6be644ba291774180b22c212e4262e7648fdb4a9aea14fb6aef003611aca6ed775028cd30a2115ad223c22f86244dcdbc7b69840c88cd0936d81f8f43436bdb3a01bad7ce878bdeb732396eadfd804991ad81ef3968f002a56a88deda4ef64fa10eecc1d3110fc1cfa862a5cc1c0cc2b02b1c27649cc18b7fc8ea528435dc9cee4cc6cdfab1577893fe8c781d62e8d73e6710711a11808cf39d89eda9e073ee28d772c30d5e0831014557509b6913707ca5dded1daf149c538065a7f0ab5ca82de356a70f21604727b39d2ba11eb8206580c3da325ab5ee3895a89f156d64814543dc9d5a2f75468290595f330051a11ef","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
