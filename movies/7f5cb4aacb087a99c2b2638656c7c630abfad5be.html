<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"97cc54fdfc1d2fb3cc6da91ef17cb8cbbb443fa3c1e76b7580d496f1dddce545414a62486d931ddcf01486bdea03ab185823eef055d05cfd224bf64df8b22b8ea85eff55f52d6a15aaaf9f830547a687b11c95046a2d9991c1f8ef1075559058f42f01df8f2e858e371ca7d4120ffe8d11587a0b88b78454d7aa03bf4274359d53415bdee9594ec551cc855b08aea9085d88757763351a4bb52864a1b96c54578b79a87e89c4bf8606d5f4a599e46050e28e00995b3b29c32bc46c989235652a30077c9d14395f662f5fa925da7d59b6f54b3878950b046cbc86437d67b725e872cace4427d8685a24e9345c60c961c461238cfa702d1f7e58773e9bcf8a0eb50360043bfe2a2ae83ba503e4df6513e0ab2791d938a5c3a2c18452d656f5e7fdd2cac91f7ec3d763e158f556f32409fefe2ecbc327f76c31f734d5fa05e063a0472bdb04dc9434e3c1ea50233afcebcfd888da911fd51899cf50e024c0f56ac4e2ec23d4e5dc31dd193e77f2cc921c19faf79cad1fc10b9de2c1bda00ddb7bf6b1055a54c560dc0286e7ebe91614a1a8a0bc6ed465253a49b97f12c655130d11f5408776ad11fedd6a118ac43756fd5ab52f712721394b0b8a52537ed867a741df37e98250b9d5f4fb4cdf8aa3ea2b324299dc38f0b8a3d8fb883838429eade37a1ee6ecbe6a5fd3647f813069e3ef6f7b8bdbb28da7ae06694b46b9bbf7d35e9269ecd3ba1dc0d23fcaf0507cfdff7fb3e468448040baf9bb22021c33a8f3f8f70b97f9055d397f558f48c155552e47b5f615edf5bbdb6634444a5ec773d1a58cef1bb8ef1c6f81d490cd46115123e5c0417fa1e56f8b073d7859234def048fb4bd01484c11502aee74b47aacd73b84121ce45cc1e28436a8b424ee583c80b8c3aab2aefed382d7138e9f0c7ba1fc9c56538b755a02acab84fc5d6e9714a252b06e886eeee9c264adfcad9124d6b316dcbb72d5779df1d5eed9f09ec7358e991343fba7a5441ea350e10937dff0ed6165d003d848117af543464b9120cf1361e05ea1a523b798b38ebabd3e45d5a9789aec0bdadb193632bc06f73917cbbeeeb61651c9e61dd3e74b4c27d5213ff584ff10dc45001624e0a30c65c5af8ea55cd34cec447ddd9f8bbabe551f2c361838338494b1996f4e9ba895e1035ab9061c006f0a27526f003c71ae964681770d9b4016a9c479f1094eff4eeac63efe8fc4c46d9e204d31432f1a6ddd8b1b15e479307966beba4b70460e96420fe2470b0d3f5685221a186873514a15c9be66b7d4da5cdc1897bb3ab0ba3b6f743a7fe771eb567882fec994d2b640a0f06ba8f5254b9e0d66cb28341b907d2fa25420acc75317a2469cab0afb3a8577795b7370ff95f3bc842bef1f5126a9804dd955627a09b09e6bbf6ffe272d00108a7e37e5f79649c0a5c2adc9353ea1ea09eda1010d5c7f0aab0efd0cbfde58b671c8166d75a05ebdb3cfadaf2a7f79adeed2d1a4d2ba1386129eb9c87df7620284ccf80dd24fc96d1076457bf2511ce1aa6ebfd4bd4758ad7397e8365c86a6a0af3377810144127750a2e83498a8145ebdfe4ae8c735b334f9082a00cef718e080a9796e8e31372aa1ab7c3df24db709d73462aa292fd770ec2edc1520120653b83980e3f3b62f1fea0341251f0fc6d1b8013c05d03e1b0a65429683bebe8570dccb51b547d750ef87e7e2a69438486501fc1af855b07f77c424cb030432aedf519588079b91f0112ec30b25ecd941b06190a16ac7f69183e3f87263f0e67460df2962ca0072331f249274b2e4f501254cb9328cb6266e9f962d5b7ff035b5ad46688a540bb50630ba65034d961cd5e62447ebf23ffe6e15885fbfdd716ce01fdddf149e8b4b662d8623ac92e49ef380eb8873dfcc7a54293b739e56e448b5688ed7574ab8097c90e86670c61cd3ead8b68327abf82042f6f35f17db6d6f5c393469c25822791b83c3e93b39a74672ae9743e78b206475d8cce3106563e2f03e211fccbb339c38f2ab102f6f90d329417fc019cdaa8e2cfae6722b43cea7b7ac4a881c241a941a65c5c06cd4101ef368a53e940bb2df698ea3c30dc5ca1e0707e8ea452a17a3ccd89fbb2b94eb79917fb36801db263fabaa4409a1b58e32b10106f57346f0c7be853fab792c5703c3bb155cdd1cd64f6b32be1a38e25198900a5cef7e9356213d40aed314af90d6dda227b5ac4320cabbecd5f029047ffecf751bcf3e1aadb24acd0b38d6e80fe4901b7f8cd5b76f175d29ff84c2ae739ae6199518f60b4ebb8b852e111ed53368bdb57298beae19378c659775409ce94fbf5171a8d87ba4ded79ebe2d09bb5568954ab92d76e032bdd3a5388ab5f30b04350046d17fc95caf459cbdf66952b641153b3f9856781cc025806332c291a450e7b605f5b2e4f1194a920d78ce2f2bca4e8394ddec9cdf75e46a39c05945d88d5a3240c3e603463386dce82222c4fbe64a9893f36a5f373c4a4d9539822faa5b5c92fde5738fe6f78810e85f76420f1e69134404ffd9e0a70cf90a0f7692f541b19fe1e1999c347bb98086f74dfb7bc63ac56be81ccfa577bfe953ec7ebb721da55f1d75b9a5b9e545020e0df2555a3e26ca0e3579d90d0b48cdadc3c8b5168c2d68799ca0cd5c7fd9cf302b74f5e5c9dbd73396161255ecced8e41fcb943d9121c8c80b8060c1b952f4dfbf239918d656a2c88ffd0f762894868be2c0cde907b0f48ec6ad257eba356e0ae6aef6767032d51e9eb8925a0dd72571904b6f1290caf1fac942c7962cd6477828dcff8ba91466669865cbc98f01f0e54e1576605a97476fa620613bfc473ae3a125382357a5074c24869f8e3cf88a15b66aaf0499bc8b79096c45001076ac7e84eecc0026beb49dd9a9f78f60e20291b354c501f721efe591445d184218e5166a70e4ce040ebcb06d874622541cc174918efa9f4fa410277ff3aba001180dde79821f6a97048848442a3796af16699572e34ec2e3a8750e1c08514370e4c3c0f53b644022c4fc6159794e73c00be887195d0e473d07f5dd3b91aa80240299b8cb49033c0285d0cf3f82ab53611a3cd69a39e309f59276038256626d93e1876886a43b853eaa6a3d1b3ed85c5d87f1cdf203b2dc599c329e4a9a2384ecf1a4b2e7b060b5f4ae8282834fcb71a2f98c347b6ab3dc2af99778fede71c0ad109223de653a955df79d87e013785e3951633b63a717e0109b46d9c3630b5572092ff693b159d5e8ad42a94e47f3dc3e1aee4a8ead5273c9710b327807621ba7033cbb32c11bf81b7bf53a1b249fc05172f48eb3145378bcc3f6094beddef50fb8ec107a624bd9e1d0190935ac955c80cb06fca2e56481f93761eaab5c17d9657c6e2bb788ec25401d8f4967bdc5f51b1c9154beca8a034904fbbc28684bada942c638995f69a285d198deeead46280d517c3a75bae33a27fc27f42d810dd417f1918eb8e77c52348efbe563cbf59da3471092152f4f72cd14d4e7faa84c551db8a984d63a6806724c158d27a0addd8d8692255ed267dcd37bdbb2e45056d2d6af675076fb55fced6b4c902c2717d8af56acc2357e450758a4f43894d9df0c8569fa0f12e2a0f114471dfe2fd5cd670b543ebe5ddf7e9876c3b126504d46535dff835f9062262ece1387151b2a4f0b281e062c9119368bc82d03c9c8bd8bef081888723ca6f9b9b83c95d1f3867ade016da2a355d19b3cf49c340e436f949be4dc8dc270726bde719cc93d3449da06602dc495ad20e90b4a7f1f53f4cff49f3927a277d37cfd7f17a8b3cc604f77c414dc5141879237e46e9516cde41db5abe1a954d057760bffa96bd9049e9fbee84bf23a8e859d3984709b071e16eac6ed172274dd45a48db8c4953ff47ddfd84557fbedf5679d579ffe9f662d810496fd4d37276cdae5a3a95c3ffa8941b97f1dacc565bb1c867fbb5a138973f46128a52e133fd811e88646aeff2437246a03cb3ea1e2e9aa2f96d44c287947463fa9194bd4b778f9f9fd584c59abdb152dc6ae090ccf378772e72c6f2edf5ee8fa5abaefa346caeef3573c12e331133dc330ec3e55c72693bb5b4cf4fd297a8fe2782315445cb95162071318a7f861721b536ff811637d4cbdef4feb667237c9c2da1a3d4b3f2694d9237b9cb5089f583359bdc9c34c91226d92f4452583d3ed7b33f9e065352a3457d903aefa4f1900511523469269d710df5b7a3b3475b50e96535114bd3eb4c5eb7a355986a2910da9067d52939a6303ba43f49df2e9676e516bd6dc8ebe3d553b479c4e7565021991fe42637b021ad0122d76a8ad3d40c7dea3a9fededaa5ee0c471e654fddbbab1dc8302800345c968d8aca8660b86ce236ae67f41c0a3f839db47583e52a2e0485b4040ea018981e1274a4363a138d5f25d13cac7b703c28360b9e674c60601f163c78e7059e59df6257385bf8913957b7aa1987af82f5e22c39798fa20f364be9f3c8cc5b949be84eba1d9bad7c51b280abcf5b5c696135388f9236af1ef1db95c94c65b9a1359ae9dc56f811ba62adef651079db57f6533b742634f9f0370eee79757c13c6e44c2343e666f7a2c0c259e4cb3eb67a35d2715ef4927562ea21f1f89c08e34f84b102c20bf3e265befdad587eea5eccdf1248829858e24f2f636528a684189f03b69c5354a82fad4d27cd867ea74bc7d1ed58f9d3f9df9f8e935d6298d232b28f8d5470d6a119bc904228d74446b0c77afee57dd8d58a08faddf539eb2cf0f72b75b5520a5c4b0616abe804dac1dd0d1462f9092cf82b9018c017f0afe254cacf4ce69df0f5dbeb99aa6948c5c577a14cdda34a4a58c331e602f0df68d32b741865186095cf91659493a003f18747f984fd924273b8f8c7126d71327601904fc2c14bba265c44536bab10474cc91d98a6047e160e713c006709441ecd5f46208b158651bf5ba7246a10bc43fcaf9100ab1ce16464a9170d5540356a2142ef39c0e7ad8e7e08370ec325ad249dd0d2606ea301afaeb6330292fd19575d81abf8107bac3ddc956447aa76caba80e3f23fff1c67e3f7ca09704c9b9d955b61189825629ec83853bdb4746c6b03d0b89a9bf2ccfcd21fc8746516b56d550cce602b82b96fab2394fa1ec9d06250516afddc840bb130a844058d6c46f369b54b52c99669b3c187e4003051614d1b4d68a37d70717051d0076cf28d5f95c715569c3787075cf8b9f8d68f557414169745ad206914cd6ab932f056ec3d936344022ef2248d97a4f0d3e795dd564f940f5c76695e166531e73bd8fa6b983869dabb457e8942595aec7fd148a2e902249b87f8969a6a17483852c91c5706b42592a0d89f733e57cdea4e28c7392c630adb3ac1f40ace7b85d623517e4dad71b76ccd176886b85e45c6e216db3f932ab5f5652dc876fefca2cbbe63813df0d8749ffb649463b7f852162c09525085e30c7e39ba8a2acc18d94356fb7ea3bd437f5bc93c711a50a903c45efab04e8980c0ba842911ea3cdf78c305edfaff5ab7dbc8f15750ddc2263fb5c77aec254efce75996bbedc8a874da6f7b9ece1819b7dcda1c42619c579aae87ce98cabdccf2f8a48e3e0b7e650d93e7c5c345844a2b00433a6849d1dd0d38348f1495dd048b44600a4f2273883b9b8f5a381171e62632c64fc635dd8ecb5e760fd476fb747f9d9fc9aab41e4beb62dcbe7639c8274fdad16c4af535e81af8a094acf3394bd4f61be6fac5fc2a83abf404b17344c1a6c9a3308978c0df8c0f54d6c834586fe5b3b052488e9737d6f2e4f7124fc4ac4e995359a561bd39297a7efc52fdc4c2be3ed6bf1c548b7ba5529ed2de3b4b2a5e1df1a8ed2a8be2116a6c89a50acb6de6afcabbde9e112637afab6b2f3a07bf9e21092b5cf52009837396d80e9092a92b4f4db45e5444dc69326e6c7a984c9c2bb398638f475c79dcae42cb5300cbedc17faf4f9cc27d30f589538b21ff7982e620f40321dd580938d0cbc55b0f3062cd0e09368349186ba353822d66802f711ce7ba88d01e9786610b437bec24a3ba7559bc258a64fb9b5437416a3bf794a580251a764ca3dba99f1cf83bae81f7be3a182e46816001799bc9479e425d0ad604a1c9c747befa92ac2e3bd62599aec1e4a07cf942a30cf8d2c6a8f610f54b4cc102980395a6c59d23d30fb9d8c5396b48d8a275e5fe5619d06448d0e20f4ebd56d4fea443e9f0a89157170b567a67f579b713e326c019996106b3c5830e2b17618459e274deb85a0ee94ba612b5c5f6aec2a526fba2727c18c2b159bd4f287b55d50624f979940cd2f0e8edf46f7fef309628ac016dc00a7139811f45697fbddd2156640a5d3fdb934425840e8b4ef7221f373c8f7be34d22e7673ee1b2a3b3d7c147216401d80c713d6fbcd3ded6ef1d42b27b37253ba85c58d2bd40b2ed31a949b0d3c3e26909e80c430bf5fbd0dfe852af1eddc959438161a50f0d4965cb5a10e546a1ae278e5092a7f010633a6420efa61777002bb7d0b4c208baababdb80dc79cedf62d14885e4a13021fe7ee219816061353be2354109ca20e3a2863b78d6c7444bba9e67792af9c749d6096722bafad58266f625cf86dc327acbe1b29d5230a98bd86d28d8cb71c84d3136667e5f7e523e847c961576962e69a9ea3033fc549c651dbe220aac63814844bf9253b062147dcc1f9c69c15780c68ac823f960c8dee22ed265d651fce373dc2dd7e2a78850a1c7106f183d49d1d09e7927ba9d20f1ff1f69f15228465a5ac98e24bb5a0969d6032a40adcb1937e46a7b3a77364cbde65bf30c659a5228a1838f0473cfdb335e0983d3dc18df598372fdcd6c8d40830cbbd67fb67c433382141b513b8c6b2422163b470ee12a0a1da92331ad63f5b23c7f98296eb6d92f8547e7e007f631c5ecd29f34b4bb9b9acb12700889023eaaf6a3ec12c1c9b7f7e00579c9b7b2418173270943acf04e0a2978efd0c72285add0b2182690ba4b56572ae2c5c53c6b6f95c83420e25794f40600c580b3b39b89340109267eb8baa5da6810b339c8bc89165f35f900a41562b80ef318ac6094e98d7fbed99df8a4e94e7df8aafdf94e69cd331a95ee75c41daf24d01b2cf51d1a5e4b4ff3462283b3dfdbf4fce2a48b603b47ff18a7ca362eb6f4fa62277e96b9e5d33bbd5a2af6480c940c1b6419c57e33578f5fd13531bccb3e152b992c12b39e806b1e523eb1434e735b5e7a316774044e0efc25b188419b48c9c56965a18a06cc50943243ece30c4a71acf4091e6e43b53d479bd9431eca30e163c6f17446bd0cea36af2cc41ea9eb21351655f7672d3bd1c3b340a2f8d7c6d2c5ff04c55f2b890cc679e4fb4d9092735f81c79a6fa05796c9bac308f1b929e41614489391286d3f81041bb4bfaea64f6995470ba5c1d203fa986a3d4f199e3818f4c6c340d8f0af6d7f92951bf0e70f53e700490520813a77bc5f032f0ce9deca8127ae9dd3ff1bd4d3d873cbe97645ea37f37ca3cd6e972284d92cd485946991568194a4da22a75b04fc4990ee3276b022e65257bc133062dc245cddb0fbb3312261f8c2a33e3e6c8592aae16f77570e17c95c504e132eaca459d27241c40244f6137e00881eea539a33f002d1f58ae6ea7baa9b309f39b25a0f02c7675a7bc8af72c2a01b6a374559a734c9e3732311a712ac0c500b7ee01a7fc23da0a39619aa10195fc1c1a15f86994341c526a63be4f54c866703ad7430d60d27d7c60379617df3114742907b47177c5a07a4fc9c5c5486091cc08e53fb22d77ff96d8a7aacb8e0b8bcc178c6986202e90f72d9700604ac330afddc15e285699731eb9c94a7c99c0e7b2053aa92b70a4da6a7e54856d06a523da9090367c9a76a4dc34516b29eb403428b7aa37e4a60614f69b957207057dde603127d957f938b3cff61ce38c6559d3f2dc6b055255e9a1ea04481d9629ac79cff9f78993a61619c0c75258634e826eb35d046c9523bdbfb0574f6bde2cbb9774abe4e22dcbea7cbce985f0178817be69be0374310dcfd7faa4076fdf31808821b155363c37f343eb7a11cfb377165ef62840b990f1a4fa9dacde4ac0275c7440bd20891270a86c5e156ad8009c096a8e800f4f216a08db0662b3360c01f48a199db5de53d584f23bee61f6c540c4ec0c905dabbc2b56203a0f726f84ecd5a142e1e76320053973d8bf3cfa3d180587c5e81a08ffe9ae0a398c2494d2ec83ce44ab1adb5803679be3430eb9e71f66b9eb084c96e503f07988373fbcccede3249628541218feec5d895233fe956f65ed5d1d7ad503bc38ed37ae57f94aca2651ffab406265c14793c609b0df147fd8cef6dd6199f2cf498327b405ed8aa67c6a89a205a3cd0943d4c99030a58a42f74514b177a9af436901204a3019d0146d68f7822f2e125d33a236d47c669d6df5a632b07501127aa6955e6544321133872e544f045f436b123dda9d1f4d6feb7fd71702699a2d8d97a864aada5dc376dfba72805b46e281f7c875a4e29f3512e4769d324d3dc90aef5bb677dc9ad53f1d8a9e626032bdaff59c30c7c2ff2c014d03eae09ca8a4e94221e064d244a06c3911bd98ef6b168a634bfd332da78e46b6f8c1800d0719a76adf256e23a5d2d5da10e10fed09531ef62c8f4d5bae5d7b8986e78693dfcec2865807479292f3a54fc3f675ccfc54d9525aa43e5f2caa9960121a0dd0c2f0ec64760c80092b5c1e530fb39f47bc19b70829ca7896b205a09e28c1c053e5283598357ed17f135b09cdadaa5db925b9c408b6b43c83fceb3b84e0fbe5d7f4c4dd058f67e823709a3e528b315d8193fa6ae1e9504debd7e0aa0f16cd300a7c8816bb7b49aae3b35f2680ccb299cca03b552916bee5d5ee0bf82fb79941b441eab86a9bfeccfeeb5435b39263d3914a192e08ce7330118189fadfb7384ffe93f3aa01c202e12e3f2bbda7d8a237b1c75fce3b276b2f4e93127e7b0ae484faf68d2376a7c08d7324686e45abc63bd786cea58167471618b78816753a86dcfbd8fe4b305cf4f98ef9e8021aa6c4fa3309d92011ae8f82bc1689a0bf79262176d9b7bfd519fc950347929973d2963534cc6dea9e183ad24f1d71a3057ff9d1b64af9ff49029ae9d907db4892d007ba5c98e935334ae10bb40675780212897cf18ee982d25777a06f2c118ffe86b9dc6a571830f41dbba6c79654e6c2fe554428460fcf0aeaa36d81d37759a97458fd0617889d9e8aff58eb516cd33be841d8f09031e4e7f7d94092e5fc01b7b656488e5466df25e069677347bb337e27cd66ea55363896d788aa17715d4001fa5811ec4a820206f05f295f2bbcf456e37fa87616c11f2b9bd4f1907274971eb5e9aeb98453639c8a035d8b199a18c4595b49493083ad58326ed7c6073cef4b19f747d11ea7740f375605239f4d4a57738e041f35a772e497605f1c9b69a74ed9c297dba80b2d16914313cf912edb826a51d7fc480446f523e8c73714a17c80286dc3562c43ab12b851c9251f125ce618f01321a43f01b96d3b7eba1aaffe2119a56b66acfdd4aa977f859578025622948a043e4c33b3b885206cdf4dacd6cd49166d4e862f2dc9ec0d921c1ed1c06037368b1381fd7791b27abb04532be0816961dc8450ab8f70cf3c2010cfb8b5dce5f351d7d2a5dd128647ae6ee7a9766acf87883a27164365f3697f7be8ee30d7077c7b0b0084dfd77beab0a529841dfe1595c8c9620e5bcd1ca568e23bf1e7f19c7b27b9b1e323056702447139e1f78e7069b3a90beaa99cb21d2e31731349acbc48f964a34bf8685d7df58854211bfa78d4d626cd6b7fb9f1bfdc6a3aafbede25c8f8f74d30bcb52cf2076ec22f947cf295eaff1a5ecb63415a37b94df752935c6a9e300c73a3c4ed56499f78f16c6a20a28a2f1ac871d9174350a35948380f20b55e99638e058e17036bb136ca6af6e4bfc429f1ff1812c21c29a220eb6273f7ea4a2722a0fe7df04fa47225efc8f4f17386e41e064ca6271164b817ec94f98bc6b746d71e53a6f944878272eedef8fa7b49af493798f282665d178c973ae11e747763757fd13bd36af82b6444ec052b89a57fc43a775256200e3b7b4b0e849d46cbb49573520c42b750c3714102b96d5204e711fa4ef514e14da462b3b4c729e722674cab9344cf2b83dd00e564ecb38a65bc65877b7cabd569046a5bdbb2f0a8d78e36399da2b19d6df92d0a4746f70fc897adeea2c0843a73a5ee61598b78bf8a317c1687bf29eb4641c2121124541d7a1752b3134f5747e7ded6f75bd7168d3b750c6457f0105406402728b7c603ba3073343a40148dcddd4ed4d9bdcefe1c81b2c328a5dc89b50d6357e1896f3c934050cb61d1a80414e1cf241f24fa98315d87f5e4552796a535a7be2054a96fdfaa097035dad0dd92a6b370eacefe46d022b10be7edbd34d8bf377dd486226dc1811ad21b2637e28563d9a34a66e17ed5d695552441e8ae178cd2947a8345bde2386f99ab5da4444a6e11be1d5fe96b74788bd21e2593ba55ba43f8504d7a8a8b362516d42a8fe0696e676255aa8f11b8fa7a22b33e6571ad157d52375475f00a00c3eaa6e96d26c94c23e9899d2046f2d72240656de1bcf7aa68e628de77e8239c7ef6e91f8738ac4450f707864d99cc4edcb09d9de57b04e0bca274b177fab5c131800efc44afda7dcc293cbd6948d95bf1f04c8a2c38963c5207244caee1307b744d98b1f6d0714431e09ea24fac2a0f8241cd0abb0375337654f021a666e75e7cea3189dc0dd48adedb622c25b033e63bebdb1e1537f88aa45c82d0c3c3e95a8545390cad0fed4193f7d869b6eff6476dacbe328b4ac38af946efe0298f2852c45f340ff2b821e0e5ef4d6c7160dd43d6374f57aab1abbe8d3a44a9dfe5494147d776e04136c6d5eb53da39a667105d6d5d133d8f45839ebe55ee345004a22e26667aee0f016f5bd5a08f85b04946a517ae275da12a8f18398fd25e31b5e6f6d2b3167f61e25bd6da08d57b8124134f234362cc4382284bb5cb1c214eb8f805370c274a22f14024066c0765153008bd58b4b9011d4bde4894be39c004f8d041c4da4abd68efd3ac9800ab7ec1d556e8a5194d1654d984957b6fb1802f4a091d3bfc2b432dcf1c207849ee47875c285e867993bc197374d6d77ad5389cbb9dafb7a5d990a5190c264fdcc01fe4b5dc7f5d6447829fb0dbc76ff022be3b3ef5022c7d872f49da05ead8a9fbbfd47dd8bd78b88e9968e02d657fa65322443c90ec65fb0370caf6c27365c0d3e59f3af49dfc448222445d58fe4b2dc7648cfc290a0b9ae63db3da4c187bab47a35460074fd4b4e7e2c5500aa5541ad026d7938ec2dc027dab56791b0894fc8316e6eaf8c32b2ea0caf41c44e277a4ec6058bbff4d6b27820066ef54056c90c0b28750c8efef9dea173ce353c12696bee5860cb7e5f079890fcc324e43956aaebdf84184f63ce8e6ae6ccf46473fd5ed4a8bfc6c71aa8a47cc5ad9897c585f13ced2bc32438781a2b1fcde94dfbe5f30d0aeb2952df874f2be387247047ac91f0c5248c8e6ac451c2fd8eb3012efe2c9b0a20d30c91c3b203a5856621c668dbedac60f8536a1c95e0b21439f944922915bb5cc2a6978211690d879aa08549652d1dc9f0d4ce55173c4d4e6719ee7d5673a4eb78ec7d5521ebc18bceb9c55c5b481238f4756c565cbd83599c51b84e9bd79826dfbefe11921fce6767a0a6d70bc7dc300a780a0679fd13bae41d6d04e5b75d128ba274f7cc45cec5b08199e8684ca91f5e7273d4e2b5b69f48f11191687aed855db5c6715e596c771d520e2d26bf6d06167257422452c60b7d6dacd55da4e1289468effbf6f9e0503b1db33a14041941cc70a6adc5b262d57c0e5931dbe42f7cd597734c1b90854306d7330089cb4bd6c1b56e1eef475f1683b2e78cb22bbe55e1cb36d218b0bf8c06d105679c2e38aeeb74de375673db2645afe885462b6029220a81eb3c5ddce2d8be29279e71d7e7cb258a55df8168ef81c0f4520f0af85ece3d4f8086df90bba75d1dde109e73d4dd682efed8dfc399bbbda6e89ed784d103e64263c4ed08cdbfd5d11fe0ceb922b786c3c8ed620ba8600c30181e2f1c794af994342e46b33ba28fd7c25bb234994439e75174fc9078cc9f051f31121f4532f164d5ca7402555f99030f5e8516139a01302f1ff7a81d2fc3643a23cc79b9d3db7ebfaded139b9c46262a165701dc70b90c75b2b0aee4493b60f148626098b47e2f078b0363879a1c0361080ea2b267190d609c834ee63627c53eda32da4c501f31463d51d79110652c2768ae8547f1ec9347083c9c26cd9a3ead686c5f3cf35b36f0d77bb189d76b598a0706b8ee11f90cb0d9e92b5105ac955b6a799da9a41ee2cb011b2e68ad2eb1d65f66bb42ac198a8b951fea42a8dc865bb59411f0c50499bb0d6fc61a93324503598b9f838b3dc08e9d71a342ca451fd9d0699308dad9dc3c18bad9d04c90a933ca8974bd95f2ee4efe558a46cf2984840e3356c60a70d79efe2d19384a0b668391bd732684f5dca72eabcb70bf2c01357227ae05a773bc01f8b20590ab0d4d06cc4d6d159127a66386f96d0c6b7ce8ac8910d53febbb05582963b5ebdc36630a8b496e60101005359d286f3f75c55d542ee22eed636a149384a64a4f417164cc31d6f165cfa28cbed7b2a9215c6aad39ff3b034a20cc2a1b2efe5d29255c58c201e01847f5b9411b6fad66ed034a982a07ec0c4c3ecb409672472c0cd2bda8340604aa55b12c513c39e6bdcca0d105b0f624a160ab6bfb4d55a158457017f7a7e149ce28c093bfcb94e08986c4e6cdbfa49aba093e9356edc79b4dbd6bea7f5338d35113d74def35e7e08570d6ff38e4db4ea956b791818c98375b3f5949a28327b29e892060581810182ffcbc90009a987e4fb4c85bceb6dce9725e0f84f4e6ae71e237b80d138074484ecaf2b25cd6098301938913b90bd1c868a9fb499c9688c0599edd5295ea3547bb9a8af3fe1b0b2985","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
