<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2c775f95ca09bf42d59a7769c20f9aaa4dd99f7048c8d17bb9ac8d1adc8119b7fee1e47f8cd98e5e12bfa8b9749dc62d1fd929978cf6cfdb566fb15552470fddfdea8f48372ad6e4a63b6391b861d7033ee4da8db7ef81c5d16c279fe00520ba282d3e15d5bbc5bcbae675b568d253fcf7f83e201b65331a72e9ce3be0f25d0a21874c929589850b392e1ef1e4f38c2121ea768831bea21ab5d3d2ec2611997f9076b48cb23162b5c2fad188dede8971cf5c3b070fd895245d4aeac84259035d68015815e6d47e2c586b1af6276ee7741d0f2b02cefe72c9837d68c7d45a710b55b79105ff3b04ce786ac5c4e2a33121df398e5bb406f084a4a376b8e5f74c9307374e571bf3c73c29c0047f681003e461b4f2ec25781e83b28cd42127cbea4bd25d4e2234357843d0bdd1214dffb7b6ca9db7985fb06022c5b85bbe0d7fa17161ed80de56d4eb21547b4508d3ec16b7f84631d54f9ca15588e5df42cb9ef7f45fa0c0e93aa592d51efdaf0e67fe2a86290ee7d1a339be85efeb09b3790e2bdd9e7ed5896a3892d8d5170e59034112ceed200370b096d9c6fc10c9aa88897edbea6c16a1d6cc95ce3ca030a31d90d8298b45393fa08f2e30114cea1f95fbbba6287a369a382d068e35fcbb91dcc792cb9355ec7358f7ebe4f3a62ba4ffc5cee9fbf67d2a2a48844f95093dd405e0f039d5bf5f37314adb58621b6cd3ef9ac54a1b087cd031dcfb57f59e95fd96d14a1e8719bb1236611dd4ac7d8721fed2b533794de0e564b3f341f8f998d96734e8bd3f76bfc6b104de77fbd60d8a19bfab54bfeedc9bcded8bfe3be177212c905e3b97ad18e33fedc2c38cdd4ca4d89dc123a8a0eabb856170851fc5db74b1af63a58c89ad07ffd23c9fb5f3cce9216c80c57bb58d82d68ef021722fbea38f024af757579e0ae585e46080bdcb4503aec74f9387acd81896c6e7456061a0a964682fe25f381e47b0a8cda90e04d3bbd7b1e319e3e461484f6f66797bd115093ecf02d70020fa2065c60ae7640a7b53bfc6d2c4acef2c7431cd85d873c969d6310aea0553f5aeee2e170af9814a56ecfc527382f9851dfeed14d370a8f18fe0e89ced1f85f0f6f6acd0dce196ce166a0a36b0f9f00ba5ee0db520f184d7f9999e6af7eb40e8933d74796b3cc01750bfc8c901d72ee1751ed5d707c8fa5ba4e6d67f70abf82863d569ca62af74dd573fd0c279b03e3199c490a2d1885a6b7b7da010926fca78263151e27c461c2f7f28332a9955e73e3a2fe005841a2c29208cbd799bc797b36a843af1a3720336730568eeb5ec6cc4d15028b62f04d63eadcca491f9a6b0d7b2d5bbb66d9942959c5f8a3586cf762ca92e6c3ce7c02b6476b03916397f16c716e79c0e44a7c8db6396fbafc56091b524f994aaa9be3b0010bdbfc723915e65f018f11b4f19d284e56fdf6faff83563b5cea8233922aabb85b6986803efabcfa7eebc7aaa0761e11a64c87bce4ee7c6279ce29665a380bc96866889dc4553b1d60e33f102a2b5a03b4efc45e02bb3717625a7657a1cff310fa6586067601748431263360ecbc310472748a8795c75b14a10db37b631e7ccc420fa627e978029c25df36b9b4290916427f8a0662347afaccc6a95de0d0afb62bdc82e827276c914a3c2472cb8ff05fd0466c03b38bd6848e415a4648f1e5e838485c1d09090d88960335f6d03c2ccae474b5378d0e67d49c144e95039c30c73ef3d30a1a26cf1525e05f7340eedbdb6d5c07f9279837ca6449cfe98c8d57bf671f60c1708a86abeb9d44014292f6216dde1f30141bf1b2e53a1b0960859d717427645b0bf6d45dac652f113177e660e0fa44308e6614acb383850aed1b3567c6f007bfa11d526c666c51c74ac35e23784d2229fa7767f9c6da6bed78578cdaca08697226550141c769ab14d64a57551a4f0ee985822d4b8e818cfca29a6d62415f616ffa594a0a970de0bc3031a263f35aac483ff3be286b7044746550042ee4574a21b0951063c860bf043ec3357e726419a1eb95b22ea7138c32c40a077d8ba678f1dcea105fb695ebe5278d6849f8f4f9fc026b39753d8c709dd4fe7e949ea5d97022b09cf99502cba401fe1c42c40790d86bd107131203a0a80ce329aa6cd49e87eefad75483f9d7defcbdfa292306db6885bc4a76ab3e652593c4ccde63b9900ebbaf42dad6f5e8e9dab76ebdaeb4910bab2835f44c7d9ae70413329ebf1056af25a0c60b81e91e6c91ced44be73f7ccb88e5dbb2ef055f361814168cbd2696cbf2f22e4b182b0c86db4f503b3cd3da2b580f3a82dad83aac05c238b18923c6483a1c5478003f51e1a20f044e3770bcc817e53d27aee3701f389353761961416688b157c63daa70e444e2ebdc3ea3ab693cbbe61eb37f16dd9105484b601c2f44b0a128080085556c955eefe872f0c249186dc4a711486b11e974453026204b60e37b4382d4aa87f76b3b09d5bbd2a7f5627000270031562301e72e1e1e031bc999bd247fd88d6e98da0493b1f93ede3a20f14efc988bcd792e3a31f316435328b4658df4c50c5d01d915b59eba91017b1aa07b8c000e0870e50c115e768bece9efb2a32b562b77c6a70550f60ed056a4a90259627c4651f780bfe2a2bed177bd2aeae141c5f99fc0096cad1956f3d97611d11062d190f08ed0cb9cb351f0927f5f41f73c46d406f1c59c9cb9686f54de37687a792dd35c253a72df61542b5da2de94294538c7977d32fd6562a71af447b930c2f0141696ee85ab2c3f2cea96b5eda1428aa39ba6b8c4b112ad489c04430cb9a77b58c7322e29f4417a54ddcf2a37db60e51c6353fafdc9c4cb5c6acfc62efb3e9b0432d6336154e55ba5725b818a1f4a01c337f274afb514b069586c63e8f680cc3bc5dea402f5f926269355b49eef306a0fd8ff3a4bedbe85ebb3a2f03da494bd9e03d89a374c59cbf3882668a60a3918905880c17eb286489a12d485e72581a44fbf4e2bb0790392357fbe3bebf1e5a17afc3a260aae5fe50fcd0340606665fd2ccb8410069b4304d57df2bee367638380c10c43f04ad6dd49151e3849468434d14993d0de14f4c901d7504f82fb560c2d9b814d3b262f5ffe48c8b5f9fb41cc6ff4282dcf50d205854c356f8ff6784f270377586b6a40462cb2082cd27a0ea24eccd9613fc6692576431a39a089242b6afa389a2641b4e394143264674f57e485549db26cbd18f289f34555364501a19a981b910101fad033f632447dd95f19563fdadef7af1d27c4e83e819bb9e7c646a3405f342e79422a36050d55c4aa64da2870170cb3306c25d1ca9fabb77a2971b465464307100c390a3f477f729f4830f25c6ad6e8118e1b143f12fbd55c322f2d1a81fc49fe3471f787b4dd8b1e8e6d5b07ce12734c5f88dee29b5042a230158b888e17726375c653ee813543f49f75ea5629e03887f92b5d529f4a7ade4e53085ef72b887d892fb1183e6938ebf4050f0b348f27df7c41f8752d4bb44f72b4c9762d2a54ae4b8dab496e7fb29cc1b297d5d982e07db6ce704dce87d66d99a742ce3edbfe65a78b85253d414cf3f7fd30138441ba052f22f19a595c2d82458357cdf87663df1db2c2812edafec9a44a583fa6e481b46eba10ec774dea64b7065910b669c99fa2385318dc8cb29f0e6a90dc8c2781228bd7463b817a0c884938e04f37a691b7383f540356d601c1e862ea16df2b756db031df6c942f836d6984351d676661b10927e76adf4cfcee272db231e72a794db3462b73881c7109f9efb503381e95027ff31768ea50d17716f85dcaaeb5e1847878721ead7b98e52a591c319d1bfd9d1fc297e55412da9a92b96b299f21bd77f81dddebee94bfc0ff59f3ddfd59ec12501c5f9d42da4c22f1a831b24fe744b9df1e56642b1aafae6c47b3b5319df8e5bacffdb2ec157b584d7fbbd72eee314806a2d808b232fc2b75cc9bcd76c4a5f87cce67f017a9c053356abd47badc2723ffd2381d8bcbe8b3387336053290520c9cf558320fc85034f2f039f7bc6adbb509797d5e5eae679aa28fc30f2a60ee6e5c3f1e572efd607c9945c02a93fb0a771280b93ff181b5386ad95c31981a0d10ad121d2d34e647a4f8e32077bc225974dd8fac829d9e60c2a4576b21a230c2dc0206f394b254aaaacc5ccf2c2c9bd9270542e975a0fdb628d195cc4cc6d4a57258ec9f41ff427e9573999dd28ee1f5d8b92d33786646686f36c517457546e66e5e2b7ae4cc2549b895fdd273fc44cfb8ed828c566e609206d3849b3e315ed23748f4209251b51de6b96179d8ed734092b43ef863f5975caa8533d2492a038472a7b35b9e4a449cdc48b35ab6504ed86955d3985c4790412edd16b38b04f986fd30f2e247440ff002ca29f381cd794706bca89c64a61aa74b49f3298c880e18d4cf9619594279fda9a0906735edab5c1b2b3eae1475cbd16f3886cbf34d6020195f99d9dede3a95fdfe03ebbe1ec4c7e19626183bb9d2924965b738fd6c90f97360ae92800e6c0e7575a9ff3a88ed617cf837754502dd959fb8772617690d531eaaf8212b5490e1a6fbecb9e792e9d3c294439fa6f28fefd0f5913aa859cd4ebdcd117746b93c680917f62ae3476d81fc38c3613d6c5c323300347ef8d0590adc580e24f26375f6db1b30ac29a0ffe38bae475573e330973391380354ba86084fb9a83ce2e096fc752dcc8149423ea589c60d31c551775aa59ba019bf1e7631153b44aedca47d8c5784b2fbe2dd679e2d468e98311b31390bdf6db5aeac7d94ac3286c7e1a3f503f9ec347fbdfe28ad5ca913e96334e6f41823144ae87b3c030e0f99f9da42bfd0d67c1cc0bf6cb608f31152aea4736620ea136670e32046a96475b2a211d2635663c4c9103d97b869664af6ccda58f0c14bae6f450cdf2f225fc2602fe9096bd5a2f4daf3acebccb801d9fc2a774687ac124e673f24363add78a6239172f668e649c345a7200a0dae965d2b611eae8c8c2fb98857b63bad2defd4412caae343e18ff99fa046d6152d8608be8de41b81435e5c55137c11c4461fbc2b6e6dc1fcbab0db7f11df28c2005131ed7210537e14a780f2b94f7bf3c0a583561d8f39885531c6f5a6d5c14e7542eec9b6a6e554aa9f9874788b22f69b244532e4045edce88384809bd874aa70ff9a73b277b58934fd25186121ce6b2b311113b25f63fe0da5805037724f28b46576308ed05c98accff5a0411fb126c9d6513b13d6f8048b4726abc0639b8d7a30a28b116506726457a1955c76b45ff944dbf9936392f17f273a3d8c79c7ea98feb7a9160a01867ee60b0d501ba8273e34338ef9fccc570edc0a5167c1eb0bf5394bcf804a17aee9ab85427c8703cf8c67068bc662dd078472d97f2c56d34ec2e1e8c90b5ccf974edd86a967d8c81f0f1053f246a64201ae3ebdadb3089fafac4f4a057dda468920b55284be08d03f201357727b2bae7bbf7ae9fb27e1cc0e143625d5b886acd3b35e97809b3609f64061090d19c5691139bcf9a6231ea4fbab52642d379624a47513faddd2d30c0428da5c5b745b4ccbb6888b4b1dc84840076d1578264f6eb4fb0bf4300699829728a5548c3d6e91d19d8f9486e23d8d80c2dbbde96fd80fb2da16b70a2b4cdcd62778ec341a613dd82e24ef734d6bf2ed2fad11d7a4b9cde8b1cf8fe1bdced38804e04ee98d6fa29750f9b35e6c957ea0270dc75ead732adbeb303c5d1730e4819b59c88c31945ea3328cc0927752a7b2c40240d760182730b399095e8a781c136867f248b32724a99b772da505e72c97ad72c0990246c2594ccb1c0b8b401518d87e03e4ab475e6f99f9b7a6662c6fa0f84fafed03b6d4247f02c6af304dd8265e911310235f102cc2bc110cb8664ab91bc98ad9f3dcc104165ea6d2b2bfa6881ed717baef212c4c72132300d2c2e3e657c71e8ef92ae900ec7d32476bbd169d66705e905532320ed2c8e0a1493196cdcb2f8955225363510acf67b106f87db613099929164d639e300e1912646b1fa097126bf8743264da2b2f371f002c4602a3702e0d71f8e7b039104276208913c86eed3e377cd4b857a164ab9f66bade35541aee9f1d91e02104e0187f770b0aac45a731ab048ab14b5ec0b99fd4e9327bf64981e6f4025ec7855b340c11620885e2ef51c635b01c9865c2a12b494a7d419fae8cf3297bdd138446eecad189bbee257c721a3eb65620a3ac1b588dbea135dbf352106ea194f56c7d4f40be6b4d50db3f9fd1142ad7612f9e6fb7183105eb6caf7d7d84d1a895b3d6d11cf64c8c277c13ac38564c1255ed6ae8426665c2626ec59f247f1c27d4cfa4f0a3f301094f4c55dda32d2ce697210d6ed88d380c74a26993ee9896f2a82e355f0cb4e6948d16608cb96b1fcf787854e9f56715f8e54a6a26e40de77d422ad6e0fe2842bb2eb6078635c1d5daaccc4aeadc2811729671201941a749301087a24cb62730854d7ff88d61b92e3d10119555741f5b2caa53f7b48b2b264c9e45b8414c9fe33a23d473d8de360e4ff7c911b2c6a9da371d84b2995ff90fc93b7bb07883a0622f43ee4095f0b29439b7223bd0a9e0b6145033331e4ef1f011e49d06518960826ae1cbbe37513a7ee9e4df1147cc892bf3528d0a0ce971e5f8e009662182edd457e13bd8a3cdcb919162cab5f9eb93d2b71d26a1d17e02a512ffbe24d28614296b29f519bd4d5417297750c30fcf05351ff62fd75b3fa07661854779f80518ae9bb227c7d6a154a19ea0ffb3314f91975a840404285c53dd7b9315bcce9cd6ac041734a4247efeb29f41446135bfdf75be861dd35baab6ba390b0517d780a062e3cc0585767ac825ce1ddd90a39b53d08642f6d23246869491ac7715907e69d7ae64cc930e3a53cca5fcde2f4ca75f7298e140b17f2d6335bbc5249e13f78fd28c2331c50735fa595399f1dd76ca9d0c2430f686117dd052e148f3b9b574daf7d4a40ab219e4fcd6f0a9ae49217a5646a675b490cd3f20f6ca64b8dab7377218535a2df7fa6995afd5723b5005b2734434c22233ef28be0841a7c7ef3f307d4d667619ec20bb4356890753bc7a6c5fcbedf037559cbb3c9899f85d57471a1a0de3a6886620ae1eba1bf88a53b1b68613e96e8698debd45320c66b2af04681edcfcf5a56937bda842d0cece145b1236cf7acf49b0d0171bf07e759c90646e19d3fda4f749c2b427c2b3e0fd726708ba283faa136df4487e4b3e04e0e323a48cea88701071c620f5507953d53c67b170e0b8ca34891efddd06176a1d203aa94daffd752d589351e67ffa43c395b35451dba54e2f87901c5d8dadae08939550d84aff53ee802c965d8676f5182fc86c6a2f7826049604d423017216a30375529512ad7f80c3a93ca4e3bf0e5ada4c37bd161b5e1c70e7166d71dc70f364cd6e895b017e16680ada7e74935e5ce3e5145fa6f882b031d73cdfe8ee5a5224d36826f1357180a4bfd3a9c299597dfdd53a7b566cde67641aa4fb2fa28d4dca3cbd865f95c0c894fb410f1018a060374afe3d3c76b74b317d693db9091359e0311c07c3a9972a74de8ad5488b2f7a13d9133cd3a56cacff8267afd08a78f72603ecefd80968830864c0bf8ee8011b4733ba8f30ab8398cd869b576b87b7b34d6912d0c1673bbbca6e7c606ad2043696ed446f847bbd4926764fd720def62f34a03f8b741db1167edb310be5c9e53b404a7dcf59d736431301f61ecc10895e1ac1fdcf1d5049763640d2de7c61e5d6b8a17037d62503754a6f34d2569e4db6141d2f9964cfc35de3a71bb4a523f485dfd09375b79e8285244c1964da3752ec5956ac9d1013b899b689bf67f83e22d5865be21fc9794d225c81cb26cc28622e50e9cf579c3c59b662f9ce179dc441536e3ab2da4ea2aba278a296e7c036d63a92a370bb15948259affb66cb579f5a2d7e5acb0deab3a1b842803a36682e0671b492adff85d08f64c43635e83bf7ea5cc8c53cf007e22e4901db7e092494f43201be59f741c8a50491f3f60e55531cee7928c4bc5a54d033bb0371575441b6711df160040e9253666575d256de1b91238ff6708c31940167842e74252adb62903f2bb2bdbc22e499aa2218837ffc3652598b656607d8b55106c96a1d5bfc83871c6730388ee57dc67451ea8c86a2b71fded8a9dddde4d716bae65daebe0eb31886c29ee2eae254a0428ee530632556724d292bac0d97f4c999680c11ac2bc80254d6d0a6886d6d05e29dd42eb3868cf985a0d805d565864e35e3b4184c276c421330c4f585029d055f56f3a50f216c9b19568db3bdf75d738335cfaee80d93823839ee69a0437193643c1f0e44b8f375a0488d4599438e7c4f7f1ae02fd4fb9261ec3269d483022383940031773ef6e432e9df96d7b55e3d16999cccfd44fc53d1e632eb9c6a7abf4c2574357d78099c7cf9ec9b580832e056facec83405d7cf01de87d0757b4e066447ef51fad4eedc3baf9cc832f760be98d2db4e0e18dba4987918aa7c298adf01759b8edced46d2b3afca74be65fd3043511ff02332527f1d4d05116b6e9195b67cbc97718c3026504e91850afb580968e016b09316a8e8547495f2f691f19ef51537a3e2d7eef95d744b0aef947eec14bd379382e4fc7bfcbd7e9c476cc748d1db86e5f0c4d1fc813347df22664f5169838ae073c66571a4c240c4de0b21f07c8fab502da4687adf7bf3287e09b4c70a75a1b11b65ef9f89f78c990ff3c282cda33dffa9ba3c0ad9995867f4fc0d6e6bf6a12ea7449b441cd01b4d127e5ad172d41618cb7aceadf82cc2cabd7657c226a5196b34c577c53a172d15fb46f8f198b1926b6869107cb98f2e146c3fb785cb76a8baca6724b86eaa3e0b9704cdcb86e6527c57415d1c73f92971a53839b9874bfa365e28e4f617d0c6ffeaae628f7b31036b4cce13234ca7fd3df82136ee3939f30c24d27ffd8c3bebebc599ec7fcd284966462d6e90e3c9aedbebb5227111bfcead04e18122d3c608680bbce692048ff8d7c6d0faf9a62d5d6c3d7a25a3aed0af96661771b121e127ed034394a5ce9d2f7110d963ca70141686a9ce1ad635b7053999f67edb44a4b8341738ab39902f3daaa350f90505afdb92329e1ba4a4d5d11d2fcfdcb679e19294ece101ea59e18d7e1ec96be5220c0edc4b2cfd732fbb27ad00431f6a3defcde4dbf417fa0f5d881279d92d080ed17442d6436bc3aae0e8cf34c2bbed2443352fe1a739a7a4d026c5aee2f2eb1a3f0d4707dedd87dec2b9d48991d79d6c0ac3d6d948d76d4a0d54d68482a2c66d5b14fedd0f8b8d31bda9b5ed89895207cf38823d9157b53dd6301cdc6f1937a80810b777cbeed639d5d63b48053b3d2fbd7c0e8199b88082cb8c657c672327705f00ad1bac48996c55ee6bab36aadcb6ff6216a21287be2e11379afc25e74f8638d7296c26b2d53a04c24774869a9421f8ec90551791b626a98c0539aaa915716bfd4072bec6d140d142061f61bd2d38151193b31aa47713989b83baafc02c82adbef6765585c5e1fbf3e7b5e28a1e1815d70270db8d812aebd0e69c9763aa50d59f34db348cb495aa2d1ccbcc067db092ab63576f048bc069c5961db627da2a8e909f2c330ad81169b598d67b0542838e7ad88ba30a2e37e1bad7113f97480b1934a8ffbff82088028ad2d536029f6ac4d1266444f1d01472c35d9af6b51abeacd0782eb9b70e2087ae971068d96c047681331c85553f43dd3ef1039e58709acb6005a6f62a08794500a7aafd5cce4ed818a071c90b5ca224e782075650c851ace6463dacc8cc5aef215fed437dd338d06e102304cc8cd1532b1785e206b535b7e107c3b19b75aa8435506333d36a17a9c047baf4203815d19010acf81f933f717e7b1cbfcb8a848be32bb8e32678fbee3490caa96717ea36b9a673bb2ffc7900e66807b7e201c59a00d844cff2470d085495058c227bccd38b9eb61f4d990e328e0aab98139702ae4ad9d90c4d7bece855f8169df8ba05b906e5d79851c49c98c75b012e6811b0b17dd2319320386123fcf3ad14c80ff0faf332c53328cca8f6e9ec0ea718d1f714614c90fc36e1986d0a7630b3fdda7fa61772c66565680f9a348ca1d3b00731953aae6fbc9b042bb2e15dbb9f47eb4c9a784e75c12ada5b232e8f6d557a5bcb1bdea3c5049899980e866b52cc6336631e00e7d57c8a07be3f6333c9f70160bec6336e1136dcf7f518e7fb746cff265fd8019072ef84e190796eb30425d9b022822c3021e7d86cafe5cc4f3547b8d632fef8b226f13689bb04adc50e096620cb70e40ca13aad8c4251b870ea2f18a64bb845f477d69fffc87c9f964cfbc7d09b9449002bf70c80bf4967d67b0816c69fc93748229ef802908a516e54436cf04ad134436dd5fb4d8afbde493570e551172357621410edc8e0878a6c1c1e36239e1270828f02a0c59d4d4afb564300845efd58ea5aced5c091e22d613e0816692af1aabb685d1f14842958152b0b4e9d8b3ff15af5c1ed152932faaaf9b3df1150ddfa8c7e582c03b7125726b1217d7c5c945f29ae1e3501118702142e5c82b0a1f97eaf191a3bec1085a50b696d219cc8eeddeb4ca607ab26873081aba0b4ac680981438b71f01e84828d29aadeb4aeed1f71ec08ab2bd3682b2986dbc8ddc53a2930bcebc0fa89ea252f3b514ebfa54062bc3540dc2e702beea7210aff7c617092affbba681fbc609957d0d60f89f91f122d2fb6412bea62855519df39689a6cb40d0e6589a089ca84b6e709ed6aa38160d83a96febc03cffae9304df842c022ec6a05f7ce0f67caa336a92e7c6fd671785b9f847c0bce6806ed65186d9bc13d6a0b7858dd9fb8244b84e0e34ddac711f633b344caa5fb0cfea57a1f85b2b72546efecd73299ac704a1caf934a0126345895c9a7b15d20ba74dd677be6b1001276c46453ed0c2bf6976dc86c94aab7265aced4aa14ef7fc24a9e241109d2dfcf5dc4b6688d59305bafebe51cd73414ac6caef4d13e93277c1a2aa6b6a63d2c07f0d5ccf305bcf5d2cb9aed0dee7ff1ffb78cd72e0c317b8bbf50a4ef64755f95cf9f56a232bfdde0638da841112fbba500cb22e91f0fa696d959adab4e07c2027d63cce3fc3fd0348401675a1e04a990832e0d32a85a32afa6221382d79239bf2a7225fbac9fdf1410a9fc327c69337592c9896026d2e73a1b325cf7e78e6428d35ce95d0d3ac27aa075f36d0293acd580e50f5f2a5a0f219dcc88e6145a03835d97957d1548897cd281cee7dc64f1090e11060fd503f2dcaab6e60ae34b74fc34035c1eff99e8a2ea4f886427d571bed78de226de013479508d1d5b101f375c0dba6bffd031d32ae4de5d386d9e22bf8ae50350009d1ea5069a094724a9fc9c990bfb6b4d9fa363ea3977fcf4dd1ea7d072c6edfbed2d4cd6d6820215b803372188587832fd97413f07938564992b5f40619afde11c4061af4d50f29cecfeb5afd1f6e9991e681c0cad5a1cd464a7e3b452b2e59b34315cb6663d084762704a8d8e1b4bf6fe84846ef828200c5a15ee25ce86e5b81ff9b7312add32db58c0eb80885dba874d10f2312068ee9000206992db3eaf9e7da2dd1380f9547cdb8f4a339c00bc7b102f13662ed89d429b53feed0f4b57e9354bfad62f2f124aa93dda8529efed3862561b9926d26b0348f9277ea1fc0882ccd648ca0648620d5e35cc66029a4f0bbd77c4b454a71a02a80281fdcc232a7dcd989cb67209818f2ee335baa45fbea272b7926a4d990fb5befb5d9fb04177abf14096048d24f0833b45a2c8d32fd80245c7388996ec15953155615e1fa596f603bf40790b10a5e3c8f1eaa551c46a208174d5e02204d556d2719313cd25f4d59ad5303bba09257c110b4dc197ee9a29381c0982f9e2ffede612140d28c4637fd6148a8ebb754da822c43c4c7b03cc51a66a2b569ca3dcadd8fd0a2387d91cac336c29aba43d8b8d92f84327ef3add07f6877f971988863d4ad8cf0c2307905656b15b6a9c046e582bbd8de15bb4490009bdd3122ab4c299bb66f30f83e5004c994f7ab608b1368705ca17d4f37d6e5b313a2dacebd0bb8531695116cfc40d442463bb42202e0baaddbc27cc68359cba360157a72b095bbdabaa70a80148ec32003286d4f5a1ecf8a45556818e3be020c85bfa9fd0f61c6b8e6770e30c176d6d4ef68608b567e8ea3d628c19fee185130b671319f057f734b7f0535ff628f6fe5420543c24825df65f4c4fd52db82259d44e01f16c6bc0979403d81a1b27c210a4755e1ca12d0981a8e35f3e02c86b13abe8eabc3a421429d6ead5ded7fed4dea225ef7ad9c89d2ea2104804791276658a7e059b6d877b3266e52bfdc8757ec4e0dff490bcc3e96d92ab6d333dfe674d499678e8391d7073676af5cd4d1bcdd63a9d32480a9a119d5a14f0c51994ce78d38b87c854095bdd1bc584a32891b504bb95580d0eaeb0d29f6fed4f1df0bd46bb311df7737ac2e19e5b9c03b9779d6dd33bdce9a1917ec33040767792f84d381fb04330d773032696841efb3269bd68d53f5123cd5a1c8a077154315ccd04bf6ab9b3284ad60fb5c84e0e7f80bc9fdfe315a15480413087970053510f87681194624f6915772ea81b8fe1475b2d5ea36c507d0c46167dbee2562f40b487e4df89a2a4b8504da1341591c1ebb322c605d4e5a76cd81c3755579b0e12adca11396a9959572d21625ee3bbc93ee9d76affefcf853fef0e5a76317a916f9477d8ea484eeb0c8c9f9a3107337458dd30634926c1d3ad079f0848aa04b84dc75a705f988e9f776760d0f7f6d2e726c3436616f336259f641f54fd6e50848730e3e271dc04a16c8c4ac7805c41be1fbd73265828892ba44acdde6c94211bc59ac5122fb23c26ca686965607ea9f8fd1116095de3d5e6ca85c77a25bfeb3fc228eb66b5a1d8868645d3fd873071cb626fca86646","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
