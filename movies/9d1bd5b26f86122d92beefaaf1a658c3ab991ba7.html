<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f169d260b9a64a4588c72741e334eb660bcce20213c169c88dd53c89e3a15a1f420286f64924a70876c6443163541d6dd35a39d7436273b5b027e1b31e41f1385d97334e75073ee20234faa0cceefe0d837a1a9d974ec5c46eb6a7d161c827038a552f73d8a77261dea0369731a0edc1ef53b26eb45392a2c0a5416a7001cf3dad02172714fcdf2179e09c07b84ed202181661bf0cef14060581d88b3a26238dc75e4607b5bac159022b1180162791afb9f5ef143c9bdf685fd2af813b4211c896b6f5ca10a360321b0be5db8cf80c3f7a38f23936ea430580af435ce2c1dd0578ad5ba942e0990e861279d47c01725366c3a3a2d92484037bda56063075ecb80aa77f29d74270c1a1b1ece53b3b402bb2ab4499e5c24e0ade31096e244c093c09d2851f5256fc1923234906b88eacbc5fd273b45ee0527428e35fbcb0ac0bf64a7fceae17885831d4471c482f57958223c56798544df530d4cd6abb18c0e9f4dfe84b5684138097c3c6545f5ad46e782abf3472e01ead451f717f3d5f31d0fe6cede405978a20716d8c24c44d49c83dc166142c246c328034ca5d49956c2eb1466a7ccf08ad7be98e399a478480712c9b0d28418b81abaa7aacf24c24002c16a52b5ef119a27b8fd14abf6cb76bb74e10416888dd28114326c39f0f0215564e14670809bcfb90d803037fdc8e9bd6c9bed28297412cced81c93af1939b2f344c3f5c638acff55e35068ea42a0c45e84c509501371cc456f6481c72e3bc72698598a33a4d09f02682cffb8823cde29f2e84c679c784051c0665b1551557562f69fa3d32e4dd3ee29c65b073cdf702b15f02490f927b547ef7b0eedec708f4754a63ae47d0f70d0e034aac5790b94042a50412d1d57c87c9602178cde15dab5ceeaefc32efe803db14094d010615e4bc4bf33c7a1e6436f92c26a88216a00c7f26a1e4629735ffe7e4649b7009f2f75a25d18dab34c022420ea568bd3695406894cbb6c8227801f843a06070f1c97cbe27f47ded6c626a5dfdadda1f932a7749c94848d223d2e2abfec70069c0eeed564fcaa7c0dde5430129543fb224345c02c3c0eb6276db7563dc49d2a410ee82e047e9ca923f0b81fa8803a3cccd1864a51d292027fe789f52feb40154e98fc9c896d160824f8ed82307890cf3eec7fdc3da418fba21fa9c3de81398eea017a5a0d33542b7a0bebb70b1cafa0ecf9a505b3591169cbf1850cc7be4fbb7807365f3474816f79a22b0d25a8314ba173bd829892eb66ae635e8d77d2c39144e54830114313b0dd3ca9648cd449193f63acccf47fe3d7e441c0b0b4cd5096aeead61b7e6a15ce1a71f846f7078ef2f0b1215d85bdf0c271af0104d7132c783e4cfc195adcaf7ce3253f11da2ec587c1a3f3823347fc4c308229642301661688040fb98b8bc92540a57d6a60fca1fc7e4a85d6c706e91d844dad53f51feef0a136bd34cefd08be0e452210d1f63ed6f95015d0462f2fbcad1f6e3fe1b09de99f18f6edd9efaeda0a8f9ee1ced11ca1e203cfca4264bf5190dccefb6114131dd9063ab9a35486d10420a92df519d8d5e080fe5e1ad1fded3a5e76fba9b8394ad8bd45947d6ed285b70a96b6e4ebafdf0a18185cd402314c5001f307f8967e3ed4a133172fd5a1bb0b6ac3ebbb6fcbd023390e2231c05cb1f27596921b00e7453d1e66baca69e07d9bca3074a1b15548cd5d31c0d6c04309752a8b4bddfe2a23adc482d73a226f4280b423c3e75063d32d5d83f7014e04426561776b7aa139898c5b800eea792d17a3b68d27d1ace92201066bb3ae73ae558641ef6a48b0120b5b90ddae3993521dfecfc306b75eed2816ddd7b712ba5487ed421ad4ab96732eaa97f59c6b0a2757bfc5f08e3ee1151a3bb1ad732d9b33e1f0d8034ecb4db97c0c9f7aa81ed7896e1c09a60bde2ad9f45c9f6a8cb6110d437344a7e670b5beace628d78c0fa0e5b54f1c032255980956dd1a2b3fae3a966b97a19055614fb7894f9c1fc57389b3c2dba923af1272ea9607c8717987e69ba2f436f816777800f181f9ce7ee06a968abcc01cd2604152e86ed1bf35b91f8ace653f2d62e6ecb44cffac19cb590cc5f8d2812d1b56126da890e2b64b539492415a2225991deac16915a3f0f32b0e888ca235a671eec3ea91258125929608c4323fee9a27bb52bd593f2ea7702b07d548ae8850ba3a40b6ef3c92b5d594f95a762990f1493b10fe41196a3614cbb66b054c13d7c77bc153eef4da84d8dacacf3e373f92ed81263bca49b1d1889b6a989720544913b5a8d0863e4e4a90eccb77f6ce35c96df2eb8aa90b323eccfa05d0b0f10491eca117d10e468bc9be061045d0682b1f4fa8aafb24e2d8f6e6c6fb786c8fc8a2ba1b2cd4a637a70ed3d7730a07c57b614469e8751da93993fb146a9bdb350c30e4f1e8127d3607187d38a60ef3791672f7ec010693299f2302ea5ebf065dd3c15d1cf6051e17bc63af6055476125f41ca01ded2592f164632f0cb31a94d96d42fda451b80572a6ff6271959a777551cf2d9fff528c953cbbf3cd1757f5bca537a4c199cee67fc80ffd1159e1579e76537bccd8d3740c7835d1013651bb6b0d880e783f6a7a253b9b2a1bdf5925f917f4c9a8d7c5f9ef4269c40f5efcf6fb9d3b626316f0c925c6073ca5d39be8bd0efe42c1f550222df8c544116466a317ac6d368e47b508489c71a56d0f72e36d5b52743a51768fd9717146400df70eef19d4f49474a9d0a429c72cdfad5d54252d8898bc43bdc6e416465c6e737f629f134eb42a27e763ddbd14cbb5659f80fa9a0d1f661cd020790d4b9528ba23e88bb7f6abd9d0eec8748886ad35986299e6b304dba0dbcdac918212c6702b75776e39ff0c5981b140d3ba68550ecfae6685734304b8682bc94073ddd864bcec789c8aaeb70bac462dba60d6dad1d0040fac0a9558f16c93a04d19572e40bdbdeb57ccd3ca98f0c46c147d6a06c693e5798de8a047116c3867c721501a7e5ddac2298b879fc446991a012461fcaa737ac94aedaad027c964c9f9825802af033a02a6ff6e32e8b52637d690cde5466506f1a420417d1a80bf5cac5c02434d4f8cab30cbbb167df6123bfc6fb6894c6a9c041a4137a4d6a8ce48faba0f7db9d475658aa35763d3280b85dbb49d7ab70ba4d8c34c3ed1a9dd7b59c827ffc315ab689cc0b3c768925ffcf5d791ffeb03452694763821f14f00041e209fb48bf1ec09ccaa7863210ea936ac4f6439bbe028ee3cef012834444549c9d1e69da94f3918b294edaab03b5ce792a91c4ef8b329044c15febca4a4a0aa6c96daf307b258d9d88e5eb6198fcb7c9d83480060ed16e50a99296ce6c3bb84786ac5f7758cc33f4d4a0fb02426140e15cf0ccdfac4340650aab44d7b3ff50f5cefab841fa5742d49357b5ae31ff52826475e05033adc6be3474dbbf1b3d153ae312e0447402c72e17630e2e857657fb647e3ed4feba429baf203f34236e2d3757c5419221118e74554b4b7f38ed56f9c80718c34efbefe88faad8d3eb2c3e681e3bef4a8f2e30755c47121df2ae093709e7e5913b0347748c4ce17dd302e377c92b22a0ea73240b5c75e9102f1b94f180aaaa3f6c9b6126a2bbbb9a7a9fd6e1bf9de11ed639f5ed96a33d792ce9744c496d294e6f0bc5c8e3d6f44b40ae5fde07adce3ca590697341c2c38ea465d15fadaf74cd3923bb5401f504a0c0261dd5beec88ab461d283317b825acabcd4349265963f7ad22f605a745bc3af1f376901b8e015444fd1afea25d6f7d4d42e5980db3e280dc1e02de3720aeaf83dfd1ea6337f5c9d4c1b4a31076cb8c6d3fbb72ca16c5bb31a7713e587394823c20bf23bef8468ae948510c06690a02dc211d1adb28f6c7beed47910c32d94d212bd21cee25b0063af805789f95d673ef623696c3be329a13bfedcb6a025d7bade5cf401ce43093f6c10cf4e791756f1ca7873a85e810d6ea66d820cd3a092674badf3310c5096bed3557a8c6929f8128caf5d6b2f8ed7ca4e98af42676a1f58ba1e54cc607cfda2dfa79115e3523230b4ef688d7c44ad3bbd8deea3fc4cd0243927656f38221fe798a0acfb065f3d5183f429ed8e19a9cb0429dec360b9429e929e9c18d75304bebe8d919898277c68a0fa3d0070220e8f988b81eeb631f475b56289c2ea0a0b6694850ce4488b6f0c85faddcd4ef3df62343a8c570f2d758ec0f6c09939c9bab46d2194fa7c5d9b47c7550efadf20aa96454bb1cbac6b3bb5174d08b27d9a55e76fee6e0ff8f7779fdffd6f128616fd69e2aa656add6971f006b28bc64690035109dbfbf4eabcfdc200009c9757c28c88b88234b046af48979ff6ae23089a89ab3ab41ade88b9e465009cdcc629c3cb3e6cbdf6bc9d331045a52677c3b02cd532177d8e5a26f24319c71c4d00135b2d35fa3ccba906f389657bbd34c150f6a5c349ded77c77f58a2631b23ab06ff0d59a2a0ad3cacf080b1e20059447d82bf45cdceae4b314ac225fb92df9fbc1549e65ee4bbac20cae4e1e19246c6033dc1bb6f9fde3c775d98ba028fdc783c3bbe19d5dd13e1c1aedfbb561c785beb73af8f8d5a47f3a10863f23e451d2b321961ba3b45cac230821e1399f19ddf1c0732e9b49ff8b32be5f8e26fd9a24e56ea1d2737259c22b851b76000e87e96b77c3993a853d32f1cd53a6ebcfa514fd96171106b151642def02e9f8db068839e984fa8bc8abea0dc05809007a4e06654c482071b7c58a133ce2d2c1db3899d5b750fdeea3def5346f3c93f98d968097d7ba24301f550c53ad0bd0e342a4badcbe726a2dcab57fb767420654f46b0e709bd6f70643a3d181138943706a7bc64962f7f0eae275f58a624d2cfa86c369ba1380abca70a86b1d6a0cba7b5ae080160609e15685c85d8c52b2609a17f6511529866e325279880a51c455d4396705cb5d8c1b6e3bebd2f12da08e5189b4da117a2fe08b8f35a86fb300862a8e83f6810232d1f9b274c7203c4ade572ea438d92026b274b8d3cf08803be6ce176cbf56b0c2c7358d6a2f27622be134a3d7efd6ce0b024d7d71ad3891f3d1eaa0b7e406c0b8556987de87e7aafa75fc2e0bff26a346bcdc8377f88f7b53bf6509406aa3253f9885cbcf81e0127a5c7d9239f316485718d98c589bd05b2140543a702fbc2947b658858754f092bb4ed93ead717d5ece68654028eed75440e8a850f0ef3bc2ada657b0aac8fb504f2673169202e44c6e705373c2479c29d7931c3adea38ec00b3657dae36f633608e887032fb024fff2caf7e7b522924ffb71993f5fee97267926da6d2f0588ecca89eb40978bd14cd2b80fa5b33bd8dd4765967cef0a5a137055e79646b5b8212d389e82f5216eba9181f86a7a15a304c92ef16b7fee7766aec8abc437bd9695ed6e0bdeb74db7c66e62929e7883ce02df473eda8e936858e17e019d1adcf2b595bfd0ee8da5be6da1ab7268019530c8201c9b137789ffdcfec86227a89da748b069cbc934dbdae5093c7b6f4ac23e95fb581af1bca00d9da9c295ba312e6472429e070f24675a63c52a20e07b3b323a2519cbefe53cf1e9cdd016dc2e80f33961abfda7946967059507f4f866a994b87142950d0bb80b3ffeaeed3483abd345521626fbb28ff341dc665d7ce10d388949ec9e8f55ef4f6d6bc2f88b1f1e386dea2b33c114f87c5cdaf0ded43de6606a74392149eff3d59520672bcf83eaf8e17e028790edfe4deffbb071f840537fb2b120cda91e6074195e4fd2e548512a7974c7decef8af44ea74093ef1ccbea7edcc7ee5dd8b99fb6bbc16a5e2c1341642a19d1bae3f322f0d8198e9b1ec536a16ee8cfc39ae701915e9032271b7dff76fa40a3288f894d18e111684298215bf8f56ebf3ca85a9c17f3a0e1d83407580112b6c1bccbd9b1a2419081634e2d7da5d654479a275b78536ef264c97ee1c29d976ecf5e7167a06f3599adf058a3b752ea3c74a7babc121de010827648f7a3ad51bde7de655752e83c35a9582175902333470744bc464db4012d98e513539ddc7af90e0d4d799afe848eadc108c264b0f47f639677a02ea5320d7f49c089d3991226c7f229a560918c8d62cf2e6175feb51a13617b9e9d948d4830e05fd2327cb332da889821ad93e8706f04d0091328b65710b64617ca1a2c63f8da2cc67124165f34e795d0d4c05cd12160b13e1e64baed8b125b5fc7610279978808531f92d1eb8493558b6d41b279efe402066717e451d7ce985cd501b5d3899677d60bad71a53352a625be769d6703560f0a92a20ce327d9253e857c3e13a293c4736db9c662a261e0c44046eccf13bcfdfbdb4175d383d1d092379b7e6ff567e3825bc3c5958cfc09abc386452e769814f9527256bcab2c9eeadfb1ab2c805d30b40dd6fe8163e77aa6beebaeb3eb71dc39d1cdf3b6a3604aac96ef10413fe9149c2eafa3b891745e1bb0f73748bd05b723977b4431a95df4bf17d22c2baf6a9269541bd971e450144e4d5b797d5df120701ab8ccaaf114687b90066a85b52d88edeec398c16fd51e328e1c2b72e0f25fb3688b8137a58c52b59b83c36f394c653b89457aef272af604f0e441239df1fa26c926d08bcfbd3fc13f21bd8e4ebed634777dd8a0d2813c8e0de0b420d56c70aca983b19f53a1200fce0080f7fa67b707c06a654f38953baeaff0f2538bcd3f5b740a0fc0f220ce86a7954e0796d2ad82073de9992f621df05f4f997834611aad6db457541ef81b4c01aafac6e801eb3c722bbd8ad271b522338da3270e8b1c874ccca40d337566e5c95770d76583a84720687f00aec33b51416d14cb73af9ae1638c1f27ea379e64447609d71725d1dcad66c4978b760a7f96e3800846163a25c7f1befa6f9cc8db50c8acfee77c2df897904944e0c767fbc566dda43fd9082760064a5a40d909c960cacdcc13b254ecee45a6820e4072fc27e054c3d16e56c790ee4aa3cf266cfc558f5b8411bb56d54c2affbbce73152917011d0794a45db978c3116726ef218ea80c6056df5d7f87f2814ffed5b81f0c1664afd095203a9bd1915f157b5ac11aabfa7e12de43465fa678d3e490181353a2764e8db2c28fabdd47da02dcb595f185b692756f89ae49eeb0b19da8063f4f6bd2d58bdf91dbf432a0aca3db95cd3ecf37fb424e7ef87a935bee0cce3ff010f424c26e27497b30f7b416b5ad8e3a0a6feb72067004e36471fc472fc18be45dd5a8f658bd8f7e7df73c2b3d2157b4d86c0df9b934bd1007eeb08e759b32e0abe0527c53fc873e4bbbfef1973626230ead382dcb24a87dd699244e72720b54450ef6561052469d6f5eeefc64d38ab521c1f8ae6fa21ac3a7c17b51dd531b9d949d2226a4d04a28cedeaab6febc7e357be4abf24be727c05b2afcf838a0dbc338b79be7654104d5cf3e3c98ed7d6927b5995db5b604132fa6d735e16c1b4d1b7aaf30adceacc2040a50d150d4b793763e031c4e7fcff5800b345ad7e3ac6e31a0b66f6cbbc825f93d9bb4c96a919ca17c22146cd3d721381218e670747da4d7dc2cef650a1aee360d976f22287b98b568949fe8af172144ba14f50e8660d77cea1fd9505defd441cf3da8a57fb0a83d1e984297e2e7d50f2c87efba9b68c711896e22bf804138b9a8e558e629b5198f9e0de6c40600af81a9366627f1a1875e5f9249175dcdd66df6986750773b2abb9dd153e55f44c9cfc17cc6d458413e19bd36af1dd4d448272dff16cec765fdc8ea283932a5ed86c21f414951037d666ae6699e1e31e93acfbd735095f860f1f05d379b9c2cf1e28b406143a883d83db4aeb6ba445df34e1a420dc7a9a1b6105e1f8d445dba5507d365937e533fb91e9a1a73f1e9ae50670c8723da7fdaf9b144672349b76e09d9699f5fe553fe559a0a7ead2cf20e070fc8089bb444df6d2920dc30264951e87df81a35d04fe9fe989eb971419c431131d31a5a8f6e7bacb4640768461f844d63b9eea079ce8a5f106cbbf59dc3d51debdab230837af8495aacffacc563b658b2f55d170abf4a5caf564e19847fb5089b056e23454b3b3bb025324ae3797b54bf581983215261c756dbf25e1db2b7d772ae5a8cba11b6a181ebd74fd54017c7d94ed97d2132506d120c1d48a45a5f6ff0f11398e2f3fa67bd552aa6a10f396f968a27739c6fcb5d6fe534857307b751c390fe4b03d1e303c36a597503d1cd650f8bfadcdab21eea59ef96a73abd00572e1e508c53cf3bc2ba358846a11187b7e149d2023e4f08802e07725afed24da7919a3abc2529629000e43e6d37f6b330de32e840d3ebb1c61ad4458d75046b77a41142f96aa68b9c6992ab55e10890d157acff9a10841e76baf350e472e2ca333590ddff293ddcac09a60bb19c0285dd61e88458824e797948babe164fcfcf3195d493cd61cbeb82d167c45150d1c7e213aba67455a8b59747e29beb51b6ea2893df3a079e959d8b8064e39ba8d30f94031b06312c842eac543e95a22399efb1f88a21e8fed16e100b9a232824d707bfb0dc1bb18539839cdff5e2104c9590b162bda95523b52273fb2e6aea9618500cd7e269a29c8ba7aa4bf75941e4a01bcf3e17888a1a5642d0b610ac5c0bd0b109c1c1344fb543beb1244c1045f56678c180a7e9ac1d6116ab668058e2ebee33a2e1c216358a73aae9cb9a9282707851d961df2bab9a88238069735c6e233a469dc1880f950a14bb82269dec7f8d31e8fc05efcaf59daec0775b3710bb84e119ad2f307fded16fbb79270c0d02d9a5e81d38e9b26666a3a2f95f97968f3108bc36e7b8b1ad33f26760ec5a78d83cbe5d492dc736de3c654ce182aaed11d730933ab0716c6d23d93180653138de5e8df0f47146811b79841e91e9282f6b7290d8fc6a0830860203c22dd150810f41b87a18b0afd49969cf3b9ad53fd497cb974a7d012e1d45d93abb693b874700e180df99bccd73e239e8df27d5ef10c74b355e854edfd8c8d8867b44cb927d1ce28fe577d94c8021f0d3dde41f2a10f85ae5f4f88951f2f693e6e496de4291c32317a8f9ae5730f3e9e5109f9697fd1438dbec333348a170c9628383a9887860476c1b3bf062b24a8ddc9b68a42e8a2978ebd286fb6072bcc078f7e900952e4ea72c97373f1749b80c3f70f1e36d6bb1391a8e596303a7af55c936510290d932c93562dc96364686d7c91e06686103e2f02a2ebcd4bba9ea730a11430f445edf5eed72e9cd8674da9e9c920ca38330e4a87fccc6a48d3c0456070e26ecbf1461137f89dc9967cfa2cdb271fd0f5a326d86d833fb9dbe8dd23345eefa8f73ff4cb89bcf7100e4c3589fa08b55ad1df5addd40f85cc2e0b1e1cfd1fab82b00c29dda60ad2421a70afc00fab663d46fbaa6f267d0b55b1e0fc46768b93f6db9e5fb1c1fb6427f83a41e216f3dfeee682c75653e4931e1e1a36ec2c014a6e9719e5c5706e4ca5b1e0ae99c255571927d1b56666483932122169250c8f6fe14dcf9be8b5b962bb2a40bc7c068d23f71b847a843a3c20ad33fdd62e572cce95eb7749b86ef2819fadbc2e3b69d0a68111c224896a7b44da9f4d5e37edfa4d9d0abf5654d6e377c265b61a5691503fb00b4c0bccedc0742a086e88257b967ebafbd3a0e640b7bad4d3dd093b6f58f096f520f9965ca8d2fc84d8ec5f1ec839642a3434aeaf44630e23471f5f59cee618013d5f9424c387abfe08d009248a89292c3fc8c4692ab5c9ead3fb289aea4666c978ebbf87024a2e59a6ac92ca17702319f1d15e5fbd915d84875ca44fc8a47c3b1cfabd092c128b711afe6fbdab5e0bc8b0bf3cf737dd70eef5a2749cb642c74be382025f2f89954df826a6e773fcdf212988feaccd8d55df4db89dfbe9504315ba99374bfc150947acb9996f2819f3bd712c1c5d11e39e584d1d074a65afc33226cffd8c02376c3b816429b4f0848bd578c36e27f5038afafe73be947f269bf1a93ee56ebdff158afb66397977cb01113102072a22d568ae9c84d1fe88f62ba51611a8dd51582d9a2090c5602d517ef8c4f057d0f8cd9f4bb4b83db72194c4f924a1e04962dea4f91abcee50d44651d0a218b8653d0bc258f172d385bef9da85742e3a866a72744b53e2bd6b1d47f2225c7c012f3282fca783c10d0709f3445654b0a9ee4bf1001798c6a89bc1a2bf330d4ec96a0ab63d938edd04bcc13a8b2975cfead4b688e81028537448dc08d97926f9341275ac9de7eba5c72f378669c4ebb1d0d2a449e4e81f9bc6f23d1eb693283f784336f968812dea147b2a9c862be5b0c77e3387f14e5d72eaebc4c13c3d98b5289ceb7d203e250c200d2ceb06111942568fd3249c5ac0f2d52a3465b7ca786833307b4c2a016200c819e3d7cd7b1944ab6cb23a08d9e6ac5dc9c76242f46e27aeb27cc1741958b8713866c2ac6e1081a4dc45a6d1f1aa42b520b5179a3ea33de1886ce95287bf05709340e00fb7fc151e00349745b756eb8d6910d466ae0d053d9d9094132fa405eea90eac05f00616dc0ab953512a548264ab0d31399bd8812cba0e933b96c9b24ba2bf6cb6233dcc69dfb6895eff7b3c971b63e6b1d6a95dd7f3ae50fe65aed5cf2aae0824cedda677d45b638a938fcc82784962ab41e250978fe9f41a24cb2f4afde60bbc16af3e3b2919e21bc82597c61c02822676beae0caef45f8b4e96454148bb56ddb7793dfb7d0452aa6295dbebf938e3e71b43a0228c5541944ee722b9a63f376d08f1e4112897c53a92c40c69a7d7cb0bfc0e04eabb75bac3916e9f9406acbf6c3d3b01ecdd9d80a0280523c8417b683c0dc6b33743b302f8f61c350c38bb619c3be0378af488eeaf8a92de8e591138b96d81428fbc1d87be9363094046a6b38dbca8bcfb0f8342ac0764e2bc578801798f05539307ba088e7ca6caab2520b8f19d455ddfe1dbac6a2a81f4e175415b992fca21396d11145940bf1e7ce790b55ab578f4acc404036b920a3c78df5d694fe355ee6452031d82f12afdab97d78d531323532e49bd8e636b7acbff1b87d25f539c3fdd4e1c380e17f8e7d0c9fa1d3d25ba1322cd5cc8e3b07fa9bd34f0b9e781d15ecd62ab6ae84c4536d7f37305f747c36edb31ee398ee41f0b3ec666a7d95e74eb8e36c3151bf1979ef6185193283307225d03d498ad7cc760fab12e5288e46a1ede613799fd27c67c7fc2a6c1df3e5ff481ab3ee0e7d298c3447e213e38f881d8467e53f22a7a0101850418e617e02a209cf8619e6b7a991274a498dd8cf38bf2beb2a43a265e13aefa89f890d4d6dd7c0d90093bc152b877a35f4819434f64a38d13f4ff191c75e63fc39e8f8d5f87147444e1a1b7f9a3485d569c8b77e75f345606ddd35368a31d3fe9072edbde4deb46fa1c8d49a83863bdd716bd9131dddf3ab12cdc3c757b0f930663c81dde01253c95ceb6306d174d0cff8c97d6ea3d9cc5654e08310a4b1d3bd6cfc21905b3b4ded0c72c4002093757820a3cf36f6382de210db867e27cca23ac1d8a45e0dd6e1c6515ef5506f721246f25cc8423931b5bed0f1fd8f68bea4447c2967ea5a0c28448a797442fd5c724505f299ed2dd1981bf302f843cf017d78ce60c5f1ecd648ec5f2bed240a228bb8f47aad11ec76f5a52229fe7ad23c2c866df5d496ef3b30b25ccb20019e428abc1fc9f112733b1daa68d1eb898995bc56641c32164fcf1c11008f1b8a9098986e52373e20dbb2dbe5b5774fcfcebc5e0206baacdaf27105af57ca572dc08a312692d11017dd839773101af444488c3ef60d22242ff809bc862f8472e55b09a2e3d9721251c642ca05c0d0f2a4f82957ef1f5f7dbe7921670ad0dd95bac3b12eb62b1fc00cbf12a0c47fe046cd514f3120e78a8db2e7dbda04f545c5c829275721c31453387d7355e6cb00e7deb305c554563725e7e2558cd0bf760483586032fd3f7bf921d934cb1d74a9951f1c63cc5666325e1d0597d1fcccc3450423e7502ac341d942fbf11d577525058dfe3b75eeda696482bcfb54418d2d3d8c11da796ee273322e780d6a41de763d52cc9977e6c4085d13da44532f1408bd60aa29f5a34b117f65dbef2de632fa3779c1b2a4e7b0418d9f9029ba71ef303b84bb53a7fcdfde961f9b12103e84345a84f82e58666a68f401bfcec7051fc8769c5a62e5aa663a3187d3c8c8db5965f5500baf0b28e5e4223984999077aa8b77c7d2a170d5845048e51407febbffeedeec8203c0a922f1d7c9941b5c675d572891e60807e15158e5be45884ad1fe7d15c71e2687a62217361529251c6066e6b800af4ed95285e3aae60640f9c1f7414901c0fd87dfda2ef26d242782030849615d683968db98f03205efce3778fa8bac47d957b0e97329dc7dc51596aa73dbd34f29259ac879f683c402350bed0f0b099c607e860bd19fab09f99c96f16681d6c7b70cea32bea0e79807ce82f9aab6ff638ca11d1db9252bcd06cf0fd80e6e5bb68bfc6016373f858351b6472c68cdecc0a24d438906e2e41b862aac677109875b3adec1564f2cf5a75452564f824daebcda8d37049807af6cddb734bf206f1936485d43399d1fa18229d122e3dd19bc829dbabe503af3d817a4a938a424ce330fec203fef848740d657991b1dd0a8f945806edc0602a9c5eea08f1b0ebfbcb5e2df0e9d0216020d3e72a4cee924d4a776342d34714dd1be102e3fa0b2b78b9c0c2ca7709e4c66cb50d1bd2a35ca7a70e502f6451bc71a5532c4f208d7bb1c3a8122cb85c16e33eb723341b78ff0304bd76821a4008d3623d72218dcbae1f63eaccd108351d4e886148e171d85854635a47b359a246ed7d6c06546aa18d7fade6a5072da31147c5a72991a62e082ed92aa48c84d7e9447edfbb050cc540e2e3c916e3711fc28246f5bcc61299845e1f4a46cb62de538050674e94a777ac21fd4b0d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
