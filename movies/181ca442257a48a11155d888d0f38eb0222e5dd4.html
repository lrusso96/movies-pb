<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7f2f7fde8f7c51a957cb0bd55d69cdb18904f9447fe447da51acc1c38505554a6dc65e9c872ed5d557ce9f615e97a923c5c967fa153ed88ccc5e29704ca9b71b9782397a831533f0e59787e96ace84028178a878bcdbefcbd0f92064e0a1031dfadf78dcb1c6ee30f8540b301f33391fb1e516896901d804beb3da8a0b7c0c16531d877937f63db655612a3eea78d21e5c97a585a74805c66b62c16e5255fab191905f010d6aee56d82b1ade2a4ae13d5f324ce433893b08180a44f384269610c1b2dbccd5ffda3f4e643dacf8e2fa684fc46f49932dc4e1c2988fd02c001bba61de53aaf1b1df333e39583be96dce14ac04fb6dc978f171ab565d4b33d7ca3cfead4c55b664de2500326e74a63b51f49e8223dbcf4aeb575f6176ba2976fb9c972878b670a2401764e9fa9bbc574d8b0d4044e13a86e07a771635c677db02e6b4dd9c8a998b659d02a066280e669993f34d6bec472b519b23bda913463eda9dea4875ad7eafc414bedb247466dc203817f22d9b1465db8168c3ed1fb39dae892e524d2f9d74b1ce71b03206cd12705c92f28d2d7b64a46895abc5af9dc6496e3e97ccdd7baf9595d21348d054b011727243035efc6439247469f63fcb49791984659be31fd6ed0a2f2a7b60ec27cfe5857533ab2bb92cdf5537baec1cda93c5a174d2d4fb3d9d2f5ba5fa6b109e57e7364b8c8c0aadb506a33773950ae367417a1cb251e9f3ddfedabc9ed66e67ba12107a7c8f3182cac19678aed4ca40250e8332c37c3b3941cc029af12596e4638a2f20c17c445656b3ed0b24624cdca24b266bdbc3f571a1c37d624651a48c5bd3138a0bd3803073ffb3cb72f474625a14e6bc431a17aacb0fe35f30d9a576c5666d4faefc8596a053138e06d49f74112579b1689b0a31b7bafbe7f353a7af811e36213c8ae0198d1da48a540858ea4e3543ab3266033ea68e94fbc322d073ee6c5a6f3409c0d1f4c1276b54920eefb11ef8e1769bc0abb6ca7333f75dd10ffbcc93aae72d86a0e2fa68310bb730f64f66ae78649a5f552ed6027c4ab484640c2333da1a3cc55a8311452651688145b07ee7999d8a4b5883c412b2686df262fdccd057e7956e546f718e5c801d0cbb707b0e8a4d40dfc844e77d5ec40be12519ee9fcbded16f79b578f6ae75ffe52de4501090afaeca961d56d90bcce84c2f87d761ef2c853cdbbc7d6b169bf9bf58b107de7f30051b01354ae99aa944875bf0c26d701e1632b3dbf871742f0723777f769e29718b694c1b40493de60e9183cf0c9ebe3e01c55ea7e9c1cbf03c3bf638ed312497d1f93a44c7ec3681377ac9f79c61009d644c00bc7e6226c4091ad27e12ddc80e3b0fda86b9c70f299fe0d34c2507345a8157e6cb75f55cdc0d987555d13d232d79de82a5554588f1967b5b79e952f22c4f1f0e695a986c123b1188b108dbe8d520106fc054242f853a28c2170aa0e97fa4f1ea5bdb11679f66d351331258087ecfaff2f476a1c2c5cb09a3d2a5ce7dca9bc702875dd137a19d8620b35b4941dc5b61475d6b39d4372249f23fd5b6db5ae9ca91cccdd721c165957b63cd225f31337fb8a109d22d61ffe8053f4dfd604d15b5d4d3d4ed282f00ed0879b3582228510100daa25d892a781ed35481658152a797abe75593e33dd2441aafd1b9f906e9640a9c279e1abc3de32f5e0d25b7f60cdbfd8b0e2cce2b16437e0e247c4beb6b1857f291d3d7f261918c1399fd79add54bc9ea7dcc96f794b39b89dabbc8884ad828d8b096ff0410359c5d8af59ab2e4f38fb2f5d2e19d63cb80c1797084beba7fe0201ea98afa40aac6e6d57e2f5804785aefba5ca70057846902aab0fa079fde6fe37a3e3f55b173fe2dcb3b1854619acabe2e3df21b34d098c2574aa0b2c6b15d938178741697c8972c2c8e9ca30dc6eccf2a9325d15146b21c29ee821938708c2f803ada19d3a5a7a350f922a74112f0e46c84e33fdd11aa89fabe258309469bd47ee9c1ba4ad79f1375c09dce297fde72c69ac36e2f330925f5dc32153bb703a4e5f6763c70ca42ba0b173b6b2da26ad7e7adc210b906ae1d0d9f98fb8a3106b4a28bf91c0d221b849a7c7bb91ebbbaf127f35ea606a97f352cf475b362278004b8d50b1acd5df49fcbd6681a4db995a457f2b7d79d37c70a28709836f78bcf1f54e63e19270cea68c47440015fdcab9e8e626ddf78b90025094c4cd73142d299003b65b071ec9f65d7875e05318cd7e48c56a8e84be07c531fc9ea52da9dc1ac98acf1b99547bc59f36e1b3be3aa7494b9b2911e98e69b54fd4b3cabf3a716be6c5c8c2219a2871884db4c5449d0aee32a6918b2777d73cfe5eedbc0d121670b3bb63318fdfb8f3e0bbbdae8b4099beaaf9d8e98fccd7786b1dc265970aa0f465a8789720d371fd162292ccace42296c8bbdcd8c361c3523cc4263f1b5afd6073e579d39603cd3c6deb57995f3a351452201539cd713c898e7b4e9de1975771a1e18e5080234f93e0f9d1e6881ce43920aec60b0a6ae4c82ce7e56d4105d9970901abd7721b343fc8cbf8bef38aa634edad42e91f5160de14497d68f843ad12998142a5f883e0029b52413c0569033eb274389504873e5ab426c39afb67881a9f11061102bcc9fbaa3845ecce515bc33815cefa2d510ff5882b10a9527e01c0b989fa7171ac67b094c2b4d9f2d39fe5dbaaf630f5edb130169221953fa9c5cd62e4008f5ef1d22e351d083b16d060b94cc5e4d1e6566c54b34d2580ed161a597085414404a795c174c8a612996a934516c06312d5d5e49c1bb4039331a81129df85edc5c8960c3559f8179b7bc2339ab4a8798728f656c3a512e39725636752b4b1cd5b94ddaf7f6c6c08529f785d83f24d285ecbe748ff07c1a8adfd6cb2890cd9ccf20426ff1112c324a8970b6e63352adf3791e821150c8bcc73389aee2195a02fc65a215bc283e38093cfd767fabdbf67d8b88cb6177a552da4bad41c0a52c0a712a16279c8253aa4096f1bc20e6ffda7a4bdfa1b155154d98cf1be41024689336a9c8b724a16b0126466b74cf52ae742cf5fb586e08cdaad7e2bae34e74cb1421aeac5dfe1c48a414120bb0ad87bd7ab2db2740ff062d9b6c5ec276fd4a97b2e3050f98670e875013536061915554b5a4a4dd7326c5161e9e9747d1d09610f956274471888f2786ef92e790f2e89111edd3c7ff6dcb8f94a0f1a0cee3ac387e51615fc17b6e89e709afbdd2a48e15dd7e91eb7dc212be690c1fc452a5f17ad78be638c53eb77aa9e33479194ec75c26e937ea5f66dcfdfcb1d8ee4dfea3bb8c554e8e16fcfaf02458893e15ad696256c63d1e309939d2125ff6f67059c0a3101116c4b782f4281e86c1d06e7c9f9de14fff367576b75199e0f4c01615c9aff07e6b4945df29de3ac040d7809d864d723d0e9e8f3cb2cba960b843aa5a582a6726a30a1be282000de0eaefa09b830e1710621ce4e8c11063fd22a0aa55e05389727cd4d92944d68f400109cb2b9798fc8327f5b56b16a4ab9239c9f7c53d6938a09f77a09853d1d20e6913b5a27940c72bf9e5e9eb5f2dc382be7033007859eae0b0cdc34f0481603a0eb6f1eb107de9e690095aa305f61708b3b00144aaf135595f2641c2b5ac58a42cef58d218316ab2fffbd679c0371d8be9881a1c9e466bfc4e006bcc30c7a36dcea3f57b034c154b074522636d2112a968ce60cbd7c9c5acde65b3e69ced015868833ce9a7860d640bcb086e478d52847b63fbb36ca8d69d52fd6bab9a9a9489f6517c1ebe2e92506369f78ac9488a600323778ae65779fe4e3642a4ec4be37913ecd77c21d20e6513a50e106cd9798618a68b477bb8d3801ce0ada5758bfd42588712d8c90c48f8a7fec097bf54300e298f781c67ab96f229b12315f2bad2a386a9101570d4c403e1ada61cd255df9183216e2d4204048af85292460f1ff3292b2b2b9524150fbf96a2738effe2056db3640ff9854814d92d3fe52bb85a04d7b50c47aed1c3c6395824a0b7f3e319f9e56e67a7cd05441c8da4d4ebcac1167f05a3f362e6515afb6ece8978185b48e5c13c79d5573c28b46c7e52849ec61871eeb56d4202f360b8a332c96bb9226767a70d198f2cb25bd6a37a068c6cde8ab1f8c038d373159c9559dc4da8e583f7c45c1b2b6a19f7e729f2fbe2c70ba28c722aeef8a863ba24f68a6bde5c4e69c20ba5ab7c371f30425ad19b97e1f902ba1b437effc3fc253b79a7628572d49de6d1667a4043e0091f9569b194f1316b82c51868538cf90f168a3d69f4403756a658a16e6329f3bebd507fffb70d2453c251ccb5bdb2bca495ad8951da8d201a89331200aacfe086793aa27432a70494d0510442ca90f6dc89b4753a48cd0728809db8f8319e0c9ab0537fba1d3eef7d4aa9d2bf27109d6b4854d23e4e7a638ab876d7514ce052633abf402bbd3bf9c3412f28403cc1ca40f1e69cbc41089984ac26fb8146e356d68f6309e25da5eb0b4b0f384a2b5275be82dde8448718329c43e53d462ec41eb5fa146ce6467985f34bb53cd5b0c77d50099581c9b392700474331b9522d5edae92f22e62bc7d81b32ff04f199439f42645a95353ba278a60cc0f7c4dca45ff30ab827ae599e2180833bc513004d0e15d38d31c391d0a7316a2403a8432f8c997b5d20d070cc79c082aec227f88fe82e87b05c09d62e12f5ba0e044478ac6ad5968a38f63617f32beaf8edeae5db67260883974c5ce5a46dc0162276e8704d737907a15186b62e124623d024a17f875e8dbed851349d90499806269e8059357292b512d9c79f9991ceed34fc8e3fa4ed3a1e319a7bd589d33e7a0c907faf0e705d6a5ea6666cf857b70dc071493f7e00a34bb6009766c01641706f4060dcddc52e6654f412b64826cc533ee46770fc92850e4fb631e5630d2aace5cfc396813930a4b014e87d638fd9f40ed9c45734a6d7303f94b7610c18b570c0d975423bc381e73e61e37bc523ec1a0a398844ed31acec7fceef102ed9c479514e08b0495f64e12571debb85e4768a92abfdeb4861fab7129acf38b2ba64f502d6629623ea02d7a655e22fd47562d414c9e35abda82ce9f5ee8a5ae1631d03f03395e777bcf09e4069b0659cb0cc8f67fcbc596cc3ab43ee6d09dc5afb8ce0328912ee27f1000e5d873499c3d132740d9aa3a138dfc06a73c291694435415948ea5a0a40d7f2402a2dff5e3e05d1184f87acfa2eb9fbce3271f1c23ca0ac916949c57a4d2262cd79c52752e04263a8579bcf323b6db90334cc0611f37a66632e41c9517afc49f3bed237ac6c86a32735a343bc11f31f5a3d6e28f2fadac36e4381e8d42065762a7868dd3a826d7a570bf00e1cba63f1a5b5094190741acccb40f1d5bb333b5886877faf92466d47701de6c28f598dd21dec46327b614b01091c7979f809b89293d6bb586b0e22117b2336de8204680678d96dbf69808d4ae94d82e9d33a4f488084d3193859d7e1d0e5f96d90534546b2404a5feb3edfce6aedb11b877421231ccf00023e5b3a61a5decedae9a1adba3f4697e077b0d255b9525e2c94d6d457594d662d6716fda8ecdf386067c4a50764e86cca53487b27b615aa6b9fbe96ffcc3658742bfd32fa2942dfc31291e537468927491ab1f959adb1f110d5ba103a1f93b7864c586d7ade02834a4e136a9129009950fca73930d27f3a3f7df3773d734e8e430a1779e9fb8e02789ef96eee1b175f2342f153b0a5ffcd5591eaca1ac6e7f105fb5a719e41cf78f045bc9fd3e7e6090bcbe8372f2a77d3b9464564bfb172c87751145f00274bdf52e1fa66bad6d0a164d748da16a85917a31dd3f4688466ddb7aaa7c5efd64fc341b54fc8da1fc688be9435cd083b1b0902c26921c9a6a5f67a860c7e65e2ae09076b681d15e772f3fc302ce47b60ee0a6dfcf9431e6ce6b08bedea798404b454d3411c068aa346c4e29f6514f34e3e06617b61772a2b2eef07924139abb9fe04d2f611f2d0354d570f38a1e34ad3726a71b6649da050c1202038062112e5c7717728b8471c9299bdb166f871b66fd4e6748fa7a750dd350a2dfadd87bb23b80d5bfdd6c5ffc5f7cf8bcd2111c83bc4ccef6e177010855da3257326f666bebe5c9d8e0628ef060f2cf41d24a40feba816dfc8be20621c82d7a1d2c38123e9675937e34da28b870d2ee3b73606fde343c07ef28c929e547fabd8a4082c6d8aae1f5246051051b0cb64a8e484ab95efa7811700460cbe09b1a875160850018e181f39eef51aa22b9d9d12bb2dc96f6ab214fb174986a97f3df403005d16e9f03b819c5526b1739b535ffa30dd2ccbf0b1dae6c19840a6c0f9f33b6a754da6b1553722b0074aeb2c524f41ef0e7503ebc88ac886991bfa922d97aed5ba19c89a1ea496ecb7478c1368a5b8eab70ec6b72c81ea8074d5f1110a2c7b86382889c8026b0f7ece966869f2a9e81a17ec57c5f6f8879d70ba1a81be4e81e1c19405a215350641c5dae9ecb28b9863b07d7527ba4c7585a48cda87aa54b6a4eda1b34a4b0d6a93928d969a2c1dc253be1bae68d295bbd1ad1f8e67f2d5ea0b42346c545a62583df6e79a2319d5dc7d02419cb726e0df097679de38f0a9cd61325e7205e1c5911d79ec4f5cdd732fb7228a10078f35a361f9fcf76abd53ffc0b6588f41ce6df515945b3ed5c67f251205298eedfd9a906b8c19ce14f5ea8cc1ae115933373c4e05ac3133abff52ee48375b909efd58983286ed06d2533c56f55c1aca1d4f7ca1631d3e7306601ad439a2e2f3c68a118fdd1e04132a61c0c79976978765585276242c3fc6f6669ce26e29145c6ce288312a87d0b48003fe8f8ed8fcf4579db6374fa14759427d0815e4738e6b1fea8303dc768167b2a6eddebe0657ee92897d3c5d1e5efc6c01718a02b3e16d641f87a9c68f1a6ae54ce5dd494e84560983f66a33fec6ab20ca87d51bb6cebd2e9a153abc493a23c6d25d8ba29b25ed938390cd0d7dae6a38cd304e0513834fdf84f270b3e397f946cfadb885614b0510ec0b869837aef6e1670e7df3bc7f8c69af934f6b899c9db58de45ddd6c1426c8c0abe2005b732bc0a0dc09aedf0cf5f618c74281ecd7416dc12b3e5630307fc72c965bb5f062b1429792f2121c2dff5680a966eb3d2b1433eb54ddb2130fa5d506cfdd6f42fb39e50600aed0d5b358af900ff965a766418b3f946c280d8199491d4cbff54316d354a3867e43fbcb72f088c51cfd524dfe1a1370a2d1b0f5bc8293b70f6480e12541716c813176326bb8a19b94573410fda04fdb90bae04279b3cde7649a0e4dde1fc431caf786a230f8560730e6a48f5eed1cb38ee4213a457e3d66425a664e0e74d2997ba8dcd7f2a649401a0d7d46c0ac311cf69f5610478a3442188ee786aecf3066ef27b14cb349946b80e5cc5f7024216d3464af81f765d7c3f0c2c237997938a64399a62f2fb8a39e8d458a098b5ed61b3fdb67be92c3fc5a0c455d371100f98d7921b3250e416ed35e040682a691dafa4e1f8020ff2a0df836789b2408c3b642620198145f2ac301b1448ae0726569327fea704a245241233fce68c0f554dac4aceed2b2931dfccb8e5868d7b7c62a3b21e77b8074be449dc46659e45b77f1afcc7c6352b7b94d4cff07c1b45cba5c4f4235c7aaf203a3bb8eddcaf6d9f02ca4da61004cb3d6050d18bd53fcc028cb8246911eebe7c4c35ad7fb9e888df6e4d01c190e5d0cb809682f8687bb94fd13dac886ca66c64b0b658aa6bdd00b59284198125f87c81754595b83556ce3c2d5a40475025c3cacb0f6942df11dca0c966f7d761e4ffafe62199d0697bbb152680e31c1cd9edf948e2018ead7c28a49162ca73070cf2c2dfb6e0eecd13631979ab882a17accd43f910c7029e1fbd1dd4ccd10c7ff4861fb009a3fa75e97ae8df7e65c9d48cb3c82c1fa9a9c7538604c375a956e85eb131e2ea32add8180bbf1089a9884842e96e0aeff7f3fd3438cef06ffe73008714afd1e8c119924f5638dc90e9abb4cff182fcfe03cb036e8e23dd30f946980ff83d50e93aa180090bdd53cd6e960e4f3b706609b2a7110846396032932cf569a183c22ba5d954357e479cf9b6dea124e20caf2f393ef659bac3c901f210e85c91a6b944d57a1a86d916d62887e20d49774e9613e1d147287b40cd8324f6fd0e39cbf4ffbbbd24c4f25ed5e8cadc201021383421c3a52d5f20a643b2af758e0a305c7eff89e9c7f6e17dcbeadc9f985ef886c2b58aa224bb5ade22625a35f9d89bd491c0e5298052e93d52315c15b9af71ee95635abcc0be730b966ec33bf2dc8878f524e91db11d19efbd17cbd349e50fb98b628e3e724ad9a8fa0dbe00c07263713b6f618e53cca3e2280b16f786be819cacdc4363910ac81bfc09b00587219525be07c9b86869ee68da5afdbbe2ebbadb1ea20c034557e965ef4c53299b4b4119baf8012c5633589782cf14009bed4052a02c7c813f63816a84c2dac97f2a5c610062c3de461024dd08343fa44f35cc9f8d1ae2eefa51350b518a9d3de42224bdae2b7d60dbfc125e6f67eedbd278cf99ae94dfcee1a8959f947b925e642049204db63709a101ec16f78f1692db2303c99c433442773def9b620f22d38a39d8128fb78a0a3891e6e01102a6f1a27e930ff7699e381fd519be72e21b98f7582b4796d443c45d8d2fe010d6c6c27d7990a35e256f6a86977d00d7f982fc40dbe2566d1659809ad361ddaa44dd681e1c2910a7db55bdb2a3d8df24c49326734d845ddf72632b735e85dcde26f86ff80c8c64de6a5af5b9717e69e71a249f96d5c844d98fc83889dc06ae80754067336e89a3d16b2e55f50724532f5d5a0930ce2bf3ba1203eb4c2486fdbf5028a327cf2cf4fa3f63a6e4b308cd3f0cc96c6b3dc2b17bcc26d95bbd22c99029f9d9e83d9313c87ce5acfe4b6438aad470e18545eb7b38c5ffcd5090f1691232978ecf401b44cb78ad982740c0aa56680c4abf987a4669d800ffc81fffdef235d6d07bccacf4276805598ef5b4a6cb343db1f59e022a4bc91e28330e387bbb5b44edde2105c30f34ed775150db7a588892d886e68e40f430e7fba4d463007e55e2b61a4670f756ee2b779c2a21c8b478168ca263c1ccac62ff840f5ac2cbaccbbfb850a62409e3f1ec8dc1a8fc0acab0bfe00ad53ea65f0e5384ec9983819a57686f6edca6233699bdff113cff1e5713ecc688d0bda28d98433938550e22e85c77e398c5cccc7dfbf39cc1490a0927e6b145948871f40ff14c6901b00a34c99ec4186955cd01a60f83601185002c589c5a7a9ec68231b4610c41b4b6eedf0ed5a8b4d8f5fd2759808a6614a810850d9c044406a77a2b119a197a51cf071f2e2ee3c86ad183fa99b748147bd05e3f91f988f8e105417dc3265b0f9d140839cb02955ad2c9cddccd96a13d0e4fd3311cbdd23dfefa4f2f0037e66e6763f22b93d6b77b3c3273f1eb1764f25d696f018f787d4a414f60a8b301796319287407c675d8dd2b3fa7a395c2876abccfebb15b61aa8b0f0cf0465b046464dfaaf3c1cc93d20de0c69bde46b9112b00b1b5c57af8f746aa49a540483f5137ef31e8de8d236ce6b0b9c12ffde391207dd4e34c21b7b23172bd0bdca107e16870722078df7dce8a25830819af7f5080dbed8826ad94584a8baaa4545c3dc4200cd9df8b5c4a717258933da8eac79fa68c1016d8d0e27b4d07876df18fff38b17bfd8f5591cf25c139673a2f5d1c410624130e65bc178764dccf9a317fb477e3b64875b011d2aa24d31bf6e068d7933d36a42d91245a8c76dfc52847cb4cec249d0844b185c2459793fbd40fde842607e2e24d30b7ff643cf01738764f99d8cd5ef656dd345feccebb34c273451d818f709ed5c485f4409ffe4a049553b02565ffb3965bd6b48557132560bb1da4d4c3f5572a30c144494858fbb539dbaf26bfdf998d96042f4e780373a7d5ecd4f6ada2a15ecb10d9da333418da6e1c45696789372297f38bdfed3b63778c64832d038bd46c43d7cd169b80f80a3707cb03ef2047a198bd542440ca8ac0e3f48023c35f444456a79f7708ce32c2b2c1c3fe57404de7c82c0a48e36e92fd0966ccaa9bf6ee229eb75029a1629534c3d2eb89172d65d81ff3215ea9437c7ef00ba48a9fa24b9645aa5b0a160cb702a79d46d9046cfd1e5ed655a3cbee98a300563df54ae1d1b3b2096dc0c47a9f78fcbd2b881458114c7f4d73d2155e388263af214e9f4584f3703d3bcd2a7438079ffb90f9545e5ff26336477f1a65fc669739a10730624b47ebb9f879dafe3abfd3f51528b88c8471ff993fac96a3622e29b967bb06a45ab49116db0ebae352f21da787383d85fd9ce915c1253d18ed2e48d0a3f9e52595d8eb1b24ba744ab79f26f9d66e7f8c0e8cd3578da5bc3f552c54b4cc63a2ad3e131aa517e296a02a183c5f05d3e288ccc721d8f47ad12545cff1fa96c96c0e29f4f04b3377cce52e38dcbb5ee24e240bc04275156f94044e22bb4f14594c4698b09f7f0ea8e34d5b417de65d8b020a3b6a67272c7485d627c0c4c47da4cba9aaa1a93913ca2a73d87005a3f5c8ba3922ce77f2477a4132c021329ef2c78f440194b19c7299df42dedea32fed38460ca93e0c67871336b0cb137530ee01dc27e48293101d135875880b4983c5299d4fe0bc1da48df1e33ece7d6ecd6eba163ae21e8dcecd3ba04692162df8c02d505ee1620355bd1a133a73c25d42584d0fdbd24ff1708623e8c7f8fc615a750b41c2d1f3a53f149fa507dadbfa1ecd440076ca529ffe2d20d7f62cb18fb3200f1f8b33aa81604dcc1912e8dcdbc78a02299456a6d8b64a97559fdf802e94aeeb7f5861013cdd374193c4c0b6cb180f0744137061bb4fcfe4b7c471f0b5c54ac1c31690642383e3f824ebda490baf53fffb3c0db47864275b54a72467bd130560ba63adcd1d3b288b5695100d6f89de76ffc2106836900e9d522d642d3fd1a3e8aae386c3abfec455e6be3b7afa84e863234f07466570df5abec9d688ff12b0a05fab66311b796df85666cf27a53e9cbf17df5959a8120309835424d65dd632492dc3a5345a18fa0b8eb8dbf7e9020014bb2824df1ef5aae3bf189af192cd5cd55440c2d914705ec7909b10d83619c7707d758ba71f1ed202e1f1b609d304d2e9ebe2f3155de8754a6c61677aa63e2fd0d7c235ac055be36f97c6ef14969d19d789b9b78eb106e52b1fbf688f167c52666db90d519ce5ca5c4c344ce33e9a8365154286b8b2de8a8e5c5d3d8dc269e77e298748d893782a135de75d7b8c3d804e599d1ccdb68ff90719423575c57d1d73958d64c5abdb09543d93217e3708435f3189b058674038c1e3d511ee5287f73c3c3ca285de8eed669a16609c3a4d49779c938e3e603551c852873f526f31079103834945a614b56a3515965ed7c5bb0ecc32f325e2d365f30f913ec599e01177d13abc8bfc7f1b992cbc2ef9adf5919e96f5b03522a821e69b8d119aa53afea18a123203c30108eea8066feeff598cfeb9cadd90c148caac501a7819c7098a08b588228872b9a7d53bd440caabfbff17accf96037df32224faabe94e9acc07c9d84c5f870ceddbdce26415a1dcb96871029c27e013ad0a05dd0798de3afe6abfd28f82644f7c660cf7e00847e0ca34d62a5713d76d21003c79e80ad042cdaa618fe036181d537f8b1a051e9b8459d303f0e6a01af234f2dd0efb85e8cc61cd76adf49dad034026b95935a630cb87560d47a3bb35d9f457bbcfd2a2b4f80c526684c67ccd9d34112b4ca187aa6a81635aad39ab27dd5bb132ad63bcbb5a8fa75a5216ef2ec6c3151427afdd82638b645b27f604d65bb7167b0c09ba6b68da9068a0cfbf7ee2a91d4d4012dab22050ae362d7634da01f139f7aff6f3f600059ead41401ddff62ae11b6f6258180ec4fdcc7edfd484bcffb9144db299655554954f2755993f4b2ca9c3be904581275ff46398ea01d69252b2beceaec2925b0603433bbd7fadaab0cdb05a2406bdaf1aef673bdfc4ac22ee719039889977824fea78626b22fe5d93b69a05cb37cc28cb2cbc3caf69ed1404b7eeb0f2b2602af6e80e0af94a34d9ba02321c61afc6b08413a93fe0b3d89bc638cdc3df5dd8b6f59d22f37f810c3f14db663484e01333dce5c7451cd7c1adf5ca3f460d96230123103a047ba860b53ab9cab2eaf7592cb53c5f9a1d661b6bc36eee8233019ceacceb819b79cb0e1516aa79128686e3c2f1e1ec473c8e761e56a0ca30bfba3e0175c70662a02a130bcdf63a891cf4efc5a418e1e5f6157cc5ad34214d0b6d61c4cb26e23766795a83260482e53e160938fc5848364d10114a5b81b39e545618606e1d447e6d6e4cbfc6785b639612ecac21e64760b773c2e32f84a5731b37b528d2a92aca3ecac24ef317ae8fbd6f49bcfba3955dd1f8aab6d1b1f2e05cde6ec19dddbe45991a1b5207b6b10829c1a12419cd0e4cd8319b1416c85a6c887a438c7ab73e242924c3fabe616aef14ee47a12116784307a01754e61bb30ab5bf7fd9228be66e353f8b6bfb08393e0c4b122583d2bc0268800307b16f7a8e46de4cef452da5288e1d0a0d200693b51cd6bf1ba8e2f732219440cabdc8321d919023456e4530dafc9ed759670f55a3c07a7ac042918ee519fb51189b21c2ec69cefee3fbe89db6da729846344c35db39d1b09a587a0eb0d05f3eb10598a0b4f743b808ee7b681a18ff818c84c783625be8110534eb84d301330a9387fb1e1c24fa785592f7701c89eeb56103059b26599c49b4bdeada661a57061504ff6f6b56e7cd1f05db04d862871c38212c37968085554b5f5fe0e31c0e351a2396b467a1b0e1b3ba68362c96635bb7c32ce2b6fdba771348fad43fc3bcb6113fceb36ba889ed","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
