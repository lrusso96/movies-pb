<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7037c1ab7f5a9dd11683fd7b7d8819c0b665ad11153d9a6343c1d221b19c60a8201857285c63ea4ee1ed651fea41b3d435cfd4c45bba68d0aa2c7b8f8a74058a66cb7af64de711681add61ec13c23e4ff0eee84a67f7563209b418c679d332c33e37316d5c61872cf147b45182f74257a440739e561e4c6a7e212e2555c327101cf3723fe2dd4e2a91809c545f677247e2f2c3f7a0bfef55dc142e8d7196b08b2a2d24718bc8d8f14c6679f335de5954781596e08717f296064476f170cacff7f70ec9a50b462daadebf1d4629039f61b7979595d57b33ddc58eb91ab4869c8259790f70f6783c702f8ea19328244f22df94489c64fbb4e7fd7bdbff6e235e9016270aec7c1949089d9cc7df54326a9c738142ad3774db9e9ad5cb29e201d42118c3de658cf8e9e54448beebcd87418967d0b3db45f16284dfb0e4b54c52b879b60797b0af7cf02594d1701746bb9ea790e856b2950b1b77ec519c688de343091a6cda8132118a785d373f0296644373305648a93e65743b3747636cefab247445c2083b4a56be16ba2ccdc7380cd9fd6710064077c9ca6c30519612313f549ac07b1988b5c843d156dc1b72b7d1b07d5cbb3d7eacdfb1b7c7fb1525239c5128926377a9cff92aca85ff96f2f6c92c1b596be06fbbb3cf50260125cfb3f714560ac3fd590d7df7236288fcee59a3db6a5e648f3268bc2b1f9854bb55d7ac1d9437b77c34a3f685e77e013321426c93f46f0970fcb368401983b829a200c72c17a78eca555d6aba45498f2d008ed2cf79e375d578df24ff8c7ad1996181fb4be9026cbcdf19f37e263601abf188f244e31eeb6bbb4a973a15959001f2af8300a934562206d54914df8ff83b15dee3ac977a2c56257cd170d06e6b5dd97090bb49df59e4e641da308506528f0dab79860b2afdac1a79f1a1c6fb1c56895e08069ba3f8012a16324fb1a0f3766c170e21b6966287836afe994f5ee800c34504c3dcf66d69ccd798e387d4b51723da8e0742093ad7465a9e0818fa6b7c87235afa6e576a3267ab356df7fe743e211e6f923f77a8d0175562eab0be5ce77adae0693432d290d5b3c11f18beab4a4d428845904dc83b60b5535422581b3da3ac2a1cab7b18dce742ec208780cb1538832a716bcb5bb9e0f850d87093336b005ac9d6d89202c6fd03c02583dd49e190fad87e2e9abeeaa01f14306a09aab2b8aa2bcae0b27eb97ac5711f03fd827dfd90ad0a747e38fccdc59f3eefaff708d02e7deda339f3b04dd6d383aa34cb2af5a96928bbb985bbb4e4e67d8c407b0ec713865411eee8ed36a66dcc29a0c7e4974466ac38f87c8d1783828f9849fb8ec90545bca2191c342973e2eb60ab7a16470483dea0e3f17be6d15bc35148b410df458048efdaf4246f1b840ce95fda24ed4aee02f4b78f697991070d0191b94bc78dea6a44a918d9d209076974b2f4254fc972086f53aeee50dd527f0e5a03cc4ee3f94dcb11591c6d21debc0ad537755fe162ffd480ee51d5dce69e8794af26b2df262496c146c825493a2e7bf3b24082efe34ea2a536dc559d7d451ae7bc65ec98d88f3826567d2ca35ff250ea050fdf04bfa7d7296e81e59956792d69c7afa9f4e2b2dae1715a54e6232c55d35adafad9a0a6a6cbd0f5fa1a5f255672ce851eccd2c6e835d4a29362b961fff46c19a05ec00e6dc5825fd7ce654fce058e9f3a8d7de84877e8832ae4e1a65556386867299ab23d4bc449487dd91c0acd31bdff9135f3f76cb70137db6f125d6fe10bebbb58ebb9f89836291db040ed0f04a4d5f3d28e47ff98d7f744e6cc37665b3a2fc8ae9fd7ba120c876902d2223c8cbbfac57e5b3936b21c2a0762f63341248ef936fa32b1632416cddb3be06248ab5ca37036a70c95da937faf7a370ae6dc09715b289a512d6c3ccf98b50053bd515882d867e086ea7db650adc48df0f29b63dbb2ba389d36e4291386597d7e959a2200811b4aef283da4ba9b912ce5027c696b43823afa0ecec734b76af19db31c99c8f8409e545fc6ee8db5ad25b5e25e0283b41981580cc460eeca2ef770985c48625f334ec74d64de7599bb1eca7954d513a0174d1b6632e654ff19b6bb366088fd480c1c3bdbbf422fd790d340234027635b2d7496cbc28e7bd3950817f615b15fe60b7d4557ac9ffc474719a6ad59de3d26c8f8f41cc84ae1f8f335705169b182c212c3d0e43e6557fbd76fabbff52dee405384fa87e22992848b1e55a2408451f8944d741593ebc49714f1dbfece3ff7726094ae41c4390af520050fb14e614094a2a30a58077337b7222ef5fb44e82d24a0bf5d5a0feb10a81e8147a82d5857a069fc76cc9d8b17d610ef9e77b238147e1cf9ce27ee628eb58a95f60614ca08a96781cda8b2deede69f7e598f968552329219cbfdd1bb78b971a997592a1c7708d2cd5d5250e9e38bdbd6e4668b4198e02f0995e8e37d69fb0e89963c5a1fcba658153efd4cc1e4a1b4a592f1f2b692f85f378a6ce0de93abceb1f65b513fb946f911168aca04aefe4422bbf320c808d23510e92772c47aa1c536a3b55f3ef646de4eb2c58539c8476e42110ec04f19e0dca4cb073fc3fdb51b38396a04955f77bdb6bd0fb5418542ad423b39da5cc1d599149eacfd29bbd2eeb89be5bbc1b2942c84284835c3b4fef69a5f3c9575fb9372e75d37125f5aa513325f523dee030baafe4990e95ed168660c202c80a4c461b2b88c8292bf68b193d2b4c00e9567216398cb4fdf28d32bfac40706def9161667b44fb74381b2eb121c700031b3334b186b6ad9542c846f7402b85a00d598fc7748be0b7a7eaffbedf1d88088acfd0acbc0428f2916c0e90585a8cc1b1be48ec9272fa8bd7ad0121f615c84a6f839049f89adaaa1e4e818a5cdd28b744613dbe67876676b1ac11ebc9d478488f1096ce8cb585dd54ecd8ef3e52c9e44fa1fa559985b20e27b564853699262704b64d234d7017a8317a98545d201fd9038f333fece2068b3e67b0dc82eeae86c80d4b1f35dafe75b63d5fb0e4a5088b790f23c453f210880a3b36e0fc9f56249ade92c549c034d09fe364b0fb08740ab9de567a9d459d9b719822b10d6fc5214edd9648f7ca2e2131747483b842d2b74c0f1978e20e31a5dad9e3a489ffe2d50b8d1e36b2ef0d9f84275857947307e1d62242827a83f56a7d59ee25889cdceae25fa2342214ec8188eefb4288baa7b15aee950d927e82dd39af3f9b1d05f242e861d78c16058c53c18e301a4bcab676eb798c689ac1b853858d34fa40578be6cc9bb7abfeb1042cd67b8899e0bdcc6662d13200999b4d6286e1292f3dc01c108e3ff4b647553b019a814b7299a4c6510158effed7f5459fd863dac5635b3eff732f069951f57e4ed192224a934122032ef269e919f821aa4c3aeb3b4e97552f35d7d6b5b283b7b2874fc832b2497f5a716dcb4174a843aea4668e3b12888f2a7740c0e19df2ff5a11b091dc74c27e9586e9c342aa997b13d957b8ba6852c7bcd7f7ae4c1e80e4bc78485a644a6aef28d18ad0817c04c3f33803064bbb04641d26cef25d5906bd659a2be4bd86606ecb8a8238d45e320b65e8537f38f889316b1d3a0cf7c35515404010bca4edf0a54b65626dff0ce9d5d45f94fe5f47baaceff5b6fe8531a0281a5901126872a04959938756cacab4557d59fb0c4e7acf46aac97ca4b68c9edabe1b0ce961e4edd9d6aaf7baff4fb478823477fc8c8b172dc22d4a73825b95c3b9ef53c6148c97f71c571753516724631b3a62ba97ae226ce1b4aaaf61c6d75a8aba5f15e8ec5d7d735e6805828c002c213c7e815c92116664c342916d3b43eeb5a4bdb922b840b591fc51681a45fe1153be086881202f4b8d62ea741f43307c9298600ed2d320352167130f1b09b953de73fd7e563288312eef02a9a7e0565dd0bf2dbd790f260558f0302ba7e4aad04b8e4b9cd7f8f1429e3b2d3d24dde3ebd0245bc8638663f6d93174713672d0d78eef4e382c5210839b16b4d4be40a232e3ab8f3c11052a4582a9111a404222b5312718622ffd914f32d8f7f7d338c59d8d5d50b446a796bb646e6325278782e81c1f7a1c07ff0ba643e6c433e014a67e3042f128c3a213ea0dc5114f5480a19aa100b36663a0e5a95d74011ae58a55b1c3bf369281fa11423b0e6d1c997a0a04c42d297db24c86e196026f88cf29e2af8ad5758778d9e58fbd05018562770389678a3b018c7ac7f77ade0c475cacc2ed5a9067b8027f51c94d73f2048b8d6c553e676316c0c464e2748b467ff102fbd2af63c6f363ff40a82fcc7a680500f9e29882a1514b366fed51356f0a72c0dd6f8fe2f2eb420feb7edd3b295bcccb2eae3362b8cd4b942e5044139e015caee4ebf056a97bc18c47df45c8e3bfdfe2ff4ce588c2ab5833d7b3ccbcc9e7839317db1c1a7def942cc7636db4eeface98cb254bc794002a7ceae3dea53bb75ccf083bc9ff38453a3efc90aa5c6079defc7e9882ed985e470926702e1195878a682a48b2160665100248eb7cd0a809d413442632f94a5b078912a9cab81e0ba43eb0dcf7bb3eb14a8ec0ad7e65dc8bc69ea1f229be162899a17593dcd30275891f47be3fc06767bdf58de731d9cdee5c2e875186f14f212ecadc1245dfc142c6e2d791f0125c7d14e4694fc9a20717e47517cf3da893c8e87ecaea579a8b83e59146c8abd776b2f238f8f500ece3a5d776ede5bc5d68778016e53692509e4e66c9835424db3b2db8a4c5c9cebe453dcdde5756865572dade6870b44667a180a86a0ee8db0173f111c74754cd7af786e9e4cb97092d969337db6726f4ca2b659941119e751499b9193c65facc24556992cd2b91b9e319f144b82747a377d8b57035d4e34ee6add1fd92a1565e2ed4a31793db3040e50441a5d9fe00a6a8a6e25409f006e4d1a7624b48e85ee1d5636207355541a6a4b7cef5979dbed9367561b6fa06cb1a6dafe9675ba3a957f49841106ef3b57f0757d4b8aa5822cca2b0bb06baad7170d27c218b85eabc94020b57cbf1611bda50a47ccc84b9c5ef7d924cb79abe1a13dec29a48d80de87d38e67448f9a702f9aa5adb97422615b31fdc572c300390ca4b330200fe79e84030418e744cfca972c8c122348e1e4c9cfd31e7cbe572325f42c7e806e537772c18e9deb02df5f533a5222242b11d25042ec46efe62c7383571ab17e64a08de14faf7a53aa1962f204f6dc030587a12ebc96e349da33af91ef067f3d33c4f62e2846b1b71c03b13bf3f791e60cfc30d1baf06b501ba579fd4a4f8f1726813cddbbd69af04a281d3843f8d13daa9ae97be6d053a22edbfc80ad240fc95b269b332d53a111a0e8e03b329b23c48e00457db6b8b0f65e521c7e47cf5143fccb78503786532b9c387ce529d30e813aefd8d49f4c22d1db5089b733a4a9ca34af2a210b60cd9a53c170ae9cfec429ee15aed8f9f2a81675b1c7275454430c4c1114291aee34ba30d3abc04d6bd7cf98773e202508be7fb22f176d9a5ccd95d5b29d9c68be4f1bb259ff7ce190089572e46319f9ad061f4313fcce96e5bface73de8d6e3caa4e2e1f8fcaf245a0f26bc5fa36854eb0bca21763dc6099833f0b31cfb50d213160e4f0330f004c14f0557d57fcdff62fdce040e58b8528f176bb04079adb50302747c53612ecc4ff2c8a52e69735f0384c054ea99cb36ea580a66b665d52495f1b00cdc32af07240d8c22b07b32f3f4d7e22f7cf36d463cd7134a00f81c743aa6dc5d8762dcc6b54825d8ff449d66316b1d6da2352dccd236194e80e60f599dc821521ab8a6b5e49832cbbeb6e80d096fe07dd2a5e9afe92aa4d724d9ca5e58418b50505e42fb0a083f71b62c8ca90d318f55f9133a9b45cee6d847e840d52dcdd080e18b1d63f2993a83cba4d00803fabea828a6ee4bf2f6d91190537266bb049e8d553f32f3992a6d356267edffe96fe5996ab883cc5df227d18a22d534fe9c883cd81529059d69d777aeed800b85214c8ea5340808afa544a9c1d5582866750c6c19c3f5f6a8754c5ddb4c7fb26635055cbd93f70ee5bced47ee993073f5c171f2b31bc93e4b01cb9cbcf7c55933e9007737fa0558a87c4332bc486e4bd942c977c838f05647a4409eb12b26e51fcec09f624610c55149909f2300eabf6318ec681152a9172b700f3f13b22a32d2f7a6c09f2377c0cd5f1f75ade0f768e193056948d9df81947534c9d667bc1213c6c78e4f9c394a23d0f22bb93dc17521602121cb2500a47b1a96b2bfa2f55b7c0325ea9881dd1b15f392c7e99a441cb7557d55239cdfd3eb803ebac9c5e3c4235a3ece760be39271dd364a700262dda2b8111e05a93ae9d519963f9723ecd48d0d9e8ae6559eb0a131696dcbc8914b2b5ea461983a0cc9ca30dba3b58208aa6e2685e16ee784c728cf31419b23867bc05ca90e60f09b7f9274603138e4c2c942eafa15580aef6995d1f560656788a620c4825082bb9525a5564e7b0c2fea2ad2f90d6642390034d7ea82bb6a0bf36e23a5103739a9a831af7e6dc47d055f031d731b78b1fe29ffb268d7bc5c8f549798680da67d82a0486b52df845c79022efe3a2719e179fe9accfb2e53101d0090d24fc20429ef205ddeb0d506ec8dc5bb7ad147a066993107a99344c9d0170549db6d8d9c141fbf6eeb750a778cb3493ac7b64a5a8f806411062621d1af77a0e5699fc10d6f781cab4a9dd2bc710256bb55267e66a5848cf99f8ea408161ca8418522344faa1e250609dfe99dc4e81bd8dd150cc7f3ebb633f1b0d08aceae383e9d43c00d7d8b38a49e21faec40ff3de813ec1dd76056290a8c6e5ba23a9f7c89aa0c2ab29cb30f23288664133933fc1fd072ac4a18e70edff01ec97ce59569283c003a488b052741063f8dd70562e57a3b8c6e1e706b74136befd604b02f4a36077532181f6bef51a327525face90d8554909764322155563c0baf6a62d1e2a741246e62e576122abb16bfb20f6bbe018e4447ec4bf41ee7fd4fadafff1e5eea3c2286a5d372ff99b15906fdc1cffde3ddf00f2da9e1c96211b464eda60e05d993132d1287acc1a0846428db5facf87b6b50d907c9f2d865e247e85372278474920fe82dc0630fa6ac12304df78ff506d7c1db492c30da40ad39837e2ef87ba2d44c017fbe7b78d195e5e9a92c8f0eb1a7008f06c5609ce863728f8e99d147ca58be6ea5508047435505b51b833d45cc57d2aa6f6d5422aefed2a874c42dd2a7737dac913f716f45a08b541f5c1a488bff9a75a0e0e93fce9ad166afd133d9cddd33e2279279d68dbb9d7ead91d976135d7cb5fb963523bcef7676c800fbde1ac0d37a9bc464a64c4c6283702cc60950b67ab21c24e55161a02ecb7078eb8f09f0d571e48b60a4300653db7b381bddd8386e3826c2a1ebb3ad8b73783c715b2531f84e1dd621c764948c00f7d2bc3cad2b40033afb620b1fd8fea2231914b7dc4090e7c2a6267b0827a1e8ab68f311847cd57d2d506a0322aa90e5ae93f24951d8c658bc670b444832577e3894d20c15220438d007c0c5aff29bf38e9272c5157425c3bc3d8873f9f06762759113dc577a5ea0026489535bc183da721d7281bc8f2c00e11aebad4187a59b30722f829bf94c5ed09749193202e68acf7ab3fa6f827fc049b3e7ba4af9e55094f1bda4d6cd39307d9bd450eaed896f972ddbe0669b909e0056c17faf0217722a2b558e719c46a621c336b7f8bec86579c852e8c258a1433c8da123a0a92fad878226d06869bb639bcab45d684e67c558bfc72b92342bdfd636866a779d81638c1bd33fd140359f681ae3cbb3247ee6759971139bbadab9e47320d151cb887be68e8c8cdd19ca9e1360fe0d448701ff0fbfae40ab96d530771dfdc8c0ae118f35e936594bc799a18514e66e6fad7095d0986811cdb6dce66d42a3467daa5040c234c24e1349c81379aaac4c2ea48b8eec5f023e54fb1904e96caa85dc2d34b8d802e6509d6d78a3617635b5940be2982e6cb1e45607d21974e45b7001eb7849606d567f3612953be4430e262fe6292be06d7db10e7fda02efe9f3adf1ebba9b6e5629291853551e339189aef1e3c3ca90d35951416768a9c19efa9e47dcc862eaed49f3e69319914fff292d9c39ed8763aee9ec42ba9f61836f455a1728233ae025410281cb4f74cbc17d44e3760595ff82c241d66ec62c920adadd2a518e5b79b33a8a51df41774cca435303c4f7b7ab5c8343fb12dfa7c80b9e655714b418eae23a0ee72ea9cf85215082b14559259a8f65cae253ab3424861142a73b73685544de71f6fbe2d99bf31083fa41ee3c1def309ef04a2885a59351cd0c966d149ea04bb242d2a8d7cc7397a4693218b2b6aa9a4f63820d7dc4b0474a57b13fcff9c5ea646f02f192d584465b01e16470793dcbb2095540d6854026f89ab3973b1919ccd86c38b8067cdb34bc15b84bedc8ce029e16cce2036aba57527f742c815437dca5f67337b1ba372205c43d29f5699e2c04329dc5763f991437924a2cade9c76665360a73f5e6c7c0f1f0a9978ed05701c65c805b356a4450575aded9f6261887e1ac376b26d9035c9060ad147dd9a2121d8d3476b564e83f305845cf91faa52c55e331f34bd07aa546660f3482621086f05ff4c47f7199f1cfad3318de6bacc69f35206e204c497debbb0bdf4667370a6c7d4d566ba56fc6b5cebcf6d4f45c817df8524d8c8c184afd2aa1bd3243865b930ab1c974d3cd7c3ae1d715752d75943d3a766fcf9ca6d081ff76f937926e7abfa4aa595b799449e2f2e413c1756c058f073d556b010418fd2ad6822add1cf55a8e7b6738972149a200edf6eaeed650f12da107f1190420d32a65e62ee684220e9213fffb818cabce31779a97ce8c3883fec68438c5a36fdcb52f01ce8b1631c1c395b7c4d469b93a0c9a581b559d7b1d78758f431bc9d0595baac3def0f36161caf1fd66dd59f656c2de9ad2f5e0e0a38082f594b3d311f3c444b0e86babe8e9315f9233e5539dc8c22ab5b7fc79019397671d53d2da84823e0fd1c02cc04d447ea81525d8e1699587431391ea109e4c06fba5bed074e9371c82a3e029f5bfd193fc88187e389191a814792ecc0b4c89f8465732633dd85eb7c8c06d0dbbd085e404f420f1d25d5c13bfbe1165d80eaddf61000c2f0caa4f1e87414cb288bcef6a81147ff60efc9ed6a7d0bc5dd8b4633e142f61c051601fbeebb871e62e370509e88b0e4123cb0856839d5fdab2fff90859f8b39fc5ae83268c7cc32bb442027b27d9b8d2517f6ac3c86397b8754617df74d744a42d67c54b1eb57ceed525c86da0bcaeed1129c6d290f7bf7b4c438ad2ac28aafdef69b1019c044cbb346890447a4b774193f81bfd1b24011fd0519924f346f57668cc42ab04a28e8a5cba01f62c3c5925874f175916e23591acbc5ad8edcd872c7d3e139c8471f2a3d3d993b16cfa7f4ecd9571ae1511345e15c9306c63283934eeb22577272ccfcaccd20716524ef2ca8959e9ceca3a7f2295a6799e8a422d0b3469e936cb7151bc1cdd68767b6d2b14ac9b6786fae803646b9c5a2f51835e1db04bc54ece74af4b67d1b927d8b9d181ca0c2cbc970b133787ddbc138c84b219a5755c3137bae6b1dfc176b92d420f0387c493ae4def0251f7a0960919369c119aced31ea04f727f9e23966dad012ee72c88452ae5fcf09a18ae7c3872156f7e9222e20db9df476268345bdc65c2dfda8ff71d225f1397f84452cc01df85dabca2d37a9d859b8e120f0f4395d1a6427c631653728d4def4d8e10314c373bfdac699858773ee3ffa83bc82535e2641b52ed055b609be62b7ecfd40e54032962c9b04568c07c278690cd4470b6f29a936d59e5aac0457fd9f25a27ca54d62b86a6174508701dd8f02f02b861de846bc95318bbdda1a6d7ac85737671d5ce2061261de5d35ad98ff9c36991c98ab35be527c5a0e817ce5c686175ec2211f8c9f930c5dedc5569c347c16e11b3853b7d04836238bbf16420d4a0bbfebf1774c042be2a0170924a275a888dd7b9d7bd38b5c137661208db05ad11b62be07ef734e7aeb3e9082fc5238db4706d6bafd057bdc6bd144f607ed116f0ba10af22ff4614d938c494c3f3b19814f93359f6025e2a0f567dc0f7acfe245f565cb95c01a64533ffcb09a41b79ef9cbf19566411a32de6c5eda3820744ee340d8c399ba8bdfbe78c9b005a1751730b70da3111c458c18706ee9a9a240822786ac1922ec9c4f55d4d5f2e9078c8ded08531f8b0eabbb7b9b4907f01bc2cad02310363eed818d3ccabae95b13ea43f6aa48e436b1d3ae3bcf0d1fdcf3db76fc98dc63eeca94e9dcd6e3ad9bd844a3bc5deb319517c74141d06e829f0e4e8edbc0f1ce2980eda40b49531c741bb6fd8c81e815fe369ece9a326daa2a495ac0c12e6dddd63ed42f9cb5f7daf94317e855f4a2064be6d7014c33c94290d7f2cb07a55e0907e2e5da7cd5ede73e40bcac20e0287d53912ea20e5830b0212ec556c0198a8616fd313f513f744abf4135aadc8ef0795343ff84faf90afa0676d9d7f9ebb58f13b9051c9db40ecb31af5ccec932dca970c3bfbd428fb1d49b5b8e3159b150c6ac605ddea1a0d6b89799b18d7ff7231eba196d9c03dc38dd125c8f95d04bb7171ae71366ade785693f69b7feb0ff2072bdffb2af0104fb21033cfa71c99c175b9048b9a78ac93c961f02fe76248615b1d7dd7416be436d644a2202b917d3e8acdaffc0ba3116e53715e70bd3fa28ed91e9cea3d5f76feea7da3355a4602adf12e64e6181bee8536790931ae16f455124636abe84c0c7995585b6d5fa3453de9049f3509950f0593edc59d4537cd3ef1685b99fd244684b91baeee65cb1886401820186e7f245cd66162c20c8fa3373ca2ca6a5ec5d40e728f9e88b30584311b7df7fcf6d3e7638069ff25142aa70b40ec096cacbb65e3a0b90147250bcfc1c616ededf3938ac2b589af8919eb164ceec24d71dd438bbc30b0c982edc65b47ca742166eea722503c3e3d874bb2aa1af7cb7f315beca6a93d98f0996e4a8fe39ac0ec48d03e4fbd9144a9509e91320649deacacfa58a05d5a87aa4ad1a9b3bf6857d607d1dadc73cfe937ec1fa9354978aa454779d01e9752af9ab8dce18b4961f0cb6db4b73927df333f655312c9b992218833885eac3920b0ecb5d13683352788902d7ab05792519603ce9c99db744f79f0760d49eb9223d28b72ca20ee3c7161370942234b5006fb8ab19b8460c4f31a9a7b43ff8fc08b4e2b8262845258fbe571a1ae2aa8e039a381307e5aa59778ccf3eee9b7e258a27e0d816302bf285712e4cc45f19489501abf5253b5ca98256aaaa6e9276142cb3935415d30becf6e8df41c3602e3875dd449a2fc527a8273153d996b3fb22159d19090b4a67ecf1d83efd6bd62b649f251906c91141ab507645bcc39e2e844c433147c4b9a9d3a591368db98cca48d95b237017f3a89079d353536700572256d207d084423636b4594f80dd0799435b6f37c8906ba8527b97ef46dd58d2625591dd9336035ccf2d2188891105630057fa0cbf3de2dddc6ca7e02d76ed3cd2373ce48cc9b2af3322f2f4901170c510d6f726e4c72b3d20c013d7f729852e5d99fbec01344b4b7b7a00362283003b6e8978ee8ab522df78ee562708f7d16d5f6b29932e16ebf0c9ed7579e3f4a40f1dc14604cca4a6a544e5e5aff348964e41ddd8b6de2a2e2e7072df9748a272af629392b72b5c9c66eef7e1f5565505f4dbc90b9cc96dccd4ca4895b138b903a8660c8a1c802372e7140fca862e76c4064a8e78837f3273edf9f3a48d5a4db788d7e1d6cf78797c706104357f5d704ac87f2f28618402a79607b54adb88d18e7b3d0b0845e0cb9d70c54add37d95c4315b916ba07a0415fe60ce575d853368dc07e65a1ebf4dc6088785f7a724a565dee25a5bcd97ea8f57b00946d8647549aff71084ee5e1dbeb6d2783785af545c0e27ade410554e456306f62dce0e7a6aeb039eded505c175c6129b6a46ab58da31bc1008cc69602f22b5cefce7fcdfe54f3d590e746f39a10681cdd2dd48de898bbe00bc9f377320befe21b7fb3970eebe3208d695307faef28daf8106f8360052c59e2875a12154d03fe1f8772cfbab7ae4e7b2f0f5e8c32e0d82bd654736f620e24f54f93f70e05a5abc41a46f62aa30454a5a1cf7f5850da900d1db8a89579912c51a06b8451838d2895eda45b9788030254dea7206b76423aadcddcc26280dfb19c4c10a3f06d3c4e2a4135191c8654637290b1eaa19cc211abd99a5c8d94a948fc57d4d30c9271ae03b32ef8f25cd89303de2bdd20ea83ffd862875a802323dc3d4bd7f3993b89f313005599bb8c024d28ef4fa47cee81246403df77cb679ebe1d5bb688f69a0eea9acce5e9daf06c32565c161a0fb8ffd40dc1be829a8b40fd9144d181289d7e33fa2bc1cfc8546bfe7a79e4811cb519122e09b56a89532befce7b74d74e5e09808973f3994a8aa97e92abc56a1e81c6697906ba43beeff8b72ed7caa7c95fc08f824e11531b1141be0ec1acf59a3c5a148e44b35b99294eed8b892af4c7bc27a4bd50de787d10b0bf90a2b38f78f6b27b2ce97027e19394f3aed7e772ef454ba54d3010a72c821eb8987c075ec9a41864c0ec7f9c1f93d7c276228bc4960e3efa27fb915d34afa680c7d1766b91eafbb3675bf37a16557ccdbcacb7f9f93a64724a0b96feaa58b85c4a7d4c421ac56b900a440ed46191e9a85d3653177301d0b57c0d723f0e5bc192774683d2e95596e7a930c760b5e0e06d63446ee708a05c90a9bfbef6dab7cba65855cc66275a0a8e41e783d3793dafd44a477c402cba1025b9282ca08cfbb184d07dc82fbec0ca93ce67692907eb56b6a98516c14d64fcaddacef14ea106021f784","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
