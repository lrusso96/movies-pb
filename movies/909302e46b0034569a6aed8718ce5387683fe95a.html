<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"93af8b8686449d3d3e1ef5462c4ded23c656c93c85709b6197257389ee71395b57b97e4247c4e2a82398c80ee2ab1b5ebc58860a9b7a733780c197d845657ffe40aab7eb98db4d6f3b1343e76729bc2699b68742d6c16356658eb878c8e5b781e41de6132e55fa2e92be6c3e94fb4a3f237b2b1a26bd82a7ca635a44f49060d4a8401680c54349f98c3cced4d71f4de6efe13492f99321ea91a43c5f8a7e9c1c37c3fdb1f7da486b1ab714e31942092cdcdea37175c21e33badf0d98202f662eb5dfd11fdcfd58c2a2b2924e746a7046a6bfd0d378accee522e11c5ce38d4fa356728ab2f47e43646c2124dda334d2cd4195ac7afd4e83fe03f0b24f22b4ada5cc69ea7d817884a46a55fece042927427dd9384db4e70d7a81183fa21b011be2f0e12b14e51a9fd1efd2b4f70ffd6329f9f10a399f855e094ba4bef2b012482c3046978121035eea03a43f17760337bce3960e7bf0c35ee5fba9afe6b040af4e423c967c90bd0bc7b9c7b4467e3c693e6fdca4432a6c14ac492005fa57c240ae9f9a182cda953236ce9437c01dfee8a4700d46c1f86afa8cc9ffb9aa9efcadf4594b40b6f8debab4cd709adf5ed8aaece67181b47e1ef28ed4f623d923d6d000bc7e5f881814a71e6a1fe609ee2bbf4d34dc649b23cf61c00ae47a9e228085fe7c6163ced9e6ef53c2c20bac81f84fed0c42390a410ed2a1f6b05708850502fa8ecf65513950d271c34a0c40bda9b9769b06b3b40df07e5d6342b3a2ec70aac6b53f90306d00ea10790449e14c1c4621be350e66ee621bcb45f4cdae7ff091b7e860873e7ea69289eb44e9713b22fcd65e20f5b3ca2ebb968e45a615f150934d72722e87614de91fce486bcdddcf27a27b00a8b20e75f78e83e66c862c262bd660cfa992e65549e08589077a3b9467ea77d11db679f602ba8486f3d664815cf1a96787546aa0f1889951182bab34e2af7fcdeb29389bdeaa4ffeffddcd76314712d9aa624ef534afc2a0854cda74586e75791a02bbb07095c7ca114aa026b07854c832ee5a8fae9186f9c050c56093439bf5304144febd2e5a526ca148853e064f6a7978defc3c36c9d3327fdb5c8d0a2885bf1611b4e6acf36224881ba614324fea28405b6ceaea8fb304bb40066a31a3278b2d10a0009976e6ac1acc9736494346fa7726f4dbbeb5c12ff8625fbfebc33efa499c13712747dbb6bdae8e578178d92804ad46edd88c1f98f1cab7d37c327803fb3272066b1daadcf03e208b4aba636aeba0a777ce43c76c52f5deaed2b02b2ea9108f045c13ec92910fba7b402c369b80a8be254812f791ecf30d0d3c6a44f4c39210cd8a3406db61a999d20b3d7bcbe58aa17766fc78eccd16e4c74fd97c6c3df4f0cfe2a37a6103c170f25905917ba05244fbf138b7d9809c6d0916c79c334547479ea358d35be2cd920986b8c0cebe6efd50b45add359a4f0a0993917c4f198c45a6e5e37e2db4436a1e3479773ea7bd398752c0a6204bf55fea175c5c2a5436dd762137521957b6e1db79038b15c0a32733b9b43617ddfddd9fecf3c397f41967b302b690c3e01709459355749406ca855239306a106b8a66177eb40298ad2d252e6d3b60a2cbb81b6becdf577949e32b2eb67e37c8758468a9822bcf570c08ece884bf3a0d58e7edf61ad5504f59e2c5b5eb7780e215172e8605c6d042889d1066e1c4a71a1f60edce427ae58ff7be77d87affe5c1fc881f3f445bb10d23c3b3ade6585d7ff8aa251167ad571a2fdb02384e6554f6c84e3bdc239a6d01f767c40ca3bc9087a101d78e96ea08fce11284607f4454f367bcc4314094d1c6543c7be228d6b12a795d2f6f28385c74fae60ed5a0699790d981870aea07ec83ddcdf9265233a1aaa5c616226b0332dc9595ab93f181c1b1bb4f0b9d4c11fbd8ae2bed6767bda4bab48e7faa214ccc7b9501684edcd58be23e4bc8c3530982518b6044ee4c154a30bb393431b7a56a7a5b0249939b51462c3897fa790d5f6c707168a85fc7de19dbe3de05391111f540fbecedb5feb57a50d6dc9899b3ea2cacc2247ac4089afe4d31313346297a246ceb1adf1f4cfe4eff8aeb21d67212c93188a6fd57f9370107618896f14f6d1e6cffe00587e0d0fc59c9f599701de0eec8c10afa2b4513de020346e95579018273c49b6426a4a2e007cf8932521beaa3da73b2856b50745935783fc4c461eea7b68d443c2c6ff123204b41d559eb31dd7c4aef698ed3758a6f928383204b212a64304afa79d57e697e826d2fc676d040e657ea7626abe08a06c4790ffd3831c1d6f6334e1cf5766795d5b0de07860b21345ec7821b06a3af5b609d84b7e0abe3110a5485dfeaeeb3bdcbf9db3a0a5d149a05be4a336aef8e0daa7bdb71dc6d8823796dd041b050438d5117b4bbc919fdfcdf3afe5e29bf4f4f9c2869eab5211bafb0af0eaf0fa0311a86e09f5c930ce815e58756042e8cd7ecc9e67129c979bf2ac4e1b7ef5cb9a6c0917d4a5248b7f133ac7c2d0649aa07df0f06f2b3c38be09921198182949cef3fbda5ffcbb2fdd3ff2ab0b9f706699a693aa69f398e7402bffb05f767cac5e0615a56d6dbf29fe45ff682a0a202deebd156ad12ba0b878efcfa64d280f5466acd75ad3d7121fa755808057b962cd0ab96d90570107ed4a2d6759d7a366a07d155dade20e686a34655c92b75c9520e776727063c0f708d89222e9bb130b7017720a425c4413dc37e4fc187c924e7c894fb7ed3982affcece3a4003dd9e83885480415160d75947e8e665879ff5df2e202ce122f10f1dea60d19371eb8b1938635a479f6c37e66bcc7f25e7462f1d70f9c2281b652227a8dad6f6be2520a518fe32c6b840c186b82e09aa3bbb39c1b17bba19e10ad5cf22e071bb2d64e220212289876a750d9c022c90e22c02d98e2e78f520fbb9238dffa6d7a24e248ff636ab4cae08ac97a2d528ef733dca16da3423d8326db890a570a6e02b268dcc0d099be6bad5d97b2a7018826820b985f1437cf9bb5f1befd26fb8e02e25fa33b1e7eaba20bb892744828b6f39e37df0597f57dec88b07fc664431c5814843b38e6e7a002c9fc3141211e6125321c266c9a59d8fae9f990c84e4ceecda3619f2b57206a4bba22d29f67cce2845018e054ad5702428ede37840129bf7069b5baa3af7033e72538afccf3760313960382d6fd03e53852f8d23c768fd5a1d0b010420300146e95a7af978d048f32ba576c426203bec9f506b25a8b4eb135bb6923beb8c1b5aef668c671c2bce6c65f70ceebc54ddc26ba47f8d32ad1359754fdd5a74ef53e4eafb98ff6fdaf3f6101351622fd65c1c32444825d92e364faf54db03989c505a9e1eb7cb093961fcd869cc1af4e6719f96c72b0900e4d695a72e3c425ec1a889a50ad56bef12f43219ae334320b3dcfb98ef14764f17741b1517d68346e5636b7cbf6cb2f4316b73f297e73d54169859a646444cf2d5c6a1df3dead05fc56f2a15be7cb5ca586b1a2fe0d64a54e01fda28f0d1c85f505c9a5e0ace705338bec520cee3ee612cf35abe112f70db80c09238187e7512a6b88bcc7cfeb3c3d68b78a95a77635e29ed5ed3e4906ea0f471ef51b44c075e21e2e45ea12c5f92e7c09fb579fdac3bd7e4b96f4f684e956e6610b96ca722c58e2d8d0f11ef3d77c23d56072ec2b4ed2c6eac04289251aa5d20541b9e69bd15971d395371c55735614d2263d54e11ddaefd60d6d83c146d582a598b14f5ada23d8a894c10c219d98badaa74d2a3f4bca61e226873321c4cfda2790fbd5b47f878891c5ecf71ddcdaa725b4743a32266a2425757cdcfcac84697b6af4b58857456a3e05eeb1998ea979512b414f9936da251d9072ad5f111d8287cf1bc28b562f5c66e5d1ce9cf82fc60f9247930702df0f8e5fe289d9497757affa12c4bf0ee2226e453fbd8a28d3b420c89bad2cd8f5ba5d8ac0e5ebc0347ab049df0ef2e08350b29a44ca0a556352cc17cbc0c1211985488ce021c9bc781e2084cd34387773fdc23e940192a9dcaee07c2c3f19489ea7b9cb1e02328ecb64121138d14f49fb59482383ecdc6bbd45591745b2efb6f7b20cdebe2e783bf7e8ecafa1aeb5d27b11fb6d0f6dbfc6f4e658a5432b27ffa083c5c4117fa2542f3db8c6a09d4626d1026e15122d8fcc23afb38533fc89f12fa056e26c0cbc8af272d1f52c811fa38f2655113d1b5088f7dd0ea90f4975f6d06eeabd76c4f68cf3f65725316b03a6885cb71140dbc7fb0630bd5f434d9675893ba7741cd3c63d8739077fe0aaae7c84395abe769fd53939d624dc928a029931c46f936a561ade4c2287dc499db1ec5bb3dff6eb1c973d2f00afb7228e9780149bdcfff1e8864bbf6f14c2bfc114cb4dfbaa682fdd9640f02ae74cec3743ce6d6c2091c5d47c1f16aa3f37ced66ad3d305dc9803c0bd6a23816d650647fa570ae03c259310c31674aeeabd79df5954fdf3819913a8f6ece2cd5ae4160150e96056a996eb6e8feb73740aabe9008aa35bea4dbbb4fab79ec20623d2adec71469536f8203416d191d77bfd04ff6451055d1420403c6acfec5f8a798d9fd26be641b8fcb5363148f038eb13263fac98717b5a9c160e905400acaba3df63b7a3888cf8ca475c676efb25bf06fc54fa9e04ac403861c5a9e400a21b8208d6e9cc9cfb0e838e9a80946d6c3d9b5f773080ec9865140b321cc1cb877b2e87a387857df3b9c1aaf04ced7e70ba12c157bdf49b35efece9eb627f53389d2218e4e3fd0b21c4755417107c5c63c1ac90f985ae2bf00cf25bffd1e81a2594b1246ee10554ddb2c84712bfde50d7a63d261a47c27d28d2e1a126e9fcab9e2fa4f0ce0485a71ba2cb4a47aadd3236a399b9f1087aa62c37c816753038818b64ec9b610b9b911fbab6243cfe37da42ef662fcacb3ba96a2a01ed843dc0b199ee283d3c29a0ea5aa586a350b407e3387ae65901b4c56ceffea447f63d6ba28b476bd52d84c9a89a1e41f17be12c8d1dbd401a7f060c3851f6e41891e4cb1dc0040da428937b4f4db5e5915df6e9dee793c216c0dc3fdf39d7217261db4e7f982e53835b0198fcf5053a20370a958ac4d1473c28755898103751eafce75ba160e5faae7ca7253568f388aaf0efc747a81afcb7673a4ae99e896719d0e9bb05f572e3392e804d2e2c0912bab7242ced2911cb75a6a9076d1ce3b547debe580de1fc9af547c2d91a1d8c97eda102da782f55f358397f0415fe9071abc094c2f861adcb0557266efb904840fbeb34797d3cbd20fe4980944c17e15beb2532e9999417d3ebb86b5778bdda9f84497b194c037a48587c30545992fcc790ce15dfacfdc79b02263d7a4c5658476e5801a4bb8ad4fe5fcbd055b3697a67d8d485e670848cb18666a50e8d8bb610f95a482ff032030c7a7c2d8e1d5d01cf4a6d789370cfc96afc482566b12c7d95b629cf18ff9e5428351572cf2f35f3eef66f2bc7ff02386602bac12fda86ecdde3e65a0b884afc23e0469163c73fb97536dffc723758b7b1bee69ba330426edf447580c85d00a97ef5795b32f71bba62aec3744120564f70b392c0d400e80c5249a18da6c8986dd9731dd36aca7317e2aa48bfccbc6a4b03a0a5b46cc089d00415ea58b5b8e0b043f33ad582af833927da7b915aebc87bf97b9f83c4e73ef98b5a43847b2531365c5e7d378aedf7e9eb7d36fd09bbdb29bec429a6c6248416b729ab91cf6c792d189373978ba971ab37197cf86d006c90fd68d53785f5a62694a39711ee9815c61388c3bff61cb19104ca5263aad152f40caa13fd439355778636fd799739d3de21554aee70ef4a1b5d7d6bb564cfaf4455a972f73309f7f5f7c8b479d59e76b4e29a85aa7019140b439c05c6b2c06618560db595ae215a3e85b92e86ac974c8b31092b4aa7a38e2a3249671054aef76f9430f70d0bee3fef698736da1bfe5c6729e690e48512b088a0bb757a3c4afe2dd3ab79e61bd4dd1598f6e281be2f1121ab406f8205b830ad71bbd78279d7f3c9f6785a533cdfd8d4d82d99ad3f8ec30a72d3d6aefc8bc179e13e60bd94cd2f4e9e4126c785d8a29e072123ca04c4cb7c1ea953283bd4cfca8c2fac97ff518a4dbe6b8497c43aa12eac93aa28dede3b2f3d46c03e97ce77f6cd72acb9a91d536bc22c234f55611ef7fc73244445dd44899153fe5e6f84a5e32e9dc8c3ee47a1f125c30b750ee5d6f21f25c2cdad16dd90f52cd59d049572aa17dd95c18e6dd15e35881d39fbb45aece9946955b43be7c91289531f1c583e88ffb8ce48cf4ffb0bc2d6046af09ff34dc9e6948dc4a40c4d9fb045de8d066168c21caac6d850d469fe33866cb18c68a0bf8ded24c61008efeab41a1e9cffda1ab5f9bd1b41f04acc1cf88e9fcd7f5cb48f7f460a03c7b3507d73e58168948ef16c3f4d296b8148cd157c7b490bc099b114c0324d8d266edec8e5d233d5d3596883f3cf089e26058cf9be5a9679c821c77d6e2d84cb96f0858c909b3af335a24a0107a551c3c17931e642accebd8b538f71d155cd1b699fde3d3512449958ed9b6d9afa0f83ab59d8198be10cb815c1ed78e327690de8c4152961a59c979c4c0c3dd475198d4eb4737491a7e96b493ddb8ee2ccac6c49bcf9655989e8681eb23979ae0c3244df6d0b132d701a34a3e59fa2a5e1421edd9db78b716422c018d474a7f37a258f89b94bef8371670cc536e79902a9583c079605270b1c79ed9873bc39981044aba1259cc5bf7ff2c415a58dc1ae723b5a44d071e649a75af744d45c48397372036f9e08af5b6eedbcf1c622df5547e1cf07ff733de5a7399d11f9b022beb9645d517e6b7b0139825fa8ce946e013154401993d72e51ed5ad231b704dabf7e00d500010e84a529fab658ef223399578be18d2d4b4537863ae7e7262fb8f0af4fc047fbc48f73f3e9f949093a6fa1367ebf7a008fb8f1063bd7704d88b067be736c55e9b66706dc83626051a79c70cdad61c2f99e45e1c970fc56474fc885cee285bfbc9951db3ad979f324e1e099eb4e70e2c01f7bb60fe97850da18bf855e810d12b1f4028e74d3c55a2c05a078cd328569ddad14aefc63b9bbb2bd0f7012b9ed1ccc0be0ac51c9bd726d574ef0c80daa72ce5e19513b4dbd9938319ad1245c65771d083e743984be586bfc58107405ea8a73c35e7e5191eb751de2f7f6633114009719496003f2808c50e288e9d9c76233250574ea11c57141c0c7fdb513a8e15e20509844dbcbe887239d893f4e4f12a1cef5d62067142a5632dec75f8a9c54b42ea1ee9b4acd7493aea9ce99628d5a6d6d904690d98cdeb562daf3e891cffd5773a7bf658605b166b38d447cd689706cc539f7e26f0122bbdf044fabe9307d0b2ef56797277592327f730d100b4b9652a335204f15bd9b348bb8d380f79c3edbb7dd7f6e9199791e4d05cc5bdfb19bb0925a02881d3dffb3a39ab16ccc9c9f9f95475ccd8f74fe1ac791d3f2f68d0c212e7586cf90ec4ffd3348765892790a57bec537c8c4a8f52638ea1bf5b6ce64dfc5e6c5afd8b668988e6d6aca98c740b541f02e758ab2cc3a56d7d6f7c0506fd67942a8ec71e8dbfddf51e63579abcbd5f4fb237f6e0b3c70a38d944301252df806f018bc16a8da24e4964a90b96f85189dc501df44cfaba1200bc24f8d6f66ca68a86569c35e7a9fdba0d4ce46e02978befb169a401df20b7237cb2335b43be543c3a4417a81e86917f62106647f35378ee1876e3fb67e78017860293c4edfd8e589384669eee22ad5438ee80e919c33e9a7ea8e8c5dbff9402e33a32e5dc94fcf30168708a3687d685d0d4bd3531a4e84ec4e00f349d127cc2615380c2521cf46e601c6a85aa21ea0010ee5ebb8176690074830ccdb033a66192f60e24f3cff542aa6a169612f0837d85518cf432d00a2b8c095b16c977613ecee293ddd8a39c91dec3c5922a21c857b02b673f8c7e81f216c26cc3c67c288dd803b0db5ee14eee48e8e0840990e08c1f2857d5359f9913e180c98a7910d2013a59c415eca918b97a929406c92ac44f0db551efb4cf5e0582d67c6167ef8939c46b020c9ef45cb74cd6abc6b6c1d15d9924818bca2f4371bbc08356baf663c030d149cc7a27f6b7fc4b31bd22b28794dbd9c9d61711031b72501a76ae8f73e0bfe929f885b06306ed20b50b4dbb226b785a084d8bbfe976957c7fa40b4e4e7c1eb5e31210a2c73142b004347c2b8b29c6f410129a459987839634fb062cc880b536d00e8311a4d13ef5689842fc5e27c96df959b098b283387f2f30cd4308e8c55dad3a056c917a51096a9a4b10951c328ee3bf1cb278d7acd79f6d18c44c1775f628befa083c234522747ed1b2810769b77a43e4362478ff26f79d6c5c1b9fa3929d44f52f92a961c055c5129afbc6dba854865ecaf081cff5310e6fd3ead8d234d5f689f7e89cfd96ad834c7c1f03ee69f1476d52796a61c2493397ca7be121fde0e545747a539a2264bbe9ffdcf94cc7245c543683a268782ca6f4cc255edee565b2cd31eb1122cb7be4ced8fffba81c6da1c78ebea52f75a392b600da3a1d5dd753819eaef73c1e7fe2d533cd2ea9f4f13f92704e51bebe67a1213866bf8bcff952c229e8fa37b71c61b9666c4833a65aec6ac33b9f6f64328f5832745ff6a94bf43885a4b57b70d540b191ab14a3c6d0b7e0857f0e8000aa81f31262f14049d088a9237895507c5cff11f3a220fe67ba6fb764fd5781eb8d6cdf6148f5a78d4e11cccc78e82b644d8dd58aa1dfd35bf19ffe759a90c3daf1f788a1b0a4d7617166daf7586a9051e43c64e0748d887eed031c980a9bfdd3db18a15489213e0c10a8a8c76acc1ee842ccd61821968b5b8c5d40f4d9b566a662708418684acfeccfebb868df23a7406c026d43996e9f43a2c314bfa4d2736a5ca0b118b33f16ba26ab59ffc090bed860cb99052fa6e5652cb7b79f579bfa93e3a354edf8ff5bcd06d737cea9286bfb08cc144b3fe90075e652321389b7e536db87e93bd383b0ea19b7358464b2f03ecf887518c46c2c3a3ad6448242c3dad2700b42962c6b9680d389ffa6ffb0108510725d7603720da197f138fc1724741a13d670132ccd61c2d45fe4a9c1743027682c2191753eca21d4254f0a7147af8ba9917fd394a0e57a465755e55f1b4c5c62e261d0d14f945317d386698d524e7cb1d0f99890ac11e1f59fb908c28c48aff194472fcaaa0a42b4e96b9caebd9564a41b95a1ba374eea0983270c22742592df5fca01e6c91aa903e046e19b44483977ac705c90c34d33d4d4ab89114b9bf37ed8b7a0a8770e2d16dd52d0344a285b3a54f69560e46714c765295704a3e241943bf0e15607dad9e93b1a7943a4e2e3e2f447fe874e810e4ee53445a31415355527aa4783e6eedaa4cc11cef9c99f402a3f753bc9a80a51e2208246463504bfe1ecd60686ccfd4427a01d3ef8dbc0a79604a79f6cbc84c88b5d1b10c6784a437605f86633a52676613d727f580634397cd2f3b6a2b36b53611f1b1cf166cdf4403dc3720102f9beec00c37af9ac429acfe721fc3ad02614ba762cda0ad9f65d82129b482256d1ca87330d94144b891976951ecb415889ab11eda90a9ddaaaa1683672137bbecba4c4cf906e53adae6c6c5df628db3c2bad1d33b3dc15c65d8b7845c2a3293fef4ba92b451f75bc04a32cf0ce7a8d87d06354bc1a6488bdefc66229f52697f23db14fb976e1ad5c4f2d612d61542b87a0bc2281af7440798d2f3a85f22ae032a132271d72ecdcfe9f2ba2fa6fe0de014e663092e38cecf267a169c6d058e65ab52fe115d629c3293f1bd025d0f5fa1667845cde1c4b0d2f775673509946c02cdd68a25a1f3d24920720bdd776d64281fcc98c8f7cac109d51cb5193030e9d693096326ce9840a09801f28e9bfa15fb49041cb3b4ada0593e8de7881d16afc67f671e9d68ddd1a2cd3c2512f7a31993f7391703f8849790b002ba1d25e26c3e64ee491b7d33d84079438c509ed2f8453ed5fc4196d2f8553d347fd8f30df110393388513dc0c0d5cc2f1e5589bcbf2642a03ff9fbbfc3b576934f3d6532c995934c527498183d384bda68ee259bbe08ea27399a5631200ab205de349e618c658c5962e058f5e7dc7a63c7ecc3aca8232430c86e610f1a658b1afc2186dbc73b52376a28c9c14eaef79f5331afaba2169bc708cd05107460c80e26379ed28f6f520ae037425d71787780791a444438da83d81739556422117b59c75205c30762840545154010bbd843da886e822f76f35b8f203d40d46b594ec0e533f04d898ee7b1f40df75f2c41a0eafc28d774e185b8b7e75993d6acc52cc9df0bf9dab29db8736025de71ef4fcd4a39639975f42a6f47ce5c5ab7599e100ab341180d07549da955405fc8583ed945578fba6aa2012e6ed26cf09a1fdf37cd96dc5738bd60cc8a13ee12ad86dba4f29474c78a16f18e98fdc4cc5facf999aa9b927e1c8f14a6aaf55c47ef76078d9c3e576c2f70736f45037fb02dbfd5112c9f81bf4e7c8ef84b58f2cdac3e78ed6d4f9e5de3dfcf7f95fad04356a159d13711cbc69e8f07d4430adb2ed1eb2bac20c9c678b4988e0bceb5a12e306112a111108022539672ade5f680fe3d6f0532fcbf27c94ce54922bf4f16504f3e55b22a76827ad314904681fa5a4a5f6c4500df2b4bcc75f2b1f14a74e42d1b233804c61c844973d1acc613c63c16fa4239426007ecfc89d8202e125680ded7dc38c3d6a79b1c24c5b67a1ac4011f79259915de34916e48fbce0e397d8876959d4813244f7d3673957a7258bab8db94c780044cc03026f570a9f78d74b1aa70607ce89635284db1e5627ead83942b1c830a84e984326791092bece7bd2edda21a5e90cab9b7fa8fa2e4a899bdba9f8eac863939b2c5ef0f362c29cd09b500e1714ba57a9b7295b4991c09370117aa53d382123d0ff513cc849413d7a086261ab16afee7c0b51778d41d53d4244c2271c0fb3318ae71017f2de5bd251cf448ee0a5ccc4bc4778ede9260dc0839afbc0dc8416739ce6b1a20e05dcd519995dd7c2cec33ef96996cd85fbe365ad8b9fa07673083469cc89f1486f80d8b4f5ad74e676fe8fb05d0ca6602af994ce36f710caf3ddc5422857e97b1deea69f661affa6b514ba3f573b76961425c5325e4ca48c8d540fe50de969dd4bfb5cb0b6a4c8fdb35625587ea4b44dffe53ab40e9be12a5faf9835a05ce83ace719e8a5359d6a8b903b406a69b30781144c9ac954781ae44c51c54c873af5ac2697cc2116dbb609cde997cc7d2677a5be2739c1f68700e4f734d0cedc571ac2072092a319d9ddbec85708305c9914516133061d58921b976776ab506b3878239f3d8d6e54d9ea77a0231192e8832e0b3da1eda365618ec185a5f823c0203031eaf46e6df5b6475ea61f088666bf762d8a13a24047d2259ae7b5dba2c855e9bd9b1bf48694a4889f299cd8d981d6f761bec69fbaebe9230aa78b689eb6531675911f79acb9077433e2478684be8dd1b8888ecb5fd16dceb8699d8abd705268122328a6e3e18429beb7952fef9c760d3082c4d47993ecbf468cf8e1f6d5d38f51d4e129c93da180d7fcfea56322deef99c1c0e89d1a3e4a98254aa89738495832e148d12fcf99f859165932e4155f180d1774dcee4fe3cf0d2db32f19d41aa1ea6d326f2e3525827394adcb960640c9cb2a7716e2f2cb0bdbb330a88ec95c68a08b0fe0d7cc18c836111c72e9643ad8c860ef9b9cd73ce16fb5d2aee27914c38633954a37b77b7b79cd28297751a21084a5215d67530a9d82e81ed52a6e76da2074ff6fc5bd5afdbf1ab878b541f600eab6b777928e42a6ceff25593ef67304f35a45bd4e48a3d9b0c6ca373c745eb9992475670ee1684b8c7a62c725ae345f9eab3f87fba5d376bd181ef249b9e6f9f21dab071356c2e2f4a470a85874f48820edc85021af3c6a2b0e8096bc642f932e84defb4facc8161165967dc2462242c84e0766cec7a0be7717c4ad2234dcedf346343ebf99509622871daf96198117adb739d69448f1e137fe784c835396b7c0b49d7f0376b42918e4550b54c2bdacf4d33aec869cb1cb383b7dae2ae035aa4c74df44046526b339d67fcfce58f529fcca196dfe2996f65a206d446f7acae4dd3f8f3a9109fb3c7a8d6bbfbdafe201f3ab552e86a9a16814c3be4beadd6af0bb1189550bc490e1eb5226d14d639cad4e5732ace6ad96f6ab160cf9ef08957c29875e95aacabf412bd076a26a65ebedc81d4918399750371a801ebeac48ff347314a83650b46b81cf6f836306fb82bf3f4be67cf0ee0cdad5dc24a2b7160a90b0a241105c559c4453266aa1b9fbc02b964ac26cb5060d84315206971156e0a3bac46197db52c13586c158a9988abe96f837f574013cb74a7d16b234b47e4620c5d82490b2657bb55898a722eb5261b6559757c1a31e2bc34010e852e1d062f094e3906255afa8d7bfcd4a3fb802a04cc3da416e98b64d68f272b4ce6bfd71706a8cef1a75dbce58b19edad31dc7b4921e4a1e815e0e25db088f07b067d5c661e3c62755835cf20fcfe3145d6e9d90fcf2bcbd8da72eeae9ffb63656c91b30892128c8869b148976beac8067a2c5c63344a0d7e2f4d8ad4f1dc84f24bc8af17e8a66edc5952e3242b9e65996c9480832e21d9766d9458eb5c9022ba5e2bb9f9ae73dc5444daa871f938e1a9628e30cb38479269fd272e5088dc2701a35033dae0035610b6ef2801bb264f0ad4b585d7b0a418e443738d948e317687bfaddfe13ea1abd15909410674178cb533e8ee88116ec98c8997e5c351334755f888b50c73bc3b3cf16e6ec720b90573c8e08369e552a3b7db90b25ae112f8d94a77a51b3f22b5a34dccb2c0d5fdf7cd76499d21099d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
