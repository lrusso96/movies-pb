<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7010ba833be4d58e32eaa3e65a50775a6449d0ae1af02113a36f74f326a1ade936ddcec2170c0f6e80b627e0cdb156f2fdaf3526d33df694b762f1dcca9fa4574650cecec7ffe581d37335ab2fde784eb2db07ec04866ff97806ba5064205e39cf8398f3343967b0c5a6135326ebc7a16fc17fb849e1c0152bb72a248a9272e3a21a84d50b732bb4344473aa183bdd16a1c67915a2488068093b4eecfde9c7cae13e1a0516546867e700a099ecdee00a42062e60ae65e329b7b3e8bc99a3f23179b942e68352d98611febbf1581231e617ef8e44dcda592630a0d26bc47059bf7879360ae6481033ef10065ecb762549b5e23cbf9fd9eacf3a2fb74a020c8be8ec49a70377f563c4fe94cc45791ebd808f7fc5a47595dde4ef3b6a754e63cc715722c572d5028f263d74bc713ed19b7e4adc75feeb4714cbacbf2e3b34e2fa3639013959b5fda91f821522ca6cc7509481f67d62192483436244776053c9feeb70cb68d23477456f02649cabf3741c689c8b0d8f6478a0767c9d4b1f5d3be16f2fd1dfbf8a5f5caa6776c7bd1a78fd0eddad71ee18757d183de9b382716d82d41cddb4e4a05908481ad1610326b99f62564a46280b7e6d40e16efd9227c46315bb233dd3b55b7a8999d7fdd97b5944c6425940048cfdfa032c725a631508794111cb8b9a605eaba51117b815d4163cf83df892dc2c0ab13c79dda72757019d9ce47ac60ebab52a52f4dc27dfc89c10a933d3de90c98537a57c19ce7c7450e588eb0d5282a613bbd867728c0115e6d3f3fd071e225a21c4452a662f00aceb10ffaa0a1464b79360a05e3fdbdf1e160d404fe818e2a5f96411dfbe2f27480e8bdb8e1c44508170590bdde2222f64dc0f4103ef1749b8b234657acd95d29d52f0a92e90bd3c5aaf7d05267808d283df70354bbb9c9d5a9206425a742e8996ea9f25014748e083fe6758bae559b4e4c10f1390ffc8958b7d838f1f3bd02f8e2bc1124bbafe6610153a93bfd09af4ea06ec9da84cc8864f2dd655664494e7e12a176088266b140a14c7a388f02a5f1a18ac889f4586083d885c146dc089e16f4aeba0f2fe89cd2be30d825fb9df206edae6ffcfef539cd59303e10d511c7db77aa962aad797faa327b5d1a850bb4e9b6b23b15459f8f6be81502f89a8383f59fdc81f098b1cb289388e41e6f9613a2c3d6a6ca7ceb0bab14d5dbb51f60033a470f31f09e4c890f8ef53b3be728d07ebbabe9f60e4813fdd22294e267fb908d01692883e61d6d77eb03e309b6110d194a94fb87f1d6bc3e0d3fbb5b02c12226a04ceee91a118452d83021d9df962337fbfe5112e396daf0a201b97ff0f8c15684d873d691db90a8505a5d2e3ee50992759800b3a4a1c75bca5434f34d49aafb17fa1d9cb3dc4a0b3715381ed37c12c2ae4f87911a0fa48f87dd56eed45018827910129a628a72770fc45d0a29367d66701ebc8d0ee0345d9b185e293f014f77d7f420db07180359055cc9da97fcd78e168a8d0ac0e9eb8833f920e5a8ff359792134435bc9145db64dd6a28b821d4f466b1a1a81bbac6664e927396accc4627e5a5c3a1c20cb473150d4ddd1f643383f00c766b5e3ed3a3574709d509aff19430fbd369e090764d5e350a9bc6c8ba404e5073441f244c7cbe502fa9a89a263c1a7ee168c69b57a142e4ede271cd9dff764259bde07289b61fadab611367a611224eb4a0acd327b2c307f44ab002868fbc76067442a0eefc374ed6d2dcba42c2af53c8b21b3c8a986e064072149a80bfa75d9eb4d92ece7f0e6d965ac529bebf4c72b3b55a0b443315f693475629ec914ae293150a0577775c163edd909c8e3c9881cad1d10de3bcaf1a88a8512609489ca41c9971dcdb6d612f210c71b7639a0904cfcf5c25f5a47739346a81a0a1e1da6d5821d45a0d5550615708b083d97d308b07f906e2b09b09b79067d19d4997e69b026dfaebe7b18fdcd6a87412985b3dfa05dead2c81ea51f5a171575bb45e6eda72e2905d1e2450d3fe5a08dc02b6f350dbf286430d4f5a39ae3c74d0425570cf96a6dbfbabb5bee91a5de377071c5443ca015dbf25af300aabaacc0676ae083f00ca5ecd807a9c14d116dc721dc50f2abc52536208170ee73b20eb50290b94ab7bb654db2bb0d1c70eb1187b21a7f84020ec9d702d4c76dffcd4e11cc46e62c30ffa918df38dd6b97e3bcc3f82b5e7664e9295d1433d64c468203f02b4ba17fdf8a910ef9111b0db55d2e93fcc671c9ef9166eaaa8aa9cd9fcc85f65836f5b7266a4b51b5021c886c20115926733c62dbee16ccb6fc50794455f51c750e84e5f9b01c65a118d58f2d705c00926b7487e6a8595f921e3e621446d77c88c814e299bda16198f33ae571a250e5e12668d51823d8305e8838bddb250798e0dbe9aaae9c57ef735609715fc297ebb8e1b09da8bd72178f0297734a2c2c2423afbe7a55db9159823bf6a0c3f0e696e277ef4e07b80a579ddf3c289ab8b021b1118a796d46ca0b56fa8eb9c9fa2586158ceb388a40b3b84ab595c617b2942cd0bdb50266751e3094bec4abafb8e4e8b0acc072662163f0367483937bd3bf764193b6aa67814de29721c1865488558e883c47ea80a8a4485d3ea42d03a6edef365c6e5a19dfc1a012187d4dd58e5432df4a78a8a1bcbf6aaee1e11c86838954cde3e0c09419b45f6dacafb19c2d9a279cf178f8f18fb61dc443603f41ef04307d7ecaad119ea4f18e5e345ffd1fb28a2188e9c4f49c5c4d6d53804bd771b248967ffe47067e8d631cd9f3797de5bae3c0fa18478cca3683d8ba74444c86a34914e7fd8b3039ca59bb581302b7b497572dd159344c8d67f4ca3bae10e510715f16a207ff28558abfb81d7d289942c234bddf909ea992bf597cba25fa25c9273442c9396ebe2d181fe40a2db6df3ecbfb2aac100b993e56aff317223adc5b56a713a59a14de57f3a6fdaa175b8d4e52078f5decba7389671e37430289b3f487ca4cbd68a7a490cdbf94d21e58309314e98cb04c10f9cf1053b6e836158cfb3bf6a7ca31168596b74782b9e1240315ac7219253b89591f8463fd9992387990c8e27fa2e1afe664d0e8a6c430f40096de7cafc72290cf67226557bb9eba1f40854bcb7ac54346ae1b22682785b4a16b5a115ceb720c7d0c2b4010009791b7d88726888c74fb35074d8c900c5800fd3b93bfb2678246f53530836615ec4ccc4cb94750160121394e450e981d7621342fb378729de73c9ff68c81a3f9f98fbceaa30c552da0367f7e202ea6e85b36609967b5c5b7050661beb90e13f2dd6c4bd63f5af36187ba13929ad36e52ec180b3e6707f42176b9ec8d9f74b02a092db9bd9408d16f400f82807b9b3a80bcec43353dc7e7a513f1feeb47f7c446727550dc98eeaf8f3ed8bc36214536118d6e90db73c20c1ba85805391eb4e650c61ec445a197de6f6e78c32e4249b1dff5f9ef5bfa4fa0308f15b9947f3d08aae1e3bd2fb455e8ce942696b9b55a71479509ac768ebe784f18a91b1e8b15fc7ed0af0e136fb1a131dbbe4b42b9ff8642c740e02001ccb4d5f9317dbd32677580d35e6b2f06c1223a8b0555dfa5ef949ec499902aaede54d962d95f3c8013bf54c01d9dcbff4fa965db85fea769b34e7dfca3c56cbd78a435239bf4e74eaf8fa611679b9d005a7aec193d5cccb388698302a121e8a8c0589d484345785b01c7af7d09b031d19ea757b8a3a480a9148d4a9980419de18185b472a055af6638a9c8d275ea870b7c11a4e98206dfeed53fb6516ac827d0f425764d2b64dc17b30cf0534c0d35c28c1aca899d68375415af9bfb9b576e3d2bf3db94cf48e7efa900a686a85f46d89ab5e48c2e75c4f546b81ede9733be03e69ca02bb866dbd5191846322f6eed4e201bfe098a89febcb0936bb02e2ee7d2d3ef967db8f7c14e2b7fb3d7d00b2b6fd1a8d196cb4c20e335e4c61ce64f2d33bf5c7dcefedb4acc30553c4044d13f00bd3660ef5c3ceccfbd3be9f80c7f7a6bd6246ed8b84e753ea1907f619897e928c3b778bd14e64f1bc8b4bb3401fc1b1ebec0dbb554ddbd33dec6d2db071f0680d3d5eb2f3e505fb3484650af9ba1730ff26a645f6544952c0a585c8b38a2985761e40ab2b4f5e45cd8ed7e5270ab5a5a91cb1059607ba34dd81cfbeed96fda7b2aa3146f5616d069fb895e84ef28ae9c1427e6396ec64256fb90bcf456269585a4d2b188a439a3d42997cbb7b07397cdc906eb2d0c8862a99a05dfa341a9aafa6bd42a08ec95117a6524d0347d849fd75b2ddad6f10506658d1c921a89d72e9d6af9e8d26449b3893e457247a1475d467111a852ba4551335329d2eb45e22d72bbe52ec345ee105003a0b66763f523b56412299b04df4d9f2f68ee2e4705421a66c08bbd5e1e272eb78c5f8f5047cc2c5e3d54d26a749bd04f6cae8940ec40e7b13602743e2b896642b3b5613e28814b1078f3ec1630a1a8b969229529687254bb91ae96069194dbed5c869529865d6d3e84a0881db6e6dce69a6ae995b870696f54a48cc5fd0d03af2b517e2368e9b70c0004e5e3322e91063736e1972664d4ce41fca5c6c7f2628cfc8d101ae36becfa2a0c3f4783b69f615d0eadc55ffcbfa0d45cf8643f303fd38b9722ce70d2fd561e39755977b1df58b8337fcd1560582a168b69761a8620807ac106f491dfa39606a85e0662a1f82cdc372281ba67e6ade6f2958ed5f2483f3e873bab5b9dee76415df40af44916ba8219fe9cd2acacbade50b63b180dc62a044e72ebb9894610bf9546d57644d240e44ed87752e693d2cb1127fa5f4f5ccd11b289430983f11438747934ffc4d363c632c77a2cef8182a096cebfd3b534498675d7f0a5fa5549533833aa543057273394fa471f195cce60c97531026e6e0f8b57b3568bac3198f80d2e507cd3b30ff7e9bdf1b20537ae896df12c24ab58831e73a06b8768eea88680abba19ca346e3cdb9177956941f4177148d262f22471181f20fe0f0a89710a0f48a7519393062c314f080a4aa46a7bcd804930fcbe00213fbcb457a7d5817bf42f1c027d95952a7fcc32a6d3388439dbd31a4ab1df9f381312772c90e1971b3fabacb46f8be52b4d0d2d5644abd140ab1a6e5ce102e70c10a1111a69e62cc2b1642013b0272332b487b294f5fc39537716abfc7d4a5f96125a0292197d24cff9b4f908d43b77a9364a1fd8c1d833d08f4cf4e4b314f8e1e62b0109b7184a3cc7aa2c9596feb68332d869a544c84bb01ed73b7ddc3da3aeeaba232ab7a8d164736ac2b9e1dc7fa4685577d99bc49f67291eee8c155f9df96f3c361c4cd866375b9141e8ecd1d7d13a7d05f9138fffc701dc3e8efbd7db1e34cc5236eab5ad2dae98fd3d7b4bb9c06254c501737437b30e03587f04e0fd2443bf3f40d90e291a10e5d8c64a9b17a3905ffecca055aeec0479a01f79c2f83ac77c5c725f2a4db6c375c873fce0ea668859e9d00dcc513aae38ef4363d08f76e846feb9f2217ea69594aef0d7535bbcf58621f5aa7d2d54b3f9d4d506964ae783213621219c23e26984f370c682b1b9499b1cc5bfca93da06a86eb89cc1879deefaddf3b75d8798c44729424d6c693f585b6a73a48536191a3f1925928f08bbb240f7c474dedd8fc758b6b93071182278a1272a8c192f895b6b151043ad801b841c41990f2e704768f954ef828fab15eb5cca4044b72d221b8e7ff32fc720ac19bdc08f35b96e07274a345a34ac48233d6257c1345218c4f3908087077008a857c67476b80764b4849f9b2185f7d8244ac88c15ed88ae0f1592c7b818825fafcc6ebc29265c8957f454a573dc54786e76c254d926e2d6341acc51542a031bbd5c25623fa5c9c57bed41b12eb231decc766daad819a6c68f4c2679f8effd255ef1485cd64ce83c86135975ec1e745734a07da1511570576a0e94e10b7630cba17d632d79ddb3cb9ab20b22681030781ca7c86e80a0daf1e15dd87ec4e0656c9e0ff08b71ce0bc3801c9f49be5b065e1f77503d2afad19f3daf8951a19ea82c5858887da55f2b37aa43b9a1d8fa25695f620a46dd167ee71d55d478310f01fa75af2fdae1713824e405e19a17d73e41dc72dd149fdb9b1cc54586b8bae918ee265490c03ab5e0bc0ce295afcbde8bd7dbf909ed505002cf7f0cb90a311343a6cb733fa835257a3ae23efd57c4f05bc06f94ae8960cd6c1d2d12060cd80667a94b8d45101c33f5e195596fdf01e4d54816a3e26fd19d32642d3325329d829d37c0a3fb6b5d93310911f97e049b65e0702d88239e2db3c84b3164d777f6a530d08161d7e99d3f8fe2a577299cb348e02fd0e132f8cacf8a68f1e9bb5ffcfb90af81243862ef01feaff7bd5aec1ff99fcace6b71c88fcdc8f7ebbb099d41ad3f6d69056a28b32c99533fdf1610f46ab806706720d587029f5da592128e5a3cc0000ace5e3e256ba93ce32dd32adec8184b4f019dcd7ddb7b087d89ebd1f89401f8b9195ac9558e63505e2abc24ccd4643ea25ef16e30d38e2ed90d16bad9492dbf3cb2156fb7179262fa1277283e97452494ec9cd6041319a6063944aa640bdb47a5fda2909754d8ea4cf1fe31781bd481c342a6cb057dd79126af564783563c65c3a28e7fb486068bf7ff7a685b5c7c64f86327b55949602dae51c0ed6f00ecec886d54df739361d5aebe3972c2bde478f988d6b7a93eb5f833da52601b56ddb3a095d268df3b46a2363ebe9b2bbe7507c468967499e1a74f695a42401a0697a042938d4fc71b37d85da9361c76182d2c5707517e50535e7a1de73d1b51c790938881c4fdbcdc602e4c771f18688ece3e4cfb6410f7aa5c5b46cc431eb72227653c1390b8ebee35129337632202640999bcc3e924b7ce92d3d746aff00cc41f4579c7efc552dfbdfc241e2a8d23659b4444ed42e890240fbc3edf9219320c4557bac547c6bed9d5bd197850489d74b7adc7d3c8a6e9f94a8602db3e0046398f58ff6fdbc07ed19157846da9cf5c195478005ab829b7aa00468f5916eeeee4f40415638aeff0de5118a98115cee05891be4564db0c82a10159b5687d6f1621f0b715a8a7e81374ce9839b3030324509a73780fad57e9b7d683bf9262f82ca1012d2c15abd5e69f2a98f44905bfda575b90f8b2369c84b1e6a6ca75ea25de5bcda4c2b925fc09adf42fb5c390e9222e25c3bbb498d0c83df373b7241cb194471f96609acdbbf743400577514e56028078d91cb49300ca7df1f0a67902ea042178ffb342cde42752b9e6977568a4d08aad9c4d65acb92ab4e8a424f53151d043f0804c49d4832b802cb20a390b80a5a1b6a3edef591ea7cf70d659fcd8e1f1967386cadc1e0e0e0c5ed1729294cd4082d5bc2edff219ae144b52ae71486a31f75af66d30da15ce4ecdaa377e3b023918c401cc7a5d4936ddb5114806214b7d4755b0859d62848d22571ffccc7fe5810c96557c16db02020b6038f59dc877b1b2c662ba8437983e0d297410824c4cfc3377b8cd7fb7d4142d197a72355f612fca7e72e9ec79062498ae3e265967856ff4d628b63e662f5a5df57d42cabf45c9c3412f2ea24706a83892f127a6a8227cd78403029e15f721640c233672bc8bf44f7518434e1d131d4adad066cd1a57a3272b3d8a49e01e6cc3a5a91723b607ec60ebf688b74647edba5e944e47a4d436dfb27aab9aca20531b229a38dee04f16bbaf2276a3508a95090ed0da50a34ed9cd1c4170ea3b557007d66a91b043c3e6b66352308a61f31b4df7ca758414f81800251d9f6d187420a02d75abffe0f50066d309e290d69bc606f90dccb30f9cab56ae28d2a6cb9a1c895020a75ed2760291208b340edcdd08e18b8d4afb4107313006d1bfb80cde2ca737581c06f9483e146eb62933da4a2338713371d5f3eb23a06ebfe98655e23fba57bfecb1aef3f395c58e512acfd2bc6a6b8556c62a59f23905210f7e9d695457e95e19cf04987ab0a15ad55f7d5198da791b34110765fd78a5d9b30a050692364b95fa4978d81882e0e4e177b18b7657f7d4fb788b950b8e50158d490e0a3401a4214f74d4050e418403b36adf0a448261cd86cf879cf07078b18a5557f2611961d034d6346588118263210bb3eb58a6886bd1cc7bb2de136bca490b2b768aaf71b9eb2f99e051a9ccc8bade8365a3c7707da528aaefd15bf2826c2109479954c4d83ac6150090f82d8b7e3cfaf1b75c095ffc6ee97ffd14ac133c1bea8adbab7b716cc72190f5b48d44f9c9f8bb8e9c0607724ee36910022fcf24063cc3dabd12c135fb2982172fc5cb77a4815d132ffa676d68e5d2d2030ae96b8f6d3968aacbd27fb3ae4bd3f2dce779d90772277948898b6258f9412b0b02ef46a3f626285570dddab75362e23e73fbfb001359a68c3f866e5102e0212438be98f649b9270514418efb0fb6761286dff042f3ff72929a9a9694cbaa4ac63184b90ce48c5adb849cdb8dd00e444d5ce7f50b0db82b8431b24b1affc9b1654e2724e43c2581da356fba8a89ac06bacc5c2a2afd18071b9bf6cf213281f77f88ea9adb7b2a19994d3d10c78994118e610b2aef2af669ccaac1ba5bf877c971c625ade68cf1c3909c069e7c6d90c34203c19128cd3ca667917c3fa08e270bfeeef969556e1600a4718174373bf982732ccc8041411dfe4a41665faecf56e4bc7e5b22c7de0375fb42566a0089d6d9813ab25277126f4f8cdf50d5637a41df7c83ba6e2a91e3c2114fb983d0c95005dd35a2094e1d62c5a098c0a900955bc86f75c46df9802459a9b30d452e7ad2eb639eca81a2113d36929e698a8625268c047d7a3a37f05442ecf3ea0574a5f9c5ce8926ff89a1efaf775a06a63ef4fd5ec757d97bbc2f50ec455ebed556dd5f22de8c0d6aab29c23ba2df879b49de0a14d34e0d9e9faadc388e68e0d1177330a2399b5ab2be2f153f7b73e226782ff1c802c7e98c8e5b6c1fd6f71d6fc3ddebaf045e71c90aa1d0de070fdffe562e0092022fbe3854033d6a4241bcf7d2edf1d2da48653fef068fffadd3147aab6b686e10d3bf69c90fcab741d39211f6ed5b127db0c7403e6344c22293a456247f726133e24aa8fd0e55961d5d3e339d001014a7a8efb0a47ec308c06e9b8a2c4d6de364ec8134ff69b7435243f2377dddf80265f6f17e8951611aaf0b2122936775b009ea3d5dec2cd87cda6e667fecab3e73457a2f57319c217906a0694a73aeded83d351ad860a36dc8339bc19d99e98ca5c78ddf5d7b541d2a0db1436a5fe6436ebe57282c0b05df4cbd9eaae75eb73fd0626d4855d846db0720b76190fb0d27eb82429be1226f88e382e2d2b94837575f921a6fee5cd766f905c23929c8e6049f0979eb5eccd64740b7d4d11775d98741c155f12dd54ae928894ff5efef0d86d5a9725f0c94726bcffe16b565ffed55338e33e406303bc9819e59ef5480b97a3e65d7f57abb3789011da0529e9956e504842ff65d7f5aedc07451f77a0400a75752650e03a9e0e4a7ae0c5ec893a4e65597f66e772d8e2b64569b2413510c85f44e4696f897cefded36f469d77cb90c3a32ced5710ad94c779e8d5b4a667af8efbfc7209db289cec412bb5a390fc68ce9289c863db4ab71c315b92a90fa91610be199048399a0dcc131ddd1ebdca0f377be64032f104449bbcd6c1b4f156b0b3399f3f0ce0e6a347a3b5a6143fcd5e212dd0a49cd520d195282e935a786ee870cf6fb815a50a1ed1b13b59ad774e2dce5f970087ed38fabdbe66c9f5aedca2bcfecdec83e5a6d8c8b55769dbcdb099bd1fa8022e949cfe4263c55f387f056e94ec68bef8adcbc61849515f0f417bb8fd4f26869e746e4a02a5a60ac17d7001cfc7c34e68a428ea03edeba283e210b4d5ae76b8dc2ae14ba0b4704a216b9a65788f8b244c528e41e29591c465ce106c55c491a2a5affa67b57d7cc49b74f8d18bd180b64456b702a9207c0bbaa8bda950fa292e3c49e8f35475e8591e19a56a213610ff6e97565baecacb8cbe3792079c27d1e6d586ff3718d26575dd5c7380191537dcb6b15fa7961b730a7a06569d560e2717c68f14f16f96bb49ac4c2915ad59f72f0a4f067662890daf04dd2e9903d80342c17f205a2c63019901042753d6df0dd3a737d26c384282b85599556bf13c2d93542360390a337be0124df32062a4992fd852709981d4cb076bcb0892af8504e57992e14d1396e88f674f72b31d63d717aa562382e8e67dc3c53a9a22242a7d67dd548d5a1a1262b1d68eb48b891af1b2ab7c6cf35b6837e3a557ccb863a9fe69b16e4c9ad7ad3d24f3177289220537cdc2f458d9dacb9f923782257affb067365dbdd3e94e2c6fad55a6790752037e4d11a21381f3168595851ac9e11408c3fa3d02697f942906913f6025dfaa2e9637834b9391c015a86839248bd6922880f884e763ef7d04c903c3a870a5549a93b24d4ce996e5107bed7f67d5f15ac2a3f7f6ee5c1510de9c929d15d7cfdbd2a50f1bbadf958af8e37e355078dab5fd09f7071d6fd7e723428a6a8ef74109ac839ddc2f758531660e64c328501c90e13ec1e8b025da8b38c219a5696acb8852d914385e204df6d28a1dab865abe36e85f2e413c418f31cc71cc31bdbaf9f1493216a6913c58611701eed4f6c2c9144bce56ea0c33d4f41356e29ec4f34dc7e095c64c988b973677e976ab9ffc0210a6fca2b7d2323f1c6dd9076474dbfca573132e388dc7d89ceabcd04c464eb0df86edd41da9be174dd8607734a49166328107a6a3b2550949af3df956e6f1fbc87931ed2166df9dc8d363fcea6bc6f6297e85e8cf0aa57aec4170df9b7bf316bd4f9c31943ffa64770cd4f6e91f5733ba8e27ec9bbc59e4a1915924282ab8ac0b91a6286c24b8f669b255484da3a1ab05fb485b5d2dd14b190f114012be6fa473e4ffaeabad71ad3400e1391a8a51d996e975875c12bd921509fd050e7b4098411fffc5d300963227c5cfccd7039e4f786b9dd10e4b2f1e0286bd2c11c4d126462e929acfb96c7d65402d922fa25300425e257b8946ffff4291fda3b7fb1c1fdb25ee6a4d39c7de6b35144bdb057a101116844449ab206873f977a3ff5a9976a88800ee9ae8485ac648dcc7f82cd54a98ce0c33b7501446b26b87c072880e59c1a5c7fec10c9cf8035127a7f273035acd874e2e5b7e9bc2f154617f3c3684416443eb836316b92dadcc56a6c70ac6b36215201cb5821dae9e1795804a767528cb878ee36f8174e4150d4cded668132e8444d5aada9ef2c9bde2d77361c56ac081eeed11f432724fc26ab744af1774ba959fe6156309269940c0a0b76e18ffc07a25ffbe02603eb51b4b59238172eae776465c927583f74ca77c1e2e897cd1ecc3c9252feb90183ffd615a11c678166e21b83e9728a073e04776f8a4e1a8c8ebf2e93f536975e4b16b7eeb85198f86176c4f5af01d326d6f145dc460a4d78d784b5424e9a92838d3322490b741604f0c27b9d256aaaeafa7501ec31d70daefbf613a4290301692f16a25baa3f60547258d42d781776b0914754e9e79b6f34e18bdf33c10ce7640e14f435496fed84f95b3abaef88608f4d22e2151f73b00c463785127ca0aa86349a0ea29929acabff2b9b20f5f5e341c06281c93e3f363e7c138628ef1601323a9b2c5c73a7b5430402ed9bed750a6e4a3d5729a58dea4f8d601d57c439a1320b004e94b3db09301995f1990b474a47c328c7ad33d37c0079a97bb436e0fceff0eb24c6eaeb409cab91eac6985ce9624be9bfbc3ac2f2b7e00d39196d29287097b74415563c7928f796e1b4b947485d66e8966d7223ecf3668b55f4ead29e2f2b4485aacfab7593642088ddeec33bf245a985a0e37b6eb3ccd2c98f32ac76d847f3eac4c0c68ecb1b603bc9bbfd9a4d24dbe6393b39d6b2affc1ff19f576bed18d5807844adf2e2bc04839191e3b466bb979c9916a7f219ed4911cac79ba1ab725cfe987079a3bbd0f1d42a745e8b761c6d6f0f45b7d60dd356acbd2ad5d8233098ff173f53cacf70c620f0770744f076ef78f925598aff10a88843a0b44055430b90a4cacb08a9407eb4469320d4a4863826d56ea9b8abc4c5a957f9669c04683da721a1a0b1fa738f2c045b77f3f809665b70349dbc0623c29a4c051a5906917e10ada6399d5abab29bc039cdfa567516ec83319540b2dff539c7b57f6f348590bdcf310f56f2931aa3b7f5a0338ca567d8a64d2c2db4e0d335c3eb1ed048b3daad3dc93ab2e8b5c8e4ec7cd685bd01205af9cd069778466119509fd086807ce2e81e8018a89fee4b8b8d39273ad2c0daaa53fa9e11e710e6f348f1d9aba1c88bcc80ac3168b5856752e5a4bb99eeabcb0c6cb427f619631fcc2ddc13643adefeeecc00a7e05a73716589101e8e199e2fdae05b57f996c29ab36081f22cf1bfed0a5674f5698e20e6e9c6e30172de3fded87a8a2c9fc515bc349a8def0a2e787790cddf36cb24dd130e7d786a7ee2f8c74c2682f7c86c32045af4302323b90004e0f7648059178a33454a090c9b7ffaaaca8c66be7e6836fadfe1b0a2bc44a428fad196ff35dd9e85fcd9b6976455bb97e7bbf47c6bcc5373ba1610d4d66005e4dc4d18cb6e1be6b361064063066dfe1018708d3b70b91d92a67a71a9faa98ee8633551ce5fe03f04ac7135988b9aaf3891bf1c19a2a6f0b102d3f91a4b8ff07e937a3d2f340f841207bac27181f12e78eaacae198ff22f21e9078d3230d9d84545c0ec10b46706a6407584339576fc5b3bf7d9cc62df3a1c525e9c331b84018c66e7b4c22891c7c0631898b81341a6a7835c32fb47c409f539dfa7852b5b3d7194232395fa7ba4b758a03bafe018c5dcf304cb4ff697c95046a946fc0bb5d87689d6293e231b548faa75d0eb4a66f6e12ec4a8e324944b6e95","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
