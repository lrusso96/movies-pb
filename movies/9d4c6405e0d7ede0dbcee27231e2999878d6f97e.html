<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6bd2676b594c3028e6a769f06d1ccd18ffdb34e407ac2800a5d110189d53f3a9e318734385a412a8b64d6a29b350f6da90967a090e2225498d0f4a5fc88b8c484100931d6d373dda796d6d029a34a1d0908bbd2d7ec761270d30d8eccbabbe1ece802d737ca0b04991900aa8121a1e4ae0ab229a2298d06ecfe4eea370c9b18737779a756049be58c0f6b85ea3a9ba091647fd621d8ca9b3eb582b03743705f88666b2ec59c9f54a8958c64489801f727ae359b69ed4a41b806aa4ba31b1938d4b4a145257de1d7f3a922a375d66a6a5c5c320a2ba250e7f182ab5eda916b045cf52d1b557494f8e4b05ed6f890cd6ce92c3fff1a9477263be37741d3643b521d1101d78dd42f2aff196c6ad3207a6bf418a2e49b1402eb972b61b1dbae504a509bb19f6946aca724a5b36d36a938e6b69dbe0aacedacc3bf6815282ef5a47aac6603302613b699881a96fee2511e508f8bedd779afd136ccc932ee35f4d68b46887c215abf1a0319a8bcff4bc455ccdb5e8ed1afde9711db57b0c13eade90f06720e722a82b42e178d954cdba225ce45f3c7c99b98a4f6d964f2830f7987e7c06d5d7728f3a5035ebb3a06d84de4488f3dbb73691c32c52fb5b363dca7b0432f2ea7e7103f72f9ad18848a00aebb51e62d03cd92bb8cad19cc7f837d5b454a41a68a5e1a7f77ca768a00c9292ada0e4f27b4a34e1b8c9ec7afc9f34507cbdb1e765726e8e3d130399e0a5ed1246cddb3b8f83a5cd206e775d82a36099e9300c993bd3d925f6845ce1468b7308cb473b0bf385b9f01c393631c247daf3315bff0f6de11ac8b20ac6068415ca1ac7d6940ffb21bead37c2b3ceaae10131ee948b86e2c241d074fd6ede7281af2f8c2f3d4e3597609814f491d03abbdaa0751c0ce5049aa3f5b5814acb9694df935571316cccc52cb7950b7bd7598cbea164e959061c19478dff241ff8a4e07afc10eda4dffaf7256795d5c100d1c45549d67471e6a8d0abf978852cc0442f97f6fcbbbf7023ea8d8b84cc0e1d06f29d5b6d9367bc691d3897205204e81832da036f75657464a4362d01abc84be576aab735848e42b135fca7ead08b6414cb1102932569bccbadd9eeef5efb7462a3a50b37af730f3ede8d024eb6bfe8e8d5559ce5dab894187ade9ece6b40452e21da5cca67236540de163a1feec1f477f276a04044a0b8cfadf2355c8152b3c9b6088afef6d8d14cdd8941ae4a0e4e04d6171dfb9764ab96ee91c5bb4bf619ff648e44005338ea760beba4e5ab125d7cf1b33424a345897aee1089325ee3e8654a071784fbc4c85f7b2706eb60c08d93f146540352094526a4521bb224a77227d7e75d2cd1f390a507aae9654bde3f2b8fef9c7efe8977d119f14b146495dbc4ed6c99bdea8de036cc6cb15aba33b42a50997e685c64650588800204c8009a93afe5164a87c95452e5ab43362ffdc15ceb347995c6efdfbdfc4de5ea32dea54181a489984d5531f1bbda6737add7672de63efebd00fbddf6033bf4d25e109559c8a8097dba352654b1f143e6cc54e922faf339973792f7e5930fd2aa22cff115661d4bb586a41c2dd69c4732a47a999b64bc577838e079d3701c3c02a3cc8d822ceb493f531455c91b1f07154ab607c991e23952a6cefb8e019f56c0e3654c94e5ea3c9cdb5397ef6404ba8a01724a755a0259a734dd1550ee41318606f4cfd3745895a90ea1b5da256e5670ed680fb45d50e04d2f022b01ed55e297a6a1367290b36b9c5f123410cae7e23ed8a489d4c2337e78b07cf0490c18eadc2ff08d89127ef7e25fddb223be59ada244a5a186b718a7f7968ff8ecd34cb716d52f46af5b843c16c8e1349e2936b3672d3390a06dfaf9699964702fe738a3ea80e3312d619379fb248878ad10be478b35ee37c8e7ae7a86b825c7087a4fc7dd1ecea66bedeaf1788367498d9be854675c786cb5d57b500b4313527fb3e2e60cb79998467253300705516b873361695396ef96c98083c4dc12fa3f3dd71889906db89e35ee3fff92b45bad875adb7d87f50b56eb65df998219c69b2f995b56a41767d6f31852cbcf81c2d0027167ec7942d7a905fcc640c536a0d71acd55177b289054febee851796b4c039e77a0e2193b62b72057a49cf91be546e545b3a4d36b4da6bbe045bbf6e1eb2d733492f946f6aea0da8cb454661c085a3079f7f47939721bbda8941e0eaa96d864d6e50b2aec90996be68d66d30fc9bbb0abd1819139fae23cb0eadd2878a6fe1e574418a73d639bd0fc1260a475d445685e398ebbc670685850e5aec9673a0cca6007dbcfa6c2fac9f15d9edd91708ba514973819505e2470bbab76268ca4304633a52f8d0604cb97486eed25e555c8f8133d7b0d8c91c01f3e6c81557424ce6b835f174afe99ad9e6391d1aa579dde05a47be62269360ca039b725ee9272c38e6bc59d6a8088413b81a3e7b64435478d234ea84f5f56800ea5cea7c2f0a2a4a58a0441c27b269bca83208e80ec9f0135ad28d4ff518c82cf359a8c2b84296c0d4346b21e880e30edbf6f302aa5ccbde82c10c95f747ebc4d85cc8ea096d2879ad9360575b4951461dbeaa140fd104e289503a85b3d7d80517be01cee2669a7050a50274babbdaadcbf0125e522d9b470a6323b6c2cb773291fb16b899fd75f7492aaf5da9d32da4d2502441e5e9d150cf05fe56db4e5341c6309a82774d0512dabb82c1b6b4c7917c9d194d392b29b122e2efb89b4442956e6c637e3fb227f330a232dade86a785b1ed2daefaab87881c3dbc0845147d916b4df1eddd2fcfffe07086c6021f274e4a54eaf2bf77cdae6e59628efccea0012e2ce3ba0e7b1acb3f4adcb8321c52b8e1f6a6da8a8f60ffe3c221f395287af8f850aa2028229c42f8071fd9e67edcd85a9833142aba878d08b8f79ae1558556e140606bb5a407885c75cfc131b9a7761520e1a2825a90fc62a4d2659045c8d16372c36dad03cc395daee86e3cb4a46d6d575920e2546eef6c0bd5e40f66dd3cca4e086c77f718ec33325a04ec77fdb10e295b23e8d7190962e9fe65dff3a7d2949d9ce3b403e70e9357adc0ef7864876b1b2a98f0628257da3576c42c8f4748c49c1e366de9f413eb067617cfa9bbaa39d06520b85e19d03bd611db564c1b464727bfc50524e589d8e8f7746c4e572618dabd3c6a80f0d329e8a6b9bf679e5acf880f8b8a61b3a906bf0ceb501ac94932ef8c0ae942354f2e7bfe7bbd556e927698e25597005f7d275e0389f04cb3c49adb62735005bd4b11ec1bc9004e9ee215b7f393b3326025822451dfa513b450d5d48c8d83cd4ea15376509ff0afde29b98a563fc5cb04fea143bce6b035ade2c052085169c87b10eadc4bdaaccfacd062e56abdd042b08a709ea477b26bcadae37d5280d11dffaa015cf321b6d0edfd8e6bf25ceee69ad1e6db5ed0a3f72ef524cdcfe10b263eab19709d581b15c72e703a22196591bfa3279e6990a802e65cab715be8dc2c9d61bc2e0ad9bc9fb418024fad24ba812a13f282a8fcdc39f1e95740785b6581e51fc92b82f664faf1bd60560ecbcc8a02ee975124d955d65a54fe88d6a81dc1271805eef0da5e43f9f9baee57a0fdfc3fed535d8ac1e73cdc76de76afd56d57a9a8f9f4d05ef4a6e66a37e70a94f8cbe82fa2204ec8214f6314bc2c9fb437611475edb3c1c1da43e751a99798a8661d172f5db6442c46fa384e071fa888e4553540c27bc3ee435cdc2291c7d0d9c7f91c8d5302eebc439ccc4b6cbcc074e4bc23abd4cd944f70d2fec1e121a438781af2adab618fddc33dc11b06a5e4061fed8daff5a5f85c7b7cf93eadd1a7fc91dc65d27a6dc713834f0ab65afd9fe1b3d3b54e3c03f05d92141c9728428b191a8c3000e2415207b0a888c82f006ddb7546873686764715ee7034c4ecee67389796d1610d20e773895f35772b4d4d825513fe15c93a886e8fc5679c95f5c668727df232ec17f0abec1d283244cb3edb8e5ea67e5d474a1f83194ec7574a2533ac12cbedbc8d19525cc756593651a0faf8fc558c5a071e653f70aaaa1f303a770edfe8a8ed36c87f13402e168ce356f64c812ca4ef668143789b4b362c19e75ed98c7462bc001a4c00ef2b989935a7a2e350b41e4e9dbd48b06aac83fad440dfe8990714862ad441145804139e7202c91608df5056f7c11d67b1557435dcc3f2dd7f9150a8d8a82aeac6a6e2aa0855b3c6dbf2b8bf681e0387e74cd626f90c3fdcf8a0ff68b4d2cc7ed1f493c77e32652e44e0721b6e9df25c1fd24d288610e3829ee58ff8402bb40d11e68487a7686fcef3e4c16f627508bfe11a46522c0a6c14711c54ad48081275494ac02d10cee30b8e03ef6eddadd58c67b0edddea0801b4b67b45a4e2268305834268bee1eb0a474e1b3b86496f082d667812a936f71f347640632ad4c8a02a9a7e1d7a0ee0c348036e62fc6f9c1790dd3484491c1c262367cfb52af324ca3351604912abc5f7ca778a353d4bd7a02948c22f02f93a91d1789f582b13ae279feec070730634ce6734de110a38e7263f18b965f7c4c539ec52540e1da342e8f3ce7307f14250b7ad41b5abb79953de4ebc0f828aeafe7fe5bfda03739f89703d000cea1ce1a10ecb3dce16b902d3196c388244cff330420da423d3514a3d3ae8fd19784c2df36bb27be29a21669263e638f8f2092fe3b9ed0825b84009aeb47136f9a3d9bc60bd696b086293a1dcdc6c914fef0518dd6a104816f6f7a0aba4c4a403e9b0c427c064de8066d0559dfb5600b023a1b0c45e9e8a441510ee206e427d7b4c3aedfff0de1ed1034898ba32bc656cce866f76da4eae36437d9a11ee0a47879df4a59b59b065f16ee938dd20136f2b5c2395918814c0b53f6208978e4afe2bd3236c63deefed094dd618e9614938736f18e37482927744e3ac96cdd983089382948620971e2f7e2394992e761337e75dc69f08df88be83aeec2124b1f39c58c23ed4722611d16e514bdc7df73cc57997d38b5e7c59f33073c5abe6e317a726540ad3f22e6b92df4bb571c7635ca5f690dc7cdef31f4befdd49ff75b444b4630b43db8b739188034972e71a022d0fbe8f8297fef11f45c9fe097759fa608217b6e43b72d277af364cf58d60ca0f61f574f8805340e0e52386396e2aefaac13cdb0fd78daa0b9c686bb12488cfb9447ad8d7693d7b93e0c4cf06905e3cb76a9d7a815d277f0741cb1936a7a9a9765f253bbba3480702607b41f94fee07fce6512fdc060454672dae1ed1beda2a40c45dd8c25903f1fc41dc69f44c0e2c2e3e58ea31d75978d5947a2af2b4e61de2cb78f521c63ac39a8075ee8a271dda43946ce616ae7d22999c4d12ebb0a5a4bd04e64b098d6b7442c925674d44f941c5ef04939f176784b12b9deb19e775a0240c20006f5afb3a363cc7b2bad3574e7ca9a079687c08a19fd8f461a33c5f1ecedab2c24b4350d933197d48dae47820ecdcf1919f341f1537596910a254950a974faed559d8d1c2beb7d5d4dfd41b9c731241bf1407fa14a983d6de29523330ef7ae064da6c71a01e4fbfd0c4f5990c90eb3933911b94619690cf42ec70082562b87141a12c9e6e3b634d7054aed93b82b8fe49343049aa46eb7a310fec80b1d33f90e617f31c1f7f4fa63ea66a1b213507b5f3b708581a748b71a33cd606c8443a7bfb2aa8e96509e892cbefef99bfd28e5554a030903ecede6afdc4e6a330afaf3188cdca5dcc4d1316a287598acd3e872a449226c19fc960ab42e9ad15aa530d1b10984d28d9a039e3e357df4c9d6b5833396ae90793fc463d30de492d099c9ee73ef16691f73d06061a84ea363da97226ab4dc826c09b1b001f0402b8d82bb1bee93e64b6410c4d1f40556b705dd4ae61ac59b68d13d965b00616b439acf8f0a912ad61c75dfdfaca735d237f1ab770c2aa949eb61a6ac8ac3187a6b02147fe8e118bdb73c06d5461ed39c3519855a055bd26814b6d6f74c0bbe0e52e8530b17cafbd1a5722fdfa00fceea10109a54cc6b35504b57370b481791c1c9b3c7b9eaa22aceaa1254693ea04ae684ed15d2b51c310c36b88cd7e5a715cfcd7a637019414e20d5d2eea6cfa1d9303c7036838c7a66bcf52c49975e4c4ff9883cf6d280f128f7da5547be390a8840c46580ede1cbd2aa10fc6d7b08d8fe3dc980fba78bc940748f6b75f293b224a33033355f1f968172d5f1e7badfeb640bd438f68ada5cfaf9c86d814942066a63b7bc386af36be4d67cb50076ae18aa7d3cefbc788ab242b4001c9b1a8f10df0ad063e1868a9b3d3ced26de7e10d74251e06d4279d74aaa7c7d093f8e5b085c4ce493e9f1e7e84d4ed15afb105a6b490f8bf9f94a174a5a3975bd932ef9d1f79fb696171ba9ac15a4159c5b42b7a631a5111e62e9d4b3bbf1cc15078df3944184684d42f6b4badbc5d66213978024f02a36dc52e2135bfad75449a754820094e51d160d4d4ef87058c208637daf04172007e4ce8cc01cf3168641aed332bd0de6971347d89561915111ee7d1f546023c849a95bddc1ebf01304cc8ea4dec6f2c728093e9bdb6ef0b75923da9ba2c5c29b2970d3571a0d9f4627ce9d355e9722a3ef3678117915f53a3ab0fa4270f53faa5f88de079034fa3ad6730018ebe7f790bd17b602bdc5109f9711baff1872683010db0db24b28918d9490b73d144ccfca9865a375808d45c8aeff9ad876dcf9c7c99c0233742f00671be7d265f2c80ccf6a749a86e86d69792fda348eb876956df587112a2544b80f085616acca31bf8d0aedb523ae8d55c861fb8ebf486f40b5592e5649fcd8342c5b06554eb75a4bda0b80ce4e9e86dfc221b42b372ab398b113cb97f461d087371043f3e1c990de41d0cd8ea6ff24c1885362d8bbc96722a8c6194ad1ebffa7259042ecac7a24d956e7675b628ec46e19bd8d94be5b27b48dde16e3735ca0af73ec10f75d2cadbba3a60281929307cfedd0b3b7d03c6a122c20cf3aa02922bf3c7d0e0d68adfe3f29b3fce0d860a2dc3f18994c73921926d593b8e50c23ebace47b495a61c518e7b1f4d2752a790c78bdf2fbc2f11acaba69fc3e440672ac735891ff56a2af6714ac68e9f0347349c8dfc46c7f50607ab4bbe7843b22e6396c0451fa6bcc32c3ffa3d5c406748c2177d60ca785adca284cce073513c623f5fd6e1a55e558732a4004f22865cc53cb235b91c161adf859b1be96f54ce9ab0963f3b565054e36124639ef1a954e2b07f057cb01bda9217575e506e98479bd399844e1d27bd1cfc2f2ceb7826f2a937542d421ec5df22df1b40da62565552cd86934853a93f2f43b3876b475f01502aafa2e2a6e516f96bcefb6ced5ed13ed295e0ae58122cf93b6801220306685269242fc553ab32a665973d0b8403fce90e1bfd1c40d37c51f0ddb5fa2de7f90986ec49911fb06fb216d79ef37044277bdd4952a2d4d8ee6fe3b6ca6b52ab8096063121a66c645b49d587a7d30432a0a475bb4eb8f570264ed82dc6164941faa3adeb45ff1ee15b2fa5315720ac75aed55e190428e25cc6ccf20c055b18f37f8ddb91a2c0b262aa4a4b9529b82df07b361657077d98bc74eb305bd4a641eff1bc161a91c1417db46a33da5bd75d2eb8980b4f6f747fc9de5261db7a5401bb0c2304efdcf118926ba2ed1412c9feacc3b0c87223bc15015dca9fc5cdcdc71d5ee54ad8dc0bda2ef7ee3619e5d87971eea5a97d67f66ced90e090ce2eff7277f9c8fef75c54f3053973f7aa3a12ccdc066fef294b1e263b89ac282d9a0ac3922926fab159016ee98d8500210cf0b7d52701c26787238779aa3e89379c09b851d2c65798884adf72d7eab3689391d7a0f06d195a7aef8cf282bd9b2619751d30ec103eeca6816511dbbc6eac20df579c6465339439223a502485c01cc546f2e268398fef2fd99ebc3fd259747dbcfad6df6312bc50de8ac8b5d127cdb34ed5f6b7c216ad0d24efcc84618bff1ad2ec1e7ff5c058b8b23554fdaf27ae8de6d12a26d1463a61ce82d9faa55828c60c1d13c329796f68979099ac0a21e3f1c3ffeaedf5ba7afd32d7503f8b305e2e94205c6a6eba585d3154708864364346b02cfc28e4b4880e9b6124d653c5d877532d579e3ba2a5cf33421ba549606097a38571e7723d3a1e77bd8afa355e8f38f03f5285e0fdf791655327e62f2b39dff4a70ece5b742d4038a289f956218d78ee20525337788acc6e3ad6c8658db267b71f08761abad54723a81301a0d15ae878153567ccd543251ebd31d9c0191c515984349939b2f29d83e2b95d4789e6ea2e06f1d5ce6bf765309546c6586246f5a9b07b4e1ef3b71bd31bd68fde142c1098d93e173f6b7730ca6c5eee6c8c8ea82adc0d21d53341103104f8db268fdaf52bd8e4513631fae6a2beb5c3223c04a68a4e7e693250f2fb15bd6478c121ce8694d29bfb730b217993c018d9ad6e52a18528c6f7c699749463e6ae1377fb5766f7eafb562b787194db762e1e07a51ed03ea781f141f47a34f354776865c0a04a809e90d972c7e0cd313f7adff433c9066e123523637915b090c093f2558d61906371f5188f0fa83be3f819922d776e5a8e72e417c2c6e1e86b40bbb2dfbba125a578f5309d0b484a8da058e95d3b5df6a3dc8e0f485d4466b7942021c51dbdbf0b7f9ed7e9aaa6d1ea3e6c359194dbfca0cf1a38dbdb8408868dc87c2ea5c07df4d91476eb04f74b1266d03afa00878cced033502474d9f63cd151562d46e625933fe4b104c8bffbf45f444e3611d7b334763142fd154115d6868666a5fa74a2cce843bbea92226e0372f10487587d99bf34898bbdd9dd95486899b1a24dfc9ea488a3fcfbacaf1052aa73c4661f5620cdffca57254d3ee08465d8bfb40d3c094bdfd653ae6414187aeea0de3f8c198ea74625a1b103081a8bf3e1d7efa0d6ec15e4b157d586b96d9e235c273a0a14a28eff04c671ace6462711d514db3eb1e3c8a6f4287f052a71495c8b722b5b5fd95c3ff95f9c3056a5b995824e1b2e426ffb1fc950f304caa996def6e65ef1a1a56445fe407b7514e052e121631e82383720d0b076091668abc9488083c40f26e5f32dc4636868e42723fa3e11b6c163222724b9ecaa7283204776e82e728426c009f7fcb0a3091b948a50e3e8907bf3f34bec166f1dc41fce0d61f75246c86702dadeeaaecab9b21f250b133fe198b92f1875063f338dc923b005218647ff7e4303971fbcb2f936ac4887910e04cf7064958f7a5a60e996082d707a49ae45405d13f4cc0b74c9e85b9a47acc8b2c511526984d0f1af3af01aafde93fb369ce2503c08659e7b0eefedd56d93d3f9915cafb7ca88ccb85f81dc1491cb810d95aa6024700abb04229a830e4e0e121ff2c3fc551c8a7d2f98bf0920cec01f4941d6119e6ed8c8c18fb91b2b6ad016036652f9364dc3ae97d131841b6a900577d19a4256787b20042c4241476506674c85b657be1a732cba3338257fdf68da1ce7fce78cb95c1e54298a86cf8a2ecf15ecd3e8d825cef824d128ee74dae8df10add18e6b9623362976127289546bbce41953459211ddd57ea8e46a2fe63e70ad9db5bf9e76524b1ca42af7c1ee9d51210f66e9d786062498b01ff1c4efe182b84344dcb3dfa6d5321554fa51b37cf06086c559516aa357574f1daebebfd8c149864d0b269bf7858125e47ace76fcf1581474701c541e65d60886b8fb767908351c9030b312e35c0dc0758478ef4a9b3107f4e0cb99996a8480716a61322a64fcccf83ecb552b5298994889864a6c985b39efe4f176b1f930ed12c558cbc2c9549f77948d9e5bee66da3a2f44f3a135985162ad11c77442a1e1f6ff5a3603d95bffcc8e5ddee5b4bf405a8a185e6fc22c4058479c5aa36bac02f2785b33bf242c7bfa447cb90734e0fae046834deb8db5d1118a438828381daa3677806332a4c87b4ad3688cdfb6a425c38cc99cf8a81e35e31c044562cfc934f8ebe8563452775c7b8a314c462483811114ef77aa5a229917650284a43d04dd35044e27ac526316244df4c04d42809aa2a6aeb96abc3201643869b2026a4bc09404faecb0ae0455bdabb250f40184663c03ce15007e9fd2e29056805f6d4ac644a58803e780c77f936f1b473bda522badd8abc22288c2e74dfdd4bf96b70251e13a457ed15255e93542b5443ca16cd2affe3be7e2c2f61ac1804429780e76ffb4eb02f042dfe3d87f7be50dfeccf8b592c041b69260591fe9ea3421e02947d226a16ee5e099a51dae77c85cdbb7981baadd45c23dcd142bfee967131ac2a8c66f3cce6537883c1eab6790ab6860b7a18b4f531ff1f8fb15f59fd4a740247ccdb6fcc67c2182b8917848c6e64acdada9ff5aed9527ce5e87dbf8ea5e573357c3bd0421bddde8dad6eea0b4f7ffcb2e40aba4daa3861e460dc8bf43b2195091f26b8748608255fff999ff4e0bf7d019200f3cefcfaf374e1ea850be31b184149790619b106fc50deceeeafa803cf7ef96db38a742fcd6d3c92dd5c01e359b25633c61971f43eb2b179edef9ad6e1d35a76c11668c5b80afe5d5e7933065ae16107a503a2afae3a42ae6773e15bfd58c790ba851559700c6ee5d62aafb1eb081b956f0bcc6e19b9a8bcf8defcdb09082f53a921ca835c9c70f8ac226fa58736b404dacfb2c498cf829ade95d487275aab5bb4e13ba92be990c352dc00a78ae009a3512cf5b5d5e4945a429d0a4ae9ac36849ca0853abc819cc0542514ae9065fca6a2e5a60d2594debf57e8f6398797c748ac8f7ac8beecde2a4bd84bf04a7f6aaa946a97ba2816319e204a3071597fe92f46ae8ab584e2c1089a618f2ba4b36a7e00209a387b26499e4aa82492c6bc6fabebb6fe35ea5d7ab2c2b2f1e2a5afa6bbaaea8dddecd352a67914e306a4e3c673f476dfbed144796b1581500d1ee7c9c0dd90d2834f7e943f54b33c85b574634b4e3b5388dcd81030bb7a33fc0b4bebceda516883832aec331dec0cb1507c5e15d4dd366c5871a998c4464d8ae2a648a6724cb65e7add6aca6c0474e215456c6e2184ccb3b729e60ede601dd3d9d90fba1149c157c217c52c43f3bd6b6b30f8ebfc9eab4e6a9604549e549afb1da2391129cb10e7412c76e781219280786128e2e5c2948d48956239fbd19ae93e0bf258061053c49323327357f0082143b6fe331bc97b1fcfeaec28456fa4a5190657fceb649f73dc6f12e273fa4d4367d013db9f35d65012d6e429fae575e57333166bb9373c54e588a0c52c7734c165e95bb629d5264826225883ee364380ccfccfd9bc84745004d30e2b397fda8652f4635f0c97feab28e8591b63b1270d9be4b599a9b911a12e4c2af34cae7e227e031ee366ba8730b8d89e9e0990bef4a5e7612037fced4caeec47b736c7f44cbe78c8dd5298cdbcadf59a869e1ef8423be7ac7928404180617177bfc2a745398e0885408f22c22ed8fbe9891a5c72626008149c8ec9d4aacb817d45f74933a2cf2a2c372494d76bc5bb47b612e3be8a91c32c0c56b69dda12d5e7b39c347a12118eacb08aeda937b15bbd4e9f774ea15b6eb50308a3f8b3cb90633bf0a34392cd791018b16f7daf85850287059e420bbcf8f14c803c1c9676a01ad8f48260d3205e8dc2beddb098d27721d17268ac55296aedf2a6d8a8715c781fb23ff8563c9c5b2974ec5d865a187065b4fa60c1d9d6014310eb36b80df721067d6781e28026c7fb40be6447d4588139ebf420f7173b845dfa33ef1fc6a7a845a07af1e7a6b54fa0affdabfb7847c8abff43872d4d6907584bbc205c824f7e6764ee152fef654884c5da325165fdb6d286f7c2ae6fe78e16b414c070951fe990d6a0010c89b8949a324f123d00eecfdcc630a7637a4d32f20760a8ab0418ed2bec925aa99fca345c2c0e96a8454cde06fdc9283189b157049ca49a6500bf67d0e452ceb6af1cd1716d68c0b140705a89b31a92bca63a552e32fc82f210b76ee76b7c5a8f605b2f56d8ebe9ede93b4be7be895cafa0c9ed81891ed0f176d0caaaac5ab38d68973b3181f206fa710df5e88012af6f40a61d82d4cd22ce3932d2d22080c2821aeb232a49c23f9a8d88fa0ad6e42574f3c713d2229057a71b0c65b2a44b97fd767d3073965efb710aa6c0d00377ba3ba2b5b2fd20a8da9d544936f6ca53d5da98c29c10cb30c543b099e5254959ed26e9c14adabbc3969cab48c89ad41dcc27e6acb302aaeb006ad45caf13a9b4c351f38a3090b022a1c2aa6396d226ef733b42e310dbb804caf8b4efec12c81bce21a75cbc53bf80b9fa2d47dc4c8fd9d0eae68ea0748369b5a573cb29af5ec849d61a417c1898c8b83ad904b57e5a6bee3159f8f3750309721caf0f7e2e089959f6a8c76f5be3409fa2f94a12b3792bfb1c6ec02dbd1a60dea77dc4a9c2a58ab1a943e21e124eab3bf69a68544746e8d061acf96d8e3a6ac28a6813abadf136d6abd37fb4bf4cd343f98b206759857894f91c47cc4b70ed11f190bbcca8f6f9f345ec9ff8a52cdace814214c9bb262a0a93709ad70a8325334e60d9fbcd5e1b82afe46ad09f6a9ec73d8e39d774dd22a3e13e9fd250461aef4e8565feefb7fc49a727d3bb7466d4928e960a5c86cd038794ab4af46132ee3a9d6c83f7375f267c93476efc78676124c89a3a2ffdd6a4cd1d6045109cdfffca0ff8a9b4caf1eeadab22eb846db1035abaf619408e6d368ab13ef845ee709a32e6e7cc139d1c7e7fc01537dc763e4409c93dbbe34d9be8921e1c83221d7d949fbc4cb4573193404aa9c6381d52644a84277e906a202fcb433b63964c4e7aed13207911228ce94a03f61c02823b618acc5a9e2fd33a733a7d35f9849f76eb873881dc99a793412089e17e0f7b52e03611d4bca4558b9d77e055fe8423d4fbc6a398b786aa709e42134f8903a33d88465879edbc557cabdf137475c6652507da7ceb841f80ab","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
