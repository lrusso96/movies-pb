<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f963928f1d80a9d355346e0f490841b7d12d616cb2ca0aff38430ab1423bb62e04752a98e059c394032f341d0cd5707e48d424194d228da9afba75734d3bf034b908b98d2062f6f30a79a94d95c2bc97cd73cec5040beb9c35b3b71ce4d736fe9aa0f6f86fb614e2bf504be83f8fedf3358d81c72a60a232a5353007e4d9a4647d9ee8a91dfc79f4727952b9773272ea899efb4260c72aae1aaf7d69abcc2be891c8cab2b22f3829f0ac799415740b6e0eeb8b56e1d151240a64d477775abce746b219f329cf5e0ed05f3ef166a7fff227afb56626805a8d9fac0de033d1ee73e9ec4bd85ad456d876b7ebce62658a2cca3cb61c14c2280dcec11ce9bef26232430bae9edf2e86909bff72f5df6b5d27eabe0d062604742e85200f7282199503eccccdd1561d221ef029a9dd97405b06e2778391c58158131b3d89449fc745278e851a848bc322aa4d3dfa8a6b13d29ccb1bc5a1216b62fbead8d93c14b558fb979c57633d0e866a68c8d361dd51122735bc75b5f76e3e29e85949f24ffadac62e296979d5a3dafe92a7e187ef41929ae0ff7dc8feb90c0180b53637f3ddf1791e717d0f2fb2e2c34f00483d5c44a6cf98730a607a9bc58317db56bd5626332d8308b7b427bec16bc2c4c977086d86004f18c42cdea71fa33d089b5f2f1c3b2a6282b9ccdeb502b5d47ef0642a965eb068f7b0e7ee0e9f158efccc01dc2944b627dac508de17a07b10718c9a4bfdbffeaac9a7f09bbecfd7a9c54208ded0e26d4b2539d428c9d27c8d822b973b321b29e71f58ecafa8cc2c9dd93b4a4b9e6c1cf92abe2cf7fa0d620acd0328086becea29259e11810ad62a7b5a61db6092af6bb959a66bd5dc005049755ec85bb3b34f11ee52a155baa41b395c16a3170c361a44cfe65aac7c0e30645fb08d71fbfdc9c516262e3a2abf9859b510848ca37cff37d173fb00fec176f86ad7da030b5addd0908aee56734c6d07f41fa627a870d3405e576bfec873d42841a6a248c9fa1a1eb800aa36f09327babb5965ab86b2298aaba4f28df648c883a9e919702a3b22f7860eb7d0c7f4c9994c6f13726be5760e76e3da5c4a0471ca19183ffe6b2f59705c2f46ad8fc85f03db0d9435c587a541826e5f849d0b5288c1500daa132bd30e4abe65306c1047a207fe534c6da6ca6cabda74c6aa6dca356bd7e1d26690da4e9e68fac10bb4960f478fac147b24bc63e59d5102234a45d4c7d0fb2dc77c245d82a2aa017879692a68081cecd4b4cfa2d4f8ab36071e88fe86b71b0c8030509e28028f36ebff98597a15c7578fbac85d5f2e50cada340099e6dc3e6310adad8f282bf3c4eafd213105dede36aec9376bb381c04bcd55deafe9c18a6c41fa6d4c46c309d3174599fa377ac54643ad06e9618f81f5bcf7f90b6e39cfbe0175e614ad09cb57635012307feb73b0f7158f7a96e4fdd3fcb0ba2604cab40919f3bf714602ea64811607bec9e404e4f01e80e45a68ba0ffc1a2d938de1fc2af89b2cfac46617093b767abdbb81ad434760e041298f47d15728185c50b93240ce86be3ee98efec7050f239b55de004f698aabf6938ca20487e8f203e595f0a26c35d9caf476217e9a97cadfeb905770b24690dd75e1db3ebfd352c921800b3551c1aebe8a0e8bdb2f37e721f8631a4dabfcb4ad1bbdfee0330f82d3aac8a92df994ab906803df4d266a953fc82e95a9236562daf2400e4e1e12b0099b41d1fadbb00f7b444b5f608963d3908d9f963dd6f5ac063bfa2afb3d0a1666c9741a56a831a855a10799250de54652543693fb806642f31c5b01dfd4c1a1ede4788f125a22cd82e722cec740acbfb75331ce2c4d273069ffa5c7ef46c161ff27c10dd6b17f378485841fd10899354cab4e93ec14f7db1465faa9fab3299eeac87bd1111f6a8e603a726e0f2295383a68a0a6714d4c05c37b97e2a27995e56c718c043505491235739fe8fdfdd480c1bba0c2f794d834b48dbefa3948b7a1f611f92e9eb34f1cb5975b35c1ca2788ed007aa0fd42fe2894721bc50ce5cd4a4acc75c2c1a590dbccafd3052a8d21ad7570622aa2b5553959e1156199d5dfd2b3e2431d242fa73ae5dcdc0efad9a3451def68237adeec129cdb7f092509918cf0d07d835401eac3306ab675c0339e5caf5ff062e1887f493cdb0be14fe6575e02c52318c892235239213120ee3dc0a77fc9f85db6777e20731f9a0f772060f9ef8c53b23008a4e1521e0e9c61aff90e8cc942482235bc50b4e21302fca4daa48bc0cdcea13b302eb51c79f7906003131d177f7e239a309c1919089a24148aefd546c797f659a852ab46cd963d76103e7f394411747dfb80666a3d092594ba7f73b6469eff3ab7b6e9792af6b95cfb08779f1148d114c1d2a01112f3a9eeb02054dbb9dbc2dbc577dd8b9eaefaee714952bd8fa27d156ba0d7392d10657f4b777be8b728c9c7ef4b2d544c109f5dbf9cd85de65544bba2cf2edd262f36b88102623251cb3d96ae6d7977ad28be9ebf700bf70ee9e57aa7777e54636e1d408efea6bf45c3d4f3a465f34b4f3f4bc5d1d724d60df7c4aab567575019ab60c2a7e118ec7ea006ddf6acb06db7e996117d157f2d2f4252e30645cc3a0b8ec4fed974c36f8d42fc65e4ecb24e73bf0ea3bad4650ad94aa1a52d832c3af209e1accb808b90d8846e06c5473eb215b76a4dae84267dc7e4fbb59e3b3bb052f7dbe1c05945c42048a51fc958545734386f5e9af58c6cbc52f2ef39c21a88356e0380744c9233f8fe99e34da31aa13fea025ff83bc3489f2f94957541006cc8252c2f9616bd2b44fab6af02407306a821d29987199a8fd1332b0ad2c1de7a3994416bf8324ba517792f0f97b65d8c45a59c5da1f5952803ee5d0d83b284cd71ab4788fcee7ef34061951fb414f9729a6f081733dac4adab159d6f3a05a9375f16d6affbb1ac2f018aa2fdd37e1b8b23e9221b4e0d4707244dba2774a09f1dcd7e22a613b91a36196889ddcd7de6b61539cdad512d22acdc2b8e524f179f3983e16c2d1e515768cf9f07a426d09cb39958caa55346d278ddc719e80f19723c64cd30c270e49c1ede9b6f053122cc35f87dca13248acaf2dda6d9474e1036148fea41fc1e9737bb39b2e9dc61d305d56ae57dc4d43691f20b6936c69680bc4f3f4e6ffe5ec4f1c27bd1ff5611cad511faf66c70cbd94f164650da5f2f73d3f9b2b195a5ba0992875438919d345eca9888bfea25e61eec076aaa67f08d3e39abada2970ba7552e9b62fad784a6603d97c55da7d8c6402058c644c116f39b90d4c1f0df35fe003d3aa134de3a9892982299e948224b40b4fdc00f30fa99a0645f6ef54ca7ac2b044fb698a71f7fdcb4f0ded87c154dd38af572ce7704968eb108eae2d10c4afedc0987f4d8e9762a5b3b365c844fbf16d92517e1061ec296cb860cd4bdb179547757e41fe87bacb25303733552a2e433844ab391a8c62c79916699a825150a416fd4699094283cc0a986208f3a6b76cc48a814843cf6b1f0f4bf4f320b4ae5af5120865d812c5195eaa4519dd72e5a8019b70f41c888c881753c9d8154f953691fd965873a1a03d16a67eec030f9711ab328f0e6b72e729459a79b61fb4fd07002539e625e05a7761619f3a16144459f026cb10b6b015b9e61de9915b8ade66ee22820ede488900b449db0828abc0c2c24b3a31b164939f3ac13f8d7c3f5fb03d27764308ff65f2c2acf06707cc75b63d16ed48ab1ded9a26b91cae4d831aca35ea251d4025a6de0a0a4e61317c7d4cd8b504e7ce9f256543f1139a9a18a4ba031f615c0e8e373f38ed2c2252f3d38c19d84474d0a69c1a4a8458e00fa32dc9aa5e60ab013379fd721a05d1d0acb4afe7c1a207bbd5a71b97b399f717437028a6aa5be350207df8bb919e72615df6ab9164a2c0692a0205fb04663d6e182da99a87e28776867347bb5023a063c399ea11be556fac10955b17236045c2b03b2b039959be1b068b768cd657a2d0750b52b59cdf93b7f14474696bd28d90037b436d154e19fc4e9a2fd583d146715ae1cdb8a68c318e9807a3618ff2ef8cb643f070c0c7b9b7faed386c3f4ec8fc7c3c8e444b5100b3715ebd321b8a4e7b12bc2874e1755561cafdb3e193557640ffb27d3f8de517d248d3cc7778d6b17a46f6342f05fac8470f688cf2feea4ad7511cf94dd94864dfd5524610d71030710694c0d552738a9202e95bd653912e0ec7566cb65224e85f1524c5196299e383ae991658668704bda54df42fb9e8448c33b0d73f95c6219b44426fa7911b167117186594e4fc424a704d32e6f9d4ddc9586c25bcf12804208b92187b9da0c37cb39909351e286dab9a0869f3567a0e8927c7499457d84b17377fb8314ad18bcb2e0e88d870dcefac2635d718d65f27c23a6bd7f8672d1270f84f603a235f97626efe270bb473d43b11a0c301f10db00d5fa59bb73bfbe072bf34685cbc57656b3d19308d204bc317c713d686873e7962026c16a90e4699bb042aaa211a60a24b7941a4c45e37cc6b2816703fac8eaf8983617e0145456b5a88bca1f7f732bb1829d1db7f84ec4d24859a4dfafd61f07da8ff5ce54bf2883a5e17768bc8d39a81e83e0e4b20cfb0d8bf02e0a0f4ea631a0dd58eec09d633266b68cc19c05f8a2a0028a7d07d3e95d9c60ddd7152dcd888dd0446414edc0db9e4397cdb437a1a2b583d67cf778865194bac593022cb599aaa8db8f504b232e6d9d73af3d1f60dfd14318a0d85f0d68bc6400d7f9deb79a3ba2a4205d23acb70b0872f6d273ec91e3b4c0e0c4c0a261e621ccdf22beda800a14a2545b2f7b307802576c373e0bf546a00269d1be629f01662dad08311afa7e354d203e661b49d080248408b2bb9766909e72afc3478b1d03f2a1122c43676a3c4aec46bb6c28a61ebf4c074d166212a02dbfd06664c50a5bb21d43a89d94ff6a9fa477cce466616958fa7014ceb83abfab758304757c0be116c204bfdbe7a6f4795091d06f43ed2b5b8bf11d4c3fe096267f148c3e6049d4d831124acbdc82a09dc99d1b291544ae47724f90237ab738b8d7559259d9004549986e58c81d2e29288e4d5a8e6725cf03346c512e6ffdad11fcb46f419be747b573150b606136fc67539992bd6d6e0b4743574c05f5aa2a42c9365fb949f9f5e13304a19f7b1d962c875c92d131c7906240285ef3e9cf554f96996eae42badbe125f896a294eab41d5f8ef853c1aa3cb783468346172b0ffd9d6869f752ee3f93736d12e9a055dcd845472228f1f1f57ac20dad492cea3fd37c11c3b115988ea2c95ad7821885e891ecbe9cf32403ac4df94f01da8b1f677d65a1e69ed3ea7a98c65dc6fa2110645ab3bb713e6e893d01fe8d1cfaae7350df5d2b5f969b4e7552f852c5740ac5c4a54aac68cbaa4afdd8587e602d333ff09c35dad8dd29a6aba01f3d7aaf55fc167f65ac3ff45c5eb960a62ac7c8c722937c79a1cb383555a336945a580dcf648364117ac31ed5d3bf885ebdd3b8be68f0e888435294eff021cc47697717325d172bcf007a003bd4ee98ead5f08124ee249a59bbd49315e52690e4903376126e1c7f1ed28fedc7da7a12189e3f6e21c5c3b3afae69a9d0ae5773c0547f0ded9420665ef4dce05e85c6c69e318c5990a8cd68a7f811dc6c328472789a921d68ff43f5ca4a14aac541f6b06f8b05778ba339a6921d92fefef7b48b4174b899444154281360a95faa242554ce33db26b69ec734ab9dbfc52a1145445fe3f56e722430f8763c1bd939a9ef1e7f2dd98931a064dcc9e321060efc3d1c990e8203d0d4f98d911b68b04da5cc2f22d49dbc3b6f2a3251454a0bffefd7edc950f9af177c6d320c10f1d46773bf0d7fc24e3e6195f926ff47cb0e3d9550254221e5fb79f9ae0c95ec8af9f6ef6f34cee0f9d7f1083fdd314a230b9f73ba4b926694374e1e63cedb3a4eb8284f099e69f8abc5d9e1781931bf72af73ec945c40acf0170bda98ca18fd28378bd3c031185e9ff4ac01d8318c0a97d26cb7ffa6a323a6917093619b79a6acd5e41698bc74ff42db58b01865195953a2656e87c49fe930d9fcac3d04602ecc899de9080e33997a8616af3fd77305c84d12e02e12843d73d5a835ba650b8de0f02c821c5bed46d6ce8111b0866ee5d486c3a852b3ca49d6e64c502eef66b865987d195ba22925647e3e26f554508ced33fc9d10c73c3b52209d784660a0bc9c081e073230b0db1d2182a5db4f4eec49e2268479a65f6ded4a6152d2c3ce99f3edaff5681bca178371da544bba519b101a40e2c9c04246e37b0e06d2dea74fc8344069fb171d9ea0fb704453f768b948a601dd8bbf65a4981a0c3be68aedc36eb6af86331e2ca197fc9e7354ad8e5112244cafead8a2167cdccc65676ff164ea276f17e17803c48d24211163b685ebede79c9a22c9092f8edcdd4743be681cdf2f0588dd7b584c4197a0f8031b51b7bc73bd2fa7ec70b7370549dd78412c2b10b88c248a9fea26dffd9adf3ff693c969c023bc3f5df5ef1fa554d7c10730fc2bd07e22011d4bc4d091463d039b22cd91acf2520650c480c46c2b4cfb0daf96f5bce854bfe5bfb741a748d2e665a230da8f4878ef665c1449fd99a81d69b7237972d50a333d163d2a6a60897b55fc6987915e826d256cc4afe1e89561f604149ae7af2119746f610ba2cb8e1901079aa19d24115132c893180b12325d87782868dddbf2ed34180e4f3d0ec5b0150fc402a89f8e50389ff7dc5a0116bfce1ef00287188be50d75669ace47c6008cf5d7a818c9d9c3ef734b421fbf6817afaea5f648cf0e26478df1cb36a9363ee1d93fd710137ac67798817b73388584c047a732fc73f27998b179e04a5178232fdea6570d033644260dca971cbadb8e056be0c6c0c506f6597055c01accf4998f9f2e5917b072008427eb62446e18a5f9fd6aedf598ee4a6c99a32bc75dddf4e34d1f4bd829501f002e7b824754f7ecc41da746f03171fb2b5765843721e436fb5bab0ac932f7a16ab0b38667606be8a85a146138649a7a117f198cea5f612fdc932665b0a8d97b25888af5e8c7dbc5f4a2eb0e2186ed193366a1dad551886d3c0c6d74d28885db5b8d8a46dfddceb3de9b7dc5967da5ae857a39a06dbb979f5ff208f610a895db70e49c455bb08c82c2e4b37151743afcd4516e6ce14f9f67c3ab0859c202274a39db79754665764f6cd6c9873f7d4fd7658568fd66725fd0c4b0d7803daad45ca2a375b5a541e0ce25041b4d7ead16d0f464e69254821c6f84356cefd8f360d19402e197f3718628d8647b6c28cbe63219f18297594c62a6140ccc6ea55ee4f840a311e7c917138b26d3c176b278c19fef60d71b9d87f93c169da6c7383a32f9f19d33839c32cc6b64b3d40c20cf4b854849d5471f0e7a1b4595ee3bc02f021db40fc94d2063dd4709a60a841146da649e51ca99602e23b86ee5ecb1dcd02633811572f8ba54fa5dd3dcdc44dd115314292dbf3fe417c73696119f271d3fffdfb135af30c2e8e89a45e8cce689fc77425fc2fe58e212e3cbd8219c091deae4a2bce09b87d08058c223279087c595905deb03d36dea1dfa4e7bce3983a10b012a2d3434f182198f56ac6da33e13a6f05f3622832da83829f13540b2f233de035042ab9363610cd4367dbdd9966cd6d4e05d86b52c0c880e84b443a742c116096db7f1262702b19e3585f8e20279db8ffb6e07a764d9448ba139798d8165fdc73e39337251ecc508eeb14b6ece09b8337ae32a47549a0bd84162d15099abaffa40f0055159b00a98983aaca5a52bfcf07e2a629b9511059d6919fa8572ca2315dc5a07734a29ab4e99013f5372483908e7061da24601287ec17667e0f354c9b3888813cd46fcb4a04e8c9cba8a123a1043b432e5f8fdfa9b0bc7e0e4b553acc7bdc5260fcd05d630c757a0bc18372a27377f3a8626094fd9ead07ad19ec03cf07a310afd4e4061e37791f2c5c16400614d6962946b6351a098080f28dafd1921d15595c5299aa6d7894c200badfdfad918d3b2e3d3f95a5d86d8b8308a4a3b0b5988f121d5e2ac574fdb82a560888fcbbb7eb85d02f7ef06e5bf8e648de8ec5a839aefd1a166ff8f9105e636472e3419be565ef91652a051ae52535b342d718c14f5cf03093fa3615dacc324d0e1e276e1d74df7d1a68025904e958116f669f6de8d48266d340a6c8a95d8030f54e7e375830c0d51b5b06af97787fb3826dcf585dfa4deac5dab8276063898e74053634c2489eeacf3c479aee1032fd6982a91e4aa4b83512d6ecf5a9e6a1aa1eb90e1c6dd860c051c140c2d32e019fdbd095256c235db21ddb62a71f18732cb38a1abe2f9102a733265c5973a1768106d9d4c9b4ac7471bee104359fa52d111a59d3671e345534b6a2f4511a68c10ad0336937a409ee9ec860da142c8821b10329648748711578a79a4ff1d6df3b319383019576165df000a5d440fd0a45ae07bfd0cdf8090ad29cc443c4386eb0a9c05006864b4cdbbd726c63c828add00895a977adc5e257c552281ea55e494108b2558cc1808645fd96b22df6265c3fbcf71bf12aeeb32e1425d6ee4727a84b761536fb9681d9e4f66843a62bebaa2111fffe1c50c4502d28e0439361adf1b22b6147337dac9b4bd63c1f10c3e3ca8b5fc098cc040944c4f574f3f1b6973a529fcaf65bff5ea91fd69a7eb992ec97823ce491a149e597dd236b3373104874540b1e8554c0d2393f4c1436683a4f27399422a53f5ff02fd72385c76936bd1902d08fb5669a49841f7669c4f8a86f891dae898f46fa506a729f31f1328d3e1303a61c0572a1a00b4996fa0b09287b550fb8aac974198f546c86fce3b1ff88b759fab25988f54bd643f422954ef590c195f42d5c8c2e18af39603b7fb6deb4b1b1f4758b41e24e853038541331af83611cfcddaa0c4f285bcc72ddc847f6ecb954aae51a9486fa89a5204f9396aad0b365bfc80991fd5afbb806529a4b0b6bfe6bfeefdfe332d72c6cc59865b80b5f46c53cfecd598b4be9e33282133729430708aa452a194c9127993eb88fc7f4522ebfbea8ada579e575d1e8fec532fb8a40051706f01ad85df748a4eeee706478537d6218727b1f84b849924e87e5db33c5bcf9c9f89a05546814d1a57d64612d35a3fbb39637f517071a215f5997a15431c23e5bfe313b391020e65fec62d48ef17aea4b656713681990a5d27500d829a5aabafeed11d8eb24027e8f6ad28a0d0eaad25449977f886ea82792b151a382fdea37bf2470a6dfe080630f52482af4f3803e386bd89832228a8d6e8fee3e8ad0d991c90572b84e031798782d40d53176acfffdf377c03553c21076df02173c6e4b3917c4925fe8b36da78b16029e90d86745604a233d3ac7763fe4d6508fe33d7c9548bd7e66849f73099e27d552bbb593fce941d12c7ee9f3a47151bcec76e12f8de81711b3458b605e1016b9e246bffb1a2c21cbc649d169971f5caadbe6b827f9f6ec0e79e30b500eb88e969a374a2658b1e1ec85a6ce3976012ba8002439795c6c887ce468021a35c9249e0b434cf55ad80e5de8e9c8d0740de44f27a6df5ee9fca787806fab04a4cb9119ba03758056b369cd61fdf2673b194492ce20141d83db752b46c92053c53b31dc6d7c7cf34b8705d3436dea38b8e1041f524264e8c9f008300588417d1cf3b3b5f606193314c180dcd8e5b488441e9520a9d34b2cc9f6a9ab2c8234f0c2e2202d9fe04de31864aa9f3eb183469b05e5318f9eef755a0ce1390e2af1561a5580c613421a2d1e8ff71b337525cd92c8ede497f7912d2cf39263907730b17e3fcca6b34a5bcd9fca38fec601eb0d2dca531e0b0a7e9644c79a451695898fc546f88264b44a8495dbd61d04fda846324822835a40493fa8b1bc2490a525408fc0caff3ede7c773499f335ddbdb6c52fa2e18d2fe6bff9301c6aedf79972ca907dc7cc551cdc83f8f3d45087a4628697c4d11fd27d0044cbc29d643cda6e66cebf0b64d5ebb74540a393870745e841d13260a408cd5af0957f297340e9d4890b7c3a008657d8ca8b212f646bc29a5a197df707ab3bf85f30a8b3d37101a33cf26be856663f9c7ec450e8626f4dc5b068aa6a4e92c29721522cbb01351113d5bb0d57767f8cf16cfea94dfdb90f5d36b2427a1235fca16bd4a07dfeec9aa645f7810bf16961afdc8dd0ba33cab6ef1c8bc5106b6e5db5b093f04c045dea5556143cd7d3ab8733619449d9ee2337c3caf461cf93621ef9d57771fdf594be70a0674e1670fec64adc283c83323573a9d7e616f53aa39cd2b3d51deb1331a72702c132db68a31dfb467b6b28dca0c6a494c2b3ede94702f6201e99931baf2ebe04fb9e192e37dfbb29fe25e9609e14c7b7a88bb6940c3daff2365d9b54c3b0af22fd7d452be1d9dba664c055bf260f3ff4967546967499fb2b98af46f248c2439f923ffc021182588584dc364d5a3a3873a3e0dc0e3a45a3341e446b12a114e367947f32c0e514ba65af5b0dbf3b2f8db5ebc8eae7488e9ccfed37e1d1aba2ae7aca5e0955a751220c69dcc28b2e49bf51b1ac8d4b6b9b136cc61988e42cb0a45fa8239f3d867fefe1a8ca2fd6fc571aef1107ba4ae5becf388395038bfccae2c82342e0eda9a13f72d18e5547c4819225bbd427259f50a9d6e2efedd9092778d031cb85ad5527538612b1df3eccc8e4aa462f2a5bdb78dd11538740a5f084ac0d622ef7461e5646642a4c52bfe66a36ceae0b6d001ce4f47cbd9c2e99051e8e3b620c4e4179c220e90149c42b853ce0d728713c2d933b08c6e1c805511b883c53b2ae94a26c1c13e48a62c2f2b631578b3b908be0c58283c99135efec23d23e39c59d019f07b4bed9fb3a44e9f0750ce1e034cca5eab04809016292ca12da81f7d92db5376903838159d0094fbf1da09289641f4a748dc8c8986ec7bd48507077d7bacf2dbf3b92faf3457d20356810b713d1aebb7b0be31e6cd8a3b160843b02463d859dac49c2736683a2761202bffe45819966006ec10d159906f8e7f6429277c5b7fc9f2fba21bf6e65764132e6cacf2baccb40086e2cb43a6aa80c0270442bef4425dd8e5bb2fb7b8124e77a1025df1c194fd313a50ad835fd93f5b808bf2e20625b5a360db9feaf574e9010170f95ac33df2d5dbc9f2fb17b1e92240c08eae7f3dd6ea56df8d3c1da541bfb29e6ea6687a1fc3179ef99b32ad39d11c08b8f93448680548fd101e83f5865eb89d8185f88d4a69b195d65064e32e060e212d442b706a8078d04ff73bb919888bf9f20f275fdac5205702acdfbb0bdb884e7203c5eee23d775e8d3ffe2197aeadbaf8acdbe7746ab5763a84a8127186b8243719567756c89cf2b0f587a2c5b9803ec96d6fbd5b1bb1185f95cf815bd6b706731fb67b12ccc43a33c0ab41f7709d458875d6c7cb1b6775d1e814138b55c3b46def90dbd23fa7f2248977eb135570e808d44022732d4ddb9440bfc907d57d23d1fd74399cd218c0bf401a937ff7f94177a17259db37c685fd9a56b08f32db3df6d49fadd266a35632e2dd49738d5225439d726cca462ead8cc164bac57f81620c005305fc96d91a3149cd1b16816c6401f0e14105b1910f13b6ee2a09c65032ae8f485d7f9f26be49ec119c92afe042ad26a0e57584feb50466b47a664a7e54f4f6bb9396972a90d2b381552e67c926ea85527feaa07b2e547f5aa776c562937cb6c2a450dc6782356a4ef226c43c1dae24e40ce6e629ae5b7c738113ca3d222ae0fff8a18f64e8902209d5b5e459695c66294b0032fb2ecf36061a1d818fa3e5b493b0aece08d9246019802976f87dc09101f9c119efc058a9d82b7c191a92946fa48dae6f166e08898dc2fd0d167ebb3702a54c6a7199aab2d8ccbb0ad7377b1666e0350986a48fe00f2de8e66a4ee53b794e1fb285d2b1b565a9fe3da493e0c1819cda2f4494968db7c079080e7bc4f0c0fa1921eba4306fde35760cf0f362dfc13ae2a0e9bea4ce34aab26aa44ace1e0cabb96aef3f085587dcc3601199f676948640c9c4af9ac54e4294a18969c6760398387980f79875be5d57c1c8a7bd9a781dae6b3be89c36cdfba6271cd71aaa5be7a4d5092559851afeb0ef085f05d569e61940a42b87529541c6a34044767873ba0a2a7da9b8ce1d29beba17573ca6bf2c53d882aec850d96253570f2f23264a3b489b5e92d94ca2d97e5abaead0280c8903d495ab29cfb0ecec80483543bce3352231196f7a161f6d8154308ef3280cbe75deec90e657e7ff663845a351e2b543a6dd5d1b3641d2ee7c20ef1754184ede4189f39053468e81df61ffa142b9375527e37598a80b6e4b3850b21db04ff050f32ac7a897cb1de2be55423fee00d525030c7c286f9d0b957922e61d3e37d035afd9f959302ada193915bb36e7bd07c8dbbe1dc5ef1bf79a0870e33668da2ccbc9a9284cf4dafab23e2e8fc859322333c0a557813582292d156303d44d42f6686c82d96c0bf3351f5fa839e8cba27b6830a2efd97badcd6b3170cc4fcba0277ef4f95a495f95ea3ef7db671caac84c4ef38822e7d8d94b55eef6bd846f1c48233b7d4e08f5f983917246994573e38fa18639f3e635881f5842d32e369062730f7a3b5777dc383977f89c0247f6ba48a77e438655bf6946b899665b1f3ca0d178e5c77999b59a873120e5fea9082ed130e4c69142cf943c32b34b11b5d3b54c9ea9cc35bf9bb77e73a7f9c869674df123b7a99a09c75ad410b3bdfcbb332326870d702ed4571d8aec34eadd70b5ebe49b3ae84cf5afda093e2d83489b59184617a43b15603315a74f84a84e5d74eb6b2dd05e6cf66641ca8a74204a8f2804e04a8c44e8ee27ccabeb2cec84abe784c1a1d2594376811e9f3d343ac007","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
