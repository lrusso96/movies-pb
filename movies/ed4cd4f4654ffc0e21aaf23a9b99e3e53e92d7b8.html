<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b8c726c636cc39736514336a57d765cdac3e4292defaa30b961f0a7353cfc0464afb9aae360e1cb16f5d002672193e6f735a9cf80c01834ef98e3bf900e4875fbeacc00adb84cac3006ace20780ae6c460708abb46855b90be7b57f1eedfc66653b56ba9b500f5f1b8223c818d40ab5f74edabb192d7a7cd4b7d960681728e383479c0e34c8fbf1762817f13bba3deb161053baec0a3fa94ed2426215ecf0fa6729b03d93569678a5d7eb15ab43fc8bb3c8754ed634db530bb636e43cd6ed2db7d4ee1d0f32e41b13ea322ed5e46508d25d64dd204892a3993019881af4d6e7f92a10a1c3de6f91275993b15ff8b278e0492ea51a6a395e3fc6e818bbaad676a6efdc4cf23bab1843fa768463a4e38a1d181d760e4001f1e1a9b87e31169a40fedad5033966d5d6e24c13407e2a975035c254871acfb9b7569bd8f68d31f4cac53cfc47f0e03c190b1367a3126875448e7a76450b726dc8a1da30ffdb444800d8791d082dace682006dd9a59ddc5c9156646e5971e3dc79c558287cc3c7496825dcfdaad8193d2254e300d0df8a761a9eb6a487bbf2de60de753b69a8b4ab1a1b548a4bab7d9feb71ae0d1d34578ddaa94cc9b88b7751e7c56fea5045ee5fdcd6ec17d249f84291a1afe84ff3fc45668d835f1053a86357deee7c6ada60fa0f6d7021c507e95cac67672dda9c64668bf8d46a42c02e804e0af18df988e9f9d56389c0718288648efa3aed7297f14fc5abd45a73220bc286c05897c054935c365d012234e05fd84d8a8aaa44763f8a5de81b5e115b58bb6d777dd993dc68233b0b516ac200ddcea727ee626fb80f66bd96a0511816f6afad915fec7e81855d2b2be4f736a378bb40c34017734d36118d67ae0c1d82f6ed2987b29e3f537742c00afd8b4c4aa42144dcf34398f5b4ef19df41c43e4d101b118b1f49edbb11b8a087257429792321dd1202a33a818e63fdee1c7a7c0d5cc884226361c80d8568b5941b0fede61cb739d4f2d9b1803f4090df07b9893a2a4172d2d13c7bd609d84faf562c55267ac87d1f1b3c7001af0f76607213139e231183e673af9ab2cc5f6aa5b21c675084c43f0939406ce86d00fbeab7a468287e264fefce4d2fa37f43fe7944fbde9d3ce51a6d269239cda8ffc7e9a446cb6f94f291f9211ce8849e5634fdf6c8bd4266f67fe48a5e87635401fe34204e44ff1b426db2517838645aab2c08083e04f14f5763bbb5df3634d0c27bb22013cd1dd7b504f5781f2003dbbca4bce732bb464943b0c3a97cdcea32a8b859463aa80eb26a4a377d5fd2f5d6537c6d4fe576cffde04fb05a41ab7981bb7f126ac46f53fce4e4ca3bb29ec4cd39581445362fd6edb4a2f0c37f5bc5ab0c81dd99bb29ea35332699df54d9c07bd4e64163071c5d4fa22d157e84b4d3bb259b2ae4506aa403ca6f482862e47043a1c54e891c38a8a61e54412d38954f19ccdf9936ca2b116022219dac357319b9228b33b9207f75f55e30a53c0b925eda7f117548795da537204dc4dfaa95a877f09e974baa2c2e4994b784d77480ac52a1dc06d42bcc5a88ca22ff9c3a60b2d97d4181588e1a8fc54795d94c0f350450095ecbafa2446855a9d6f265e86769061b55dd90a58bb042ef47b5e984d089fdccfa3277a93e3a81826f3c2684a032253a73374335d24a4b4f12ca148659fdbb811f207f378327ca43554804dd2adae3948f8f913a832a8c819559479b402f2b5f4a1681d96f249ac6f9166aa5212e823c2fea43ad29080a0b634e7a0bbc0826db4b34bd8e1e6486b89cd9205036f59843ad4c64cc4136e49b93c28274f1f093d329628227065a12c31ab3c5828c215c98765bf1c959172a23f2ca0f3a6b92539568260ea9695ec0e71b0f600df22aa0e908fa20b3435e9b526919dcb65e64459738725621267c5ebafbe26ed68e782f101b566fad4d7af40a65974fe09215f936c5dfa120eeb0b3fff504d9c72ec3f8a00dc88c36b5cd1e4072fb8bd6d650e8a34dc31ca9fd369db0e4b20dc39135449a7dac8d1bebc8a1475cc765cfc3a0965e509f6b93f28ac09b85112d61c58edca818a2640fd044dac18d3e032c47b53aa0740bb8d53b90989e839189066229c8c9d5a695dbc368178f33b3b4ec2ab81f03cb71a7ae683b0a5f639af6037acb83188ecdedb723eda1f5ac1cb2c378929a9d659e93b811083d4b3c387af2cc51af1c55dde8adc9440c37c70dd600c48dc22b1e440b73d823ef47ab0ebd61e8a16034a7193954c86d64517f57feb71adb2d045d0afbfdff8966db3a31fde79eef7d141f2b5996c3bdcdfa4b5b79f01d2c371b3263a87f4486e60cadd9d5adfa1b26e7356cd22e340c48f4041a7dca7ba8a69e057f7cdca1b81b2380668a093603f7bf9ed5c20a67a00d58b98658e4c61ed7e1a56a91ffcd5e69223da32088202df1ab6adc467c153b4a1a4feb704f8a029674e59525aca63586d076e5e1add4319ff502ebb72b00c0b68fc58c60a702ce5c532329d9e4e9da1095786c447b60e19948c536323623525b0c38b3c2c4b0cd9868ecc6f6fe77bad20e3adaa0398883a8276522cc3a428c297dc3259eb2cecbc14a5e82bd4121f93defba0c753c34a8b29e67523e33088bb323fd26115bcb46ddcac0141e37e4c9dcd5782451f130f9dbf9374bde16d82c63a9de8461bf437a68c2b8aae09df0a6547a02c5935b906349f63ce1c608abe4bef09c6f29ce24ea36471fec99a9e0642ed4cbbea1ef6b6657e3fb3449439fe1352f2096f68bc640fc53bfee6cbf4ef3c752ec28fe97289f2faaaadf17962b016b6e7793efa66fe5398b175b631296a5e7541248d5b1b5fb72025ae5954ed6212373a40fe1a4484f44fcfd2edd8b786ecaeabe7ff11c334bae72ab211d2cbf608bed7d894b32ab4a7385698a02db1b1ec952db1d19cbccd98fb961be94ba7b74e96d7a26cad3fe6ed2c3119f58209c5847fbeb3500f32272b687c958e6b7a662aa28b8cabd836af9f16f14d2111de6a530e144c0483bcb13517213d6748a9992355f8d822904b5838da7a617d2a32518956786b7f63a93f92790a8fb1f76c19216cf898661c226a226526a2628ddf16f9913be66e0dc3861285c7eebc3ba238131fb5e6d8fc55893a04952a35174dc01afc8ca747c380d40a38315ed097509e62b907f78ee7f255ac21d4afca6f11450fe6412d812609bede365a8c51fd79491a54cb55183645b923bd049881e0463d7cb6f9c1dd05c529fbd4ccdff3d164acff1a3d6cbbbab1c2d8e37b682667c44e3b56f684a9b9e06ea29f65cb39c3ca2d3f1c19c5b137ab04040d737fe2108a68c01e17cca47cadf432dc77e154ecf990a5a7617ea207993e53eb254ec625c0d4c00b4885ee4bb41ab1cabf5da657fd7ef9c359b279a39d5cba565c8e8d0290fd45b0535c16749471488a08ba6102dba2f80126f7995ab2bfb75c3d0d77e873177eda408c0354bb10981ef3c2ae39f4c1e930bcce04469dff1935b79aaa03ffd9dfab1935018a509f51ffa94d887a6c70d3780e73e9e2950c5f85d14d34239a23ca2e7ed013f4ebdd3d8e7f37be7f59289c9245c80f8b608ffd8c51ebc6514489c6933a1fc6e7ffa7026bd83ee8c807443c07d564a41b842a45cfabaffa75fb00fe84de6899cdc5985f35f85abdec6c82d252a77a89db0aa129c6e78465f7ead27beea17c7a92a89702e9934f96b5121ef6a3d3d3e138fa2548ed622b0240474b968014cfec9226911d8248e1d4e3625a9de998f3dd53024a3262abd4272f84425b5f36068dbbe2a16d281e945ea58b173c0fe4bd04b7d024ea1f7ef8e1eff15e88dd31602cd95a3397cada7d0eb187d8b45c86204245801a2b24bd79875693426cf4c98907a18083ab43000ec140789776e45777cbef94082a4ad86edc47203c90b2eaa46f9b35573fb7e1954b728835481b20bbbc67820139cdf196418c18fa448f938271f69ed9556a72eb60b6ef689d11dac48569366c0b36c71720ac2882c5e18bb0faf2246b7181eee97d880e284be1e1413588cbdff679770f134a135d8e97b66b66c379d3470e447587a1d1be09c6e830f8044d45d2ebbe1021e4cdcb1fbe8407b4abffeb821bb3c4e83c0d28f025cc384bc43d6d08624cd6f74007077c5a963718f07af2fb5f16cb0ff605bcc5a76b4f74d63390eb1536b26f4e02cf96b85275f2b2ff4d84e2c9b6a19de7d864c8a9ac873b15eb669bd2837f082c1baae4ff3b19bfadcf82f35e5c66cce206e59e8dc65f550d0144576446797ba7e4f999566f44c6e25fb9b5437c457623a0d24cec850e855e2ea7eb9bcd525371bb657b3cea174c4da653e0c2ab67cfae2462a798fcdd6178873afe0adebb3ebc6324f982a9178e924c08549d3347b6673298f2d6a9dd02ef8cff9e3af2bfaabae98739a31d3d7d767f56cd86e43fb6831e3b78a51201a02cc55e764fa5a901379d2a70d349d30620e4ef728a696c921c294cf05c2248ddd8cf7299baa43ac3845f34f9372b4d68eb78e12af35a10018b6104b805c3cae1bc43ac13fcea968c163516872109545e3cbd25ba4af96342ef3514a2610723a2d4f9a3146ef00771bcabbf87b772b695c04ecd96a7923355b02b959f95f90f0c0efef6aa20151eaeb45bdd1fd1ad59a6cf73ef7debfb28fa50d710c35d36fb57660da32242661a26c03e03d018ce721a742a1816b76d577c5def4bcb930b7e51abce5727a21b2f17b1ed6ab11759fec95b8556e8cf1a2be8a05b81464f845981d6687f80b368e77536b8a77e1683dc65c840160dd337e11ec56333b6f3fd064497d3ed9b5305d97644b430c762103721f79bbef87f830226ecaf121e0714505f05b59351ddaf978a40876cb474a3cb4e6e94f8b0f05b0f5d4b29bf7985f6433b5fb62de72cf05c3afbe2e3684e77a3414f4f8559414f2b11b56996e8cfd8ad36cd53c01d480ebc7222038ac9ed4c38bf24880a8dac4614484c0e30582aebe586ecda7448c6ab49b1dfeb3f8d01bd2209d62eb918395476f3d080df589f013496bedb9e33878b93c499c79b479cbbf601fac39fe35ba6005f242ffa93a764809cdde43973ce6ed53a5d1e0c02a1b278408de32cf7cdb9ec2a347cccd53572e57b77cc08099778c706c1d231c23d53a98a0fddd727dcd22a7367ee8d02dbeea246a533d5f43f586da5a3cf683f09f5916eb98b6bb039d638b254041c51f3a266a2c32524568e546e007333cd015917710b4dfcf053f655eacb90d72b5efb0ee68ca8b92debfdb07df36aab700b195915a3edd98de41ff4b08d885085bc37bf33ce2ebee413599f6570c5f119fc7435c0242378223d0017b3a04dc7ce74e2430a5c668688ea2f4a2c4d6a4fee35d7a36f7e7e37bfac1319aa9901440f2b577ec1d8e4db3cb676c0d820915e1624300e4d7c4b6b0d3615672f47aca02e794f4e96a6b41991c2c26f383bbfbac40342e2d861180683155cf39f5bdf4e8b4dfa78dcffbc3a01f7f5cec565a98eeb1d9daaf16b7b8710d5ac119851427561ce61bd6180ca3a59ed8dbd41a1a3d70da33fc72e8759db0d21f1c29a2fc7973aa4ff971d61a582f0f5ea7da9cb69c012f74056995bdc0fffce67f21b199b5fa2134b9566fbea590bf2df04efa8447b1e5a8a14476ce1360f7c9b4d938c58e1d6d0d528d8170ce0e4c9eac3b6a7b81282b75bf97f770a1d5238bdb802978b11d7fd94cd799cbd6b50da74e79a7cdb75b9d92694a9db8cb284707720f8a630b15a172d651bcf6042cd3c189f28123052b5aa3b8400c518471e775e0150c21a3107bb03fb30e962e86119214b1f4d63cfa5082a46e1e1f15ccc2817162fe261d1c9fdcfc8565762bf4269badb807f6a8995696a27d00451cd84dada665a9267a1fcf54267f8f7a76e5001dfad2a06e006fed95b7dae5ace8239ade092bf63753d7600121951a20a286605bc31c58b3b7e76f4698b2681fbb9dd6f06cbc6b422527ed49411eada448567d4b281445fc97c09aa2b38cf5ec72711d8d10dc512d2f50091a1db5f10fc08594f488f77ea08924a9028bc451ed33e6de6f38abba256c2906926c06015274fac8b9492184335ed99f640358c71061493959547698b651dcb2626c7da1af2f2c3374f98f82d7cad4e5c468b312ae10469b66c9348acec7513782a12b386b975251cfd1b44ba7def72a517132718cc3df8e7b8c517b16bd59ae47bb7ed45e60a8be1893df71c966ffa4d728700085ef66c458776cc1cefe241300c6296c243b27af0f6f3c62d37036a5d146691a584c283b9d3a7adac8a8b18f324230999f4cfdc3b63a82a0efcb3dcb3b81e9f86c0520051b5fd875b358fa5f4925bb5185143b57ce9456c2719cfc63db2efe5fe05ba0df485d212e7ae0fc32da5c39df71f9e0d84cbeb2127e8ce00c91f2d807f557fc67317dd88fd7dd730180da36dc26d3bf7719262a0db22dc26e9ca416b87ffd2987f065a0b81bb9d139a4650a2650e3b59aa3273e72390218bec8e8a7c4ffc522285dcb8ff72b18636161c6674d1e65e1cd8980ac26ae502ed735cfd2779ff31afc44d3ef03bfcb868dfa612c72681a69707f7a33a718c1d5448d021b13f9bee2ce7c66d15292da16819f73cbe249e8c9bf61154d59e01063aa939ec6f028e8b0815d7bb2d227d3e6c0b3f01367a9e256095bcadade991c3e98e218514d68ff356e66dcdd8e96f15f6825d5fb330822fd28e92298199176e3ccee792eaae29f2d9af601b500c4aecfb4aa12e5bd8ffa456c9c752426e7977eab8f62ff74d2bd38ab4c53dddb6157a3694ba99ff890a8936fb6d70a060619d7c84f6690b63ae5d159330fd4c35d8d81f126fe082344fac7cadf9a35188378df35286b18dc3d3a95999c465e427ad8a434045046a157dee3f973e214010649515cf4e4f877827bffd4b051c9f915b6e49bbe5a6c67f1b6b690552df865b93b1051dbe9135cdf005176c2dbed3f36c77967a5f01e28855a73665fe992831a3c2fa03667a67f74d0fa06792973ca76addd1109670b215bfc9724a9e6b17e3018d7b2855d99a47111089231cef4c528605946a289763fb6c68f6d9d9fb158967e2e8615dae2b1ab89413248d4a0f7a4fcaf7bb1574451567b2136891fa5bc7fe99235ac09bb0b6c856032318b960bbeed3b488cb4840320ba5e4be3cf3a68a4a758a0527fd48f30076108b186d14bc1b811ed9b0c40aff1b8664e2a791f661b9b2aba73d4746adde4286da9f67d9f1b4905d8bcaef4178ece1b9ad45868add1a6da728510591aaf8f1e3a36d4556b3806ce365d20a1ac42aaa53d501e70b0c23a936d7700a1b3dc64214f130b20f489c7d7db075505c994972a411f69284f08ced131d494e1129a85e2e1739b82f6100d52d82123374bec8b24bea9a1bd8826fca7063bb683cca7c336821c36fb17603dbe1ca4a3b2df315e02b72dc5c1cd7132794f1ec18cbc9988ef45ed3845c2b0792a5b23ebd9cb30ca3fa33e9372b928b88d0bd0a01eeee684176e20f3370878108bad53b88a8e3fc7b6f94a91c320d34b2f23e190ee0f82fe58c5191032dd39d0960dff653801b225eda72faea1e530bdf07b6c9bc4715628f5f882f92c8b4662d13901f9fc6c771221f9d9ab695be77b9e88da591062f4f5149421b9b509e4baca62bb98732d58dbaa7978dbd4b8ac080691b588c33cf0b37e0d36df9f209209f40c140447cbd394896625a686364c0ba7c88ec5b001352dc425c3dcec6811931740f72b95e3d0256c0791a84cf21a1def93601460a18187b7f29b296c3e74bda186dacec5a57f3764ba5d647b365c80c261df77e06e43b3df295a8f1c4cb93422613470386717c00f094e675b7742712e3cbada4e427d188f5ed9e504cb9427c2e5d5507361ccd7cb174f9216012403c36ecb65f22175da559833cc4c53da2e7c4e829bc7886897b8defe3792eb71bd48daaf24448f9126ec94c73795291e5fb819a3a8793aa0d80a680016846fa9cd7082118a114f4a97769807012411b338cb8460212374096065c267d336d07376efff46c9d91bb1a35bb0de09133edfc2fbc2c06e5b9c1477c896434850b04e120a8c0c81d333f4114bb6cbd0268ea77be789a9ecb52124ee3873ec408c4149dd4783fc41134d254db1b39fd830e52ec970987096528e03644b3094e34e3d1f8f3604df94882601ee0c2b0f4cb139db106f29728c9a03e48ccabfdc38d3b0a9578f583df30f0b3d551ceb09b6b70b3adc3ea88ac636bebfd9b054fa73574950ff00d4d3364bc0b939029d1a8a9278f3b810d75dd69bc8d3adc09784b6a05d9faedbf7533a4b8deaea8834ab2a0d3c56090c7531c38c5a31c3dc0ade70a0f217b7f57c8061766799a474135e94e8df125afed014a0bd663b2a8b31d6d04bdc11994a3dbc38883b07d550fce181864ce0aba432eff8c20c3dd7719fa5cdd06ca061b7472c1e93e766feffb50c62f97e4a7fecef673466c1660b059d8f702e0107c082923e37096b6b7b990e619b76e5e25bde8ad64c40db4c260d7057f16e196d37db495506037b127bd895dae2b009e2ce4b801f9036d689a5ad8675dbe5012ad871942ae1e21d9824b411057c0ffc14e4701e6dbf33765e246976a2e9f57b1cfeb7f6e8542d8572b5a17ad59644b1421fbc5809bc08c02a98a04325b23f7caee414f40d0c25bd019d0eb67f692549c0f68135cea7fc93f38cda051b832ff1fbd854551c035b1f1f6bbdca0723bed1321857621f1f1d31f36697524c94c62f8fb76f7264a21f2a0050d4994f8279b2d4440374f77c6497da60d2f554c2c329ce8a2c5bfdb86d9638b7916c0d90cd3435951a97b9b54309708e8c2bd9376cd748b9b60008cd01a69aae448dc5685ea80d6b0517259334170627b4952fe5daafc6c689133e18f15006635f4c9dfbd2f550e2bea1617b4f6e398f280eca2bd9012ffbf33c9bed0453289fe78f39d0b65f10c7b559f7e8a90b48f0c97feddebdd926e0c181fbaae87c8efb35c5fc262b0d1278582f4877dca43ebbfa1b92871f4b5bca22fe12ec23bebd1a095c13ff22d3e661bee25f69b96159bfdc6de2404b77c8226d5e044c1495c686fa69d88c5851fb97e09d7908f155d734ce47ba00310744a1af387dee5d849772a5bab03948ab55b9ecd4569a741238e2327f0145380be155c8fa7f8f59e2bacd2209f4644418abb8b177fbeeb93c95b60444508ab72bc5dd6ef05d18208cd790f2a2d6fa5e87661ac13efa874578d5fceb46ace93a987810af6a21d3ee69e23e79b13848f05f65d9d9cf2a9e5055e048573629fc038446dafb50123e9bafd6417b4d06e537c4d8e2d3aa7e8fb13b03435412d097e426ae66a84c99857ec498b08f76847ae978216ddae86851d9280ed5e83a5cd82d7e3ce9a7e9395823ff35c46611358a42db9a8fabfa6d40dcb2fca2919c2ac7c2ae104c9e7b591cf0993594e0e3d573522a8146f2827d45bc5d2c546e5678cb2546a71c4220e8c354aa80c243e2d4f962b36c7b1167080cc6a5c0c5914253a88a52269c6fe5f5ac1d8d6eba3838a80332ed3270a72ffa920dfbef553c5be2d487d7bbd7f6fe2fbe5ea67e8cec6df62b81ef06a27e37224c1c31d081f30972c86227c6678ed8e9553e05745ca3aa96fea49e91a90a664e3ef9d6fd3604e653bb28bc0a879a777e3e827cf90df604c6f3d2c7077161c74c60ef2c51bdea2304c6152195a313359478944001b4b5fdcb862b9ba2b43f0516aba2cdf0391d1929015c1edbe2767d5b2bbac6b09a4aaa2680ce5d19b4772d78e55a1f440a1a5ed73adeb0b7d4ba91d61d6b7bc973ef3c24bcd9cc62ddc08f26c74bed19c956ed840af2402e90391997ecff6499d94a915a53f76a6de38daa4d7d6ecb06759f397a2a5c97a2093369905be090be2d194844f30ff10f84eec28c9414f94b94921c9a0e679a9469cbc1ddaa473fabe0b376132290b9d6c249188a4b356bb99e034e9f1575d098b1491a520c52af25aabb8c8381cef9db80d7d634a6e803fe93d6290598539293736080b1201a9a9512ffa6fabd1fcaeffc4f022809bc4781d5e28be22a5ee221f7977a17521960618889f92e494d4d004d077cd5c6ec027dc004ebefef84281d6672eed267aa4d0d8101760697cb92321f45028840415dd09c9a1e1c43bf14e64c00feb2d6c9f77a4d81f9ac7e793aadb5d4cf2504fceaf052598ac3511d9d7dc1347c4a14c6c884b871b4ed6d76d3ff8b555f73f3d0577015072f94e341391842a4e10044e9736cb84a2bf4adbb866898b2622c730a1d360162177e1819abaa85d80e605e5785f86c9b23105f2fb1e47413aac45076554776c927bac1b8de5fe70c0eb5a00e785070ee0e57826669752927d0cb19fe73fe790a53702196482099c5c93198e0de557900073651699b05bb1683c461a0547030df3a4188401375a5592b119b3d3cb4880eca9dcbd3cc7694a490c45bc98aefa09a899a46c957367595f90481e678492d79532e6b82e2786a9f8bc653e7541bbab16629b1e26ba3b5f109b3eeac8493431ea63a4bbd5130a09a3faf98f7da1132fe8ff7b9dd34ad9d92c916f11e8cd1d1a6d232f43562a5e5e3a698d3afa59b10efed1d7833d8a17a8399030c83f44adae25430d900847825a2accb16d04ba31fe3afb4efe630eaf1bc09130936932db5b6d220f0f7856224412d9b6133f2276c175464650d680ffe32a9dd43dee0c9638524b3649ba9a956786698262c7a571a9df730c230998d3cd52375939dd9de1c85f73f1f5c5600f30189e819d0a855f39b6fb460c5d3bbd184426168377eb6ba15dddd4835f866cff8e1be5adf34a7effe7c9f4d7b91604785b13bebcff0af051f281ca354c6189cc2398822f2a5960201059125559b4c878dc86ff1e633537a9781c62f7089f5dee133a363a0c73a6dc1157789ba68ec1d931d486f83d0806dd56ac2fa752917bb8fb7195842cdcf02dd3723e476638d79f996ef1c65681b5f0b056d7a7d7760676244065e549841e4d1e97574980c557bcf20a4bc189d6ae075c005d592608c6f0e3228707b255d23c2d9e898d5f5a8ff553ad90a1a2e552e2ddb5ec306590a3bee68ee5a5d8d1cae9888294bf9f1cede954e0f61acae8a619ad2e2f1f8dc815e5ddadedb655ae001047ca398d455f2b67db8d2a54490e5261a3c20a5f4966bada8c7018cfd38c84120e08b7a786da73fdaadd7aa91eb05286b3fcae1d4318d11ccf1237808eec803028a68bde5f03f63841ccbc2b37e1cc4e38f088fa958acf900ba018c63e8f6a431d5ad3516062d6c10e1b4e8716014f233974f64730c93f0d8b5a597cefb88e95e0c1c1f119f1742e7366df204649ea79ff2913bf117447885e8f80bd8f789e330d2404a702b217a504fc722d7219438ddcbe44af7abe7765c1569bdf459a7569a9ca4a9542b01f33bbdb612f09fc882580052cf7f4308ec636c99f9366c37dc77a550160cb8d89c4e28feda41a6b9919b973ee35a6b41d2d6464340aae6d1f7f71826a7fb971a601d135a7cda2595da2656b3a29298b5291b145e95b12c0e81d7dd55bd2a4b0e4e6c73cf56e836e39123b1667d9564be2b5faf8beb70af98be19390dc8d5235f2de7c280937499ca83f8407b5f54aa107a8c98aaa187acf0eb7f2b9bd6c275d27aabca0e9e52517fc67b90277b3cf597c4c8bccb07f906874d647921bc849ccca94a2a3fe02541de5e428b1974d7e6a96b3293066d7833023542b500454bc9a7b76a8244d3ed46ebc860ef90f3ec0ee98a7b4ca176fe3bad0a155d753573df60666a5fe8e48b430a931fe2c36b71c0194dc3f479ab473636c27529c879edc6f62d66071c6cef5926cb10ac654d44f967edc69ff83d7a480f8ca3ac6ce71336e3a4199fe70754ee2fa98eac102b8048bc3a16f0f3fadeeb3dfc219d682273999c615b7c2c993d61df776b4d96e82be764754b3e7e4606b8d2b25406224a37f474fb9ca3b196f32137b3dbb22f353c4c7cf33023dc53eddc87850395b369eee433b57592314f3bce8132774e1e9c4477b94dca3aae51abd22e89614ba62f7a76602d154b297b0e441a5a8182c396b6b50717b61aa9408bc9cff1f61955ea7cb23d7ccc49984a7b2adfdbadda6a5e3531e4a05cf9990aee14eed3c0fa0ec6c4f6c6e8260844b778d6d49265fea4d275c08088ce5d44f9a7227ec8d874cdbc32f37e9f81c19a27dad9abc41cb45b5621f854e645344f7a7275e2e3e716d0799df53ac790500273b5939f679e9f5216f6411b696ed246742b7711880873bfb2d82299319521f63d11151c6f4aff04136579517d9deba8cd81c61b582eb49a3546bff08d4219a22a287a6df51e01d635235a663004f7ca7b1f2d855bf4cc95ce628c4206adaf421252cfac143941229c71c6bceefe84cd86d56b42b3ca33c6a46237707547ac8187815e8e338b3827e4a3333243f978845dd41e6670ade2189f791c31dc3fed832cd143ed1f7f6a205e4de3eeeff2e1adf3d15f82c663c9be21e21a564a15e5cb77037a1ee76e35a113f3f4b4fbd27f06bc715250ebb7357335a09e59e740089411bf306e4907d6fbdc7e5487735f2d18567758a02f3e11e3418e93aafb82da06c54d689a754a2f7ecd454bc497d7ddef890f52c862668f624717d5ce09435162def8c8e6e6b09cfcea3ecbca9fbcb47d4027e4d212427aeedca10cf0d2657ab779b002df0ca50d865dbd8a04a08f4d6505342b07d9128fec591197e1a2394eb7e0a4e2d7c62c3c06e071b869972ad8ab48e36467e0ca40e1f380bddff830684df86aaf83bf200dfb831635ec71f55363efacfa52761c0c29e2b85f063f5197a4c8863e063ce9f88622fb927d035e142d8582aed78ae9dd4ce85272a8eec8afdb493c6682329445b3d66068b86fa536ebb6d76b9adfb0bd7b7d8032bc6b2fc5ec338c2ac0a4b9cfbd66ac99b8a5cf4f18f6271b7516ac88e3e8f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
