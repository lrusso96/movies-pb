<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"21fd0d7d3fb076b0d57ac47e93f2afa98a9dde41c511719c6f4fa84102ecfeb8b1500ab751d034ced9b53496c9b61228f6505befe6eb3339c0662d918c284c041636df5476437e6704bbd25fb79af3b98007d29e22b86e17f1d145c7ded39c2eeb66960fb6d6db5d21e5b0a0056ed34492599b6bf0e0d1dedc3794efc4cf044ebf7dee87f2d472106ac2b3d73927e33baba530bb687a91b4ba4bff570723ae4844a8c3c0e509e2f40f663337e1e701be06bb16b2660731522d578c46bc0fcfbb31f99c88dece8a758ad4c7d49ed7f8b0c39b9ea6b7b21ea5d8b10a01ddbb9aacf0107a35d0b76895a1bf0552f9844aa80afd8b83df7443d8f8246791bf31293840db8c99c1bbbb55f795ab20919876894ec6a8a82439565eaa4fcc4c95287c44724c12127fab298cba2eb4cf03962c72db2fdec5ee06454552acb9e47f2a85ae5de7c863a752803faf51d081f18c8ddfaf74543009b665578c6fa1c1d186b5c048cc308ed9ffa5b4033ac4d5115bbaea55abbccb0fc2a696eaaf58bceac1d6c779a9945b24031df9d528a325ef5e2075e9ce117a0e346c07fb63d7d8c3c4b761c20afe35450f3c415bf657481400a4ef7fbf474943845bbd416993c008fcd101af39df8460f9c9d8420befd7aaf5a50a9e29e0091ad81bfbfa9272aaa7297e7f80c7e209ddbd4eb74c29741ce449894749364bbe59627183a03d70ab6a8f77d0eec6b2fd7a4bd4907f1a97d72517c0e64c8f0e4f323d75ad89d4f3887011253800125013db7d80e845b03b692bc414b05e7ae6fefd999a04d72799e9d9f633c01f4b5ebec6e9f81579a28a77867d34af7349ab190a2ba95d7f2c03f1f53cc3da382419b9b0d16cff83c5c1b0a7db6a2f3c51920b31e7663147591868221d1ffbd90ef05ba97b2085ba2a6ee2ea1498f5729e70acbc3458f4f7d38f190dd34564fec11da15fb16b2318f15258e91565d6ef9d086c75f93d174896830135a1dad7ae500ab7d46d2045d6304ea9399c8286c30a0dd173bc9fea56bb9b7c29f0a396a3c1bbcaaf7d0b8d9228fe568d3858ae63337adf43422d24e2ae704e3e9cf0340cc90731018f7f89e4ce51bd67466b3df5c0ea2652319b13ff7ae74eb1578fe2a45d835678c50046ab2d0bc7c635865842fcee074202ceaa278312fb2ffae1ae99843f43a78fce5b344049a94ace70f62dd6232a54d76b9d99d12dedabd26bddf8a5707de9ee2693595fb036209e9c1c59166291947cda200603aec12cdbf60add12c60a87869433ff704234828caf0a4c28c76a566548abb38da3a80076515fa9a48b520436a6d1f2ccdebe5624ecc6f51015d1e667f1a5456dbb081688e22bfdc31da1d844f546bb8eacdfd61ccc1988a2c25331bd9a322924ff3bc7a10fede7c0bf9cbe71985e3dd5afc60b9f590667f514ae1258d559bcc22efc82c2bd95b14ef75d92d35610b32ab409ad1de5ce68c7e548bc636b95703952f53ba89611bbf3e0372a613212ce05fd0083b64391b4b1730f6e8cefc0e84faf593c53c6745643d532c00bd2153a62597a35a0944c52b75b7cd54e8254763213ae29544ae423fbff394b40d436ef5adaf4f13b5b6b366f24bdb04fff529b8736d039310e21a4deb13d5ff367cde7a5cec50fc3c98f38b459db3152272c71df47e7055f4f3c43493af7486a5b855819a099903dfedd3014a228de4a8f40c05798a1057961dee3d55fe783c917c38b18f3abfa5d503791378ae68e3d55b4e2d53081b8bcca9a439595d72275260ac0d0c0d55a17a189abd8973bd518f87c14a9ad2344e85385059776be8e8eb77cb095b1f7d3b774a5b67ac106d687a14955ec0793a0358c711528b66f05d46bb4229d70ed7728cccaa12e38f8960205ff9a64d15a8934eaa4662c120383360a76a8218fc9bf7e1e5f6e8f1f6db2d9946c2e7f1e5f81e3619d2fe7a73a90abfa25c5a5f1ad041b2c82fa0ed6b86a519849596998cafc9ba012bb675e0e991d091cc5b0f0ea9f2228ebb50ecc29ee4e588a1d9366f2fc0dac73e4e63d517dd1df0e817578a5e1b770ecc71f61a34e74c3a4d337e21e44149336e3b0450a8418a0a67ceb8667f98f9fc363679ca12b56111de563b1daa54e7a92605d34c42bafe546d428caaa9b21a37a9b44097c6534cf6b58ff42d18afa1a965cfe17e4907ca91d3e166080152e46bb02dd55d3bbabca0208b2e1500537a0704f4b2879f57b3b0cdf98c653b8e01ee5acd34fa0d5f7f999f59181758059413891ddca6138b5d9f631d23ecc73c85f7e9f8934a856243565ff5e40b90907d0e1809cab7b644ae2722b80f73d0ddab362e5c562b782faba815d33d2c86e3e289eef6252031b9843681218bdfb747d630620fc4f39c4cae19baf3844e07cc79ba46553f6d18b2b77e826c3386c3c8ebf279278e6a8f447be1dde395b8b050461b8afa5572e3b9502989701d2a7d93007b0c1a76073caff6067d4eefd6808187f5b8d0bb895b684c802941fba38660f4f3661454c50936bd6c0e61902dfade7e1933215ff66e35d7d04714d56786b073a454beead620af9870836995f82546e93e048a1aca3b68b2d78eb0b46c9965cbe4ca0971ded91805376fb46644d0aa2a0d1be7d4b5621a9c540d23dedeb719fbd74f9f4ea20a3358b5f74e2a63e57a918af51cae933bf93819c7de80be2e908f2cec582eb2528acdad8989ea0cfc53b715051c3161c84db082ccdc83db93df197cf7b6c289b24ec0d9d82b76a2cb5fc024129524cf8dfb51a741c655e02e3115293c05c41a062e664a550c8c55aa4b0994a117047ed7df310ef3ceabe3e14f2c461d7b5e0ef10a8c0c928af16551da68692406d33e4bb6398dd4506a352832da5818ac644cf06e46767df37e0163aed1f31828d08cd12b7c6f7e2fa38062cc0906146091611bb255bf46cb1dd58046f68d86d1b2959e7710ba63e014a2b578ec7923d20838d3d04dcbed2a45aa274a341eca4c954234fc549938ba3fe742fc01383406bc605f802313302701da54138df87e278e95ac91cf3c5765cfa05dd132810c4e2f7f52a474a3d03881051cb7b067b2f48264c042d9215409314aa1e80721e6bb043c4a385fd45c19030afc1a0dffc6aeb2e8b10a1b3eee88896314a0b07e58ee79465c090042da483c6710be428beb0895a69ee05760b7130c19cbccafd8d49337caf4df10546f24e4a206c963023fa0df0f6d062c2a5e0d5419ec2a5317703e6746d5249ba411087e40a33fe18040e50651d74d01cf9a5d67580bceec066bcb51dc43e76e998d23fe7d981401f433e32971eb810696c1d8e8a36313815e98cac2ff2e24a52c137d6b2f38637f7bbcf659e5245d445f95f9c2e79e91d4c64ed56bcf99a52ae9072161bd95f3e8871e49d4d1dfbb7470ab7626188bf6f28d4879eda96c3d3623f2c7aa105c65d0964c8ae837f0d3abfc2ae27ee836739668c425584e109d6e5a6cab97add52468b4e6890fce6d5d6d5fc8cd414abd7cc4641b3632704efa07fe86db4e4c18a4a0bf44f523bc531ba1580c3acf786e529e92ff538acc993e3cd7504b7028910bbd3e7bc5a64132bba7c335a319c57dd7a85550fa25ffed4ab37f41f458ee69b3fd7fe669bba8d52cbb57d1fc77073704773622c7ef15bf441f0396b42392de4691870ba921143bcb8fe7a86b8235c71c544366a8107ecd58f914c81e22c9c52fddda3cb90ebb5b0082dc2113cc729a42c21f9051bf12a6ad1f495233a40fa33c8294fad1c3bef4714bccf37fac40dc93040b485bba413215548a92990e7cd2d12e023b33c661c13b40c7289ab9a7e1a8350613ddba19d68a80aabc76b0519f06454ad87925e49740738dfdf84a52fb1565d0382795be1806346c3106a0a90c6ffe80740bad329b70167734b3d78934a14e6c9c51f78a6bd791eb1bce9f8ca1c90079012185637aea7fe3e81e39a68de30a5d29bc5aea7ecb90819024a4e2a152c7d9561501afd7c54f02ebf49741e2ba0953144c95de9cffd7c124d3066a27ae4d1e51656dcc3d83d67fe56c514e691293557f518a95e71ded9ad837cfc16acbaa96ef255f551ca3fefefe84569554ecc334b62a6eb866441b0b8b14cd3ad7caccad8e7f79cb62533acf3eb44100c69107047f5ac36c258d3a71800f7622b2bea0eb29275fbf1e195cc35d6d7c2802c02986584aaaefb4ffc1759ccd58ad2e09c873d284b612d0edaa3e198dbee0cd133c83be8f2e7c1ec1710bff5dc87e97795fa03a93991b99d73422a393e29d2635dc5fa37cd630cf8754d171f0452884ff2a12caa0068c58375c2eaf7b90a47f4a445c55e4f6290aa58e8e46aaf910080ae44bb6d9e7218d1dffad3ec5b2e7532f91c98632d5baedaf625db003a467a611b3c19317ac6044240cfa0ae906499416589f5e7a715015aa640d91889e6d95d3b467e9d582f5b94ddad6cd9f983ad2e294b5ddd6663b6a1158aa5e08861ec91f595baceaeb23a2442cddf5571876d3aa5014a15167757b580bd60df7d64694c9d26d5c49a0e394a7538451618e3756fbe44324a0528ffa3d72335b002e826ec6e410f02de580a79f466127a127dcf216446217659511c89da6498d232720f085b174617e934ca4a3814d977b7740d89107b4bec9ea11a14fd7a685d30e56ba81bb33ee3fbd324262413ec9652839f561d98d1404388eac628086e57bd328b94795ac2054d81b1634f027a027e7057118a960cfc7fb35ea42ea586da01528db5eb1df358d60195331955c735b480392dc615fad88c9064016cc16940365bfa1a0bd36d1fbb2d15381ffcfda38a3368f508af3ccd9810bae03a9f7ff72b94364a64bac4d3dcb12ea2ca5af9aaeb640e6928fc23b7a1762344deefd67033cf2558e54f15c9d7f3ecdaed79ad342123c762a6f51731169ea690470c34587a35e0cb6702587f4e523fe873b813287370e0d90bcfd043e3139e961051b637b82b1972069889880dca14fe8552c7b574ba612afb0c17ad8298f7f67fdba5773ee395ec7c02e5f992e72d43c6e9d9210c94221c156ac246d333a8a7c4c79e5922a70e4268b694d877e3462a929939d2fe7d4af0e13f1ffe0b41d23a4ebc947132cf7302db5d1cf6da819dd78bdd6bba0134299c53ae85a5fe92df5e3631a459bf2411e4764eefb3ae49106632bf12d7bcf7d05709423f81f8e075ee9149e2a042706c48aaec5105370b9dabb98e4d5dbb55a51356c842893779cc908607daeabfc1e64b5b48a947035d805fdcfc7dbb14e10bac0eb0c60bc7a5ab798f195ba76e8d447e93d018954511fcbb578fdbd19ac4303754d4885ecfb10e670b72960a2b2bc1f7a3c3ba7d7c3aff1c745c15fb8d34de074bab543d36845100ecd826e3dd5a2c7aab8237017f9ca0f8fd5d3a319cb1d4b7345c184d2ed06f232a833df26fd045681322f06a801d9f0242e1b97432fa004c3da311daeadece04d54e34c1586d1a6c86075ae8675fbe5062365aeada556f22b6d132c319ad6a0e390f81bafb380fd89b7e185b2bf2c809819461a758512eb577742fa08f505c4b5d36063eb276b867d299bb6c49d4f372136a1a9c6739a673735111df7e69b446f16df877c4d42f1485153c37f5d94e4352c2d8164f65e3a1accea3a82e336126806ed54d632fdf8a2395d48504be063720411b50a0820939afed7704d1831bd7ed41cdb80966867b44bde762386a2811997c846865b5508ae0071f50211e6102eb9dd12ecb6769caa388e5cfcf912a20b935c7111834b9cb9d3916429fb642de058671e315cacc90e6a86d1acb9a1420f7c7b4518491055a46c3729bb9c53c4f7df9206a263583f009734b5e2e063cbad0d5fca57dcf446106cfe66bd852249a3a22059cc849aa87028c85482d198e20d50ae3837920dbf0277cd97b281e04270fccb2c8f9ea2eb74b0c52e4092cddc79bd8e5761c82eb305abdf24022197c1a3b5f88c50eb0f4f96a3c8485ffd1a9ea59cf20983194d97453304abe7b70bcff0e65297423a4ffa664f47547c231dfeda285df58d657af4aee84c89f661ce8847aeab6810d95a38d887773f7cbb0db11e6a6cacfe2fa66d74cd0f02e2e906ad7cecfaa496fc6879ac5972f3068c1d507b153878c804d16d1d36842ce548f47143b9ae850db3da614ae56adfb2466a74c190f014e665a134e0db7d85fd32c7ca9a34e001c1d86b2f38fc15208790bf76a51e34ee9f9685b142dbd6bf511f3eb4ed16b43676aea00c6f593ef37f36a0ba5bb1dff02739afc95a2cd6b2285079a96503917eefa0fdf1f20196dc1ecd7abc950ec801feec94036614c5c52312143bbcdf80cd06683cd1a12ab4f4445ffab990206cabb198185f72dce0b08c829ff9505003729c4444540b5532ea9938deab9bbf62a8b8619acb68741b32d3d2e605653c057161f8f3fa90ede8ce9bd85e5b590ab393a46db46fb828179f3eae7e82404bca3fa3dd484702e4c48185885bed84f641441f3428c7a920517c76b97d9105c313a3644dc930bcd132b2cfc1bbe7818f58b276dce49b8c8559275a442433958e0284c1c2ebc689c36eb058fe5673cb37b42e37b379fc72296d05ddfc10e12936011934f4cefdcc41d7b1de7475d05626cf4ed5c1cd566b78f9c7a4f148edf51ce40a38453b1cf3fd55119b9d109d66152e0c1e8ae990c6a3bb3edb4af2ba341add28992b41715781ec01732d2cd66743fa397f8f24b2cf8f6ea05e4b29d636cd6c7dc6400f684c5d1525faba9ba4675b2d3af746ddf6b08ccc18ee96a9bf5148c12a58ee7fdd91a31d7a4d54e45dc3d565a4caee7c34744ade4b67a82650588d09e57e7988d4a34f672a8ced7c1c122fa2091ef367e4df24c597a65133da3a1a14e439dc25db5d6395c5c8939ff87db059cf328560292311b10db2418084dc1149321ad30e5bdd441bc68be4afa4d0164c199394cfadaf74342e2f93ca42b7fe3a4447cfe2e3838ecfb16e120727b035fb46116f860961615ff94b5c3d8879e5151e90fca221d69a974bf8c64687261d80daa77163a6f4944c7da3fdac9f6a08b20d2d2f12e451a6d8cc2bf38708c959168dcf7449f4e2d676a7fdba7c8c0ece82606582a6102a1932227a3faad7592973b6cf4a2872e760adb270f71ef397581181e6c2a699b2d7f679053485fcc1e62e0f49bdac2b6f284d0fd9d7fd0cccba767d697054d37e41f72ba065cbd043ba7874063bdec1af0d8c4dcce01b08ec98b36377f6993a9cf0303ff68205e7e26ef9d431ec937c3fc50a51eb2ee817727388e71d6a94dea95304bb6e8ecf81540252e4623600081e2bba50d80139cd6953a6ff9fd41386d1676c4269b34ea0c74969911f6aa184fbd07f9b1da7985dc855c70ccd3b5c39e53d60b2e3f8cd5dc966ae89779f005b9741230486244b3f82dfa6a707c2ca485866fd6a6f0172be68acffb1d9e5b6ce9ab9281ddecbe69fda1f52de43ad04f8ca15f2008d7f795073f9bc4386f6c36b376b9640b519d92c2cd528e703ecf13952af4ec8deef3b340dab101d98ec43481008edea15c2cd7c7f26dea1178ab1059d7b0ca6ed9db8dd0e1e03827ab57d601f4722522e27f6a6f454f39971a8526e40e5af8d380dbfcc2b39d60bc2b2021d1ffda469e7d8aff82732ea74be52977c26a498ace8a11e90d3dd78a8730c27a3e8e451cf591c6c991540c195f4ff68ff5c494a7c59dee19ce87927445e92598f2d4aef56ef38cf8ccf61ddff4bdc62835c9e7d166ed12894fef8dfa42681da073f64ae90b15111b12b050f21aac5d8bbf300a32e6ea7b93e06561e46b806c8ab4813ad45b123dde3cd5646af19b039614950d76050df4e9d02869552e079dc39fe9c3828db5a15e523bc51e6770decd882aec9a68e4f5dd8843416adcc732f8c805f5107a7559821416522e53b105789661f8ff77d9e61e26f3dacdca5a33a78e736fa103fe8493f4f5a1b4272cba6feadb4c09277fed49b6c5898c9dab8bbe92c5125ea888ec4ed80600b0dd5d25e54044b48a95f37cc4677d9c41f2fdef1944f2c354ee0e16deece7e9569ef5e49b5811c890d431e61a033a86d4d10eddeb87de0e25dc7c49050c4beb2c82761f6f6f0bda1ad086b320ebf0abc5703a5348ad6ff668666418c46f9ec63aa1794d6c80e4e894befe11a5933bbc4d30b267b47764b617e47a314db42231fc829a21b5fa1fc84ed1b86fefe4af8d07b0c51b4a3e7ddee67522be5e988a3c13a0eb71a3293edd005a3c41bc5728c8197fa9385180c14e4c43c054d3921318edc5dfa346f89252c58a9d7f97177b78f385385425a58671852e8b1ebb0a2024bffb5183b2610c837e8f8f986e7652a538222ff9d4d43367794701d3c4d6d4394f6279dbd31c8d3e7e3c3d0067623d97799c4e808657f65958018fd9142906b266d79753bfcc67875c49b324c3bee7ea601a82ebbb75d36bf8c5d46b28d7244bc9206d2b4f747d73ee47e46490497720e4f983f980eca8ef5841721dd8254dd9fed4d65eeec2f03c084b38db1d72aa53cf9789d38c0c39cbcce567789c8dea6fe03351198285c2883c45bca92c039e7dc289fa301d04d826465531f34ee5f995b0aeb56f1b749357f35a6b063db06f1d2866ed3c11d118ad5e87d8bd5dfaad1d6cfb80bd1123bdb7ec8a4f89b171ee1575439b444e0879a5b31e984c7b66fc10061589dc55454f1309567b5e1826b235a6ada3fc86f0f04aa858873d6b80ccbb8d040dc1ab0a1c9f00dae5e9463e2eaf4833aa9d07bf2c3c413362705c767b594b406071900f387481cf1fe3d058f22d6709fd282e760b0ec94f37116c110c91ec5c5baaeb51282f06b2fa4560cc492baaba175f01edc0412481fff206992b9b5b25dc6e22747f306ecec54a974aaf965c17967197721e379c53db2529cbff1ee8ea7522df550d2dfe3c5c7d62d2aaf171c6e95c4f83d2435c765bdc3308b92cecebd7db3e9c54e33b2212192ef1423c09c80c6d9f769a669d4ee7cbe62f90f114ea36ebecb0381b4fa0c15ca13bdcd780c49b475ea501c6deb65f57d1be357d9f358ea6350066aeea168d8afd14168a1a05d058752e49901de866b19213185ab41773ccdb47487001029a729c6be8e9a01cf06d1718cea6ade4a52ebf8b5b0fffb377c847191e4d78db3112938a56b034a4214a56fa743c25314638beb8ae89e09a529d69d60c3b18c3f1d058c29126cc370be9b51dd8f3131e776e779d4bf7f7380eb417980c725254cb5783242332687c98f5dd8e46035bb934c0026e39191e55f533e9ed51e13918b88491e163a7fcd1d60054c0095c905f48edc61cf243ce97a0ae8b5619d2d18e9f3745bf1c89f6303bf95eb3d8d203a439426ff8cf4b2a88437024dcf9ae7b7947ce683a9b884039c83a3adea23cc23b79998d67679f389d108eb475877910bdfd1971cf09028264083bdd28ae7a378bcc6dcbf581995c7ccb0cac9e4cc329980884e06da8ebfacf2562a7b4ae529b5c45ab152a0061f26c6033a6e3d523ee79a9e802d11501e4fea9c2c40b2cf354d08723ce660b558603b14b3ad9bcac376062873b1b5b97cb781f1966e5640b678f241a7d28735e6e10fe45f9db2b532979b5b7d19be3f8af9b76d83635ad86709dbc5d4e9eed4c4f5c7321900fafa52ffb5d82f923f174320eec9ccaf24099bd547de289926a409349c71930269fa671409b16ba1fb59be85af81c407e9cd742cc26d25dae96d356a7ee43e6501ad9ac15bf65fdf11174a6f27b19ca709ba84554ed1bfeac770e04b452bf61b21535bacd654b4afd64f71a7e19dc797173e89efc422388a450ffc39d2eaaba10c2f0be39709c8c2ad325aaaa8a78d91804ac1ea46fee498169c2d0b9c6cd2dbc1f7e01cf66e83e4f9440ec52f2027b79b597c27b6da7cc13850e6c12c2e677e6c9289769390c424d8fbd641378dd0630cb4243af04914acb3a8e8b4355476b8d085148aabf232873464b3a37a1cde99237354fe24e703dd7d1e62b41a07e260f27bc9bf1d055c7267daf3a03d836cb25fc901331c83d6e0b5398b450dd85cefe43511a7d39780812d6a6f78c3205241a841e3a1f893c93d0b5ef502980ebc8d07fa422ab6d5832f3a2bc1b69388fda08482c9d8ce6cef08731133d876d0910aa1260789be12fb2f76b413751ea26ffa37e03ed3bbc9c7a5f4e3d15f2adf6a94430bbdfd0c873e52c3d39590d82fbb1c88e82ca1f150a447fe8dbb7611e6c8c756437e43f4a068341600ab24302dae9363674eb66c16426432623f63590c510a145050248acb87d422a5226dc30218499b578bc90aa68fd236b78972be5316d0b48d2b7441b1877b95fdcfcb762db7bdab0e27185e7385f82d10f3e6c1200c506251a973507c725adf8ca229c2870980722b6a22dfc42062d123f197f1fcda06375ad548604cc59e258073a4a41e4ccf2531563efca375741292aac697a1156e95c721409bb921f094e57ebcc597e26e6ce18803bb1b61137ea0f091811ecc7115d01542d624c3f444283fdf6de2eac51e0226baa50452e5b9c299080f4d6c8a815cdc89f4ce2fe8f270ce544010c0a8b6f9f7ba0ee2a94a7ec25bb68751b3f4c63884b4ef31c98eb2997b35febafeed3ac28f802c4d83ceb372809ca948b35c2cf2b4b0d4ce6bb36b2760f6397b9d521d6a53e1701dc4f332fbaa874c0247a1e605bd0ed96420e3cf1f3918d8b5e5f0b63a05bea71e37b02b9e5bb2ae8d3e6c2ad25efc09afadb571284ad56f6b36b7aaeeee977bb94913db48ff3c871d5f240a8c2da09b1ac0cee22932d7f2d2363ddc7e79dbff4980ed59c94aae9777b3c3f5c75a335df786599c4e85d44cd10039e1ca631d2b765a66173782532b478bcfb45e72e0350461eb9266c11d9c5ad6c02686239008dd35e58ae179851b4928c8168065f0509e94b39b04b8d8d57569ca8fbeaecc5e309ad9e74b4eab202d5d16d1b22e8f1c3f6af6b55995c469173b6b5d05a212e6cf05ba5a35ecbfb42fa68e06b44651ec0b95e22f9276523bbbe2918949993a766e4b46f089bf3a9ca48e6c394c182729be77b19db180aeb4a0f643a683c0bd3f10c4d3d203e47501ffdda8be603ccec77f6e4a324dd7131b0084e898750ba3d71fa53742c9e82ef35566751220b886ae5d4d226a6acc327b55d632be41c2529881d11f989688888c0ce313d0bd06b6dd0a064c4aad301f57c3a440bae0014b74a5aae31b28428dea10fa08be9ade1ecc99c7fea93476cfe00a859702f2f67e1988e2ecca9ef5ec7a38b8ef9f4b2fe645c330cc1374f242610552245adf5a1fc8fd6c528addca75ac52ec9ea631b58791656907d81ccaec98b1495183eaa1bede9fc4f5762eca741db9b0b4cee2312ee4733e8e55c91d8204babf945cf14cb95dec57793d754307698b286146013dffa75d15c87492b250c0d01191c48c5c557de0237bdc02fd6cf8ecee57c8bce43aa9986320701b032a66ab842ed76dbcc80f9882d7988d96f5676f9fd8418b56c9b3fae809f9e55b88ee2f90f6856272a713584155aeb84f488331de154b2581a6ddc5e766c64af09d55edffca69d76e5566604cad242bc6892b4c8d1de57831baa6b325786cf9880dc4a0127892da6f9d86eb18103a7531d36dd2b6eb1ce10af8d2d2849c68ace63890ff694fa298a7283dfc1eff2a243acfbafbf618229195753cccdc63d217f473e60d99ceb7910ca76be66e976f4823a927a900fc96a4b3db49fbb38d89b7e0ef174294301715f4097c34603a9edd676250348c22ab836dc5d9be9711255f0011111e1bf4c3721a8323a882a820bad7a3cda539dff734ba7b9479844eb84e050147a53fcac81c472e6862ebfa80b49237d393303211838de04f943fa7b11cb59aee72704fc86b2ad60caf1769d12539b5a6d5779c676e638ccbf173d1e9d98304ec4a2ba35213cef544865eb2183b173fa1bc680ddf11b36749519fe6935a25cfc4a82dc04bdff98cf07a57cb1798f4c131b3dc60618f65c14646d1d631da89191512cd9fb16f19f3be9a639a4c74d3c19b2e629f44506c74c8bd9114ef1560c48477af395e2eb764281ea2ab162a4ae6a1f47bb5554770c8056a502a2ca77a4a5c06aa39f9030ad659fa121c872324c8028646eeac898128fbf5043bfc4ac7d8acc10536564e5934c72425bfcae87893308f1c9a02aba528c464d821f3a56ab929159b49b9a48b1502d5e604b3c11e9aca39ada39aac58bd1386459e7f8b6477419df8171ce13a761caa914d6b3ee44764933d782eca01ac2504a7c30cce3266e80127dc0575a8501878d7c45d8e65900b79e9cbaa4dc50cfe72649b4236b98517ad6f3a4b0e514c144cb6c791051167fa5f093691db178947b06201fe16492f9feb6dbf76f67e65a9dc79522df42e8145067bc7d3371ec2864469f34fc0b90a4df386504602799683045889a06f607a1a531f4f47e5782dafc99b9d787d72d6c22b21913ff250a6e3c3218c2d40aa95a38254f06f86c2f8713a9c4e4fa18f1a6e770db953cef8fddecec814d4a03f848dceb08a0c3a2c75c6f715b46b2130195413c68a74b600df5171b37a00a979af6aa44be889905adf154df0882682f4d03bf6003923a2a1d54660d2075a0e4b2799529801474ae36a2668dbcf4eeed8b6c771061fa9c4ae83c1ea5fa2b865aebc6ba84dbffc32a82d2a8320c8d305d1f8c71b5c2168a6b197ef829981a28f509e3c2b86f3d5d0792354baf409dfaca76326a3da5bdb64c2fc65fd6c0e3cdc21af6de44db4b814ba98c331aef49bfda072e22336dcd973e6cddb79b1763447232459bd95977f4212c0caba930bfa8ce668f7486cb3347ab01a0c35d5f98ca710d4bc2796e5eecd6bc6af3a3bf438a334ac9032a609c76eb3622e264c140ea0e4cb807949e33629d3844d188a121c3b18027d78ee5886db525dfa8d8e7faaf3dc2885165e35e009ef0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
