<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5df5abf8c4451abada927d521b0a77467aa6f9af6760db3416806764380673c958f85ccfcdab5dee109546a248b8b390e607afe04c9fc486e975f42ea6579b0bb43b1f79e1d594443d9dd2584023588e43b01224fe64c4d057215ba6d2e22fec1b4b39cd37436c9ae9dc0ec2b7df226d89e58123f2567e1df8f78eda346cba2300366a58db7b6f54744fee1b091dadcbc608a1feeb440c158e27241286bf8676f4444cefc3ce2132a5155354f3ba70b6b6707ef508eb31e1f9bd3beb619353f948109755b55ff2b4b95f374dc9f409bc3f7c2e4784f89ae698b9e92da7b703ccacb40c294b10078ec9bd51fa036d8c3c57a758613a0683b7e441b215df50314db86370cd47c93ceafe43f081c4882f3e5e9efee5de26d970406e60e49f63b7f6e84fac1107fc652cf17321fa4d76253ca296493fca6c3bb5421c5fc8da9ce19893ac0edaf3483040f263826377409c590d9d76846f588ca5877945401f5de48b5f7f3412a897060ba66264d96545af4db3600690469f0bed92c306091ed4190f50b43c3bf37c2e6241834da0824a389f42505fb73d9c6331a16e2902a571a5889c3a9769d254ec6e8293396f42682972272555367ebd6164502edf3a85d984bf6334b033eac6d6daf2aeaee51814e815f47b12453e089c081527b1910e4f59ac27758cdc4f38c8f96add955926c2a04a59d25c458f2654dd87ceaa8801d51a99eb150a122650b818a7b47a595d0b9eb6d1eaa93591c0765f28865ed39f8ce2ea905fb31095cb46a389e92f5531b8144521e1853a1a65464dafd5ded921bc89a5ec936a174cc60a44fa60e393bbc475ecee8bd90294a3d0b64b92d1d3047215dc82cf317f5d57c3ce5de99ccf9eef27edc4831f3d90a2bc463c3b00cd1712aede7e846537ef0158d8ad86427cf556ef7214a99c97d13cf5a2dcd2b2139c078d4bc04b4573d70e0cc169420fd494d56cb3a5769b0b8287517c8a4547a20726877c20c1ef1ad7793e093559b89926742ff356694b8ccf0880c17b071da7dccfd45fcfa2448ba1078c1725de120232c558eefbab21a3e161e2f2fa8bded8eef8bfa523a41677af35ca22abde603bed4f0c554b6e4aff4768de48cbe3d2ca52af09f35e2e0bc1db1db43ddf639104239ebf052edebb18cef36d9c9a08069844808270c372a5403896beb0917599915bb53bda350e5cc491505eccee81d6b9aa7c18487e704afc82823086056bf6cc5952f26b4479786d8cd4ed2d4afb6336fb539f4c17292174cd67ebcd425515d0dab08941ba7ee0dd25063649a2562470fcee44220d7b119d2f6d39dbe06254b95b9b5d6cc49e66b482df28189f83efcaf1bf87538731a5f0e2f13847bed337af3cc44de7b56b6b17e5270bec6a9612c00d713ce76ed0b42a94e4e71e2a86417c0d11747e17f9bf749234dd99139e863416e3c4484db58b49905f3aa29a0b59e769e34dcc1acb6c4391c1afedb33a7194b073fc02c4d1cd3d9b59a71626b2d81592ab04ae1121199dab3adb5c83665363419b43f7de75ba218f5123dce8ab734c97fc9bd7d88ae0738d81169974f9bfe54fd55f2f31d6c8c0fcabc54911bdd72cf39d096696cf5a6f58ed308c89a2e2b51053dbf9b3cee12c7c39273459b329b819975bab7095774a7baa2c9a241b6ec36e76baf972f09c5a591cb02c17103278afe1229c7efd7ae630cd08c10592d17c3e3a4aec1402f8ba475642fb76ce50b698e0a1ebe9dcf1f8e865073c989d2b147a79075908d2d365c4d878728b1f759e1ebbd2bd2d5dd1a6c80c0a36082d0fbd176663c9625f9471d663e4eaaac2222e497e94d6599d44d73fba14ad7200b4bdca4a8bbc1a5d017d7a5a7ac3dd8d180a5c72cf99109dd4f741c5a92e062bf6bc6393ef6cbacaae17457cad99e1270db19cf2441a691c515e0565c0ec6c8137ccf82b59ccea067cc09b9ecbc57ca993e45c1ef01a4292ce749115f76b9fcc19558929788617c2d07e43242b775f9563d57cb57faef0f9411870293bc4ac7121eb957ef07e9dfbc565e2140d547b2944f588407fccb448231a58c850cc495fd2f816d78760007285604897e0162ad355ce64b2d0d24b04760e3b81c22baf4088c456c7693bf2131b4042188010532f3df624c802dffdaa0c31f3930391d51a5e77d2726d1f69f808e433e4f01c6c034d88a1799b4b0f991a5697932ca484b6d760034a604a74163cf46a166a201ba5f8eaf5c24b18a7d07824b3e36dcdf34934a4a718d750e94c6c0d890219d80af1e6e6fd7460c151ae6c2d89fee9e390d0d77b355278d488642bb519f81df7d5d5be537eaec86a742de329b3d3e07fb459917094b08a2beac7a1418145b7b68f6b844536d0b543ae394c14e25bfe4ffcb176acbe2a3f91725fea20bb38cd93c2bafcf99e7709691c909d961580dc0ca965e92f5675008b2c2ade7832c9d55a93d763f7cca713e061ca82a5174916ccafe50cff4fcf2bee29fc217d8cb4e47424cd04a8085647f123d4868b9b494ec8ba188778474763bd322ef9b74c5c0a3371f2cd873f9e00b289f7c2ac2470b2d1460d837d46b5750ea8e27455932b2f31733edcb6dc675bf7a07a5b545c5f28ddbc116343255839ce8787ab8da9258131d1a9964ded8da69def3111ba48e7e73ba3bade78ec0433ef71aac2e684ba2d26a58bfc33c3420c44fa26a0186e0cada4927e5c3312f2a6afcaee79946627113c5d9a7bfaf862c1d80f5a0587bec704ae63e24a3a060d67b5f54804cf1b75db5ff619734bc8cb535de414a3a5177505a04b7a46f5baf4fefe8c10196be2e808d959e88fca7205fa7e4f7137cd28475311d9cdf7de1851caef5933f682f0289d2237434616d349afc72649eac839a62144a401b69ee708a05fb8b180559798b72ec43c18f0836ebb95b3a3cc162c38b52da6108bd174f08315e06e1c0514ec6b4fd89248c5c89ff7f5842c8115302a44922e0a35d75b9844af34b1caca5f64db84b38d854ca98d22e0aa5346a848333b0bff047edd3f67f6ad86fdfefdfded2995c1ed2563a87c02aa3950da67c094a1641d521e842302a0cb96d2b4675623e3fb53bcde7f6262e2fb9482724a5d974ae834c3bed17152489e776d0391a48b519c9b73ae961d2c62bbf051b95af4d0cb587c521a19aa9688011264a85d0d8bcefedabf8f3026738381c48701e6acabc70dda7bd0bcbd683a484efd529b7cb3a81929bfbee58e89dfe8435a734b1d974e0a53f447f5dee9a17fe8aaa00cd005a086dbc5c6d8326b8eaa7636d7e68f7de797fa5d1eb5ff3be3824f589dfc69864eaa298fecf04b88453311642fa65cd5c751c7b2b33da97e7602532432e32a1a75f0a29dc4f307105553b791f0b3574c22ac13f316e89f347f5b80342ff866316a436ba2a7ef6f92faf1583baa0b5a7ad7b38b84799fdaf3855d717f9be89e4f87814b69b0951058e840d83dbf71cfc655a8bfbfece1e6e2c7b53802542535225daf868d007294e7ceec82c75f97b216e3bfd593a23363ecda64c9333617da50621679345525f3829a9affa0351994cf33754699575425391e9700db5acb10473d4ad4d6bf60a3a1fcf3077de53560ac07b9dc6050409f90bb13df61baa45023daed801cd27dc5395ce201674928b3e1aa04123ffccd407eafd50426c6a1d2ffe6af075516ccddcf8c8c43009d27466d31a18a06f65270589390d1b723f2e7b25bca384c0bfa4e5342ee76df3756ed40ee27b39d1e507fe691ddd52a63cc3057b1a9790712285e1caebc0f08588ef126b68e03efacaa82ced8cb3dd319499ffbd33434cca4215691004d67eac2197746a7acbdaa8dcd842ca1d11dc0a3853f5ad3def778fa2433f5753cb15871328d883058ef4049b75768af8da13eee35c0d8c2081fc3dbb6a78276c297153a4d966692f9c2b5ffc0c06fc341f673e0d20e88b7d82667fd0a5c0843a0a74d4a93ce6d849f1a7b1660f8723423442089a2a0342038ef77a6b972891b075d649a5169344e1d189ebb01b2641b6369f2dfddfa10fc3d9139a4aadcdf7defda0b792d1ea0d8dd3c580d61b10461cec4bbc52e5062dfee3d36481081e1f89f2f4c6cc1c416b5c7a0a403d0efab79c1ead8c03b36d48999dd3f8f4c27c09b218d0a1f3d5c9391f808a59bb822c4d2d4ce72eebc5ed1c8b978da3d7355f5c30914531487769d2983d56a45438b14ee8aa717820bbd155c9a0211ba52f89f4654d8f482d9d726a86fea402f67e1f9d87f63e38ed5b1f3439f5efbe5213e2a36222fab74141495c5bb94e65c7ac5a7d8f509eb17a21636c10d603fb070f309eeeb638fbced12d9f1fa32e46ecefea5fa584197e089a6de0d89eaff2d8906dda97551e2265437a199bb3686cc7709c7cf6cb48413bf9cea350dc69b9b9a4811f8cfbf7103935f9cc396f410e9063e4a7f7cb4bc8793ed1244647068bbf9bc7b51df0448bcd15a7114a71fa8e4cf47069e867dd6000a1f347e16049b7b462b0375ea317b39d5883b72e956da826ddb1c7fc3ecc3b9e8ab8e7011d871e363690ed32d503b402109459abc095040ab864fcc0f367e65a514d0374f8926791fc0d55b78557a0ee16c151e7d28a4937e933ed58f2a7a9eeede19dfe408e155f58f59c8254e36453f22cc0497c9b136638d775a5ab5f432b66b19ebbcc7a63776b124ab3930aaab3596df2da9e3328040e79e5e4d2c74133c39bb7495d06542aa503d94d2a9e363e6c5f9ad24090eff12f57c9f7b1ac5034c536c85ace00b753e33035daf5cdf9d8ee2abc7a7baf9c6e6b374e94351ade455b859509b5f4d276214f553ab9711d9525dee7ef74ad0a7ed0471304f77933dcd4b4d9abfd064fcea6786b5d85d3086e6262c1e8d86f5fbe7d0daf696947df03835c7bd70a94f784503c75a258c42d4cf3d93503ec3effe91bd96ff21fef12d7ed288666ffac59db7740510d1420fdbbdd4455a1cbb2e66dc8b5c07a90212594c17bc573079c89af993f85d5c797462f99251924fac0368db9924b371673b171410c4bfad10871524fc12c932afcee49d4b31b1dbab0c2081debd4df3e12e3a80136b3def9262a556b0e62c35dd1cb330dd9c275cb3a84d74e6bd21bb3a484aada629d820bffe37e00d3385a97460002115a114c19ddea5af0fd05c5b1ffd68d5367d2a4907bc7e1d27c0b1d40ce9e2f2f4249c5418217e20909b7239ccf38e2158b9bfcd90a4d7aca901af9fec56648d47fe176155ff9f706abc3cb043a7e0c99550a95098da8e5a3cdb0fd423388f4cdea85b6112c89542b46865ded7d2bfeeca28612750e13bc35472b99ba3bc864c8b7275c8ef7242afbdca5f4043f0d93e60f772c9bff97705771d5f87d2b41c5ab26536497714aaac695bd64ea7262f5dd5a1921644ed551e7f9bcd66076776166a6ff9c52ec14c4de4b9d58c23c5f52d3b10b938a6544885e7538529547378f3f7e172f91c756e8e05bc9045b5e29f18884dec48caeebee76f403b05fa3ddfb1fbdf6108fb803b179f61ac4e4680043429f2e0b1990ed1c010f0890febaffd871b970907a8cb54edc95d73f284b7d22ddfb77d4257374cc4128da5f6ce9720c9080233373508d431fdced3b0e54a6a6d6bfdf1f1617115d8acba2207671afad9dc92fa8d07c17a546faa42fbac82fa5e8ef5590150e46caa3674b95e54d7233cc3af7db42aef31c273990c7be8d9bf736df0baa43957b353c148e42eda05cf9a4c4933eeb4b0c9fa794e94a09d61b8de12108a504e6335c03484832a82d9e27f7aad482578b4c924f9c9e38595ea5270e714c7e612d14b7fec274d43cd30b2d40a7341d3372f6c3255225267b195e7cf32673c140c081348097f0cba31b2f4ccc0f130d6c8bdba44b11ff86156eadd29841c5913037dcbde9b0c83f96e68ff65e78c8052f76fd5860cc84e61f78d92bfcfc4caa11723d30a215b6f6bb663df48ea280a6f03f636a27ef422389d34c0ab6a0a3c71f4872633d59d3b7e558157dd1ae47ab762eab1ae6aa530c3f9a6083cd895b943cc6ee1f80e64305856d47a4757b9d4f7d060b9b395fee6d97dd86961ed7f3a0c77353269b6eaa98f5ecc00a735c19a313d675d7f22dc0c8a9df053dd709f565ab42b9eafdae8d36027413d6da1a136e295bbd8d942377f7e6d2878e0c978f6f86f693b034381f9eb244dbbc799e481daa22f815d59708101d7cf511b610ed79fefff7e179abdfa33e45ff5865851e65b80a86bce30b11def9b31fc4ebae4ff6fcd8dc47cb27b85fce6200210491fe0ff0dfa01452fd1dca26fd80d7eaa74ec0cb8e3d0204cce179accc351047b23eb7c35f3e6fdbf242f18588d614042dbb43f06b4b5663991f4ae1af50987a1913b955bb4b8bb17c78ff1df08b5e34721e1552d699cccb68914498c68096b60e322d1448b36545aceca8c2e5fd76892b7309613bca7356af5d426aba56e7dc0a768cd5b905b5f7bb1c37f97d97f43d34fe1dcc55168cf809816d13e6ff42132980d5847b88ab746762f70da721795ad21b8622b8f659e19f818def04a5f10c2adf715d5d8c5d3d3934876c4e4a094ea10f051c72cd5159d5b2a468389c710e223cd38e614b87c36d13e5d6a0bdf11e01741d69178c389b2dd262200c7bbc9216cab842f131ce0da0077f52c0e807fc5783f54c081ebfc3daa11a5fc0c8a6e57ad99ad8c539181e7525322433cbb9edcf97d9759c6b5e5724096b9d71188e974df70bff1a7cf0a5ddc4a7260f385459b53b9ec3e71bef281b668e8277d8b3aa3d8ed0d6164f15893800f4f20e55b0d97bc0fbaa54333478e5d5b64c32ac6ade3b1741d9e11f4f63a518cbbe6ef4589f5e307ed3b59fe79fd5da8c364b2e22f60e7112b83aff945462d2962f880ae20b2a08512e142948480c40bb9267ada36796f5473800a8202cf931bc28365e094be9e08a21993a22c4850e6e8ae8bfc6ac5eb7ae9a7a578e4db572a80ac3d4d8413cd1083212d8e00b3c89122402534d4af7dd0c4f8664e0e8efec51c4c932966e4bfee719d25a33a0916e33d6a6bd0f2d2c79f67bc07ca501e8d76379d5ac71ae7b01581077f3e0055c9b1c222c92e0b78e2866b37a3785eade77eb0444606be12ff05f068682bad02bd034273ed165f362ecb5793540eb7104e3b0d101bb88d2b915eb7018c47c81bf5fad0cb06adea643c039313c6ff1c893b87ff80e9f4e473b6085c9dc5b530987fefd989a76d55ac0fb3ab774678a163ebe1152deb307ed7c41448605f90d6b3b3079b6b9ebf1dcc2800d63c65b7890f792dfa7d138b2c141a34ccdfa9806188c003041c7a83010d19e3ca9f8929636337f977c9d9ae5c4d3753caf3decfcdb3b7fe0149ae28ba8442dc20d25a8a4fddb81126d2c47a70c1cd8d02c87e7f1d731c82fda06d6efe3c388e154a3adcd66e95b9a2437fc49e69c0621ca2c589966718e7f35bd77e5a7295664c79ee1656427af25c293c50c7aae093430cb3f2ff5f14324cc5b51fc9a9630406080911f05cb867637234dac72e57e6a8da009010fd3248b70f25faf205a2fdf28ddb2214845baf5a3c713dd99c0c670c44f5c48d9fd65a3bd37cabbfdfafc1c389f07bb4534fcb03177180cb779048c253355276b0659490edd61d6341039f8b981fc12009ea7e061148035021a5fa697c80d4b4dbaf309ed67100fafff4f62ce276f9ac84c076f7487648fa06f4930149414632498e2d2523a52b49a1920da981a5a48f542f4f9c5d3daba2217741877839b40280774b653f3e97e2b59c76b2c09a9857bddea9b710411b3e54226e9076fe5b822d56b1371abf1ebc8bc432baf93de9b21f5d23ba735125317f1ded2a53a75a87c032f328c68b930668b9a7797c34143d5abd7c0a44871ae0e90423a0921ee4ad901e84e87654120717615021697d94d412d10453466427c668e6efdc7729e5d5ddbcbe7d598a5b9d0ddf7f1505c83944d0b1d38b6819b0773dbd9098adfc0aeab0d48d8c1852a9679428f5a685ae6f11e00adca1d799958fdff0d1d0bdaf635ae5a0fa18e74950e3c27884c7f253f41386a4f1677985f011c0c9d875f89bdac8b9cb85e126f0d48282fb9cfbafa105bba6de4f477561930572aff4efe84afe054a0ccb5f947076783a09c29925d77ae624c8274484e97e5bb84af2c631c42f439feb9f5dd39e1501be222473eb019250f451bf11dca4f49daf3d334669940687d09d4d400e2e20bd8c8450edc807e4ed1257eafd2e98f91b5763368ef4db1423a06574d0b09fd4551979a049965ef9132dabcf7fee436453541d36d986e2b82ea742a2db7dc9aea5707bb83d6d55dd971a4af16cd3699d71b28c3d6736fd00a7d846cba30870fec6aa25e6ab276e4a606329bc6e418cfd600db02c14e37a9b0a3b1f3bb37376c220fa3a59a13d09dcf9c6bc9f5ec26029ab131f26d05bbb4f94208321877f79fbd341c6b32502b5a413d2c068046ee85d9a93db2a74324f640af5c0630fdb162f933eaa58176ec460c8461fb730f0139e8f6154a3a79222bfc875e9386a1679964a21e7f4f38171c568eb53acc3dd610ffa529c314ac430932956392f325d76e76ceba060de501744439c32b323a97454098b545e381288834050d018c1c5f3989ef153c6ad0b398babf8d97d047f00a017e507fa678797acfb07fcfa257b269f235b812e3098ef77dfd2fb1992313210d39b8e753056897a24972532eb79047253e2f58ea0ab0f507250299a2626ac6737af7e9e313c3fc9dcc50477707f5a2f06cfe0beb2581fb0ee70911a11453f8133a87b915b8b861b8ab65f772f3ed82485ec36fc157f0f5a1c4bfe41fb86196bf8c794771837b0bf4fa2c90a49d041977fa05b605fc18c3c85609103ca46254809a82060bfbea06c4bdd2bdcadfbbb2b09d3911899dc4bebc7c09f5579ebb6a951e26aa75145d7262e1a2fd80a355660a0610035dbbde9c3bfd659224af58215b542a8447de1038358f72646955ffb850d898fded16f48f45d0e8893c71b7362ce74f0501085e83015fd319fd1f6636971f45710965bad4a3dc919e4baf573d9b04f89f26f17e9d6e50275588b8a72b5369fcbb737d9a28f8a21bc335913179c2cf7bad74873a4773cd42f821724c4773e586e3e045ff49cf875aef75641bf1b2a198b229a5396e9082e6919e50decef911e9a50a42ef80bc59f6c27efaab8c658fbd6cfec9e9b1ed32a19aac0338adaa2669ef828d4de9a6c16432166f4db4fceabb9a5ccfc69a0def0b886664107f815020ceb351c233f45fadfcec6d695ae435103a467fd3b1972fe2b025d5318728bc635df2efcc2ca70e3b5a9d6fcd02d3448b432c926eaa0c36058e119f7cd58475d76e52433932672c6e1e5c4adbe1170141a44f4bd2afdad1fda26d4081dc618f282167a147bd2b5e294a4613d65a57572dbceec923468b07795c036fb1ebdba9b72b3070113099cde0a3e5f47f44caebce540cd5085004d0d42c4cf008de6ae4599a57b17c8b76309a459780958a2a6e14384c05e7509b337fdbbc470b126c434a3d7a6bf4a3dcd5fdb4ac371734bd178caf2d03db1a9a71a13de6830731174c4960df5b254b0e7e754ee27b6f94fae3ee0097816966e5e054911aa6a95aee5d644a5cd71668d005174a2a2906c22eb5b7cb601161b1ef86ab950f7b28ad6bef686093faa531bf8f7a0e185d47e1bdca23611989a7e9ec858eb9fac989256ad911bafd457d312af8a16c156c0abf6688b1f078fe39456da96180f103c02da46f4cbdefa13f79adb8b9d32cdc9f358011d9859cc1ccb27881c0352055ef5bcf47b23ce3838730f43820ff130359443a29cc9a011fa509aec282c7254630217c56febc675fe60f9728d2ad952d46476ec4dba171e71dd937bd03daa769a966100a4c212671fdc48868d674d783e24a88f71125b8d1a5ec7aa822ac04bc0b72e0773ac8d5372cc25a23dbec55685046d2ad35ee019ba1cdc71f761f89dffd33f3da20902fe1092a91bf8b829332bc6963897b5107325c6f919d8bed463b41fa201953115c2be6c65bce2924837fe5ae7126d0cc183513d0e52e2cc1c7614fe1d8d640ec7f0aaa83e33a31a474520a4679100d8b748278ff5284a1ca57c62babced8cbd443755d49350f10f0ae99eddb2b9f05248f936c5b9f4cde279d2eeaea91f7ff111377ec852d2789d2342b9622671b8a4ea7213b2373b9003660a93d6189e19bc20462b065d6d7a62b21062fe18fd9e35ae8530979339b0432c234c4b6dc7583df85cb188aa6df917664facb2943ce5d7684c2b8d728349a24432fd38304be4a36d65294603c42dd73d9f5cc9fb0295606babddd8d50a5abef73da4c4abd2e37f9947d92257c101c7cd80e608f7a869c979fb4c84b1250b43a9f09a0ef4cae116d17c15a0410e9f18addb424384b0596429fb7cf4f54e4137304896bb3fd9f9bfa0f25ab3c7d4e402d44f9e6b8e06fcdb9f5c32ca3a91877fc7056d011d2950a89c4dd9b5ebca8ae64be34324b2a0a967c26a01705662edc563382ad83f48c1c854bfff4d005908d237bf1c7c6d288d9b5d058518a3ca90f2ecdcbef589010eeb2870411d6b6b790270cca6e2f159ef4503382d5dc25f713912984687067c0194e70b42ffe45df657cc7bd132469387bfe7e53ef7b936593c9300be48a00320345e0f5535414b0c6432922ebdd7adf26622c3ecaeb616b0e71df790d4b8f36cb99106c945851e5c76eedfd3bc2663b4fcd6b884be183ad412a0c41dddbd159114469dd2d1f9975deb5a726a0c9e334c7516b58e116356da10a913615373201d3204b85c4fb364f5ad54c6e3293818aea40ee7238dd39ed8562072b07a917a8ab5193df68db99aed155a06607608b8477154b2193121ea04e2ad02b4b2ada1f352c0824e7be76d639e2e89767af3eb7d09eb9956318789ca3e49e2b5f289930d04fd93eb0a59923c4edc84dc57bd3661e9abf8aa742f5b8193ed17ca82cea26fa260e5655a731fc597cd51966d84810a38ca9926c76412e88ac059903629373cd0344dfe6ea76ee34e88951c6b9929b0f5b5f17bd121a8b17a326e8f17add0c85251653dabf79ed05b7c06ff3394aede88b50a5bbc759582427f6983d929d7873dd10d74f01417199cae2707f7673f7b623b2336f1abe8772d6ce4ff526f34b57845561f982464eca2d93e98156122ca82391ea2759d6c83516c1e9ca496fece86dd250fba1544acc8e4c9175a2277f1e16f4dc24ca2d2ec089652874d280faace6de5b9913ad0b41850c6a408354f34a85eecbc23051462226f1cbfcc356d40edf34ee99913bc9da0e95ee812a8452f497647703f24b1096e8f806a604a2cdf9407d6177dcc23157825f49d25894edbb9b3f95a2c93d113ebcde64b9f7b3eb1ca792b818ec423bf92e3902758bd68fe194afcf2e9c3840fd095541c284f1bc020486766376548cb7cf2fd9a296d1487abce3ba46b509bde72898e7014b66ae381695136083be23edc72122e151bb4dbd787ebc547adb90cd3070ecba0512e9febe70e80ef456c12774e8069466d69e65f5f6bca5ba054b63fe384d637b5e88fd085b814361caecfd84edae712db0fa4339d7bba5e425a694e1b59b026d67db4b0538c570fc6c71f75a5f1a1abed95cf3f8c1899cf03ab8464150e5f1291506ad280c288375c225a887b471500538fa4581afc0b699821de53e381408e4d7dcd717c5692614f760c109c3a45f0390c15465d829d4ce21a56cae7ea5e0ea23392ac377de958ea23658f695cb10479700f5b1a6b8c543fbd3d8528db4f46c40985ab12b78e91b3161ab98657529cbfe9bab7d9892b914bbac9f8d72665d96f717a94cc9297328ce67a1d58015878e8424103a54aadb6f073602bde1f5c07ea6f1c74cf39a2d62dd2fe190ada6d75265ba5e82a003243ad43f04c83f8a85cb43bf86854c7dd5c64608d6ba9e7aebaa8b0c34e2205929ab8c034c71f721198e12c7bb0e8cc198fd34a93b4ceab5efbf5e798cca899e92a7aeb68902e8d96fe6fc00bb0674eedadeea4c7d81dcf8219134d8b7ee2143d03337ec78669f667d12a55d0484036989045b71ea262b417027293a6bced056c77bd19ea58355db816644ede1118a693263487ab861df0a4b3888cb68e726045bf9f153df459fa177e3c2c17913eee3632f37ef3ac72bbe888ea94710c8f591b4f3bf90358a395db61cf5b2fa212aeba7faab3635595fe619e6fcbc602315fff1b1555548e27c1f5889d3e7cc88f2137501c9def5a8583eb416cc81808404a2b18ff77c7a2b0a9bbf45714166cef52db3c56c2fe2c53d7442a23e9197e39bfcb4b32309d78edba5286fac69d096cc58a54933e3515672e804c1bd90505144153938c8c954c746dbce02db4b23950df2295e0a51d12346aa5dc9a6f4b8b74edf9474d97a47782618eacc750a26c2e01bf90c4c57ea33dbf2fa51546a7f4cdb73a2c2c9180776b2dc0b946e25a2ad63679e2f35a2d03b0c3d6c46eeb373b3fec97c31516f409e631546c303228d1e1bdeb2542027a00ca3bd7d081692c3559381e577135622172087610451e7f7ae4b78f6dae146dbbd091c17657b8176efb1a34229fd6759100a3d6a12808fd06b81d0717c26f9d84e4e41d6c8482a624dd9cccb24207906395c8de56a10171511f0febe862b2b69d0a6d2476306562adb34851cd5391ac0596b5e5a06bc42a6b7ef478a30a9ffa65f8a449a36f75d9374d8302c3d31e4d3ebd27dd29151383d73db58843f6b7175c4ccf60984504536c41fcb9a945d0dd94bc381af757dfbe0c27c02a8063c70af43584c0dcf32905b54d2d35b0075b14560fe2251baec08be825e1555a69d76be13d998bcb064f750a4205de6f023a857792d7ee652165f0336766e8b212a7a98fb7415033dff5c2f96eacdca7012cf11b971a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
