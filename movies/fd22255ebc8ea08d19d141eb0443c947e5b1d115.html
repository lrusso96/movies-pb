<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cca1a234cf0717d1192661de45e6ad933fc211c98fdc494a640b6a3c4c9294a95fbcdfcec48208d58de7dfaabad012701eca95c5d451fc73a0433f3c622304e21079dcb1f1ca47ce441d12109d39d9f4ee9d4e2002157d0ab1b870ac2d4a27e40f7f13e9b535bb5c2c56c258348eb3011700be6982ba58acda36d260eea83b3ed9a2c1da2e60b103714a5fbfe8b69c4750103d8b3984f732e7b33ae9505e0d7132a5edd82f36de3bfca94991ca8ecdfa6cf27d57ac44df7caf449201d32e6ca5b61a5c870f2415dfab1e6733992cbfbe807c554df4f3d591a50c4e3bc1eaa872f01312c8609d59e165c4f18d22aa73f47d9f8362681ad31b06bf9cd69e73ffbeb4906738cbca7387c4148ab61fd23e93ce142fa6d2860cb24f2407989dfd57b79bbdce856dc48f0d4092a07efcc2be53081d3e9fda83659608b1e210f7d5e55f6da24f76e91137ebc306b9fa6b58519ed025c6121481c8713b5bf9dc294c9ea5e314e72191e9c24af31141738a11064f65e0c5f96b3e7a4d705aa5cd0be4f9a7dbac033c2eb39b08ea8f70706c144cb1e981985c9a531893b15765ae805c4ec5225e9a75a3d879b7295c05a688fa0f7f192fe19c935e0db43d6590b000a79c588334d3a0980cdeed39756cdc0f6c63fc5df611c0c0e5cf507658539b7f2653eaf426dfd3d1b11bdec950696506f07bfb9496c95c9907166f6531bbea7587ef5079dd7a2cb76a8c209f8ecc6f5ca575b3b97fa49aaf9df9a52531ddb121da084af46e1cdad54531e22f066c1c4cf7eaefde3eb54b1890459e338ae19c0e89407905acf6e66691995cf1b703c849789201b75acc36ec0d7ef71f66485d1412308baf9f66724453da743899bf73ff77701a98f327cb9ba0e54eb3bda76ddf38a7579a1818aaca747912861a35d0f68c4b4b26111267e9ad303e4cd9f184ef36c0b53e13c0d4babfed7db3a92b87929b903aab49757cc9081760ff6eadc2021b2698a45530fbeb157fe696b44031b33325e30f1fe5e35073a8c6c697f99d4f29bca4a7432b776a01210e3ccc685eaf9904243b63aace143d333b60b0561950f592fadb76f3713a08917c1012b693ad6169b56fd34bbca9cf2cc70f25439c865608cf2ffe057f9cbfff7dc1ef6cc1f9ed91fac1ad9c3c7496f22d155f2e181164cacb8c00883da00df3ecd9b474c5058b462c7905edc86ec9b107534fb78d6972055ff56c9b9ca7ae60781952520d26850119c8e8b58d13e5ec56813a521b0a8116ede62af0ae676d8ef09d34cbc180954d24ad6b1096673db5b015af29331e04bf88e8f9ce8110be9c5ade6a0387a03222df32c34a860214aec027b699391ca58138e7a3f2b2e0cfc04a02236949bda7dac435840c05cac84019b124b68c02d01827a4a3f8060fbfcd1958247d6bbff5863bbb4f3e3473a3af8d1f56c55e82270c9000cc0d7dd87660a65e096cdbfc2877e0589fc7f60d7c96876e4215ee3c1f677986f9e794b2153d7dbe132eb248e23978edae3342a6410c54e62ff5685b4491b64485e72bd675cf12cef9c23935fae6f2ae0a7febde8bfbec5254001d9142b26b6623eb26bd319b073c07fb1baffe0b4c7788dab19c8f6ced1c13a7c79a07af6113de1bfa473ff67319594bde33d1f54add9f7bf1d90a92946d7be7a9ae9528a97968663c70742a2512d5a1b6e9b71785fb2b6e60a07bdea77f19e5a982daebd5de0a945ecd7222610fd035c8d63ecad880f0e5474b7f54aa9a4d68bec7f7711c7f8ad82560ef9162e08df893dbf6c657255d5e49f71b5a51874e398360e9c1564aa9e1d67f69499a5e3614d145e0f5ba45fdccc656f79190fb3e50481ba1d5f0cd7dab7b7f1527ba243c1f8d1daf6ce437e1408d03133e56d472791ee4b98a32508b1487f6bc067e51119cfb0e069a4b30cfc0a46660d8198bda072e3ac2340b0c7022872767cce5e0af1a4faa8b68fac7af47b3a6cd3e902b67f8f1a92efdce37a67b3a6aa2e7706a2e28d14daedce77652f7a6f1fcadd44e38f721e66bd428abf77d7dea5e95f4d89c78aba165f0a0671c9fab09a49c3b9d4462127f872b5b050f62331a2dd571ca31225f9fc1ffddcc988c4ba68366461be422ca9c272ae12c949fe7b5cfa486629eaa80088f3c53f2bb1611fe166c2599a58ee90f1baa15ef52f6d184e992fabedcb2f72f5d2af319d14151b4a08c7a8cb2e8bd8624bdc193341becb8997284518e925cf2a227225c94a9b0fd262d9c678de55fc2293fc8006b49101b14d204794bd429e0444ce744c328747ce6b6d4bc58af26408b3dd8bc63cd6ed0caec840a0998b0bb2e21b5f5f8619124b03c418aca88419a528164a7ffa06c83ad5813e67668322bf230288fb5550fd0a34f35ea5e1eb3ff95e329d081077f688649dbc4c04656e525b72eea7b3078881db51f11f1cfc315a206746ad2beb5dc0b9c0985e537d7de940c51cb5e8173364533892acf793c9a0d788ac73824d0d3f5406a111e9e3dc5617039b9b8ff03f3d124bc4e4c928c6d479a961e12ef22f9b398e75d36ff1ff893a4555e945faef5c3850459b337ab154cfb173878a43fc173741401dca3e72f80a1e1367731c33103562b94e6205d8ce1813a0eeca1ad78fe6821b0072cf9c0111eeaa34c576c897b0645ed4ecef19a174420315bdddbba79db140a5695e939f195adea80dec7cac441967b4a0bb0941fe5a86bdf326bd45b016eed48e452acd32b25b93fbc12e5c9a39c39bda97beca76e5240f262b5ceb79ec2007805bc09317887ac34e1aee9ab963c22dac46074e5507ee6f4a2c4c31aa568272366d770812d465fe8d427728776f33a6406ef5b346f93b6f8975650bd837e7db79ca8c5f9d99446353bf40e345e16f44eae35181d725bb1764cec6f9eb0bd56beb344eda4bccf0276ce054587d84917aef9cb36ce881e3c19f12b870ef780552d46a5e17ad70f5600f1f6783cfb7135fac117c5319c6d7a7d61238b41058d4e5fb6a834f45e6a406220eef01fffe19e079a2afba28aa6490d61854881a4bf9a260907ba45226a64eaa3c49c00551ab11f47c00ca0216ddec2658b2d9316887a6871b0f876c68c6b6f83fe48a84990030e483c93561ef85946bcad00dc45d456909068dfc50d72dc235317e1af882319382ed40d6afde22a13ac1efc9366eccadb60005b8ba8ce307ec655cd35fffdb4d1a19e4509785ec6ff764b3d750a188b7c0dbb4a3793866d5cffe426e776e4856323b0364518e7bac6e1046d343d2e8b486f6419b83a16871b4dfcca3664a14b8e544e611f193169058991cab2e20fddeb0416d14612fb9c769aa259313e28b220d787cf8a8635161a6db15c03921b3070327616e49ad02f9ab82639e4d6b8813177c8bcdfe20761d6310968d9fdc7f887f0988aa19e2248cd070f2637c235bda9cb6122f8c83f6fa15f734befc0eb010ac067e4569aa2eaada0df11ecdbcf2bc5db2d3e36178a2328b6e4a494300065df0bd8e8e3b52015d06e15c853eadbf4de160714912b050626d7dd5702d961ec5085b25e125dffaa0b26f9464678a30cf69e0e8b7b14a84850006d019929f3d348006913da9926996411883f7bad7b1b75e5d674664aef5e47ec998843f17f2b4cb27c4063b5af3051a58b46ce05c0c34060918c96b56812f908752d2da564a0d948dad5d31c72206629563133e46b8ac973b2f8c2e13d36aade466db0969c8c498c0c4bde7e00e450a3252369d6a1eb2409d29813c9c4087485c569448cef40ef3154640e8ad55ab29396c203899bc182337e7e9ebc64c95957fbf875d87eb7022bf4a11b7fdd39bb1ff68d06af1fd3187b349195213c61d3ae691e892fca33e52e656e3eb4beb14f2e9316254f57290fe22225baf6cfdde17232f7d025180712534c9bd2b6566e814693e035e2b4a01fa355e87a99b1e673ede7a560bb25caf2dfe22d40340651c774bda92462982990b6a5de2dd8f8eb1937b368ddd4147edc544a120cbac14e4532ef2462116dd9b2105828fa6f62b0852e91f0fa714bd3f1085f6122e4d2f1c90d6439d3f621cee1b76796d2f2b66417166014ec0be997da3e87b300c3e61f27f876f70ef27bcb518555d3c37cedd922b467a54df1da0f28a39352cb72eb925e6a6f8e3988159812456167467b4c31c08ded3073e63c70d782684467cdbc29b1dfb9055ce401ecbb9297d8cb92b55d5971bb4d971f217ae26c16fedd3f87d4c49000f716a2963dd661d2b3848cfc9e33573300bb444347e3139fa91107cfb46c95b41a072b11843854f40e8e639c76f94d38f96fdfcb3998b57144fe37b709f754264d4f05545f9e85eb7595bb848f403f941cd8d19aff09d294797764e5f23d2b6415bccecc4691a92efd88778add51159abae77b05229bf2abd461cfb44d65af9d467c12b7976799e216c1e1a0cb8097060fa02cc3577c920c2cfb104524e16ea0b476a51f94fc107d540363eda6164f7fbb3b441a2f361d25383cd2d26b2f4d6ed2649233b03537ab9797b98387e3a81c1c16a1941dc44e048812135ebcbff4d8a70bee004ac9b4402b958efc0dde3c5c17ae1cb693851a9e64812e63d01212347868aa7cdb4b536bf017ed100bc5750014f59961d223cc5c36890e13f933a419d2b0fe55660a4bae58368784b5a5072e93031ce92bb695443ec6d7554953dc416254c16d1a423e8cc20be2f435f722b0ba233175a5575bf0c9324c1184ccb5728f174df88598bc2afef427107a40096c69e240ba8d187beff7a360ca4855796c60afda7a1151d30b976beb945fd2df49c5f665dcb3cb17eed8c5b12b9e9a8475c7ea9adff11ff2c6a89d5fa8b889b7e0eb94e3ed2dd4bfbe23a061c884e375697520de02e0818eed32399d89e077d83312a8f647a3054edf8051a96eb906a7ef63de283c9821e9725e36f7ca922825abba1c30c6f7a0c3c3b473c83a082469786a2ef03f15d1c3c983420aea0b05a30db0a46765622ee217e39005d76b9ba380d3d0cc89c505af78ee1042eacd60b514f6c126ac4c6ede3cee6ae63851a820a628798ed83c48fb3e4b98385e994c1f405cfd6f4ecdcba14dc224e51a2f7281dde664a109a766078d0a00247c6b7d5af55f57de1369bf0585e393785c9baa03b890ec5da768e043f4f6dda1574dd8fce4385c754bc3119a1e894b069227c6cb90a9fd89bb1884902548ef1e4e093c45375e137a720434ce0668bd5fb5d75bf63530a5be71de9621478f7e57053fad557d7d95e62bd0fd662c9d0889682df3f35e78f8db21566391811efa7dd508fce06a371aa135cc2ad3344c2dfc353dd9ac1df34fc68beb0d2b4482ed9491cf8eccb5b740cfc23ffa1cf11f53d15659feba57f772f28ac73bbf0e77a6adc3385daf3df3591fdd7a4e296dcf1254b2cf3656f6b154ea40263e8ea05a7f89a4095bab1fb9dbd6895424bf000bff237f686a495586f62ec72131ad35b6f6cf7a7df8db0bac04cdaee14a65e84b8d744262d156b1a7d8ae78bf943e96723cbbe0bc3967a5667aeffba0697954406d338f16a292c83ea86b1de37328eefd2ed4afbd70f415b95495e9c523fb2de9108d8c583fd8f03ddd697af942e51272f0a33f6cdef3e494bc40e514857d2840a543df4ef56bb9a2b42a020dc2c64c0d7290e54f85dcb8e9b03fff03aa5bee25544cb498f6cdd9c3215e84d07508d19c31cd7ee8929d434c6d1def86908f1b0f10854a4892d272d14d733b98f68c1fbc198a04297bd26c6b0fafd1dbce0bb183b85bcc387d95434db63a1bf1713a6aa5d7d15c51b5923af19932fd8f66b1af8d0102aeb6e65fcf12a761cbeff91c12af5be4a76a5f3cf4a758a1dfe624d8f01d6f908b70372ea70171fe530ff0175d322d8f37b88afcba5db5cc682ec7ae543d7ae89b4a21ecc88f2eb333a9431db07b12baa4c1d7094f8ef49ff9c521ca7ce5937be125e24cc956b001ca75ee6c1e7e9f42bed6fc026535d5574a539b605f0ef49d5ca5d94085420a5ed6f4eb626834158c21b15fe1e49f93c21fa224ba1bbb85ac6fa6588fafd78bfe0b193b09359cb9a2e8485837bcff6f82cd64ee715d586eada1a4165e20af77f21578cd3cccb410fd5929aab07bb704c5225e652ad60641b5a8d27ce51d5328bfa748feb2f987e3516ebc9802f485fe3f32d392f04e571d94c2cfa24f54cc64629841c6b34cdcb538e19995372e5075c7016e6c7bd61e11c4617a3bf1ddd5e792e3fdf7c7b9fce3665abd09e1735f15f88d05cef62584ef271a7360e231985365c748f03db9c49904c9bfc97c8125645b63b8bd217216930c0bd76c44d7c27837d83ce6b181ae8f9d0922cf67fa8445dee8e314b3640385d56a1d3f8ba40a21319d624fe43870f71a60ec9425757c679735ca82bb8e2d94fe2133b3d3e75180a3eaf7d0def7378aac11cfafa3c9c1444f16c1affabfe984d49274ac749deb54e7264009c4ad65a256b13fbc980dc8b36f424492935b78f3b3cf8bf0d2ffd255f440a71b5b96dfed5ede49410ceb178c31421f319e1978f2fc378c82910784a1d29f5f13bccf92d7e2bd9c4f50bd41cf1fdee21f84d3f8f57bfbe3e6fcf2368d337a2599940779c1baaac36b3a8f3e7ab647e551137b2ec6bebb979a84b78301c05bffe73d86e912b51a2eeebab4dad35bdc9e5a84c520798f4247ea2b66316fd312c82c8b7bf0e3bb63345d32dfac71a67f5d989fb6e7725c2632e04b8607fb379a68a1945f4a383d4aa4280e637a81a5618409c4ddc43f3994eb5116e9c5b73e47888601f4846b6af569e68ecf3a7936f0cff6ecc1575e796a17d01a7fda6601fad7920d2517335218f05fdf563f152ab148ad719d13b2e74f96f1836bf47ddb61db357a8829adfeb5c9f9a44b049638b74c7e93560076585fc45ba9beb7921370a8d32e571f282ef0d74c82a3dd8350dd16a43552f4b971c87da5595cf035a7d3a97b626c06055230390be9c765dc50d90b3b42645af730df0af2c34a347c1cdfe64f4fd00da2b33e9c06709fb3dda59d59898e9975ad2fc25c00d7c4141cd01daffe23adabb7b60b39c0ffbc00a71d5aade593e5314920b3899f0052a14f992fe752c2a110715753a33a38843176fbb5e4f534ea7788dd883f1635bf3abe8cd410f7b1800caa52a2b9ebac36b59c7a0cbd8896d442b05fb996212b82545bf944f025dface34df8d2e974aa2236ad1cd672afd30b3ab23033fd4a93d11b57318163feb223285b796c2a285e9300da4e5002af0037d8c58fc95da862cae31c5e625799a0e3b2bdaf48a697d98bf3498fc2630cb391c3cc9a28ed1587f32e8545eb86e75d68d71f48f35e2fb9aa6821e947c948b13c3d9f219d0453e37302cf8d44f8835ee0ea954891a9e80896d7af91474a68b64310577ef870b0eb6c7e1880dd5d685c8bedd51a144193def91a2cb2af20d110b3d38ca05287400fe1bd3aa1cc63cddc6bb4d0b9bb22c2ec92c3c0eb55a196e3c4a9aa02b3955796239342524a46e54f0437f7448df1097f2e60438dc3ca38a47ccfd65b84cfe09dc61361f3683bb4cce375cb5f3c3f03a6db1824b6558022ea22bf4e9e1b288957e5f0e06545c2af78ee8c6b6fdfaa4c75fb64e89ffe8e4dbc827f6f0ca81a0118e537eead1636f14653e2f16b84fa42fc0a6c16b716cc2372c389fc23172c2b5dc48c2cd9bcf649f64cf8b2808037720d25a4c2692b8ad9e66a29db0709c31f1506039c8ed547bcb0e831982ec6898a0d2832f564e88c3aa608106776f4d0362cd5fd072acaed99dc1f3950a5e0f28cd309943cfd2983ff956442b63c58e70c7964b43ee81771a67fdfb0dbfbd54d97f93fc119483bb94a30de932d98f8d1a127c8ade2c96f667819cd9eb54b432cd1ea55b2d5d11ea98f52cba3e29ddd213a07bcc32d24d355e4a7fb141add99199d845131098a66f327c217464c950737d3a67921614547fba244c47f1f75f1354ca086ecf49639c9b2b0d11fba1e826cfd0d62ecb1536f0bc7b2236a7b8d007ca7615b40eb8e98336cfe74d82a21bcde4ecb903fce35dd587aa7fd7fa6bf160ba03e139eaf29bee6acbf1c1fb86bb933b11b58c8ab0258f7470e5e79d6df2a28cc0d46ee25a1237766f72a0d8cc53a4611c31d8e221425fad31f3c4d96e4bafc87da7886a189637ddbdf5bce3626d307607704d311aadb8c08e42de1f95e00981c18861686729bf1718cfb64ef58f1f1fc72a82936de4e9b778aed81da8210d3a319306dc1fce11d31a68c71d53d75d7c1bc3409a614c8e983c71599e282c3850b22c792505ef524a5a9fb713d6c3c54393bb9132f25a49ec1a566d8af47de675c0666f376a6e75bfca117f659eaa032209e56d0296f9d356f1b0a8105861787380006e30411d234dd8001a058c858ee6bc83720d36294a3f9a97bcc5ae5390de018c54ca3a55a33f93dc59e81d13f12dccf27c3657717a46480e3a51fbece7b6a110c87a166dda875e5bc5fedf983fcf0ecdfe3be02aead8bcd959ab8af6870530e320c65fde996eb53e6f9479bc57be27956c0441bb8055099c0c9ea590b980ea6dd9967d2f3afc50f8723c281b7ff16e43aada3e616cd63611514a5c223e6edd00dc5eafea141d35cd42ff6f2a3a4a3be2815af91aa8bf04c3354b5c5df7b1e2c1f3e85bc7dc2877f75ff7b2d1c46560cba1c648123fd44fe69c222f2c2813c09b8544456e426a97e9fc9cfb60d16d01eeda2c7abafbe29788f7086283192895ddb0ea3ac50e40d28d5814e65eeea5ac9f9c582d3978a0f875949e26b43b7bf344348ab67f9e1c0cc18d301989f7a0a9e3e0ef4e35eadcf83728df0460863bcbfeff22834f1177c70a6cbe6657e9d0c3b68c02fd2c81572c0eb910da327b1452722c2f89cd7f3eec21c133f3d0917d54a2781112b3613ea890a791852a6bead5d456ddd4ce133169c7b895986c3dee54c45080104af0200b58327b8689f64099aa3486aa144590dda46f0f7df9039b243f5995608f992778df6cb112ef2ca8599493911b0fc0eacc99ffb501d5bd224854099f9b337d00729016ded92b9e27eb15a0a646bba78ecebf3b7b861077ddef5a75ff2f0f1e90a59ab2be9055b16f92bc25f08d84eb07d9d78aa93ab6291af015dbd23b9838227c805cc80f62237387cce96631dba6039955e1d34c82b60381fcb99a1a4e837c64a0bb7438c324164115e3b44f05fd9aabfc71e236bd155ea8ea4e0c3f59ab2fb4ab2f8eb0a355e37c2c84096ebcb2a3950c82482b4e4c84725dead6c4feb6eeb4e08d9f31cde730a9dd251b4f00a8a802226e0a598885db6fe032130d25771979a90536a0cb5a5e890ff66076ba7dcd2e5b0e8a1f0adfefe6c3d401b83849243cc02e6d8c5fa0dfff6acfad5495d087d68cd7a3d5b04fa7b57d97d5d018749ee05038eefef7553353a79d084e66644466dbcd34f30da7808ffd86ba01cbc783a2efa4b8df88ed8e6cb0932b18ae8e4214e5f0eb1e02be33dba884bb3585c0541008758e7b917ec80a1c4e17f8f89278a35cca66334a7b71a5694ebb066a6cdb6153b861802b74088981112e297b5a167215f7a5854788a96b3f4087b1c4df99551814593f26ed8c5831a0b0f09dde52631d7dc86f9870ba3b702d7a6baa8550334e1ce21b352fd4c8ade389e20487aeb6187fb7c808364cc087471bd2eedd18995592b7e074594b8037824695a7641a068944cc8f6f8ce6e5bdd437be3549226c28a95cd476e3bb58f6e31f1f9a2623e0538d224462da09cc3f0dc1daae6c4ee14585a00138e9ed4555c4365869d1360edd2cda4b1c69d5008eaaff8b08feb8a8bae95367e813dd87394223b60a790eef9d2499c021e14b1ef8a390f635f013d5e15841a1ecf50c5f9505e8dfeaa4eee06dc5f69ff3cf4ebb120651c14baad4a9d76d0a014335cb2f9b718af78dbb590e99d4563070c004b248ace7e916aa956c62ec532e23d0e1d9357f592ec0ba054de48361a8a80c97e54591266bb89de1639fcb347a585383c385b02ec421beede280646a823e96e0297749f56bd06923c559daad39da289cb604f025f9728eb3a06f227b5960c59a60763897912579ac9015385e00fe5101bdb52e17426c3d1c1026b8ebc8a8b4f031f169271b8a959e5f7653568a67ce046d3f55dbe2bb4d98dc223ffb1625dd8c3598ef73c166cfafe4fb4e76883bb5c1945efd23c699baed1ef9bce0aab35b7e144cf1f0185b7bbefaf8ccfa512d28867260108e9ecb02bb8c276761ae1d6a0925f55fabcf991df2fe4115daaa5d1deca414b26725a3ebdc082da6c7569112974a7c038c24cc2b74ce6955b18c41ceaea7824e76fd7fc8b7d724688c83a7e14ebd98dabbedfb3047c63efaf0ade762f750fedc68a72c09b129c1ca7b829a73c18850537e7ade01ecf63a9a24fe8c5abcb3c4112d87c0829f0402022c03b8a6e6cbcd23fa0c4d1fb59bec921a3066022412c5b00a92936f3e655770695559a9518f1a68c560a624614025b8e2ec474bfc60245e358d12cefe49bc55d74d9e3d348212a925425221009c16be30200ecefc17c842d55e6ff198be273c4d0d82d04338c19934abfb55fd151de3e722bb04dec34d0fc090db2528b4e32a45503f772b872988f4f1947f28451fbd43e3873cb0c17765bdc4cda38fae07b5a1f14203f088618a35424d4d05ae6247b8a88cc9204c83639dbfba7de7b9a80a28bfbc8619f5c7ac600f92886c9b4f8b0e80fe0add80335a7c86e321d3db6a82452d09a5be5bc6c9fe05b92e13140d8fc97fcd9970e2bc702742dceb39f06923d3ecca5a864d2682e4b679d000a6b8707c82ed80d546b981d7cd8b394724e93840491c21f5bc16e093c9b14baaac4f4679f4c911d101eb7bbbf6ea75f8070a8b87f172b14f05c05d6a8097a30188e041981317382dfeab96f7de7c2249c82686d179509799c1ac70e1ef3b0c52438ef84fdeb3c7589c7ca5350fd049bd343d812144a477ea2a8542515a81295fb09f509a29ce334f0e54f84524a464c315307ab7dd684d82366c1155504c4d326738af5ee01880ee045a51f9910bdce8f7cae1ddae667dd665084cf2a1208e677168ac49edf4e72b5f8a3d8b8d5998d85e786f21295439c4cb22ed0b526391e670efe1aead45b788619e461c4c05487a8916a2d1d878628d06cd68a7252acb261fc905befdab254e1029d6b6b9bfc074d6b26a976f83788a4549e1a324ed7a7ffd70b63582ab1fd2a9c02c2018661562b258995fbd850828d876d183796a30bcedaba613c17d4703bed8638ca10130fc134c3efbd53538d65b34217041e7b54fede160a8fb6098e3f6c1d26d886294479b42748d0ff203659ec97538c8713b7dc75628a6d4bbce347a64e2e59ee1a8ed5d24f037f67d2ce45bd77501509aaf530f20a5af872e89ae8783674205dbe7fed7d69b13a77f22410e41957aa75956a4ee43d37282adba9ab250ce4dce3b18029ed1860304151856f79433bd25278ad4735614c52941cfdc479318fe3029725971892a2689585507895cc64e9a58732538221d364ab59beaeea238789c6ba4746b2695052d58c8521235118bed398e280ce9978952f5eeeb6005872e17dacd8e20c3c410da98775104754d7c4e5ae4d7b8d4e1c6a68f9c39a452063320d6cbefea899ba0f1040747fd77bebadddf5e0983e6fbc9bd25e74487853c0303c42a20be7966c28fd3d229380d063e6937e7d9fd2112335ee946f91bb420a2231548b401dd4a78918dd13e98376dde1341fb6fe24de516cfe2f9865f51d7b54137808cf28dd4724289c89e2a054ce5e785ee1f4e88066f0c59db24f492f7d138b2684d15213108e54e40e0f8c631bfd028ed2e359aae6b00c9f4cd5d4780553cade46dc7eaf9efc46e2a507f1b50c28a9b55d8afeb4ebbafacad0bf8fb185d25db0434e65c6e73dc8e5017d3e9fa3f0cc9fc4a1071a17c678303793389b0211f5e0698dac32480747974c689fe67445951eeb30958e0c98a221bec72124ffb191fbc627ee975a443a27ab276e62b3430a528813bf832222f7b7e5df96149276c2968e9c13389dad36e0637e3c1e0b94eca5ae4240f052bfd183443013cae83a3d610d4505b29657c71a6bad2757c747e19c347009825994072429fa2b6d6377b18645ebd4a5c2b29db21d130f2f5ed6a6913715a8c15fec30352592aa0c352c7746f6795a604933fe1929d9c2f7a1d3fe2daf996a716d650fdff1a945e1cd9dd8ec0742fcbc23af75aa79faba922530e79256a02aab64cb968236e01509c0a6b59316ed45ce0188863c2f932b4d4e9edf43ae19cc6a8a93a154e7f78203b84b30edc67086219c42801b5ffbec4c003308a72330b1265c67d291ef6b0ed39d7e0b08fcda9cb495e0af67c1b2ed5b48de3604446e880ddcf1825675432858f010fe6e599cb395fcd9a67c0282e50165a3e4031cd3b32b487b2f9e79cfcc20e1555ada916cef122c08f43b761cfda29080610e8a9293c5e19deef32aa5065f786aa3fa86ac80bc1d6b423f157c0df77d22579f809e73f3688822f0781e0289529f843518db1ed7665851a25c1268088f24b1b8800bcfce6bce5afab0e37fbe3d503a60804aa5008ee31a251b82c101c9797ab0420edfbaf75b12bb3af6a77ab76a9d1aa1046f89bae773b5b37bf748a6dd44cd62dd9d16cec73d03612474f1befc740b726aa8c1db65eb7bac4c6fee8cb711e7955a276469dce26ae0ab097bb6a1ef20f824035997d65321dde45487409e459f68539c56d728a69b3c7d6c073e185bce4f28de4dc9a8099cd893471edb6490450e8e740473b2635ab117d24d07d3907167defdfd96c593b9e5ea01149cb915c17970c5e87fde73c8e3336b296e0c449e1b9d26201984aa59480ad5855bd5b4a17ab30c9dfc8afe1a99dba2a72b9bb5f7f16a51417a979b7217362f37a6b3b670c8c0764a83041e121053ec708791b38c25988a335a786d90","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
