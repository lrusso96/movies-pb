<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"63f902be42d0ea99608696566a7412acc4774d541d7ce4a46783e5f0aad6ce0c78aa44c2c51a7f0da1ef8a78b068f19a8bf026f61113fc071dad342e7e3f30ab4db145ca098f85033dbae3a629f22698e048da64dc245ffc5ce2a87e6cace6d462049e4971338555dac2a48cbffc7416712ef137ef60fa2cd5be5f96f68f09560a2cbc04e88dc9626b221ce960755fcf968a65a59e446227b9c41c7eef17076c8a7d2e2aa789359e5c7098b3584b7ad77189152cdff1f263fa87cbd2c679648d24b5c34587bf51e864ed742d7f7c815f787aa24aa143b8fe2d63d7b617334c3be2ec4351253f281f54f94216f83beb1bdb109b7113328532861362a380cc59acace0d5c09b16de2c08c862651a3698888e5231f70e8b06ef4c7e63b1c269f759347c4e0d4c9101eee0956a1ef5234be1b2ca5d7c3011b014abcca2d5ef386a8bf1335384625af4e293cf40cc3aaee3b5d291b263e91344025d7b4d37247101be390347f48e09d36f181bffa633e462b9b4313b5e02e7629a7f5b2595eab660fe2d0e74a01ee79f9dba5df0203721e03eab6185c25d0f3bb7f2d9d51a9a9533ba3a1868b5d9743d852871a56a913944256e7075f39b8d65f82fba76464990a4a3d5cc9b5c3944c84025b0c9f9b21b98f8c5db4233ea5a5eb84f9c0186ad5dc31716b0e887bc372c41b3b26fa24436fc05c216d0824ab454d20a811a72a658d61363b93427a327dfb28fad309d266348c0f800d280ef6ef52de2de0b2a49226d149d77c13b937a4afd6d7eb1221930019442b05b1baf73c41efa9669bd72242ff94c5182409d78a0a78f3226029179fa973156a97aff85fec0def9c39e5559140bb1b71bda7bbbc6099360ee95175952ab1788134a7d1e3e24586cf8474ce12ff6334de1639d4f8316bc7dd5d66332bc605bb47653200d6776ca1aca8d20ac514fdf7c9c4416d5c1e7343b2e9edd21bf7a988e0f3a3b21cf39b11c03f5bc1473f8e787cfffc4dc3aef6e76bb8dc627634f6bf39776a41e768bb10b3aaf38fb8a2f6ed7ad69ded69e177414549ccb9ee8fa537a684d794ad826e7eb1c1ed56ff085945c51d1b9c9ba4a60f4a717bbe6c5c777132a827760fbf8d60b49c9e7219510ca3722c8074bdf98cf687138950fad52f67af9582509663c4a75781f3e27f9de7a6973948717b1c9f8ef54072ddde9f9079899ecafc962f31689556528f6755e086be79a12be7279b0c4f2a88267b720e72cba1de962df7e205e4ba55f8c8ff6cdaf67b0027240d50426dc8817d56b96d63cacf712a73de005d7e00148f49366625b0995700a4f30ab25dc0aaf13bfeebd544de34eb338120bc13533d4e546b48d1477ebd29105bb3f463b3caba78a5bb70c95513997cae87ac0cd0e7beed2aaed04768376dcbf34738cf2a00b2fe1d6b419b6a6b1f1a8d8d5ebb989ddd9fec93486e140a1c2fb67e1c29506f3a0c5bd72b383736dd140e20311fe20086cedec6b1a69a086ded34c85e01d1f35de749bddacd6ac69bf819de5fb1d942a13d5c5fc661cee37e1d78b90ea8b96b956bb0f2c4c9c16c87574e8abea0bc45a1a5b19b3d4fda7198c5896479cd8f7bb50b1dabfb734353c35ad8bd614e49a03e67267e9f8a330802f0312269867edfd06209b80ba8b45b4b9731c7dd2b4391001975a77a562755e05d03f5846db221306264c22555585d26ffdbcf8d9892e68101e3f49e13aa6e16575a9c65f7652cc4bf1220d52e53b42e5fd9efce67b2b16625ef2810ab413ab9a434ca8591244be9208be7f33fdca23f11da80415f1eb9603dfe4467fb437872983a420d480d754c8bf64ce42fd845f0a9a290c59f58db6e5a2302f278129d9bb3249f50c6cc37b3f668fc7f560bed9c499bc1c728c00d5fe28d27fd87f6f69eb35602d78b1ff899fa668277398a20d1d59f18be2f6921b59a346182e1744515c43f9330f801327d46ff13877d21d54052563194981568d97b61d51b915691809f09bea4d653cb778afd81a0aed712a7695741bddd49af8eae86dcb0da955dcd44007b7726619ee4d3e55c1e566407fb3236473b3cf8a77ef086a315e82326bf9c73a65b023ad706658d52035e69de6b4b5c07bb3ca94fd818e103133492b9abd52ecccdc240d0fbc6127a436090a30a4942b0c4a2568ec26f6a5b710730e682a4f051febc5ebc05fca41f34cfc75c86d3fdff30fcbe86f9770d3174979124ad3432c76af5f62434926dd1aef362efdc829055f2585ed83ca15cf3af77c51507dbd4a1a40283d9ce83d3a7fc15482166884f683a4d1b271b61c35388b9509e2509bcab2dde255d10c0d123201808ba62692d0ab2f76e443c449e113c80297e1a8fa9865cf70812e7013918d2a1a413f481186d3465a267e9c01fbf940390c22cdb8ec875903169412138c0c10783cd6af9474c394dce3e2c24ca291594ccb45e2382035122ed77b45b2eed71821395c399b026395cc82faa6323a9b6d9e79f92361c5f1d4664c42287b03d70d7f5e41ccc98fd16a5ad715739e44ee34c026a3e94c629a60d50e22597aa2ce2a3725601e4178ee9412b21414b9491b0b47d47f1a4aeeaeca8e5ef6476dd64ef3833b89d32308eb3707d222c8fc079369a7d653196e9dbe936f42d35f16da393a434e79ba0fc2bd207b3044b145f2979597c37d56abd63117b0aa6342a13a7b05e2896a7155ce8a0c12580f605519f36edd9ddf296033d2e91f522df04bef5c1ed43e09f414acae765d306fc3f69aae9ae335adb28e4755c0bfa89b3fe5637cbd9a7a42f3d6e689db030f09e5d9961b308b9498023b0f65b3910390a63ec4d43d85ffab41f5f10609cc68db19c558f4a8a23f8aea33a91eeaf4349bb0669bf2dd63bfe6824105f4441f38452ce49259af57a31617518f5b4dfe83bf82c8873e9fecab1af57ab6f7d0747ff9e1fdc77e07d1698410041e11532c5b332a9b021c4cd93e56d88a9ad3255dca926222c4232cb5c9f12ba2db6b333d16fc210908d1b53e2d6dec824b28269c9d23e53eb584225f534dbf5f993de5ab880743ef3855d4ad5785de37d6829e0d1f47963ab4a535dc5eaf638c84e2f157f5c9601313d7c7e2ba7f43eeccc4e0294b4341f0d218df830aabf41d76feeb8610bec40a9f5214479cab904b9ffa72088740b30ac660a7696bddb9a2d1a0bc69bf303ab9e3c65ced6e92d04954521ee89e9ee59122841317a37b2d984caa1b1afb0d947364de0a99c6b4aeecc0ebbf27c20e453f2a6c824f29b2ef642596cc9a5eb754aefcecb1a42de21f772d8352f45bd7f2f7b2c20c8ce05eb4d4a94ced8d7e4fc87495e592de56fe19d1a7ddc6a1cb6fce225ad5697a19f072ff438c0d0ba5db20fd2d9cd7f8ecb5317786c32fb41d0d3fba1ac785faff632608aa2af2cc1e3fb839ffc9142d633b04b1275cc00b980fc995a092f61572c65f9e2f547fe5ee62bf87de13c1d6a557123483f86acf005f1384fcc14e8ebd3c006af0651c35cbfabeb172079033100def90f28f5871ed82e4893c7544d83796fab4fcf9618514897335348096d0393969df2ea781dcdeba4cec0c098bd688c83626687ff7c49a778069b37067b5922772f6040b071a61404e4ca16b957b6a2cf217eae320a942d07f99f94ca794ae27d12e5e3b0147e6733597892efa0536d39906a0f25f484aabac3f913fd8561612c26ea8fcd889da356dd70a274805c8820914549bafaf404c0197b15024a472097bee9c8921f6ddbfa5f877e72f8e3f577017be8e7f31956d06ad8fe6f263433b8a1b222e6321e040aa2a3a28f62896b6e935f6633deabfade07df3b5687f360641897f66b8bb2ec02c1e4fae19d0f9120b61c1c3889c6391dc9f31253cc49e0efe5c762064ae01d3ffb60e02c16756ac6aea1882d6107ac5bceccc7830de323fff48dcf8595785358bff84c3c0012bdf78d930c520f0653e9be2f1bb668d7d2acdc9d625543fc54d7bca0d2b1e39f5a051e738f3597c0f0fa1d9bbbd53c30013dec8f629ef0d4b91f457c1e890078f678595f679eee1411f68838b61ae5e0e8f4492095c2228422aecbadd94a48a5770f9692f5935dde117e9aea8583f400b026d6c34f7a4f0df1b0035c39b79a22b8e9754076cd8604c44f1d280012a77a4bbdaf2774dcb4a99a94b3b4a12c3c0d1142fffc444782dc168187dfca51d06819aa5fb2ccec33c4669f6ffa75a9465818fc22947cfde725ad50fd6fc67462f45191668132001a24040e603f7907092d5868a2cae8c5dfe197bac63dcc4053d93103d5f99ca0b6652a4769675d9366e54388fb93a62ab4c3d26a36dcef479771b147ff417df7cf1f8a9f9d414070411d008754db40764700e20b95e5453b6ef28b6d5ed94b18ca994ab97da09755c203507d65a40bd7de5eef76fc4816b4b874df4916a7c78f60a5e44a9da8b68b5452566e7f29385f9fc593c59d26afcbba738788383ab509375a8f581641941159137f1f7d722ee1959574d8c5ccd2255c5f14a1b66ba95342597af765535f5a441bdaea50224dd1d9f138292c90d9ff4b3775d18171cf2fe718f99aa64b2e3e6f489633a164777f343dbdcd7886e4cfc0080e4dbea211f27519e721c3cb5c26091da06c74fc7acf7a3231859bae21197e44629a0e8a191e6577ac799ff6c4db144d23053e1d48733ed17ee9cd62dd713db5e31d8136be8b2073028bf969e5e3e13ff0a76f081e68629f24e9a82568b72304a5f90d4e1ca8e781b10087eabed67d6852c033a3f3f7520587eae6bdb05f1defa7b70f0fc0263ba4c8fc42856231d73822b07e890ef30ce22f7fd3df0de7042f5dafc5f7a579b8af6cbf784113dac804da0872eeb59feff9187d6cdbeb6e3eda04caa02a4cb6b1ed8c0c4b867ebf642a6acb044fdcfc62bdfcfd01fdeaf01e4d27a3bbc6c9dc3d406f8dbd2530e0c30245eb1532c4a2c6ec02951ba15497fc73944c7dd0d5685072789c5a3415ad6daad0d8106fcf6688705ee51e8c5183ab109b0a5713c0cfc8871c6bee6127da580735ea036c815261f9566aa481b34de30c4221923702c0ef299243b193cf5085db3f7b62e93e97ccbc759d720f233b36f993bc7341b102487eaf3197c8141cb3df698e9e6fd202f1bc15a5d36c41c5793002d7288f15bee20eb3eddcf336661aa6550ae54beb9d45b370589028f4b28660d30d4a334289ca430e9cd8a267c8cf110c84cedb3d007e1156e7342b144766661e0c7eebec6d649f3f9cafdaafbecdb60f02a53b4f12113f4bc52937e6588b3297d6aba19c140c7e32cd08fa08bbe3d1136f9387c8b9e925567e13c2483588186e99f22e036048b86d086bd43c60ab41e438eb6dbf48cac0dca6dd52f7c5fe15df2d40dc246ea6f5f73c305c920611e8bb67b09e70f30a3110009a8350ec57d125067f824b8e724f73d00a792ce3af3940804779d7eb949b8a3fbe925d6e72e1e0920bd0d4f3147c873deff9f61d86d632eefeac494d752f9f1f8b64bdda8b6a64c3b585800a0ee35d06b73ac4a295738a28dca08ea6cc7c7f33836b7f0de57ebe616fd6db23399924c7c502258cd7c102379c09ca028866a8d622b9f8ac17618c587baeb1deaa71987e03b5fd438f98b0f75278b370ecefad5ab0d35ec864b265ca7cdd9f23ee2262f5ade14956e77b919d69605109aa567776a93e6dbd23f1c0f83ca949c058eed1ed3dae5e4d8b683125e1830a2f2f7b4229f7c841f39cee2aef1106ac588cbd16fde69891406e6d76efb1fb0cc733b869b6fb047d4470fbde56abec33e314c43d7947320b526285a2fc213daa83471c236e746af350eafa0e0172b48e6fe9e1f4f93d6190aa8e74e2a5a8e2f06592774d5e55df329afb0aa7519ebe1cc4b6ea3edc3443b9674aba3dbc0ec4c6c2e0c322927a47c4ef2222beb7b39fa97439276d9381c771a27ee91092d08242a9c7136d7a3a726927f2c7b0885269016c50a4cc12e6cb85ba46bc4fc022caf47138422e8e8a2973837cfe2e091dfe496974aa0ea449fc24c1e35136c23335a3466eb4a2d5ef5204d9cbab924a441d8885ffba33b6cc3eb98f7fd8b3cbf77e4858a24f0dea9605552062ab461a87b9dc4f4aa51dceac87a0fae9bf90669b61f494fe827c83032d7055bf14d9ccf0c1d75818125b092e395e129427afcac11a7bc66779eb7aef3add59060fed8ea8059f62b970a0c43ce64b447573e1d149ed248423150d93675c7859c3d095368c72e2a48cb7483a80aaaa03d9cce2299c1d1005ab4a6bcd06f0f3e68a1c0ad1683240f6b8ee7c1a1f815bb1f20685fd1327ce4f404fc55b56738811e4d761a33428db98450ec128f20bf9e14e1a8deca1ec003534a70f0daf8e6c3438a502df7df2ace0291bfa3cbe401894d40996328b02811c6f16620e94197db15c16716eb2ea88133ce216cc679304b053e8565f1143a3964f64a520d7d24d6c13a8181d8f391017dbff14a9c711297e78e63b878e5cb98e7d01f299ed40b08d9a5b2473e642bc01a749d84a08801d605859b7fd8d7e6bb72697e76e9c44261dc0ed51426001c15bb7f7d62c286e1e71bf1e837482e8be2d0185c6d6aae61d055cea3bb18fa3c14e05f373f2ecf1b91c7b258949bb99698fdc02db1fe145b28667efa173095c52bae36cb9805c1171735697d59f122c44e98ac878a5ec9f106b9d9b07316d0985174d0444ca90db6fdb8ea2dfeb3a483d523971642e06261c19e6ac7ba81c395b1ef8b87e106fe682ddec82354a2af56cb69c19d1969f4e8abe59268dc174477673063c0057d74040dc9dd22b6956697f03d064092423d465236fea07357fe3f62a10ea305aba080eea21d0cfb586cca6d777495cf68289d3a232329a727d1704945e85ab7191560d8792b7d71c632e1a35dbfd406a5889d18d5186ccb159a0cf6627e5ccc8ca2ab128ac689afa987aed89e863a044ece38e7f851b953a74e1a04c99db31454d7649df94c15878bfaf677895eda20e52d4b3913b146effff35b19cff0e6ebd5169bd6d2ff03c50442077b335bee64f6cbaf94008df4734a914d102fb8e5ad9386490f087b5789fafa3c22884f4ffead8763c89cd8537c1d2521e3f8df706d6f86dbacf380e2b839520ae60eefae72b34ce701c37b81561e26178f158968d336600996a94d5b08ac8cae9c6c1b0f89f8b0bbd82924e01d0be63fa34dec9a5341f91657a4a2ebedb664663d54686554be320e70e8f39169f5945e8f46e3ad9543f117174fb6b317b8e6e8840dc22ca88023a08fada7cdd8bee90f91445cface78cc73f4c7b9e5fe633a7f40f531f159acdca32bb916bed5e600cfe555d3cda1e3cd2b3d1afab843c23f452f4ae233af8982e2643ddfd9abcf4f8feffa60f4af60676a148e16308894d3bd4fb58ccfad567551710aeeb4658b317f113ef722bfab86c4a5dbaa93ad48c43532c936ce65f315520f696dfc4be62f7c9deda90b593f1bb62a58542b0018a1047a00856aa3853997624acecaa73ff89a8f3b3f8aa9998c8e0083e30393d8626c6089b861807003e8faf33a5c05300de7f404eb6eabf668727a48f857671369660a561dc8a87616465b99562b7b4696b0726b486abaa6007219020ef36b3bfe91e0bd841b9a21319ed44ee881a6bf0efb5d3443286e2aca8e39b6be1a4d4191893e11fabe5412bac312de62dbcf698eb4c747ade1f5eaeaf8d63e7fdde4cdb550969917f7cdb01a72bdacb17be022f8adbedacef52495a1c26ff85e6dbce1375fdea24c5fcf67e3e6c612f93cae3faceb48ea3cf2d818ff60145b9f2b694ee94ae0154804fb1b08281abc65d37984cf48a57c2b71385eb21fbe2c9d7a29ce867791f65d2d2dbde7b6c2874465d0b4bcc521ead2461f8e08d68ca633287d9938f8afad55a2dbd8d3257156329ff1e729616c3c9bcc697cf37fb905b7c0f0f964483f4f0c8a946fe00bffc8af79dc8475b8ecadff17c687045fcf78eb5155ec3b3f4599dd61edb581c0aa7961e5fba7eee5c7347c1c8ee373b3c1cb8f5776376b666979bfc43c570fa40c7ee6a5c8dd47952a1bb86727c674f41b532964faf3a83c681eb1223d89d6b92c1ded560fa07cda99bac462c913e2fff570ebebecfe1c40e9d21627a6da49b4727adb6b946a439e071502431144256a2944b5eb992f5c52c3814e73b09bdf2ce2e0eacd0d8d68c1787785bb51d0d95cf04a65aeb0e9c377b2a664f43b8426b9a0920e27abd1cf211774529e92ce25de8b908c1f61dd965c5692d77a031ac1f832b4859faf4ec5341bad0724c63f1b6b507ccb0478caf67bcd0e7ef43311b06a547303ff19b04e6bf00486fe04eec7f5ac0c406ddd2949728f2d637591dc6666a1e37a102c5b7d5bca2bd981cf046933900eb4b574e84cedf444d01d364c388812d6f126fcce7f870f03cc6801708c9f2186568b12c3ead47a679f819a2fa9cab5b1b340066b59947f1f0ba91088968d0052a0a9e1ff38e2e871e162e08c6d0a0f2b699d46d8381b2b9cd90b0ac4273d7afca6926ff84d9c7bed0ba7c1125d8683719db71228d1458de85cb318a0c48be0b830ea0446f484f1b0c9230b7d57e5dd744c888f12989107c54661bb0d3abc07c7fc47231d6d60a38eeae97d4ece81d943aec106c218714339a35444cad6e41278698c933aceca8d66145a1b1888baa3e8daea67bca9142ff6d6d3eb389d2af048f64b67847f58be2e21627baa33c43e908c493d6d4dfa68c09d9610c016b75a715b7725b258f4b4b4c69f3a3c0e2d6c6bc05049ac3e8f542f0a7b6a9affca6b7923ea19b4d2facd17ef6cb8a4620a03df9b16c411f70526b2565ab5a84c8e5a5f030306560a7a822e6a3d35aa6205844e65f157d388e3a8ed41642bfb15728e1cf7cbc024836ba6dc957ff82757218c7407816a2049f77f009291d0101a933512872eb70bc9c88fea88d1529f7067f2ee98906f0c3b23a87ca702b3f5c7d4968998622e6c4971a81e9677f99c7f11b75c9f2d120156d697ff886b06fff9cf4e119201417e79d5eb9428b46fd8e3aecb87d122169d7c651c6de7c79e17f1d56626e57ecb8159a2a158c19b11fa106d810a80610c9dfdf0e4988ff57db0e8663787a83a7bac3bdc391b2235c8117d54970522fd092304510e3b1d56c861fb9072a1ac19eb5058d6cdd0959c0da5cc114d5154a67be6cdd1ba9c9f1e6b6a1bcd84e0da0825a4faaa8282ec2753dae1147aca9e149cba0a8946a7c4a5b2e2de11cb1d7803544426d9a8d1d9a9985508bf8e7bb1699ae923b9b41fe72f0dc96b33a076d8d5cb108d0df9bab2a0bdbfff7cad50b1704427bdc57b6437b840e3f1e53d2a8e6b8ae8265bf5cc75dd3893789a78b8426781c1aaa60a1aff62f77e0998af272d29a3e71a54a949837bb46ee2f041befbc89197c59d6cb1826660bf3b92adf3d596b7a97897f5889b006816e638ff776be1c5f413dd4dcb4e792d940b9047c91a3ac8f3057a62194e5ba3c3ffc387adaa691c028210e03bb1f5fc0e0a5b0087c32d03281c83a38e08716859ba47278d9d499f76a83d166443f004df2eac7962f2fc251604cc543f18ffd7d25fde321cf71b61ba23a2d4341c69afc4a6db8a2f9a1d9868f6590819fc37c48dfef26031465e13acf807c3a2287808c11c0ee78264a9175297dad2fbea5981c27801b2953ecf356ce67787de3e2d91014c1d2c5a3a9b620c0c7915b7109562cc04f4474a08282419ea978095d789a8959681bba3f3064826c3f46148df29415e7e15426d5624ca5ea946573efa2c4e90604c5306949b0aea7c14218273f84dea544d7e2bad3d28202b34e2b55ff8e2e45a091437fcdd7de3c8fd39d25ba496fea030bba8c2a7e5df19f24cee7230702c4e798af0c824d27cecf0888bd7be38af4e93e85961622dc170e2ce492a8326a69ab644f2c77a88f082d0d48f754ad208d674b9f8bcdb6fb0bd54a25fdc828f9d0ba50c6279a70d918f7c0ecf892f03d06808ada7b410d1a4ede251ae95f54822d873edeaa35905004133de4f48b32f10520dc6202fd6841fe72d311e21712e73a1827580f9fd7ca7322f098b7a6732eb30f50f4ffb0490d73a2f61f8556de24bb9fbe2e90d0d7dbeaa5c56b677209bdb3f7e138784dc08fcb2fd0c9f17337c63fc95677cfc1cd120d55ef4ca6a135d6968f95809b2a2dd97b9092796f19f80d7719f28617dd484f4b7234d022908d6ba9f189684da65c06f3aa775a66d47dbd8c054aca97c64b88bef79535afa6e283924adc939fd778c1d4e19fda77bc5ddc7f0b6df2f8e140e912c30b6f8495bbfe471514e6789dc8255ca86389d7045cb592972504e16b97179753ba7b90aca3cdc7a3225f47b9c7b7aacc2f2708c7460a4fd419d66cee5454b35b675f8e41869510af066998084b3f497db95986ea8ad9103f9d8b0f1172a40076467a4f2fe515f6ef3d037b531b12e064366b5434eb4e1a7104660968ff7a88bcf826d7f2d2c96e664ccc683c97a045957e3171b367f4f2f328f30554fa7a9662c14ebd27a43c9f520eb5459fc66af87f1e98e26853258e0c747f08d197f38a9fd9bde98d9a5abd556152779a4f1b98cc799645cd674bc4d0c70fc9dab8b151d0e9320ee9de140b01db61a47c18c9b05b3a26a16c9e55614ed07beb344cbba4ad684d2ba64cece2d0486430007a19b9050d21d721d4fed09351f8a58d995c576fa8684a4bb3429576edb707b77473105a22b93b4b81902a02169cd85e3cd5e5facc20df7d82c97107e8665985deba6a9c2301f3262f12f3f63a16578b53d5bdf04c6a98464d81e26dfee14d0b93b2318c4c62c28df0d2f284bfeda5afff508e56e27087a12aac23deb67e734de04ff3d74d90ba12258cc6014a3258213bf92f956a1097d78dbfdc491e194236b7a4fc325068bd43483fda37fe06d90d322a7ad89c292b401eb31e2df77d589cfc93e8cbdccdcdab85c2d65906e65f6b66bbe89548e9ce7a3688e4e964170629a650e3568f990ec978b22119680f52b5abd67c2944204bc0b89dde2022a315e243b99c75f829f389029059af67791ebb9671a1cbbf84d85bf20af6eef14068ff8106722f8128ee1af30ce6411da4ae28e93c83c6f0c4b41c0c2183399fe33f1808c9ad355f924517f9b87d011017a6ad548bc041026a2b11418bb6bde44cd464ee3649a6f5bfe9bbcfe310ebe2aaa383a07823ac51e08ef21fc4878931110c34efcbf348095be7d6802efae5d7ca391886c152ebd32375999e8dc289b8548a13274b8d5e53e64c9b7157633e1581842d109a949b0e454cb4a1cb97dca54573ccf2660c8278616cef14f18780b3faf74a91d5c42bd86c5ed5cde990a8d0a6b6087b226d0ab50ca78da04053215c5164332e36c81f2aaf305eea0d2734740b8f664ee01838feb21d2c0b122f266c7a9c1d65a68fcbe369b7ab0ed5fc6ac5037c3130bd34b77ab1ed48d984a40f3e1cbe47414de414cdcf04ab6e58f3dc32c52b29810779b6b2436d18f2682ccfcce3670ce958c04172710da1533a441ce1ad867ce8ec1a27118a350d2f7640a5cb0472a2b1159ba204962d72af1261a9c179eca1b0aeaaeece7d41f4abead4c7f26afe8210443b7821121b8951a4bb012fed362cdd800939fe6931950991bcec7602bb3014999e8b4127dd1d5cb3ed6f98f34e201e3c2ad71573c43d226acee3c6e1202a62c6556700981963e4117d4df76cfd662dc731208071b4c5cc0c70554fa5afce9b96bd70e4cfd99039f74a436dfdb40be16a4c34b454ebdb8c7900f4c70a968def6906f52cdd42192f3461410a69ab8796756c56f2d673f0004eaf56cd04cdd9df8cd63385d2bdf9b04d23d8d67fe1d656c50f1293d68fbd5a3177295df8a7c507420d2a6f46f2b7166d7de05b65417a0e5109311f574ed6874a7068e9ad0138aae0d5ca1ab5de5f1587eb43f5f0dbca55c870544820b87bddbfd5778dec7011fe88ba490b74a55e1072a7394ee9401ee8370940cb3a76ee1044e6aee92baf611734eb702fa1fc451e3afd6400e08132f77d18971f41e95d10698bc5a2504310471973a11976112370d384425fd1e3e565ceab7a833593734182ff069c96b2dd0429d704a13cd16513e9f3bc7742010045b87f632b4eb90eff47f07b8ea03d4a901346abf9c0903eff09073abeb47694cb7e24225de24a24202ac6141e99e05f16b80dbd37c8be6098c5bebc194f9da04a55883103e7b3ea092d48df84aaa405a30a0b1808f16f4380b88ebfaae1287eac8284b99ef86d63e29e40c55fa6bb758800ce3e85d0aa920f460fe4f244710a4bc17c6795183bc6330c0d0bb30ed956f1a70e7a0350db487b6b20d12a742fd548ee8480db2e741e0b5ac2bd915dcdaec249c9d306d168d958249081637ffa9cfac973a9bf317e683d736d691d5573358b549b280ed514dbfce72d60e690d7b6c5dcb84ef09cdeb08329b291aaff21f78ee3747e6da3d7cf58d46fe0385bfccc25b657ba438ea62bccf5f1ea46665be7cf9006c76693ac1bd5891676d30ae6278685bfa3ef8ac2c6f971a2bf026af9e03834d35edcf9933cbbd0d44cd03e8a5561ed0e63c907101500712cac79be8501f3df29e43a86253b14475f45d6d3ccba46f73de44d7ca15253ee1102865ea99f9790ef57cd4bf43872d306cc97f3dae50205330d21af5f07d96fb8770807b33dc99c8ce3b615664a257a56cd152bedafe2bed28fd6718cdb8c00a2e4a62d50f9b524ec3fbf0078006c1071e35771c35b188d97958b57aa57fd32df7d347b07632b7b00634c7b625c94439fd481cadfe4e0fbec8f2f8aa971d1d7dd970d45c29b657b98f30c8e0f6a3b38cb540a4456b9fc89de99790cbae60e28182d513769bf9a6be1010f8e7052f3075a07349aa29d0fa4d2dccca7ae28c2c5f3cb095a6c92506b0f60ee6b191e01c56879af772f950dc8913a5faf87a6b0c8e3a599b81c524c8270f38c1e7b4b6de4d328b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
