<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"aa9c1b3ac962d4ee194d0dbb94e281bace35b2a77d32b564cd36abac932b6e24cea5b0e41058ff2a2fc5388e766b168f4c891e7265334bf61ca8ab7f95da1f72076400d0e4e96e7b66458c4d3e0864aedbf1e75f07965745bb66d89b5b9b1fd63565586f48bf3e2b2ab4e6cd26b828cee42082e64fb928e0e7620fa2fc78d34a3d9da5538a19e52fa80c4e370884e21085943e35035e0108aacff7e0735d98b05a4b3bee41fa5d6a38572a2b2718ffd9c992ce582b3aea1b66776a84250f0e207e64604eefa3cfc9f19f17bff000e26811379ecf0050e91b089db07fdd85ce7ba08dbff8707c6c2c569ab0b1c3e766f2126f4490864557750a8d655fb7806a81a2d80c1274964b93103b55b6b0c5a7b8b6dbf3d7108c9e67feaf10f8204a948610e84a1690a856e7ed0bb1b2b0ab1b8acf2243227a4476b88aaf4155a722cf234c5374f5ca1f81d7b1609587a8d4b7d92cbc4d487af4bdb12a195a296d6ffd247e73c05b05840168cc91f73e5ca7c6eb245647f7cdc930fe10d8486ab93a03b7cbd2fe5d4a636a02227fd00568f576824c0f51ecdcf99c2ca879b5e6df53061cf9166387e7bd0eb5aac956983482d469e44d83c5645b42d6286c76f31a8176f8195c62688003900f0e817b59c3efbd0c22a9f4cd89d02deca2e29b5e808bbac30c8314e624e8fefb37c0177f7f570514058671d8bd2c845edc993b9c1b6144a773d7f4d5f3289d0a7a5e0e48a14b81a6ba9d68895545c82c8f1b31e6006f306d0dab946953fa9a3f410b22ba159b992113adcc8566f929d695f524998c4704b4aeb843fa60e5b3d2d7b97d55f81731caae8c363bcc432c89bab2c474ef1e1de95e0464aa5e28f86d2d2aebaa252417da0cce64527e5a9448b64816c7fe39dce1471ef3f6a17987fe15570445a2a1297c450d80953a935d68c96ffadbb9710d5eb4928eb50c94c630d40201b7acb4a8ea0ba27419592e1e746e1902f8c4257e282ddf5c220fee56f9d684dd3e82317c276a9a744a20e0bc62665808db5adf677cc914b4fb282134b87e44eaf380121ef321d3be1bd3e443eb4b5477e950d0145a30d38771131571e9edd0c8161206b4dc4f31e8d8296b960ad282d9f09203856fef55720de1736c77f578d6ba7bb3b6df295b537be729a4d8ef24a4a6bfd4d67a0f967324b19abec4a949fe8cd53614480825b872d71c174b1474f9d831bb7a8f35df2123dc0e2af4d4cb79b3290391f033fa1e8bd176f0c176377e8798aaf06aab3f6c135273510866c8924f2bb30a638165774210e79164b25f48b4d081d433f24f7f4bcdfb961f2555c5ff3484aa4247036829cc97dfd6220e4de4c16915308427c61c6bbdb0d283416357b470b04c788d4db738678244b53bb40ff8773b134456722ec1bbb35b6fb7e831d0d2c1023951182862781d78c433efc18351c24b13dfc2b95aa69714c21c6d36936133e063759189210a147bf7ae383c64d120122f31f32c4cc9a4477bce9a4e4e5aec55bf1e3d6532e5c435d4b2237f32f02e914b1b9bd02392a7cb6dc8faf75b489315d0f9dced18229e176083d38bd1fa407b869e62a04eb383cf33e0048c84a99e5eced7dc22dafb0e648887a192c59284896a62416bc34fdb52fed01996bdf8950780fca4da03f4a5ec3b7fb3bc3c246b1115d73d43fce2a705ff85c78954dc3f593203e2f9d3ae54d360c5599b995fb453d1f442fcb1365bf0356d67c1ce9cd420b4c9764bc9378985db73cdbecc598fa88cf11ab5b1685e46ec4b86dab996dd08e4164b139aa1c9e02750c0fe626fcd2b8bbff675b36796265098c26ee081f8afa997a324f783cfedac03c8fc176390995e5720168432faeddc5493f7f90be010cdba71c7985544a40671a7b84765bb85b1915ef12390b9717b60395ae9226a9bdca2e6b244c885e7ec9364f1d0fdc4392e8ebd0990a5f3f364c9ffaa8a2ec11b3eebc8e48ab3b6c5a9117a26bafb1ea4ac659e3419290155344de2706a31297d761699b7c0808dd8ac24090033ac2b809bd9a0d4f7790d84e7e92be948958a7755b8d61542be7d76409d272adae29ba458b918c02f4c5240cddcd3c3f721c18ad3c705dadd079bf1abcc644d9143b6913caa6404b8f169ea185dc1daf8ed3ea99e5fc115c6cacd6f95d221b90811bc6976d6e77f222a0454fa2082321baac48dfda815f0b46c85def1d793d1408e9727bbe6ec2af9c1557e5d04810c869031af699ab62829eeec02e82ac570c6fc96d61ff4002a9370caa761e5dcfcfc8b0b5132c474f38da24f1f3c0b5d58dc5294aa3d33ad5f6be23b7217b7a330c267a6e7731263de08043a03c5a772d55f2edddc0b2cdb4f09b6d8007bbaa3bc0f03ae7b9e8d6e86bdc82d121330fb946e59fec48f04c99f92845ec1abed49a1f2488794c038b75d6571a6ab0f0c87ce7e1c194872171922e5142e8cc3ce2ed685597f74ba5c5893dbb67a39313156f44518bf9eaad54b71a77f901f66d1ad73f3640b7887c7e17987fd5a932c18d9681881f0d2642ce431d4b1bc77ac27583b818f5826631b61b99b54ea8f7934200c8e0e28000d58bf22345016deb2dd01a84fce25a59f11a7caaf4c1b0add617fe96715ed21c071933680d352686d1abe6ea3011cf1857adb94eac8c370a06ee54ab657f0547a384a88d10d76daecdac7e5b1d78316929c5ad137e136a4f0c35b635512dc9b3ab11802dd6da31310c7f7f8caa3538e3f9b8222b0bb16713bdb1a7acbe4446c4dedca7f9d455ba448ac2d38e5d84678cca948b79ac95d5211936d4239ca98aff428e644e82aa8914f5f9c04acc7ca745058b7b43394b5f2ffc59a7cc66c5501caab7ac566ef3cd3ca680df4132c8e37ab9ea6b0586cd669c001e9302d1e7c527934b16cc3a93d2ac44eba6a96b5cdea59799c92851e1a1fcbd720a092a593d17f47513000d941f88942c9af8763e28a6d57fd8076a45f1afa3f7ac6d8a964841a12c1fafb8d9eaf17a227f353095f15b5841b5d976b19f800775839c542b78812c99390d4726faf11e20ebf36c0527c9cda72bb407d5774e955d6758692f2f6f1eaf56b4e560e46156c0c3fe33fe0b6518831e304f38e1d5918f84e249c0b7713031f8b05d98fcf5c41c040fc747d31426318a92e5efa2f730f7f42a46f288a2fed2ca0f6423c3b83a20b2240cd45c7c5965fc7064e29d09081c9ebe23f9b2d568d5411773cd3de17eb2741b8f98c0ae6e760356c497251ab20f39b2760bd90b1b95223ad76ae2998c89a93ef30b6bb0b8664accbee394f7477da20808987fa380500f823e1a2390f4f2c0d29b443c60202860236b0f8078e6177b1282b67fba0538fe9526e58046443470b3b4a397f05e639257d0fb1538d2c0bc8e5d6a258e6ff68b21407851668c33907907d798f1f6b46b4d11cc8e0de325667cc7c0da22a00791a0c552acf427ee95a143c240d8ef2fb1a8a0c2cdbb164dbcd8d799cfa33b4ab6f32964d0979e325d31c936c90c4594d5a82841b64e18206beb0d13f692d05fed88f5129f12e7facd09287941a82a4566826b8601635b0142ddca9ed13c0de71700a6bb511c3894bdf06214b4f08c4833352c79108ec845206eb8634070f0345ee086f3e4e3ddffeb37c7271be6bf77ac1a9d297752f500302f5723ab60a907b1dbae8fe3a5dca8ac3bd59e7f7aac23c63ffdef0e49827451c23f6558b00b8af93867a15181440960b2531f0cc5042b36ac392e668140170b7599612a8e8c3b9015c7b34a8e041f4e60365de88c0179151eaafc0a3e45e71b1763810867ad204c55541daccf581d8ce08418c0a0db963a3a72d3d49f4d8c4cacfccfa9c9ff3c46f4eca9fddbad6c3469f2061be899c82ff7e39bf2de553a56eccb37f8c06a5a75b24b1bc535f72bef91d1b174f552a8e2a6ea9d66173c1137d5c0dd6bb28e91c1c34865dc6d5d776969bc63a6841f593b077fdfadcd4ed0f4d1064d481c6a90825bf611d6e68e9cc63012d802452ce44f9a964e2c7f468e5c656cb594aa56e14a43f96507980a0bb9d5e5ff8bdb2e8fc0859dfdcc493b20964c318d3f3b5de648911aad69894e50391d37c18b5936f90cb341e92a8b9d07a28b893ffe57810180599d000011c4c2efd54aa1f15be1106bb6a8ddfd0bb10423e9ac3cd28a296333f4276e3b1e6995f69330d0baf4106c4137225de32daf3454e410a6eced3ad8249c395eab80fbddc32ffdad5786a518be84af6651bc52ff9ac597d09af953904e98eb6fc4e793ad6217db97ad209f5e9c63795d0d49a51beaffa83c6cab116c1bc236d7593967893e1f94587255e8572ec7df6b4177da9c694894609ed759d5517c5c20f2cd4d276345ce8586461379f57e17a59745c3e80ebdf308634c0074da66ce8f01327d159817738050e0318d965b011abaaa1823ca1b1c4a44d249af51e8c673c17af716be286f9be6a12b2f8c844ebbf1827f9260e7000939944753ea2b14ea8f45aef63d622ac873683ea18e7b4fac98b775fed267cd481060ea03031e48dfc4c1085ec577ed254361cd1e6428086b9cb6dc63ecf55891f9969664d5c85a5384804280bafe50caafa3eb0686b516194fefdfe08259f48d635fa23ef1c8a06dff347b60c1f0cb94fb3c2ca1ab7d7788044c0c34401c2826f93d9e174ee12016bea4c35be9e38661a9c23ef4f8cced039595e40560fd9e495f1037e90656cba7ecbd7e94cfc3f2bee7965dd42cdc79ddd2f6118c0c4e7a20e278f9cea5f2b05d209446866df331fc5f6ab0fef6b868c8170188d8090683692fc83ac836a7bac3326f2046605d6e15909af8eb7dd73e8f1c9c400b2681cd7d8d571d6adb086043026a4ed7616c1b57d27af6a5df9d97ca6f4507d56f0111d02bda31cd4d28202ceb7626615dcf4739ec28bb7d842c9fef4d63ce949389545da77ca6e32b68acc6a8f42f8b81a8b79401f51d45971503f4dffecda542009b9bc0d7a8e6270e8d59b6d43e7f049b2fee80b3e30275ee38c4e53d3d8c43a30a1e10d1084f9d51a194f72a9929873ea4cd324c51a2862b979b6e28a191dcf1d8b2c206570dbe910198751668da9c4e68100f5549d7000a4d888616bd64850363bb665af88e01fa58729343e3902acf160d42cd34d943a8f584a1c448df680b474f91f83cf2435728141ca04bc8d7b8f12bc8ade715eb712291035340de4b965736f0b7a305300bb0079c931bd155c2d5b74972660d8408637c16c6a1bb866f62a53deecb08631b18ef2dcb033769379483e072ecbd775024de9a130a420fb39aebe032fa4e00a93905002caf5c6313dd26cd08e8f70a4917fe08150f8124b0319b1f28a0af0407482939e2bffecc245e712b7e6636b5fc60188ceeec6508f81d4bb8cb96807e9272b67697e0d433e1404e8518833127565867d3320571eb9449474d2f2337c32a54d425c813a8fe4e6c88f66c172ff973f5b469ff949cc72a58fce13ea01558e8a492191493f1e26e365413081550017abab420bf64248eba68ebde2354a43970136b43b87f765b3bf0b154efd2ccb14cffdf2eb22d34a0aacd135397e45f3a6c80b9f882400a67ce67ee0fdcee953ac8e33033b2286030b1cc930ab6b20bab0ac5f0ac326c05eeed4b4fa88bfd6aeacb91b736f6d782eb8d5aab6271f741e0d933468c705523470d3bd59cb9891354095eb66cd5cddfa17d2dedb101c7d29aabb8b5b8935664dbae5ff655ac8a55361eda6ec9cee3dba94653adc8bc4f4ba0b4f560b2e3d39053a265859b5776b2816650a6f2eb9eff50231f935cb87582d612e1dd85ba6f635d25d9a6251360b61774467e69d4cd10387e38f7ab64f73581f9181177e5dd9fdfa3b59f7a42ae89a64245132a56c6609a635e2340e8e2e34bd43a287d5298850a6bb9c4e2eedaa4daf0f2e875de073875ad7ff04a2ca470d56726ded647635b5526473f5e8d1949ae2f342db0406f91f9a7845cb5a8df2d093913f067fd044f547cdaaaedc6ccb40802629d655ff1a1649085bc28b80da3a8193496796d716ff123ca5dafc46925fa26f76ba45081961a1e2062e6c8493a96ada16a4279e21f8765e3a9cd32562e3fee2c7ee7527d4cd1167a89c182195a1722858295f70683e1088246c9f1987565cc91c69c9bc5f8d24592281aa2d2f43bc509411ce780cd714e078d0acfa7a868b6b360efd6b7967624177dff99401e425fdc3a07740edd1d1722ba86d63b1a37a5d22f82709ce686cb2e78d7d302fce01e42e78439a24a39732a062756f32d199354207a9e4c548ea877b0616c4cae9ab75cc8c298fc981ae478e1425c182d44b8381006ace1edae1ade8b1bfb3803719343144de73d8c1181f310ece9b176fe8447791e683a4c74254a1414b02c8f61cb5763ce75fbba8a461adfc18dc2223cb323659806f6e2c21c841a3205440156c4f13f645be3cf5f26334f11eede00a88fc284013a8be48684012044f69e8841322d912abf97e024704694cd769acd5f501bde998b26a604d5b0272e8ce4487c6bce704f6b21f8d78c868a27277c584589fe2194e8b513e088f31835ba487ca3bba7c51e6e7a2b07599028c410edbad8e4e36dcd9be3faccc77214f3fcc2b23c2d041aff3637d40e68c02d4846acba8b8f102684d039c5c19c0552a93604fd4c2f26ea2c347915fee3a22a172b0d3b6db5ca6603f0cf0b9408a3262e3047bc18f53788cbd218d10acca49159be08faf1ccada8dacf739bead086125492d56a5f9190a230b0db3e8b35a1add487fa14cec2a62801b4b35914e23ad47ca10baabff3e7bf891031616fae7c739a1745d79124c83bfdc5ca71edcd2e6af00a0ef759e5cb6ad83e628a6181366917738637a6a0cdcf0af283756d5b6e91a9e4bae6e197025c839493f5d3853ad3418d93a70487e5569e0424d557080522aee49d5fdea77bff31a223f405afb2e9518686d7ae4a49ea0be45d917c4bbf280606c6b192abf1d476c9601eb83abc9308fcecc660f2414f4766ff0c534bdfbd8c3f45232c302687e4bca3e0975f7f28287642cb0283d735c36ce8ecf404ea74f11a2293758dceed3543c383e8c9c364626e505eedc8f84b813e7d5a0022354506e67cfc10da1323eaeb68facd31f4589057458bcdea42f6b9229311af84f1b5735b9f92be55f11976b4ff01d6eb34fdc913ed3d9a94143c815b63fd30ad8541b195da4fe159f6caa80e5586dd3781f9529181813889ba48df584c78f0a5b23b73a7965d2a5906a47bef79925274cce9c0a4752908b220370674c4dc4384a46edbd8241659de2573e56407a5817a952d72d155646d7a0c326d00474700288535075a3c4475e079d5637fee1c9148bd4828beee6c880b083060dbe096b6e75afb2b12c605f3abe6457b9ac0b21517f272742dfe46195c92ac5ed30213d6de845495e21739c49e6776c7e570c0118583d187733e04297b983266243e3e895f135f7022bd8f64fb3c3a0c4bab28ff6fe0ae3df451d9131f963d9b736571f647d99dd0d93871ebf956de67665687d2d048e241afb1ad64a98380ebdc381a4c6d254d5d924b9c497d949eb38d74d0a1aa0824fb3134f4d0dc53f80795faa5f78265871c9b8df24513d976901a0a8efad682e8c8fb70ebd2600e7398048b16904bcd295181ac1892732b3d3753beadacab063d6a01c081ded29e2b223eae83fe8b47bc7cc5df0177908eedf5c7f2813bc663a893fd40095abb20e2d1710932157a00d3c4a777a2af0719f8a3e16cd356e3bb8e58dc9257834a0715aabf44aae567d643b918c503c8ea3ea365215f6dc62638a646a4c26e0cb4f8601f2be4107f70bbd54b7db9a0d6c6ae0c496d746d23b9c1bbc606e7962a75ccaed8343de0690697e60278cb9901e4bff619406e6c0dc643e5d66382f7661c3d89db1fd55fc5ddbcef9908c5dd45828d359d8c45380556b0b7c3436f63a01db53d78dbb7fd3a707865c46a421ce22afcd7925a75c1d5499f1987dbceabc55634721f87024429da20855d34aa4bc092233ba3cea95684176d380c53c8ad41ff42f4a6559484fa4cb907efaaa6c9bdfaa91081ffff1f18123d22ce7d77e35a6f470299eaf802e2c3cb778e5965261149fae9b8529a703b53233299ef6b6136ea19c3c5eb848fd3073bef3bca8c8d23fa02c1027db8fb16162ed8d4894bd53fa461e81c7e842cd1f676bf29f140be2fdab58676997f43e40f20f4fb4cded1fc1bf45b729eaa1c5a2fbd2a357a55044301fdfa534d962776d630c4421698956bc462da4baf6662059251374fcb924af463199890257fd4f8dafac4578aac51a8c60bd4980ec9bd0e060278be47665ba0cd6ecdc503b4339a74f8ea5d7aa32f8fa4edaa676563418e1c0fdbeddea39c5b4d78206d765359f4cab8079f379bc357e4ac09410570ef4f07bb0fcdf3f1c85fcdaf2fd39afa73b94a218d8bd7b69c0692a20bdad8a80188532f635ed82f1a8d33d2c351c6189daca7c371fae739b0eecd1b82e9fd4a46180e822c8e27b1f2f8bc3bc4280196143a33fe433d515ee26241c06a4ee2b4789e6e855498c9b2aaf1f0c29571e6d1bef123c2a21f6847d621f9f0fa3cf52d4b3eb6776b11c6bec0ba0ce0804146b5d3cbaf88c59d5f80ca90ba16f8a18f5dbe03526a1fbd635816df36a7028bd25ef3fa16fb2126c8090cfb4f4b4874488fba6c54098ac2ba22451b2af3fe546ab3c25e4bf23383ab3dbd37b7e9d0162ec3a8c23ae5c15df6325aebb3bdb5cf8d3e55f531c7fe33d2e1aa0658d1e49f26d2b168b1415d39b2ea0a35266be4bde45de4b915170b839125aea2bd3e8bc5ae4abace708fb923a2baa5a06b137325c577692e01cf1719096c5614dcf22de72d2befc13de62f5d63f4e3488b55487d613b5f84f1526243b9f90c58ff3ab39498794adf5308291189b46164fd4fa5e60407e2a71327dbeac4a607190c01990d543c5929e89add39f750a36748fc64a6a9c10d9a2d6783019f3877d73a6049e23b46665b1c33d1092e54b6925dc36c5d7a39815c97d743b77c4b7b71946c99869ced9d690348209b453701c1f2f15be955c2fe9f3151055c3d4a37c120cd62e5806658a72ad5d993353a2b5974194c144ee7056237a5b07659c80a9b86e905d197076b05de1dbff172c83bc031329f562f9891ab088d8bac7001473b1af830afa3bc14bc9f791193fd14b1134637d25746fb652f704a1e44d1ebcbb5fd4f8c184d24bd39b5cf2524d4fa5b58089ad9419b4be7f94fb3cab07bc77f9ec9d234015ddc2e0d7c44f9e8e2374647206dea06b49556560fabcf381d9cc6f4c08718c6cfdbc865d1f5705275653053a5495f9b26e82ceb3f32dc5c75e83416bfb2b923bbd3244a997b2607f64c6f026ef71bb5e33c8fd6ff39193bf0d0c7b9aeb35e82bfdeb54807da72903c8757fceae462dd30f773377b357e5c86af7621c62a5eb313b9c8365ba116182cbbe6593cef4664519bebecf6636fb51029ef4fef01db28331d6666416367ddbf82ca2829361226bddfb2e14cdc17a3e37e5f0dc939d48ecee2a50c9e52fa415daac5de17d891e0aff2a54805c8f0f656abd9b5eba0d24c384e5a4b81d4c2fde06f37ba10f4f801dfc25890b655f41f4192f75e2f9341617acc2e1fac888d8c04d66b81de401e2d6366ba5fa72822fe744265800eed69d18cb86acf5d3373be35b3fb6b3bf53926fca8bc1d489cebf3e8ad142458051c663b945e7355b9437ad145dfed524f7937762a26fb28c4646a65e837e1b49639d7277ba7b0371161df49e0175864c45bab148580ebdaf4e6f5d0f4ecd50c366d5f6af0a785b6f21ac3236116e4bf6663d48874597fc8564e79b77857b895d5e8ad79bcb2698738ebed4fbcbb50e89781d23d5ee550856409c662fb240835813f7118e67718241fd922906cccbeb9810f6c3ac4c6ceec01e5fb6cd63f02c75e79f20003ad26eab1005b11364f24fcd220a079b8dfd97ba8e2c2a06920d98ac4fda2d4ca4b0efa58f8359d6e8268f988aa1d3340fa081eefd5425f6a3439a33b4c897d626c625ed8dd39bbdf0a8eaf922241ae325661de697de5e33198c7390ceb1f28b1e90453699ffde4fb8816f6805704b066ff322f6d1a90719a3c69de47fb58a0e07d66564213e32ab96a2321ef8c8280353e78cae420aac594aad1daaf9e4ee7d66b5d2c97f5ddac7e5f1491aa3271043cd91c333e2975fcc5b26bb0eb630a7adc195f6569b66818e0324283fa197b42240632b9e9e55f4625e545952661c23d56f4a1871dc78d1466a9de1755421eeeb03890b8dcc147ce2ab1aba08d730abf74088b5b3020229427a27dff039ce0f067ae825c52de53a53ececb420615f37db1881d3b79873fd9e6aad93ecb5d0b61294cd8eaeb78ec8713efac69d7d37450630d91c89580512c9b1b3f538908197a4deac26f7ed320a6b478ed0e6ca2ab80db5c115b6f0f2c73fdfd66c1a974f0d10efdf2512740c8b1bf5a4735cbafd371e04a6f2a98b77633bea0f37fd722427efcfa50c50da84dc4920fe6c7a0e59d2d6d28dd32444af258299d7fb3ada86034c800bb7bdb4d6c3c657aaa18b4c77cacba68954497a470fff0825a54c2e49071927a54e2a3f6e4b848da366640d0be3bfb662795f9a017571be3d8cc2d279c6e3d23a3359216cf8609301d784cf094121467f02baaf1c1d435b62d0e7df4a8f6c5317154a8cc6c6e37dd272961b73b18607f997252962b0837122b99f42209bab1ec4272ea6692cabe07e964aab8f58080591b8c0857c5581091e09ed49afec7b8ebf6b73d79f7fc4b0ace8ac5b93c0d4360e17506a3b7c558491aeb34bf8bdfa7b15ad81ca76fdc153a85838a5650006d97f8082960f7beeb5c740e135edfb3d8e61766bc6ee3e2c5f95ebcf1da4a7c89e8e1952b942c32bcb68c122e9af07d88f3aed0ae9a2d7c54969e9c9b64fd521918cf443a9feb2896ef16bdb17cbabbdd2ead85577048b121432dfb342d3beb87f0d31a484f4a8737f05e488f07058fa28c8714a03d3a73376565457c81ee0502bd61ab1c235a14e17d05370c6fe04311d6943f189b600954883b79d0d41f69c5f0eb2a170b6efd23a6b3dd7f5733d9c407fe1518095ca1ce33f437b55f6a248bd870459e2d6fbeb971839c258cbe3edf00e16d31b5036eab9804d1e4da1869704cd12e444254b62ffe6dff78184c586951296f2833d7d0b6df826dad5f3f754eb0fb8e2869fe2e98a55bb19bd8a6dc0dace6ce1f2f9bdae04084385a3ecc24a763b7e0df1cb03d9a9939ec44a5ec8e3974e6918f0eeb024599765cd924a2fead8b33ec77e92ed69aa958326a5d5afdbfaeb453e831e985f57f733189a551c9217d430698d8ec7c4d8b379f5a7591bc52e449d5ee0cb33eda9126a768dbd4bfb7f94529bd731279db805637e3a20ab68ad6b34588f27bbf62ea68ddd5e41c42f5e79912bd091f1fc59bd0eb15fd3deebbe1ad0cfb1ccc2b2e5a687e1edb5b916ae4ca0d52915fc65a16c4c9ff47683cb947acc447a4397a1ee70b8e68f81af18cf4256c9152fc084b77be81122fc5c9e288f529e36a75279205d551baf5ff34371f99fa9bead2116bc31d5fd4ba3129892fd2e3a7d19b589e861630b55d9e63a8056f6a4f457210a82b863f7a36e3a774f602bec30d22e713c38a8f516a79ea77214caa6bf43e9d69514c25c80da95ff49c254ab45958eebc76c7c9f73d7e170f417cbc948cce093dce70943e859f623c2dab1ae392c22d9aa2ba0b0ace218785d47b74dac9f4967ee6f6a577d963050f41d72ca895d2d9256b4bca30a0550eb729696458a19e1162b800a7d7312dcbe1a7eddc71fe02eb0dade57427df278bd8cdc9dc3ef4b9981f4953f01ee49229c9dd877d1c3f90e511c4b48a87123b2ff914507ef25d3ae576103aa4e11da3a635c83becb5bb13ea6cf55c7bdd65b3318fd37bf41a5e854084bcef03bb696dcf58636be8ca1b4b31e896f666c3c9fc9528d4d024b087fada08636ab4d426844bc361531a9e56aabe524129b6fb3defdcc49979c40aaa437e91f95f6f90226287aa3c6ddb61d35f5ffa30328941906719bdbec7990a02dabbdbb3491fc069abc4b24319ee2e344a22c89444d1ba24af1311dfe2911dc30f09524c14dcfaf42342df87efcb749eb6fa14a5932091027389e05d9a814fe4c00428ae451e1fa8384a0f1cdf8118ed6e370f9539110ad79b521597946aa0fe23bf78f7ee778e9baef8abaefe4fbeab66e50e766ec86f98b9b4c0a8f307ed4ad6772dc7befebd947857c01aa5b69b3655fa76911d91ce7a0bb4b50e9f34593a1984caee285200b73d525b4354834daf171bbfc60c942e56bf787ccc4fb9fe5086600ba6f17cab295ca91065a0ca352b26ee8f77b3339cf38bf49d98f5a8c7a752c818f795c346213a45830fae8948c1089f1c7816d0e23eccfe4fc0ededfb2a26b294bed508109b95ebad43a3b0e95375863d7606fc5374c439daff683798223d62243b36ae302ac196128ed25577a90ff4cb5386681bd1285292d7b2c019568f4f4c7445893c16b2d659ce43a61e08e62130cef8b5a71ceccccc9ef7c0bfae38343f21ca3e51cfdd89c1fa5f03803669df81a2adeba0a16e486aabec2f829200b980f4ca16060e45ff38934f21884791f4123debf95a65eec5cdf1f2302ab2fefa9d3fac28f99181ecdd530af5601a3731f2f54a3300eb84be1ebd6dfbfe3acdebbfd36c84b1a4fa1705df1fa2c4843eea7c1016e217123733fcb32a14a4e607a93ffe80d5c99c290e8a992559870395dcb8bdfd3ee5aace8f845820bf1a44cba6c7c3aa12d61e1c5122327c1ca5e0664299b152644aa4fa546880d42f6d561adc878bd67b21a31fc290ba6c810dc442a44c5b2743b019eb66b94c7dc0e1b5fd57b23ed564c8bfe765daf37e89d9d7ff89ebff91f3f63e00f791036a60d41022a56785c22a8b8041067c13e953f70727fe3e6e3d4c542aea4491bc1e3bfee0d7dbb684e9e01381d514ba31267f827463f60347d61aaff0c90ee34b980177116a7e672e6b4b0d3420276aebb3349815f98d88de855de3b5c7ec10413ea077db9e5e35a4eafcbf32b1d0f8bdabd15aa79da23ea7a444784bfbc0d4d27d24a2f871695527751d0fb543db406fe68c82432e0460c1cf2fb187438c41a62111d2aeba64d1712e4115f66d3fe6b9434efd7708e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
