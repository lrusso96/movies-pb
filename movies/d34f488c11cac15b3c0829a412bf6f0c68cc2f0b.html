<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4daf87ca2ddfa9294ecaa71e0a96d47fe8a237ff0c7359a89bfa8443779c6ceec5b6591a75ddb55296bacc658addd1bcaec9b84216345d6ac913a053e2f27288e5471b948098bd0f72ae773bac6f58371c42f56ed428d7b869f1e37987d135eb9e9f11e867aa49eaa13d0e3e89dad41aeca355ead461a037863f0bb081ecd9806892690c8557a3568f140ccf712379ec31d6b59d579b6ae40e27c1545e14be6c28fb2f54f3a1e3831a6b1fdb8ceecbd0983939ea13967499d6354eb5c5a096760775da43d7b9d47e2b07f58405f74de07bd3b90a041ede59adb86214e32e3948e56b3116e06e0bdefd2e9c6a541d236b9d876bb02cf027f0159fecbf40dbad54e371c75bbe592725e8ba4aa444cdf5e02d333bc5f2b409508427d9f6752f23501941486edd81afd05a83afdfb899d6d01faaba68f1684cb9bbd626608f4a7088a8676296bb4e96c6bcf0c30203a844c2e39aee6baf3951e754fb4b2cd0e82d7b79ff9440afec8a1ae1fab70b302823f9d73fa164a5a827ba53d8ab83d807a543e69d923b56ecf042beb436fcabfee03f3bd7a3c7349e4887fbb84a2a075f401419d63a7737f6559046b42c735a3461e597ec2758fba6e51990a2095d24da43bdfe3aa07279abeb91e7fad85aecceac44c0d514b51c5bc1e89ec1a260f18bacd8b8b46865900d862ae3b9f159229ad4611a4d0aae3c2ce3ddd692ae4104fe5de9e5aca9d288a751f52dc950033e1b2efb8fb557beb2485c327792aad494dd40063ca8256b3c5518741de1fa698d6b6cb6e5976be9a2f2ce3c5440ef1ea51921436f1df7850e35a92450d51db1b0cddf74fd5ff374b991ef0369a6e5ca3b51ad6c07da416a88d13bcc2bf7c83cb8a5242aa2d17555c11948e1aa2662a766d9e722f99aa1a66ce1035c68fb481f1233bd9c3471cd928ee339ba81d28c6f8b599bab1885908c72bb0dd338360e14a3064132a63c88db2528c3d2c36ec95921ccbf6de9ddb45442cf1049463d221d96a2e392e79f2ed2727bf67a808d36a0df94afd2b47ec08aec9840658273facf8b496bdeba2a9a340897d3a796c68c3e9e5733ce953edbeac60da8c4568ca9f4b546d6c4deec666e71d3a41fb292941448299d2d4a9e141c104bdecc49089400a4392b4d84036ebb04ba2bd11012f7417070793973a87fc917c8b62760775e3d74dc70348d8a40e5d8f96d181535f5dacd9e8f243cd47165b042f7ef337c28049f7d4ebb7e82317bc55f9e05a32ef97a7d66a4bed03e908702f44cc4328463dc301f1cb788130b3c4b5512c810bc18fd7a065ce77704e2f4726a7019ed4cd85952e5dc6d6c2ab138c84be6cb9b98e88be1f180cd9e723d8c540691c046d337106b71a80cf07376f921ed03193fc91068fa7dd0647d05870a446f3758440c4cc24e88e71992809e2fc56ee149bc6396289f749265739b59650678142895a2a0485c4ab8e56081568bae9f441364948069f27df3cbb4a09b54643ba6d04f2d5cf8356094468098262824eb048147984fbd6a0c8aef7b8b3e70ef5c613229166b3aafb8409bf543d09f8224fc89e17dbfc51e1c4fe85c0d540e1f474e08b3366ca2e5aec170af0cdf9b1f2035ced10ab8690e4e2f2f423efd16104dc4a3b3be4c46615409356cd5d29898f3b5f5496ea6b094dee9ab1f9f1feb90ffdb693a2d61c6288b37ae639daf37045a978239bf33bc803c3ddef9a5d3d70f6d4fa99388dba228bd0dc009b5d79b3ead050245b250ab177c01fed69fe31bd8380f266575d350439dca3e6076eead2b680bf46361e89e841186a7ba1009bdeff0868cdaffabc76fdf2dafcd03398ff4c2a97e16f6bf53a26692741a605a20dabcaa40c0d7b1585018f83d663dc8e0c281dcb521e553e7172bb7a55b2125747d8c17bb93b14351e7ee81825ed58e6c60de8de6edfd165bb4312aa2bd34f85f0fabf58fd7f46ec5c2aaee481830c75574cbd0e9c8f76a787d378eb7c47492bfc714a4628de4046501b671d03e95875cc7a5484ae2c7f899e9eb4c823f782967a0d91b76dae68ff497a0af2b494e5479f501776feb711af00d7472e9f7f7338caaf9d6109242338b932876da6517d82ae54e24edcb28cc71879a32646a4977fed8efb5f23ee7c9c2724bc17db77e004230c62d5bb89f546e9042a8a1f7693e27b598ec628430ae1363f352e883b453a4d2d3bc1d4011b450c4f6fdd8117e5900653035502950370171fc42a5031b164cc5883587ba173f32c07e75485c82eddda2c17d781585e77449ecd2d96cdb9ba8ad53187997f91985265ee354e2902032d9b70d4b7dbfd228e16933f3083d9d4069ca7e1484be074dd103a05d44a2842466c5249e66c406cfd91e1a5b3a1777f912304b15ccf60b1168da1c8aabe06db75648c34ee191996629489cb9b7a7b3d2f6e8062233209abe93a0059f4bc2d3d916adeb3aea2acbeea5a7f9c36782fb638543a666f56fc355c89c02f715a0ea419cce648c9932681e2777d20c75d6efb8768d8daf87fa8cfeaedc868f1d43d9b245e908b0be0f7bad72e68f4113f629ec6f05934309ea1e281edfde23f46414c34e2e8b58b99672e0644fb6ee981b0e728696985683deb8aa9933e744856095029b16245899a2012323d44d649306c61292e4b3082e8955c554e3f8eff8feab6119fa50227fbfdc1919cd8453e2005bed0b444bdf9830e37e40c1886402bc83de852a19c306f78b656c8b6375a58e0132a2d4edb5f62dd230ee3242af47137935d823b9a18477b68316498bc9499706a0bf090cfedebaa2b5c2e20457452835253650ca2346c1d1ba3442f627164f853b673e72d3319a1bfaa3177042fbad5331e8b938937a1e0aac1545780a2a76e9c5ca58e591eac79fc3c85d7411ee0825b5bb0252b69e339c51cb215a759dd1f4dee2a86178ddc5c494df5e81ddb2e83d6866da79524bfae0d504740dba5ae8b2326eea09ca20fa71fb45e1b61d9ca1c46ec3cebb9a87b7393a918ad98404e983789d24a5cb576a45e8261b308e21a9ced70c791ec65106ceb718e832b56a1cf8a711e78ae1a5366c97c2b9feef1b1f380376365bfe81960b2711b9ca051ad4242c23676d0d4db685fa551c5f78f8c34c2a324cac352db8f326ca14c44d43f66ebeda328c3660b4f6d40e7f6cfe843d246a0eb6286576fdb0b5c7a24a1229ec2776d4f1d3d28937df4c56b5fe66e321939de7fff41085621b20730290270d41c07ecd66a9a050db72b18dcfd24f0a302dbd4f711c7cde72299e205248412c162bbd155772d0ea9857a444be9a589489e5cf83c4950faa39173326236e7d3abec19e08258b881e62b0fb37fd49348901e612dd5863f6764f39e56831a01b7ad7c78055cfcdfebb7ee5155294fb3f0d79916db0ff3dbc3b12a77beb7cc0f9202dfe0185e3f702962028db2ae6af3509fa5fc177989d5720aa14748fd2379c958ee3228b863191a1f17441200b3cf36073534b0b27e9dab7f590060a6f9a87a60926f799c319483dd961cab4acb5937baa5b25ea506e98f8d499f681186fd449fd1be42ba4a4a244c5054935fa8ae1bc3fee2306008de000c8913c87ee6cd3c618da20231dcb156996f37a796b73a0321a5cc38d39560bb8ac867a1aef116afbfc5b5cb0a11b377edddee96ec44b812a830313864b9aa293972243edea86bc1a3c1df1197f2cfb6ecf179b05fe0cfcd2707b698e992c72d7161a7c9e0eca5c149d552022f3d1a431e2e699f1da2ed6b8874cc4ab326d3fc748c33045cbc96f303ccf6618ffee2f55903815ed096efc0107fc3401bd4ee7709962108f8c94f0e32955caa00eef27a3995e6104e6bf8679d301ab1846aae755654a4c46f35bce9e8768642f4fe9cc5f4010d0158f45beb9035ed022d5b8149ea6f80abd87047b1a2b5ead0c8ba86622f8246930c4016609f8dc85cf52128cfc12b749b741275e15daf0b4aff61bfed4643ed4374e2efaea9860cec18fb9d255855a0958b23074fe15bdc32123b788d03db669e1b3dfdd6e958e79ca0f423d7eaa39f429e26c9bc45f83ff977176901dcb213ad12d7f3332612e680225bce94b6ba06dcbaa8f950addeaefc574214bc8f56e2cf7350637cba2af5d7a42bfd2bd13316c55a1d979d696ca411d3ab3d8ba3409c240f7a7c0671b8a754d68b1a85f87a763f8c4f9178fb85e9ed78228a0d957803573be508f95ee5cf100151b41d82e568dd5fae30627d0b375155e6430c94770df76c0b720904cf2a786c3e95a32a690766a8e74dcff96395953f5577c6d5dcdbfb69dfaca725f7415e22cf6abf56f54a83571d0287e63dc1308516480c4b618d7bf09e8b042133671dd94677363f90f326358d396eb0b74674d59b62a52110bf05df674a5aabf18f2cb5d194f0fe89943dd5ad3857d73889b1854a98a945c412a4de040fd659f78abc4ba170747f2d95d151bad97aabd80b011f094475924a183d5eaf85a5ec1b0a73dff4c21c9dccd443da57181b84723050b4545b121abf3322d07becfbd64d086025b04a8c491dc9502fa26baa53ec84db08da8e1d5bd968f96539ea44ef2a3214433e68a6bd8c1db868df81d0b66bcc6c4fcc85c0d6f45c91ed22a08d55243283ebd913b733b8dc776a5f5f2c12f958e852716a1769ea3dfbe7a5871d54cc14f1f9d7adc3fcd58e02789c30cfce4ef557534e7665f7716e6e2781f42d66ef879e0de4b04dec5a575b7be8ac2025d81826643ce517caf73102aff0cd8b128aab3c15ded967eca721c15b89db67b747c92995e530f48e2b766f17c447522b223eb20cdbd58c7c028e44a3e5028451fbb5c683b977dbecc81f16b1af5bb7ecbbb522964989cfb32bfda27dd8f97571ee34d05648ad61fb390a0607f99f83945a2fb19c7dfd2f7ea6fc182cce864fbc09953f5f5a495b8c48df198e03e4450bfbe938f8e6b7bab5c664e4797fba9f07644e0cf94f8ce6bf848d326994857bb7ad599aeb741cf3ce3808a8c1803e2c468ea09b24db089ff950923638cdbb344ebf753b72468c7f7e4b24da5acd53d9df2219b50f877cef2f75042f84ac64dc70bc6551d1b0b36019c64c184a9b07e5a25a875ce3ac79aeb3b9009b35fa94fbc66b736ba3debc65bf4f198a45645e28981d15297a509a5e6412c4a31f5b6650018fc218d89276950cd6e9d2836dff162fd920d1d0f1f27d56d7bfcfd17e8d06941d062e105ecc89659ed49cb7b56bc4c789ac73a40f859843a7a651e0f7a77778ac8d4f2be89efb6a06ce8c6e1868af6d67b483666951c294580580cc0218969c1f44dfe8565168be00b95697448ab118e235519390dee36e7ef40b155892bc7be13a19baba8a8447afe64c4ed518a41430bb950aab12e334cc3421434f5edff419c53d255520987da3886cdb2d3184c946fea0b32d565acfc52d49bb24a35d6730c52e3350633039713466cd4012f3fcd7949b0d39888aeccdf5cb404cce5766e697965e0bf3be23dab28fe0f6ebccc69575f1edfb5772b23d36966c040ad3f9a535c4cb2a621617a3edebd5626b43290845995695a2990ed7cc5a8ef90d5f6680c1c13cca49891d772c048006d243a9b69892e65546e372578d17b2338f4d848e3df4e314cc5dc8d973248af5d68f011c3eae8f443593f5403dfdd02cf8bcebb4e757caf4ae521e85f47623c043f66729d58f9cf639b357d48731ab67fe2ce8ada52f91c53e60b4829d8c0e351b45d0c622fdfe45b858c511c31b6095f844dcb42f527eb719c03d1da3bfb7ed551a8cabdb697b7e622cb7c2ff44a51edcf121f9724d6bbf1485e206108a83e19e1c7ff242c7b0cde86f02814f71d68ba387544364e4a8bd4b62c2c04abd98e033b1d39f8deff6126099aa16d1a3fc3749ab08fda747ccdc93dae842a6eade9b628891268fb0d5bb70bb2743e471c6d1f665f9c03b1d61b3b070bc452f7134a90e8fe3db39cf7eb646ef84c418ebdad5f8fb0ca4550ab0b2b06d0e24c5550c96ed72aab45f1fdc47bf5bab3003a69f73bec4d7bc4ffb2a1d4b57b962c8146a871b9d4038e4de2db6e1b3d163bc7a8af3c5ffdfc4b97abfab8502adab3dd3c5f8b2b1b50c0391a253d81c2236b5e4d01bed610c6c824fa3d684212f6895f519d20e6d66d34be3b0142f7ada362263f0d4c4aebc7aab39dfd9bc8e3e072e6d8665df03f22a02b99c54933bad096f5df9702e01c8665547c2083a4b809703cff6ac67b3bacd10dbd52aaf41eb11775536eec61ff8637b5e2c1b0470b637d7ec3ec01ddd50a55483863c77b6f293570494535e4d5c2fbbd4d0f77d42ea42cb4975cfa4c472f00b769177d42c1d1ce1dcc4b4799d926ea521db5de53b7823bfb2eafc4aaaca5745e4b7936134ec391547ed3fcb08cdac0bda9f09fb62c9948da82e2ac11456969a298341eeb5bcf5b414fb7de3957ade98418d5f744e5806be392080fdc54cbcdc9d93706a5edfd85ef31e68bbec0a548783146a982780ebc9ab8b1f81caf25c3d8cbcfd5d3e9bbbc05166f3d2e47fd8b85f474314fe109d0cefb849e63fa5f960b0dd50b3192d4d7a9a5d344d352ad8e1057386f3a1428931d885f3df062dbc83f3363bf5bdbd82968fbb8acd2d3c02f8e3e5e986f5a68b24a75735986d163c076aaa2bc32660ddbe35501976af948d5a43b95bd66edc7e9e2bbfca389b93e6405c1b00b94f16f91ad9325c65e4c9e8a46ae9998a29dc2a0ecbcb1af71ace682f96978fd72d4fcffb376b97debb7c8434a23709157dcd16a366fdb8b43e37e4fa41b0189281dadfb6f001b03bf95e36062b6efd8d5d3dbd38c04c3a9569e4280d428a8fb22cde9cc4ecefba1a2f32fcd90910e06e10d504d91bc7a82b66699e2231ed9839bfcbdc5a93d1762883f34e59017f89d63591b09f8efe09414d4a6a236132c3821d6cb6c6610ff6d419777591d93449c4367608ed4313c55e277c8662837e4027d35422b28c7dd18c58863380e80a536dc76845451456c1d60524bc48ac2bef24a59779538851976e1e59b0f7e90d75692779ca42f17b437f84ed97fa988226ea952f070d6c92d16514222a073231a0c8e71721a0e99e890dd5f75576aa376aed8c6ca33a457d435d5e4d45adf5c984f3014c748866b9ecc87cab424c9f65e75aebc0362ac35cff08c401d49a0b53b25b3e0d63039ee008435baf39c5b30c9ff64bd6807ba64780bc113aaf16d9746f33f430368cfb430354efd966d0c43fbb3735e5fe9959cdf7c774fdffa86873fa43cdf044a479e4ec5d8c65d44d79c89374ff20de0be75e29cf3bbee90ba8809bf7117e3d31c547bb843512bb68b7c701ce75917bde0d2536feeb80f135788f2255d114c521bad5be102a495fb37312ab1a73bc19c36cb4a46f33b31f453c2f500c428e80030b013bb08cc02066ce52c35b757e0489d24dd95614ee7b230114bbf0783270ac9cfc8e623b83757fe26fcde7fb72a930b88a068901bf0856f5b9b12324a339212445f1d08e28ddb95948b65fefb1909d02014e06fcf14c339f19dcf9a5175bf2bed49113ee65d2697f43a0c27a1c1c7ccab4f4358a0e1a1b7cf94ebbfad0c13192cf85bf53410c150742e8677f7f1baf27d3b92fe46276ba244312096a633faadaa46febc9870380a7aa29c9b010691c98165fc0271b7c1df5821c6536886b61b8194c3912a55dd0777dab6a94559ae8580d583ec4731ffd5245f197cdeacb276c8d4be1cc828d31640f78c84fca5237ea5b8ac45e14048131936fddbe78cc187019bc5e1c41990c27d4d71e79d55290f14ae493a5892c1747c49a674b00b93f957e3a2b397112a8be6321ddec77fc8bda05b1fff756bbfb979ebc3390631b7172cc29a85bfbf16f26003b41b7cee4048d5e2d91e37af219cc7f4cf8c3c797b8f3f670c481a4d4985461b038e4d7c5d718cd126fac3061cf0de6e19842689789b9838a2509ec46719d714faa216e53c15013a5708c0815945f5c4cf114a3e5a54219e076b14b72d3253c3db4d6d6a1322204efaf676b14dffe5682790451ef8bb71f375f92f29de63f96477fc2dec43c3ed534c3da4101262eb6cba4d6dcd9cf9626a23ea68f1fed9b7853a9c8bdf7a1130dcf0feaad7bada048c6fd04cd72ac5e2ae2c394352513b2f405ebab531df9e62332eb7f39f578819bfa12c5f14c886a9f4569e12b9066326cb8e9fca9baf520299bc7d7e626569a0fc74a932b67d22c1c2f6834fbd5258eabddf0262da59d1628a91d151fc925a0e20185cc9b05ac05f965aab367859c61c4612fbcc46d992815c78940823c48d6e85424fa8ec3d01bb8db0694d65637d89d91b8cfc07281328fcfcd98f078c17140e85528f65576672de7a2b1064ef73989bac12fdcf8f3dee3a4d4477a9d14d2c782d192c2a965f6f01f84da847e0626a529160b9d33bf3fea0d95d303cfed7435fa7098f0de7b12dad83aa8b0a55f4ac14b97511e362c20adb9e6ce94adc7992d6534e2ee9392d6ede72c499bcf09f02c4524f7b1cd2244491aeaad1211a2b6e1a7e8f9ca84daeca289ba1230bfcd05d809eaaa53e196e6ac8d0559676618b3e62d8b524866558b22b448c35783e2343a7d26c8eb8dfe0dd86dd273b6e691847f4086399f6f7d700141a57d3e3c016fe7586fc6430deee149b6c1279a446b7447fc8a2d90ad06c21b12593bc160be1e2a9f77086eb6e260d8a78a49354fdc85ef27c1d060eac80afe294e6ab60bf34704e3611c2595d07b9022b87e7221aa8d955cd8f439f258cb857cf05c9aef0382168fea16904ec6c186b07fbe6671bd0b8db9ce28bd17393753801f2f88324d18827c6cd9691d334a38d427786c19655dbdcd98fc992ccd9577b1bdb4e91cc245f3f6fdca75be6374d6a30b7ea2ff4a65e1daf33221834ae9500cee42e30df8e9f8032b945df189ca9982cf0ba42d151beeefb727e126cd99d5bb40edcf4c1ccc1b101e47d833160b8a5b30557de4e81a6b5ac9ed33d9adac1ab359b4ee46bfc987765162277884f414b20df192ce6514be77a21a25d53a38848b9ebb4a822e48c20a1cc0a2839afdf1f4b58d7b0a2c98b6efaea1ca6637543c68dba72136b1df1e9e748440820bba21e3335a67f44c4bcd10a5287b1addb967906a78fb1176453c683e14fc067bacedb1846d6e757b688487807a7c941ed8e18ad0386aa957a85aacad56804b0cccba60cccafcda32e6745f8509448206f29b53fd8e994f0e29f4f05b2d5e81ddc0424007d81d1a2f899698c3dbbbea677f0c2844ed9de0480438662a1000f36e7aec9500d960c8687eec64dd3094ae4b04c491d835888a7960c191cdecfd0666c8fbecbe8c1f78e844b7f1424c87b67ea3dd6b6cac8db508f8f3b90055835e1f7b7c03c26d6bd2e6833ff55ab179c9aacfc201e42a2da5555e0e88a8d50043821be2873bc85af16ae87def865b455e625be54df4f9b334c5764b5c7636c6e4f7625264e150474d56d408e81c8ea8356ecfac8abef0a805599bf041c8f312b8dd1ce3fd5dad54a34b854ac24137ae004899d6d75dfd1967745b01e75028e9eef4545de9f9bc4703f7416a49bbfc9ba65e5fc89d110dde599f7d30c55c26a4a9022277b572771e8964f47b71bda28412e136747623cad05bdcfcea11fa974ed6a343f189369233befc4d37ed42c38c9584ab895cd4a2eaf1cbda843ee163ca693ec9c5f835e3876989312ed05692b308fa5f4261616fa169c2a5fafba5dc4de751fb4c9033d8ba9db391a1bb0a3f6c4258393695c3b3237a2f2afc2e6d0304a590595504547980a5aec544ffeb759d6985e442180785f3dc165c00e5b53057370ab90fc39bf0a2287c5271f3a234b855acafe7c492565033e6cfa4f4817049ca88f9006b358707f2e4ef1eb6b7a24d0026d23dcbbf814ba3855902070b55b062f0c107b5d24cce109a9d9332d49e5a5f9405937265e1e4af2cc4d45cd40c3a18494bc3d928ceca6633d0e9adfe03296586b52c669e2c0866127365bc4fa07f6e55cb3b50953148e021fdd898e834eb661d9928f7582bd8138c205b74376738eec8668376313a45814004d62b1eacefea18713abcf38cb2e8c210f45cd47467cfa49be11126fcfdc782380291e2aeb64e88c9e5a7174a285921907bdd263fd2f11307fdadef9bf85647e211fb8020f40628e2c2000e91c56d553c21918f3618975bfb975ffa55b25088d5da6400a58263862ae5a8156ee2ea798557aeebee4899b879cc0e93606887f0815b1e89bc2315565912c22612dcf988aa47dd87b3fb75797de41041d7c69d1f45a062678ec321128036a3513921261241b3ff64685ef9eb5303bb914ede5cc3c4212e45eacbd548073f6b4c2bd44fed10d9fd28620bd706891b09b08cd81100cba88e89587fa2f29e9341a2ea3d91d03fa727107a7eb99ea26749c1b5e774a9df69a5df96d60c05705e172397fd54dc0cad5f3a337ef5ca1f9d343f65b3d27ce5c72139a01ae8bfc092de448af3c145282c62ba8fcee9cb8dfb5fb1b2e07d525251fca6a2d26f99cd9226e2ca96390c09986904e500343d7b294ce3d66d6d03e6d8f110245055e17e74feb1043bba195b0dbe44540cc5e9503ba564cf5282cb703fcc34b93fb271d44a939158c1a056ac86ada479cff698487f5c9908015c52a0a3acba2630bc16888ab88105e60438f611847b811e3b50f61ac6cc27c8f6ce5a9a0f2d17e9ac3c58be3c421ff0d6e4a20d735c1565b21e513e84fb9eb22385974a7912a2ee0f6629d822e44581858fcbc8a733fbdeb3d6b037267c868583234b2efa876a2a182cbef701fbaff7930b29f7537125cba8ab7d02fdd571e0058a4103676c8cd29da0b43149d8310a3255b2954ed5b35edaabf6748233c9a0d30034cacd4e409c29afa27aae40e8d74378af544ed674663a5074c7485ccbcbef25831f2a491c1b8300b0322e16b8d989f268f570d6dc5525d465957c4daa44581e7855b93dffcb924c3f3e88a3c2c5c1d64b8fd6a9986beb16abd58d4a1c8f1e8e07682b6f4c7a4662ddc1ef08419a34aa7cb20fbacda225a00707e05048f498ead21edfe1e865f73e114aee32562a581c035f82c6ffc4d23a939909667bbf39b6ffadeca1c5dfc786fd0b2b5b82104e84c601d2c971561548a9ad3fc12501d9374ff585bdf741ce028d62edc481607ba881d6ae66426603e72f8b04ba735a09013fcfecd96be01f310ea2bb93d3bb745b6ede68c209df6ec4c1f20b50d17d3d5ff9090427cbf3276d951cce4b1c4520715a2ac31c98ff12198b074f48d8fa68cdc41308601c75d411157244f6ffee16c0d257e97c2481627b2752db8b0c24baf681262ee53d18f385c0d8d9c98f1c176efe6c6dc1f08457e87a6630cedfda0983c68d44b7c7d203a8ee5c8e032c9ae417f99bf9d109a378d594ad6bb1bf523bd29bd3bdb1f1b190a9c013e7dcc2a26c31050d7e981afc6fcbec5cc87e25a1a8ca5d4300a6859a8b203fac62391ae315bb48f787866fdef5e1ad809355860831e319936283842b5c4a1e7ab78ae2d78a688a81ca63d7d1f1b4907a7ac39f3f1a896cc71cebc083541af3be6175aa705018465f204fde4a5cf4c7395ecc1d18d511f75228050a2f553e6950afd7e01777b923f2bf31468036cad35406591eca9f84607398cef79b115e4212de52d7023cacf7f1ecd15a37a4fb5412924308da1f38d5cbb9fa4a2b0e809184f0af6609a83da3151ac1e00d7dbb5442646952218cc3c843a3e8aeb6d0a4e47bd1f2ac5cd2517378d22685a1c9c7f1efa7b475b6c4775774490a0175cc29385e8463aed5e95246b55438d63baef5c61029e014aa9a08a7051022bc5d714c9b177823f440a176507da77c9766966b80c828e2011ac48d610267405b3c3043571bdeba293b5e81abf5a6159fe5013d8788ecc14bedb326df84b81e35258b500db1f9e21f6fb1852bd25338de283383ea6a17de0f5f0de9ef573138920f49153e427a6c2c1873fa20304cdfca2fbd767fb7e06cb60470bbf66fe585897f4445ce37b4fd32cb5485e798e5d5ad57c0691205152f26ef2c0a165322174138e885ceec1e00a3dc1a7e7932a762c49c277a4ca10bc113b52d0ffbe3d3e11319e2b0c7fb270ce37e5cb134b6d1ad02f073e8a4f9990d4cc26b23c1c25021e97ab4921ebe0d6b4c31ad42b1478d5a2c31880f88a4b99d1350d1ec7e0879390d704066b7aa1c15fdb72ceda8c47558d956aa896a9a7dd7d394e6479f3e81103ea1ab68876c14a4ebb2c3ea2fbf3b7178e27ef48fddfb897a8f9aacd4db791b489279267359ac3e58c0fbb661aafd737725121c4e86e4d413c66c9b40639e53044b09237b869454d0318ebebf1b809306f36fe415247e441365db3798e6200a248187123f77c7965669ad7b91fdbd1baec60dd83201dfd76bec34bd8d76ae53484313fe027f83818d43258d75619d5217630528c25b1dee4a6c186bbc92f80df680ccb14fc326b145c8a3f54292d25f449181708b5d0e0df5f3e4921cfb170aebeadeff62504e8414b48266e5ca0ed1d4b15a4b17282ca0cd9ef852c4dcf332f83a7e44ec62740ac7d834b4170afe72bbd6c7c96de58c680b03321f127cb35d9db91c2ae090ba80bd568c7bfdbbb16e8d2af829ad4a62b79e4e789ec1b3788bc7d53ce48f2e2996a0907f3f28f9c15f4d2f3e4c4c9905afa77b3b6c35830fa0417b29f372281120881ff0f86ec8d1a4b3467492919d565cfb028e9fcf65637e0ed6ae3a69803bd78ba4672d54ead892ea07a8b97c7db5b1f62b1dbc385f7a738ed09b92a03188f2078362aae064ab7fc6b5f0e636f0478da09c4bce8dde3b87c68ecafe9de532c2f7877b540b55be2f25cdb019db59fbd7f479c6f88f724d52bb7a33f19afc6244b6af8084f3ca75e214c283374b6c96a661d0d1da72f235de0beb7ce16304b962f5c4781ae1f3ded9b0ed12e36bdea2d38da2878801b7badb9de63b85c7827877f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
