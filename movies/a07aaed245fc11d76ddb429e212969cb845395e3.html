<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"20abbea4371dd5d57cf8724de5b05f3991823e7d6463b8585a206481772920b8be28a50f18d4d7c3ab287912e603ade7ab5960e479180c5a9077f989dae79885effd968c249f64d8443e971c70165be0f743394d43c452ac14ea54fbc9f518c8e70db86076d5627bf88987e097672da1957003ca7073dabb5c78190185f46e388d75857e694c1274d8b73173c898c19f7f60439aa67881ed3699a478157432f484d5ec9eddc8f2aa93a453cf4e042fdbf45b06e386e127848b8c6d611eeca19f69b3dea971a36a80e6e9967fc28864753dcf7976c2bf925c2a7002e4fd9b2ab86d36940a8ed4042b371153d69020954716eff723dcd9fcbc264c9bd2e175fa740e257e039cfbab1bf06e3f493677460fab9961d18ded5c4274bb483a63191dd3d8657c2c216e0afdc40dd801590cf75173f5f9c524923450c26946c86c17961588dadc2de9e9b449e5eb4f3451cdbd4e4cc291b85a6aebd670dc2bce6a464129588e960cef70f6f5193c786747d15c28011f1f18b65fbf3e6475f9524b482d38f4e25785a02aa7e55766a800d796a307cd8f91821893f9a5ad92ff7153b85b1aa5d2f2377657f0481fe62900d58372cb1936ce480cf471a6eb3ad7f49902e57f7e2c1dd0d4102b6381e86a95072d4674151099e4f8b9a5bb07012ca098fc7313a7ea0ced86e7180eb36365cb0cf565ef94480c92dfaf5da6431c86ca358cd17d94e964a57cdc1763367649e1f0fab71863de1ea3dc7adfc39fb85d2d74bd6b5b7bc56dc710fe2a80f8f31690885f151ce1fff802b823a6125ccbd8e8273a0a8a8fb0ecc9b4ab47f996b0e9538e94fdc2fc6e4d30b49416ace46e955355b7f543578c9f641177f1cfd389d199f7cda6485b2d713f142b8c32a4c181f7821a77cd90b8e8d5e7a1c0833b368e5cc13627c7671a8f7c71d632aa1a1d1522970f5f4886997beb15eb7f9217cff389f5096544d48fbecead0a0e7170ae8541d1b499a9d1ebd7ae16e60ddc689e130c67a0460e4ca77cf387bc53bb907680b0eb20fb5441c9d69ff41c6d233a8174651bca184c9d72355389e1701b389a70c41572b2a52ca8cef97338cc4aa383a966c8c970d9f1298e5edc845079c70bcbf8684c81975fd3fd16691d904227a892abe808345db35355db30b7133438358ba7e5754247879061d6e37c64278e9af4eb03f813734bae61c73654ee3ff1df515301aca72bf5f966abcc8187e36d95ae01e1450d20bc94dd300d962d79be34f45cef3e6cc8e882285b743f84829de9c54930bc616f6b366fd8f07ed648c94a54dda25115fff5feeaa34a51c9d434f391333083cdcec9db6910485f834cc2b9df38801454a5bd5cbe97179869a4fdefed2dfc9883e7ccf540cada7877673dde2d302ae6c87cb8832763144c8afbefda21a4c1441cc8bc3a9279b10d62cb8cf1483c5f507229443a881d4179272e5a1dc8afa74ed07cc85f87d4fa80ab052535b451805c9c8c3f2c524e32d8c2f14f4e90cd5072ca7dc84b6c8e3ac2431db6548e1dd514dd5438e68bcffdaff37521075a09aa344c00cc5fbd321afcc7f2575dcdbf485863034b68e67549b4f696157979238239270231adefb3ca3162124f7269d259afb3128a91e9e8b9ef2d5f1d911d308a1c257ef48f0a8227edb29512f8b5d8b22646c1965e5d0d3e9051e897b1637c5823ed1a3893198d6ee9fcc35d0fe21c8f6cdb3d2c8591fdf65e0a17232fd44a59d1f0601e6775d69dae633b31b487049f2089c34100a50642753bd48474c62c2f74361ff3416400a408e568668a29efa63e6d430f6932181137d6d095358388b8034083aae88e66aec794b06e561d0b51887ef90e967e4a2c8834f395cb8ea8be6ef563a12411e72884525dc280077989a72bb4bb5fc494bc3c9754c7ba2908c3ca06b5c0793405babd0af338e01ca92ce0516d4ebe5562fb685891c082a5eb843de4bdaa8bf3dd137c7a0778e1e60210f19259d6f509f5aac173b36d63d101d216b80c1e4fc536abfbd35147cc929d71b8ec123d360dd14277f247c5f58af55af0edbac58391196a4c054a8601f8583b3bb23915de9e89234bcc37ab4a6f96359d0b3e77183cc77a69dd2c0b240f9c1c7069de01a03ffaecb3d9f3bf6d208bc4edefdffac5d20ac4e74e1cc0ecf9e13e7d4bbabde3e7cb14a8f4bb3657ad797e47bf092a76ffd58103330f54c86c1e97ee850639b2fc3b46aa161163ae3c6c6e4df08507bc9d9479ef62f6a7213e4820272c13f1454d6c3c5366a14e39e47f7a9b1cb6c6512c509d3643585be6d4aaf19d1c84e82edf7e785fe66ee52ce5dbfe9a583ae6b6227e9988bb3eb5505455a39619de6afb8523f1306dd448d3bc5d0d22eb37158e13c7bdda6256b281f462325cccfb297e7a2e23b29dddbbde27b5f64a3cee1e171f992553ad006f4d992d90d9f6e750c83cce49173508943f2d18c182cdeef8b75b44330d28e49e36a50efa128cc2fcfd3d805f576c3f773b598266bb0dc6cfb26647c2038e3aa13b6b8f270870c15f9bd76777658594043bbaf4364a18ac261266995cc84d5f5a130d64d1a674c77d95f190b7ca402990aaa84bca2d8364fc1dce4ab720ad63060fee8cc182e0e8c965f47bf8d88bf0d68d14643286bb0be8d5d2bcf0fae5f3cd04a8d46fc2f3d352bf8ec27bb8c050106370973553d22be14b98ea6d375582edd955994960ef108f7f875bac377f550f9bdfe1dfc704bb2fd46d98e5a47451bbe3d59402e739e2b59303f997364a22abdd007d1c480ce6d744a6449efeda344d8255f173da3cca9353b06f4a815d22e96d68424e3007c84f980aa5436a9f0d57a982e1bcb2753fc02a380acd4085c3d1901b3a395991421469642102b891bb712924359ba75584f2ad18e1ed892e07d070193f3209129d9bc089d21114a69545bb1fa5842fc093b4c5f1214f35270c733c760363a81cda3c107d8e75e18e85e572618c25e7d3ef753fe500e8d5be9bb9cfd538ed71a3fdf83b42b7863dce91db2937c573c3bd9ad0b08bd12d6e445a43be201870e5e60429d54e245ce495c4c3acb6e5447810ba7495647f4481dd403813cbaacb92b720a7a2fc1f72480ded8ae670a1c94e7a5e631fe33d290639e963528c550c4f07e551838526a1639c441d4308691ce9c8e2460c7be2de2f79b98bd87404e0b29f882666f0bf34336598fc14d9567d48fd786a10d939f98679cbb5170733a3e66d216d6ff777b16b53ccf74153f2f18e25696d7c871ff270b386fd48fc0afb4883f5c6d95dc66e62056bfda83f1818aa074d3665040c96df4555342b7324575ed18d144cd9d19982bcc09a64cc28c826684001c9bffbd6245c7e0eebaec849a35a9f30f3a85397849f32712c40645040e6c8b12a04fbc80de32d726863495bc251b5a7a1736ebc349d63a2d1e7ec5cdf75a3cb7b83b315a91faa980200be4dc7385bc40b86a2710b1d600dce67e1b0c5bea5910806f9317a5a9f486424104a55bd4a757382d6c9396a6bf44fe3404acb6f998854f8e0e24084ba54990f288242566593c11e5d7b796ed39a6a0532762547d60d46c5b80abdfc90f9212cbafc7e993b6c93d804ed1b69edbce510a7f92201ae85387016f18fe47dd517d0016685784dcfdeee7dfa99cb9b3252cd7e9aee8432fc9b3980e68dd67f642576c684694d895a292e74ee488e46c53fd7e230428e61da8861a38de44316eca2350daae2e9a42ddb97871b38a64d9282fd2ae8f57db38f6ea898ee9ddf6e91624f5267fe4d6d67cae15f76e7c40afcbd8f2768ec6e4ac58db3064e200ea77de5e118bacebd4ba4445fedcbf49617bc318a581433ea7583db4c62b44c2f3ea90f8c747b5ff1b939cf571fa065b096f9c9fad789ffac1c557f870bd5db1e2cf1048c04caece02209b215173845fd1deaa295ff67686144ff24611c9071367a5c9d601683f7301dce22d94d72abc7e51485118e395d3eaf8962ac802c2972e73d839b6453c71333ae011268fe7486b7a90e5f031428c6179ba371ececb740bc408e51f29f30a566511e56a39717f90de95bb05aa248b13911d69af5c02469ee6c288463e412180f1a7f9fb63bdeb568c1870f8676bf85e62c10e95b2fcd561e140adfdb75893d92533be337b801d84bd71994b8886b3f5eab1d9f6bfb2f3f4a4bb7a0f3d9edb87912191dedb5b2c104ddb3d8586b31b4177a9fd0a05add2d898b4925333ab80430c744fe993c05e91b82395945467b128bb227386485dbb5cac149c9994c45581cba69080808b90e04a1860f4556cbd872d4ad6a1257d711ffc2e7441725bbb59274d6250544f46aa41f678fac91bcad6c30d4dadaa583ee4a4e3eaa27e2d4b9d1706741a72e1322da5ed8e62d7766b72536b43ae563c6787fabf5d2d8ae8e55610781b726d1ee5a51ec6aa87bb1dcc24ca3454667035fcb6306c218fa460d82a712fe47d3d08246b859cdbb9d961fcdbce5c397a61e943d25d21d9cbce893d18144a7d79f7b3f5e5839a2fb6de68b5cf4ef232338db02409a225cfdf0c3f017c5c563f7df0966ed24659f25678fc27806198f33c15df2b13f56b2477feb11913c2fe70c6a2cfbe1ddf063acc105d72ea4b1de5e2ee44bb5d6f1dd8768e46a0a00b772745b545db64e0f83b30fbaffcd094262612567ae3d232763f9f81bc57f299d0ed728b2a87a5c7978070698e0891ce3409c28671ca9ed9215a0af51a843a41974f729774cddd7372005144c2835c3e8f1a858a8ffa66eac2666f7df0574ddd2bb7b1ae372008298f51396390321c579ecf8977cf8ba0b2582545fd37009f3fe9fb0b00aa23f63d89f25005c1779928c8f44b5797b813101b7fd00fd8cd9b65758ca7b1f47f567e68046bfeeb151173e8c909f102c443f7105eb04bfde4c662ad0b3076968f4f7cd2b2631c7ad47d1d5b5dbb7903bb183c45f586668f0dc43a268fbadc5e80f03c8c29977bfaf6bea3f4d39813fc915e97804db340a0ba5e45b677e0509109df8e47f2007699b54a49eb43dc57ba61b7a31e1c1fa2427a9ba7097765d1b31660ad68ffdd9143e17eb2d9ff86ba83e2e04dbcfd8b5e79355f2544cdac78b076374852ee719352646702e986881cc6ec8ff1f3154a1ff4ae749f58711a9dc68900ba4ad0b7f345d9af126e1d6ebb047ffa40b66a3c73593c4665c6dbc4d1702593212bf97a07de9513e0a0b34d515ac9fe70856c8787a6fdce47610547ee688b0baba6656a02d0c042336f45982d2e51bb360ac6fccbf8effd9c90f61f0c0e50ecfe944f79aa119add686fa51628b0a8d00bda8daa3070aa81e31e9263ebefe9e3ad3dadeae9bf044ae9f00dc40f00ce200162ec001e484db4cf00251ee10e41853fd1ddff85bd4c03d60738b37de870a248d7dec8a9a98fa9403d334da14666025a09d7ad32468387446a66d61e49e83da16bc10f0c9c0a7582132bce5dc4d1f0bb452199811a7975608c3a1b6ffe3e6a7db1a54d23cb0a5920b9d9105f4ab7f1b68440d2f69ac4e15dfead2033811fe76cfed81aada90297a759044b93b562ccb17fd19609a2914956dab70346edb2a8bc1841bc4c1ba75408b6c9fde7bf0f62741eefe60f72aadc564479ad443d21c427073883a73491c4825f13c04bcf0407f956669f5d04b0a16617a6efea4500bec00a133fb5be5190aee783b0930cb007d167004ce6d0312619ece6658a9cc38da22d791893813eaecb2dcd161b16389230f51f634d5e40a62f68c95f049beca49944fdbb04069e62126d17cbe9104e181487adf07c9d0fe640829d41ecd8cf6cbf0ed4185f11633326b6c78433ac4141d609d312e320ae056f216176c2de55db2153dc06b7d56dafe2fc33615ef042d29d256f9c427c6e88ddb1dbad304d59ddbf1557bb3f68fcccf9b86fa3a405b1cfa9402ad3dd113520e20aa32dce96a86b1a6b9f8648388e819ed6fdd7c32770a0f6196ce0655b82368ae61a6ca4d6659e8596e85ceb09406a4fde0c64bf1efcbb2dda348d949d954dad2957f2d19f7a14fb9d70b53afe3159e91ce2b3a541f67e8c42e3fe70310c09b78e889d873269ee25d9c5f58d5a8d8cb838d6286cac3db0477a6181f5cf22558c64c58eeed4711cac561854df6efd1a354424aa3b8d787fb0397913ee07d5710b58242f13069ee8bcec0b697eb58346c989180683260519801298665d55b54c4ae379daf66c170d5d06b553fd15c00e15dbd91f5f399870d3584b2542f55db6f28594da6e6f76a302d820860f6fa9ca7eac9019e913d16e4ec04b8c622ca4346ee7e048c7c3d21ce36147ebfffb7c6878910806f8a3c659e1db549bb047ae2fbe6c891b2f31244f11b0e910dd3faa38d40b25b456fc3af4b7f0ecc016c4fcbab62596fa0a6b9aefa30b25433fbcc93bd9489a49bbf447ae35f463e349a1fe9ca7b9ff1b617857ec3c8b557384c1b0a0b9401ba7d6c481167b628033c3728648455469f45dcccb58de05f3549b27cb09720acb01fca4d717cb09617f40d8c5a9721c786402223b776ca99202c2e8515d347fbbfad84ec09d5daa3f407f86e9991e6816f26b61d526d8aa6625c9f10d5176f5f395616cb3196ba8ec748be0f535eb5cdbb390944cc87a6388d52bc40cd3711e5bb31aa604fbc785b32fee5a4b34e448c435fc33174c441ea6ea99bbe17445af65cbbf9501b171a6f5a39e9af2481490994f3ac69b6ea3e14ea58b2b7f76d460870b62689bcdbbee843a73310906e3df3815235005f2f92720007b5a81e111226ea1361afd5ffbac8d8953d8feb9cf6bf5bd45b6f74a0d0bd748b223fbfd35c6447c688e2b8e2c34869b09b03aed1bda3a0eba44525e73942f12cc47a49ab66b0ce161469bfb6abad5f90999ef4e95c1e93ff702370a5af3e7595773c29065513c6101d07976a55b10570329c0f7cc43d5544c5ce92983e949a1e9a5b3c1c53441afc44ff142e4dbbc67664cc2821e9805799bd1160a2ccce33a77601cc2068a971143952fcdc3bafc41c926fda822d6dcc8408e25e3257bceba56930799a7762e8206b6a83651ecbf5cd7fc0de0f5a3b7af4d93fdb69268ce5785583da7050f54965a1b3b067d3d9b8b7fa0984b94ae6456959e42a830df04e96758e562fed4734ba4356f354edb630bb65ad3485fce500128c3542dc7b88d1f07cee9d6fe3f907ffb6de5292af0475564b58536f03b539d119360c00cd5f449b2878aeec3b7ecd677e0ba2a9bc6a485f90d92764256977d57c74be5f24caf7288a9fc0fe2eba82a4446558fc12d2404957369115f6c7573de36c68142f0863c058056f70be40f292ebb6252b1e49b07dfbc4b70dead5ebef0a0749171f86a8380c683b1c21e302eb0d5d658a513cc36783500918de96c6e2ab4c8bc8860e7d45ef4e07527a9c5dd9a11e67ef799fca75d701463ce2e1b76a4be329f42c76430b953c0f25bb54ed66af275f004ba3bd4a63a4b98d624f9bbf0d64fd4b44589059135ca60e47a53bbff1e89c714617db9000296dc4a7165a5e0d5b5edb6ad9002cf8a1d206915e050b4a175dbbadc99bf225dd31a4e33cf25557fe8473f36c6c8e56a937a736e548cb3abefc73684fed3bc28c7726dc09074623912a0bea56ffe25d38ecf69a869095cc37ed4a1ee930d629c9bc0e828a9546b5984a296d9c69b3271ed9f7e89105728c740a05735cb848486090748627f0898ec7311d5fa08ac427b889d3273a7174695a68092dff1d2af1703e4de40642805f73c2d3c4d903c6a2fedddc9a914c483e0fe46cf470d423ea5de6f9704aeb315dc1e347bcca87f945f50ac8c738c17ea400700e5cb0f60099e0f8743c42577d32914e543a3c3cc07dca68c05ab2f176970728498786d5ffbf64f38edd71b90e4f764aefc0e25b4b3e26121dda309eb47448b3aa3af4b9a83a02b78182dbc59a597ba4fef719a97730985a98f0d252efab2c809b5b699c23a8c1bbee845ac3ddc078952e67626bf6fcc5350e0f51c70e47a293eec0743a47e80dcceab4d729e16152642080b0e426520e256da824ef52a6a2b4c2ec581418d5d162a40d8ad2797bde39622b0e5c855f8cb64948ff016f1396d4e511cae93812fb26ee4d684271d20080699431af6c46fc00d409e6a85c76e625f67adef1dcaa9f738c2ab0b06ed8486908557f143fd0d718c349b8d040ab417900011df09c5ac36965aa4c0a87eabf9342344244e9ed5ddb5635e544f71a8e4906b519998f621e57aaa6866962a9c710d034beeeabb2e300cb21708d89a0e3bcf1447292de18dcfaad5c4a048a4db56d5167c7a6b62296fd936f9f2d8966897aeee4b21a95ad13f2a697c3a38c4eed80032c2de78b5205d3102d0675e2e43a8d5071e6558b5daec4e29b30b8988cb5476592b9514c3c75ea1118d5d7608662c24ae1172532e7c3c22d3025cecbe3c4a30694cdf8b550c5cda9e8476df6f2177aa074752eeeb9965d0b4dc7c0ebbe337595ab81af9e714d54aa32cfc501beae374ccd5098313e64aea6a004f12feee56366eafd66db4be3ebcc57e9003ed701a57ffee7323221fafb7516be652f7841cb32733243c178e0d8839bd14fc0f4d8d8591d1363ce843655847ec047490a7e350e8c76a521104ad77272c839e7a705dda0275f8d04f32c1ae1b49444b436de4d1019b34c71a9e1815554c1acb945869c2933d945dfc724e08ce26884fb993414f52e070aca79e03976890b2294f026f5a72f327679c0539e1d70a4b07a2961f5c9b96ffa6f38bd705978d6c3769be4b294157a695022d3ffa6f688b6367e1612642f72d6c5074fef9f51556c18875ec4f00450ef623bcf2fd58fb5c1a64f789b9220a889c35b645d2a58250f32719b205d754d6d540d804e65402d281b22d295dc518bc497b2f4e8d7878adf228341304d84c639c790feec2a43fb65cb66f9a183c4a8a0ad01761c38380f87d0165bc1457db17e9b6ef3710922f4e3b3b55d4354c513eac50b32aac58e622cd99fff342dce4417508e4cbf53d061a93b491c95ebfca38572e754ddff279a6e501c9eb61178affa725dda76ddd36b948218b44172c22066dcd5b08c7fcbed03837275b820a1777e50899e8d0242d0894faf0d3b74f65f9524cfdfe36f6207f41bf8f0c0e816e6e08c6e2874cd4c2b3f05428c93b9895a07303bd14a29dda472975bcc419962dadfe3ee0dfdad7e4f4365254a31435c2e58b0c6f8f0113b4586feebb6d96c12520b473f774000dde10940218c9c10519efda2e68fba1566dbe2c972d0a365b674fcade84f64b6c201b0b019bd2c3792a5b80b6a80d06458016b19173841fd6e52e9211e1c3ed2ba0912578d8f9f5f6e721de8d887807f82b019c8a37a28c91e0a0da1433c72dd1866700533a50805f72bbae1726e55b015b93ea5c4480dcbf78efd3a120f7e462416cb401df5195a14641dc4c25fc1a90957a27db6d03bc930c77515253a03c7612d72d13c408b6bf418a67926d16096021c09dfd1020c24689b35733982e49778a320ce9c26014e63ccbcac25f3f1df40ddd36ab1d39ddb8400c8be9f8d810d78cfd71f47ac3a1c892e585b925b7178cea060a9171a0bb7a06c30d50475b69e5a86f20d373e67a24c40c19705884cb3abf566eedff875376ec07414868f1feb7c28a95f6e066afd8519be00b4716489d97bb61cc6703d6d6e10e7ab4de359d37a32872d91c4a341bfd61f6594825a201732b6c98b393a5933ba80a0010547550118f7ecdab1d9454e7149db4264092569373ad0c0194c41f19dbeb2213a4f6b53a4b2fdb5749a35903cc4d45c46beec5dff204383da9830b5c69b4462042438a43d406a92bb5e1922baa336ffa1257101764f6aef6220dc5e955a78070050408ab5a736773185fa70c46405ab8f3d9cec5fbe83b81e06ffd31e180c355b17508b95ff0f57cda9e8efaf3bf87a726748f7ae41384401b0504a98c490e18a2286b28b2447ba046e0310c2cdb3e62b182d459e8aa4b59868f7380b2338a64b9e5d6ec0fdadaa9c071a3d6f30b2ca2fbf6039337fec09dccd7e0aa16bdd50b75ae56c9784c815bb069d4d0b6ce20de05b6d51c2c7835dee7247bf867009e56ad359125d9ee14525cfe916697a0bcb5513dd7814e7a04a72b565d8ea59663abf73ac0ea3685d4353c4459a298b782ec38b3894fc7ebd7dd7e90402d344a0ddbf7f6baa333c525f16e7134131581238b5f1545c26a67dc73377b7d4807d0e8ad9a027b4011e52f6bae70f03a40664414e0db1073d3cdb8487cb55ef922579fd0c6441b21dae62adba3cbf5e617d61c37acf53ecd2f57f7388d5ac28bb3ce7acad52070899a15e00e8f34b033a2447785332c59790fabc52caf59e661703092f2fceb22fd29e9615ed90559a1c2c60720d849b9b9ceebdf5a6f295f2d784f909f6464379acd14cf8c5f03a700256b74126d74c1e66756cd79c3e5ac5b711a2fe48a080caf0d093e5d437980f79a989adf04dbf21387b783262461b52bc41f87299fd7c2f90605d5208155ccfff2d26ace2a8def824299db87f95e58694f404ecba606ac9222ad6b47b7288b6fa3e571789b505157f7b0ebf632ef9f5bc50cd62a81253915e61bf60d953be66c793177277610b4fa9e39868f71fb5682aa9bef7e8fb176440f76f6ac5e5e81ca5a3e7792fd5792c1ca4a79789bf1a96a1090ae77abad67d3d54f820a379344fade480ed44d5c11cb5331395197733b4667d843e4878eb490264b18d4a7a37fd09da5019d573717f53473a43a75083661c55000b758f8a4d76ff86c37ba50e1432224522b61b1f656ec1ce5648273d6ad8edba79b1aaa3e4d6d3ca6d9ae6c31e9bd454b8dd7c2da826a57cf3150c848f26e5b801f763fbf615a7d263ae5362309ea7ec03424e377ad79fc99a0d0b6f059386d9ca98dcf295cf1ef32f1fe94092f578c73a4c166254865f40086844ca16b4ba192ab1f4e4f26d10d22249b647ef565087c8b43212566aa8eaaa34d9f66869860fc9f4c046c594209ed1ef0b5ddc62969476a5e77dbdc5b19be7dd42801aa23f4be4118b2aa751d39106bbd5fe09bacc007f05f5f8c46aa964bd6bb2e01f190f33c03d50ebe0d57764c7429234608b5a2983bac9391b1df7d203f77b49c54066288815b06731b45a4ba691e6fac4163aa9bcdf6df47c889c525a7250f473886ab35283e0014e862f00badef29c36308b7600ebdd97e5455ed0debc9a22e1e5a3bf50507a888c6d17736fd869732b58c0366f8db161667eecab0e4264f3573166d218cbef5eb31270a17f3bfac3a86a3df6f24b973d9fc91449a6ebe47805c3ec05d2fc71efd0c114cfe1249d5cd6232632b04fff1abfa1544670033258cf5829fd1b458c85d8fa5f6bb0d032f9c968ceb36f41058239deeaf91ae37aa5b04a5e739e028ecdb4ff2e4a1925cc718887e9c6c5f786fd9e3b52ba9555ad09e05477aa36cd643a28d0beb10177f9b6eccc43e2f149796480cdb4c9e8fd860d4c769f5c40eaca7fcb358acd1b19db2551c9d30e25f47a44c451993da8acd5af645a48ede2fcf5be219f0f4b1d47c69083da5b085575ac2d302b29817bb2ece2019467f9985a3147392734c3ac90b1951ac1886cd66b041ecb7898c961d60a61a02efa387ec4614b51b0bfdc06d4e545dc54dfc3a97587666d04b035a9cc9285e71509f7b731490cfdb65bfabd277fca7899da4f7191da771780fbc31a281830b162f0d052315f2ae033a450ebae927a96b45044265fd14ffdb32ccd5537d5371267f71a7af4c085b94863e817ded6006003fcc4dde7e4f6b18dddbe7a40f0f1a39c9715c91da1c6f0d194c4d8eaf7d2e6691ef315d9e6e6f072dbdbe4ac3a7cec5d591d64a83fc3f66bdcf032c4d7cfb256b881932ad94ce10535cb06a4e0cb718db720766fe747b32388a9f36449061b848d8a9b1250db7dafda87bbe35dcc75b824f306cc66006ea8d47dddbb4d481f193f4f61209bf6b90358431f6a348e42b09e2ee958c9708d6712259b4021046de1a264680de4adce8e204352e5bd42b8ec1f549d39202896df2bf47d62b6f961ba513d49a66d06f1120aeae8f8b9750b49f5f63247d22784170b8c540a59f428de0cee585b59b9245343dc441bcaa9742effe9e74dbb99c6f7f8698cca1673f7424b5549fac819ce715002f4b382fc098a804452952c90766768379530faf592fc89fe3d20f2c28fd5a1b231a9cc0f31a2f60200077c89c783a183522b03207d076ec2a37b2f2143a48fb5796a378eec3393e77125b082806cf6d225d51cca8c9d5d9bbe6d798d19be00e38e797f21b232869230e398874a49a6f35b93be770100d73c62cbf38b46b3c39ff7cbe1e4536e7133fd9a65a58f47fa184346232789f6382424af3366b95457262b854c09d0addaa972ed51ee9cf85a520b4502472086a6ddef42093e08c2998f1cffd429166491a7de2822b6198bb03833b79e9dbecb313402259cbe6496a1fc9b7709a672694e557a1bfc466109b5beddaeeef25e9023a397b1b76f5839b88dfcc94c6beee84b6f453fe3ba355f83cf6cadbb7c4a5ea4454815cac09c3e06c8768c1b7a964b341ab26f7d8208b519b961f2b50ef645228ea14d398f956ad6706b763b6ab813e6f8629355ce6455850c519b6d9ac64bf6517e345b328e8f787e798c3c7ab00ed16fe17fb71de7861ff9c55a7ff16439b204d28ab3d88141ddb28e1917ca87ea90132499304f0dcc298883778533b92c3343af452069571aa87ccae08a934bcfc791fb816a6d9474cf4109ebba7b91dbf39d2f603278437d5248b2377f03da74c2ead89214348e418c31b0f60d07148c7bfb8ca0cdbc9e7e7821244301f884cd5afb62d6ee62b03d163cb5b2245827e602057e3673ba21b51551b4c6e9ef39ee5ca3f8169b19a9bbe2953a9c867bd0dcf732ebac59c0a477ac370cec2d21fc4348e1af02d52f7335a348d6f9befe2e2cf0c2bdd61003050b4bd593b63d098a8609c356b0e6fffaf2d1dea122f27eee1f0d66cd50ce72bc3326ac8d8817610773c03f59e507cc65db778743f9a1980926bcaaeddc8237c284dfb826ecf0c2ec55611a8e47e64fbac6007ef33a297a7f6be9b75cb03a475931840758ebdc73dcadbe3e311f46e19eb2186008c6835704a2ca7b9b0ea9c190eafbc6d19392c0fd69052e54232777949748aae38180bdee91fd77007eba8ab3d2804b25e3aa4df73dbd446194cddbd83a8e80834e6dae4ee99ed4662bfa02","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
