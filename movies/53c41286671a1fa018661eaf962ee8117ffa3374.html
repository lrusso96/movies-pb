<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1841a020e1a6ff9b5add36bcd3eedf9ac1df745fa652d00c94967dcc5debac0bff233f53f80826ac4809ce2d930a2275f56683fd77d6feada81d502c59a906da7dcacd2add1936d63d1ac56aa528b3a9bcbca3714a0a5ee3c115e63084b308e19c8b5c81daa8b3777b61aea927b0fedc1666c4eb887d8bd6b2d865e7517f5682cf697cd9740946b51f581613d3bd86c4b643b6d448839cf970587d077a9e15692bd44b6591e65cee4addb9f07bbf6089b72e8e5189aadb2737bdedce8e3129c1a4b1e2b0d7a9b878a3f274f30a193e06dc7fa60fb9b467ee6a58a7e02a2f9429708afd1d872500f1aa8e1f1d682ff8f7905194702105c66e08ad82c0597d043a1c1afca0ae7dad175bcedeed3c82b938e0ef1d8a614e21226882a97b9b36da3b2bc996a29f9bc0790ecae1c751cae36ec0ce9f6f611fea4453f79a9265a923071554261c2ed872d5902cf5f456abc94b1b18412094d98971b137d234b452235313ba1d1d5bdc8e0c9e78fee47e9de20bee52753d3f5e40670b3e47b07ade5be481e458d663ff7a5933ebc876d703b64f5281ab7ddf642e1826f319ec3cf97790a0ea66c8a44a54c8d23da4389d56bbbb4dc16f733e803cc2c303d6c6eaec924c680304e3592f68dfa548ff3c18704a3924243a292afd202ac4b4a7f00551da1e3c8f850b92e54f915f9619a10721f8472edd8b84f1fbfbcec72d1dc0c1f317f0075de9a56896559a97cd80acb732af0b2160e3e974aced9d96c2f587ac79404077e4b52f897d457e77969c594460f45312e207c600a716f7f1ef8c1f943a1acbf08d3360d3d23bf83988075eb15643ffa0b0be3a90ee86befe26dbe37c2c43b686a01fa643491704b29e781aa6e3d47417fe333d1a835203ae4aa691993888a2357e07ab733cd126dda8f73ed95209d9092d2dd713d6c4d3fb0d1b34bc7e63c98b75dd7814a11f19c91664da8fab3caa7c9d726168b51709d97017a60b07fb064f906bde2b1d1eee8b7fd60ea8da820cb0ca22b993f56ecaa0380d7bf3768dceb51451263b89e3c79905a97e4cfd87b101ccf86d583fe576ca332414992c553b41b381324e14f46cee0055cc55e3bdf31688279d23560c57d4d95443ac3375131f02eb402124944f80bdfa776cdde8ca3612f0fc1f92663cb96da75951398a75c4804e275b5248621239f418d9a2fe6234d4ddaefdb6118ef9188cff857c9e70a970a766bc1a24d7be62dc223eff4e349c7a03fadae0fd0e21646ee588807534a152a58cb85a8415bf21c278d4e4ab5a2b1b3e2174d681c7b855c709676bb1ec6e6a8a6e13741cdf6d63ccd73ddf2d92a99d54ad7224e42303ac4e15c761a3df56052123a80a340d368227f51c9c47398500163b8fd20767a77113ff7cddab9a853cd38305846abdf635fac30d8f8dad25ebdf1c47da66bbeb61ed740fe3be5e63d26f9f495686083c2b104a693fc9acd50f4fd46ba19306add8842965e7b9b25776693fe21466a7589955f3ced70c25962aa143c42a52ae3ab8906968321d31f8cb8d18863428cf6243147623a01975a8343f2070809cfb17ef6c526fe7b62207598571f4e58a199770e60e0c80c00b76c1e9856a3cfc4248810d8fb73df3729cc854d591f7b758fd21b8930787d8ae4d2b439d0772548a0b81a0959a202da624b7859664dbeab1d4a9e7a3d3e781bc7e9c1d05dec62b28bfbab4c9d25cdb829d8c4bf9c334a0d3822dbadbd997f39d6ddc64fcc4a501e8c05a97919cc7e26ef325c6f95a9388d15d3fe91ae9899071d76d0a3e51e33e7eded7714ebbb2c63b8ce66381f943e900be17d845120cb4ae2b328cc1756bd5fd42d9e3d32070148d006a2a926c6bc241e5f8b32cd8a6ce35ad922fd9e414aad86372106296ced28798c773da761a6b6e1f5b72829a23955a80ea133fa3639dbc118b3333ed7af20552f290faf1e1f5f5d8aee5f3991d84338a86caf4d800dbfd6b71afb612fa47122475c9f5370beaf821370323a67210f7ad1f998c1d048a0aa16e82d0e3369c56744e384259d936de5bbddf7dae3c603f0dcaca5fefb75289ef50fe49d734d8692e633233865dff3371d01ec2075c1e4454fd7ca0963016af126db66d933a2452499d140fcf1218729d153fa93f1f42b78f7aa2f6fedecf11a4e6ad11115fbf7c221f38202105b7616a7d0455b9885f3725a9379f204d041568f40ae9f52580595240e6e561a8a01d6ac6a5581a48896de6e71a39fd6c9e2201c4f65c738ac843bedabc29638b70f8cff4987c1503225fcf86138d1b9988dcb3954f8983c37518ade37f5bfbb69ce36053e1606f78b791afbc2385bbb91965059f07044ff8e57ceb39ca952f1ecb7215b3f3659cfc9e86a54bd4a8b45a9e58c398e4685f24441fdbb320f4e24217c53602bce9fc95796ecb2a526a80ff0e3ed01236ccd1c458365c4b2f2aeee1500b46c854c7a7ab28feda81f8029209dda4f519b4756623d82c9edaa8125662b28276c1dc31126cc267beab5db7cab40a2fb858fa5d37d14aacb383ed7e8919b0360f6ec8d05a5d55500dffc144748138016600f5498bf9f6ce10375e09f5a97e1c9338cc4bf39edc8b9710d1c45a6c6ba772486abbc4ebbd97e846d63d8293d40e33c63c3afb9301f0081b0487cecaedac4bd04918a6bc1079c1f118d1d2b4305e6c62d2dc7e9bde4ff62f8bf11d6971d9dd93287c91fc486b058757cfc065dff79ee057a54879f3644608d72fb4a143bbfb883be91ab2992482e7a5e237e603a8a42eb07be945504992d0b1728660a3dfca4c1c611b15dab96d02e3ec077eca4ba8577ab057486463c1eca2c63bf81ee327450d735b0ae5c749e4f0d5c3fefc72264b317d46e722c2d4a32166bdd8e75aef8b9f2e11350fdef6f1e89a71ffb0da47282d3a96fa4609b35b065a55e45dfad1192f62c37aa065b923314bd2ca2f95a1d64f40dbeaece17cb9cd46f7941dab4a27ff65dac867a599d1a2227c9c006cca9bce619e9f0c1b88f73a66273272e775f0088ee1be021b7024d5bdf332718363f8c4d8f21005be965ed7f747697a48c5deeb23ac4911aa64d2142ea2cfa480c6e17954182f9737ddc34bbc8f411e0abf45264de799126caa642de9c45d533579f2e7bc451bf3747036c3170159db6d3d15899cd651f327b2f48f7790cd62c4653bb40111887189ba404d01e8944d41385fc3669d93bd7f7015c29931d5c7a4e2d2fd508ee3d015fc2d004a6acb5fad1256d24ff13c4f68ac5b592b6403594d27536401e108c44abf3f40584c937462ffea9c2b28921466a5b08f45f7e41ef897b9089f6b3eb9da215d3c5d84a8870bbaac50b5c2b106f6d2c7757a0c3eebbb2e8d3765850dc91deba943048e947df2b213670a2b38452d07e99a1b707a6695175727cb98e3231fe5f69d53bb4b7c4f8bde363fa07ca3fa29d6bff97416e15ac5e2aff6f03712926bbcd2c1cd720c012195eb651f2fb2d399497a8e25b9a220b1ee984c3b359ac69b670017b3d95616920cb7ad2d2ddcbcdc5579fe409bbae70fa37b0cf66c8fa0e7a331597ebc2fb7aff1f1a0dfe0b1b16048f4e6071ee8c744e75e77073160adaf753d02d16cc7c3c4c1edcba13428af79d292995b49a0762779c82ec08c4e31b776a1c4a4f1481aef5a6d16166066cf02480eb327c260207e31b954a8a6d8d0e3677bf1d5337b248916d043054360f11e1c473a245c6f5e7771fea3774c2539c2ce67a7fbae84825a6e97bbf4ba6d5234e54543ce4b1a67d1d00c02b9575ded8c4a53459ce60fa7a1f0b8e2a00cd28b81156428b0246683f165fbf38f0d68e2b072031f6e615b6bf1f46c6cbbf344a08a3937817b11a94a67bc7d9030012acfd27ff9ac7ac48d0005a217b9015fba1b3326803591ab2fd36623b1cc6cbf7fc352948dd51badb0c4f95258411ce177170172ef2396da3eadf7a63610749078020e89ca9028ece5bf43c5827c401b2895fbaba5c2d43b53703776148e69f9f044d531505f604d511e94aafaa09bb6a65d1c33aefb779cc32dc4acecff4a948fcaa91cb39b9bf1524d524adb90cc38a2433931738489e84c4860958af2ffd80eabcc98617dff863528d3fa9593d4be3423775cc58cda7e1dcec3008cab955ddbde38464a353f270acd3a242204372eabf70cce5c041ce4c37f12d1dd55e5a7f5e0f78ff94d681beed628e5a4589277aeead522ac4c9bed72f67c92a1583bf14030966f257395f8efc18d137a553bd825cd409cfe91bbbbd991d5bfec2bccf51bf58f6042f6e45b1ab4ef73c469459435d9bd5d0ca1100163abc870edbce57e498d9a01b172123690757f02f3741bcf5590051ecb3ec1e339e02685fe804226223c11eeee05ec85b0bf2795293ab3ff8c8dbd89940f2cb197a802e5f58510b28dc679339ea858d8be9c98beee63be1f4434b4689edb3bfb2a568f5de6bb6bc26749739ce66f0df4f5db35b2a932e24998beb0d7552c39753f343065cfbbd3950154cc1ffd3302a261a75e32e39c3235ea25d152861cf19224dfb3b090ee67c9d92ad43b8865cec2ec3f33c037b77cf9239da94bef772d31c8acfb93a873343051eb7939e776dea704973911ab6a8a6040a27c152acb65680e505aa45c020bb559d4cf1add98bdcceb948179c53759d13eb8f32a1e27b50af65f6efcb1cd74ba61439f3bc85de33a188623bcdb8d71bdcb76bff46374cee501d435b6d158aaef5fad1d387dbd16e872e4c353dbbfe30c28089dfb7f0dc28f92e1fa924e60cff3bb1307f1b85a63fd19cea009882a9bc2b4842258bbedab0b7711f8e4d510270daf10d1cdd760d7832edff627228a37059cf2f77b73bd706eff86910a0fb0b6ee2a4d018c306928deca5a359233caf3312c1fd299d22df2a643cd11b567d12cecdd2797aaaeccaddcee79987eb2114c1d48e7ec9ce8e5af8f5724adc10e6fe19edde18bb9befcd48e9ce881ccb8b19e2884167a79b094e26a99150871ecc323588563548342285bf17e2e00c6576ee23d4813ff3c135f968d6a77c845020ffa6befaef9c297630190bb3cd116d9a01664bd4612e0d19a4299ba79a4fddd9cda3f478af832e5b01346e4d2696e3f8035b5a203e3e168ec8408455b355e565fc8dc22a838c41e0b9e50f3f92fcd575549a46a648b4de9972c4f2faa8eb14e167169e0454094a0e3cea1b3441422546a406352ffca42f8000b2bb3952dfd6c8666aa31d383be233426aa5e2335e61d82a5b6a5f38d0b5204ffc98ec31925a70e87c7e18dd8769be163c30c68325b68ad4012db7e87d46c309494bf89f5e5b874b2b0c053396b12f1420a1444acb5ddd4829f9cc4d87cac4d585ceb9a27ca658ddc25084a23cdb3c0344a0649241c10af8532e386d824c96f0dc5f95043ccecce1c18c96ed607c30412ca354dbe7ca847e7f992a160a8f94abec488efba5c669775f27c9b13e217764063157379d19f397ed4146a0d813d7f7f44300fd6786b44292ef9a1ebeb2bf90301ccf6802f1cc2086a2388ffbf83a60baca38f50b343cfb9e3faaf2d5a8c9389b5742d519d8e1c6ccd5b0393c4fb855a4108ebb33916c02cca277917d62a02b7b293984a7d4dae376ddf1b0549d715c327edd9f69816d8d3a59b5dcd9cae4ab9de067f984b41ceefc15544abad4227e99dfe0a34ec529cffd700124e606482565b0dc7f7b2f2e9a376debcfbfe3c30b85862bd719b1b23e04ebc8f6091f2fb9c1c750ac4aaa3fa85a4ceaf12c43896ff85baa9d6c56e81bf0746c837bdc15f2f5533bc57098e519a50bb2d5de3dac98388ff4143351b29d44c43a044e7b5c9af1827965913219d4ed755fe2ad35bd58a807a46765123d04f8952338a22e2cd9e336cd2c215c4f5ae4ac4418a8d1ba56c5f06c8f3edf15a57a081d543e44b049cd211046b2fe3bdf9f9afd1151c865ec8683465f41085a958b8c64b8d9fd166dabec219a0bffcf53db875cbf45a34441606f8ae4bd0213df1ca4cd4e77e671a3b059dad8743eab7af3dbbe960f6a80d8efd58a3fb35be03e5916784b8f0a6c38bd977a8058d63904a6e47000393038d974de73e6e7defef3351539550e739297492bc110342e644139b0da1082964cce8498cd7bc8ddf2b655865387b6d7395a3d4172b87b6482cfa91efcc69597154022460a05afc6eb35e0ae298d985e59df9545e13bd36f294d5f490821e713a858eec0623fd4cf5442daddde864ab9452c26c85aa22eecd112257622d29c691a912be4121588e19e3743800ba0fcdab7dea424c153a448acb8fc4aa3a1c557c45f1a1b9c1f4cec91ad7d2e6144dfee1f5bf2612f3290fa33e4a331567c6ccc6c0b4c8a52a0c1f56840b9edd44af62293bc99fca0e92f2a7346e6b656ecd83381daa54b640724e9ecc2d532edeec8483646cd2accf1de1ffce2b6f98a6d2394b625163065b0f3e072632fe051ba6dffa31224a421483d83e60e39793119214f7774c844287a07d4c03f02fd478c66729e71c77ed85e43718e398f5edea9458a25e036098113f15308005bfcfc4abbc6cd2d4e16f20774744c85c72666c109728ce317d7fa324b7163a830bf1e5cb923d72fb24ef00c65aec918a2f086c7631d7a04805c1407251ef49fc967c16d8f315851e5fee752151dad5fc2472b5971fc0090545b0de43f80966819dd5aceeb5aaf432a767a37655a53e81685b3ec0e4f378c389f188e1969267d31d436d80cee157534f272c4f7264df109e5b633efc5cdf98f1b845884b8522ba4bd2dced9afc30df7159a287684533c61a269cfc85f095b2f237552c406d8b87cc2c6419f5e73457d827d72de7063f5495eb1e9bfbe68cd606b55b08443ca635c788b5542f87e4d626a27cbd2d93f313c119bda266b2118cac1c1b130555d361d7e49873e639da9a4bac7303e9183bb4b784d7cb40cdc69511f8f4ca5a81bc8173c6d1b3c7b13f6fab8b6f68737657ab7daa2a68cda18245446ffbaa57d76452602949eeb0328e51490b38418ed4c2121a2f818cd479617ec28859461ca115094b85ad1f90d444bfe16a816c141fc35e25a2968e9698113c51dde76e2989364d2253d04969632fe2bd9af60bd37b0f2fd82b2645c24245adf51f2a83518808b4d4758b720a98604bf5f2837a94e7c1cb83b3772d0d07a4db535c352fcc47df04c0e2ee1ff5f21f8086476679e7d1142d57de127d767865a885b47d75cc79f02248a0e83b907355443918257b175d1a663a24d51df8e9345f7f05a1c89983c56ce2b29203b38c2c5da0b7ea7a2f68a06fbfe3a3247f714205b5edc907eead01c4607b649cb54f1e9ef2e5640bebebebea3912ca739361371a3e87326ef337e3503c3576d4ed105042ac5000db080ff1e8409ff52261d93f9574347aa69f4ce0a478fd4531e6db37ea4fdaecfa2e33517ce6cb51ddcd06dd8fa6dd4239aed638e26edc3a7bc6c817e559ab1f6d32180742c1d3e0408a465f405c4082101f76cee3e283e5020c7f7d0e74efcd8d9145989b0e9a95dcb39025c9f87834a77ed9a6d0120923d410244adca821d90ed5d0d3d4c9e3970dbdb2602309b9b82228365afe9a6fcc487a3bf06a766e008e3b5bbf9cbdf249c9c7482f11ac508fa32308e64a9c0acb76525e90b79539cd8422fb7879bc0035fe4e4f6d4d8f6d38c6425ebd5980e69d45cb2890b0293cf39869754e5192fbb74db90e8f5e230d9caad59c5c88c9870a22d5299094bca95ee2b57a569899bff9cddee398c54181f9449a034f5f7b32a55284c5e51dc92387a060863500aba533cf93e119fe14a7945fa7d5d4985e76afd115652065c8aa42e04cdcc2bdb7c657ac222775f0070dcdb82b210a933ee56344aeae69bcf41cd39ed0b87e520c41ae19f5b807c156a2000159c68ba9316f0016b9841ad73188b3be979ad98fd4689356d870dd9acfb91b8c77f0a6c7aca6ba0efc31c307167cbd56874805113aa33cef7973dcb2b9a683a3bbd2cafeabcf7ba1461ac82dc3b8a2837edcfcd89236c6b5beb0922629c0892c74ad5c5037fcc8576e060cec72b476baa8da63a46bc71ab86bd1ff1b47f370d8ab0ec8c1fc34d01ec07ef21057078bc5b5db93b0973dfa2cbdaba4658ac4ccadf60928c27cd0aacc2a4d282d070d3e17772f5b5b3bdf2d7a418e5ccc450c0dd6aed6c4a8ae505dc00f365ee85c51d76f6feaf4ec2d26716afe52b84f773fa3383b64f760de6752e52c4caaf36ce82f89adf9e6cba0df8d3e037aab918bc9d86f35f305998b1cf50419af201aa4c7252f03e5a68e1673647c6d4cfe105e58c24caac97e5565f8cc3e1fa459100bb80927908830249f5b389e71db7dddf3468268b36a82004130b6a493e805c9f99e2d1e260bfd75850b65062ffc967f75d1c3f6b837fa7dd8bfe9a7d643587e3df08d36687d6c268e140440b8db63cb09727e11f5e943194bbd9df9235317f64fea1befdb4e24f9847c286d6f06c9f880b9281083d17b4e0570e4b54319827c25c2a47b86ca319b4a915eb5631b811184f7fea3c4444912faa8c8ac8c6b0c2a6be5ff4a08ece750d12c7fc0346bf67e237a7cfa9feaf1589851c63ddfda10fbda9c5bda204c168e73d43715e2794aa34a3d59e2900a4608b3e5144bb89e512db3a02f7e9e17b3092a945345557a5b366860d90676178331cfe4bdc5bac8394a455bc3a1d2783512f7c62c65c821357d709a10e66b86100e3ff3be4b4b2ae1afc4613a64886d57569c8b509df59bc4c005da01d6cb0c2c8f03f63e2a286bed230a434db646c5c97797c44949e56e32aa8c6ba63f48a9fabed7b35c7bd794e931cae3f50a813a0e261144b3a7f233e84cbafbd7bbf8591da948307a1e33bb67397e0ef8ccf2064044ebb1a3d875dc468a8558b53aa6e50536b86f7de715a26fef71d87d11be8f4c878e56f473539c415023cf964ba1965571dad7e92a94e9846a2c06b7616d1bf8f1a8f7f9cd33d09f667c6c71d1fc6b05b9c27a30578412407a791c8bc2658ceded244f9e9cf916a14965eb6fd59452048258682e48c27d3970579bb05ed8c98fdeab0ef820950b0e11053f0c85738f145d1350d88b82e43baf234c2b534e84f4cf4d3f0e29dea5b310ecda5dffbc6c41df4fd371baa81eba7fdc9356f6d4bfcae93e01e9ed2d545be2320625ad38ac3dac51d2e296da386a5c02ec90429351a1c8ff0dd8557b06fd60a91085c903b73d829a774dd2da8846d40c6c93d0eaa0cb654a8b275b3b42130a42ba6e2e5d3da5947f69a445b7e414bb21ab65ab5f03c285c80e7f6af1572973d35f0ac7b270d63562042a9c2939ae2b3fb049b0eb050d3b3f832ae3b91086954b66eb969a9c7e6a3af6138ac5aa160a75de54edcdf6cab21aa4345af9b14229009c82819728c4e9af8f9ef493760c5e2bc1bccc48513288b69171c6ccf7137ce54b490ffbfc81e44ca5be30b9237989810a1bc8469a039880e5d9c0324249e5078aee1577fb4c08883eb1b2fcbb7c18f610dfbc9f67485e7d88c522ee4fa2370eaee94b2e76fb25750da5c81dcb6471f9237e256183ff016d343de34bbdb18eb678adbcef7424bd8e0db8327e58f326f262933391bcc178daa8feaa750a94c1b81f0a7e43bb110c25093b9723353fc9468d13155445fa0d84e9c45efebf2f92c9c14cc1fbf388c1251d892416f032bdf74a749adb5d18f877b711c2882549973793df8f91d5057bbcc7279e4448cd38c8e03821eeb41e32fa17b9d47d6e1ca773a8b680bc242b69524b7a736e12c1b5490741fe480d3cb52f23c275915866d6c411adc059c67cff2b3733a2b01fcd60622b4589bdd5b315315dd6489f243348e467b0c76656dc935f239dfa652f6094f25029cb9f2713b4c257150a02d4417ffbfc20732555b905f7d28d22021648c25fcb35d157149cd1c975b1848e573b6246ce32b137acec7fa079a614a6e91d29a9a2501b420629d6e0c1b0dbb50871decd3652e6a2f3aa514db3c71ec48c1b319586af28b66b517c7dc0d4e6443d0b29e0a1b84093eba46b1ab6ae1a697952b4b00b2d034abba9b14870f477b102b223d09a293cf9212913d0efea8f03217eca1fab83292ef8fc8788f48b25d842480063eba16e16049445acc809b506bfece129b5b0a61db17c3b6d2081da61f8d497e89cc4898b987a64aec009eec50b2622e7948a55043e04c0c09dbe7f1de5d9b8f4cd7d2efcca3df48c04917c9d09a914b7539f91dcbc57f12907608786fb1a3fd5ad6597ecb273855c3844610a5a8cfcee19fb4a7259c0c0a17c190b5b3b0325090807540272642751082f7f943bbe1a124076fdde86aa09223749ce90b474bc1f1b8895b4e7e6fe836a60c59320afbbbf7b46d89602412b62137ce0a3b722236a7e96ce8dad1e3e6d1f085c6e91da288ddf9b68cfe0713483a50dbf94a04c3b5e140e3705c9b027389e8ba3a3d9cfe5c370be9b6811ba1a29d5f615be27c9712ecd0712eed20156bbfa674b82e60c32af78ef4c4407cf0f53e90645af4d548d271e808ecd5d4d519a52a01e91edf0d3ec48cfeecc82d5b4e64e2fe0b45e6e9c21e8ebbb32418f69a261a62423961295d8ddfcb51b7058398917f08ed0170ca76160209ff645b3b6b77edce796edca12028a8190e19b23735534c8054d832be78ee846d5862850b532d243bbd29c95c74571743a3f4c1e25b758cb5e684055aa8be90041065f89f395c01e06f39e5b2fb3f26f1d3a4d332ab828340a8ca917b72321ceb90d7541652e0b98e3b72f7261180c878836a3d83b171cb1f263a88102c2afb2382a1ab49ddec9e5d1e9fb86319dc2fa8367b8deb00e49d1c875d9574271c3ad4467114d9e6bbc1ff8bd39a12c2ff94d334001ed5af4c645355a28df29b44b8f4536ec7b670518291ab1c1d06cb5a1269101dbff178dcbb4777be0386e932c7034e52714ced8ce35cd40b5d8ea4129fd8fb82848b0b9ea3c0b8e10df8fe04bfbca4d617893cc94edc0af1c78b386f60cc802adbe36ce490f3c4d90825141e8b3545be38c31bf2d5a0c793126a89fd6dea5d9e7a5d0d72e545b1b366b6d2261872b243eb6301dde02b8c36f004567e7202db1e304794a5325ce55763b4012492f643bcd6e4a5cec8f78ba1c368814983be4353f6240773142aa5a1de138d417a4627180ab3d575cf5e34ad862e29b79acd667bac679088e86ab1d02e663ba7f6ceb758fe351fbbd7e9dc328615c0a718bf263ed0bb7fc6b90af522d57a2c50f05a4fef64bcdb0e91cc74065897d7bbfb6942ed5ca8fb687e717d5640de72f7d46adbf6d83b403207b56dcb3b087d1244e42eeebd63d63cfd2b435954f719d0a41857791e7283c66ffefb0f9e14a21c323a876a9be1816333c086f9a90077ee63020356b336b8506f58ed13c32f0711c8d6c8a41efba4472653cae2bc1388cd11a378931e307718c6a30e69e43f5115e44286b0b67759e701b89b9e5fff71c5aeb9b019a4c3998831c7dd5d184288e8a8179d88a3260e48d60218b1979d96ecdb0a400b65079b28dfe453d723ac88fadfbb11ab92109cad97200c4f18e8978e1ced7566500f15a30251d3731ef51d4681efd874903c1dfcf572dbad3230f8e0057a223797c2a8102cda42ea34295fe9a66a3d40018329a1b35d9db958440bf04a6d6f9c36408095c69e5fd7c323dee96fb7a224158e7afc6788ce6b269dba380d8118ecb66dc6f18c98a37c417e9558b6e65a0c091811c90ce2a83f8bb2930877236914e80e3492d431e27dfecc7e1714b741ca9e74d326c80d5ecf0cf37b6dc141fde9a2a995f8dd598cb6ede47d5b1e0b61125f8a96518f461ffb28ce2c7481aa368f61598e7300c9496480697e3000ea40517f6e574feebc1e7bc20512497de264ece62e52fa3fe6af88c5850fa2deafebfabe4c7284e237463002b77f518095a62da5f65819f214daea120ec9d2e1b32093422ee6413e375d84bf0c02c064856a838cf0465d64f974cddf9fd625af38a9f8e2ca578ce4200563d7ff071a01ccd53fe018bff421c104e834f1fac1e1b88a7d6268724f33b9b7a704ef42eba9bbd412bc48bef30cfc68357e33ad9dbccac1a750d5ecb247608aabd35d71c8d9be61fd0b347ab79bcf8a5ed91f2cfb726bcfbdedd387b49a271c9707d15e6e78fbfe3ff01eea21e0fe9493cac14bd3988a0e1ef93e203c9347a7af75a0b5fb793907e9b94c71aeb5160e87ae138970d63398e5a4c347653ba4fa3c8705a1758742a964a6b1c9b5b2f08d8ef9a3360b6df1e85277ec87af41eb1440b4d3aca63b2fc37ae478905aed701b188a8001f2d2cff0200d0af519b9fcd23ec98e008b0250b7ec995d1d6a17dafa30ea2ec1324141017d97fd3cf121b527e3b9df7ee7ab57f391f4715cf606b90fb3f39daac343c7d9e2bc9570142c80a8529d938f07be120909b92ccb86db2a9c9b2f2ee8c5a5a7c541360375ac11e182d48d386ddab62c825154ef60e6c262ef4734e2406f80657b4093b1cc5da618fd860de0c8c9cd9f3f1c18e446469b27e5aaa578c885116a2cd44f753ae6960014b02dc2d0c200acf294e6817e049a178324791ce522eedffd04cfe5ca8ea7d8a0ebf3f32d1fff648701c5c0faa6cc7d87e008884535c98f83a63a9f46417563cfb135a54207f69cd48c388d7e423cf9cbeec718785584a305e35757ea1b3a1663ea57aac0388d1bad147afd1c0fe6553938cd9ef2a2a48cd9a0531b31600aafb41d3db88036088db79df24351d931d40d9bdab0ee295fad7f52ed229d0d416d76bf22f2a485562fbe0b873a4160030b84de672bc2c8a6a1850783f7435f41849a2bece2d9fec6113cc865f61dec7d75c41805d45e55555b426882cac5c5228d611a46804312440372f6b69b650211f1097d1bd9ee6471e6172b42664895fd48d54d0352d5a86a25875c148d1ad72d0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
