<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5e6392a0c0b45513ca569ad836d87117526084521b60f8705aa38afd7b8af6a6a0703ecfab4d1a293952085237c2da59af6f8a892e20a1c72ba40fa80fe8c3e414203bcfa2b2a86e290382b23e02ef0bde982cb810b8821613b72a468f312ed266f79db7aacda31e13bdabd9e4b00775fb1a2449e5454520e90e1a72329df5cdc8f7c4db7b02a6ff98b52a1a4316e3cd9496a2fb407445243208bf0d102f1aee1799d9125fd0e817d0cc5a4a30ffeb1ddcfeab87331158800aafa0702d8fc11a7e529c9359b30a31747e4cd3b4c9b52ccf3071ed313a9df0222c4a67ecc1709a672cfff89a2409962e7a103d0d11050c21bd3a4a5d9d2feab9c4f80eb2a0bb80d577412dc3e6ee3c322d1e70b2f817156bc8fc5c9e7e04f2232b2d11e3fbf79ef3a1bfeb8986d4f8819dc408cd93e3cfd8da5d3fa6c819b8f3fe11bffd96267211266c7c84196f607837e435ac3c6bb01b49af4acdd2204b559580819c4a53d4e8116c57e7e83d9e5bfa66ebdef04f0eb092c6cff65669cb6f5ba393896a2aa59a62000dba690fdefe92b5ea6cdaf82c3246214572d5863e36d7266b55bc0d501763f0220f6c7f27c155da1f89b1e1a0566b1ed3f1cef2c3372a77e96522cc0f606f39f9a510f42d6040a62b32e3875b6d7149e190000abcd416834ef0b07e2f6f1aa1c95e1f14a6fc50339c22ac712fc05393db457b5c83240eb1bd1a6013a97aa00e0db523a690a76318bdeb17c7d3e369dbbfa8b80c964b03a5e7f694c1844ebd1ff5af6844aebd2775959b783f7a9af3b9f409f16f893f03e252c63ad7beb8d7bf944c685b75459a2404c9c3819806f28bd5c6e11ebdb937b4f681934aa04520adea33a52810559ddcd72eafab0eedd6c112cea322381f42399c6b2a4b616826f8fd39f58418dc2bd2a166aef245d0341bddc5a157d01b377cec107bb450745c441e72a7173863ac352d0b0879b00dd2671aa5dabd6830c34ac894b5dc12e4a96ac46c65f07335419602ed3518bf4fcc788a91c99899ca37dccee85624e14eadd4c6ca44bf5fcac762c768b3c33a2e385c81c0c0eec5e5f34690f40de211b933e264b5ddd80b6477b5b0d1118343600c62500218740c07030903f35ecc7c58030250aa3fa05f832036e63420c26014e3e37df75221a7bffd030567f062e16a1d8a5b7d97c3fa1023f3a80e7a1610abef40f25648a0d8022670b97e491196779bc34a220925e535da1e59e2927111295d25494974dacff6b7b4a94174f4bb555f9e24ad0804fc354ea0427ec0cdb20a458030ffe5714991bd9b0b08bcb4d14e2be4f12d91dd774b3dc09be712ac5040f53dfd15c65a3b044145306b4b45be0c2b9e329d4637bffd62336dc524d7625d3d7c7a627f1884983799adafdf605782a4d0694f2234af62913b41355cd78b4b5aa0fd134e7eeda896e4d865df29654f268f7873f158637b2e400697f29f092838a11ea5e8df5a8886ce110cf0bcd72277e3e0225f63db8dd04b8d972d93c8e1b38fa709143208585189481eb3fa7c430f02c397dd89fcbd7522cc3301456221907d9d6d12030f24e5ff5b95f24cbec2ad0933895a8240762c72bcb6191c7425f25b8620574a81aa6c4abc5839ca8b92c3b35ef5fcf86518ae6c81402ab356cc25463d310ad3bdc7b8082fa9a71cf8e2a0bc0ea8344109b6b1bdb04acd46d689e6dce46e810c013b2638a97f018ddc586ceea8bbe79226c8e7e9104840ea89d54dad5ff82046e0b5b93a5c3d05f8232bbf2b3bbc4113e6080fdfa821d6873cf11c568d04be8448d694591d56aa3e7313a88dc9757ea40aac682820fe56130c33cdfa5922789aaf1978c2325362b7a9bb3a97b8789932a831f26e4c79a772b8bc23dd5ca03d5dfba433a0a2e902be36092cac9de4abe166045def09afbc3ada7863187582b270a6522aec60f3b99b3dcf9581a47bc797b47850117cfba543f733f42fce3577093273ea977bcc99730d05b5a288cff3335439a1b0b466f796b1c6b04333a0c678ec984f3f1dded41ca4a9fd0e3a8b99a9d601d79a227977893dd88683463b44843a3bf77cbaf32346fa440ef136b17dd4c825bc8a384a526ca396664d681171c8cfc77f8b1e8df8447f8b14192ec9ffbc7ebd7409a439dec64d2c944eba30598ab470b51fbce7f22aef433db7e312aa7d15adcfc388f9ed1a0125726466ed66d3b8289cfa8d3f4dccb0cbe996cca616976e9fbd3bd60bad169a0085f966dbf6e35d67449e943dd2ed975ea5c7d03a782df9a7c664a037664aece070142a1bdcccce9f4b98505132484cd69f687468a8cdcb51b0703b9df1118278ec3e7a94b0d04ed5e919f10ec08d9a5f36dae6ebe9c478ee90d103f4b5761f92083a6bb221459026ac6cee8f88bc6bcf313df4da47d55cb1d3f37c1fd3d00e0618f855a046f416662fd018f86bd9b4dacf4b1b8b2d60e08d2fd11d5594916ed113522fee5544120cdf21023c39cddd3aa4e4eab11a84e128d5c954e1b927da7a7b3b6f0312542ac1d09ced95c5ebe4357f2f4f60e9c1386af617a984e08d13dfc153371920586a945cd2604c2359f1ecb84042d494cc2d17eb22e64a5505ae969316ddf606fcab1b1a7e65da8cfac4ebb8b769e2832e3d8ea038b0214a93277d164d51864971bfff590257051f5e48eb2be20bc8ddae7aeb8500805089db1322db1268017225c913a98f5bb0fb8b0d08e202ac4c3cd04fe65b6b42588a9d83437a101596cbee2e14406c39cf4304d50ad6899a08d04b1cf4d5373e0bee3f87003e2fb9720e88b191d7172f30b08304d5924b9929b5f3560aae1d198d8ebec7e2a25f1931810f5e49a5cd1f5a7ec80b28b35a67e99fc33390cb2c1928eea58a3009cc587d4c2ed37af13501ceb60c0d6e402eb3d7d1e960456dc88dbf587e403b2e1d507561f8f26b3d856ecdce0ed1c903406cc00da0a73362ee992b3b96bac6d0d241167f010797daaf7ebd3a4d5a96df6543d6d2920da27771ce7a1bd4cf42074dabbf499243deb1838e9fdda9abcc774c608f156e93bcd36feefb098301cf37de879091acdd170ff9b086642891cb64b6680788a6376a3d4e665d44b7badca42c4fe90e71217261b9fb617bb73baa6f22eeb2115622e6bc8a9dc5778ef813741b4a85ceee1b696f71c92d5dbd73b068c35679c0536346ac30d26016e00e66657930cf41158b7947e16c42b7a893e956783b8658652a7d1fc664df05b0ded8502304201e7543f6346d08fe4baa0262570eadf0b2103f7e0833b6cb56227d77cbeeadc1d5b2062257195c71fea0641404a179389599615befda90498f0096c5c064a26ae4dcde1aed7e935887078eeb6839f03a1d81308ebc1a903f090618c07a6fb06df1e3e1bf1d469f4a621861d6baf60be48189fa0452993ada6ee724f20c43fd06b23ec8ad6037eda7585eca2132c859553992c5d9cbdff12346c26a6e3c25cad5133ce757e8bb80044a3c6467afa40b72ca2e7ea560853724be742e8821a74b0d27ac10c99c177359d1034454aae30c5dccf558e768e61dc379fbd74ff28ab225093b25aa1fe36836596ef8786249454d22cb1b3b3f27bb249e832dc414c87e838093ddfdf4b6e4ea798c4991c59694b1afd483498255d79a5934dac86f405975f707230fab6df51b8e3a67170eef5ae54d78ac66af12bae55e2ebdaf467de9a5fb139a2f5d190a44d280279986ccfd7d5ecfb8b7009081c514c345cc3319b1aabc4d814933f2258e05a39299d7979ca9b4766661e1002458c4d899da384dbc6624854f8393cd34537f5892b677487075bfee6308f97aa79d603723ad6f211a65483c5c1eab3605e63241bc5dcf09f28078fab8289364a931b27e24d73869ae6582ed71eecda35941bc5255bf983fae2cedb5130a71c5fd0b8281ea238e7ada06b30ac794a207ed24fe3f106381e196095aaae130b1c30d4c2acf4917001c224153e1fa41625312e46b0c95d59cdf93e8c6a4180c629edd49130b140f900cfffb8be2b339717670e121b2085d032b0bb1ced505a86c4b9ea57e7895dbde9a4c5a75062deb435bc3b980546818134c38d37c39164f689e06d7d8f0699601c4cf1ba8cae5465f0357099c870c0b64697a69166f22313f031a09681ea86639bfa616a94d2e4b84219965d5ab8de51af1552b857a337c03a5a5800a203a363f864cb0abe253613cefb2f25839b2359228d9d2d37187b9d14077abfd43b094ab1a60dcf6d79bf04bb527ea472ab92733428693d56185e73999da39b32b98ec0fd2833f01a7f3b6f06351ef5118bc6a2e5e220d9c0b8452abf662d28a776c73c282741ebd9b09881340ad45949940ceb33e6c2582e8779332edea0512fda30bad18e5ba94db97eb4bec06889f96195069ca77358d0bbfa5339a901f9bb2a3bbbb568a3159687aec59c5902c479f4efc42c46b7a141dfbb6df3d7966fb4f0e5a66fe2ae594b75c1b36a42ae95d7fb85d3cd646e0d0dac99407f9c0a892121b5034fc014474e107b57080b6403dcd97b2771c2f1514a1fc6016e0019f7c6c24a89dfc3a3c14a70e06d0443de37bce9581fad590f80cb8101b5f2fee94f3b3f4d76b2d23da484c99e4ae56a5d015eebe15b4b84526cf45058f5298a1489919c11a217cc054e747edb79ec3b470e81eb7fe025126892e5556b229188a92cdc99be690a3385c7217790150ba581ff15ff01d29845110d6ff34e0d9bde96e74391e3e65f6fb69353cea4626ee34a5c3e3c5b80536a0b009d3d94eb656c4aaa8a558ae21d721feaecd4e8b01635836b168d19bde9d26790260316828528cd0a3eedeb3b5900fdfde209cf8aac9ffbbbb1de3eeab00c30de20469a074545a3c19563316111b748e25f8aa21092d3fd0cd29c057d08ab86670d1b640579f03c0930394b2b92690aec5ca3136a3668ad96dd3de009447b06c83cee6c30e3904a55f4b0fd8e0d49783fb4da4aa701af51b30c9aceb373026830011bb34e690ac18cc4aba5e450d54033de741d2df56a5130233fd59bc9c1f58dc94afa67a7311c7f27373907423675728e97d36a982c2b91f33d4b57353d32b7fdd7e8b7dc8c3d101ff0ab4b4ce173d297f2662b942c02fda6eec3ea72fe36f8ece7ce610c48e61f4bb6ad99abb3cfd02ed29208939d2e0daccb4a523c11877a2e9f09beadcfb4275aa8dd95a9c5fdb6d7c6185e16ac6e9f2a1e7fdcbc5727e90ff149f6326ee5ac997a29faaadc927884e8a4a6bcc0e5de6a4b68e1cb47600d2544ac578242315d5887e71f950060824914e5d4e11e48d93bc6e6c7af46b920e125a2cd372b9dfda7b5c04c44facabd1c0f0de56b50409b7ef3ab472c336101136e0934405cea6877c934eb9607f8eaa91857dd8818a9629b136271c04405c74249008f8c88ca61f67dd1368ffedccc5e152eb07bbe04676d75fb3d3cf80b2d1eb54e15ae9454b032bdd0ccd28ea8ef05b082cab11233a57adc50ca40dad1f3a0a14f80c8dfa6c4a9369453b49183a04b14cef1f20d22e6290078cff3ce3abdc6786e9eb4277815c6970b98c02694ee11e85c43ff0fa082ec0706bbe893f7b8e57bb97126725a3d96d3edabffc438b70dd7149cc7be6a76db3c58ff900b36f8bba710e896c1d63bfcc8882e91200050b82db2e4cd1cb3eb8ed1cbd7535c59aa4c8c84ebc735bb237b297cd7f9695263a4a836a639ebee52d45870a92fec0f7c3c6a7a02f30f0d77800fa757131b41adb74dc8f924c0439c286b97c592749b2b0f1164b9d9bdcff87882f08eec1e7fa34d5acba92acd56425eb8fee7e879493bd390fd650046c1830e42ea2645049f5a2f593d1aa04dc38e9f3f6991922f5eb747771cf1b29cbcc9f884c08378440838e2d405b10462c4d726caec8304c34e394584dd0a298bd5d5c8cea0f6290eec97ba8388e8e20fbb654a6df5e8468dd19b7f322ccbd8e19526ac4dfad56e6563d804bdcacb59ecf3d942f0038de01a9c3a06172c7c806389191af9487bd1e0b8fb45d21476a037b3092a54b53eb0ca238f7e541a25a2f3180018d11e4cfb8ba3aba216237dcc4eae4c04e92d0ff17df441d28c92c8cff170ddad1aa0d0333799246b33b1e2793752cdac78374f2be2f73e872d87abe48b0332e470605c86e07bae658073c432a031d8c97a1cab79b45a085a35b7a20b6d11859dadaf1879413aafb902d707688587e8767ecb1bf12dd933c45611245ddd6b4f86b27ce761fb64f01a0df7c154cfc8240aaa39323acb0a167fbd3e9365bb9cadcc858c9f07d56c25274f8302e1442dffce5a709dac4bad8e3391bc45376a6ea37c32f11dfeec4cdd408bea4f6029c06f58e0966c3ee398affe6b15db9d24e700ece528970980a4a230d3c6ab27c523e614db21f74730e45246e79a9bc9b98a7b097b68a05fcb681bba931b889d524c40dce3bb9444da151420dfbdc1ab5ade1f2d9a0d337705508c485e3bcd7effd3adeee7304c54b694f4a93bf85e20bbfcacb5ee18ce151314d232aeb76af1cf50e242dc641b5cfbeb6aab7bf99ccc0a19739081bd16fb69eb479348994512177ecdc0aafdf80ad20a31abeba1648e033eda5643272a1dcc76afc7f5486124c4e497ecce5ba0839ac3d5593b7c3b42ff66fbf5e555b03592392b969c457d05b93782d94f42d14a4a15aabda56a9d3e84ca012ef0343f0e52966683c889945cf7898c1a4fa642214b1f8aa83342619eb21e78659d6343ab72130a60d52f416e20d4876a577676033fefa6adbfeb74b3ee0362a23ea97d359096e89773cd8736a7e995c3ebd3bd51707d01aa9ad25887debfbad4a4d0b38cd29c2f8c9777dc0a0b4733c84dadac580bb8f1530cefcdcbb0684af4a64fd66f05640e6532dcbb70dbfd93841e868de83252e729b7a9aef4c995bddc6b1ef6574c69f42ca90852abb4f0ec0f4ee706e8b31519c90d99b681a1b8c41258e71545e89d2a145a4d5b49458339dd6c2a353f317dfd49608303430c36a2d61fe1a40c56d35083cc8df72b0b43f24fd10207f6ab45bd77c91b6fd55d4dbcbb3e296ac1b8146f9c70912d4d8946b04ad26032878f2b6fb86f939df57efaa06abbb7d7d3425e1ffe32c56d42e35741c83e641007446026a2343826af4a10b04650b50f5f061ed1cb9ebb69cdc798f20f9218cc1a50bb60c57267a2c4e7ccc5cfc7a58998a623837258ae4df8339fcd795474843fac7864c4c9354c31930f7ac0729c11cdf8c7da618c9607068d11960034ced18d299fad662a2659947b8c72c4ae0a10d0a8381b33e27cd8af339ed472929351f8282597ea7dfb42135c4353d3e207552cfccb891f3b5ff0ad3b7501cdfd4af9000dc351063ab81e938ea232fb516e2f4b4d729e98ae3588022dd34f596ff28097e0a04fa952f5a5cea40a568c492ca582a1cab4d0e5a56b60e2f24d6fce464529cf04256939dfaa447470eec92be6d80db17c1a032cffb9f09f54f654515595cbd7fb3a46589aa0ae16f9ae47fdd795909e8e83b8f8da748e1d356563d0c4f8dd0e7613a911940ef286db3b602bb7d64cd04148ea6256c4a8241accc26c5cc5d4bba6bdac73afdb035ec521d6032b627cccb63c7b5fe982274d0ce24ca40f45f5eb71cdfe4f74beff41bb75302cc263eb71bdd2a681b4f409d08549dcae4e6494214840acb630aff61e0ba2355d9ffb136dbaf5a6d640d46ca81261b5e89f71b71b7408817a72916dca60dbfd13a09419d4b950ba479025d804382b9635a4b40abd276054e724eb38db6c5451c91aae03cc1c6dcbf6f4cc7c6af11e29f49cde5d44e649473ba7b3e6399ed1fe2673ac908404a767e33f4c1ee043e3969b33474224762ede44f59efab8f2a2a372ca4507c4eb6b5c2b75c3af377bcf52e568d2881c19de15d656c4dd3e357def1aa86c7ef80964c79e580db66a16393405a7d2198e7ab46c58f9f38267bb84d19beae115974ee6ec71295e44f6e672d45f3ccd9a2f2ad8b7398c60d29bf43eb61052c3a67c35e97cd9348b9fb4d1bb021940950dbc8c62dad30b946b66f099e678c4214d052070b0613fa1931cb03b730c2c48f65a156999f6f11c9c15ea8cdc6fc56fdd61ee397af37674ea71d29dbdc793fa605bcdcdcf084b9ef99a88734e2d0cc0b0ed716b398203a4590521db34c8bd2d9edbf038ee8e6b9974bd290b797c4082e70f161d383452b84ec0f714cde5b7b436c36dfc4ee04e9ec9ca8b45bb50110570ce6527d2e857ceab421e4957b7dc6dbc665281d01efe3f39349b2b1f48960df5106f0eb74ab814795352ce28ad30dc8a233a12871c9ff6677a672f7a2af683daf4f2cde368bc891414de4d713348344d174ee7a471a51c3030fc269180f0635f25368e5e9db2fa9fd8f044f523c16c2d07c611449c07e22019db0f3a216a8dfd87f133801cc274d0491198a3d2f97633b76b57dfb1af2dc5a2187f4b5e91337983d33a476d16f485814c7d2546f1440f3769dc615b4e1600457731d1dd6b7b93cb5d31e42a5941833c4e7a29740a5f1ed453c8478076fceaeed181823135b5f9ee2b4bc2eb35970d55081cd2e437bc00ead6b60917129262d54d93589d8c91079904654002439264e00057ee25710a8c24eba7352f18138c7ff341ab7847b6d6eafb0b6e15ca6346f6f988a67135b30c82e2327491da275fd5e275ad59b1e6e8cbb4e12794714710f5da291222e17a60516b2e40b703790dcdf9eb75d69ceeaabe000771d790cb0da245bddfdae65f4a7a2b5ba17fde77275ed0bf2b748c6ccd756ca1eeecf6a47f01f7b0cb35dc913889ab1a5ba3304459b1e9c6199ac144775ab1ab92cf76e5ad6852c1e0637502e2b42bd531b1d3036b220d7c71a729521efe22766bfe89c5d721f97ccc2204cb819ded8b228610515e49b4747fc1f5a0423965e132ca0e5316f604ea87421f461add7ddf543aef4e1698c2fd7821d3352dd7b58bbf172438718504b25e0f5b1342e618895fc4ee17313f16891c276fa39992e85365ed79384f6797a9cf18cb9f9eb3f25cc2b7a7f56a31d067c825be4d397f0b996daf183f9bad8994dd4d33582e4c4b6c50e4f213d245b27702eda07806bbdf873f9ed0126b639dc6faf457505a5437c45a4112cd50feb8eb9a47584c50d13156b352e0682a5431f920a83a263aeaa85fa33cb5e58253800caa7a0ef47a3c087bb70438b25f6cc148acc475db12e6b129330ad05e80b990b27a0929ca60fb97025ee98dad9c9dc018616883e5a4f6eb8088953544722b3185b525916740fe46edb8c2d20e192c4943220691889a1e70c4172cc6240ab8e6ac5330c093ee71462f728a61c9c40a2ca41107f8a4780d677ab0401ba26f726cf26a5cba5b28479de6a282c8cccb9c46dd9e1d378c13d1c83d2c6977cb8280adb30a244bcf12a3a5495377035eafe5c3424964de838d12d5cc16f2c02ceb3ea940bef8e3bc4530ed8973dfddbae1a0727916dd8ff7bc6dbaa962a3eab9dd6da836de6c2621f69ef9d22451b3df68a8f148a1fec13e0b29a1621d119432347806325b2955bff41764ef40d55c2ab038945b5de3fcbf9207401d655d018aa535ffa73e3983d170e26584d21b22c08241b1fa9ba13e80707666a41c17096300009869e112bd66b7a613ffcf2b79b169742a78978d93d748c135f027a670a54b005ea075f0d6274519c600f96bd559a98b23a1a7ccc4af25752488271a57e0c031956335f4f23a6e03e1d61930cec035b3a58d8a8443a35dcc3286c020e6ec009a8cb084ec0ba53423ca05d877f2cdaab78183af4cd0d4e32afe44256104c37a4c48ff659fb29609714f64c4c87a1194a16f7d5ab86dba4a1fca76393d9323af495411ec9153d5d25de9a096c82bfcc8648d9cc8d636c02aaff5f157f93e0ef1c24d6fed8fc3cb1ea1569c55cbe0f5e97005cc2fd1962e8ca56f1dad474bfaaa5adffd8a86de287a65c8be753f488eeca8f762e54e877be36a79722bb8c02984e9ca11c177c034ab4c277924b44be6d1f3b19e2c8b8f8a5ccc0832aa58b770789919d5654fbe7f823403da42253ac0ea5b31421135b721b25867934d4b97c0e4ed5bb34a2af422f04db947fbede47ce562af15ec6f7a016830c75f2be25865dcb0dc0815b0c24323181da6619e21b9932247d8b45b6d802c0d3a6ccc8edd0c5489f73fb4c4115ebf718db6a4a0b2991607fc46d2a3a8005c515ecc1901ee354a6d766df7e836d8df6463bb5966213d035a06f640708e534bb34f9c833cd4d123d2b160a390523ab533b64b71057eb335410feed19a886160cc99c01969d3bf7185a719167bf862b868811967858cb6da201ab01660fad4d544d0dae9e6f2cbe69f980fb2702b94d00175550777ea4c5033448e75a58d9032055300497d19ac12aebbe0a4f8ee6f4c0291d9796faa35d626f40856ff0d7a61d0fdec2a353a0278f333eb94bfcc9d8e3db9f3c1284bb56741f57ebcf1966374f3a03efbe7a3cfd0c19c7ae5abcf46aaf644fc58c7ccfc9d65c8eb7799ccac284cef725dc101c495096dc3b37681c4dbcdbf2f80631e3970bc4be3a962e7f9b29e79c65658c8fe7a5cda197c390e4a1a2e75c552ff01d65ba1d16cb777aece20eb1352a2f6ca247ba20dfbe3423f45d8102c802c812a816310c3ccc248b5573f2202845845087562ac92fc2152c271c2eb324965085f1bb6421cdbbac8524e43ef25f412aca3ed88a76c9855d08bb8f2692c8c80d1e0295e16ece7a5ed1ff086e1006f75bf41a1aded8132fe3537f21f1323ff39e69f84e4c29b815ca8ef6cf8599ce6300638e1c343bbcd33722d1fc34c7ad4e61fc23b1dea84a8f159f1e14152dfd4c9ad657c4d20a67b08f8fe1d034209e5766fefd51b72cce21e29b4b5ec7a39b6f155745dd2cf7850df5f84ded35d8fd709e17537ec607e389d8fa0e3a3165cb7b29b5b9ae561e801fdc816bc6aade6c896e8eb876d5fc81656eb441236bad44439f5dddbdb8bd9ecc7b01c8c498235c498809f694351681a45db0dc45143d1a89e4802b07d8513743ef62f1bca1833b052fc4a39782ca4f02bb2e94ce7a24dbc869dc7859540b50a65932537811941e52bbe14d3b04a2b6cb2f93c7665828326b0408217fde7fd7e2e0871d72e4b590481c77b9045dbcbe24c98ec063dc63eef70490d93f9060fc74dd91942376465ade18467b2d21da04a743417833d36120ba6731b04df79ca4684c01f21db3568cede4d0096e6d9f51e18a08ca7b57a40a835dc0beb91943120106ac495a87c97974e924c280dd1b991dca3d416e4f1c630489b2fa5c1e179c86c18b75af9c433aaf3619bf24c3589abbdb951c3fb36ae9df86ca1abfd7a67516c098c09478747dd3c343adc2bf64de293bd9c867dc8dcdec0e826598dfe135be02220c6684a598f634859bef532e5de5cdee7be1937a961bd7feed22949bd4d4223234eb5d7dd7cd970abe6c3a5d61f06552605a8975bc4e9908fb2787c8b9777e6b0f0c379e402b6d451900a2a0736e3f2f1edc9984d76ef6d0fb0dd2160e0519f3df505a4603fd8af3120560b5b8b2d6b5574750d3535b1b94433492e110fb4580cc4a87880c2327f8ea553c1f7337b05c5d0a1f26efee092c272fdab8fc295864ed5b94b9584660d3b63c776f7b408201c5a7d828da6e4cab6d1d65180b4de0a0424b21a6fdb8ba402f1ae7f3b25c0da1a8f3984883c53777c91ebd7873dbd9065d25995f9dc79405d28229553a5c571db8e1e6d6be2afcd4301e92c594b95df34b06efe31eab3e30d7b658a2d81150ed621ca21ed354176e1f32ac1e45736bb3e8090a97a33ac2d83192f36493b390023a37469df1c195e77ea5cc4e49de4691fdb8c22c06f6ba8d7600938742f1502b6b4d63d232ab936c176652eb0e48e4e65438ecd523684a0e2f77928be3cc7c3d21c3fb45a5ac4868c4fdd13f1d1cbafe37703981e3fe0ff2607b6554a8697172d8772993064dfe4be882df724733d91f1643dc02c9e895d4a69263ab69dd09de3c937e5886b3a3d63ecccc6bb059342620c82504b9f7d39fa860a81a3d0a483784435e45304739930fdc7b3894e186350a4d75d25c1b3c815310de37f40d28d64ad68baa8e2a90bb1983e720031e3e0e2ac9746242eaf45058b7a675b2638931eba3aabeb3e475ea05836ecd00b5e3dcfc48a913ca8ff21876e7d26c5805aac1427afc99a8901d75f91bd4098593a8008469a660354b484c706ca89b2b273ae81a037a8f5b749a829f9fcece869aecfb5e7256d8ad3ff832f581db349baf3b12ecd419b84ad19f58225e9e2fb1b0b044715de97451d94f70ed31fa9d4ab2b4a38487ca4224073386590a4a2af3708f9eee2b3a13470939dc86f00e58e2e963f3b7d0f9838bac9d82e8be4c91bf70932ff3d928afb8b7a158c806cbff0aa15935abb65873b12f21b00e55eda324b5de49c01f6fd0b066f3fd966baca540fe62dc9ea6cdc7a7b94f10b2837d7b36860e70f6586a7fcfeb6e13f19b30bda7edc9d262add16e9d8a7ae23ee6204c10dfa5b4a2a4e13bb5a79af8e304573c831e9bd0cdfe78cb68316896a963506a16011e334e0cf258a8304dffce2e0da0b366d31c2a4ba9470833336c8f69c39248ace0ba18663a6ba57b62a580ff72a5eb5c24d7a0c34e68ccab89f318bee5a6e7d78a632912780b78de78fe3447fe9df65527d301042640a4deecc9dcaa231b9a5da55c32c6d04962912d19f745d70cfcb999dbf1851485ec2008a6e336acee33ae5fe3768aa8ffe947bebbb44a7c2de9722a17c1cad6c2482b1e2939ecc11b17b325a31decc4b1e50b5db78a8ba19ec9a2f390731650e302b22c92f8235e3bc51aad209d5c92a266e5fc74832a426f03f11c7f995981b225d478aed736d48a2c56255ec4953719a8d3f37d6ccc81ab49e004551f7e6b0e6e4360c6c8a6a6143da8207d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
