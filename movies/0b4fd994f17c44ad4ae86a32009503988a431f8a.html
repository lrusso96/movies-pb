<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ca2857c1c278a8a992417df78bbdb6b325ce4877baccd629163f245d8fbf50bbf7dac96552644bb679e3b3a9582bc2a2606dd9eaef5c4b91cb120eb474896341f6564d630c802d3e1a5d93108ab3e3f0dff06dcfd674d4f74506362b141f24cc261f3faef00c146d05a8c10ca23e19df1a52ee10c4a5e11b2f51c3d922b67fb97ce41d68985114c4b48c93f2d6ebedcdf16b35885fc3ad0f782a1951cd53b0c1c79e9f347a9145f59701321d38047ef859cab996227ce851ed71f4730c0d1dc2eb93cff2f5fbf430e1a5480ce39e1f362ce9ca794f743f0ff49864a63b775f96c83f6cbc8ed52ca52d8e9b6190da65735d653d553e525c7a6720b2eb84dc902f7534bb8b10b5d5543d4479977b735b19b5b9f6588786cb56856ca33abb15a5360258ab007650d562dc21cf2f8bfdcd915b49b10f3e2fe327a9b850aaafe169e99c1350b9f97e7785fe80c067cd1ad56cca3bba391a75b8c115f718780533e07ce32d347e56209aafdfe00607eab0a2c7dbcf27ee1028e281b2c31e50567bb8d0dba85db7941a729cca3b8c0b6411f5c39ede14ae1d95b0fb14ac8b50fd3ccc72607ea2bc7b67eefa901eff5a647dbc32e13aa9e54694ba17bd0ff76315e339e09d98faa9c46cde3a39e7c0e6ddabe78b3f769e87c8800cbe49126b726e7a039d3b59762f151501fa4cc26db219e5c7f01a8bbf2e54ca3543de0e31832fcb38003fb50d0c76c0d3fa0ce657d90a7aea11413703d8a29ca36eaf64bcb5486da2758aba722d8bb09c527e8773698d56540489928efe3a7eb3572eefe8643ae83e5a22656cf1881a7d1c900e287bbfa6f916e3e887b67d5e75c558d47cbeab1d417e6ef676c97d282b5a0b1dd4583276b26d1becb49d425eac7074d2f1b2c0fa16c2ee56bdb3b5c05ff9771f03b449fb1dc5811cddf13718fa15bfda3f4d63e1059a72657bd94084bf73cb0bd2586370d59cf5cdd00ad0e98618b9d015f1837cac5bd1303103309169e5906576dfc31d38e3089487281bee862761c9f2deb4c6ebd51555f40783f99576baffd1163dc669124e517ecf466637f98d4f3fb8adf8191255ebab7abc4a23c9423af61db50f521456115ce9aac23b9ba4d379aecd487806f24571e7799afdd3059a047ae1ebbe8ae8c0988514d86200974b1ecc2a2ab9c654e81fed2737f01cd010327c11df484441685ddd7d8d68fc49420817e245c606c285204a6f645dc1124f31697effc097a0ddfa51556e0ee98a777b4348072a74020cfbbb226a28aac28fa718262b26e3715257a23b4d7a738b8891b0bf1dc565aa2b2ff352be8b34b9ab9dc9e305bc3c11929fda52d50913f53741d1a17c2e86e33e45cbbe5ab5c42f9aa1cd6bbf3761a05dcb9d5bccd022497c555f382fa07fa93870a528861559b6dfd1f6c30b8eca21e3f44c22ccd6409acaf9b4659087769a494c11b4ba492fe6bc51496ff7edb664e508e5e789b196212f24f7ab855ba598c474e10c0b929a55e9acad1b5afb8c231049018e292a0840410ab488dc8f33f39c4bda77a2633fe8627f9683147f77542be98b314f02e94e667e2103101b44751508a5122b3b22a31feae4cff8b7c275e27d766d5c10370bc709533706577eb3eb072f1fb825872a7227ed1e1a3b2bdb717d944656fc3fdc3b5ca7c56866e8c0037d5d6aaa1617a9af767694b9f19c8e8e7894641cd082cca3837e2cd836677894816ae88f1efde939ce527b38e2ed3bafa0e68c64596ca7e25241eb3642334c69bacc15f790c37f1cd4702678d03e98d81282ded5ecdc73cb56ca48e74ebd5a9d5522c2d39948ec0989fbd4fbd349dd89806b41aad8baaca3be4a6b15e2c0700a68e30e48a52d5775e36d8d5eebf6c5dd60f9171c8aea18dc47065ce9e064a53067967ec2c93ac0fb11e0d13ca160d644f5b7f0a8236326a57a85d912bdc905e4a11ac3163704d4745e537322c373b2af59ca8d6cb1344dd26033eee359233fa459cba4d6851ca95ebe8dd7e9957f9be82fe9c362aa5fbae4477032ee43dd1b41bcc1e427e12767b65bc4fefce72c709c4bb56cf3d8cdc73000fdca60479c1bd08278989f476fb357578e561d94bccb1e548cd5eb469667f6352b493ed519968e4f8b824887802a7a5da8c3427aeefb537ed161a3ffd26eb48082723ed2bae82ad1cc1d186fec25b84b182c5417e9f53abd298c12b42c462c50781b942d7c4b68dd0aa80e76b35f9e1e15e05f9331146dd2d69c5311008110ff1898f4bf094aab01ac218ea3ca41742f48efea67c0b752e5c87ad955ebc74fa1cc4ffe028657bbbfe89a9f594df80e12281411387812b2a2e9774cfc989b71b335cc75f69b5f411dc5a01cc53268cbe211f5887a6d40fb44ba633895e6b3dd1e96a9eb0f7fe9f6510ff91b622c3e7fe2eec8e6c01402059beceea90fb9c1d8825cc29843ff9fd08457d4cda1bf716d6b288fc88e43064cf1c010cb5862d37bde375b0814ac181ce4fc7ca99e2d1aca3fe247b9d8626061558ee9980a7800c3991fd5a9e546a41d37baacd2490733b70a6106386e512f4c870a47251462ba59b60f05bdfd5be46bb4533ef3cf0a6fadcaf1e4ec7d4b3ed88c08a0509b05807f254e07b214111c8840ed838df51945514b2de58f008519477cca6bdd477fd3f22d79ed254543dc05990bc446bbcf541bc43f1c02ee9ead8c2cc859896e3cf5b96cc0e91072e7c96f8b81e094e02811cee2949537d036acad0533a9c418bb4fd2759aa149095a85291ce87fe3b42b3828648c091e996f2e4a155971a7b555d2ddc8c91f284df7bd2ae033acfdd7a927bf0c81f440364c5f898f9357946471d32432d6dab27bae5658d8987e8a305056b15e33d3249821bde555e5facd4a5cd5269f4035124dfdc93ca32aadd5b745d2327a6a0862f8956f623af7477e8967a8a56965f29a4398639e4d29dca6de2107cbc82d1ddb57e9cc5bd3654f110a5b95217d373d6b5492c9f69cd45ed3afb4895fd18754b7f140466304e0e979298fe916be89776447bfa977045b39640d40bbde77a40e3714171a9481f2f7e203d37b8c1974c12e002fba98610d7bb76053c104d22e7da383d04c6689553717483149840fe2cb4d1d9837348e8c329716eca3538bc92cacbd7f3e19061481ffa9fe5ba1cddff9c6fe04eae294408e4a393a63c778168e8f1bd26811bf93ac06e217a937655b85d7967acc6cdae6fe8aebf1afbaa6b9d388f9a4bc6c18a4a114e8e7ecfee1f6840b8052522a1210c0cacf9b4873666f54785dfdd10318a94a21b61dabb7e83b81004a74d83cf9826b2b1b3e62f158792b25bee61368e61d6d70f6974aa877382d6b3d7844e94b5542c4540baac338d5cbbbc551262c6c7f57f0c6dba104a5987a26402189ce80e155f39202f87c710d7a578c2f193fe5f0f90a62619292a364128ceaf89ca2e0b7d9e2eb78ef7589863d2db6a68cafa1dcb90b9091a2786bcc6a6c98ee2df85355c7619b9fd2686e0626abe3c4350d9eadeb2a5e64b5c25121e0f67700dbe28b480347e41ff630f3bbfb8f4e40a7fd28539557fa4a7712f9182d329294620c0a9e5e8dd8bb55be07ea053333e8a34be17d7c8d6ca7dd8b7ba0b0fa85b0672160c2b709161f19f8adef4c62fd1be05de4e40b26c264c7780ed5e6e734930a0dfd3e33f9c8e94756ff7f920ef48099aa943c043eba5f622616867d1db4de2d624e504ce33b3db3d4f0a0d921b8520afa2834c0ce4a23ff2c43c05df7ec754277c457e11805072fa6fee6f0b648371067a87001d1a936a04686956242d53344408a7343c0cbe46f96a04277e4595956650bb04af069d1c835e1cc54302bb69992c60271b410d88a99e2353b2dcb532a46ff9f024d576333972d58cf99a6ad0d2c893f5611e905daf94845ff750670e967a7f75b3cc924e51c7d137554ad3777fdd8b3035a8da5252a7e7a12e4c84ddc02b06990f6e7e4958197d56bba5f9e0583b51e46b31fef3c74c3b993df216d70e622260949ce1e662f6bc5eccba15cfb0e962857761e957834cbe505d07c684f517108e4b1a879ba1d4725a8fd9cc025f401516a9b8e7d1b7817fe4591fd8ffe9f7c3fde7dc5a4384cdb6cf7c5b2d3c31a0f987baef4bc9337a2f574308bfc257fc30c8b34317801dce967414b5d439b262baa4bea344bd8a5cf0843c17e0f8914ad5c0edb1694c71e1e44506f04c2f97242e223f72274681241ef13b6a9bd160afeaa5757489fe01b9efb78c6e895c052659b1588e13dc5e956b21ec00205940a397bff3cad3f2f237667603f5ba1b0cbb26b7083d755098ca8b6908d267575906121d062ee3fc17518421842b96fbb35d7b277fa5155bc5806624e08f58a5d54689305e869e9a6f153a8b1b7236063d07418cba403fb6b3ebe9f26d70ab20dc3bd3f3eb5f07f2bea4e97e466c0164ad2d60476f1608a5b3e65ae5ca10dd481fad40fd9bf2b782a9ecde5f6e675193526aba921c68cd9175b4e0384b6cf33f24a17b72409a836c376d158bd984313c56c23e8c542855a7ba74437572baa53973d59c5ab341169e7f0b33e1834a900110a470e3a2aee56304dbfa5c9d9c6268fc94cd31386dd05ccdb4b2ffd517f69493735a1fa3c81e9f50baeb1a2503a162d91a3984f7900d1fb92f521666ee32d93fb6c4ba4c12c7b179a6923dea2714dbd9f42d94618bef912a0a5d899b8ecc48b3a977c78cd4cad6ebd37a7ef581798ddfea569c4be918ad3925ac6fb709ae3cb3c2fda9e83c0f4b79b5471de1639a0acfeaffaf3ea42f37efa4b483571e326666bfd8966fe87ee551e6f0e637edbd33a000b2b68d41a306cdcf3613ef8c2e0de5bf6b7b99787bf8ae8a08d1499fede411875844740a5c493668f41a1679ae152ec41dde9551673dbb8019812b6bf02855272d02117e3aca5d148917c592a1cc448c4da611fbf3054c12176f2ba7f303f3bb97e20f58a8401d245586b5b127dfd6383c073c49b33a76c332c4d5de5d02db515ca440a50b55acc34d4ad6d1b5f9fb537d05ab8ee00ce08b24d34592dfae1c80837c838bc279192983afa9dad60711c5518988fc7cf59b6b050de13cf3ce94c69a6aa6e17da5daa55ecbd23890a9cab6caaa3feb5eac987e03e9bf865259ada486f810c38babf87e427f9e1ee2c8913994ea2f0f7d9ad1dd0e7711bf4114cff239fcb9c9d7f8c942c85d2a3b61fb10db5c0b9b9bc70b830a674e5453fa9a18175c6c51c303d38887a9c0750695724e49126dbdc2f00025666e1175dfa205e222d1e890b853d3d61ee33041dba179a59cae4423a2635bacac9dda9a96030ad02a14463cb3f6af47c8d7c38d8a54bdc53e5b11486e64d7177b33c61a29fb553a84d41d75fdb6e46597f1ed27756bb5a1a2057569793036d93bdab4a6a93f83213afb5d6fed1c37e9a3f0e61afb657de386f7aead5484f053da2e90d1bb8fd75c28e6694db6521eaef3595103ae1d2ebab69bc7b953c098df76dfce90154ad66b49eac2e33af4f55f0e4ba4c41ce0e391491b80e355878e63a554c8c778f834a0e3cf35f1c3c45a38331c4b919d4b3d253f6db3b3c37521e7520ebb08d8ad777845522010acbf5b9d20f3ea1e8a48879321f2111233c7e86b846a4b15ad3e2aabfa0fddc46d3eb1780253072ad55dd81fcdc5422b9d530b9c38f572e8d43a231912751f9ec13cecce82412ddf298b660e596217231dbb067d280502f465daf40885d1d6c605b6911125817d83f3e82449e3c191d9eaea7ea9cc9dde006d93266e163a97bb0a8e5f5dd145c06a59f398a34ccbb3d0273fcd10efa30fa1b1728c3e4e312b7c7a3ae094362ab22e72eeb6f7bf0eb7786b2d3bd26776f06472cfb2fda9d037ada97b03d9e334a403b81968b0f632cccae5d0b107a91dcf4cb26116e157de7cec2950abc9e03b00e182f1a600961f46e59edbbe4abe588a7e8a70ab557f5d2c68226a03d0b1ad0031be28dd005c8b5a314ca6a86b6d159c917c048b4019dc8f33dce06b1defb4a4f9b7e987b26979206174b87062fe6f7ba1022583965941048c20e8876e06a4c40e550567db315badeb4b6f803a2e06aaa7ada00bd30157ef725076e2724c33b0530c162c79b8f64f3916ed01e7fbe808ea2d9ab29f440353df9fb9bf486b9a10393c77e0cb1a280dbcfd4cdbe1081f51b95d35f6b0f5e385e8dd28bf21bcbfd14e4ed97e1156dd4606f29c9bc8f872cd67f43f3839b0e1c23c2de511c502e2b83f3f16d78aea0d9194cba5a70fa6e42b3b4113bebe70e81ad11ebcd96f3a04fc268b9f543c9e31c2f8b40286db8bf0254569e465250498eeb47c0f3afc2cbca652d08b722a99bc4df88b60f1d723ef6d7d224fa7a684ace4c9f5aeb68f4440ea8d3d46ce7ed95619509e4d4a394656b71c1f4d4da0e94bf5cc325ef29e3bf78aee8688d09011679915550aa161f366ed520c339649634616bc7c78c5c766fdc5c742631525163ad91d907e10e3465602ea26eadfc4e9b136c52b120e5012fd962c91be546992296ae16c16e3c0b3125dcf9704aaaf65a81cef3d37106936de3cef0fc19d5be9e592a551618c7e87872bf83b05549e96f31c897c7357ee518b90b35e5b26f0ff19a106272e4d59aa05674d53bbfe9085c7ef25f874589ba4c0780a603f1311fdef292b4bdc0265e22c304f6aaec249e42d09f6770a0de0bc4933f2d4942201792c87ec20c946789a3d71fedb347d18638fc1fe2da21bd73e55153099c8e3095d1f00b52ffa36e1218efb6fc5f4c4223d973ad614c818922433c952ab9214883d56745f12258da8ad38e8bd31eee291fb17a11a50a58d1ce951e1a228531a5dc8118c4ff374a13041ecde57f68f2297e27aad4e3de3cedd38ad1d5d77610a5d0319faa2246fe7b9972e0670dedb5ad71af845823dfef60e7f2ce7c507dab8c68bcb4bf39f4d8a10b4d22de3f6acf72d7c9941e5b82b7e57f218be09f88aeb9dc88289970da5f7602df53811326358681590e5495e9eadc21966880ae63fc37ed42a3c78fcc0c01915d6f829158eea84d3533424f43e8b3d48bda6277d71243450f89a673bdc525e2c9cdad7def24002c74cad84f26e6294c47e152ecd7e726ed1f4306a07e4e4cf524eb9b9ef50b9c91d5616f5f585486d116d0d0bc2c9c0724bdbc10f7322b11728413fe5c46046d9e74badb336763144516d284f0f90706618ef0284b522ab9242734c4b3f369a9b4308eaaa382cb65e462794a27ed7be0bfb3ffcbb99f56a1937772fba1c18b8e93f606d88d1f8e4557ae08eee105490a7948ef698345a06dcfa7c69428140c641b2f7c15ba98d25886f78cfe547938d2998a18d64b0a339a99e824e6e44d7ed92893f5f9674eb142ef6382fd5bc6d2f929df7edafdf7d7104a9990257fd19b4f02195817ba579275ce5233ba10864666423f4941f7b1051a861c07de2eebc0e221dc0534cae500023a3fc4072a0a7e71414e255c782c8d1e4d7749c43cf92bf4490a57a14a8d4a34118c5e45e7d7bcf61dfdd5eecddcc78179d4996cde7a07e6a958283d1c13c04b926c984bae0e9caeed25422778b8788f2974ecf34ab34911bbef4e9513359c95c1948a5dc335c3ab1afbbdd2cc4e0acee8925963fd00639eb1f177fb01cd6373201dd0f6a4a68560fc30a14350627a3be2878fc2096d510e17108f6eda48cd784f4caf41e3f614c45909b02e5c7052980ae4344fc652644b815e763d2274ff2d0f41e820cde52e0433c5f156ded01704c1a8dcf34e6a56c26b185161648400d157459bc9d9d60e9c1ad2c4ab9d7b196dc991e29f084d83ec4a620dbc1429314c4e3241fc1a73110206a89be3009605bad328fbc3cb932287d5dd51ef1fccf41223f67fd66f3318187038730c8d9b7bcee858b9ce1b1b6d87237140106052a3a7db70faecc482548d59eed91627094ffc39fe436b51636be7dfdf06fd74dd169f9d573b66ae0b566d8a8d1e54ed1c6f1f85590733696e66422ad5bf1870de7b0fd6a38c6b2e66706a03e057a098ff968cf1205a5f5a8dae1bcc265cc23dce74603414e5b25533ca32920bdd5ccf65ad65ad931b92ed980d3199f051173b60437f49b16e9c1532cacf7b258aed1d8733a3484f12eaf8487ebff9ed7db0e3d0f6c3221a3f262da7d94ecac266ef16d809ce475be737da8e28e3dec1d944aa43f3fd3a93973ba9bd13e89e731f974bfa21cf6a66dbf6cda311893ce96701540bc5956a040870527d93f8692d23f1e16d8f95bfc55fee75a371f9f27fa79ccab527545ad30b2fa0214794a8a375820d43b09412cd923397fe0dccb56aab91aba9d3928b2cff73768e3f5cc22e80b19fa5b163ee115d8fcb4aaddac1c2752fd91fa52eae8eba99181ee613fe7f22e904dd18cef69d6b5e14f0d9923caee79ff9e80dd75672f4af6f234127267c7167c71c47ab6150f4de3577714873166f3de4c9288c73afa6f5d46b96b3ea312e987546cdd4a7531f03fc81bdcbfa73f14a8c730862155822e986a8eb683b07af2020160689c55357e2c29a90833864ba565613d2b54189872cc8635e81ffad5e7aa90315e39bca819317072a55909f75bfe7f10e76889be8326f56af47bf05954a892f082bf7335597f99687c997abe3e19f659561f2e77ee14baa17bcbd46ac755204946710b1c9593b85971c6a1e3ba9ab7933b940c7cd900f9398e42801282c35aa01ac857f519725bfbaef6a3670fabe35e15bff1665567960668bddf59e47773af398d5e64c8c2f3794165f7753319c199044088abac57015fc5a44212911ad24c8a8c436a8c17b48aee46fdd97b011c46f8f9857f3f1cf066832452e12a617414539ef4d9f5172f6f171682df49b7b1d996b0fed48e61982119b129d109a30274e07e6f6d9a81292a6f5ec57fbb1018c404d8fa411923c63ee53d2d79359372c0d05b3f56c74d662d59eb4279b9be438e5c2d87a2e45d45cf743a7bc5af0f8f7afa20febe19c3d3e425a57af35143113348b1129b69b63fd096dacb68b8ae6d5adead0cc00b301f3b9064a65eb8f5819839fc04baeb0e0bb6ac761548cd195542406f7b987173e79de302cfed46714193945661b04d2d0b7df7d8c4ebc0d326a994e2ff9a91e2d0606febf6f2fd1b4d5e056a3d88589bd30093e0e66fddd77fdf0fb785e180e7137d4a151fa58e69d9db9d4fc566de5c3c26d4a4784abd2986b42a9746e2032f57ad52307c5ea88634c210770bcb5782b1e98aff737ca684d4001b63e70587824212a339f7674f4863bf4528533efe5f40dd7390e8873b8c949bf3ebef7d5df9de2c65f96da4501cb53de9179d31b1272d61bc61bb527e0e362292716cec93e7a36afe71b10beaeaccf4afff7af77cd878bba3f2cea23be8bf273967f19192014958505606d88239ce2e9419de32004d20ba22720f692ade64f6f45833aed196696639c7e2399604bc5463da012ec48a660cc66dc1b880d58ffd912b4aa3a964ed738299a6bf68004c466349b2586d9f5c79850ee1ee56b53b2f6e81609d9691c37e0dd9860215d61faf864c6f70d2662b614111122ebf43e2604ea13c0e8f2b201c96da5c4346f8e32d75837c9c1b511886d265fb261c249500be3713047739f2801e72a9ba9f203720a88b1c9f9ed3a345c4bd980d70bca0d1004a1e1130f53ae2fd3ccdb0ed282c8685e43934580f68e97aa1ef1c2e4703a80ff536b5330bbcbadeb0a06da2d2fea2d22ffbb45febe9dd91434f10fb52b43960e414a6fa8bf775611dcac0b9fccee0752ab4d26d5c59169524aac719ba5272dcf000087b7e56521f42930fcbc937cd955a5445104cb9684cc2fe1437403cb0d5be2f950e9ae2ee34ed985caf28bf1ab91a8f738dc5af8af9333ee86e5bbca9ddfde370f6203b49d9e4cffd01e0a18c120761c4c727ba3656ffb9c4ef383d659a7104bc84e8e937156abf9a0f7149d3c7a0d8f2697de1563de586ff9991ebeca4b2ff929d7ca660c78c18d51a3e734539c4752ddc8d99548ffda5173e9912ae9fd35a9cbd39acbfe7d48791c9ba2ebaa2ad7aabbece2eb282fe4abfbed228099e7f0c1689a9f9cd079f7d208087dc621911c4d87943e47c517e28a0c39be44d935dc44fef0289eccc0615f32e1e25a31ed5da31d013c49c8cd4bb5d16613aeaa744349ef0743711bd1d16488d36763de0a6f582225486e0ccee9cc94f7891d5941d3774a3b00af9f8085b675ace41f2977f3b8a2a48b2685e95c4a8806ff614d1ef1fe0fbec614e656bd28b745cc8cc3e623d568b77a3f1040bd8550b4d12863dda52c8e6da022431cd6a189611e123b4cbaa517b3203bae68de8c97e5a792b0b58f19236a4c0958697c4cc5a903df041f664782c3a43eb4e74508086d49d98052de3de00947a50af8ac71e64754e55b4fbd13bdfff9c5d656c9919ab25d2cfa0f6f028a9cdba4bea8f423c0057361df3368a7c7ef08d233b772298c197efc4ec327d19813dfd615902a42c6c54b4d55d26da849bc8a232b6441374b1fa9ac73360aebc1095ff0a9e68eab92386f3a89fa174f3bc4147f35f2f6c29dc2098331067e92adf15508e59d901604a44e5ca63805b1b20f1e78e59d18de0e4bd910283416662a1f7e7ec220fde96e23cfa1137ab5243aa6b01062718215546bee796d405d17085b6d8b0e2eed84f1c44b890000e6ab1235adea6f1f200ce229acddc81653e25102c7d049aa361608d49fc6ea47b6bd20a5b336c1ecba58de1d0ceadaab5d0d8ea43fd7f0c77b97eb8c8d04d73cf6e638718aa83f87b22aadadf699c58ac289d931806c7c4e5bd86892ca4444aa44bb455232aa349557be464bfaef262f14bccbfeea27505b92b3fd4b2594fd13e5960890d9d60555d2f0e4d1991c9e432e58316f7b7ee16d4dd41b57edbf4f394c93d961c2cb1a5cbc2c917ff5965f7a923404527e83bd606aefc286d2b19710df7867bbd4b62bf0e9337b57b4ce911ec988085a1e5b3d9c81726434cebe1d8c1902f71739a6590b72b7b93a177dbcdcba9e1454becb0c4488aefb63cc1174d3184d48aba7780abc9b58932300284ce093939a8690991b372777f182fb7fec63bcfa3d87156f74db49ff7fe6b4482614f55d297eeabf885141d9c87b2795fa2b3b68424a8395e4af1b2272a72d4ef4c442c3a52e3055f2241f2fe75bfc8bd5706cd541fe46233236dbe3841bc2453fe78ec2c709e84cca2bb9553f47f222ab6eae94a3b0a2b21f4d5efa8e92b2de7fe73a3ba771ecfb43a16d04d40dc4bd13c50377d8ce182d30f025a30154e5ed936119ea208b18b5680cf8ef35bb13f01247d232d9db0d7edd42847745b864d20c95c9970fcff67091ed3d1c9bb7fe0925c198ff37ee70b52d1ba7941617f3a9f450820e768d7257b678c2a888e40341f485be9eb97081eedbb9d905892ba972a435ec5db5441489d67eece8ae4423a5722155130e29f35e3d66372008a1cb28c67923828f12359f89bf03638730461eeae1485192a405e709169984cb7106ce3bb3c030c9e29792645b8e8fb42ae8ed62707d977c70c327a4580dd234d918ecdfa45753ac3dc5d98824f313ff9e598dcdfebe4d958666508290173105819835ee45049e0e083a821665098016c9b2de3ae14a4f16c0c78f521f2ca62c436751bacd22aa0382ecc28e4700ececc8b3e91efb531467c72ea450e24afc8b154fcf33d86fd5d926ba3c092441cdb01ee53525f25fb221223f456a529abfa29b5b73973f692ac6504f2bba577cb758021c0a0531e09bf7824049969ffbbcf7d6e815944b77fc1f6e2088bc92ae970efade3f46995a6da7524b84e39860b46cd2df0f1bdc6566d85375224a476bd0d0e0dc7ae0966dbf3b12d14eea88577abdee077a8edfdc27cf963433cca0dc4e08a1df2406b3186cdec38c8eb5f6a6aadd634284a05173ed1a0934c961b07f2bad70d478f71a2a79bcea54f054110934293a70cf65ef108e57160d672b23e4369fa6e08275c33cb13dde6b9a1864f5d728b589509ba3f5ea04656b925292dd88287502997ac616842ee09556413e79d4892d4b068a25d9b01dea3385beb96dc0358f1444014b2f22391579a12375756de366e319deeb8b511fd2cf956885d3519cec3e70e90bd5315fd16f625260d2d7b0ac8043879962f0f53d70984dc66350b0f53e355f87fa6610bb34dae6ac002401269667b10d14891f5609b9a9d7d04a046ead396f3590d09aeabaf758a07fd52ca8b3e7ee5c6aff60d814c920d9a540758944d544f6dcfd18c9023e40cf7eea9cef3ba5f8a4be6693431aa9c3ac52291c19e9eb39e50dadd1d3bd11e2cc9f7e901e5083d30e02821f929451bd5e2aa8b58571ec0fd8326a2505ae1b3bf48075de763b741c468771b2c20e475b73d40e90e51407eba2c9a4d54b1694bad7b339b9d2804e840d813e1db57dcb4d898d055b586dfbc41d8fc36f8835d73c0172310b7956aee1414b9c3bcb504f8eb5bec052673617c0e985f09a1ab84e51947d3aec418e6ded03c857617132486dab417ab6b540888aab7c400dbb747438f1f08403f194fd5893524f97b0ffc25b63ec87069edbf0bacc57a64a15bcc18c1a0b9ce9f3386f967bdb1bcecc1d4865a56d42817b3f0e946a2164fbfcb0e037c7034efe48e8ecb10defb3720190b1930cf6d1c1391f8bf24e47d1da8fb6324e6e1f5e703bcfc489f1a920c69a022602fc41d5847af14cf6d21eeaa307f9eafd272cd427787108d4b875c567f615d30f4b6ee9081dd98a725008f8cf0e8af8e102150032dc40e11a45ff180b0254b88e98166722ac132fe08f9407ef3ae22f45808fe54b675a564daaef29a663a5eeca7dd34dd8eaf0c7c6b3b8e1d9b981fa775c7da46b91eb736acaf45b9af7ea9f5c2d8367628cde04ae37650b9ae7d27d583fadd56484472a847b832b39c683c5baf2a052c15b6a1dc0a6e162f7e0551532","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
