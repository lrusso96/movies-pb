<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"44eb6fad2b97c3e1290e881b60b020bd5eaef55f87ce3da27573cb10c20dd03f8f4f16feb1d4e7435315ee173b29da0831ba72e8401901f1b6940d1cd43212975652378770976aa9cda05a3fa2a233c0494a8a836740684dd659691365a575338869d71c6c17e2cfb4c1520ea4390ec15cd9b79eea344633947d22fb0684e6cb92f16922fd3ac852e30a27d3c9aa6059f0a81402fe9cda777aeed75269ce3193dc43fee4c9a888c913d4623163ecafe4ba4e546f818c78383a28a6e3c2a4097419dc390505a23985162d5a51d3f7376e36f61b254bf82932d6c9f833128e4aafad28c71aaf7e4e685e8b0bcd87186b5d1514eaa2208f2f5a99627d824cd1636811c9de74dd8bb2bfd2fde942bede3ee664924a016e7d41dc2789eeed2954bea52d71ff4e0b33135f99c391666218036d508d65d1624962b00b175197778418fae04d2966a5ac1c0d2bf2ddf9973773b2ba80cbfe31183483bcd4672ad90abf5a319ace73d112edd33785ce1c1ef3897bbd0dd02ffabc22b6cbca4943c0b09072d33b626d00bfd496c38caf91abb081aca5a23136b414a707a7146e129f0cb3877ad74bd92ab002a334f5ff0437e832339d2500adbf2411a167c9863d6a5d1dde2644fb4dc1441ef153d0754530d2e8fa8ed2f7825c925a1b6f284aa70ec44e5d481e48b27bfc189033934597a5f17b40f5682adbb67fbac5a0403f262ff85fa6d92c9caf021b36258a4f40d15c3555f900c9ff87f56352458fee73a00374dff84f52148d4d7679e9fcf15179283db72aeb229c3b8cbeffccfd0fd4eb7f7bc482f38eca1def716b03fcff744f1b784509abc5ff40c11b0c70a216d3a91fe301415de5e5bf3276bbbfd040f63c88f9a378ccc5e73bce05bf95adca42be4750e334f67033f076e57b52eb8e386dee64df5e3472f01fb5ce1859c510215b01b09862887201b6340df1f8f75ae9a29739d88819a9ce1852dcadddae68fb3702c2c456c9f75e573229a7d9a476e455f8e1656e7343351d4f81d5d769b2c36b14b3fd31ade1ba0b46cb7360d6370b1202467f98ff5d17496b13e9cd07a67345b38e9bd0866d3b797a51a91c3cb9a127103351482bd326c5c219c746b0c58d50a47e7d962754b9278d1aaca617da096a334521600dda314473cc58e78a6f9951ebe6f88afc965227e8f49521962d983faf67fbc1d10ebfe6a4d66fc65b6acbbd69c4e77e8ebc058dd704657ecd3f0d32f84be465651cd78a07bce1126ee8c0aacc397057a5dfd5cf883dc5c54e7a3f307a076c6d20fcf8f6e5df800d2eaf2417e4a6674772fc043d1eb077fac6efc07fe83b102c3613760d06c08ba9ee72ad5ee6eb2ad7f5c6dbc93fadbfe584c0a7b81a7b8282978f619f8477f538a6992751cc7b9da441460a5106b0613ce0a478e569de490a7d6435f9027f66973ab7de42f91b8fa239b3bab4e0980ce2a41e018cb9a9824302b948c78b0bc8a22fdee0cc5a1a5c4a418cd43464e721c31b24115358c663e30755652c1a061aa66cff41f8841838c2adb0e272c480e72e324859cce553b7f12c39cf454382060bceb8fa46dc75106ec9f78742a081207c08f3646d2da00d6a7b3dbdfd0d70075d2a50a48da513b79a5d6db72c52c210ec67f1edba5ebae091dea8cd58abcf66f8944b8b403f14d836343938472bd9894c0adcf4c59b346152c72a723e8cf0af520b3e711d07cbb794982011f15b007a0559952f799f5d5613ef85ebf32ae4eaf57244ed3b13eaa8759b960685b8181ac7351e6b48e65e5ca93836d8d35805bbc0f304ae8f236dc6abfc5fb76e290522713fb7d3de933488209453582345251c223d39ef40295dd8b8e3da14ae9db90885f93da63404e9d32d713d52d14e959f056335f498a7167cfc8b7562eaa56f0492465d2d001c1211e9755932b5f0acd1fcc06e81e0560c2a681ce9e284195bc743fa91c99c5b1e11956530c773d54396b59ce34840c44f14e9cc261bbf7f6f56d088e27bafaa295fd1af19514e5ff9d1d07d68e16aaf6063dbb607f22012e283aeeb5d17c8ef23d99afa1594eab3b6d287280698e9533649bf01161a23ff697aabdc33b3ef3de562d4d6316f009faada3c5043c49d776da5d559a70b2c0e2942551df9bcc3d24652ae75f5b8eab6d38b9143519811211c9fcde7916654c83ff927fde2a0b4d80ab730a6a34af59e8fc06e8fa940758993b9d20add95e705350076614305057cb8786507b91308995b97dc9e592a014ee52d1c21f8009e58fbe529a1ba2551e8e5cfbc9c5eea3ced1f61049496c3e24052312a533ac04b66a877b57b30534e16a8853b5e9bebe83101483bf6cf6ccda09c0166b117a21c4731678f4858b0ecfd3838dec67b4937bbbfa610d892fac85a23cb2caf2388e8844386e06ef5ad3d8418cdf38db3fd38d4778af5c508a0f00023410fa45b493cd945c6d12dd79bf90fadf79d8901b1a36e0f4b985c97170fe10e08c3f15f0ebc2d774a9ee132270de44dd981e98fec1070cfae8be7dc5d1adcee9870666fa4202362a805ebec87a78b578a3b6080c9f086e1a570601de27ae7a3994323a14521c40dd6ee46210f41f02e79d6358f8bba1d79e0a05d7342980c585adb611c8be5eb7e877c1f71889ae14de553646102a0d02c68b6309b2b744b69009cd4faeede9075847cbff50db12db5bd6522ca438753751e37ed16e8d67f3d849a576e25e0cb841c7ca25ea94cc270ce48b45e208282ef5fa3ae7ff7bbceedcff01bc23c28e2cd737a4a0d8388a05bdb245474129ecd9690e347816c37369ec896ac8d94bf92a7c752141fe6b64ee531637e50ec5fae1fc6b56a069ae85d4068df3a3e8a38eeb8c62dcc2564b3ba23b890c69219cc03eb6ffddf40ca1b7f6c439933e6e55b06814e48e3967d9922d6f843007e9c12aa965c291c85914df1ee8d2cbd3a5cef8328468dbe26dba4003fb9edc982f5c2d8416a9c8f68fb78afcb55ffd74380c8c9f310147a58d6a2c0015979b3c7d9f8b7c2ba2155998c3297970565599184a88e95b820d692590e2a70957b396dd2b56e43518c0535c811d1da09c0f53994a29a53861b1be5b661abb52ff9d5fe598a9bc289718f0e2212c44a9356bad95a9a4900bb1cf32606caef7cb1465dfad64e78223539451c98a05d03d926db3fc0bb2d9b89c53612b4d579ad293cb959a684139a75de346db3cf236988acfb348320f83dd7230f5187a098f040ec7b131d039c849940797671a12b1bb9fe2ad530ddec111b6909e8a41695fce82275e071e562043ee96a865ec08720e1609f5e55a3b2ca29a3bd1a64adf6f38bb14e77eea70ab99bcc76892575afeeca9829ad1e385869383a796ac8a07d9e7ee1ac1822a228afb39182c2d2f3e629ebc29886293e02ae572cde0564406bb5dadfea3cd50e750fdbf7143dccb5c394e45b2c76e2c7164d6b910545f89d60d0f0860a019ae42ac35757db9a0e7479c3403ccd46c19d8ad65116987790f0cedb7ad8005f674375959e95bdf71b3ce21271b400effa0d55afcf9a7ef45cc6b7206c9e9afd09552c0f81c4fdd9005f6bb0afc8319bf82682007a4936c55427823121680f0fcb2e03210383ef32ddd7662e404c433e6f890ac57320391bbe026e26d6aacce15fa4e516ca8d51dd1b2c2f879f49d2af2eac181375c88ea9ee17f17ad0182f3eb4074ff3b75f120dfeae5a029e5ea8252a75ddc36869c02e6d19dfa1c807808d46f395a8921b0a41b62119408960a841b899fd30fa87c2e9ff8f4270df08d4a16971f3d9679859e1acac8c57c8bf24cb1ddf29305cc449bcc6436a56ec599d5b427b740871577bb7db59f12b402b9f4768670b14df5012ae9d22ed13ea35f2537d587ecad18e61a6d8a2fce230a880142b87530cf2f33777943416594cb384dff61f041d304c27562a81e9e1248b7e9819dc7a5af241eb06d0413caf22acd951dcef582edd88b12bf7b4c67eb13956c40d4e78b2e40eb1803cb234af28c2fb55cc5201fd36dd5c4a7a033879b9e0a0c395593653eebcef00c3b957d66784e257937df1f8f218b209dd47a47b9817a0ba43ae6bd380bcff2b0cc50348d46457144d94cfc26db03f008bfef2cceeffc9089aecf97a26bdd48e59b570d82724a9970646330bd3596ebd1360ac1163fe558a03c92f99266c9ae109ac8f7123fa600764b1b729452dbf61ef4527fd0a35686c6b238d789e9929910a8c2a094a0a4d016f43d3b0c4fe71f3be9c82498fdaa9fd11d189d3fad647a6705f80d8d814ab8662ac8b0adfcf7865091ff13fe004afdec20faacd6191eee3eccd7b0a19efe5e00c67e58d92571e2bc845f9321c8044de2212d57414896b905f840b0fe47d1604bf921d680569c742b7afae12f62abef2ba94b69f8ce8f844aec6acb4e5e7714741a7a029923b0cbed5359219f2197cd93828aee654aae0f37227c2b020389828ead061a30b56b8f6d5266f7710305ad1f4907e0ba205cce8776d7783d014d2d6ec42111ac0bfc956c43d23526fc48bdf9b99ddace727498636cc037dc50f55ad96608e259fde23f6ebf6af96e2114cdfff095f43f5baa79fad8d7a500adc354c46cb8bda570cf581a89f3e080ba20343ef1944ca9c96c4e6f9aa4ca2855b61b7c5676f06ee61ff97d4152a0f478ad49c7fe517d1b75cdbc360a857bc0d0947a0cb63d400bdf94f5123bf3c949c0fb52c5094b3c4469395c1b21fa3f898f8d4435958c85aa691c9d85aae3a290c24e409aa6322aab03c5df214c8be155e82830a84976a05a745ea1deb0d8c0e26fd57eb9eef5dd7ea7b4db4e593bf8d423a66f0650a4c9176586ed69d38d4de631aa2a6ee055372516e49a976804c16e626169c66b3d8b35801ec8abb7b9639bb6eb76eb7845c585586d967efbb23a0158a7e52cde6137cf2140e3e7f4f4052b073f8232af50705b3f0ac405fbefe2f3b2aaee6cf0ad32bb0ae9094ff142d0af8752e8bc5f45e9356b76fdd09ae78db7298be09761dd7c971cc419b28e82245523bee2b9e65a9705c2c3c9fdbc5353aae4b91efe0cb086a8d7d326c8baf8b98e64c53b7dc7e625242c0852a8f0ca8ce65da3e5f79afbb03f2c49718f2dc9162d0cfd91d35a8061a2d12e59232f8d663ee0492a26f637e46efdbe127767bd1641ee57c62a7db8aa5662d602821e1e447e500e8c56ebfc380fd9c7198ca6162ed9b3f68acd426a2dff6cc2e4775271c018d52be8afcc5e0caa06e9bbe2879048ef544c542ce245544d8261309ca747fc93e66701268531c47710dbebaed07f7cbc3a1a6ade907d30e61898448e86d56149ef8ec8d1849ae0f2a9074fa83c6b923753dbbe5bd10ea8317422ab42b2af8189b7cdbaf853351e7dc2573e1aeaef5defdf3c935bddb841e8a0a398764b3fb16410f814ecc383545b94fa39b410f6007942d7c838d281e290904952ebc4b56bceedd5351f417937ea734a9ee9826618660f600c82a3e951a3938ee1b839e26619d21e3c61ed41d930566e520a2f494cdb65b76ed0b6f0a6386e1d3f5abde171f58d75c3dafa845e2c873550ed948cc4541eaac041b010e7865f80821d646bf39549a4ff633c62a5d50b0951e0ea7d24e330cead659072f70c6dadda27c2147a1b9b684229569512624b83ca2240a2540d9eeddf3ee8c726b0ba76b08ad180559d14d12a54cd2351b3aaaffb93a2c92af4f3634a51f14f6356e92f499003263137da13938e99cde8aa7d720121712d5d95abafa7e565012e6064a3d29cd419db688c43515c2faafbcd568f3706dabec2a93d8cf678701a424d542c269fedd6e2b8d5c54b427f5aba4bb3e59b641bf60ee76bfe4c82b71649dac85bcbd55f7efbb620a399b55e88f5e04b2fb183985aa8606e5b5560a5978e1cc0054440b409de848c9e2d55b2a6f2a8376079a62e2efd29956711a047539c85c179c8ec250a1f8af3e198bee5413a9e73a6a05db57a98ae818294a40ef46f5a307283b166560d2b85a899ba4f2e500f6b9db6e241311110b2aec3e5b578f9541a2bbe5cf261b66996c12c9d8ccd1263f360101fd24fab03d83f3c2a947dbb501749eeb9c588dccb430f1630c54c75627dfb8069c4c502683c66425ee18764e082a379a8ea69675fcf48b51fe905d3bbeef87224f73e46af4d7a0c04d0e3a9423b00ddf506c4f311ac148d428a953feb7b71ee01fd96c471b6bdfccfe45f1db65066fe12e8fcfb26f65709103e78a30aa0043522c4aa1a33a6261f6943df4f49b9d9cb316afba144eec9f6a13492ea6d9f29d014d135e5c8ce0eabd4b7f75164e9bcdfb2535ee82e6e8c9d7e9216bcad2f40de79763217c7fb33cd53c75a207bbbfc30b38f207c627307a31937716fd47a767c5a86eb332ed6129053626462a8d314d8263f5f760cb6bbed686d2a7ed025793ec78892e79f3f3b3508cccb7ae3d22732ac0631bcb44bfcf097a25e3f47ae65771f13ca9377359e8435565727228efcaf9559c0b1f0e42abcdff84ba401dcbbde8041816176c1faab6aba16a106bae64d39e28d0dd13557b8625707f8a9df64e28cbca8b4a4a78251f1c57121a15a88e8b72177ebe611462c3674ae7ce60e01212480ef85012e6dcb0d3069915ab830aafcb6eb66506bbcb2d72f4c03b85fed3ff841ea0cba9abb223b78f3c99d9b90e66e36d72693405962c57dbbbb600c54bbefbc68dbee4f94b32115b90b670f69f943085a27323b0e73954ea36cb7ef2dc5669fb4f3c3782bd09e5622dd32e72c7cc554e930be9d196c125ea64018c27e0c93c39c6cd01d6d911acbfe767ae056962a403d1204c62bc57cb38feef7e9bb5ac211702f63d97c849a3024b87240e37daa230df3e4e67986e6cfac68228eac7d43fea6106c45e070ba0e53119be11dfaf15e4bf978cce57f8b9c66a2901559b64383384a3e1c167f7f94f375e89c367cf8cdcb90808600316377d63901fa8111d9354e29b201e3542b592ceb6d7d8645ef235b7cfc2295292592284781e24c94394caeadbe4ca09753094ceec3beb416e152023d335c889045e68a5bad0515f8ce21df61c3321712a9af35e17ce6852a3e61dd5d930d4102783852dfd6de9dc0202a58051513f9a92816b45f43bbba1272f14db92f8e6e74651f1f76944e98a663df2a084c95a44076adde653eafa035c4e0236a7da4a2d41a9950134bd269b8b74dc5ba743b45db96c9557e391f37501ce55b0303963885319eb6be5fb5931250c6365f6067d4a749fea060e2d0f0aa7a5df4330fa27bc30710535e2448b35bbcacff29bd37f1649bbaceff1f67504cb646b7f3e9ccfdaa07a23b429817ed09cbaef8c4f7a54af7abe01c659ddb9560302c5a08572f170627170b134f2a86b6b6e7a30418e579bc44934bb478ca1b8d91248b966f9c9270a5b2457c4f22a033a187f5752c6b442bc3acd00053b4c598fa592acec7938b8ae92ae9cbe5a4ff6386ccb2ceec7829a1bd8afa5ba59cdd3bff347984e51b9922e2947cadc45255b5fe6b4541d2cb13edb09ad9f74fec4b1a908ebad84900da968c4d0362584f51b5bf99960811b3bd2f2af29eb8874774cd5bac19cc8b386c8fc93d2f1b16573ce2e2cfe3f4ecf63da3754774728de8a7c4e00442caf136ef59debcbbe6afab4ce34615a43854a690dbe7277819235f315d0354178b87945ca3f37fb8915b3f0f09a4d78a6bf1ed41bc66e076b04f11347da302f2f2dd50be46968b649b55fc55985cd97e026c855b077e565da44c603fff742627e39c7e0b367b89471a9b094fde5f9505c1ed99cf215c76bd84720411b93b3ef89a12a225f7c8dd2effc37e1eb8888c2a987fd996c662fed806485acd4057f24e8d5ec4bb8e3a39a5c43deb66f155ab004bbc1f3b706929450a6499c637e0343cadadcfee146d59afc7bb5fdac33553eb10175a379ef0d06ea1a4f1db090181602e32a56bad4df2780f5c57353a9c68d01ae464a6d7868e376271baea9f4206ce6454b0130be86f0e8a1a425f4540e74d24831daa5c5608e5d0f2b029bff904245fc4cb2bb3160679cdc4d4cfe129e09f3e4783ef9252ff9a8d8241ca1e85aab4749b73b7d19660fee1490b7014262fc266326812f4f69654cbe4f793c29254a6f405b71b59f89ed6300f9427db9add46bb76269f56b9b3d9040261d54e99df3a8d1709af748a9e48bd8e40078f0c89fee61c7bc15526ed375ce53687aac387641cb55ef8185a2eaa09b2a00d9674ac595f868da0fe67efe9f1ece921c28fc5193b827126917e9d9a15d8520c76d02c359a9e8d68946f1c49d0d02e59f03541a3ef46de777d01dace9abc7fb30da952503b1ab5fb4ea1290aaa670eef28baa0af58af695b6f75a9635c64943c5f1b9f2ed6d14bbca17af9d79bc085d33e65fdd6e5ef5625863436e44a9d1b3a8f52fba53776d5215a60aa08e7f7716f51d8eb9fc57e3092f3211f8f9aefa5a6f31212b746ad125686d4896b0ccd585706e29951c5f6aa553ef705ce2dc5de7f95bc651defab96b3fdc533a139446cb4e0a92c3a8fa8a2762ad1785d48f23eb86e2df97956795d71a5a00ee0199a8666bd45c8821c89ba813c70325a2b2188a3e0560833c4914c547d0f6eefa2582dd850ca1adac057ddddd4e49f3ae999b5cc08d2830a0e66406f6808f564b55455ed5bd0feba5467c78fe7be9905a7f23598dac1c888e24f0dab343148caa0072afef42231a4f0afcf3a22593262ebd4916ea16a36abc8deb20d6bd474ffcbe99dda0856e6ef2b347d32e4238e78d9dfa906a0de27de5ff4057f3e01982f780d84f250883f4d0b99b7804028df427d6831a8e25aaeb5e786e91a982715034f00d8d8e5e7a4181b7a9f2e7f795d747a6a0a2bbd7fc1016141e6497d966918581799709951f2c5325c948773796fd441c6e58fb2ad42e33795e0d574dc2037eb40a06fcf082051eb42aac3c114336076903872170c54ea894c49389650c6b7133290d6f9b41abc208f6faa9a1282d5bbb895187bfb32df0a6e8faa17e316f1fd85113421700304965e452dde0b9fca92bcca6785fc80c4a77345468fbc4c329648ffed2f0bd4281d89e5cc0c94ec404441a0d74411460b3a3ea43b8a97c37d9a0274464509af3fffec002b39fcab60e71c14d0b49f94cd8c807899009a2c0ffae0e1cf6b96b81c7fa1f9f4280a4def4bdfd4ac4a83d11df8b70c0a450eeca8e34817fa12ff629dac2efe925136ea405978e9b00636d6669f55781a6d2f1d10bf8f3ddd0759bcc1a422506ef5d21736f0801a098551380182d457c09bfb4f71c2bcace8ed5488ca3714e3be36a545493d5f411af10f3bb638963994e4feccc331f6cc96ebf238b15678cca543d93d3eec4e383d4dd0f4cc271b719f795f4ad6918cc37e8921c811649a424d4c6a859bef8363ad9cea170238b4aec8b12ee6de1dea0139c40e74e366060bfd8deba5bf094c73a52a5251862ad827346ccab93c3bc87d23836ff785cfa67859f6dfe4ff1ff7bff9786e6b34094400b7b5cc73d579306275414d613570f1c5b6143f34b34851adb3645d88c1cb3c1c11f00edf9737158bdb2c85cdc990d0c52a059751aeb827589f2f607956df40fa511b29e78ed60a02ab6bdcb36f5dc1b3e6ff71a46c1f5bac78e6932dd97e069c7dcc3f41b38f7cb5d0f0a4bb24e05640434dea6f3f1215f765463424739cdeaae64056db6bf8d8be0d15056ce0e7217a424f4d04ec71f3656bddc2e87ac99ae097888bf3b286c21038dbfc0e9700f231505d89f38ac9baf3e1d9907c1a501140caac6bec159b16fd7e7141e526b8a3551e93cde1f2a7b54094eb7c16e6578696f2f0289fbe9f81d53ef9e683722a44d5c6e299019d7a659d23dbc9c8bb927edc4ebf8b76dfb8a941c76cadabb02d6a8ab7f57b967643aa30a56ba311fb3c15eb524d62a530507731fee2ba48adfdeb6a228983a381363a90a7d5c97d14cde0535e0f1c4f26d55699afb996d6a0c13fcba3a0471f3d315f0c04c31e09ee7e5a8ee97be78990b5726a8fd5dccff59c60b24416b46f5fe292da1834a50607c3c800cf61551cbc52775f34a502c0cf367f0e7cea51c3c92cf7a8b3aec0d5bccd3056a4700e4e863d97522f1fcd6f9433c214ca17c7b2edc8a42fe0356847aee97c352dfc751d774f53c8e96a7761e38f5216474ea8bfaef7919c6fde76212a2c1421088347c1d246c5c206b2d65db48e390e287e1650953b2ab6b0848ea32262ae920db87abd4b7e8ed896c64eadf9902cf8211094dd39e73b36911ba6e026ea6cb958a0534244d4d64ec885fb44eab827024231ebf5edac9c74c5f00cd50f0f968ca1228553a6dc034e5e7d9d08ad2a8286b4e541225c8044f296caf324a2783696dcaa29ad075663bfd4cef16dc029c61b6c670ab85a025bbbfb17a503e7b0d4609d4e815f61e2956711747e0d3887566111b0417236e5582d694b90867b000dbe3bcd51c8ba13004068f2af29e708b39d54f0c873dc142b433fe3598b1c38a2d6a1480955ef29bb49952246493cb189d11a8746327d30c142eeed7a71c13db507c277948d4f9d2cc0c853b1b0f5251631f8e88d3f5ddf236cbf422299a341703ca1517e7b44768484cccb53f5c237541ecd4ba8b50396f75a73f981e3a3e47a91f53bd8a6b5ad8bc2c37c7501d76512de4d8df06c4fb97868779d39bc124c3f7a6e2724ec4010eb659142bf82bb555fa3715d96fa6db1b3de117af876be937a8eb1174bf23a4df7b6e0b0c2d0d8905b75c45dab09c5d8a98979a7662c1762796acf8e79d5e56f2afa4c29374a6a9f9a612b4a81123a23972c42d049718f4b9df24f0c9aec0f8a498d59b9048180bf736865344c3ad4ceb10fe1d279e851e3ee3957e3c8a56f6daf274eb21b6bafd70b764331336db0608c1c9b0b8011c966c21a53d2f11985292faf5f4b46b3cd90355486231c16d732152a231c9b4a16646535b647619040d4fd3ed535a4cab1eb7d497e9d6e7f6a7100e5614468492da5b323ae1737d07ac3450052b4e78c7f8d938a6b63f45f6e0029035e0ebaeb77fcc40ead2c51f47bec8e625f44f06c6e2e1585eba750c42a6de4cf248e57dee5b3d8983d122a4690fc540d2dab1bcc4f8dacc5b0f093cfda3e4906049d40193c6d19eedf894469b6fa6353242e1ba67e526a6ba336d43ed4b7fd78fd94fdf49bde38c8073d7187a4e0ebb6a7b0d3c5a226e64ee7447a8eb67288f4711f108ca646528d660ae11324ebd1c180d6c54b2688a5c087a7e7326374f6cc52074fcd40d8bab4445d0e4eb6e01c1665a9a742c0b0cca4f675f33d6cf64a929f40185262df777d61e2cde937d5c0baffe90a0716df9266b90425b058ea74c5177a1bf5a7017dff4783e8d70d7fbd5c3ec15d986dae55b39d55b5aed716034c67dde625f4858e5c903cb00507549782e75d7cab3ae0711cc9860fd786ffecffe24ef58dcf9a979c7c9174b3fd55ec9c7402c53eb628768c20c7c1f337a72ca15d4901e8a4094ffb20f9c8fc082791ee65f399bae154660bb03082a82043849dcc476b1d7ddefe01f3b55aac97e16b0125ecf0ec6010f9a0d4cfbd94a6136f71d430bddeeaa8b413a056f05b727d9e0e1bceeadf31d4afb37a2cde9f452ce742cc93cb7bd9a24f81b1bb621c6ba749782317f1684a44a2a3823e6ae6f260c0d963df2f50d5295ea4a80c8ed873c346fa0cac9df08e94938dfa19d6596dc643fe7dd0c0f52b8d424c44fbf8c6e8b6fca6d787d3700464ec05abc77433820b0cf586c62afd580f52637532b292cf6ac614f424a3048c1bc726465bb87ac5289f4186b448cf5b55762cac518541e4e984fc56a7538bd3aa63679721b16553aadfea6b0791a2167e041a5d7372a731b102c069b13d6590587b480e1e8cce1a1e28db0377e91312b0d2db7212a2768beacac7fa75e3b5880f75be1bcb5dbb4519367b2cfea48bc23e4d5d16cafb7b7e6af9aed6fe9f568e8a405c30a4ca1efb245ef939669ce94110f8fc7227f3c114a754a5a1fc1996d69656a667dbf377887da4aa89da5c496d663b0e266e45eb75364c48b0c3a56c20fe5dd8c7c4fcfea5762f1293a484a888aaeffae26238fb30c1c10ac2dd98d2a67c24350d9b634297057c7d2e0d7354848345d9f398e130a38730859c2d2fa28680010d367af9b43ab6b34f4c239df49388fd4eeab15d85fc0f687699e41909310484bf5f5a009213c192f2031bacb35a3f90572cd8e59b2a8b69cd52e832baac38221262962b6a7aaaec148fae39bcd9d7355712a2deeb7a165e185074dcb397209b0d7f80b6e7c9d9c17909ef18b17aa79b8341b5bab9da1174344c53db0ae1a147995bb45d41283ccc29cc18f60820bc8002166123fe630dbf647442ea37caa40e9bb1e32e26789a6361166871b008b4a04737a658f32761d4b316e20f3f27ca44cec6698d06a220d26297c3508c9075c1e7ea831e40cd875a29129a8a5c984165e754a8af325474a19089cc0639514e72151124b055f200ef50313cef9251421536518f508f71f4cd6d7628b6f9f4699efe7028cda50e992a0eee4225c45d8535fab0e875e2a6f935544bad66b7722886faff1fcdeae5316e6833686532eba7b343796b920a53e8a300f4d8811019c3af244d208a6224bba9d3dd393eb716a1eb09fcf58a02635210604c77b4d1c89989fd0ea195e34699006dff7e73772e89afc1c7948b6efc3bbf0f4c9c34fcf3e71df22950c50650c6a2da452df5c692428603ee6ed5e48f1686913d803e2a1cc172e182a16e1e661613561271c8c3d6ea2ea56740e5794cab293b7e58d69dbd39d98e94bcba519ffccec74b17dc8e092a464d1f0f8879c3d03e7d50a4c6b276a7404a81900fce0a2cc2c45dad180659564f550c0ca22348dcc716313f7b198fade05d7495e018d3ba1be2643b8ade6f7d6dbb2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
