<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"03317362989d2ed6365061915630db5d9834ea1ebf6743dd3e2bf88675a3487ec51ceadbe436b624fb16f319d11c7039fcc53a37a10ca1585628cf846d0b916aabc79fd3ee6ad890f48063ad3b3a17a692198496655828826afa55021f2c563c299de6566f405f7108ef543615b3f2b487e84ed8b9e8b49879d9176d0835d59b6113e95610a608ef90e29fb4331fde2a4445daae0bab743e84d6307e50cb57721275aeec04f92ddd54004fffe264475f616534b5e819e0ecfef90970573181d31358a423139f6a1952562533700b0b243a4f1885f7b7c66ca44d15cb75925e86c9417e538a89ee1cda52e0278cc417794d1f6c326ac81afbf52d1865c7f022365ac192f3a870e027bdd60343d61cf27950c63588e381c191fe6f793c117f0dbc53c3c14ecea070ae9747de96636d1184f52bf3d4a25777a3ce249779204f03b61ecdb20db290fefa7dcea0f9442c491deb69f50428be15bbb1e8a5601b642c993bf046e737546dbd6d81c7fb93c186981a5746abdb64c37a719d49e4bc5a00e778cf0d10453b31953b93f07e965f9b171fc974c4d6361dd7629b84062d568d2b7037d4c1a3ca989c925bac8bfb45a8fd04800111935559cef0b1abd79a99320ff25b61d9a17e4e5339a823a5212d8610c919b76ed2c00c7d7e9e7bd14f700478d44ba2c9effc9f2375a49ff4fea3592fb353c1ad46bef6e8a67dd484b4f21c1353b19a4edb22eaffda1cf131becc24af8e207011bbc9b5cf55db4f02ac1a80f261981c0102c990239a891b288468a98d0db89a075e118373b2df8641e673aee89000d17ee975f96128ca75d8bbc84a82ee0b27ffc7fd6b9700007dbb8e0cad93e343cbf98770b5905d61c844c2203c1bb2927e8c51f4fdd6b43158d458dd787a5cffb4dff7b35ace8244825a30efaf6ac3f1fcd018053364ec6fad0c2096541c10aa2550db14053cfff9aa32d9907896445e6084b9ca788b0906c022789ecb7612541e2b81600c103f1947e4c6b72fb62be37e0f6a4f739dc505cc8e5240e17d04dbc214eb98127cc3f16416491480cb7127acd1fbad99a291b4181d5935b44192f12bfe2246d7312a7ec2208e0daecfef7a540791296c7228d2087a6dc655226f20b7006d34bcea8dc34a2ee143308258cf70db5329410ddf8b665084f94539ed3c5c174f2fe5fa87dfabbeddf1946b21ad9fc4e7cbb18d404a5017e8a153170fde976bb8287143281daf13ba6331d769871a46adf52e30e3b1fcd6b54cc5efa30e139fa2731c21cc23813538d56b59e66579a7eb1747bfabb34db7dbc70efa3443384b686c9d63aeb72020c55ebca5eb7ee56ef4180bc1f48b94dcb501bfbb3a3e3fab74e353d3c772ee2fc0883819bb7e8640b3576ce73d1e1b45e6d4120341d51ec14fa8c7a5455a093e1df0673db5852bc6e186b761a37be22f5cd9e1afe47e92819b85eb9b9558123a242f15d0670057fff10bd1c02ba07bdcd0fa972ddcbbafedb695bce122bfd7e33cbc131aab5116ead2749e91801c4e4dfd1d9a80260b8dec898b45e08dbf8a035b73ee261f2946cd563e84f4190e775db6622738f21a867e4e14c5cb302729a32bbce172dcc198c958c0e0530ea19b8139701f17272c2fe40cc9a15bcbb574bfa09be5effb078d8cba7017561d7e651b5e7da802a61c74fca7916186eb8b518179eea8a4d68f1c47ba74df3f897ec025cb08f8d75336f8da98ed74cd32724116f35e4be27aa1be92ad940e14dd5efede0e0ea7fdcf880f0dd1a434e5e775b558572a9f9a4470ae792c2918eb690bea1c3ad0659ed049bc7ffd05cf0da7f8c3bac8b523fe280faac8c03c525eabb81429ae555552e49aefbe6636ca8baaa02ed674382e4b5da6e455de29c54319e5b3317be4e1496031540e5d690c0020f8db525b2db4987e4397ec52aacb98ff8db2619aa370c816eb7fcac04c25d1ea5fb9578682f5c3022df187b6ddb4db104652eaa6f711870d206357d988c7a60f81bf183c3374edb0eedff60a620a3a62478a2f1de2a8c4cd8bdbca10669d8777460bb8317180f65f414d541e61034e601facd6d9beeb859e64b7a12becf4375d1ec342b64d27a7b543b787a5b5885d76b408e0c84cdf8d09c1adc3b5e7b2a2b18d88cee3dd961d017c49938394c697a6a45a19db0e2278af4e0522fc482719618fbc903aca0dc6d86b1544f63003dde47593f5ac84b376d59bf2bde507b86ae9402c5e9b562d8c29f09c910744f3ddece105f5bfbd46435e8c8faa9df237fa3549c9900d9e469c60d6952ffc40df1286cd831d66ed446d76489c4849b17cf4ba244bc63e40b10dbe7c72356218a237a155da46a521af913cfb55102c077a5f3452a277947768e7f6eb2edaff469fcda4255920d20319481a1deae2fb4b0c5eb28bed13377cad82657766ba7e4ac21910d660fa5d7793591b3a88c4fc4391068d8541fd0cc52bc05cf465ca0a87fd9e13c52ef9ef1b0894ff2b765678020a4bf8bb864765b0128803433155650f9f39b18cf85f4fd30789adbcb2c404814bf01f1799e620ed888139b140a1404436545ca82b51d7e24a28d30c10f214c5a59eb9fce536d6e2100cfb707a55492881e676d56caaa843b8e31566450619671c3ca34da25e334ad1ac4e71d28101435f32f22ae75a56164f3d42fc3ad00d1e2ed42a942c83b83d3d261f9113ef257d5d88a6daa5ccffb4b9792fca6f46c28327c785ef5a4e466d3c69e02140f916faf3fc854244ef6225b5c4d4df8d9ccabbb3006b86a594725ef7886889056684acbb9ec3b06a2417000e9fcb39f42ee1260cd61fbfd11c5363a78653ab37cbf63c15c1ff39030e206222f2ef119023c46d26897928acd5d0b63485f5e9528a21d95b0862ac2ee21a0e08868398f3547ca1f35f5d0f8df90b51cfa7192b8aca22a70027bb53aa5b2674f2eb91523d417ca2eff822dbd7b4f5eb183dd6a5b78dd25f75d47ac2148c7c80b342ec61f82505480f4f4869c432219a4a1f8c5020fc14a2596a767ce07c6e799b89d343b8108fdd34345f1abc55b2ae68e776bf2bed0fcdaa0f16f0f4c478207c471412164cbc3b338738c5310da91e287ad04ee2b3c5965cf24af9a1d6c0e41e6fa16b08e7f834fe3e30755ab9f3b49622542ecb31a9e379ff77e3fb0fa49639065fd6a10e8dea21773c03eccca3d0bd7d726ca2f70f8a19cd1f2a936c3e7681d693457e12bb8144456f3687e5622a9fca5bddc46fb20ab845041b26098e54d92138cb4250a9fe5a755e9603b610fd785552252016b23c40fdee102352b72324d642ac7f26da998228adad76d1d3d8c87de8be6f2cb29642132c9e2f58ba4894547d3dbd8b5b30ea3b4e041d9a76e1a0f55e19d7e8c13f892fe0c0a0d96f8528a5d543af4ed8ffbc377f77796ef630736105ace4a00d38c675ee4b4bb544f09f7cfec9d4cc2cc13e89aadf14e2cd5748bc6655b8ed2f7c7ba122ee1a262f83228fadc0c83c7828578a763f8bb3a2d85b077334db1a2c9303c30483a7b18e28cbb839b23128725f5e309dbaa811d3f653bd3aa9631c4a8cf8966248c7a1d880222bd2f7d132f116ff867727d9083a98b685af776a55b7f860df6ea8a6d6763c714e98d1a7f42721d6e8416c09f905d21e1fc89d5fbee8d6fc19b9d921060aa2861c960f482ecc331e76c7acb1e4fabdccd59a8cfae1623003519c926814b63a0a69477aab8f7780c1dd58b3f15b52cb4aa902ff7b7a90f8e32074436872d7551e405fc91c6a4974a6830a1a59c2df34c85f51ba1be8a4ff15941393c5887d3e0778f9a02728fb53ff76bd9f47723a4d3088eb6a7e2cf6e2c503fec4e837f31c77127d49b3f0d197a00b767fbb21727965b844867afcdc5b9d9bc7bde2342f7b7dbdfacb222addb24efa925439a7eff381f9de2e169bcfeaa74e89622038f45c7d0c7d2376cabaed7260a22943c262dabe2b07b340b9c16ce5b5eb261d1ca5ee7b7bc741f15496890cb839a0c9ddfcdfcd8983a399e3862aa0c23b6b4af45e3ea87cb4d5a3e33e11a6c43bcbd69a932314248b31045f285c4296b306e1130ee2c1dbddf302fe176448af9b93226b6b0ead6a7a2ee499673cfded7121d6458f1a4924048a38f05b27b7962dd7ec15d8e8948f3bb7036aa93858f48f279a77f84fc22e67aa345cc5455dc6440e0c06c739b1a2132aa89645afb164a5259c228829e2c2c6201914ced8f6c9f2e641d62648cca771f3c303410727262e0aa6115f44b46541f35f3f23fa6294fb71e33ce97794e5cd60a851241c8a191a0682d778be89c9126a93f428781d43d42cafe0a64e132e7365588438a2da918b0e39b128ad74a67cc576bbdaddf856ea248e181cb54c5b3ef30b3a6de038df5b742c02fbefc623de3fdae780be20537c520d3666083d7910076d5de74d2817ae3f938080c97546accc74ffc3ff02ecc34d8a6ca3a439cf21c7c5b717709b20dcd813918aeccb541a088f69a7ae748a2df7981b9364cd1cc3813cb44dd90872a5663471d12b28eebdb2e41d042070419f36cca16e363de9be69b34f7e85597584b6ed64a1c2991c21fc58fa2681799385b95b91ebe35c37d96baa7e89eb7dd0bf4a06f62d23033ff1da2f3fee9fc76e6db9ce72a4ad5f38d96a094bbb8f2993b135da3c963e818b6d8dd4a4db3b7d26d072052797f09ee16a42985a2135e58df7815093d5967f286798389fe0d2fcfe0e3410a75cb65d99403bf291926b86014d04e5cafe4d56aa1a36cabe36fd811cbf76f7a3186864ac6236f1355412909b8ca19c7bd43a06f24110cb984f1b9108aa4bc9d9b63719f7cafc87d7d9916d22362b901faec128f4985f8a300d9981ae8b801fc07017d5995b0df2719cc57357acee526ba6a3d9aa8e12357be6833f1ce4789b69e70439eda12cc6ed530ffd6f817b3c802c36b1748e6376e4f727e1d0a6df113dacaae1c31219a51054929d5d4ee3f79523b8fc4c148289cfa1059237c3af803745e8f023f976a0feea246ee01870c12baa0b6c1f45064c8af4f39dbcf1accad9f3b8701e5ca3fa3579f5e6c59f0ffb05bd07e802b75b7507a827fcf87287a486fe5712a3c2bbcfff09e56280965d0cfe37cb22c282dc1e8c07b8de7c6f6a11a4408b7298b45566d4c70c9062d49cd4240029210a01f4873c3e329ed8e57cf13e34eadfbfb769a3d7c44fc8e33ef80cb8d92d484ac6ce9080ab10fcd62ec169b547b4084a9d7e706d80bc8d8126ba13d9069617301d4bef7b5d64cc434c581386711d02b69224556cf8896776ca5e99eb4a34df9742f8dde55e1068a077c022ef33913d791ea9f620dfe59287048bd13d900ac3e7267cff10a44a7aaee1e2f05fa22cbe3cdf9b60e63e070224474b26f34498fae6ea2c0ae2fe218cc0e3a0f58fd199d94e0f5d19f427b2e511a8fd918ff9301e11010451e1ad2a6f328dca8c3e672b6fcfbc075bf174fdca4f4b3ce8d2d69382ea404fc6248ed7fbcb3aa8fe892341249511a041bdb8e3f5d219defb8a019fad0b442d9d5f98263520a27072c3e8253af17921ae659f18d997e0030674ca1d46c73129f5604d7309571b296f18ae7c1682b7375496e1298c0133d58527aa22d316c43dcc56eb6fddd86bc4c208e859fc0a2abe0111841d32f140e3618d1aff1e339684131d00939cdc0a9395aed8f65af063951935b3a421ccae7fcb1b7c1b56b1162288358de7e2cb20678c23f6b841b2e4b2290c4a7ce1b8bb34d279553186fa7a9042d6d9c3f95b6c0c274b12f424919fd7ff61d0a9eac8518052e728e672e5dd827862cbd7e3115bc560b941e60f15f700f24a3fbd1e3acbc0534ffe096d9a690a662f46c7eb5378502a6c7d04bd470d604f35e6dfbc038b4cb5cd9b224ae78981044d8f48cac9b555e8ccc36e1c42121ca66e0f8911a175c7f1c20384c0d90b181cdae57f331ce79d4c470957aee424d183af8141560ac756355c791aba364e1e4cfe6324393d0bf89a550001c95195192d535c1bf11eb66e1aba2ec92cf84e4ee2d9fc4c1889c225a82e4e348a59849d851e9d7b0ead4e4e34544cbcf3953951f01502f4a0e5a042ca96521eed1822a15cbf06c21195c1dcb72e1bafd2fc087c2601ba7084d447e85293f08dde36ea816d6d27125302e94ad963fff1b12a8e8e7b85724cab9aa626b2c086105e24f3bfaa93103983af4ac0e51f5191dc9df67128f5cb40be002ccbd5d5774f513c6f801760f484fcfc5c5d8905feb3c4ad1ed1125687320ac90d17425a0df556b4bb8f094e6ee2cd3fd56eb032855c649a5f0243d9b94ac26415e9ce1a5c00c4fc9d501b32b9aa4e3ae431e4bf0f93319aadfdcd3cd89860f3dbf1afdf2bfde2e10de09453c48a0394244b57b40f20af88adb582ac692edc9228ae2e340c504dccec861c2699c731f1a78b3bd464eac7b3b68e315d0d4a345cb8eef6ae462c46dfcdc236397af525f525ecad8e1cdfb5a241b53ffbe5744a1ab54b2f49569efe94ae2a21edbd6a7749c5117f85dc3eefadb9975a47dd1e01e26db15e5db1a300cd7f705d0039166e14ea747a5ef523e498773beb4892d1222ba52ed4e68b1aba8a3ef4dae428c2eeefc96f3df4f8c2cda954c0095cea692b8ab4c2c7f74f2547cf2ea01f112c378703846f4797e30df74faadee60d3daf7d9329b98600a8c954ef828ac6c1a88663d3db1d0d85eb1aaed3a261d7ef25fcadd6e72e44dce62c2a40c34ddedc6d86497ba5a7d8c1e29ca79fefdabf1db9ae5160b5d2c0319bc13818b2cd7e7b3c67e5e0f501e9c7c6fa62aa035c53b378713cc9ac677cf5ee3cdd12a313bc795ca21107ed5fe6b3ee539502e8dedc87c1a8af255c8419e357c83cc6e6aee1fc9b74c66b9dd1ce13a99927edbbd25ffbc5562f3ebcbac3ec6ba9c57cf9998989922ffa12c4d3a278fe2b2116790f4373e33bfcdbcb7f80bb03536c20ffb4decfd72c7b296b44313a84bbc2fc3fb7eae08b6a08d7c52d6277e3ae8a14f360be5769c3e20f20c896ad9f4e6c7072d2d69bf2f27094578bf1e2118a90ff7c7e4c7108efa8507d0d5f6164e21ad0b5f6d8618673f40a94ba1cbc2ed3995cee949c272c3df3cf641dd980d37f5e24c16b0a66b5bfbe68d9914823968aca4cb7bb6382c6c1618a968c2dbf4a140e1c4575ccb504cd8429b566859fb07305e36b98444977374b6b4053678f2a220b5f1296106a0cb17ce361933d9e29b20f57a31df1592ab42788c61503ff9bca40ea5e7ac3410cd4cf650805ebd50854fb062c47422028232d28626bb46267a99623a191e73621fa46f11ec01e178b2fab591aa16c43e02d23def9fbf3841a327d6a26719cb3f49961a98649421b8b372f344c6b70c6001b687c361fc4ae1453d72e8bba8c49c291d691f3082ce21081bf8bf9866b6cdce1213f433398a18201ed1788a43fa572ae496f3297bf2f9d65eee95f7fc041be81b26c8f9b0f2f187cf106e49e64bb8471dd2e182abe565b6f780944d10b1bb1b792bd3463fa4743443e2a707d25c500ad4c42e49db4d3710241ba01fa5d9406a5f265a6ab5bf6352b86e911e5ea9437fb421cfe37982fccb3452ac794ac761f130c7959301302ce96e8d26d58d772f9b810a821f3d97e03ae129b1ae385e029bcac3bb5abe427d519d496217f24b3206981b7ec7dbe8fc22961fb04c52e1f034b3592c9c3a43e32e4bdb93c286f5cfc52e171eb745fcd7b23c5ddf848e85e7ea573a8c625778a1bb65658423afd63a253d6e8ee0fac75f3b26d99fc9efd1b855ac31cd387e1ff9aeebdf492fdf82d4daa34e1f1830a7d1bdc21e889decc977daee94d47223e833a9456ffaab747a295f93d8ea19049bb2e45fb80922415f1b725dead09f2c64c88ef49b33cc4bb893ceefa202fccd76a9abd6c3373f194689e12c97f8e452d87e48c5d7e3a4113ca3254792316c743fb1e7f70bf385bdd24c3e76dcd0926dc6c17f5ca6800b5b0ec8760e014376519bf0148037e9690f27ab6e7ed0ae501d718138e1e05aabcf2ae70f759f432330861e23adf753cee762dcd30b4dfe406f967647716fc936faf16a1a2a49d85bc0a38397688ea254bf1beac6a4feb9387b5659525915c8ca0cc7ad957077d2e5054e6e1947951f0da3cc3beabb9a9ea695dbde2698ea94b7f259ce8b28714b8e97fabc1e60ac20d8be2aadd05e9fb9774ea57013bb6db68d023d9388a149464d52e108a6353f677f9d3e8b6276404a76b846dc2c9f563dd5d720f04cc6b6dfbacc6dcba75001c901cb87d397bdac3228a1f53233ee08e2e420cbe5744b436a30fec1b848e3dc65d7575f711f895c40bbb2b2fdcbde23312051d7ca0da4a0a5972a31d965b222984c1dc4e134566e1deaa19ed8b23415eb3d65fadc52956394134f8fd437efd23891523104f362fca97cb890aa0dc8d5f4972370108aec4665b3b28bbe526d655b05e3b5c8077bb6849a09934cf2a042a4eac784e347143d2f4819d0e7341b8548acb09b794b695c7f22e3e024679f2afbddef735b6741e61c391b672a6424ce9cdca8653a6f67786416bff06e0741f39a004e22631cf4948b6bb24649315126aafbb5b31e629aa43ce6eb1f458e5ec3a4e842dfcfe70e1764e5660f9e7d2f6c3ef7107a083b67863c6174cefa965ac3a57869202e12d4b08e18f71abf27c8faddfd73a8d1a721b116812362e38757ef43684ccea475fea58b7ea734ea25a45b079155c8b4119ca8cde47e5a5b81d6c3053e481b7e993e8967c2f3f3505875ca7981101699256410e9d59d88236dff40bf0cbd20fe52c18640b35dbfbb002fe9f7f2d85dda6b1c49fe281b2b42975c8920571cad53a4472ffcaffd6d3318d507514abf84969918636f447f94f1143d2923d821b9c8c0c0e89498ff0b9615ef6d560f059d192112f3ab5f540946b114789f9cda85b5714806a7bbf5cda2c2d845fbf4d483d87614b9331e55ec44aed8b119aef5ab155cfb6290061e234b12e7e3e48533cfa11df70981db1103d563c6abda81937be98bc0fb83097c2c8cd51aad4f103b6dc122cd86b075f7a42fa7566e0a540a9318cf8d2784b0aa15451b86f87f1eabf297abf2a6ec78906a55617834487fca336a36343f824803f8955f97fabf752c62b5e9565aade9da8a5ddefd55093ec4792a3d81d415e30601415014a0d1a827daac9643fcc7bce515f1800626fe752c617e5e5adf2a89102b9a1329f66933f7fd93f9537cf12e601bdd2c0ee80770fe492c730581c29590d84195caf55bf38f74739d1caf064582e4d451121f387e303c307323efebdaa14593bbc7a2b2ace5cfe0aad8b45e13b34574dfbee1a413ab150333f4017939c53d59df43b192dbcd2ae194b2664089e39dafb1cb00e688b16213a77f842f4340bbfdf831332d8f94825a2c1801bf4c0ec46ddb87ddddc57a2d69288daec338f177fb3b7dc2245fbda83347cda72992aaf7c1d0f35ed064b7180cfe8e7c231435f9ede6327c48b5a87662de50d3fc112bb5469af19648f070176b172e396e6c4b3400a7cf972430a85a9ed06f926e8d2a109ba093ca5b9cf4f7cafba3ce94eea1b5ee67758ec0e978646718f7a3718e6236893f604672aae992abbed75ffca43ad1a95d722fdab30a5af53ba2e984f3e9733b255c81100a88ba0089f9d3909a12dfcad7b046f8ad9710f31a9905b452a0817308c771cd2d81c32683cda2924cd571f2ad2007b75d670cc2ad40b0b1d84b7a157fc34dc2e0b78b408fdaf4ffd95ced70e768648188d46fd9fd54bc54ed3ba0c946c76ad501107463ab410e040cfeb2fe7511a4f66a93434e14efafbcc69b2a0715283da9e39a9f6914075641807172aaa9ca2f057bcf083f20a8ec9364c11cd5d2e29283cd16755483017169bb4ea0170a1f54a0068042c32498ce1a95f49bbf7d643cd89d7b091f64527555bfa302ae42338880dddb09fc23fcef020ebbb73120ad3581e99d1acdc04a85334b2701db397ec30b5cfe2625f0a6bedbb800df1e03a5f9dfa7ed73dee2dca76d013a9ace08485d30b269c612ea8b5fc8e3086a90eafdad8c885d85f7a0b871c1a43798b6ccd91fb8b15ebe28667fdb433243f682065874390dbdd488ec81cb2ad567551ed0255c69374bcc9f737869b7266be311a07db613a62e83f7a78b43d4335b4d545f9c957cda4010e7d3e9d3bd226d1cb829f4226daa51f3461d1c765ee27d7616ca8fcfb59353fc3ede745571c68aaf8651c7be29945c26f4ecfe6e0c6d097df2cd1e832fcc0909d472add01fb6e6bfa37e3194f0fbbc1a7d16603cd64c24a060524083da4758fc23840a7800929cf7599267eb1f1e12890e71fbc49406f5ef4ffa3892b0fd597a6451e51c76a19aa32fbbbc913ba604d69af2a0d07c45564c3b309ead5b32b13acb7e8bc43624a4dc74e85935e924ac7f4ded38d08f70aed59788943db8f3b3f0271317500b76814fecfc3a2c415f5320e4f4ecfe92e7701dc68f23b9e9d5889069478d63ca8295acb41a2aff311c8c8420c861d8c647c012c1b7fc660cefd6f2a7bb8c546451788a693110b781ed6f1ae1308d7aca2afa69ea8b4e8484047d377aa170b174412828b5c1e4bcdf929bd0a53780a1b5ad405d40e49e6caa018cc262f2d29485fbdd0e05c5a69dfed394ab51f9f2912bebf523b9ea35d2de315ca226606504667747c3bd28d995e47f96d95782943c6125964ce09cf7e51542b41601ad8de05ffbdb906c76cdff0e33456ac9237ffa6f6cc13e2f2bcc6c3c72dd61fb36f268ba25abc1358430b3efa51fe98e11b63fd69c48628c2f53ce4a7aa599ed9cc4d8a8626ba970ca088ba94f3b759edd8ce40ab8b9cdb53e0a3079e7a2478b7dee4829de1c4c69f269b4484bc793cc51a5ec7bb5c2f4579b728ff8312d4b6066e1aa22e7878fddeca47bde41a79f850b7b4b0f5db95af3ed1e0519f617af46421d586b1ea86f27f68000bb0d1523cca0975417c9555aac6ed415c6d07911c73bbf201a2749b45bb5e3ab8677059ef49e8debb2a6d6016fd8424524d5d6b163d798accca617a24f7c634ff63b85475ac56007813230476e91d611484200564dc65668516047bc90cc2977abdd4c430de5bd9692dd8de5a06e58a8de1cfa8c48f86c6b244ae6400ad6ead85a6c4d5ceb48306c2e5feac591da8d29e0a6d40530eb8a9c93e01d78e8c141f00e3012980d27279ace5b91f71e49d60fc9e0252c8f52095adfb5339c1a191c86f7c916cf33a11dad7fe68abe3ce1fafcdbae4036ab1c98f34095cff7bb3350b2bd71489f179f675f33dc8e18f37b80d221d1d31acb04d845ac7a239afeb04aa293378a2794a73683b92f035d7603dc887a5dd3bec176ff7ca4428cebf6f412787038c6455e3ab41ea0405b9ccaf6374776b20a8ab96267645e63aab77139023595a7c56f3c2bd27431760cff3b6315d99bf3715dfd1e8bfa3ae6d1fddd55da85e2d93471ee87b0b5ab393d8ccd1f6bdec0be4dd1f701be5ddb566b39fd24349ed37549ee8cf0e7eb40c6b3ea42cfa46cf74cad7cfeee63ca40dbab813bb469d6f6a4e9deea07645622c9c263cc8383d5d8958d5c586d0e15811dc33e75e2fd74417ac0e6627f1bf873ebd7c130a9f0fbd4511eab80deb000508a490cb5e4acf47552ea7bc4f8c07265ac2fa6b888b97fd03e2f40cbdddb81e301e1b3c14458c65e0213ccbd5187d855cdc5f2ebb83470a68caabd178c4cd4a4dbd430518baae94f1c5cc6c8c9ab63188daba336299fdd54ea5fe2c4310d485b55551e2e5029808da15c2f8a591514791f8ee05fd71773b9b932229b10e3d7b9e60ae9ba8c577100699f2a7df259b974e4c974d75fd9339c15f30de02b8a955551698424fce835825b97cecb16bca8626a74a3bbbd2104dca47a9e6a8e1ae34b52d77266cc417de5e5d5ed2cbeefa1f47ea93a7a48c3442a669ba43271c3ceb692e4a0f1f4751e209fb7eaf78a048614466af39b44b23142f4ecb74ec8dd40823b8521793e17ff4d45de03db307180dd9e95d5001d3c267a5266522c1762a4bdcde11494177b16d9a907ac0489de481821d11b3a432c87695d401f575bc621d79268a580290d0ef69bcb95e63eb5c4e13827350eb4131d28cf7f580fb3258ccef077dc1a5a4b89dd7fdcc75fc01c8df01f7faf3760776e522c7b1cfa98faa85d44093d1f69631e74126a5c6a59155958b12a0cb20cbc6f8a3a5c63179cc9b70e3bae09555a08729524dd7773ea164383471f5102af4746681e01bd467cf3d37a4d2535d4309a53d26cfdf3ed6ce8956c1e6811fbb6a4c8e08d30291c43bf7126cd9953918aa356387eb9df4b907a00782fed96856635064494efc8ca9d1ecb86f714e5216ffc3398e364d101848bec80c88f5bd34cd6764bcb4ecaa634ffa50a6070b1c879fed82c35d9bf39a459c0a1ece4ba8a0bb22a35bcc1b8a4d07d3590fb0862dd61bde177385f3510d7cc7d147269daff2b2e2922737bcade6c77aceb5f157c9c745b668cd011a366f77c243f4a9d7efc333e0087b517690e9b5a89552db3d03490b4c5157585e0114f456ca68db4c2907146c237264fe155ad3a2ce6922281c5a29a4994e7496760f8b8635a00dbf04d600a2b020f883ccee03437d01eb5027264319ea823fd8319db1cc42f672c3f6c234cd4466dbca2ce05a30f1fcf096a5481e0b9502c220f5643bf4fc9298d7bba158257e25c1da30911c4379e8c1760dd37d96933447dcf62b09af97cac1b286a1567da48d106074bea413459e774b07d8c395624af07dce4bb34757f1bf17bf9cb383d8c02f84cb88bf58d887fcdf2122b34a308da55d0df05a0dd8a7c0133399af3403bf2325a5b05cd211d76f090bdfaaac5b42b809b9f6cab96e73d81f821863c8d5316968db4ff96686256ab8395acdd99db6f98a432c17c9b9b0d413ed7e666bee4ec34a2603f676a0e431016b22e6a83e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
