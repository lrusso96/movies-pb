<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e3d3d1b5fc214d0ce12e480de9f920039535ce9fb8d52c0d55f2ebb31d2f3cc60f629493886b74c3ed570f465a4f33913fb8a0a27e44181b57a7569208f2b206b2bc5bf2a2e61d595f1b4670fcadb5e81a3d29c1d9e09f36a5d8c535cb0df588b64b40c6b9a53db08148fac359673a9be0eb41cebab2a79849b898276d64d0373dab06effead99e5d1bbe4a6c0f7c520fc0765ae9bd106ddd09b434691e5cafafab3125ebddd500cb0b7adf8033eebcbe937f9612b1c54a6f8fe429ad85542901c3172385ea12b7c62b48c7078972b114cc5371c919d082cf6e43596b89bda92f1187284b59f887cd1ae5fd2603130757224e0d1db1183bec73a47b8ab8deb41d0d39be6daf091ebca49218c3732d98ab04404379ca2befa69a95f4e901e0f5b7db6a28fd7406952fc215c2b81e2dd4a2b024a109bbf294350464030d91b26124a82070c344e6b1d9bf895bc4c2503fd73bafe01dc92d98205b1ee10fe917af032b2e722b0467900cfee0e6e4f4b6872dde798d917b89d7c51ecbddc10e7d3868b75720b3b1abc7f6136aeedd9ff1b16e2963406717e298eda4ddb70ba1f7b2d0ac96f1b5c0372172ea7149de482592452fd5cf8d0507b3af7e7da3e06ae206128c50cbd9a9a81ad5c3aafdfef680fd3e8fcf4e2336c6a3052b0c7d96bc8d47b4853cd7b8d2286e6b340af1fb065edbb2b27e8ec073f49251257a12b5c2653d064ed8e3e97b264870267c63cfa3dedc0394cf63df21f6069a6b2228cd517ced0bddc30a70a88073d153cc44df9a6c7a51d9c7ce74e2caa4a2b037da0f6d318982b4a76f3c2e0e22e1352ceb3009be8a86ace8f63f790e6782b6c9982019d2aec606375502c3ee212a189601c9f47779ff0c01529e5e3df076a69a1a352568d0c44244ae1806ba8a512e64d6ef363f8c8a657267bce78cc59370460affc452e1c31dd1a3b5b0b3c7cf00609c706837eeff718ab4e3c8b211f3016b7da4d92bfff41f5c302ce81e0c56f5f24c6d6a6552ef6ade1698ec37627a06db4612b2a26786f306b567b8048d7ff040d75fa8ce16c39a23f33947d87a015debf9f3d2f3348d495269bbd56eca054f354be48a0a9f04f7c99e79f99cdafc7d80367b11376c8e67e9a1081d323e3cb72d17568d3d05c8a568a9a6236e4b1b03e4e21f433102b12be1f9a2cc7d8658904e36f565f9c8a27279e81975d91ccbd6fb450c675d1625b0df13804caff8a5e01fadd8ea4a1f03e1ba4ce0ffc3e157ba4c18ad2b2d5d530f19fa7daf08978be7cd59bb102fa22265f8a1240af9e0635e25be17cc11d15594e86537c3dcc58649b28da2267b197e5f653a7413b87a44815b75c67ca5e21b1d2a6851c5e24f888dc245932892456775c571d44298dc603245c1f2c74186a7a1138c9b029bbdee4e0267e862aa729e1e0815975332fec90e538c788c611b3b15d8088cffa3fee08fe3c3fbda8b982bf756bc28b037ce3cf6f71377825a00ad21384704eb6f80411515c828034f6cb0e77472a93ab90634412bceff0cd42fec24ec4efed8ef6e7048fe7a25b029dcbe0e898e12667f4f2411e3a6ae9bf2be5bd9c757c9e4af30693f03d271c31f958cbcc2c4d042ebc5ded7dbfd4fe069b0378d36cc21122e573eeee91e0be6de81c67e06e4f7a1f18cf261df61f71c5e04a5fe7ff5d5b0357f357fff67514a81ec503e2942a00e973fb5314ef389b1ca3cdc25c0e93eef37b7bf152b8a936697c7e4096c0e77522d1a06c32b8b3dadcb058cc21604d40a656566097d2bcdcaedaef1cbeab93bc1398800b89077f224293dd9b94315306c218c0a967be7c4447c0c05af13a23717de9d7cc403472c0374a15dee0cfc2688e9cce5054d265d257f309b01dabdbe13ee1b5e4f241b5c47a9e2cd6b3cb998ad765b348eaf75d857bc1d270ffd77af049dd4fc12fcba56626820920c9326ae151a6d5b85c45b0befac8bc3da275209a631a0be7dff61302c4835a5b742f1796ab8e5dce6fcba26a64d3a347dc20d8c1cf607e4fcd6759ffefb7ce0689c31608bdedf531710d7efa0be6370956324ff897978cb702e16836e4a000cb02779ac15d55c820ae66828b584725f5a36660546caa77b45b43728c8407bead3ee57351c30af2560358ca23f0216a5f42ff291432a99819758f438b58e6ff49a9874624ff671b8e6a8a96faffa019720767c1f950f802a410463f2209d32c6973c8c37a20418eea4fb4b5ec213d795a79f7abece5d70f3592c60d3388e52a02cfe55f485e6e40ac0c3e2963f7e7ea0d61873afc8f6d7b59f70d7a1924f28eaca5db594675bd2ad958424a650c19719d5a2cd164dc06956f8c515d972b88798fa216ee850b5a34bed124c05587e8ea814238e8dec1bddf0c908729287bd3775679eada8ac2538c3cdf85cada3816c3abee2b277ce3065746960e0d264d1732391c381c189dd37de406428ca13e512d88a408334b245902201544b8e54dacca46e512d631656f631856d0c91b1b482fe28fcc7a2e7b61021323c5bfcf8c8405d10277f1718930e2ed86d2763168d0ba309fb042372660a2afe83d3a5846a04becf4974f87b9a193adf2b09d33a766c6fd7519c5fab66ee8beab2dacbe4124964eb85fc49bc76d98ec826def160cba48f2087bddecd0378cf4b39ba6d9c1531ca66a99149617b6f8e796a40eec4a619f14425d2f374fb68b01c530e75e6c07010c1cf262047643ea6e971da93e20d3f36bb9e3e6f1cb8535cd9496ff2660008a0b33040f3172dfb4def19c8e9514af812205cf603a0eac85d5ba318e1a64c6366e500957439abbce1eab7861a9c00ce9b85162b918eee79223bd92e756630c89626f860ac9e26936c06a7c40d2ed84ac6e0d2c10e58e257570455e0f84188871221f9b8fe87a35fad251b937e0ed6c721196b91f2d5f115680615cbbd3100e559e21033c3a934d57a00f041756c02177e7e51560cfe180c4f808c456558f5a75ec7664088493b8abf95c2e744b0f4eb088141850ff9719abe3db7b0fc94f6689929905721159d37deefefe174a6375bc226bae7c4f458b5adc6750477453bda39827d084ff137b7a5fb0d1b2e8cd7e0448301afac40ca0c98f8b0d429adf78e1d2d3c34441ef53ce7c192ab4caee516adbcf0ffeea0da9eab1bf875a6aefc7f963a82618322d919735867d0112bc2c724a37581ec516a946873b11552f75e31be5aa182a2009bb6861799b8e0e92334bbf233b66166537c18de928eea10dc8c8446c0066593f7414b390f8c1c9b0ce65859114b5761e245eab990acc387e4673e4c263f44ded7ac88aab7b7b51692a0d088906b53ac935b7726ecddb3a35256c688048c486cebcc65c4d7b62354d436cdde68782edaa11be964119326e42eb8cf9e330d8353ad31b60ddfd2f66df4e87de970e76203e13cb154f670063663628ba8105a694ecca1c1c8e42af3ed17efa2ad736c3456706ce5fdbea1e48307496efd3cc232017dc5794599cf2b49822d7a767cabaf581cec2ed634c53454268c1a97de850ba201cdee17ca61d59bf5d3e823c81dede5169d76131d9cc6f7a117579cf0bd407eefb294983e140a8602ee8979ee6b7aaa0a5f64f9e92ba8a40d3d20dffb59269a45f941c3fa7c1cae395b7f19126b538956e7f18e673e8c6c0ce1697a2b5e7b44d0ac9b9d113cbea6398d42ba3adb343f80731699901ae620fd7f5db2823cda892540eb0872fcd071e35e756f7d7d9badff61fbd7dd89686ac0ae76afd3d65d43796c5677490a3538cf17088f3b8d34e34bbcbcc90d163349e877e07282914bbfdffd417d3079e8062fcc73ed357bd7ce34fcbd11fd4f11d9b4737d48ab644a1a67d423b5570cbf3cd79167111fbd6c6723440a72c0b9998fd02dbe009722f0bf6f59b29e2f0330fbf18004ccc3b3e36a0bd8d4d8c109ba01941f7a1852ed97c1758e552f34e7943f070f79fac07ebba9ddcafa848a302b645737e3a87c4fb9740865ac3483f2a9f6fd68909b714e38fc07b7122f88804c9ffdf48e8be4dbc06eb5c9e4a76f3f4dadc89fc30b0a3409c94f01188732257af83f9313e87c803ca831251eab2edbd2124f2d18e96cff24b6080756c36a825a633dfaa4f9dc9500abc5439e90ac4d02795435918888eb6cfd7f9c402cd7d32a54b3742b53c119fcc846a8491aff6161e2df6e256c053f7d1b59c644e4692ee9f195efc9b66d064568a77064970c5deda48e157d622906477cd943221f26124ffbb43bcc44581d9643da7dd1cee00262bad08b258be9125dfc8c66d6d4e6344ae611753029bd575824fbeb5df1236a3ed6332b186456e060e35a5b184ac3670a3ca85fce4efdbe6dfb11459c2958bbade63748d63591da87bb7527e34ca0d38c7a1358e4955c183f598516f876d519bd8c432051a1e6cc7f0d7ab87b08a72df9ad41c86290b58865e45b8682c3d3f9ec0e2c46e1079fe94d6fa7bff6bf31f60e42654a207469801a6e12058201245845e9136a576689cca6a9e2428f2c4bdd68a133e5bf678e15a0f50d6ecbca362a282996a184b9ee140747f99e45a97c20ff135dcb06430d3cf5ee3578c9d027914b14b043a1c73dda9d1e65d1cb23c7f5f98003072aac559f0f83defcb817c936be0ea71aac4716feb24961289eafac87366a8e7885fc4c242ce66e800c2bccfb27e5ad1608cc0f214865746116f159ad38a836c3b934da1cca60074f35e10256e267310e3725d3c0faa26c3b94bece2394fb2fbbbb171e632225596550cb2093cbf653bfe23a228fd6c1863145a3266cf44e206744ed12f330766638124c10ca7b67493a4529cc7e6a5e88e64b95d3f55a7c665d5d745ba0422c2b55ffcf5692b9e0dacbf7181edabe0dc0e871c351c0012ee6882c4300c891edce6410394ea2906556059d106b051e115c859d107c7c6fb7e835a0d8a4b70ccf0f9c69dda899f67b14fb6e24e865bde20c6d344977763536f27d335407bf67a60287d7d87cd1d8afbe0f2807e943b2dabd2b1f9689ecc44ccfe755956396c0a1aeaf4663f69d889b141eb83d5f1421abd7a4c8946fcc90f524c2ada6e3d9daecacff790a670eae1cdfd9f9750ac07204451c3d7e97f18a46c8a99b80edafd4ebd558ebb43b560a99e2d8113f11250b0d34f23ec549509031cbf177271de32c4d731738e33e8b8a486054786bfe76bee163036ad9a7c0dbfa3209fc022a0b75e1af9a9ef3ef6df912b13c86ffb2930994ee92a420c0625e61799bee416a0c2b37e2ed14a02fbcf327cf664cae7806024f11b62850afbd4ca93ede0cbd3b2c18d75cfa0656d2db92ca33fc97807fefd5cac15f06dce633d991b4bc04e21f9268ab952d8d0626bf0bf60de88b8eb2f083f4a016235f007674d452f432b41d628b573283f0ea1a998f032e891f00962b891f09e98ec34c29a4b78e5428ffc8c37ea160f00b3d23c6854ea775b697fb96aa98071e2d9f16f50d6e6afe8bac8ed32d07d622d4551cec59d0d7b47bcb625925f91eecc212d47b4e0e10bd65b2f4f94e59a30ee23123a06dc2cf7515b2774b13bd77ec035f75f9650c6bda425a1fc20701325f986c50c0e6ec75b354436c8a76e999342585d2f6b5862d62526ffcb2199d657698ccf76e018480e8c8c2514c7033b4940633083b6bd74bcfffae370ce0e595d0d8cc0c7284743d32e2a1bc5387769cdd21c97633a0a7d58da6f6a8d2c6a0e57c82800e6051b5db7158a44c16d90d8e2aea36797910b1909b2f6dd0c65b09fefba803743b23b931607ec4847a4bb425adcffe5faf1c671a59dbf61689342cf99070c865001049f9dd6d1546a6f35aecaef317cc449eb6f122991fcdb31ffc0db5e46b682b6028c3c8fd13d7cbacdeb518ed2ae324d6561f41cebf33b6ebe83b9f9f4e9a67037e72accf2c58c7640ee3cb80a5fb7bd93db88975018cc478d1d8c9699d3a3bc9d1b7ebd27404a73bbf66dc66221398e17c871f4971acf1cb4fa4164a7b6f74d24ca4ef5833f7d032261d40ca891e05578080231f8ba66c3bfb860b1faf09b0a8862b7ad93e622b4d8bd99fd25a79379733788205110032b693f96398bc56fcb5962a68d42547c0aebb3bb1a56ddeaef500169f6761ef30a18d78314f201feb5bd9cc16b239e87f93eb793d72dc024a5bc65d75f96195d0b98754409e78847b53605b3fd486b0ffd4654ba415a3e3b62f4e9b96fb80640b96fafe46ccf6c326ada9aa594de9ba55eec427bbe8735ec7f3f842193dc0c1e38bdc6b3c154bf6dd12a6552fb0916225e3bb04583d21ac03abc3fe1f1e76f3a325366f873491f4a8ffe35e4c0e1837fd3177607e333eeed04e358ac5d781d7b09a61f653cbfd44b31b6107edd1682a138662cda5222b9e1cff4e71df9136a14a68f3f1027618c895740c761084fc8bbebe3afd54f3151cab98ac09ed3eb59a02103031ae549f70b70fad6d43351d48c57587610bc2f441fdcf8252e783e0d6bcadf82edfa919c2545db2d99a61142c52b980c2e18ad99024efc713cc4cfad64204ab018d436948679705fe9d5d8cf156ba402b93c1d7bc9ad6cbe01a830251ae4d1daab17223967e3ca4ebfd7ab18d08a2e874c29bdd6101f3ca829a54cc20b91292d18c325d62ee90cbca54f26b4891a218c3d71dceaa2e6d95e8901841f13a1e70e217aded06050dcc2aa4f0470697a85734bdc99e8830d5c243405573964c681d57da4e7476e3674d092411934ed62a63197dae2590259991b5607bb76fe768bc1b84105e03b133b5594ea508ac78f01dcb6457eae6a9f4d5e41af709ccf0f2bf779432cfc3197d049c2aa48692af592a8b5432934de0702108e798906366d17744c6c94f96143e125b722dc2d440d124030ca49a7e73f348453ad1964a7b07e20af15a47ca8634992a34c08f25f45edec7fbb68334c2951bb02b7c58db3160fddf2196181f97e162697101ab639fef902fafe92b001510b35ea17c0b3dd7e8ca3d021f973ce6b7f6f000724059fcc29c7b41f58386fd242905a6f41806afa6f89d965bad2170b57bf0a29ac5a05931f002ab91833a42666c437b333a28d97e245b0bfad062dc8943092e7ae47a5bacb602ca5d6d22e58eb1edc8e85b888d156475815caa8b48a6530a3b0d8183d584ff0a6d4f8f9737c4f98dca457d500f82c0d9a30dcab3e2e5ab9e81a595d0cb011e64e6d24444e976d3c99294ad33a66253f7331614defeac0ddcdd988484acad052875e0f8ff9d9426868eb6a5522f26d0344dbd1fd1b050a55246b5d9c7e7500c55c687a3dcdc45aea77bf5e78af22fb7636da97134cb1471bb4d8cbf2658c5135f4baf3d2aad6aa4b04f1f1a22ca6f0a9ed26052fe1a50ac89f12a25c33a4af9d9b571368e3f07c08f9bd1e8b52ae567b73da8d15b616bf076b7027d94ac7c4e0f077d39b77e3bafb6ee98c7a13b83fa37ad7232860ccdcc01d9975cad7253f2c3f195c3bc387d21ea33d90db2c2977fd9ee5d5f97dca6538ec36d0bb865333765d68393d7fd05b018d1ba1817ab604fde20b29a1187fe7682d3d6d70dfeaafa71780bb5bcb4821029a64179a1b72e6486ddecca5d15bb5642ecdad3eaf27586c65ebf708e709e92dee55ba8945e6220db379b679c42ffc2054aa9753eb2fb7d0af7e8d1b663ad51c6557dfa6725c29bd9abc7ac2ab4beb67a56585ac3bbd90bfbba8f01c350a0fa4be876768977fdb217bcf7be382f601f6f5d2edb2ff91e92e28b1096376c7deb215ffb91b72fe0e335a139705d5faa18f681c1ab24b40b8fa1692bddac3f7be2daeb35c0b491ddc371fd26f0835e9be481e0136c369acc12067d42b85dee7625cad5c243068b6a7424ffde1b220bf959ebe390ad65502f282a89a14d7f894055db04b2c7a56b66657eab4ee9173b9e2921ad3f46493b6c14507ae95a87393dca17e47301ebc6718715bfba6d0a5e34de25c6989e006c76c06700f21d52cf174edb13d7f6bc95657bfbdceb626f90158c72a49585ca161825fc5a781acc6785a4057b8945d02a47ff41f6ee7021f063e665d1bb903106323cf5095dce6cbf25175a719763e10386b0090eebe3d373316c647210d1f658466df0665bad94d4e43b25ded3d587167876965f55ffdd732bb83405eb79b5c5003734a106e3cc325bd47fe3051196371ec8797794943cdcee9c8633f1fb493e9bed1ff7d8995bebf863b630c6fc68eab9b2876afa6a1dfe800e0e0707c2fa813590c27b94cb98972bb28d6638dfaf4675d18f194445a1c957b06a51ee4618ae2e99d3dee8fe29541b0eee8b4dd5506a7859707aa2d92e1265bd3e067750f4b2b0bc0f8147437530706da3a6953429fff73d34d6ca19ba3cdefa2a88d77ce5fe7aedbc11313b5b76d3f5b6dd358422e2c2db741a9a4049ba06bcc00c3a8d80e815c0234f24c181f3e193afd71ba2a980e59f8850c830c55ea4ddd634fc809ed7b0d4e982c4e310bc6884e0d7f097bbb60c76a43ec25fdfc9564f9cc28d8a2915708698c44a7f79b41bc7ab80957dd7afd5986d417dcb23999d3d23d13f3e958752810517c6177cb6f544bcbe289ff6334c975c70897f727418490141d74d7faa2a07119e114ea0c80408519d5bb61b7e47f6928bdd28360dffca10a1a72225461699278134b87318fda7ffcdaf19cf9ffded5ab559387263dbeeba0bf7a2830f6239f4058514c4e9096024aadfd79a854d13b57150e4019168071bbd708fd99f8ca32495079625532582b56fb10c13e73f9df30c87512ed251be7eaadb5b863def82cf0b31a65453866d917af25088654d8429d57ce367927bc5211c9188615d57d3debcd3d8857c46fa80cbf62d29f4913c8a2515464712c0814e5704f502f74b7ffd5c699e2c774eb2ce270a450554c92846b86b5e12f400aec4e8cbb9620f1e4859401b451cfa3b022d1f822466a3717ae142484350f4c3c51e0e80adf836d6f0d29cb4d6b9ae961ecd30997686054064e7dc2cfeb3a3f45c30fc20cb04e1f63e753b0bcf7c04f47b6cd0c5b9f074158b0f44d7488a96d15976d3522bcf88fcb4b61a0f0f82860fb2b41f2c58276d736fcf8a633fa2579d28d494f05503334637cccc15b17d2a0cab2614e95078c4455565ea159ee13ec5bcf45471ea9c8db1eeced48a4f71ae9a2e620d5f53fc22b60da878d92ae69e4eb7237e97cd48121e2d46fff5d55052fc8d44d58fe14acacb24569cf41fdadd744d232c9948e50f84553efffc2d90c7e27dda297a5964857dfdbc20e3a9d57d38030c6ff23c88c56999edf7b4be8c2160208f0ad3ca78c706807b555a91175dfc82bae68aae3b53f715f4e085def8f063988a757b88b58e1e3b4e57f76baf1a1fc63c165ae21dd1fd3f5aa756f347588c33a6affc01e66d350df6b5f8c8cafee1988deb5575a866b44ac5e0842b415e0de1c5d032a86359670ce9644b9b5bf69eb47e72f156c323f580a6c16ccf6c5a2e65675b1d2a6bf3c838dcc9f0d5c26cb4cf0ed5c2fb8d6fa57e66a4c323c32278cc8ee8fdf60afa0922f6428e12bbe522861d967c42d8d19a63a7b55fd50d23162b58e736421e909c99ab411430128b71c6ecec87e7915a04a7a0cbfd8ec765dd1bf94a7e6ed5c8974a8b6a3e48f0a3715e6c8ce2d996e24665e0f3306069bfb55b168e0abe5e59afda5b53c48feece63db65acb17bd17387e548e6a1476a63c972da00d2e40e8597d127fd68b389460e25dae24f7bfabd0bf766c2f314b61a5a70fddf9841b8b876101b4cf8308e6ce66313db43eafff892fcc2d7a7f9a3aaf6137e3d8ff979b64091e6d441d4ad75c0a1a13fbc4132296dbe407624dac21fc0eadfefe8b509f05dddbffcc0c3da32c242f9eca56991e86dc436f2388f148f4eff4d74909c6a0882e7729480161dedd1dce1c031bbfb4c81e0f1088206ae3ec742be8c844c8f1c35068860864eb08a1052058626fede8436528f3fcaa05a275b81c29607ed73fe2c00911757172be613035fbc79acca1f761a939b21e2566f07c37af18f4c5a4b274702d2d2561ca1c84bf9d5f682f213aea946676013a79580a7b6f1d15aeda47fbfc1bc70df4b8536d3b4f43e0eb7a4121175f6baef48b674f18d0092a270256cf3186db5122d1b7f7c36f56022b841cf0d166e40bb49ba8368b15aeb32ab943c039c12bd1c13c8d9435786c1cd36cc528c47e73421e952b919a2c1a8a235367adc82a152ef55e1e4b73688b0a50df887865531de5e7d16ead5a1850fc8596774224fd4adc481788abaa0193e4393ce971bb5d4d46976e6b1ea71b5b664f23690e23bf59b12c7fe71fe3d9a1dfb7c2117a8ea2b61cd468a8f7ec9b74283cda512850dc7a6a59c6eb6f15f45ca3099328d66de073f093b28996fd682939f90444a4285b32a47275fa2cfd3452f64b87c93f684d7bd3ad9f7628b073005499d6023cb1c05ffe4bb8d7c1dd27999fccd97a402a03b96044a61539f3a9e49296d34f6d0ca696c442a3049a72bb945ff8231888e0eca98527036f0134139b9a2043dbb0c7d7f9c35c3c8c0057f2fdba027296496454675b33562779f1b5cfd91cdd88330671391f6f46d6afc4c5265d49ed72f50f60935d38317d3f76701a1b732e61491635cdb5218c20d517e3999a1794855253d0696e69754f6d0c197b64eead101249b118201ac485e228afa5d4c41aa6496aab551fbe3b5f53f8455c90d49e06472c776278086b10475f86c39708387e756991f88ae4ac52f07c8cc3c7b9419cb0ec2423555c10db53446e295bc1e7e5259029f5319f83bef085a747fdd747d660e924656dd382b3ba5e85d68bae45d5d6dbea970238daf9915294d6e44bd19800da8816c176a118476bbe154ddbfb53181d233d1aa6c5e1c1bb0e0adcbfc2954398b8316ae6b070289bbbe5230e904b790a88f1c8ee16d4807be68c6f210bb8fbf8789fc2cebc1a41a44086fc69996dfa18a95ef82c37f98664d128e2699ca279f2e0f726e3a780d95f6ac9d8ce02a251213dbbd111c7612c9cf00d66f267196f6522fd07c9480585ad8de36d82487d91d63020d1eeb44f6c91992eab72e2af38a312ba4b6f446af15c8b93c5265b550d31e9ba2784e57e8588c99519f61827b0933eb5c937e80df8a0ac322b3b343baece9fe1ce306ba3780fca6c077743a6877f8a5d9e0c16682513cce2e385ea4cd5f078cb4d7a2513039fe28e013b4d9032aa8f7ed70c1eb8e60ad99af5ddb3607d1bc3aa4ca340f3373e196abb476221c65d3adbc485afd9accee0536af0783980bd828005d8acac3866a9214d2c2157e855954636bec3afda19c7747284ef759a61557386bb7e1d1ed4e7683f52dfdd64beb404a7aae287f5c39ef7c84aee7100a7768f667b1f2052df9cde8f8f0fd7e5080fe1f678e803a2130f75b4f2c1fe907b91970299fb4a68811cb5b3f8b05aab5f63c21dc18b651c593762ba0d079d4b33a390ab2d6e82d0a4aacfd369669ce8208f91c237a8f2ae5628677dfef9400e5c5f44126e59c5342dbdf22cfd96caa646855e26ada58eb7f51373f612478964895b611e3a838df2ff539c61467d59e7030387fe95c370e83f0edaec00ff9e18d016c968a16d846475879267393f911210b6146e0c51c7db1f5f1a0b93639b1f6dd60cd57d1a590263e1e80bd3330351032794d73e628d94d6bd19ac9000d15a2209501ab84e0e09746e4db15d27498f0e915bed73da99d74c3192c93e3e01f3ff557a64ee38a6f21df9e1e136e722ceafdf2c714679e3e819eec0a656c07d0d91f2617af2928193767c679b0fba9f0807644bcb96991c3a4a8a963db1d7f67a23fea368654396717bc02974a883e4048760f5640efe8dc5dccc8627ea89cd64a4eb980cf5728700b18c562f2821825e973e17c4e645a1b604acc86caaff00cc701cccb67a00aeae553059a601339c31a6d5b2a075320612d2d9b08833e65a1d3cbe7dddd8417886782c4138bfb5a2f334030a548aca6b277c4e8a664c185850a5f39824f2387856b64f89c2af82884afa408176ed583575844b1f1b83fcba9ccf6e080bed069860536dba6173d3afcf433776246e0968a86777dec2b2bbb7b1cc085698775b966d85dfda5442b9760b87b90d3ce2a3b3bc2d01b216f3959c5b5e55a27d3f8f0aa4aa42f756f11781b0952022267da7eed120f9c1290aac45bace8babb8d69617c1936e65206b71df08d64d6222c096e6b8c603f4250e7e2b4362865733aaa6e06becb95dec6b50a17b61bb7918c540af3521582307396d62bad8232685d13272e40080f37e6f2f3447a48e5466e40116b9ee2ffb5226fb044b9d00ca4ede9d29c63907ce05c485aec8cbfdc0a10457263121e8d38227e34b8259664d77589314f3dfabdfd0a1dcc52053c856d1c00e6c51e7b69b382df60bbcc324eef32932e10dcdb6afd6ad1d4b3530b1675bac64f20250841ae741e095471bdaf6f91e6beaa13584d8d2056f5ca6e569923dddaa91ea099b739e84a48b5937a7e0bef15d087b9bfc2e18d45ed1b6815a9fb9d5cf688e903e16489aafb38882d0aee05b8f095fff1b9c112727852a89d8d18a32cae0914b61ea7b5fe3a5462fdc46e6f148d0950c2ec56cf9293b0b1d98c450cc50ecfd39aa251076c21e5ed53fa3e909e6753f0875eaf24f896f11dda451d686f1551de674e114b42d46288eca025b3415a789b1fa6fdc98723cc37b49d8e894127cbf8805808c443118d255b4cae96d36cee3d673502cab2f1056f1f0571ab3b90654f733e8f70eed410b1d788d24f7f4544dbb27879dc8b24ee8c63b215f9333cfbc97ee4974f88f51f8269ed623d44d7bf3a5d8a57645b8cb154b1e6366abc0f649ac34f0190d785a375bbce18a5b45ef8175ebbdb0d80a1440a5404a586315ec077ebfabb4a853120f9b424c13688cff63dcc93d7eb3ce748dd3128562612fba734b75abc897ac8aff7dcb307dfa814dc5dd15e3773b8eb93deda6dacb484967fa87da0d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
