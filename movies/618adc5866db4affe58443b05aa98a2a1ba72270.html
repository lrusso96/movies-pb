<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9e066c3977d926ced14de0d9432725fa165e40da8047b30ee165aaf7e149904eedcaaace91b3de74b4b479bb636b24f7007f867c97017e13d915322ae512a6ebcbc694c2ed8e967216d657e8e26aec40522be12cca169aa869324167c26a298e66006676f13dd8cb868fdeb8f53fd04e38dd3d6de9dd45a1646844d05116ac7f547ccf342410867313efadba03709eee4371a6604027a3e72d6fcebb605bc731fc3921c66fa273fdd347c87d4a500c2767671cf66c5acb69c2cc595cec825728fea958b318273c2fa09c061b3e7a00daeec6039317f42e1b1ab00c24b29c56128737a73c7e2172bfe5cb63c7d33a815f1e86bd9fe64d681b32430c0648aebd0ddd70e22d8c51d12106e53a46da5b791caccf7073c3b70bf10c503858bb9c32e3e0eba6b95a5f4d4c759a797229d59ad49b1a0845d2d5073af5b53f06b53ab5665f468d57c2b0c93227db62507748f60e6b755082ec2df0d42bd7f949d0deb80a34a73a2e21d00f70dcb395aaa66bdba3747ac1c686973b58b4ae0a1a71d4c1180d6f4d55421934c952b6baabef789330b6fd28c4c06ceb076b8638df6106b81e59e7a6482199740f6fe2b320e3618b50a5d87e2e61b8de3b012018716c970cdf3d4b3402a22ac4bdee5a256a0da60d0ebe9b316f651696c1dca0d2eb7d38294061002cee1c454caf16f875454115408cdba9840be275db512e2e0bcee3aa83e36c15afcad0bbe45b3dff1c732d7fdc8e6e87ce89e2b7819ca208a783a1aa31db7c7522da6e9a441aee99bc7be10eec4f949b7303aff4e3eb1b6898511a3b0f65ee5667841970f1d0f42ca0aa89d9c912dca69da0e8bd32346dd71011dc483c1b00828b7b52863b0d77b8101d4f7ea5974ad0db3ec4b26b35a5b1b86ef0105884c212a62426b2fa7d0f232d9f9ffcf64ce5777e6ba014f1b933c5f86c14384ff7c4704e7428192a9758899f1424fec5991e75a7b97c72ac5143b648b1ea1e25a833b54acb50681d868f2c2dbd80c58ce0132f79d26950656b0843591277de76a0838dc4357d09fe5aca8f7f4c1bf46197f6a337c86a8dc44adbb7226b9e0fb3aa03f0344908e134a57ae27fde4f1ef042c7712e9ebec435ac62fcf2b5a037fbc02d747bbe31874f62c29fbd8de29056a9a737282075c9ffa3a011f3f9981ac131405db0fad9c01a2214d50c6b29dd493060cba29336a7cfda38e20463432ebb4cd00678500b6da611ce8009186d6840d9e074233556d584b91ad7be556700faa7194665a3e0f312b2411f5407bbdd55957ba14094de23c018e75153b6286b8ea487f3037e247d25270145e0407c4180c5d25b090ba8f523d1eb742a658c244fe51b29ac7995e8f03fc9303d2c01a9c00cc3b36e122630b4dbfe31ad1b31ab7905ce137cbe98df62512cdc02644771a46322ed25737899f3628623ecc283f35a668fc9a2cb71fc0c7803d2a11b433b7995f1bce8764f6bf2c89e3d03cc4e005f216aa09f5e33f8d7efef625baa511020ec3e3e632e6c74883d8e30c3f5d96b9ec9d6534980cb14597bc33d31f54401074123c20faf62d7e6db40f5e43137a666aee79e217e672f3b4d3d6b3276f3ca02cc4e7fe1173c08671850a72bb04982acc22bdd691afc7c935203a55df33ecb70fd19ef04703c4fb2379a2cf4de60002a0e584c6d880d485f42ac50cd44e7eb1af4d7de6bc2660175ac12053052ea8af7c8d0531b579f24ff7fcbfad67f8d85a39a68b50d17b370a43447c683fdc64dcb43529c4eec2bd8a32bd9e051970800852bba5456fb48abe81e29c466d12e8931d7a2d1d2caf29bb699da3768d95042b1508e26898011ae13791101b8ebebcf7290cf2463f0be30f748e2a7f4fe2eb781eb9c4845af1650efba1883ad49d604602ed995c1635895a4e73c9535afa8a5bc77a4ee128bb9f13b42ff0d4f3ff503f73607610b4f5cb1c55d051c22d40807705ae8d1b1f488d5fe3cd579b70739618a2b36d3fb2b645e2e4cd25c8839727ce42c77dcfb549cff995a741bfbaf557d14e906d1068e91f0f8595eb3f19edd9f6d55dc8e91cb47e26ed89a61f88d3604cfd98358e65b628c333297e1715d4615526ddb2b74173cc9f1dadad37a1de72ce9ea0aa8a8705072c90b88db10fab41a6dbee033ddef1577ba6d6d98d85e74bfbe9a00df74cafe42dc68f225d3f519da2f2b697eda97bf1ecc949fee86c9e51abed04a87d0440afe3e32ed82d2d5f5e72d074a09dbc3d4f63053ebe6273b540a73c0139c841dc04fe1f07ae680237691c0d5855785d3163d1f582590364a54ae3a002439b9f3510c1ebe2f38e5d453f59745f97fca3fc2efbb4cd0f42e6bab019cd7115b367ab96daacbeb55aae4af33f16c85efeee10d13803fc2404f54180f3c015d9b2ee7f272eee9aaa132150c45355e6561c84edc472d44591ccdce55813cb6d544809bdc644f69170fda75e4b921473b15b53d972b3985f628c19806215e3dfa58416982923ea58d6b82becf7ea6b0bdb6d60ce3e2208553621f0f574a4a1e14935c06e04dbb3dabfd0f77aafa5b871a4aedf9428e59f92c70447395685fb41a507a8bb641eff560f3c8c9bb926091fe0ae3bea20ae21f40c0950f0db5ebbc41369b5115c5383392ac557adb0e61a7a7b271821330bd6d0273a206a5a183202142949782a312225680a9152b5b3ba49135df579f6f1e0b7dc6171acd89bbb06c680b7b6c0cdc579a91fc27214298afc27925d5d1e0101c948f4f58d0b2d4c94c48cc2bdb7d374a078970a01fc0d6c0679b742009ee7c93d0d9a41c7a44223c9dfd1c6472c8761e16ef27da38ccf5d007449641c7f6bec4ac7a9fcd0c8f83b0876f55e9aea5bb739d6eef4c51782e8a213c3f4ac714c2e6ae107d1f5c3f7e42e238d5bbbcdd34093f3d5d7fec50cd5e2246fc7ea2dcb135f21eadc84f9c8ed143ea19af51efe56d94bbeaba78a3e21a22ce223b82d51dc86e45c23c6d8ca59cbdd90e32e387a8ca12b2e17cb1ae5108a343d6d7d35b94097eeea11af35b9899e79a1b2a0c372fe9afea89f36fbc57b4f058dd6acf5c656700d65e72901ec3cb4229986230e86a4fe1fbae562ec7dd6e9ba0b989142be719f54004e6ca79ca2a417d8befe8610727650605740de75832f96efd8a49e007d5dd794d1a91dc8e96c23df729ad117c73cf410e479093a8253c18c22ba8dba08425af732bc7ad28e327df1223dbec6db349bd808de06a486304a0ee40f672d535577b9f7fffa03a39f3fdaee9d0d8b19e2d65289169358c8b1d9956bb714a1c4a7718ef2dca72087cca868e7143d52985e58bd3025c6477564b98ee98e39ca8fb5c2d849277c289f8b424645ab7389ca14f2cd632c3dc82489cff1459e5f860276859cd8c8f9e8e9d04e7915cd72eec13dbef55a7b8ae3b87d89ebe4a56cb473b0ff89a57038a1330f2c78347ea1629b05e8f61ad9051a3993a8cd314ccf96853e25d5bc273934f637e46257e9a8d48be474311a2e715647d7c29f58fb3b69a22eac463e9d0076082d62ac0fcb6f46c01c070040f257626d3518d1ea7d8ae126dbc7e852083c838da91178e3dd2d2be80df4dc67acc3afc424261c73632be18c47016511e359af52b73b4be1462fef4577e04308b26ad015671b00043726dfe49098e6c61dbbee08c4e8cd39f54d0a2b040c6e921bd32f11ab411743cf44279667803fced59a73fd216881283726c22c1be403e7cc27c161aa19d127f0e7cf47b219f3898291d375e851ac18370605f50b848de41f6bd34622c05b49a951fbeda53085149f8b9a71da1a802f6be31091cd760965dbd754183e3f175c39d9c36cbe36981a522fc442a8979cdd23135f1ce499cfb9f996df1efc252d5ec864c779daf943335e72c10c4c553d35a13d677c74a91feda69726007c942bb5a6a4d98d6fd8a9df6b71cccd2a474ffe9788e77e9e9f67a1b8d8cc56f0110bee1b2931e6fef6c1186803a730b40a59cafc8412ce62245dd5fb43b97759ed64bc2668e5f917aa20dedf8dd2950136ac37c27dcaba436c859f1daa06d431fe272586155a5ffb4584563c980343a60e03260cb540fbc2e4e85bcc02a6d7bf7d9fc78e5a490523f2f729757e4ce38be6623239152b8f5bd2200332debc827fb9a21e0adc7fe8ca5f089486e42add329c0049dbe0c1929ba576f85c4885c71888e2f5aa4647635fc99e7fd470f85beab0899abacca490e9372ad368102698d5c52daab05f9b53072ade532a66e1e429d2ad6dd661c0ba50d88c931862bdc75761c236c9861851761fb0052709621aee4ab215d3c6d3f0c40e6f38f7108671f23d76dcc598652af1e6defd8a220de76671080cfdcdca63c51944e544778102c62feb75df7565314541aa1407a4d1019873acfc106930a0b4d4b57b908062ee58a172c0f19e014d40ca06856944d41f3629fe96832627ac0694d73e93b56fceb903ab0585845badab27e3a8c94cee6b9f461150a686f523395e9e75298da8dfb803a950cbbb36376b8aeeafbd664a10a26222b2765c834f7fe6b80834b81c53346cb093644904bfa37407d3daa2157c3ca2bed75703fcc7718d8e696b6c29e2a16db0c2dceb1c0b6bade837a5b1b5aab6aac498373c8186ddd0c1091d3d89c314f6c5fe9bd31fa96034ecce736ccd1427977ddfde46dc5319c4bc8ac24a430a0a2b3bc068b0b8eeae39360f0e2fe7ad8f4667e726d93dca0d7cff960423ec7a832584570b1be7e8c87a10fcfcb85311c9cef8e84502a1c5b4892fe2bc807d1f9a02f62edd06a77080a05493aa03a3c6628f9ed6a6aea7cc933e5523f9a37e0e02cbd8b0a2a78f2980ca0ca4934502a5e94dae64fa011918ffbec094392b6e576b4a6b45ede9aaac15f85ed35bd098f4f7bc12cdefeb1b54eb93117529f4431f9f1fb3a473fa740c5f1f4660cd313b5a8bb816eaaf7ff124dd2f8753a9c3f6196b6497344627a27a045dac8536629aa6c6267133bb51cd36b56f4a2e4eef85a9152316b657ace185114b14939d9c3d7e4d15140a2d308aebcfe111a45f61a33116fd2566031ab696190309ee039a1293e9253874d1d711943faa408701f2db3907b2129661aa65496dbf689d32896c51df9479a105f39a0a788749e9a712b8792be211ad24b4df12d5121c4bff7c7dcfadc08bf959446287055d0fc5b583d458e8aa56250268c56f4b65b21b2c90016241625a7200941f2dfcfc764aadccb20a814475f5ba4b1093d1a65cf2996cfd8c1e6cd27fade926ab58e4f10d845d65838b0385fffc588b7bf3c1c565d539c2a7b43eedddfc89af1211968469b3e11808026fac1da340f50c03b6c3e9a76d8add86fbc6d0266d48b9fe88594df56bba87ece69d5702bd49ebd148d6bd1c8facb63bc07badfbfc7badd3edb9a3424a02d95e2d81b729ac31b0bc53469d6df5122fd2ab9e10fd67344c24653c97172cddbdd440339c23bc26ec05557bc98c6d853269d01d2784ee1d96c5a8aead2d2bd82d901ca51c0304b88f9182b1a2cdf53964ba4f78301a9e94e4a7358880a5dbf12e2bd269e176aa2cb1ccf63e43290bb918ffc27b5e96dd9f32a4aa3b11dbacca09740ed042258e433bf7597b1954d946864419721077d2874ce100e33882e40edc3a00cb6932b9474179fec7a91cff97e45563261bafb87fbb7abbd6e5eb93b059a5416f0cfa90c81685f8c8f5a938956afc597a02c23456c4774b2f223425bb8a5144653ff898254c67638f2a880f51c646d0f561868c5f1d61d16a1c2058565c1c1ec9cab2947fafc4b9e9d9f12e268ba49580e61c0f967e3e8ba13d973000d0d3518d012a8d248927cd63fa2bf23cee94be9b4f94b6f3b62cd1cfcd12a9873543f4ece7ea7f65bc378766cb2a8d9a722b5b025a67960df4739710564b546d70cd1cef5cac348ce7dc2cbf06c0b1dbf97ad018b1129fd4393ae6cf27aee8034744611d9ec8e65ecf3305d8260aa96a0f5f4746f877b1260397452c929097ed7e97cf766b474da8a0b0fa0696fc0480700ece1359e9370cb311db3df22d5f89d255be9e579d0adae8f444cc85bdfe92c10649553d53d3e879c64e414ede987fd209451976460ccdc42a531d5fcfc3eacdb5b4b634dc98649f97b32a82b3a2504c6fe97848c2ad27f8ae7df8f1b085b3f15b7bfac6542c015a320cc765ca472dab82d4041231b86985b0969ca5d680761d2e4a86669d0ec7ef77dd207f8da3be2c0524d1c51d5d197afdfe985cb5dec6290a09f0c3d7ebe8fa33abff9f23f7bff56de23d4d25082b845cc773c31e44c649a4a7930aa1338f04da8fd4b4f96a58fdcbc26554c9bd314827ebef626cd50eeb8dcadb370cac8daed7bcc0d522bc1da658df7b1d045c32ea32cdbeddd2d85cfb362ed42cc0db19643fe9ca3258f958a5ed09f99140f7360efd65be4ae8f52b71d8d23be885a572e5b3c909072aa4dd45fa90f0800169bec358c5d6ea405bac41b27d7b38fba32ddb91515624fcc5f004ccbdd911cea22adabf1d973b137a7035c628d32f260f2856688d0d344daa9bfebf6e314426684f64d03b3a7362b66f19094faa214a1faebd48d137ca0b79dff85eab5a13c4fb449b9388507bb5d2b6c5f331ef3e4dd47c67389ccfec722d8d93f405c372bfdaf87f3450a2c86ed7112fd99260bac3c422d16a41e5215cca8f52f0c21d012963509beb522456603237ab9561c96e80e8a7f5c00bd1a9cb7adff5fbcac68edea6014915672304185bd38d097743aa29dc4233188ddf435cdd86fec13bf63265d9ce69890fc9f85a3839eae00d1648743e2336c6eb1b221d2cf916eb7272569e380696e2b2b84c5d3cee84a85790edb8c52ede9e9256bd8633a39a8e398ba8a9277d1bc8ad3c368def91225c842cc830aa36d868a1c7de6402a61ffaa7a481451ad3a28d833364baea637cdb02cfc2c4fd8ccc7ba9f1e0107663a06fd3f6f73472f762d6b5e2621591a86551ae80b7ea2aae1110a2bbead4d43e2fc48148f68c4611b1964c6fadb0bf519d04fe5e0561ebb1fbfaae595e5da2125986810b2b8a07c86e1da1b9b4b1b5d7eef11cdda3d36d4bd33a9a459bfb73fa91b7b46a638ae97960e12390b878c46532383ba567a9516346760bdd9bc7ada47edead1bfef5bcc4d982173b65813a9230b857a27ddf1210f3042173b612df8690ce6a0bbcd6354a7b0a4bb5f65519ea31105d75f08d56a1dfe3aa337b7d021ccc02a761962d9d6769dea77334ac638e96c38112a899a23ce74ae24036c642ade14e0d6584a922fb0e61673b91e1fd690ea8fefba7942186c5f874d034ed6955d469c8f2f73121e5e41b7d9385a1bfab3711dc1f6a2a08f61cf3e1d37faac593004428a59105dba3beb122e1461c863c99f91ee34d215d1e0c3a4ab20ce44f8ce810c54aaaedcaae34bea712a7e3a356170bb951700b538ba87732508daffa9f80392d134338a1a0b7227bb3ef2fadd1a1508dad05f878250336828eee26b86bb612c7dfcb0aea7ec58e15da830dca32e00a6f1db18f7f923f7b906a12fdaa977a0b58bb0b6e1821e0001f07b797a3690f32858b04988efc406179275cff8a9e800d7243f7de93c8b27be7ec3ec6dc59a26dfeb0c2644a79eaf5bc2251894f6cac9bb7673b8eda721fb58f4b21946f70196f51c99c7934e6a11719064544c2880d5962ed9e8a6f5992880f75bf52c3fe9ae1d5feffc52c74fae3e10e06aa514fc73a588d33a575bc17c2319894bd4f5bab1138e426ed8c9d69a053d0bc8dc0bef2401e8ded5184e54ead208779327165e2794b5e0883ec19cb2981d5d854707eca5761dba2d36bded0f8aae3149f7680b1c1182200e8aaaac72bfc71d6785215b4951bbd4f52839ff5a602383d32d8d745c55c442ec6dfb9d3fcb8624a51ef33d26fe1280a2224ee834464606b37b9f506e3f98c3609dff18a02c3a5ba2a75738dd201b110a9d1435357e902c3ab2f3e675ef9f952d821a6aaae2174d7ff6906b7946f42ba1606509f8a9df81cf6ddb03499ff33db1e6c662dd8ad5a866b79432da32134d8136dadd019cf2d5def872a9f47187070b83de4a29d40762ed18502db01f383e4d3bbec63e9395cc4c47883765caa1c1be5a71a5d244345fc84ced8245ca9e3595f9c8ff58599392045d2e47f65454c6558cfdbf4263e954d1a1fed684d019b822c44270ba03187129a0259fdd6cc11c240936603926bc6168c8654a2f1eb9ebbeb7b3930b178a6715d9e735c015202702c64d806aac6157f1e4c00d5b086445acfebc976954d868e6fcd5cef00ff7f043902b71859ad1072eaf1500be36fd88a833ff5946b87f48563bfba5bbe27b39665ed5b58f08ef2a25494a7525be47dfba0e1354faca96451392b13ac35f7aa3cc5ec7d7472b82b50e859cbaa99a09ae0c57f8357b90eed3ffc557deec298af98d767b267e141cb30e20702604ecc7110c93159e90ab4638de133f8051db66ab404508f4b9fa3e6bafccad06ce6daf13f430f59c53459c94a0a1be3fe4a84bac3023ce7df602e32a6470d716a05ba4f670689de0746b0f2fc75bb3395be0db2a3f569e21d73c91eea0b7199a02204b5cfe7f9a179f374a27b328a4fad6563ea3c723030a94684bbf4573ab0c4c1be6f564f9b8ff0d28c0cc9b5c3ac911f5257c350eb918d82d5c46e63f009bc8d62943cceb568bdf2a4eeddce306dff7a16cf08bd45b19956e391f8c5776797e70f2dc9f659344e54631fe6db12d48ebf7b1b06c0973a943a3129a22380ca4588b2e5f289cddbdd18f1626d79afe3788caff0bf66dc924ed6f61714a3bc0a1e8a91a9b21e2c9c9380793393c2fd9cd9f30a20ee0067396f7781e39195fd84b0f17a1caa60fc8ec805704d1cac2763ecd7c00aebac0c8e87039d2fb41c4dd696e1a3773a777af1ff7c651d2f9f4977997e594690f018148ec7d2a33baa14bd37c23e227dedd5e9d74e440b2a0ea5d9077758c536ec477ae105fcdff37405d3e5ca94b332feb4fa5ca03702d25363b03322e34824737a3a4c6c3312c651496516d865e96f0330a5276ccd38be5ddec035fad4d4f31a267224feeb52f6fa04fd2c2bb62bb8af5d12b660b04278752b757ed478de7a0f77eecd9af7a35851b02971f3ecd37bbad205158782380d7151532d0d5d6eff76b19b04a84784037c89061ee2cb6d8bc183b5badb2e424bd88c0d3d8397e9edae57ff83d19eb3a9741afcd47c182552d46c980ca5e2b0744cb1405ecf3792c1500ff34d57e3cdf7ecc5cdfc176f509709cc089b7ffd7e45f13061b50635c00eebaef49ab5c993cda27fa94092f0296e30f880f660ca4cd5fc3d502f48a89ef6b0d4c61e5d5c42728f5721b8bd368a1797886bd222a5d227d907dc40f47ec19e2fc4e063f19028d3a435d99f92d2b5f960bbe149eee1913fc2a8bc2657bc9982a8a8ad61ff41e1dc22ab438039b967935ee7bc48edbcff7785ca367e7416e1d18e92ff6d74c4a6987cd3eeb45d3bb1f59327b4388dc5a351cdd7da4d4bbe76268b675fd8ecde356eea7bddb65454c179247d8098238f682db00bafc2a37edce739bff873e0a0d73781b1086c27128fe2500fe4351b9ce3def1bd0b7a8905bd995c05e952d952c96b6f00e44df560307a6e628e9d3075af9650ad74dce5e24a248726deaae1a3b9e4a32c1901998027b4d1eb796bd8775933efd403a1acac59e09e6b73932383a371b21b80789854dab43152a1840eff465f69dc8e4757657bbc7d6a381f39308fdfdeb8a304673eb0493e4252ae3e0653f5a1be87b697f728ad427fc3f2f480c50220424aef119226c0f87f2dc5deeb03d9b9069b7c3db719597d5488d9d8fbdf361dbf683b10b19bdde3db03cea1a96af16491c52360d204e7b2b7f622c58041af04b6c35fdd0ec13acdb605aacba4ea9e5bee53a09fb29b8674f70d2a6e06c7e1c6ddb3307ca310dbe60ddcd6f28e3ed5f6e3b597f2fa65bea5ad999e5f9478267925abebff6f89e9269159d9d6cf8c9697e5ac900e2fd92771ea5f1df56cd07b91fdc2bbf78a9cf285959478e580bdcfe3d846569ba03cc30b85c5f6b8bf38e62a9e467849a45f33403fe39ce3357f5c6822a3576d7e2e1f6c0875e21320c30df622a83e2018dbd7859098521ea17eb6608637334cb73526a491e8f95e29c43636fee2e10ae81e7339684a9a0ccdea8c60694c23c7a5e7519715e12e3ad9fa04cfb2cda70eb6cf2a035dfce77675122f56036636bb9bea971bcdd6f20d9ed41c4b54691f271b330b735fb50ac0ef7486d008f9abbf652e99679b633b9b25775026a10162b09cdbccb92e4983dd3f09341b15fbaa42c2ad927b20709ebe5f5a0f9437804dc7231f968b7b8f8fc5503b816f603e26b3d2e6fb6922cc7d8496132bcea4ac70bec063ef9f3a3fd696e08b83089c7d0d4a750d447f7223a3477a677d77444c7bf42f839a898579dbae28d431d2fb100d5ed589292fd8dce09855ffc659bdabacc26ec545346daba516cfd190b38df33a47e4ec4a7ee7b1ceb9b14dd3fef2e03a2566ecf8d31d9d0a8d94a270000799e93508cad76ba04e1f38f27b5791cd423d6cf4dc6287a8cdf6892d94c637c21cdb59f92133180eb257a7bdc9b3868fc18ae539e4fda808886f22ad82e36ee78b07810e4ac13084cb94c226177f9f5ad7c11e4db0d896495f4ae619ab675de9e70f160a285327813e5fe4f413a36c8a77acf5f6cd30f87315f9651ce709f092ed36ec7d8951f59b8292cd96b37ffc838dcebd8c4240a3cc96403ed8e04f67da489d0bbb2438dcd4e0574586e55e01a313712722eaf44b58bbc044eb6bf1ad48ec409c1ce49d34f084b4381cbd3a9b804bdfd98fe7a6740a1ceee5d9dee0766cb30849b37c3cef6c1895f3a29eb1d9ea2d87f948a29e5124298a859fb6eb7723a22580443cba6f042a9154bc12667e5d7eac1df0544eb40746c47e5bf25ffa22b262eb69fa4bcf458b10ce6b14e5c96bbc9ed615248573d9f07fe8b31b62102df6274390a0de8bfc632429b7b3fbddbc69f655964438a5481bac7ba452d51791f84d5c27c63ac721e0059d7850be84678fa14e38b2660ac8848d886e4f2351ee0232266e6695bcf783c1df5d43828a4b52c560171c7e4e4944a136977e0624180739512dcf3d1f224493203ee2d8e286a41be1a0e07de489ba6dfa3e17c376d286a141f2bfc12d6b3a2426710305f0209acbcba4bdc7b708e2445d536ca0537d635d9ea231a0b360f0f97c50fb51793d4481951d51b80a28047a7d5772ed3240737d7da1bfd236982bcd36a32b71b05bd1f38ee5bda2537006043b2845668dc9b50fcdfd3ebb5c93b4b60b5cf50d11bdc926e297dfd526ed225881dd09bed5a4e9c062bfe574ac4dda434a9fee8879ecfd591bcce7c67725b42b3193b58246f8e8f4b81e80503cda36d1c7f54b3abb67f426263fba4798d7132f91828927e2abce159c0de940c0cceeb8c3399628c6ad83b1c6b3db9d466221ecab015c420707cda75f9e0d898621a17a22d584197877b2e82e3628cd59049cda2952a39014dbe06d0cbb35559dcd38931b2586b069908533a2b0f765ce91ac7c4740e952a5ea9189edf83fa6a277ae4de69d6133d3c86d8e3dcde70bc80a3ee55cadb814e22a71ea185a40be271b6621be9ab10d3af540ad30c1159e26482b26e586dfc62e73686756230f9f197dd8c24bb61194c93c7620b7a55272c13156e16158fe2e438e6ae22a965dffc2fb78e3472ef85b6118fc3b333df70a372adc8e542da25e2778f1cfdbe45f6e52676b5692f617a7594ad0ff72b99a2a45ca19744431a8d5f7671a6138bef88bcd5dde47549035e6680e1b5143afbf3c9c89d6cd26bc13071fbeebf24186cea89cab2bee59de4104477811d3f9c7ba5cd330d53ae9985f95e1674fe1842254ed0974175fef61fa85e7285807dbc216be6925bc5b02e587b673e741e7bc6764cbc40878b17449a8ea887e612ef95f764125e4668b1201d7a0fef9023ef461c33305b01f03d23614f5f4bca2939cc91c6061b9f70f223a68c3f88dc23cf622f32c0cce42ba157be099b735340847aeff099d9dcaf8722cea040f935f25b52c16e0066ac64579e26ca406476d37084eb9ec089cf1c5d873c9be594977bf05648a92bfa9b20284c4091ee0ee4db6ff886ae77d9d4434061a0e7b8be15d7bd52aaeb47b380683268cc90dc3a48e21e1ea49ed77c32149cfdc12c14fa17d8d625eb1f0a3daf03286b976f90e98e09bf7fd98bff399d6afcb1d76a48b84a5573f9ef250ae3ca5a6aa7a0330cb7d3c32a12412002039af8602bfcd228d51b549d65866a8306517eef3917467cdd7503240d7c0a8ab873b6fa3347a34f0d4c0caf1f131ef98b1d80b67199529d3ab74fc06ab474fbcc2c291549933ed1ac76f772e1465dd82b503bcafcbe145485a6903c8c72a66c3ec566d13696f59777130568f757cfe10710902ac01251d94e373ebb6bdcc3c842af341da9773f534263076a452584c28bb8df97a422df64efa8de5284bb681ed4b764ba36a02eb944555ca05000c06de93e6a8664bd6e7c1bb57a4e0dffffb75d8bfeaea0dcd71a69732c5304d6e5c7a476e377a78242d2018e59aa6c64fdd808344e904f815b5f10372c73a8a820fbc137fcd0175094f154154e540b1b1a5f41c3b5ad06f32bcc97442c3367b1a4d36524d8431706fe5a16e73b56ae0d3945406b3201b7bf043cece2388b62aeed441f98814998725c935373bac198c93e36637e108349abeeb875fce88d8939b8db323c151bd83c519286684fda8eef94376d224ebe6384d5e3c5377062aa411cfc3f82ef0bb5fa5a33694e0c5f2ec45d2d35a16431e72426821f01df33b59dc066da17f548ee52f57ee4e2f301c41b73e6cf8eb1dd5e8720a568c44670","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
