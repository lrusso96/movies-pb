<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"040d055082173be2cc68a0228d312c55f4bd90a837595b631d23cf166ea79cb18554fcf3a9f5c4d4505d0478dc8a4af880c868744fd46cbd05673a3455dcf38956322eae8dafc2554d82f03852ac44e6b12c9c0214ca1fcca820f769dec0266782106178b3e54770a50975d2f8b2e0a116100013aac674c1e3b7789fab5d59a7558db47733500c207b8ce47670bab192f08d6d76ce48bf1bf87197bdb65bcb8645954607c5e072ed3994ceed74481a4a2a43967fd7235aef3379835b86861893437a95df38a6b9aa577e493918e8c48e895b554ac6e224fa2e92115fa558c17022261b179dc7a5b1bc81d2de8d5c51a7ab87b1957250a9637e2ab7622f462d9a7e3331e875adc1b9f8a84028f30949a721c9970087688f11b25da45856fa980ff6ab286322a1147ad27af74fb81a665187124ec2a899a5b338f5f970f628f8125346c7349547fb05fce18bc579faee2432adb85bf83c5c57eda31b0e2f36fa8ed14d7dde88b3a880726028d93f4ddf9b893b6be557e1c932ecc931a05c2ac0d62b8667542dae304040af57008d88bb5dcd673189a966dc0b791db80d2c0fb41e64768a682b9aaba55f5942b3650b24df7f9ec6599b512c46ef669f70b9f6a2bab2261c1bbb8ee3c0955dce1093031ba134d1e656d8138cbd88240b8c402a76bc716584cba317f973bcf6022d68c24266ca80abd6e674ce4b9f59c82751ee71233b4510d7d9cba7acd3ecdd09ded526bafdfb28bb2bcac6a9c425df88104514fc8fe462a68ee12ce803fb2049bee94afd4550d68138536718e3d61e4c48b33d5eeb7b217c193ca4fa2a1bd24a7d820e46be3c884250ee785c93d3d05bd6e0b4c38484fff4853ee1bee349fb3c5d753fa05bbbf715ed75a27a36e014939659d22113caf65e7bc4f1cf650642668adad5bff91ba5e059b9a6aeccdf36b91506da5c5782f9c3ee185975a8ab38935cc9d6c354145102358f2feb5eeb90a85916bc4654a274e27c14508ab0421637bd8053a72b95202b9552fd6998549b26830c319c4223bc91b0b7a163481fb49a5b0c88d72250bcbd05dbc1dea4da0d2eff1948b8a6a77bd6845089eb6f23f65fea09fc668a6e9f31c0857e790432cc136e1905f217259740415b71c7a9d159c45cdb12f3afe08da2990398b3aa33cdb056bab49ada7145cd4a37971b9633a7a39987c71d9ee7b59b369e5ce3be17eb34684ce18a13679a672ad677a8678bf058c384f9fd1753f6ab295eedce4aa4cb243202006641730723f106dd957f3952b2c94a3fd8328e83288f9d30bd828c49b4ef43677971072970c04d413782a9f3eaef57cc326a7d8364fac1b65ad99febbbad6198a0b5926f428804a8bb89bb6d49146c988fc28b4078ee4b7efc4934a77da54997b061aeaf0a7bc46d5921bd7a6a9a0b898fbc4b15b8dfb48345284e03ab9153aedd5c5d06ea84451baf5083eaab1b653f7c8b603b1cca8484d4695c1afd0129e0cd00b1e5aa8ed551b6f539bc25b0d059e18a924a9c3084d269d059fe61d3e59fc829b377f501b69b6fdb2c6b985cc69eb9a18e551d99b0cf49734251c635746e5e840ab9d882abed6c90bdb4bd86a55570969505a783a9ad537088b31d2676c9989f1ea043b66c5399aa145d729fb38caf8e399014820fa21ef132c889eb7ee8019f4c3c525046685113ecddc526fdc344d0295e89c35e78aca7fc6a993a18809a1d338cc5d1b4f30ec80a792896eea2e910b976d211f978022ca6da30e03a686f0fb703e2d3906e10199558f81661eb672f6923633e45c211d6465b05c6c72622ac28c328d7b5ecdd04abca5c50f892bf77f1bff0daa795527dc48ca6401d75d8824f988cdc86ee774120acc3131f66c46a724467efc6eccdf41a493f88cc1c274a39782ba7e5f865b5c70f6d7db6c44eaa6b9453ca7b1e1ae88b5a1629e918d9f4ecaf3b218e4eb96328406aea7ea6e069a57cc54d28d9126b5d8b59db55c3f7227cc91a7f88249b2b45d19223906ae4db814e37b8387cc5f0405a33b7935ccfa4395c3147a077d9f04fb23380643a482ab2d79bd4f08e61a27c656342407a514ba7903d81e5ce72ff20eca19847674bbbdfe7e97b7a7916144a73e7394164555699e8beac5f3d6ba1375eb3eccba9b0a87e0f60a573896a8e3b59fdeeb20e17e999ae838d8c08d35ea9128e6722628460690fa6907aefd3d4405ae3e67791420f8d500b9ecf1179453c119bad4a6a33e94dd6314919071d871f9cf0e9730dae5a7b758fb55ad9ebbc2a3207a02616f436cfb44bd4a3eda9f5e07143558983c7078e4d71b6a785c799f124e2bafb1cc56bdcaa2a525cc8ce657bf308fc8aa2bc451beda7fdf1a8bf9a16de54c3e6c3cfcecfed343cd43da8ce05bab0a26d9e329842726a82d63d52f49d27e6ecb73fc8ed9e7bf0d303e4113f5b1da02b3cfefd00f0008d78654766e77710c8cf287abef0c0feb3702cc476b75713b2215390b53bb9912452a1714f5ec5fd70f0041ce9c6213d21f256e02955166d9759df4a0b88291d41675df97b18d1ec4a4aadab85b11bb2362b058a530d877014b0b56b772d29d0d9ba2563b82f5e329baf0ea1211bce2930e61b1484d7d1f39d72c2ef53c5456238f40dd5b4812970bb191e31082685002a4a4395f326d6673e2d901bbf4628135b1d4d469073a3f88b1a324608f115ac53f56f036324bdf5c6f8285b921c660615742c9069b6c1182f09360bd796a6ac8b65755b9791c31d87693be1ea3b25f351b3bfa0747d1ea9edec4de39b9e900126a5bf16c43799c49c48959358d0890c3f5d7c3c0e71c6958f6c99a67a243ed46100e429d8d1549f08df4426c6ff5c2e0f2d1a5157c8670e6978bbea9600068351393f62981b50f7fc95aaaf76f0137edbdb0656cae95a87051e055bdc4f5ca2337ae7425b5841db47cd4fefd190fdb762f91f7567d88b30190a17a55fc1cee16ff7a9a81213671db51b63c18af8aa71a0d34f6b11eb859d906a757396f096b9662acdac694511457727295e9c3cb87d15f4db71f06ca5e1141c22fa33ea0e1dcb9c7e5a0e9d5ac6b3c5752db643ce83a2f379941a654bc220cc24529f2511af80502da02021dfad5a449ecfe366089f6e8ef82fc826f87ebd729efaac65b0b5642dc0a79367befe0618779feee805707a8448747678fdfb56a4b65b9ceca762f5083eabbcc14dcd1019c17fd1be815c2d41971ad98ba5f4b0abafd006e4c71e94bf4e36734a5ba995ef404ffd231d8c17640cc354b4d3e7a9f32e09daaa7c3194300b119488ca46de6c360b86b870d11f4db3e35999c5cb400bcd96319021997d1111787efa03d06443695ec2c77aabf76d1750a3524e819f8bcc6f1e3deabab0949a680d5f368c80178d57140dcfd0887d26442f89368d5a38afa923cb995ec5c9743d4a502cf29c224f512b603c9784c44b774265547e776c6a8e206c27ec8c471af5701ef4a96eec3c77a6e5877b8a79b3da8ed7ffe3bb1a3b08492992ae1cb25f52bb15148986e3c2cdb300f20f103273b8966835817551d14d4d389a07e0b039a063e4614276c0b9873e9ff06497ad35efb0dbc00b45a8519bc0cb43f9253a4f1d0269fbfbfef8e7890bcf6d5a3f5a2ca7711b6cfce61fa58b931ded3be1b9c70e9a01ea6c469d8965a9425b80dbabc26ddc3bc3dcd4a898b0ea69c1bc8e5b619959d0c71e4abf78c1a7ea19eca336f2cc90f05dd60f161fd67487fa530cef43e9c114629e1ed4594459d140437d09c46ac9773aed84136f18afbeb46b2fa96d97e95ba5d68b6b218cea62e2d8f53a470033e93706e863f758757fdb83f52791cb0528660dcb6b01a2f3b1353044ff999e4249a1aa93a0874bd7f2307847909bcbcfaa82d27f6c4bbbbde129d07aa66db4091b2cefc48c7fbfaec0fd7b59c1e1c9977f1c5f804d57fa999ad623c2e702bc437361b240da4a7fbb752e65dc6afdeb7f94ad4ee565db4d9e22665412bd5b60fdc0a2d582f1082a426ef6b045dd5721d6d49d10e9c1d2b2c511ec976ea4476dc1db89e525687e30efcf4ec3e82629deb6bb6033875ce57a18f744caf80ddbb4441bef56ea1541985a4cb7d1779e90b1e3b9857015f3fed7688369cfb0791a087dd0d2fcdcc30360c1db97daaf876f83b4efc5a02b1b6ef4e0a4c5956c2a9ce86e115b4db3cced2229820a1d3eeee153600366b830bfbdcd1f3ca98ea5c04cfc017bcc90bd638231ca4006ea7b9aadd200216effcd6305482de10f1acbede5eba91124060cf4205a56edc5b31de4f9cef2c75f293a8253ae4d364af2ccc772f2b840cc5042a10db8947a36e5997986bf6ed2de9e85ca22d86ddf386f3aaceffb89ecda09e313db8b38ac4062dd4b9f33aee4f25af8b07d4b77e24ca4f2814f96c9186fbf81c0e0b7474cd1599f1ef9789fbaaeafa1c32c43777b2c2e72364f072a0ee2c67398f8a4c2f78f11658b4cc249d5ccc742a7764a0d0f91475048d4b61b20c570a3f7034a63c81041d7ac23974d4f3b140b1e5852d528336734c15e364b47969ca407491352b90e0a5bcbecc72280777688a5810e797650e0633092942662c2b89553936097d736af548b6bebddd5015d73900e7015e7265d5c918b281af5259ff7c825428a98dce544b9dcbf90f7cf94fe1249cc9905d2106ea105e0addc7d6842d4a40aa576bdecfa794ffc91dc52fc33d374191206045e89e402b18f49179a4e6f2f01da975227668331e4bc89013c231cfa6c14e097468feaf0edfb6afb5d27e2cea7be8b16d6d0c9cfce466a86da8e5a03a4ccdbfc9dcda974c9b9523ab69ed77371cf46afa75c802a866f62a326e0ad7dd6163b52ddda916f8518142d7490ff2a667e94ba989106f0a087573add7cec4b8c3cb17b96b30205ae6677a85bebac77a4bdacc2a7e9dd6762808ae2a1e1c7b26b84de74e99a58ca4fd7bb13426c4dc4a5d64cb7928316218fdfcb7bedfcba97feb39d4c3854fde355634ca24f5aa579406588cc87352a962607fd3dcc7a1c6d0b9a422e368b1da826d86efdfc127e8a1dbc71595e59cfff90fd2db78018fc73e1e94487e083d15fccea855f1e578226d2671963eb7aa2f527e8b273fd344457864b6147bbcace7297591e014908dda55b7ff33bf9f0b6ae5df7902891f22bab94ccd55a525572620586b95d127d42408c35c8dd56153643badc9136727ce7993d50b42aabf76f60f7f3aa197365287203c8025bc8a67bba203bba9fe17483ab425f6e6de1aeb32f2cdb615ddad12f61913d087850bf4825fe5873ed39e7d829c53f76bccd803dc2dcec314c3b69a2444ec0c7745d34a5d0fe80614b116684bc0726b70fecce46ed57bdd1b61b9c12b55ad8dd6bb774faee93bc28c862b8a63805c63276272b2b7e981e2d1b8c09ce36f248cf23e63c0f516103f233503dbe644e5635c702095deb3eedd738fd69c9f0b9fb79a85b283db54b5413db413564ba94105b3e1b34c21091a280dc290f528a49753438496e8d8d07a2c48bdf6def55aef49d313cca047de16adca003ad4e86060ebe6ae2b9676b55e54eaa4e79bcb95d2fc0c212479060f1f1e8136ad21097895af4fa595a3f0a13d771d894200086103300994ee3f77ec75c7ff1d15c91985d2518c455af8e2fa1198e03d1a7e0397dd052b40d224582da701d35d8e137ef4d9d02db446578dc665b74e2d4afb7d462d4be4e70a77d20843ce0c8d21741dbb41a0ec52a7bab17d70714c9fb33c196d8211c4d9af089a00e98c001ecbc07815533f1c87bea2edf8dfa8b0d8dcea349eceea0c4ffa50c0acdef020ae554f5c229a831e10cd73ac3d3752eaabace79187528586a0f836f229e91cbe7f4fea1a5c8b97e1e1c76d5f313e9a79bc005e701e81780a0c46cd2070ebdc0489fa6c3157b1f3a6c7205766e0d0e242b62885d292d84b3fc284fb5ca5121044f769b9f5469ffef80f476fc9a22454828465a590efc17781188095b599cae351e6a5ad2d20de6cf744df97981ae35ee16347a6fd8d49b6f95b87a7c0e15a4421f6da696346f75f7604c8e89c0cc272781a8cb1097bae1a1e985758a69da851c64dfffd4fa73c5671250d2e930e152f47d420d79b2b17e9024e5abfaba2edea3d0a9e8e7545d23d340c70e28876ea6ddda15d13afafeaebc2e438a18d59384ee0fe653477852990f4f3468f51c6f58b2e8384b730aa9003c469f0e5c72a0e923d986bc04c4fcfb073dcd8a09959aca67cefbc3a6dcdc8326991c87729f7201550d1c74683d17a40dfe0d59b5023fc6cc71ec10d1e9fad4c5501af52769c07ad83295ebe484471886c8620e24d9685e3aebddcbb157f72620393f06001072abb025e6207d15eac160b57573a62c848420bde7e9cf1eabd041fc8cb2cc97fe9f086a92068b6d3730fb55b5379485cb7c4a964468646c21e94e2d73117b91f4a831fd8955af536bceba41228db28bbb754a5768f06605d941a4e3dab617d8881f885917d261fbad624f123f43cd8e685706c06a65e98ec29e3642b51478687812020a83a91e9c43c960922585d6b7586aa6f63607698b0b227e05aa20c45652747b06e5411ad3e6ff2bae806170d66846d006d30fd9175e190dae30b6000c00ebdf69026e3e7fc618a884b77869ddbff9a5f56dede08eab47c24a3ac35dd740d86bdc8ed23916baea71fb490547f22f274ebb69f941f118086b58b0c4e51a4bb6d832377d81d749365b8a1a6b93e213b66edd85ab462bbfaeb6c81ba53089cf62ad499b399bd46a2be1aa29136f5a6d9fda18c29efa165a99987b99bdd4109cd541cdb810ecec6a0dfbf100671ca478ceb7e3e4c29cf0ebb3eb5ce78ce8a5e6cec7afe46b2e2b9e2e3edb8c68995b0db99f4dd3862f92ab9d7b19966504862fa3ed8edcf30809b9d11eb1639eb33f93933e57df68117e1e9a1e9ce34f4ea80033634cb05d7720101885b42855fe195a27e9f88ddfcf79f24d95e712b669a787315b243dde49febe2d9f6d00e52fbc6fe8690d9ca7adbd1de5e04258ca01165a4558e4ef2ecebeb203fe2cac239ae492a0c4d273bba8cb88b7a72380320812227ab8e441da0875e75fde9642b5ff3f025bf1c95a64b8791d181e11f1a6f9516774954a337c34ee2275d5a4064c263073d95eaec2782f9129ac00296c51e8b586c4cbcdde74feb8f83339923b87248146bad64227c31c20ff61b54d21c5ce0bca508293de227361e741b54fc9e95aceb6a7147c96cde15a8705087e654a91254fd09d0923b565eac900291f0fa17946bc8a9d2bde28365982313ef5d1f753413ebcfe7b2f5d54248050599f088488e3a0db3c3e0e7804a2e7cd03fe69b1298838b16a5a46c8a7933daaa4a07814bb5375fc858f744d6655b54f8fd512c0ff7b68cddf01833104fb33160f71efcea690749faa68fd69db3859a5504e130188c5764fc236c44a05993ff356ada30fa88420938baae91de03fbf6dfaec0b0aa5119af041a5ffed4500742025b8c642faccac57cbdfa62bb6b760080b602f2d937cfe4631827469ed277e6c22a74d8a3ac5065554dc7d6bbc53d5026a7770b0a17ecafdf07229b0f5a6c0f895ef0cfff78541ddae5f52ddc3983e8e4714bc78e9fdde1fa969b6efc479a53102ed3a6d8a902fddb7b662eb2f870d7209d5af9efdda658b3b801816a5d575b58afab51e6a07b508f6edba158bc76be7315c569953bdf78dd15a869a50cad19da70c2236d1f80e565ea567998466506ef2e9a9c6daae6dbb3356412d2c0c3ed870468e3e2e703a7ee7a0316a11372844c8bdffc0068e5df341ac69317b6be30f6c220277e5b60aa2c8ea97b3db14cc44383c6eaaf232dfeaf9544b1a09cf7c6ddb2eb54e039befbe27b51949c49adaab8af2a58aaa474b46b9a72d5b78309a5eb69faee5d0e88c5cacbe4e46c69cb0d168b3d8f56832eb53764855e305d578cd9a4e4f279a714520e8b759442ad6a1d6ef8ca87bc07e5e0504a574af4191f1cb8757ab9f56c6bd0b0824d59f47575f80de5e2f74cf6014e7abb9eb41673fe4d9617d9465cf8e76703fa4124b71443e3f5360cfcd1015c035f324d08165c22c0cefb9f628cabef0f3ed99d570212949897627983b44537681d6089b81356d4b66b721d812aa2d8add7f4fd0384580fa26ad0c7fea89824f4405675bd7827de7c5907a3a77e45700499ad4581029ebffb047a1c550eaf71914ed32ade5710036591a9a09c5183972659246f7f80aff011096053bfaa484737b32a756022f8137901afe3b5db31774f9c2399fea2f0cba04fdecfc553e0d70edc0c7450a132dfb1ec9fc5ea8ff5119cd4cf3f691ba53f82f2536298d73ac2475f716b029820a5e20a6e38076897228bb2506ad0145e4b897fe7ee1ad47837a7ecc8f1c5ded6a973dc8df35778680891ed1ac7d079a6ecca626b3b3cc9415a2cb77a8cb61dc3ed3e14fe4c402c7cf739ad57dad5cc5be5c66201c664607472ef7515a4624426b1bb06e7821205d8460b54edf0cb0546fec719c2ba0e53b3b8ab8785b759ffd68e8f0ea5d13bfb659b8b81600a173a2e2c9880fa3caa4b314e5ce6fc00e2963805f467c1cbd8f9dd71b3a736bf3f1db5d355eca833a5fc2a7c5e9d950323875d3bb418d9e119d48d9e3339ac1c926c30d946e15824bad9b20c09885e72fca6c669367dd859dfca99e60f80d187b1adf664747b56d4441a41a9d114a7f69c9f89e91c0a4bb3650b497ba0386cdc70c539bb71cd11cd9b4a562d9b503fca2d0fc99cff405157569563dbf6355dc8085aaf1208a44bb7fbe9d425ae709b0a1a600f402ed3427a7c587b765fd7594d718d60abbc83d70ef7cf87157da99032f9ac83d41bc51c6543b1cc59995e188f87ccece1c83a3dcbd62058a0fa2891bdc85b7ad4b77b0bb33a184e4c4191f8586a3b6098bfe3024c8f5170bd560ea12625044d7d267ec9381e42ba6d6114af846f2572c39c9d3e5f5af729f486d7037484549e8d46cdf2557064329662b8cc082c99e7c2377e4a187579d5a4e17dbedd991e7c4aa4c2cf3e7065021d749df41fe1cb1c08ca22078d55b4cd7ed15e0a0a9493384845f3fdede8232c5bcde2916e0cacdd6b27803f71960531c00f9f9537753083ed2a44bafddc206ea499b136addae2997109972eb227465aae220b8a60057514618c98ac0347ae8f6abe21baea7e0d69ccf8d79ee7a29681b5c0a95a0bfbf17cad849e7a0a3dae625ba4a82ea58c6ece37824441614923e41400f8055d8bc51134b5740c4cc03456949f04c9f54a1485923dd65dd1ae3e0d40967eb63896a8cd72be67acad25bebb2d281fcdc8d06534bdf0e75de8088bc2a29e1639e4329ada37a41dae9e4fdaf7bdd184fd77d2d9c3fb6277004efd52d5137171cfb7d7c401133bb8c125ebe744d5188a9c49ca47c1f2817861cb58d712970f4d10cafaae5d02bc093c4e840a2c64dac3efd2c3396f9094cb95cea8e72ebfb4b4838112c87d8117dbb2711466547146d9dc9460afdce89f9fc642b1e4cf4d36e674806f26fc4b99a37207d0ecc5184f33ff75f86f143b303fc6ba5238c771a524b65cd004137c1f67f74e186f7a77a1b368022d44f11b7c2be8b394d123d7dd67a1a85a7a263ba98f0d945127027a219acbb2cbe53209c16398c87c0db24035df4a2189deaae3ccf1f6cc7992bece2cd2346e4ed484221e6deb8bbec37f31e3decdfdf0df0384cc5cb916286c643e31c99314d4e1d395ab1c93769aed61fd81dfa17b17fa9a97d5fb34d42677c1c99103a84988c379619e5442d42b44bb416d30dfa56ecc644813d34630273cd7c11fdaf83e00e704a41bac751ee6509b96a39e0a2aba58d018d5d8af44dc25d64c5e409e4222bfa4b576b54e245a5bbea4f37e627cfa2a5f6ce193927b9ac81d2fef697e709aefa85c0369f3f9640ff5c4e63e9457838fd7a516d05c5977ded7a3639522fd3cf0b64ed27635de6d18a2545b353e7ba439d6c5ab3b2a2db73bc4b9601947a739ae6066995d4e7482d76bd5939fdd0ff084082d38b299207b4dbfc3052048d89462734bb433c6184e0c91c5858c4240d585488f3ae793f177600d2840166924be000a7de6b50986b300848e68000bd4a8d67b44ebe082fa6708e08470cc6ff5869d4b695ce248cb294bfaba1db8a3f3a345039e04b683437c2fb68e03fe406f0d9b78641cd283484751ad8dc2a9674540c97b4e7a8184a8db95498ff9a39fec077c0219b59c73ee676a5b4a35f8270410a81393a9301c4b583032fdf08c6fbd5a989f5db01c93da67f6f2db03b0a6c2e05e5c7fed6e9143fad386ac59c1a25bc8002767b2c897fe2c1da494e80e6b56d32ac920c4f3ddf49b36f3caef4cab558e49d493259253bf7659febda9807ea17e012722383cc72cdabeb8df9cd8864cd7fef9f555cde072ddd7659afa64696f1b34b60a271c2cdabb5bacf69f4d7eec894d024680a533c4f5c882a1533c6a07c40cb949dff2991f0529cf5fae882b84e68ee9122b53f63fc587c938c4d222031e76dc27685be8f89a8ebab62eb8b7184d3e94eb2b9d809b2de83e035432831549e71b6092b6c6ea8cb702f2a832881138b6b2ebfbfd5df604e16d2c6471f0392c201baea50583276f8dab9676c6b76cfa95c4fcd68117278d3c9d7711047be88e612aeb85e9cb1a76c8199521d645c6472c421553c84916982a4c9aa83e0d76ec0d346c29afa3b89725fe4bfc54fb22c212ab77747b4b223f0be09be6a7ba343f10811b345de6c66b63110e136c429892754c35ea8cccef0af7dd879b0499c797b97d671df371c9a98292248199a055f29a576c73d6f4ae3441a357f84eaa23bb3213efb1325ca0e15faf56f64cba7360d2f98cced2f89ff65b169e6074f6fa2d716a64279b02857b22d635d566e4bf59bac46267f89e1cc806ab86082d7157a2291d6ddbda3995da688881d127999144281279dcb95a033f8908310b5d3617293f91963fff961cfe7d92a57da1b568811ce6ea28a2305466a9666980797907ba72f2381c49927e99964fbdfee8a49a4d197a1b707a37e016b5842dbc6bd5c95afe4ab50935290401e23fbcf2b107580a69c60234e2c11604fe29d8158388133c5f40ea5b4a1659b0fc060e2d898088555530a649779f42fb67ff9654fe2ac2ab07acdaed965b75900ec21df6508cd92408deffd92d7d3d6f22a27bb1f05ba1ea2e41a4ee66228b57cd77cb423e13dd4313caf35bede04b446a2579c5c20ad872d5ee7716b7eb7d57c68e1a585e904b72badda27669e3a6ff8258e60bc90aaba6618c1cfd02ea8d2129a6236283ade63b7d574b6ed0b890e2b21661a3cfb4f1388a28efdff22fa9be1e94fb33b9c23219a137f00fddf6e2b824552e910589748273e9c78e61a61f68958c42be7bd287d037539e81c8f9d3820bf02f59af41c6c3286c07a338310929d7b5d9e747a9d129bf67465c9f17b31c5acfe76e2de78cffbd16c19ef6e47939740476605221460ed82416f447c0280f2d54585e8a50d584b8231eed035db572184a0c945a21b6bf94996f2e1fba9d47bccf0c16c5da5347b021f80ede79adcd90dcf6be37f34ea892d595dd91c0aa27bce4a80680495e4e8d92aec3545af204d5638a0e4982f7ce8d7b59faa10040ec462b2b28fe34f0866e128e41076c1b8af9b6b6b7f5fdc25726da79b834723fac7817f6f6e498b93a9af915f6e11b39b0edbc13f876c1e42c6a98b71685d1a52e03c25758a2cc4711dde5b31c33b812cc375974ba2fb1fcc6ff75fd44af22cc5d697a8e9748040058a120d32aad514dfbb4406bee7047c8bf59813f1cbb74d951fed762c6fdc9d6186c065b08bc957645be303e97db98d73d26b0f7a971625b71db04fd2812c637a1879e93525d15cfeb7575586e65105bc1aee48cbbcb137577b06604f93596c3afc2df880b8e122812f7596aaeacfb746637e99a219ee52e207bd9ee7278bcc6c121b2e28e8bf91933b7d47ed6897387eb300dfbe844254def6322620cddc8a5478807228cc91920866f90770bcd0fd3b18762aff27393ee9720265bb23bf440b4a5b1e5632e24f2f70155ff44ded2bc10a3e205b3efdde7a190e06c95c645b234a2a97cc6303fcb31642efca2da2f55d7c23d323923073eb9e29ee752139fed40146981f750de330938466b30688ac8082b291fe8e09b1e0205f2592ea6539e03ca0eb79f5442421fb098fc47b5f1c1a23bc1e960d47190f06c9fb42ef4338b55d4bbb46f8d7cdd0722071752a3000534d89f60de6ae2bd430627136400083a00837e0247e235d1e9b03b82c0021c05073ed77f6c1de17c57da65644f9f740290b61dbad3d729439bb4e3ceeaf04650940dbb86c08192cd749c8fd1c12e9934915736827997466e41bdc45e189686204e22778ba39774ad22b77c6e17c0a42eca118e496df572e902fbb0b68bb369ba48d1bec7938a9b590312cdd98daf5349f577ab399c954b9da44f8ced06e6bd475bf70f9360b622b06ed5904f6039518761fa2c3eba23e7e16e82538f20661298d5ee164f43aa0f98933a9c837b2f2bf9346596465feebb91531336b1af58f3d9ade1b48bdcd3e00f1c51afdececa7a42c69215645204826a387320dfe7b0ebdb155c319974870eff3e1c3c4fbcf9e2b16c4d82d8752eb535eca3e518c5734caf8dde3e74552d772c1ebc1f04516c6c560da0c1d59cdf50495753f9de30ed439c18708019b38e903561ac27bd8f4afda3b60c1832d2096f61c97200aae76028444b0d362474830c3dddca24d7239181ea73a47790cb40e6f935b758d62baff9ef5d7a60b7786aff8db3ff91987604dca1a3bc2cff672e26d11149fe1a9dccfaf4d171d1692660bfe7ae34f8b060e5f22ab98dd8275ab83dc4fc09a1337e30b0cb20e88f0a8243e27c861798ba590ab3a318db9550c1d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
