<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0c5131e7094261c9f57f75201ab6bc6bb7d3cb462fab0000b474a2e462e8536cafe9bc0240a6e3b83ded1d7177546fa5b40c23a3bad79f9095df17ca53c04225404e6840c71d75c19793933408ba37787ed77e8fef7a897f4b090179d4a5d6fa3806c6b2b7e247a3ea20802b406dd3cb793a0a613e23f436f6440d45f7c10a87ad9f90f45e852869256b5204e7515e2961a66af656537872568fb77381d18e91fb7766ecd969b7e65f7cf2e93e4f17e2a48f691f63d850a908f6cde01b3608a0fbcbb0ea9b02b53ae201789b2f363408b5564f81b8d6265ed0e51b7fed5f2900733e70424ee86fb263484b5b987e3e250aa6697ce13a121581b9b3436270740242ab7bc18b0866ee76785da03c7a7d7db5664ae83523fd0b8309d01ad07b456aa0d5a1418fd5b2ea3a937728d20f0550bec5cff6be2fdc870257dd3a567957071d989d4c5edcdb8553d81731f9b0bc46066886a4150de8ee43ff7563ffc89e64593d253d1596da70ab5e6dd6e946b7a9ad9f91da82aa177ab97c7be2a2b77e078904e22d78c5e8c13bc1ca6d338be0451d61e0c3a6e3c988908ef12552c4486a73c53fe8efb7c166006bd87d370ec2be7c0ab976d1e68aaeb4025432f35f2846881ca4123571eda8144863033bb6d901ca40937758ac63552fdd8b3ab78754910ac2160ac206118fb82eefbb10475c81e7c5da75cb3b973dea2ea6eef747b220dc61236517e5ddd180e03f74b473f6afccb2345d7c85f61028a9c902d845735c9f27f533034ea4e25543ce6768fca6447cdbe0561b95887ab865cdda6053c46650324e7beb4ab746eda41a5573efd84436616f6b5a0da3f10839677fbcf7eda0e941fabe49c81051962476f4f943c04e08478c04f4b35c215a88fcc6a0bb74ce3698f9800cd03a04ba018d60e32f0fbf771edfe69c475d2da73644df9ccf06778830d2618f0e93e352b1cb80349393e52ee5451cf808f3fc4ec256306d7d32d9962b0a2b696c3a548d28bd2bb38cf6276f5f25c6c6da1f053a8a6c435516b9775b2a64c96453f619ee02e53469fb4bb6050316b040d2b3d3f65d378b16843c9029123207c332d334aacaf1c6019075f2a8dee5a9517f923f9a4410b5ca5c8a0d62f6e84d0e75b9f29dfca552da2e5452fd88f667fe65028cb47cb8cfe259fec63c52a05d2f180e5994a9c7878f064c181ce26fe63d3344d8e3dc61b8a0a5f475e773d41d5036dd01d8db2d50f2c25bcb695373eee36ea71c481fa5f842ef1bf8f85574cd340e4520777bd6a7d3a615a007e863b09ee484143338c438fe7e8271f56c4779eced4bb9426b085e3fa6ff0ff6e3c3e6a69d5e459d3f406237423f12e8c4f6291fb61ef72f822f17574eef2429c65864aa9384cbb05286e0a43310d16d03a7837ed1687b349bf0c7b46b20e375117da33d8adbc8387ef83221040b2a802bd42a9da09669e6cae9b89414937fed5cbbae8578354a0d1d7d8c67f636666bf1ddf4f69f95112aa714ebf71ba063b1caae16ef0f8e8fcece900329bda2070a6ce200288b40402112c29a14dd717bd96c07ed1207a633a5a7baedde18c146cc0ef36e19fa2401a8a376d6782a274b28ad424927484cb7a293f3a58b4e563ba9b942fa5c1e04528cb93b691b9ee8be2ac3f9fee2e31c05b600e172666eb429cd4767c2cecd1d652c8a9b0efe6e1bcf296b61d4688d917e9127cd66b3aa0b6b27c2288aab7590d07541cccc05c831ab95db590a99072931f9ae5c562d8ffd2b6065e9d42dda429568ba312d4840c25dfe8a6a2f0d27400e01a275fdd7c8f5f466a5907f8e118d240e839816a2ad04ccaead588a797deb983b9dac6e8f5d238a47a45cbc459cf6c1fdb5ef484f0debd8238ed023187f138f1d403e5c7d92e626ca22197315d32447a70e3cb9dbdba3299bdb238837d6df610161bda47bf807a953f57c49b9aea7c5297e385ca628135bbdf8c74ce3a29a123c5c8ee5ad9b6407e1e7a0c732aa1404df18da3c86e16f65eb9f1b32e7244ddde6ce2a30793ea0473054555ea8e06b2c031ec6020f20acbb3e7b105ef3d55ac8a5c47cc48b3f5d17b0d4f8f6e155ac82f9caa4a623c168a111cfbb439e644cbb11ff27b64070a9ba1d9a06bd416e87bb420596468d0399cec153bfdd469cee67e878b8fcc045395dd55ead0c01f6ca21f6b47779df73222b8756097188fdf0d0e25d333c18ec4260918bbd92ea0a1245ec84c4ce78af3030687e7c0cac7700a3b6717feed286710887650197ec25eddfda431ffe446fbf7294478698be3d7961840a42316cef631b91808dd84160e0c944068b65e6e7464202b0731ca527359b22c3d8c6085c5a8694e942544d2e776d9e163520981b0c539105fca2fe8a38642260a86964e8e2427c056a49865ba23d5d37b018657723daeed2efd0452d501195cde41ddd9b3e081cd25cf8404f237ab83024e7fb302091848219abb5b8c1e9bbdeb3692ffc6ffad4f7e121419bdb9afb80c35b4465ead98aa0c7f15023c37cc6754fe4db99e8392efbf2c7c29394f4b57ff9a89600225d5fc6e391ba23bc8c94245c2b39243303055c18e7bb6a9bda74bbb0f9beb709f5257c2642489382903bd82bed1934932bd92b559480631f0e2040a5853ecb348876c8150767b856b8f5eb19741112925a09c192fe019892689c60e364115b703d8ee220c8c33790ed0f113b6e6af05f50917a4921108db0b66ae8dbb655cfb38e026abe2926a37077990e31df76b483d10cab25d7da38e17fda0b8cdf4516a0ffcbf5ef7daddb7716fd893b1a2f51c1dac71b31cb68bcde75e797f7626099284a240f52e93bf68795117dd326b86b669a8919f2ed011f4825f1f992b0b17b12e802ac555e636cc0bef94d3e6582b59e5b47ca6ce67ad4384385ed61b08556c7630666a097968cbed03e48fca158ac9c0d9c3a449b3dfe3cb1658eace9f60be30b163ad0c1f327490267bbe2a27e1be4434f2ec8f648716d83f4059f88eac142211dd568beecb6b6d3d7d604b77043172ed49103b807c39498eaeef13e948c0bcbe315f2eaa3885f76085738835833e020b08972c5a790b05f0b8364ddf97a00e1df657ad11791c96abeed6b404bd1ad60824b8a814e364567e775d4cbc41309d301c01768b1b81fd2893b2db87617865887d361977434686a45a6a76c62ae06c8223879ac5cb9ed8eb475d99aa9a2d0e044b43fdf57468ce830df2351c2220770cdde251d85dd935316a463e9290c2be15edd16a9af28c2fc93c41b9083267f3882ba4a5429f64dc601389f4406f076ef63b0ad1876863e2f379672e68686ed4288a0b7e11487940b72a7eeb0c2cee313467a1c60d91b5853eee38db03c72e195314b46434981c69696524a05b426652f0d344afa5f649b7c68a4ebda4381d01c74e5b15b44c041b6aca20cf134b6b7db8ed37860798ac4f1b7a1286522df2ce68c07f61426fe2c1c80eac5fa3236d0e1909bba77bb8ad992a23a554feb4f37ab60e422ea641052ed275fced4f022d1fe9727a743d98c4578695d48d03570d95a352aa53bd7c1e3888c5488bc26a5fe4f3da11e07bcd622ca24eef3895060bc87cdd7860a6e3462e0b73f94ebf06655594af2aa816eb3f4e8a9f4dbb443c9b749b1caa73c8977dfae9065bfa67d387c08dedad48afd5346f98b5512b25406a17b538f29212c7f5eaefa36a628ba71feb8b11056e63e4d3710fe7dc1e1743b3f776b4c6a80671ee0cb9a4a1bc3055ed81e7f28b3fc9e8c28744108eecd1e97158964909d9d3e176b6f11abce6432762e5328246b3fee719ce78a769b28fa63fb6367b3e99bdd0ba253eba79c265a4e5c4cb4d2da5a10353282839be5569e428f1e78bb3a6266c57f9d89556cb3d52e0ecf274176ade2ffd1de6c0c5f1970c8de52050e5d83342f55d03e8d2a3446c782bf17d468eab2184dc584c46d993b999e4db19c0d1472722b3f4c5a97fb651cf782cc2f1553ad33b10c0e2a3cdfc23ae81c03dfca702c9f9a9a69b62159eeb2b89763db401bce1e9482988c8c2e9027542b8e5b029f52c9f58eeecee0b76473303bbafb76974214b84b4c8b4862883782e2c102a76b87bf2b6fa158a560a852f2790d21411b7095cfdeac123dd18f09e26d0c776a56e8f3b048a22b4f59310f4146a569f0db0225dccc220e260798463dc4b73c757b28b47747db88e6e7796f1ba1bc3c0c0c51982856550b33009a8ccfba60bec6d884d5f29cec8574b88f2454c4b5d7a808f4e1dfa519434f219a7720d4d00d0b401d2b43589addb1b17c557f45afab6ebcea01fc91be0535e2dc1f353a6eea59e1de9c756d891ab7425a263d62d58a988b3a77b8107be2d2f32f81b1f9e5bc193bbd52e422dc640751c46a9deb03a9fcaa411a65f876f17cc15e1714939dd3bf75716b66323c31cd7bf83a2ea4b7d0089fae462ab0e4674bb275f46a72d30f1e24df52db7a81f4453742f046e532cc054753248710df121d03d6e741fdb201d724a9328e1d5688fc0882800fe86ca8d24c54f7d608cf9a117237284d78c5909a9add0c1fe68a985530f7d08f85b8f8922840c0b591cc5187f31affd1fb028575a0259fec979f9bb858e016f70e63a5a7e2b7d0e525dec3e8a3916d1e048ca17b789f438aafe68ea7d78ac86e379b62888296a191010ab6ff2837e114b7a4368c1065fe98ac038b9d4b5cdb8c80a38b3f75c9ddf77321ebe547c65f742d8fde42e17f72a9fec8f1c92600bf4e3337967e505d5c915d9531384d7ab68c74b807479927d9d6a96dd584dee17136315b372e8091d50911ed3035d7b67824d757179f3e7bac79267180471b74d5d0286f81603a572817102399969366b8a835f47c04bb09a04eabe7a00c83feaa1b216e323616d9560255ee9f466df145d77eea461b9c1930df13e3601d9902cac5a321ae5d21a6d537a3744a7aa3ef709bc36f974cec8cca228bfe6903215c3401008160df20d7c44d02b32e5db2618940dc73df952617ddec8d124a6f64bfca884515618d14f5e17098609a74fcbca965b273d3b217b4a87775c24aed1c9120991d328411630eafd23aa2a5376eec22fe7b92fd5e8527c63b0a6a77bc41cd835ae06b849e7b9fea6365233e5a2eb8b47e3c02b9509a17268d84085f4df31734133a9bb6dcc8b4e52a4b6aa43c3b4d7ba41703bda75d92a3b04712c3feaa799b3cfb7b15274a1069c425706c3c6aa618ca7cd469d1ab2f7266eba4af7e051c175e8c1c6f5bafe3d842b83e91c06a8785ad4dda8d3bf7ff0dc8d59359d6d28ce89d721b65cfac549d7d492e952ba09bb543a9c12f435b6791521f7994ac653d693128347abb8159eca7fa938178bcc3bc328843ca1ae136f9e381bbc7c8adb683cb945e8e18ba3b6fba96a14ec1be637eb2f7f354d970462df61c098c3cb124ae7715da47c9907153690d839e3a46057abcd2d0ab0ba4a15ac0a1ceba7cf9d816ae16d3cc97af214f726c994cefd579c07d97d9f91ab9d80602d470659b61757d4b4046552261daffdf056aab96180e7ef7aab6e02a52371ad616a3a7f38df2af5a8b585f8d351da4e1fb31241007728d3d41ecefeea18223bc6eb08686850b5a8c670da0ecb55b7ed399f9698e74adc0eb695d0bda2186595bf678ef28b50111076d93ebb8a0a970ef2ef96e7abdd8b64db57657a54cc87a64395543b2f706331bd8ab28591874589bb8965c1a398b33905175644b8bede63d31a8e809948b729ea53b2cd9d858266bdc26ef18431a853e4dc53c98fcaf03c5eac84f093d3f2723061e0dcd2c22556ddc621f36eaf136de98d7bc93ee7366db785ce17b0b2469918c72e07c04dc4503a6117eb8ff0796f32135e566292b3e82b93a0dfe879878b402a68888b3322615253b931bf9e00b0283eb68ad3ebf5051116c1033e9b38e362fd32eee43e5dd1a5d26c8a1582e17adbd949cebfe4409c6e010fc6ce02c6942371b5da5776276741cbc0ca2ef70e48f0ec6e21f9cccb1c909b22b1e44a97dd6463b568aa7f28b8c30614d2311cb2946aff8e6b3e0f0968cee8153ecf40ff3e2d17e7dfa82d3f50e9fe2a02bd38ee0d915266731581504ccd179e1813cca4f6fa261bab9971f57ff539a5052f24def3b2dd7d7224a8b0ff916e2a755080e63c98a0d84cacb9e7047578c08cb541fa7f87fdc723b9921480afe26ce708b43b472a3b7095821863378426403a09bbc20da316eb8c28d66da0ff14a76a34c77c32902f272a8e8e810fae7de6685d002dbc11bd0a0324e3bbe4b677196760ab7f8662f2be6996b665a8d5fc054363d6f93e5a1a3252ac80d665467b89e5958e814ca6d6ed380e51ec60f7331af5d822db0a6a989c0251bc95cc113bcf391b0f4b657875bfe130f21db123d0f839cc08e324d0435fffbde93a4e73672aee49b1421df345b6b569501eb8ad7bdde856a225057b5f4aaa00216c4c2ba3baa1b9effceca8ed4f4db36fe6d5de8b5498198d11e0f8e5ebf792fc3d7ac9fe5428cd250e004b20dc59e0340dfe57e8197774901ee876049b22de9f2dd78b5ae9043e6a50d02ba5e4e47be79461e9109b3fa0627467ed7323973a5ca28cee40e9bc1b170c2ca36d9ec87db01b9d726cf90a0bbbd5d8b91df91599f71c6c471edb6ff69fb8b518344fdbbba4690acce915044db5102ea5124b8923338a6f602b1b1ba7afb9d54252c5863dfe53a303153e933e0ec677cb7ef6fcbed31dd0d05e57a39d1901e0d9d30280c915d3dd6ce9dae8338cd94ebf1eaa3e527785fc986fbcb23569c2ae09af9b17f607911a326fcee447323275396bda5e6cf173f3d2b26b11f08d6e29ef631561d8948b457b8755cc05ebba9d485115936ac8d28b5b7c5e5483eb6db8b64bd946d83cddf119562bbb6362cd23ded5cdb8d94c508ef04fa962b51e053f8a66d04c694b998a37bbfa025e0ce4e70905cdf37bd645cd95330976133fc3588d0ffc540770dc784a6b0b15b8f4a8ee55e1805631d009b5938a9bb1b738d5d733010c8ddc25af0069caf503da7c18f34493e0654d232c132dd2b09ef4ef21af01dc4ff3abdc1b072bde75ef53fa9e3fedc89d1f4f7033f7cb51dc2188eee059cd585fe9d12da7540011abc5a52a8b487750786f8f5690494e538552e6a09289eec7812e967de1c7fc079243bdf810292811db13f26c550f4bf1b34340f7ad5704d51d6050a34930388939975496931b419f860588dbe0a91f034f3fd7441a832ec1edc11dc08cf8c2a4fbf2863f4cbc0baedb19fc6eedeb8727085345bf20a3c80551f68e5fe7a52eec4696285e0040136678c77bcd3bab79bf741cbfc919b4f44c963e213f2e810d882e940761bb1f01268f4a83a8198520bbdf9b4b09945432fb192eae0eef7020c70f03c8731715555cda8541dcf044399e354f7f6cc840a08e5b41f06cfb3687ea4f44218ab247e3c16c72b9d90a033e0e8128eaf0c29e5b5382d5093d8c9499421cc89dab0c9c6ab735bcfec694d2eb69e2639e56ff4f2ba19b7938c6cf44625df47d994494a4ac8b2f0aedc9b7f4f2eca2abbb69010b5715dc29a37515263a156c20ae0e4af0636641e1609b4bb25edaeb04d5d46b65390e807a80d2c73fb7a428af38a1cd6265e67fc38b5127f43af815683528c29db1e3a4cecdedbf5fd09b8e41bfd1c2f2bf334871d01dc2678d21318b6018d5070316ddfb2b9d58482a11fe8b28d262b8271b16ac7a987827133f93150179c4904d475901d79e090a5acb78ee02cc99756d63908c9a89f81e4bf7c7ddd9354fbfe62ab9942c3bc2ceddee568aa53a24b33203406ee03af2e58a7b21332f5c0079b7318119de9b0ffca228bc7b83d0cfd50af82aac89ba9df44fde7489990980ce8782a5ce39e3eb12f75a40a30de95993b7351e276eaaa0bda9c86ba17775f45979db1b53af44f821f6c10a41bc4e52efa742b82537044e58fa32bb29d291b7097265842e6741093d74a5f4da3afcf2bd3f76888f5dcba1693c9e40c17e5c00f06148ff20596b77d2a96455188497fe62294a5d5fcd69c05442ef8254b054fac64ff175cc685b69d18f53215c70b14776026f7f565d723aef2a4eaf1fc3766f3928f9e30e362667ac262996318a844c684120a91c90ad2d24b7d3e6f2d4e762b22e6febaaa91604540a2262f74c74fe1ee52dbaa43005feec7ee0c9c1721945d7796d9ff505e1291f88e784cc3d2c062478a0a88eeebd4952cfd6891da988ea674f727c5193f85d2e484b38b187685bb3893b88b77ecdea6ea01c29708ddde5f7633c59286d4397f8fc4d711e62ad6792ffca1232c1fdc41b0c407c3044dd218a12fbbe728f10eed90bcb51d6fc8cf6cf6c348a2980eefc4474a33b2a604be96413e328a33f21729ef97b1b3dae2632462c51596eb16a335f14bde63030a4772e114d9ab4957d92c4dd08eebc42e1cd412e4b16c8cd6e52326cb5f68f9132b9780fb57cb81ee8fe230f9fe42fc486561015e564d58f9371c7c7112b5c091488d89e24567eff87d616d69b807f0355cc3669c071ef70b7f14b9cd8601e90d9bdc2f24433728147d9766ecded3a9fb5476b2a25103fe137e07c12fb0c9a422543d17a5cfd19c4df4b9a5568f9aae499f0eabdc0d8c1904bd9d0d0999a49b24215325f10c94027e7b50bd0a61b59df191d288d5ad5e2f883afc4ca2085c4339b2a9d86a4ca8b4668bc25462066dda957f3d5d8ae7fed198e23d96a48eddc99dd63253ede8e1efd93efca577f2c35b290eab74674bd20bdc1c20124ceb8cdf2aff663b6b1c89b607a47821a2f6886a19d6db64e9e2e787b519901d35b9746f5cdf985514d5121cd326c58feeb28a01029acf830e4d932ef05f42590cd9e2e1fe870a6c81e0a2cc2b87ecda27576658ec62d005a30da7f6f7063f5d08c6eb0e485035650bbc6d143fc71e3c9a7c165c48131996b52a7ea90db44477f886ed7344a698a3ce54e5554c1818866a84fa415d20299f024f7534ed91112bc707bd5924adc9a9b727608090aac8ccbb358b056400adb4c5998a44f1a9d225193de098d3256ffb6e76190179dc28b4e0da8e4186a84694a4f2b6e662ad97c76d21db7f969d7a7982ad77998d51f69ef1cc4fea7c4fd39bfdfc3762086119f50e15962ce285d0fbb654d75873853d41f667d7c6c690539a864aec625da6df35c58cf8c46f49c6ae73271f59c35473834d75a62aa0c258a026f85a042f644e2b9ca02cf5fc459dfda81bbd4aac64547f37d20cd3b4bfdcd48e175270e4054f941ebaa88e6614fc186cffa50d4bcf1292b6e5ac88870e3b1a5487c2b5e75273cbbcc5eb0f426b57e825f81253dcc34ea6be9ee907ebdec67fd33651b394f8cf843513f1b44f9a4ecda96a8679973459461581f2c7271b9e49f6424c86d8a5e825d233c23c502cb2d8147253e62a6c04dad500dc6a6b5ce9545dd10c8fdd65cf615bd9545c783d3aaa77c580e41384818df88373930b7fb27a057842c81e17592b28768240660269913455c3e854a9e4acbf4eb9d07414a0fd0efe03b27f2cf08a118c3bbd09312a1bf3225f65802e4ee5da3d80db6ce296e8de556ce8a7f7861a36ebd3559f320c6e69ca10343e00d0b8528b4583ae00d19a67e93a95b13ae23798bb84965c4474d7cb3673ff8e84c2cf281813769f7866e524166395b3813f3626dd0b7e101e7f10b62ee1719ebb0720d24b0e6bd9512710e125e41bf0d29c17b3b5bd5881477d84a3410a7e51614e51f5ee039fc90c1077703c6285ef3ad952b7724f332080d609c23d669bae375ba1b6297b6ef862e6fdd59e416b41c7fdfdcfc633e5b5509669fbd2e8913b09d385689cf05e365dc3a01489f0eee8b0823b89b970b9739cd45a6041a31165b399d96a31752dba39adea21db713c1802279c56c2db56726f8bef3251f7ce9f97ff523f6107c30252322b7460185b0586e7ae17989caca598f5040706550edf701bd14caaf7bd514d73cc8100ec643f9c2515cd18c0e1e3ce5ad18ba0354792dae3d2fe77ca13844fbbc012678e90898bd91d9a77b41e299c8f2ac50df75a04362a358c5126d250001f56bfd9dfa1fabe6536e539fc0d1a1f5ea81890e3ce5c3e79ba89fa76b0b78c98bac2b2dc3b4b644dccc923f8d4cb9119dc37113df49b3f7fb5b5cd5505937cc162ba3faf49b1f7e10f4c642542b65db6fb0c58443ad7db306027180764fe658668ce4cbb7b01fe2d46f3588c5e4832bf19a66c713f56c6a78fed2f7ddb087be425805f1bf17fab12a1392dc8e66d540c7ab2533b101b9b00ee3bbc5213dd3cc60166387e16f328794aa70562a88808d76e376a58aaa48b6efa457be0778b8b6a6339ee95b93f977dfbc0be8e77c1845f6db1ef1fdb43f009067c457738465c7504309c74f2445763a63d11b224c6076601edc7227d4ef5f1f8bab9e9911a4a85a7a6118bda1580acb031a4a7e99a9c0b771fa5b1158745a3bee613bb38e7c0c9fc112689337967602d42778bb722c70c08668c3dd71b148646fc5785102808430f0a6b85a34304985e5c1763c672103d8214c7b74a83ebb43adc9958fcf6a10d5b499eeecbe96b4d24d5b37bc3ff0e147c0890c38d90236d4cd9fc7efa4cb852cd23cb2def55ae4b6c979de657259a44eedd17772dd16c11d081b1ae38f8cd50099c97cad1690b33f7015a34fb5774616eb0e1d75b769a9d54671785696ebb532d58f9747d686eb32cb79703f8539066fe1c3ef3cfc760e763159c9986507c8f81edc0a026038151ce416f9ef24be4a15767c2950fd283a661772ca31edfb5e433d61bda078020536b6e6d2c76c7d7802184f15c3fccd7aee21b801c144e34b31dc45eeb655fa331000274343d265a159bb686b646bff02cda74f93ee0807288de323107ca40b3cbfb1dbc62cf2756d8ea3d14420f19af6d707bb81792556e68321636f81ade67276023039ed607090798e0dc078eaabd328817676d2300774b34645b9dc604820e153af4bf976e1e9de68032458c429d7420548331cf2be0a444cb06ef9af8e65c8e99f6fdb613355a4e8a4fdf722fe2fe3c621d51fefcf52450ba5795dcd9f9228c210701efd03a412e30f5d689c4b21f995a367be088df078bd824f947dde9ab3df54816deb9c5ae0092112711c8c520bdd622058a629333ca48bb3a468e1f6890da937ba5897bae80e2af54bbd25c8bed056685582607ccca94177a2019ea2dea1a6a722909948c1d4c80d0d6552a1a2568e639c34808f1cec2826168faa20229d7627f79185c372667fdf80e0e0e1436b31c5824046eae62a09dd40731147c6aa6f6d0eed2d2539b2178d700d951f008fa2d1d309c937b354d1536b6d0fcf8ae86da02167563d394847611ea4f90884114c93b75465a3258cd327498cfe0564bf20cb2bb79e83418b4bfff9744a9af087f5b297c4a5ba53f0cf8c286a229d0ee75e5e051fe986170c67ec8f42287129c4a200b794cbd50bd2a194297780583a448f71f9681bd99d97f8c6630881d8707860779330823d0af04ce4f28f819138444aebf07a7942e1609cd1625e10f69e28b6fb44a9dce5568db6b8868112441d6d3981d8b91ca1000863cb43baf86707e55af4cbdb0bb1c14bef8bdc865623d84880544fc3606bae5e5a36bc6d8edc04706ae8df873bb49e04d423472e2a17a46277368a22c0f0d5a0d1c6e505eec7a372e70716e13b18cd628d499d49b16548aab422798ccc657b276cee6301d0b0ca332485bfc3167c4c136e4d9b48fe60abe1c11cde6edfda12f5ee89a1b20108fafa3e736146e5d0952bef6c4ee2e28f92a3f2d15b7b6678307ddfc032f06b736faac5201a1bfa8a0ffb5ad47d430b6d1ec34367d83e3cf819e1877059f29a260b3f196efb7972ca9c217fc36080f422bebe55e25593047f78c58c264ad411db5412ec2e4e386e50ba0d69f8eb46b1261b903a25528ebbd62c0deb6d517040046dec7ebdcfdda9320a15ad45e304176684ad2333bee4f1eaedb9d30c1bfe280bb27be16e248aa71f0af202eb4dc83cb40280c48a4a57ceef2d6abeda1e22da3c26e30cca4d684523b084cddb3caa05a311d50d94d39f49f7f68f6a12dc2ce40faca935595a5c409044ec595a1c370085eb0383af631b595b5d8bfab287e01539a1b820fe8c959c3b719a1f7e22a7d574b758e8e7a57a7038c1ec5aca51fb0cb5fa93a79ee6765fa77aebf185d8b2d1fdee5652fbae2b608749d1b04b913063c4ac8791b96dc409286e63fc761e41873c067af7f9aef277f9d7f43c113bb264ee7fdacbfa676f0b040c82045b495b95e472c2bfa0e473dd5df76235edce1b8fd9bfdd8c9bd08365873ec0cb5b8a64a3d5e2388553ecf4c379ffcab0d5053e64d648d3b5c9995ff35c3c9e93127e7a1bbcdf58e3b8a0730bfc7c9da8a9289e38d1ea9e047b3ad0e7fb61af3b935cd8d66003b51a9d07d5fe62e8cc40a7e9fb9acb14e24fe71c8dee088636104db647d63cf5f4c182c64dd883adb42dc7600bbe897b49f27d3f41a05f5e4f4687a0cb4f5a9c98b21124e17e244555cb6555fed12dda7a4f1d0c60fe8547d6a0d51d39e1bc7c5a32aced93f2310aad126de2ea7d79d0f12dad1dd4d86c4d1b20cfad3e9bcb6349a8364c46cea62c9606515992a2c68dafb4d515cfd9fd8772dc139b66be0e29a41e74a4bfffbcbc36ab6b6aa02afab0b701baf97b98adb08a8665281d6972749eac8e4ddc19bed5d350c3291e465e4834734662fa88a9452b74f119eb8cf9a55e7d496e1fca6e5b439c216db967bad64c3199796d6f27232ad9e25f1daaacda31dbaa1085ec0b5a20ffb9cfa8446becfa3d2d1bf34c72330ccd4fa229f0432bd7f71b5d653e500bb54c9df0e1ffcf7678da5a07e346984fce32751d1ab48ee3c209ce77e99e799eba7d7362be7ef974968fa1df7a707362ce38384f659c6c0479a719fe7c03c53124d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
