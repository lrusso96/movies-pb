<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"882632b7affe5cacadb76e58aae0c0bab5002f876e35a45c7fecc04bfa097f67f1809db1446f362a24e91fe457e055d47b3e13036afebced1dfa0c4259dc1e93b3bde6fcbb1670b83b965f9ed12b25cfc1f12e13042d90027ba0cd40478763206a52e7a86d3a1a43312945bc79910bc6d4add51dfee02b15bd4711eab0c13e874c7557a6c19d46a03c3b47f579910577f80ed8237831e026f23016c285be0b8ff9099994ba897aa75197fb4c7dded6f18c145da55328bfd400f9e3c694901de01bad9ccffb7f6e3c69fbf3e1d82935b3bf54ae733ccb47844c3de482b27a1e49c7611f26e4a12925b7cc3e73e54d0d96dd927e338508d8cf25d639680c2ad2b8132715271a748b08455e96627df1313b0eccbcae4a203efe8aa05dbbe76dc4e5d42898b4baa9f0d1044a7880cc6f4204ef4bafbb2a20b9cfe1bef02eade4a0d05994ed998c2ded820666694a1cc9d03803cc1e717161ed4cd5da8199339278fb73738ca4a4968d5546c25cb325a9c143e8936fecd558efd27fc8097bad2dcf398633c173684ff460200c35269371112d4686605096ad117ace17dbab1c1e652582b15b9f3850a251908729e0c61a715516e2e28c096c9381216d7653a8eed59cce1e2fd6dd3ffed95fa2ceab347ddcaa9216554964ec8885e27311d73152d46fefd3d909e94b0c44430caf43d11d351100b0c3c3d8cf0dd1241975331b9407b862b5840a2933af28bbb6e17686c1146b53d603e1e778c1e760cd4ae90b8254de81e367328435676e754c0b1b348fc475fd8f69c872996efb99620e50c46f6601d8567ba87b7ab5a60c2af8935ece09f86d03311b2a5d6dd8b117d3a21410177587f3e441f366cdf6f8b1a71b140e23a6165d90aea2095243116c3e30acbd93f52e854dd1c7f1c31873ab8568daf1730950bc44f7cce9f2b7f93206651214ff13289df2fe298f0e352e99bb83ed8eff5c556b6fac3a8fa94c56b25b1d0dcb7835230f374e1aa7311891cf52e203635d256d7471d56497b813d780b03d5cadc1c47612d1ce6a120f9b3e2b6c53199877ee79731ae1704f5fbb6f1559f1d96d0c8f603e0c74db3d4895c54ff88de76d9dcf9b08d9490af7a121dbb6237f1d2b9252acbee5c1a177988b9c08fe9d37fbf33ad96a4fa6e1ae4695a34fa01d038f521b2d1ecd694f6ec5e3c6adbde506253d20258fb89fa30d855a683b717e6857faca9db074b37094910267934ab712f1c2bc971380578bc447197b1188c5849eafcc808a1b7b73ce100dd104da06ac6ff12704a78187d59cba0858458bd2f79c7b74e8898db879f19b9e6980b373075ad15acacc931f36b70d89e0abe9403b4fa7af517c67f2c7e0fc466bb63c3dc8b2d2141a2e9f547e5954e9d56accf95bffd8e1d75cc9884719cc8feee2524c46c2e82d93c1dcd0107461892191b3772b76df162d2bf989a2ba08083624b3fb087b9e3145da286e3786d29fc30fc0f752738f15be0a2f2d7ac7a4ab48725130bde53f5e7ec84b3dd3fd1d80d6394e262e2eace0576df4e3cd05e4d99a489066372fc03735191659c2e1c355c9c1c9036e546cdceed3e495a5089f78e610d93b0a9d0a88d81456017502c8450d4af8ccb0a2739ac97340e26afee3a3ddec578047584df53dba417de95de9667e7e0aa5a369b2ddde1c14fff972e14ece38fefb5d267d02f221d2fee64fcfa8988c3e7e3136d44ca300600abaf387090d95718a05d4955a38d998f248737447183754f42d62eeaee280b3b0c818ec26a65718c7568b7a782d5821ecccc04738278dade31b9974b3b4b0cc0c716d17f0d89e460f8c9ce336261a1c9c0140493ee58bd3d43f7ede38bbb7d697b4bcdce936feef7a64c135a24da84018be63673e12a3995d7a57958061a3f854e407db692f2935713acfdacf7cfcf32df19101e3c842c469084307e52d172f7a893b6f90c74d817d8e4a5d180ab9a883150bbcbe76dd7e280600cc645ab6e3310b14f07deb879dd81bc5fe7fc57e3200ef9a208721c786a9939ac5735e3da59ced21c228e8337d3549d2a0d84c3a966072193f5434207e0a8a46cc0c70143176c150211b8e79c208c757cf6fb66292cc247cc03ff854fc73210b2f56f02b183dcec50293a3b82325dc38c2b55afbe1fc28a4e39e61eee99b7bc9e94dee834e2bbc9d61b40101797ebe5f6e25058a95362284fb85b03952802798ceca0644a9d53bca42bf4cc3095c528f958cf489fd48ea0932f8060e9c228fe7be2691e02d4338d4d87d5c29340c908050e5a4a00ecfacdf1a7dcc7e1ea13b1d09ae6dd7239b4b9fa9887657d84ed537404c4eb12a54d36fcd1ac46cbaf917c3078a45b03006f1b2911bda93f79bd3ea9db9a289fb0500943306d75919013edceba0fd04bfa8d4cd83a429be9ed3fdd7a14acaea295a45242f7401b2868c3ada51177dbf72aacbe8931751df37ae458de85aa74328e2dbb2cf2f346b54baf038a607b71e0e4eb252c8ab165eb90ea7d5ff284bc5e3ee91a80580c8f50ddc1a8a66423a4381c482174ba55c65a40ad6b57e8c7d48798ffd83cf4d0011e16838798ef2b6a4560ed8bd122a05045cc19c23d33bd1f8c4846c35dede17f999770d057bcb5ef7e19b9820ac88e18644dc124ec103903c807c345eac3cfd1627c1da84b89ccbb9c22cd4f5ba8ab8d471155af842987dcef2f313efb26c2a4ab6417a41f342d38083b25aff9da9b96657e845984f6920a24ee762f736ee82975b143a4bf37e56864dc0abd25322f0cec018919bc59b697e228052859d2173d07b7a4cefe441808eb080fdc6f4e49963140aa8f4184d42bd4282a45e040f32edb429953f192eaf214674aad46e8db3e463ddc026deaf4cb43b99e199031f0df8d3fbde28da3de97178e25c4f8e141fd76d2656b667e06b334122ac0ac0718eae0423302e4324a30450408933685f03f213082402c25faa78419cdfa658e8b57507edb29a170ad8c8248772b7390caa9b2aa133261c91bf75ede5e3acd3b32d961313006039d692df4e5f26928040ef338341b17a74914def69c68ba371dc3a2e3147b5ca38a3dbda42557949ef7131610e5f177899cdd261f47e3e347e226efe8c81db8a929564eadbe3cd9d46cf077fd69e7fcecbc14a919d7d91338df55113c69feaa39d541148f1d5fb773a2986a797fdbdd313641ab0fa7b75456e43b176242ac68b64cba585c43baca1b0472389c228d5e6fd2f1c403300bcb9dbe902dc581e98fe1281be392a2542181a1397aed17c4048fcfc4c2c24ab7f11e0029a9da889abcf69499f5f95649128517a5898122d6a88daefa73049b68e4faaa6b90b2dabed85481a680380394c04c304a1e2fc3f31024cd660c0624df018d7390137ee2fafbc7992cc86270aaa1d18af313e1d3508c976d52a2ba3835003763e29402038fca1871a9536944faa3e368ab95b4529c072d7d4b44ece3544a296679997d935b96c5d4524e0ad0d9cfabab7d159b9108dfe2bec7e2e31cfc509faeaa5ceac019817cf44d3194be65c40bfe4b9ee178d8db16c87355ace7f313bf14b3e47dc7213d25263bfcaa2a00cb22590b2e72158ab04ab55e2b8c6335ef3404e0b0a0348003ac5452da9be9786b347c4593217ee15cc6f74c660a5c488c575e285e181a2236126cbabb28a3d088d4b3286e2ec4129d2b7b0e326c7a1c590d1a01f6aebd0cb60ceb8227719d613e60c70d81b04541e99d2c6ad618929fe8823ec37045e67bddf286264f2cdc576785a236d30a930a99773bd8525c6f3e39260f205bb2fa024bb292fe5895e9ab3bef91aafc49b9986e88cf6763cb406fbbc4fba25033adccc3c491c4d376a3699a0b1e2bb30b48a70b22cbda8932ac02f5cd7c5e17c19ca3f0f6261278bff3c7de8f9d1f8c350054842d83df6057447d8438fd3cd018415e6ad52d25bc5968b5a86264bd2ca0d3dc740bc0fb4347e1b08a5263f861d50b7530e4e6cf85fcf4c0f8f97c59e2c506b3a73b14c2c4e7d6328058a48c45270ed97dcfcca4035ea11324e8ac52b46b0c57f1ee525675022e5702e4bdf94f0138690f6552203d8c452c445bc80f72b80da97da6d64711cbba3faaa5542a37d6eef2c5b6517c4196561c3d39770188c69b21710e38a63fc8d16b6817f2ff2957b9016a7d8f5373fe0adbe6cd9bfc7b9687807760509132781497e86fe2b499be53439dc0003bb8699077cda813343b1de9dc54565a5de5e7d184513d29e9089a49c2c2f7538db2c72a041b1eda0805bee97b027eaa1262a1e74ddfec7ddf17b44351c1a8065deab99c6061fb5cc4efa06faedc2a56fdc1810d42378a1469020cb37b6d42463135ff9ccf5f7e7b6ba8d0c6880cd676f3a8051855501e321b2ca1b2cb0fa8868202f0cf444d9a8cbbedc4a79357407b88f858d42b3243b82c4dffb5464062849caccd067897c32c1583398046cbc1a169690960a6258796941c9ae8cb07196545a5859bda6cd3be3593d85716c5e4193c5611b2afee8df0135188cb2aaeb11f348f9072ef4fc73ef67543e231f011c08991df00d35f3af28f134189fef968cbe053fba7d249d6d9fb99737777f8af42a9ee35bb7ead2390f206b4b64f39f0ddf29fe09827fe422db222b90b2a8ae80651f3dfa0bbb620c31a1efad10f1a8345a937869200fc2ca60a3d48bc790c399b15b1ff89cca5b936c10043a123e3de560d9f3cd3ddf9154b42c2834848dace93a5b2d348435555b3e975f5a32d8880b2ead9d944a1b9fe22225969c5a609a459e65ed7e7586564c9897b3b79afba169c08d9a5bfa68281db0cbfd81d981310a0a0a4b19a8b3e0b8c5f1ba0aae4dffd8c834215a71769872f8f2fed5c938e29c2a54252f8fc202c3edf71aeaf2433f63ad61030e2093da4a83535c694a3fb07e5c5efa93c64228b936f884818262e0cf8db1a54dd9beb3beb94a771085a8f1ca3dbecfc3e5eaea3134938a2cf52e566998e01ec8df973e5231951bc140de519183d1148be9f4e93d64f02ab959443c2e509885fad40bbba1d51c34f6da985a329a0d86935f55bb9212fb09f30b0ccde40384143fb224b6c22c1906e3982ba52a57d9d5b31567a45b752f2c1091ab3f980ac0045bce84c9c9cb050d4e830bbeeff9937f347e705454f3407fefadedd47e3eecaf1c0ee04cfe3ccec09f82ff83f00036ae8f8f03b8006d418fe1f9d9a1085095c56338c47908fd9e3c4fe8b1330753ce4a7f05e2cf4f29b101e7f1e81764d00d2af4b354d117a09b0dc58cbc987cafeedbd723c4acb03f2d6e5f2bcbfe8a295c7785be5f63c9ce529f6095e38d405655459bb2caae6f244d7dd0d6a9a26f82597c0c974f6adc181a253fae6c169ceac3d5eb8cffa2a9953df38ca2e334ddd7c59f075966257a5dfc5145913f5207bf587dab66c6080763d3157b84491d25bcad966fb879ace177035814116c9ee53892ef333ecd2803b6b436721f869b7fbfcc9f1f57b5b3b67fda3fa4f17cc4251cf66647b41b8cdd23e37247fb399057f77fde1be38666e4277fcb87f860a40b907ddf5f4cea721d2952a83b0d3e8610164eca6a0282fc66b296cb6e6d29217b67e5ffe2101d8fabb8d2f9700ff1f1a653919dc099027148898a50e59dba0f7773a576253949b84409fae4900ec84c8505cc440adb0886e66876caa8e62bdaa6471ae161e32e2226930c7f0e660f743ab571a16d3508d18081e3810b3e2d5fed39d1f4c09ef342da1e85c7f9ad29169a2fd8607eb4424cb8fcacae4727dc2568819df693cdbb8ab3c0f43abbd88a2d8f9006d1b91f298d69106f8b16c8578da9b9f323de1326c98b80aa07c29773b23e2d96514e385429d4df644693c8053415bf9258f221b42ea07f70a9616d4afe362429e5f3e440ec67790afd5adfc300068186df83ee75e3821d8291b0f12308dd45f9c210f8d1dc1ec747699ac3c29095e43285948eba1c4e417d6ca43d9e523c289c82e1b7ed680105495522d24b7ce5dd8889a7cf73ebae499e1155e2a806a1719481e065ceefcb2c9b36b3dc933f4282202537a70e228a39832a2466dc5f25c5302ba43d1d2e13b8bcc7ae64aeb863013b1a14d03bf195c740c8b2d5e336494cf22df6d85e8abaa8ac43a4d9aed532a6e9c7562d15d3f52f6db41e7205e033caa77593d73168896a00e9bf9aa7345244a94cf19c46d1cf78793c251b8b1f815d9b73b6b8e066f99b6dafa906a5aad9806ac99ce665f2b3c839acb945a495ed131b6eef50ef29c11ddf65885b9257db701df9bc3e763d692393344f8d447279720f1b753ed7f15039e8d542a4021f427aa8d8f053922e984f620d66d2a38c6893e5d02e64930c4adcfc0434ccd9817ff8d6d799ffbfb724c17696da688d0aa437b2847f2c89882c7f8adf3fa0e8efb44ea02e1d77c4652aa3d87672b200e98e6d56dc54e8938d7778d3113d06b7d508d8a5e016eabeccd3507b7ad22391f568b26db1c44fbac2d9bb546d2ae04e24395ca09727ed934ff8dcf8f132380dc3cb6de4ca94092aba214d2c2e4fd58af8eb01eb1e0257f64c178877215b8ac25ac98edcf3318b4ca5a9d18dae55769245afaf149b38fe2aeb0899c23f2fe4cc2775b4d759b9ed969363d420f4bb19edaafe57c77ab6474e05df6b9956a8478164b4fdf61d5b2a851d7837af67ca09a087e6a0002581d583925b0adc09340d222aaa20db376398c3846aaf77dde07c4f8a1e1c96e79280d0a45c00278aa00d8858fa5b6533f44e63f4b0c5aba0bb8a6a25850bccdd39238dda43ae705719a3f418c18deb1a1720fbecb439f79c7b3991be7d09f1618b1ca8e7bb0c23146c64ac20e4938ac94513d4d52b846eebdccfcb8639ecbf2edd803aa3d17826c826c153efcbb754c0b4b076892f82d6f2571bdeaef339623f7c85fd1bc1546299b7400f96b64e3bcb28371df4a4bef982afe907ad5549713f0152893866109a3172cfa944700af126d721f556eaf8fa22a92ae66ba8f75328e4bfc3b7743a000c48a5e201a3fe0347e521c8a004b70c361e3dae478aa6fcad12be39ad6496921d331de261209e05eb2673574b8711dbe0276b5371907297b48002757594c760ea2981d13a08b37ed5c934affabfb383c56d7a5a17abc39ff89275a94ae5496d5a8622d65bedf24080a595b4e3a6c076a30771ed639bcf618310e102c940540f4380e94044320cb04202750e6253e870bf7898fe8229a0a2e920427b95e74c3fd775b645234460375dbafb6f3f2a4a58907ed74af28d8713a1ffdf0fc5d28157a329538b0911d54fcfed288b959a977fb2f7c3363e086e54da1db002f859211bcd4245bf501d767632134e989a1e7d2a6b814212705223ff9395d20590f93788c883b73ce187351f9fe48eb6039c64afd3f091d24900b8f39d04d8e7efa47135f479b0b1624bdfbfc2bed62d2577801974fb326154b668821977e4e44148fe7f97c9d3a38d7495e42536e41acaf1d02e01fb030674fd3d5336577e46764c1a19e5dfcc8f3a48f58e693146d978b0b4b38bd0e1941158177bf8553cee0c77775f59f62b84281bbac2c55e621e3de85eb808690ce841e574f9e3c870c6b79fb8211267b05e265df10eddc99795736238c82125ed6c4642046b0dff6b586d2ae71669d2c7331c3ebe900b7334a0d27fce8a85932425b5c4e738674d346cc1d94229917d56d2874c153223a02cef0c850d68be8aa2be5fad2737e5604d861cd630c8962976b55853707be035b3a8ee3e10b013c5c2a1e7e7ca932d90ea8ef910e8cd9f906f37ad197b9c463e4a81b28d4d8e7c702dea60ab2d82bb6649dcd35ad855a6b69fd6c061db67d76cf0e6762afda5e2311514e4fe36509465be902058fdb82358e696c7ac86efb53417db5e01ab9727bf576ecf515efa418c1443cae4750e5cf5d02a79f50fd31d1b571e14b3dd53271b7479475d101cbc54b57c35a41bccd13f8141a90fbd6d9c69c328f69d2f7e71e758456e9ed68d610c245918470d4e478285632ae24bbf6f362f2afbad49838948907161730a6cd9b2895d93c07878db63c14e33cc6722153ed404853b6defef9654eb99d3a61d5eeba0b1a5eaf30c95da08bf7a471bfc54043290c32362ec6c20a00ab6f5a5c7a4a596350dbd1a9fbc628adb6350ba10d07037c907f049ef07ab4d97ef5015c314a3378c86d53d425cc7e4e3a4b9e75f2bf9e4526ccaf160d90ed20ce532c270607c120c45618a34432b41189da62bf5c710f2fd120de52fda7eabc6e9b5d90c7d8adcbc16a7bd70eb40d60474c2345c38951cb8d54ca29bc6893ce6c86fd92717acdc18aa04d4dedd1ba07c6a5a583ae032420fad75a62222fe431370c796f9f1190943204ffbba355a81c0d8115900952abbdab82c5588bc0b84bf07db974262c00e6272ed3e507c0bb674fd0e96d60c70aa025e7d5592b1dffd2b3e43161254691e2387cb1fe92ba96bae63bd0f761a314094fadc8270d0428df2d14391da04db602ebfd4d61b4c6aea2a6c21adad98bdbe7f772c7169576b66d0f31971b45082fed28f867e8eaa2bbf51e1363f7528f8f6b5a91acbee324d39babc86c9195af49071f9d5468410e2d7ff77c98b36b64d521025af8a7fb3e278b6d8eab1133dde2afa4a03b056b48b88e8bb5205bf6551f53cd69669ef381ce39ba4cb6cf5bd553566d748610691d8dcf215b6aa9ee14608231a8ad4aa8df58bf36f24a73b276a62b4cc56cedd86f71ecad8166fddd4504bb0d6d4de07aba4f91d2192254a537145dcded9bde8bc91653de70e20ddb2a0c41f528a45c5d4a274ccc2b73d9309f0509c94ecffa62f3f83d6e1be9a98c1d23b665e083d827a9b7773d960c2e196a3b6a2186aa4bd52572f4eb11438b51653f921c3c328dc1760f7b4621167af5cf97ba853311077458bdf6e7da831aafcad9127a6963b7dd0a4c2a0a023093082251edcf3290fe6e0575d62b1f5d003c0c42e9b9dbea9e51596d57e56bf2cefcc9b543515a7e0bd74c416f5cbb78229dc628940e0c2da8293b44483cb1baf375c8960a00851a30368607a3fb10f15afc08f697484123f107e39db56e9cbaf3a90a680becdc87d12801952cee54ad6287bfd394b6aed05cef265a65f24451a34174211565a4371f627c8d61989e598d31ab4e073824d865e2da78ed76f4ebe2a1c04b7bf7bed6d5d80991fae997ac25d8f3efec60c5c7d04f73ad59aa5e85e1f2c0d386d06f86c2c0ce09312dd555dde42c8b3c0e250089451078e9b34db682895227511e7e2080c91999d4e90c4a23a8efd1f23a87c274a200a5e44a2e86c0cceacef1e17e5ddb8622b5f95668e8448ab85ca3dbf83d5374d495cfd20b0103ab047c20cbfd0d531f7d7eeb791db11bde9d467169ded4bd1428626706e02de20525be70f613f2982c618e92a6c49fa260eb98b9adf17316f7a2224be672ff50e7bd510d35fcb268bd0160f84eb00942bd13e62153b989ba06d5380c3fcebee5170ca3318011c9d15e061911a6d5d571d119e5c48739905c07e08c8d1395aa19cc5a19956f7e390049c7e66a32eb8bfd3102cb0347fd5733ebdf20ff12a0d7a42f5c4d8309daa0584709b6417d9e45ba57377c0ab7c6cd7db51ccb548317349b7cb8b05e02ba31d1c5434c8d58f8e0ec7e1a19f9c0684bfd21332c785067dded661d0af81f1804627ce5b9b4952e22d53f1e0cdb420aeea414bb8a739a4d694a4df74ba63664b69da5c1365f5c93fa149d0a4c16a8ff306596c7e87ad4f3c422726b2a76cc838e7ca3c7fc5600b1d9f17bda0e3b03e7f3c8c7088959fd2ec0096425ceb8efb1056cb09d548a429960248d3520da161142c6f39262c9fcdb4eb3499cc7a2a1bd27b56a630d9a82889d57b6375b7d348525027628a263c8df75888076adef1ed11c568ecd0fe98f512b3b4dbeb3ca96a78f506411a2fbc4d4eb622c63082cef0f7ca87640d0fc6d9cbe04479017f3a8dcae55fa6b12785c1cba4057a1a7790e41c853ec6a196e89c82bde5ad5e9bddb39713763e81518b5c4639b48f7c6172c4dd64d53f860c92ea855389e7c8aa77ac70f2b129fe35c5a52c97beda8146620f6f23ad14fa9ff1e339c5ef6bad68e66df58bf4add8b445f267cc68c3e95194fb2cec3e23ccdd81325bd327fbab63b7de5e459083bb032611cebaa74f18bffffaa9287c2e005097c564b03d10d7fe3c8f494d2582e1e12a3f9c9098a1fe70f310b5fe54a28e0f30cec1d03e2aed62b531bea20db639ac8cce7518fdd27c07d259e8ff77c4835decf1df743824dcb3717f909535aa5331002a4b6786787abd6f765b222f78170b2bc2c6f86c01307b619c41c277579f46fe41dc0396ea47680b53fa58c9f414fa4ae866b04029d2c0c953c1758e4e27c88952877e1ade744d39f08f5374cffe2a64b10ea7e9beb7126336bb16e4e1d20342b0a36e77429edd07d106d507bf382abac11efb2ef6d1e35a99648f54c3b457f33b160456a2385f8d38ef888dc822b988afee1d6725d60e6b3a0f4ce2cc9fdfd686b2548c6f5589e5babe664295a9c7f9b52aac8eb230bf76271be24ae3775f2e1aae306e2b13de189b50bf1c850b437995c68bab309e4411a2831d6570827dee20fb7c1dc883d70fe91949010f3f6ef9cde29bab8b08292c21547aa5f5b7f649eee50f92670c3d755d643c7c7938364be3ae7a5f303c507a3034eb4f33f9d4116db3444ae68158689bddf6a51b0c0211591c0a0123282a6726f67d1662ebd010a2e1fda41872c99f6907c0ca523421108d7c441ce3c82cc5c1a3762738cc2a89c0f9757a0a14a0d7f28a6be17114c27013f21ef00e83068f9458d92e3debd30b3d5b7b8ba7c1ed1d4ca7cd63c16bed85ddaa1873fd890ae9956abbb295d1f5da2214ae32a3c88b882e38eb26c227339c1b9096dcc98a50ae2cc25588c3069ec3ea00d7b875ea1d29123a35a907b36097e7c449b7284f09ecc1b507f357f41580d8325bab5c93f657af2f8145344d8160dbf2885baf5e4d365c57ee7740efc60c71eb655df0338fb0339b3e5cd8064b7bcbc034dac716ce1fd631f3ba1fd675def2bf22217aea8517a52e9636c924769ae58f622d815b41529763f8f0bf217ecdd7fe408f2d4cfbbe058c372f2383cf6fc28ba9141f7c53ef4108c6d0700399437d9f95bd8e17adc75991651a122468984b65b35d2a0ef8b37692245a5622c642f46e533a0d9d6619b5fa80079c4498ace04dd499e5ed920a58438e0952e73c4f8280a1493066a1435711e7e2d9badd5fe8534365e8fd95b1144d989b5197104c204e7d40e616c4302a876729e0439bb621f76043aaad99b76dc039bf5fcc55e4e4a54361c15ed3113c1092c2c8d23e4bb75cc544d9ae26a4ae7533364288797f61a8b902a1823eb226e47f2451a8bdb6c162dd8782b51410621ad06f9c04698a210aa092e8f822fb5cea342e08638c0260d2f43ec7e2fbfd9485c68862dbc9758feae3895cc4da332a61339ffab8ed81c59e9a1bfd96ad332df60e94b87163ad1ca9087df10f04555e45b149815eacf8e11cbeb1c173fa7dae8ee6a6c7d21c83a678dceb08d48edb9bc4561192163013a4fabc9706f06551146ec83f5152a2c19a1356a8e0cfb5575df7efe05aa2ef444e73d031f0ed203267c444de6836db3ae4f812d6923617233d1fd204ed27241e9a8b86196013ddd463c0c8988401cbd93ee8a0b7c280bf06c222011c42d0eaf936bf60ee635ed786cbf4e39e6ef50946409d5c9c28d2a8b468769af57e60a187a7e257ade533eb8fd975074bcef3577ec21ef4536e2eda20cc18e7f8a83e23c8201362588740330ae859bc76f546e826c1eac4dd401141015057bd6294e8b24e594115ae282f306446e5dcc260fc9a269fd68cc37166ad608fd6e381f800e719bd4d39bb566f7a2d6e935163f095611b22382427a3e930909a55afd55adddd0948d41a58dbfda773d867ad04d7f16094708934e4f4b0c6004bfd610e89e04e5bf845dae2b5180b461f948806f3f96d02f35ac8b354dcfec4aac6cdfddea8ce6bdbb0e1ad72f03d21ba00df88cb6ceeaba15e3aef2a6f8c135ac0eac9e2f443488a819baa053492449b56669ee6c2479b8847618d861794c5bd22139aefe5dc1cf8317eb03551b47098f3af4e02d5878f793d947e1df99dd96715cbd5c5f86c5f21e8f47408188604561aceac4650cc2abc83d97b4300939195345ef8118188436e0dce2ad846e8731a3843c687c060c294aad9f671b70192c24cdf35f201dc606aa9e90631502df2c2ee159532185e645f770ef11ff3ec6941c7405c46bad522320d75cd14d6dace05fe56ec2d3457f3638a668fc79a1cbf9b43dd80d0fbb41fc2ce6c49e1897c50b7d54f9c5b03dd01d45c3348a2765f48160eca11a64126d532764c103d3980feed054aa00803e39dd7dc18c684d50412c82b57f10430bf8bbb4efe2ed4a2c9bba83492326340d0dd559f232b452d46e85bb2523f9050086ec064d1550b6f84d691dc1f944a9def2d09474619d6d91945b23a06f3e54d5bab05e9f0200058430c4827dfb8c64f9cfdc575ecfb13ccc334672f45ed57ebb72326d2b620912f0a7cc02b83e9da242664050cd76104cf5f521fa26d1ce3a9772189a5c7264fa5be8b14374489636007b791f24784599906e287d6b5f0abea7eefd7fe33a59f3e58dbb25c75eebf37bfe1b66251e4f107fd8b19ee83d99e972dd66dc1236bb4b26985a60115edf591187283393f0a9c79d26b523265f5d055015dcccee03c5cbccb5b4020d7a829adacd49d51518dabe05391912a5ef8b3ed79307ed922d28305c1ed45445a0ca0feef7c67ebc1d549c2fbf1673c0e579ce9ca52dbcea1d25c0168c5fd4f486a8ce1792e333f3170e9a3cf5610012b4982c591bd52ff1194bbca7674431d079ad62bcf4e8bae329cb151d4257497438315411e2675081a6bf1280fe2ebd37d12bb56e936cb4a071213db7ca9c91b38ba358b56efff26f35852ce8040cc9c1169f256a32757639c66c6e477abda24820f1a30ee6ec9657b46273fc63aa5b748a3f40cf6e547038395cc7ee5e31b474c9d5eec37264d798301ca2bf36be6a3fbee7a67685e3f5bd1e7332ebe383a6888eebfd4fa5110330a3a6075f25670593921bbd5951f4abb266dd3fd3ed3ea168d9d33697178a17c8062b1147b626233924cd056873a17fab7eae357c4d4fb4e6946bd1f83c07e89b0b0ba94320762618e60b68a26fea8085a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
