<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f3146b40b580e00e1e5ba32e0f816d49b0fd18c94e1b2ce9bb21908000cc046a8b0ea984675583403f4f55819694b0536c6a13b69f6c6cbe6d95da6c2b0a6b14df2a93ea55a40d2c74184f56c4eafdc0b89141d51f3ddb1b18bf56e5ea1c330bc875079139b9def346df4620a116161fc5839ab408289b53aa3c97adfea415018c5392b7c019fff1a86f4552ed06a19b1dcd27f307c7dcdbe150c148bf2b0130eb83fead338d7273b08f7c2859536556515a9bd476d40396a077e0b47105fd34dca536f832b3589ec1be9242aaace2b25a815733a737f1784717573493fc748d84128a0f193f910e0cb182cec57de0ca8983e296053487a98f9a7100b61e3bcb170423c4585f321b366e3caea10cdff89aa5fed79c8fd684b057c05fbfc7da1caf1b4504bac87e756dcebaf257c988b819e50dcbf04776270d12d3dc97e3a799b9720a09f40288b6b8f394c5eddce142c0e78a958ceed6ec85e70196a1ee55b58632d7e5c34d8cb575aa62fddb02da7cd5dcb150927ecfad41b600aad70b605bbdd85e4640b1b7f94a295c7eae2d5d1a93a0e301735989ebbede84bc484aac296161e459bd83cf7c7fe96a0133eafca736f50a0e7dd0c3fd3c433a6ca9974f4f9caa72bb0be64620ed9105e6053d732f0d1e92f7505bcbbec959c10143e171bbaf09464cab6de371519cb3aef057aa9cb33fb3c9797b73d846dda8efed72a814661e40debcd28fa48c589bbdbf35d0903da7767715192aaa14671eb6f6359ada25df1ea774895861cf44042d0b9a2a2ce2c8a36fa772b8803d422a6d2136349a42ee34e0f82b4031dc8ae1e871388c3e8d25ecbe2fcdc00a5fa57670b7726b655366a1ca6fa9c204ebacbbd99c62738a05aab6387a74448b54588a6b40140668e69e07e22c0dbee7337cb7d16fdbeecced10246c89b54a20b79059d7d4541fe17d24bda29ddfd386ccf8dc104a0e183d8961082b0caf726e4442ca328a9d20915ac8396b1f4b75a2a7024259f998bb08d27d1fa728ee06a1508d815eec846781659847ee4d66e037a8033284fb04fc78bd8323b2f80bdd109148a2f7a97fcb7a036d23a30959f6cb0ef3fb9f66af5cbc4c2c746046c4ff0da2fd5d68584725d39ca35b6e0ba3ce600cef51ea13eee2d705af28a76137f509ffdc32963f4a7e0ebdadddfcf98f8e1c106f74929dde2ea076aa83699f5f7bb9d4171523414ece483fd2d84e29f93df4ba9508808256e923b9b4a7a75068a2867ffd5cd7fca4d0846bac794d23ea50a0f7e84bfc0e36cd4514741bd6bbe8e08a9f90873ff00bc7e4b59b2b3a8ffc7bd39cb0960060b575fb8bfb1f32bd209773e2f73edeb8e82b64b52e768de4360dcd8dacd151b45c82364f79c0efda440760661867368c93dca36e2d52bd622ee13625c44bd87e28cad817a2145faa3e6c7640803906094b8d05e993ded165ee6377a11fc12a5b4a4a15fd35cfb702747886c504a0b63b71024b3d7c304826c175a7d706a79aa8e1d802d0acbdb9e20f9d363cdfb121e98fdf10860444996635d33fed28e2d9646a719993d21206a069f139cb4ba4a9353666cc8def35cb9709cb43d335f88f5034a4177bf8529c4626625215a05b62f33ee863df63f1224c740d973cb5a236b4a733e1e6917dbc2d466de30d161d939dd5761ee445410ca9e654c062e88812bfd3743866bdd97b2e97bf3f51955ec570788916b327bc6ae2810d6cba73c7febc63e48b1278a552824ea3842fb7bdefd268422c64ed8807532e8750ef8412b92585afbbb458200c885bb4140ee0ca89a49a142aff8a91d874c18fd61cc2c9e0cdad76acd0bf39c69b684f92000c55f1e0f86e4327fb3d62412469534b77224dd010f0af18c27aaf031f49f46b9adaee3b302bf63e92a7bba126f05aa0d40cd06dd9ddb1c7c51370acc5f3252c5433bc0db279f07b0b619717d207566fab3ecf33f76d15d8bb81cccf640900b07d7c83b78d4ab0f0385285289fc522182b871143eca1a98024d38a2745032da8f0f3ae94004ab8183998839eb63946ed43ccd859383bb67bc72fba8b520efcc6efec6621f263b032af310fa8b1efc62875175f9252a7a4d3090dc72c5f45f429a1f18c3e4fd89f194cc5d7a445f0b5bac7bf9853f912f32e145bf7904f6d8a1f337f04da08cee9fc1d983ae90af6a35f54ce0761146a53808370a46ded31f1af5543ce71d3df14b17e1ba713f12bfb82fb06483c6361af27f0ff3f55cb42bf2f29b8fb7196d95789b524f72866baa92c7b8857c66507ce976c0c25b35ab7f9da4fede2d951efabae0f246666e49bdd76cca7964c389649a11b01145bd893298d95661f107480ebdd785cfd38049e9303653f9e609db0ab607acf20e56510f7f3839e478b390d75bfcdc486b20fa72dcdfe29fc20efe8e272a146f97877be2f6d774c209e8afb017b0f3562d382b2b090f036b5b4133a52de3a1c341e81b73437616b689deedccd9252678b4096a3999be642298f5c449a812ffbe81d5a3539f6c0944ff493c2c852ad8ae6f6a6b381c4a437ade52960aad5561ef9986dd5ea2f230f33439d0c1bbe45a0bf2b8daae9c1e82cbc16b30861dad86678a52daf1e1f8a6fccbcd934638316f843921a01a34bd77b05cdc86cc2d0d2642867c04a002df21a45a54ebfe9e5dbc885cfec6cb70108dae6edeca7ee58a7149e72e1f4de9a7b50295965cc5c6657285beb6def2ed078ce3020e9c3d96136fe488c9917f82902851f74406760b4c27493639c967ee654d7a57e5da176ddd2fb95c5eeffc3363d6a8c4770104c703a6313479f2ab835b6db830447d73c7b243c051894e6d6f8181372540ad4fa0dad9899fbb4def8819325b1d3adc7e29fb56ef2885d0c669bb478ae72a5bda88e4d54aa4f95c48bb326985b38722da75096b7733c71315e8fc37bec377ef403082d8a02989f6ef7c569983bcc83131b047b5b06652632b0bd441404efe00021295f63c48e18094cdc7cef9f48a1f4d0952411a006027e30c33b6ca58b8dfbe9c3001b976a01dcad177c9a2b37a970debd72a5eaeeeddbf2eee2d49463af00d5dc7688daf219e435661a8e7fc1017fa9dc028da82e2ccebc5bc8f620954b6649e764f2ec9067e9667e13d25b9d7e92614e0b2f82c188865fda6218a64aee2ba5b4ef291692111eb0042622dab112faca71d6d69026a0762c795f489d4432fb7e4b8987d1e2f390a70e6f2c3d019d39303bd317c175e6aff1160dd49dd84f31c9a0daf03b3ec5ef94ec9eb81eeb8b94302a236c37ffa0fa40c3facafda77db372e71a16be6dc32c06fd2ff784487db52a6c8b1803809ed8676dfcf259d20623e04746cedf7e89facc1ce3e394870b03390e9e0579e4226af2b9103f7a8595240c00778178fa3c075214b8bf5d98a3a99e783dde53c5181d349b8d8fd527a9b08d9fe33487d8dcae3185eca52ceabd9b0a70bf69f02ee63ea8aebd4c6b50522dbccc974607a283bec779de853d37c470ea6a02310fdda2dd9a61248e96784b73939bd27f92a45026c4e25c8ea032215f8be4954eef13b4d812a8d6dd41366215068ca24bcbc6516f6d074dec8ecc3e101274a827b53fe0a9b640d39b9d548ebdb031ae82db5ea2902733e9c6e9d2be9c8432792ef66804a035692f5767411afbaab40673f44bf553338a85dcb2768cf50ac278370cbddbe3b0eb2d4925526c7ed6ca6da0117c5ff9aa374485e944fbad58345355c561dc5ad9b36708c4de033aafbaf54e65b66cf6efcf4d892e6341be0721d366ab6ac634861dfab9c391caf2994eb7530415027b24f54a8ac3a8bdf5b153d8bd67cf3fa6309826f01fd7ecd580fc3a26efae580766ed291943c3380c8282af2f3f093f3349fb1ce357667d0b2d2ac8946a11899dbeb7fafc8ad006680a8d67b104f1e490134aa3f310fac948e0466fbd77eb9845ec2130a089eaffd12ebacb151d3f436464ef54484870862c1bffdd161e60ce3c03f831d25a4a35bc25ea6e971538a08ef2f1f1910e8af7faee16826c6314f2ab01a36fbd824a4d538cb3f73e9f2f3cdd64f07cc7e5b00e0673b8fe5ef408c4692496e5d4efc4d59f854773f45a608c9c9e99c4e16df44ef318eaaf85424e06553cc70c4445b74adf195d9f7345d9af7202c188d5250bce054d4e2493e09151e9cd0ddf209d3ecd9282bfbb66d443b1753a50b45c6a8d34ad6eff9cc18db53a42f88aac88793cbf961abe1e644480f70530cf5793aff8db942ff5353503c4023520f5d46c3eb098fd703674d6f53fa95bec1d3c3e9f0a0f86ca6d0ffd1cc1f4a68b47584fb6fca300f9e14c0b232e7e9e86db27ba6d2f9277e7bde3044e167e8ee9fef1acfcae5a4b0c9f2866111b17806ae40183147d9e56fa850c1456283967d62e1fde0ec8a34d750c70abbc99b11e7df2528edfb1d415e828bc0b7fed22522a46f570fa4de4cdd6939fd5dbb9a7f00f7e5626da2c2d5325b93da9ac5af755c6e1fefe4b29aabeac47dfad7b7ecd585c048ed13b0ce1df59829e6ff6c35cd2ab825e42467042acbd8177ca87991b8254e1815e2e9e4ed92c99939268cc198f98e7e1fb923fa664a5b0709ca909164936c442980f58f53f542d4e7ac5c884acaf44c9e6fbb302cdceb40092e1677a335734e9d3730bd6693fde8a47993d72bff93457b030c158e64f0680aab28cb03ab64319028c1892a4c0d731810beeeba963aaba45f86ca887199deedbf4294c0b2534cb40cc7d42fb592e2fb1fe7400d02f9d6f1a5a341b47e6d15b2c1c17093082e4c1ecd0b0b571c5950bf4b607643be6cb8577dcd0fc49ac8ca7704d98e2058413d0034623ae81fe5fd237d5c2192bb0b79fbd0117b3b8d2b6ce4ec93776d3173624c58d76ddbc1d4a081bd511c7a81ca13d9c4e971a3e6bdf151e2c93ba545e78d8ea8714bc0a42c47fee036b3c5e327e3490ffde7fc98c3ed7487ea8a3d7be82986ae5501c4fb811fe43fed66efa0ebd3637621c28d1ec03d0d1b5c1bd9b1ce8510b3344a0a5ad5730082f93a53a6389e224f502e326d2d0f238b4709e635a85c5c01da8069e43e2b75308ffe129eee3b35bbb1cb2c8d69243cef3cc1b4bec7585277872415ee6f41dc4a267f16e66121b4a6f6c69496a0f7f39619cafc1bab10cbdd6df13bcd4e28636fad6e9eb0fee1aecdb667fe8771c85ed041ebb46cb66134d1790f3cd5f328126dc86fb4e1c7fbd037e94762fffe4b8b63b4972106c1a857861c7d3df11ceaef97e1c2cffa6ca38ed99828f2c29ada3ea765a4d11f3826afeb1c6301ff03e48e616721c67a8e049229600a842be13c04170f8252f4cd028176936516d681627e92561e12852188ac570abf9fc9f9e4712f3971bc9c68159687a884b12d800772061fa62aa40ce0944e1484e85e5e4dc84054bc7d9b936c50d15ec5e81d114844d0cbd982a6530c8d5906e7f8f2795bce110f1d0a44bd817eb44594d139d3fa03bdbbc5a9f22aad608af289e5291c430b88672c47e8e55aefb9db7597159a13d43cc824e1765415a812d2c3257aa5861d5400147186d2b379693da60f975a44b389d8c71d5307e2d65ffbbe50614de64c0266f4f5c84be1d3a4900368b180f1eed0e7bc9029c99cc62fffca87dc384f001cd8c77884334a75bbd91444857283b677248d0b97c8bca3f93f6da94b69df37c8b616cf976d3ef8453f23407e27ed778cf4e0c08ade1b5162e55eca5bd7c7eac7b8541a525da0609fc3c73fccc1b5064c6c15b8d8f1284c46b6ef6f26e46fc30d95674d3f589f227028f9ca414ec6ab17baf01ebaf2f9fb8f97be1b1de8a41f101aecc5e12f1bca8ffba6a45cca89f108e8a47a96d27f7b199c59f0a038fbe3113a1693503e57d48154cb6b209d911af0bdf3e80ca543f82ed67a7b8570b445c5f3a5a5412628352e65356216e4251c7430d2fc33b8f74b1e3c32e5b7f04150ad283cb43cc178290ae264ab83d7a04aeba1254bb75e3cc3084223d23de452c03fabff206175f38a88025de3a9e8c174313329a4063b9b435c99420ebd56bc8fd1a26d0853d07c14952ccdb7a26459b4b2a4780b9691a3fa0cb13ed7a864962468ac9de3651d561c8ac835b8073a4eb847522d61329ff5b50f980099e15b2979f1e66373165a9c2d3f2a13a7326958d10672d95c0604b83475c7b0a1532ac735ebc101cb027e100431d748c292eff9816dfd7365255d119cc0ffcf385e666bc4fe354c19451ae9b2ef3494a436964b6d7d8c5933e33006573b0a1b3ca3e8a7df892dc5f5db5837d3ed65fbab5a57537ccb295bb801cdddcd4cb505c2d5619e46e1d7bb0bbaa4310ab57d3c8bb4aaffcae97f7970d33d934ff0db2603e56f00ce5da60412c43316fe169027e2e7af07333ea57da0f02b7582713225d40e849f61a65e5c041ab0cbcdc0a21609b8f66716237e15475790d70205f19b92397a8ca3a2eb84431a865802dabf8fc491c21281844464ed457241a6123c700cd61943fa8a761fdb083b2e0aa303e09b1cbb674d61014c66b38c283c04bab16e9b651a8273370eb3723bb8672d05d0b9975a62a74d8ed4acf4eabb376d9a6fcd268a8675ef4ed090c7ed8fde33e31eb9cdd4f20321e22420b925b3580ef5861d5d344df3bcfe9abf333e0d4866d7f20e577b915794bfa7fbaa9cf2b6803f6f23b53b1ecfa54861f5e763ba2c8041e78e3e4af7654a4222493d05f4f6cf3c401b41fecb075ebf9a90f3abaa42c9a32e51ab0120e5cff29c813a32f5fbf047708771e459f2eea6210a2fecb0ba148b24a68f982297453337f0b880cf170a805e81a4ec9e83dff57b92111d7169047bbfc71dde9990a8e6b27cf3f62437637f55042ba1332c5ebf2b37a5eb4e7313172ce17cfab985acc8b70604633ce7023ea8d7cceb3000d1cee9660e0d606df188b7dbd662c4b12fe7c1c969a36e3ae61b96bc5c160efaebc7d39132d1af47a07554d88a11687573b1084b8481129063f9cc5abdaacbbab38435faf21d76d669278953c03badad27d4b0ad465f855b710d2733f04abba72d9ebbe680cd68c600374d0c3225a313ade302618e2e134e51439015e18506060db805643c01beadf9b43750784b8f987060c27aec80369f2dcd3ee264fec6de6625deb9ed5f91690920ce47009ef0b43ec898d2f3aebf70a3680cd9ad9ae4a7857bbe92e16726cbac243f77be36820a67103c0266c6e530cee36d77f83617652ff9cc36df63a1a334aa56524c915a5e3ddebd07982b467d571854c436f7f74a2e4d90042f1799d91b39e0ca48be3b638a0bd210f2b9edf5bdd1c6c093d87b2273c566bd21422d7684cfb857acbc451ff372ac2a6d7c32d3909725e85d2fabb2ee4a0902afe8b22b6870bf94b548882a817ea664db2748ff54dbd69ce83c4b18a636e7e7034e98e7a72fdf32adcb765d4ee8b35d307437dde3136aed5486c67e2b6f79b068512e479305252694e86830fdfb5d2584721ac27a7fe50fb198fe5e6651f61b00e29958dfe4808e9553a83fc89aa6ea7d6a9d776158a17f2c5f8f4e61eed318baba165db2ad8de44a66fbe8a99bb1d459100e306fee9bd75a93060db200d72ed84cc0e127c9cacf7e31bb02fc78e946ea084e7b49191345bf3309b6d82ce0584946419d9dca21aa3444108cc5decbdf2f28943fceddda2ccab325471b5a0f44abce00aa7348c4834d81bc084d81f21536dae72df365171a1bb7d10819483dfc59d057dbe2a28890255a8a38ee793ee72895a56ee1c15f059180e2b89dbcca354b685203a313f19bddb2c09d5fb5033285ce9e704e21b64d417b326f61b9ffb04960bb0c633e17c3685a555c9c87ba37f29d89db540e11ffd678c368189a1bc7ec02d75e754524e1622a723782e1efa37684a9838c5e8a41338e86e1751a80e757de82234976940b481e194a22da998564eea44ea10d3239784351068d29a798f65cc4e309be7d795f684a17fb123ff53d1e2049dec3c3e62f3b4983ac55135e5b799ed7a3c3f9ed072ad2952a77b5af7c5d60613e5d016685b4bc218273b5c80298343757f943f4356d723057ac6adfc28efe1f8dae0eac2cdd226069c41a4f4a071eb90de805df759b20948ed6e960986920aadf489f8e3397279b3efe0a1a8229a60ef3e805f09dc309622f679c37f1390aba3c31a30a6640d1a0dd38961b6ff3b2546e47be4099cf15f41916b48b82be9a5d80925db0369a59a70fc46c8a5112ee3e855c4d11dbad8d3a9231c63bdf2f6d5e1168091a5ee32addf319330a8fe09385af9581a839589c0f5f220abf8287089221c225330d6599dbfe5b6fdab2087086659171fe57112ccbb7c9922bce531bfb1819db74b195290180d9dc7c09a68ba21759fa55345168dc51d6467346b37874eb25c1ffa4f0a87e4464a92d06e3aee905b67f3bb667a19f8cebd71866e7f56802977be74c69f3f072d0117311f42eadcf904417047e25227ec8610e05bc6ea64b85e43e067e2c2312861eef4c7842894a9adfda4335c099ef4ffc22b4a2d82d9ab78a80b3e66b75b483cc219d71908a00df5eada34a3a6a14f582b43d279a66a67accddd71eea4b2d3742f0f27a5521e16a9dc29b8f0c85859c68feb99923101fd2367b90f6c808fdd9c88315ea5c4981af637b6f83627a9a4521b9aed548bc9d9420e2c22492207d56257f376be8505aad36a08047b6cfbb3a8d180125fc7c99fc3f565195ba98e8124191665d5546cb3444266a4aa825198f9267b7ccbd4115b2cf86d8b530330d91c66421c1a67e0f134d00d5b8f05e429923df4716050016eb65c278b7a81d2556f98c41727b4dedddc20268ccbec9041940632718c9d3cc58717b8f5b2cdda138fe1c6672fb5f74b04aae007683fa2cb4ca69ab7632de1a8b6523960f3eaaeb468746e92010fb4b88382f396d408f7ac78f0105d99a0003eecaef00e21ec4822eb588b6e05eb67befe8beaf1e5e1a89d8d91cb76ca2228b230cdeccdf326d3659d4373895ee3b498372c680145a3e12b345f37a4f3a2a2836e4d661d7280abb424b8d5a64ab64fddd0e7a88c27441ec4f60110dc1fd2e4c864b8c680e26b88150345a3947f644e3cb456844289a0f22430c4d792a730cd9134deae56e0370011e0f3923060b290dbc49b16878ab4ee8bb579125bbe1abeca3f1c596134594771d45a3c4da3e41db2c8364693d06fdba8d47a028190487aa92ea901f0423f65bbd9e991b4fbcd83a82c33ac40cbc7eb072641c288cf5369c02dee181df668f50638e23fb0f5c4ee0d44d7b0b3be42fa90df2a878c195b2e111655d4525387e539ecee70ab3e53a2ce1ff7abc08089e24c94e1c3283c19c13868c232d099ece13101ada26a2c4db61a99870c24aa91318cafadb3dde6dbd29798cc076c5a5caf500a0cc67c6458b80bc3b070c72a0206d9e8fd0b09ea16d1a0cfc4107f49ea83213bc0e2b336184108c190f7adc5502f6d41dbf69d78e3801bbbd6462076681e3cb5f4d521f6382c7ae9a5f33af4f774341b4bf394833bae2e2e1b296e385b82a01b8a49a79cb331e90ea6cae31aa2cca95a4ae68e14f11de4d635a7670c11eeddab73731a4a79823f65644fe1033ffeb626d76b15bc48f1a35f38ea26e7fd61dc6b6be7922443cf620e8bf446f383ac4423e194fb14fd6d6433a2d37a9a3eb4a8271ef140d5b33c57c9098a319e1f0604a1db5a9ada322d55f75c7b038baf0413e6d7c8a6d83369c5f57276240b0acca93bf5ad62cda041d7aad7c425e3f9228d3d88625a00814cb76ff74306c69b6ab041d7a7dc62e7d28ea9b78e6e9aca89f91307c47af9ec8aa94a8960439d9192564d8be488465a0c0b5ad49f297a623f3127a12e6ec5b9aa578be1d1dd96dfed4dc412181e6159c81c3da95b5eb62c6409dbc63cc912b1f8648f7e60a80a505b47481ca561735a062317f2cf7b2620116da3bce70c0ea63c2902edee61497a65016df494290a86282544c970211a5197afb0ea327e5a8ef1cb8183ea0f6bf25639acbd9f9cf41c7800a15c7d5e94859622c6c5dcf38d2506480d3469ecff815452d953a5a113c614552d6099505bad4381c692e48d4fdfc73199f44fe7cfe5284e35cde22b68f7aa5cec4aab5f20122cbb04a81b7952f380c5c3794528879129f066b4e1874d3e8965b4d2176da0ac2189e54c04105be8998d3bd9fff017e9b2d0f09f7623018eb8b8968f8d50b1e0033838cfabee8f523782862d14216a58640665d8d4a2228ae530b52d130dc18eb57e5ecb059661aaaa0fac4194c911ed144f5e8ad4594b51e3c9a010df7cea912e3c0aabf073853d2303dbf18ae49411372c2b3de0429f81b9c7eb6f93474b18d1318e82b1c7951fc7338f0b8b697faf796aec9d337acbd3a941e09bb7d065eb1775ede7301e0c0463bf42c17e1d66754a67a6749eb7f2650d0189523f2d11e386e77ba536a877329ee1bef990976844e419364ddcd8e75e4ad0ec05e028e559d61765a6e253d76a66c2f560e56e302d6e8405baed9e6cbe320e55571cebc92272acc1f534c589631e730bc7432d77df4ec1e311f10c7f952ba22cc74f2c29370767dcc20e2739b39bd2b7251718776b34c3dbf64974cb8d355780ba37a7cd08f50bd6c791e51145c2c91c27686e27e66c84f1e8ad6ada49accf0f1bbd7de8f5c7545432b0921cc1ab241214258f10edd34dae1ce40d782f3b9cc57dc09e5ead18b566d25fa1d856498839f5bc88159bd8f39493dbf27119b15178455d8a2b979e86ac55a64eaa0905e211eb51c9e82560fec1651a9eff8423133d6d849725ad78e89e4764bd1772118f6f2135b9426f28d96a7a07451109d3c0c09a591f6d2046e07cea30242ab15e9fcfe5419545bc5152b33e85d43965455918b2357746accbff750b8604980e0b21ad2d98bcac91c5fd52a02f37b0d55b28a4922c4b2d570cd43e64599f7b76851d7f256eddc4faf194afcd65f1c87596056e7fce92a0a686e5e9f66995b7d5cc5d416f74dbd14594037b9ce8aa99d38b247dff5e55a0c2259f2facb469a90456c656e0efc5b226c6fdd16d2a147c170ea2ec18f49846ac3826ca2f11d5beedfbd6b95fbd7edb04de5c88a303ad2519d4917d9bf1bfa044eefd31b852d512f3bf83b77669289dfee141ef6c6fe3d92f36334ae5bfc23e9b41d49174cb906e3100cd3afabdbe1c34d5e7431e69f6ff7de4bd97b64ca20c6f33ea2865eafeba94032a6443c63481273f44f7cfc33fbfbcf3603bd7709564447689aba33180e45946c4d1557c0e0eee275adb50583337615e3136732c144849e3a2c0061caf6fa939db3d62da825ddb0ec1207022a28485b409fd1fe5b95c4dacf068647129403a6d8d3d9c7392cacf290aac2d1f0d05b21789f8abc737f14e638e2f69691693cac74f2ab33a745b0689b3d25155411e9d78252bbc1304348f1d37331b34d2321cdce43eb15c327694297a9522967cf173541441c7f8a7e6d77302302a763c7410d2451891481993ce463f4c606b3e205dcac3994d9e18a79f99edcb11001e62c2643318fc24a8e4add9a0aa4e0118ecb0b0ccbe6904696587f9047d59013f1949344e3726548b1f5c59b0965c3ac369ec1baf210242d3b7024db4310044b4b88f3d94b3a2120e500d9ecf313c6cee6cd35e657904f556f6fd1a66e6108f3c848e7f03b1ea439df12ad6aefb425d0b4a9670e2f5c5823ffd1a37552fba792733feb791e1324a3967e63642b69b483ac1e77ea76c7573b5a4f11fa88797947f410c7847a685addb269810e71a05bc13165f424f5e63256a6042765c5f2464d6a07c9e9aaab7bc0cf4ba825755db733a2052eae175cd3c30480a7ea16a210309787b2923386d543fc41a35038eb2a38505cdd1b66ec39c9317ea228b1d25bf4cad9f234ad710fa6b46a423e6db480a2441e7d961f3eedd46b80f780d6909fc7e5586d02811c1729eda1e351a2531cdcfe6f6382dcad960933c3d13e7f731ba8c915dbc8cae3e1a73a8dc818e35662a183ed49fe14e49e7db1c76df4dedc9d1be6f65fb0dcb99b7ae442d9055603fc62146b896c05246e7c24b30442cb491125bc5ba5247a64feeae736bbdffd9a5394e7b3cad1acb335676a4506b113a9a204f728aefe8b2e54b439032c34edf2d7bed3adee60f2224aa0af892686af16326baa8795f4a4cbe71e0e76c72ff3636b2edf25c12a40f763eb53df54faeedb4d94f9d8ea37042d484a4a164510aa5553bcb723c36c27fbcf4d72aab5a88df3c74270e3389c9629a629dbb14bf1589af0ac4d915d0965e7b53b7ddfb8cbe2d2c8788efaead15da687424e992d49cc1d9bb4e6a2522cf1efce07c01092996cf17c22d12120db70369e12f01e8008b97e171af8def4d71c4f28f494f27de1b57a7d59ebc80df8e1f6e8b8cf52c28c93486c4a03b8f4b2db5c511665e44425dc805655b617efe9cb8d05d42909956acb7af068448626af71ed4057b085f9f6a716e5dae7b3706d815f012b759c7965f7024aad86fa8cc7edc69405c9b80c98ccd6e10c268190b148067e21130815b068e6423a191eff49082ad9195aa086421c7a41e14b324bdc774ee8a3baf235576d974f0249fe2fe3b4385121a84532a34d3de6a3173d5f77c084e6f86c159bf7cb4d2c40c0a0eb8ca2755baef21f2e7193af3946e219f662526dcdf0ec78229a0ab96510880f9fd66c654716af90daefab5bed315bc7b3d58d7479c73fc4751fcb34b866a229efc1736a2efe24dc913da01dac6b888100f1852e76e17241a380dcaebe6c09b86434fe2ef31cb0425a5b4d83f3d38ea5b34e933ccf8ec8d591e3f2a00fdeb4aa85a8b92390fa08c9ad9bd05954d81afb228ed025a0a1f4ed52035932749bb86098c07a18e9841f87dd4562850d84df1cf0048369aa67d820f71ccc2f776b967a27d7ed852a3114d4a4c34c3d2e5caced2363b927dfb67a9a48e5c86448d95d4069ecab4009da84f47f585ac125175483ba3ee7fa6d932e2fdb2c2db0488ac3649280195170446c77c2be05a673d558a243060148456adfb349b68e33655dbcf9cf2e90b55091ab700afa709a98face7ca81482e56ce117fa50db66a7c4adf443965f097cbe34c70d4a95da82306d8b90fe4d1eb95123c2a08adf2d68adb8ac264f38f0e7ae3cf31bae977155f6e8b6c53a4c66e0a6532d8e1ca8cdbec727fae51eb753f338d45843f309d40a9ab92076b3194f2ad729c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
