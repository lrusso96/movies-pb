<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dc1a1bf285e497cc07a26c5ef3a7e4baadd8a979efb42e06cb8b7a2d3cf58bd73ffccd2468e5f67f6d79dea7fc44fa2721c696be6395c57b7b0ea71e08183aca70498e2f2fc3a0552d62d35ed184df2d014997e4e60410052b0b2f863887e178df82c7eafa418fcf6def1b7f5d3fdd21e3e9eb02dbc4302062fa684deb618fbcd4f244f51310e2647a5d17a2daa33bf91fe5967f5f5fbd7d0f49f48d9e7295dd7b786107601b964b375f455e0dbdb0de75aafb9c8b30782a5f5a46f2c6193fcef6f5d0cb89e758b4863135ab02560385252da4f176f8b81ca6d04b8f04e8cb05f6d1cfb982e94eb2921f52a7ef969c6c71bdd9ba63004c1ba97ae876aaf43d2f93413afa6461f2ba2888252ced99b14db508689015918df2264b1a8b9d4fc137022aa1ae939b6ba1772ebb91d30303524331d3ad439f94250d8c5869c841a142bb76a9a5cc14aca531932845634dad5e8342ba67599fcf3eddecad4169ef1e8645f51b8e693dedd31aa34fc99315fd04ea7d5f73d5ef14d27fd5d2afb8f5f2681f5e893e691125c93519abbc8ac741598427be0596b1c08584eb05f21f0eb4c5e3062744187976ad2dd5360f05fd8a474d295df631728ff148cc412bcc1849fd6339e45c0d1a700946e079dd813b7cb1e226fe5bdc5b1ecc0afa5ade4c2797e38cbd6e58c714cbe50e8c407c2ac5beb1a9a0060b8108dd1036653cc0616c4cf089bfde03aacb926de3d9eeed955d10905df116a40ff6884c37bf4016c3b2017f8d8854ded362ab10c42a80a1877ae122eb4cf45751291df7f54e61cdda884f3e5765e06319741467a953689c07cc409e290c9008f7213dfcc6b4983cec229f232a46c9fba0612f5972378e881c53248aee3cb2218faa793607d59bad0058e17c142a8287c7fc6234a04c86da462822fd6f97b88adf26e3efcab219ec546caa87c833bee39a2cb27d7c321b1df0e837e870d66fe371f2189efa352fb47225e1bcfab29af37bef4b7e0c961bbad634d7dabd560a0ff51e33c2496ef735c5c4fb885015bc15e01c31ce08a57eb03f8b34379e5b3ab4814bebf28b3833742b4838ce72a1a581111415958369131738f9be80f58b4eb468035a5632ff5d91ba4d270713b675ad5e29b32844b98a6502de657462fe7ba70c780ac4a8ae66e20200bbcc51de529eaf30d71727c6319131eefe41b3165623b81501a7544c03f8e75351d172d7442fd68d6d924f9238b3a403decb52f586258418d96f54458c8d772ebd88b7aedf2b0da0d63dae679a419136e7c901f4c175f958860a72e514dc2ddd9f6e9c6bc6def504925170190b99ecd8e925b44b925b63d24ec09fb7fdb8339726e3ba491021b3e4708a309d5d25f371470357f4252d4fedf0c77151e0dcf2e3134bc7a020a4f442d29dcd8a8a539a77d04d6c5587c659a854f148e7b7edd385010889f40df8c8502c0ee5ce78575d7aa44411bf92ce17bdd75243e28e5698b2d3d7d635a02d30731266ea7a761ae959257a63d8a2341c4417033cc2229c115a1d44d91599f5d7c4da3f18d6fab4f025f871afc949fdeacbc5ba211870253cef3aefe1390efa2a3c5b70c03467dce07b305827c4f6d91128a7898961255dc2328a846b8227a07e19cc8d3606bbc482951c20be4df8a53997a9840900f379aae1f0e8686c79d481deff9712d8f77578370be15a71d3e6a4dcad4265ad4baa2a749890bccb4439271ad9ba161b9033865dff01488d8ebf4243582a6bc332136e4cc4e80d5217e19cd7010a3ea86af65c90f84ca399f4699d2d17922f827c250fc4246b4ec5bb5b60d8c854420de52eb06ff2a8d08c4f60a229cdaf440205322542a39f8427d29ae45575b445dd69a49c01b2efd9fc4bfe52307b0e81bbdb5d8fd050e2b5a5b01614cad219eb4e876800607aa4f5a5a1fa78583b993fa2e6e371d03004b5f48d220980b513aa3fe028b55a84c69203ac28c8ba22d36fbf8e3deebd76d0319169f16c07b4a7042c22bddba13374c1209c9e1fb5b87827600324bf4731fde59527e190dcdb11ac7890c29f139730dc67489d1ffaa53105e0c1b45d5b139c407cb634c6dcb437f9a4918e8ee86d65c156371fc4c669fa4ca3acf5e99ade879d37e838b26322b2f846ca8d55efb2e9e6fb62842e7994569b57d9a7a292825830f69df87c0b12d29669b3fb80f4af0111d7e528500a8e70d1bc6477990586e70900e7f5dbaee72c31cb593254581484ad732914d285a674a7c00b4246f8e5a5c78719ee503867e3b4c423daab94bf80aa6721a88ab387e1b2c90f28b4214bff7269825660be48cdf4d861ec2edd6fd89c1e2408a362f23f022483565d27374c300084428715686bcdd1cef4e1a30be145cc809cef33831f0f847e1828ee8d087b1f63e28c1aaca6fd6007ead7299a4c796097a4a77ab41d1561516874b373e17da0d81b5e63bc71b70607a594c35220f9ebd505c96783fb387eba152f0856a5fe37e31aba0f5bf9f9667760e9633cdd72577d53161c4165a4b52493188f12031eb19ddd270c6e9a28fe429ac004d5b137287e9c7f1dc0ccf7fbde0b3b8a0c66635b752e81ff61d0c3991e79bbbb5b142f664ddcf6708efa5a81e8fa244420f6d9c5bbed3ee592850b2b25eedfb71d04fe870a4c1abdea70c11ec66aaae356f1ab7ab511c52b32ae2fdfc885fc7ab792abc79a52e99895549d2b8bd58e9d6d9b82eb6644e29ee650fcdc6674d88a8f0100b1f06960411378589c196d7774afbf43400322329bd55014ff8f7074125ae4ce01eab3da0ef8e301860cf8acd2eb88e18ac0bf5b7a3b60ff3c2551a099113d0a8afd0b61aebeee89cd0b2d6e096904671fe1136222f0fe210f176207059a97002cdd768433c723da7790577d26a09b87762043d42716dd835e08ee4f5ff0641435f94cf6e05b0ba75ed30c8526356235260cafcd047ce07c615e3ec87f42fe0dc45d3e556b4e0b1e66908fe17cfb1cb2da3005c73b347fdb46075bec3e7528f865ca7ad982bce35ed241c725c5d7e1eb330e8cde5ac14eedb145e57f25954e72737ab3756594e7bc1d165dcce488fb5810683c388275d58ccd68b83d7b1613dbc90919f68ad5cb175cd2acd4c1228bd7ca25b8deab83f6fb587141d5c798a56b16c6c322559833a748c04da78c3e13536b97a250bae6bf7741554c6765a06a7edac0b68cd66315e5b8bbe33d524337a3cf9aa6c922bbc964c7e4e853fa32b2cc1e1e86a9d09dd461b2c72fe330b5ebda430acdac0ad4c0f7defac1f27fbfab18200caf65989c8accaeb3901057a069f1275169312ab1d90aaec21b2ca9b8dc618fe9dff843610193504a1d59115d04e3c0d04d726fdbad12bb307862b80464e8adce2430512344d67ead469eacd47e6ae5ee930fd401716adbf279bb6017e53396495ddae52e44848860ec1562579da219e21f3fd6a1e7513b4eefcb67e91a99d337bb26c4bbf77b763ba4ea787648026d4bfac996109f88875c916eba9b8f1e09838cba315e84119572305221efff2a6f4cc2d2799d3433f5d50251a17c429a66cd3a67ceb2d78d09b55bf9d0c3879f21d56de3c38a3ae0870b5dcadabf4bc80c97fbe46644bd93ba41c793ad58375a601596353c12d887cc6d418f5286d8fcd18f9b12ba01f3bca27b706538aeb93f7680be3db88396f3164754ce65281a81d52c3aecee4d7c6e41283e1e2ca7fb8ef384ed12a43e43c37c0954a5b5fb1a9bfb29e46cb742730cdb5e7df4a00e773bcaa82611aa52a783800b8dbf59b78a4bc639ee8393791b6d5273dcd40890354944f1eb3625fa6c582ab92da5b50b2a2def1d474578ff6221cfd5cafb57a8105f262a5772cf63675f525fdbb9543f2a4a20c7448181f8a173f4690711a699fd24dfaf6f6cfbdf3ebc378e0fc306af9b5e521763386ce0399c0a4dcfbe4558b363d9b6fdff7871aaf25efea131798e37d1485cd14475022628b3818434fde074b9b2880e3501fa7f8880942e615ffe38ac13358a7b9b9c87f7539d5f9b7bc27361d779e0231016ce983d55be7ceeabb6a403a22c8dd1e576cc28e9ea0cd5392ca3c82987863fac35a1fb721b6a304d2e53e2a0d58db994c8b2e1a7e189b8c5d1c873afdb6ebafa476954d251cf324d3294b2ae627fa4418fe50f86e4d1569ec29d0f0c633ac1e022df0967edf14bb8fea6c5197bb7e5c8f2059ae1486d15eddc3004a8189301a4f7e4e18bb94a1eba415d6174786d2f22b7c1aedf4fa6d4c5188419a6871621531302396e8b9ce46d3a9d4bc9904adbd53aa509e2ca28e680eed79e4a98253d7fee6c71fdefcf57b9416afcea4ee3cc411355caaa4217a337a18ca56d22751160e3dc138130ce3be665cf4e497ae040bad35c5244c283a45e1264b0af8a2eb487e4924077a23b17381dc50a9cec84bb0611c1961f82b03294c4288362880868aec80435ab78fa0512b67d6bb4a45a948f43b202d296b7fe02026163d04e4ebade2c913cc56e18ce43056e79f787db6c4fa728bea9e583c86e521d83cfc37b501a506b9927cfebed5ec342c2e7a84e4ce1ac8fceb405fa747b11cadd880df46e18428cde6ae38b282a282e493d3e23e15808265cd1543a0a05f5aefdf889bdbee00533c0f0d98fc74c1925fe08f877f1a62bacc9064bf138b6535162194a3c434c1d3f25f100ff5dd21dc47e84f8c8ced6bfd3da6728283d4477d3236d28555eda9cf58a22492ec5d5dded47d6ef25e5318124d713cb32810bcd066b0d343910c667f92dd140539bf254d4d427fb02fdbc182d4a862a32b49fa9212e3ae422341a1d7e06e279c31e97b0aca7dff78204579d48d0b8fb6e8d11200b81f2726cbdbfd404f2869376c4c4d4bcc7a4073edec88909209343757c8062792eb7c5c5983a67b45977c2af479abc633eed96b82930677feec7240c04cf704da79561b9ce88b82bd70c645435ad3c6c2849da500fce0eeea8e15d43fc6565ca2a9da15d5fdfd6b3c20e208455440986cbb2c248ae0d785367ed92e9d98dc1323bcf068f0ed24cbc1a76e6ac11896e41c829f0b9780f3b7440991376e13680fa30e20f29ca428304b48fe076170ca0fd06f978133e666e2aa77fdd5d820ba98fb76d68e29d809cb866311129ca193f69e1ff7cda7872bdfb5348c4ec87eb94a6652e84a1ab18e3148fdf24414500c0e60773326257589db1a4ccf38a34c9a88f8306c0c9c2084203d233778a988791a0e242c304b9438def1eb3c24650cdbb3a78650e0742b46e5bd532922ca577d5bd750b1e623b2776c9838b47e501af7158ee59a6062bf66a0c807b72623cc0cd05eb7dd30cb3be8a43c02333f2288997e4ef6fc9eb1a1067d0da21812a118d6f0204ce97a4ed2b0d45a95099b30d0eb94200603fed7f9224abaa86a19a3f22894e1e84cee26e401e3afd1d2a9c9d010236e59fbdd0b35a064091cae1c32c3459dfdbb23b2cf7c99b5364602f15a178e02350db0d324103f6e56022bf9afb5b52136d0a63a68a962ee8e279f8c7ee3e9e988b0489b33751abbdc8e51dfb80b5ccb709929d8205c2c12b5836eed7866ad97875ba5b481cc9ee7ddac5ecdca3088ca1def1ea3c6cb8b55e8f273743940be77b52093b744038b3d08623e9cf15c0b48eea70fa1ef7634e76d58c1041323c4506aa739c300830bcd58eaf53dddd6e7763703a248093f4d1317a86451d422343694d0d42db14d6dbf0923baa630b39eefd4e926ddc4f4a61a656cfdcdba47506fb20b9003a747cf93ec2a5bdf1bb1413642f5e652db7bbfe59cb81454bc8e55ca666b7ded12033fd8ef92c54a9519279ff7a3a5fec182c45812034b7cc2a0259e18dc5dfa159b74a2934394e3cfb2c07d5ae1699e46ae62c070777c3d694259edc722f44205bec267cddb7223c8846b3651968877173c12ab561ba9a55b4beda51c947c9be35df9f1e75a197d4c417db05f8a3a73eb49dfecc3bd32b6298799a1b5b5b149aa008af1a931e073b9817f93efdde54ebb0cb726675a1e29700e66260a8a91c901be675c553d742f206994ef87d57e6d813e589aed6be60daa534cff66f44a2c292267f7ff6e89484ac3dbe19725b07a93dfb0e4eb6c8708ac8b99cb9796127008ecc48f8a71fdf28c038031e136e36e9632f40c185ce0f26c59134a342e118791756857dfdce6ce3c99ed20232e98579db7c0a740cd4b3806bedbd69508613a6e61ec2922a420765ee0ef9b54f386527c0b011fd066d674018cac05d28acb24efff05cc3aea15f4df6b9bc5245e8106754092ef302b0966d32910bbddb7494a548728be5bebb60f979cd7ab35005ba83ab1b1b7c87f9f36ee41afe68100bcba29e74e3fdff0e265e89670fbbc7474dba8f0825895bf5efe3c40bd44c891c587307edb7014c4a425a77f903c7238f0711d3d1ac2f600c1c42cf1af53f4654b91244cc88e2edd93acc38a5290125d7293d134b538fc065583b363b028547acde03041f8c1aa02869e5a41033706bf845b82d87ec108050da72f281eb540ecfdea5385a0198e339a6714783690dba0bedac89605bfbc8a9e046df0dcd566014b78491f2aab304c637df504e8309af8f54b8c3784efec5270c7913e656aa1eb4959075ed6f8bf678957d7233cf8d9d591155bc9af00b562f6262e8822a17a465fef88a4b20be13040ac9f29f2a44b8805ce5a48a362832b6de5c064f36f7ae7a3ace14bafa74d5683e91b1b5cc772ada568f9a23dadb0bb60c40aa61c2e60474fb14baac7d97e7b431efd60a46d4d0376337adbdcc51169884880be63accf515da60ea5d425e8ff30adbe150ec8f6637f4a6b5cb5f629aa35413d72a9089f1b7677d3f4ab6457e0e440611e658c7b550d12d126bbee52d53c8b7c2b070a5f13f4d34eaf567b127d3930012bd9fc77ef5ae4d8d48e597fcd90b4cdc223567d379b6683807bb03f5050fe6598025554336cc6ab9b996bd65bce2de837bafdfdf4980d63ddd73e00d36ddf56649cee099403c209c392d50312dca6b8b4b85fb285a10c29333df213ba0148d575b5b2376170f7189204edcabf1863117386bdfde338c322ddf12b1241233ece91bf47ef13525c7d00ea2f85c80c89a510a321ce6046f009871a24a62c7eb8b35efb4253db382d2606abbfa3aadefb0f7e0111cb4c7f8dcebfd6fe7fd0e670237ec797f9c537d2f8af4b338828debaf24f14a7911535a1696b42774732494dbf6f0e3c21e3d6423efa6037d28ed54251f3cbf993c09dc611ed1755d42d5ea7e88764209f36ae7ab04770b272fdc21aa93f7069956e00a49a6b25e1caf42fe82fd06f24e1586fe1ec9ccf39268beb141621c46b50f851534147a7226aad50ab4299f5ab2e6d29cb25a6239aaed232bc3e8edfbb4527705e95784d67444c5e82e8149389ec9a5689d7bf68166befbb380f64e7c6c03e82a18b22eae13019253690df3abe4381ac09fb8233b0fbf4d806efcda41c9b680321981ac98fa1b402b75e9e636ba60cb004408a96ed80b6452da23b87c0db58744647e780fa6a6aed0672c2576dc896923628969d0b911e9a07dd245ea715ea867d0371317104919638b8be81e49c3471a30cc92dfe65da6782a803cbbcc0af7ca4650274f9f20d0bb0862c550d0d35edd24e838515a2a13547b7af900d230db547ee93e06eba5f20b443d84ef9671026a8dbe6a8ea0f4dde9083be37e652845422e3faff13f6245dae3718c42bdedcd2325d67b154500fdeca62b79c66fc12bd094e4b76c47d2a1efc2457fb491461086563ac1b3361f4a5aa8f75e0f3d51e51edca53a2c66d3fee970981e78d4e0897102ff85ff88890f36030b3911f99a8113ff7a09405b6825bfe69ac36ba625e41f03cb2fb16fafbd68ea4c13295722f7282a9e6b061fbf654477bdeffd4133bab15a77c31ebc486c6085aac034f9b08813af2ab7533fe9ced69ded4f42fc6f894707bcfbcef18bdeb912655db175e72c001e840abab6e0c3cfda5c556bbff0298e600b308e5cff3ec481cec272cf01695abd27938e052d7aaf9e2e2bbf39c6509389efbcbb368f2df728964269abcaa55d3dc79da4429e4254fa807166f2cfae0a45901cb034b32d05350d7088e8eab5a218e04925792c13d9434520b27673044eaa8976142eedd48fb6eea49b597efd268b1d4044c74f43ac0c9f428841d37c30ce2659ececd5b8417762ac21bcb8217844efc4f82b6a70a95b244d833b7cb7718e114fd3fbde94f0b773ebad2804e1bbee2792b3d4294fdbf936bf55ecc06745db5f707a5c0b54f76a404ac104e29275afac7036cf28ed5f98c305e48b1de752f8298007d24ffdc8bb1ef136b723a2de28eb187358e8ecf3935ec5bb7853c555cde7fd9bff59011c289e1d80bd6dcf1466e32c253a92ff2bcdfa2b75e4ffc0af06f8e8c66722220d6bd6c05c6feaef69f01d85dba62cd268dc6e6586fca76e075c60dedb1c18d1bc06f7cdbb7e8d231dbe16af622eee89806ed1677b30d2a8a6cc41e7eab1a4cfb02bb2e893090ea5f96c6b9d51aae525e82984bbdac7705224be23706851fc71be8986e2c3b4dcad92b474a565ddb7ca0d719a5aba613bff0c04424af107c5c2d3ca8848c34f983f2a6448b88c537309c75cb25d57cf36e0d1a1f75e29233c3574f7f3d02381db715a4c517f37cf1b9e9226dcbf73ab0c3379004680f91a1dc3ceb6db7370537920a6b203e188d5250cfba6883840f002928c5b66ff82ac49485564ead0dd175ce157488daeb0388a01cf459ee3e1b3daecb61d1c4427ac064e1e0de969de7cff8d3812d7f5d4c6e6c3624252740693526f23b8a8ee1733b596fbd299bdd2664ad8b41f4cb8df667309d8f1057ee02e232f8251f786ff050de66c47b3b888cb74d16a57cb32b081908099d8af3d79caf56b5d912d537c569e51a29f06c459b087876fec0145ee5a3d72c4587b545eeff5412443496fc093e2bfb01343c9053b7e7c1ebfe055baecea62e3e784b56f928b54e841f128e7d917e658522e802fc640dc3b57cd4852c0a119e9aefca9a7c3ed3be81b3187b721cd321df59077bde8d7c8a9b5d7a9e3ca40fc8346f32ab94956aadabfd48f3a944a6e801b5879a86d35b81b0b32b694756c7f5bef9788a849408b802dd5d8d4f100c3cc46f5a35b2d7dc455a674f89ac9a7d9833cbdf4c630226d7a61752ff85f79661d721fbff2af50e17cce1dfb01114dff56beb24f23dc8c326a6fabc729d0c398d28f372efe247670e33b5b1085d546679945f4a7f06050e594ed171fd3931da5cb2e0f300632d845566d2da86c7e63f08e8afd6b26fc9b248fcd490b1649b098ca0d93025513983e905ba016d8aa6f00cbb7ec9716134540f29ef57cd674b153f705ebb9afed53a1a817bf977ad3f9ad974ff0a141bf241a67454790aca4908c7eedb1de11a991ecddf7319fb97776aeec09228a0f0c10461745a3f2fb9c410ca8ddc4ff72232b2276b85c6e874037c2be4df7cb8470dd42934ff686e33a7490f9fd9813455db774e227eb6dc885402d70f7bb95a843289457d880413e08cb5ecfde59fd8176f29715fbcad53fe864a7546d0aa30a20e4249f100097388eac9c38b10b10393b52500a9d0d1cef2dd5678ed2b4d0fa2b85c9232adff437208128ae800c0051b2d1a85666c11cc0562b0cc29782204ae1ef24c99db207eed4f94451700a764dcbab4e6f747c24ec801847ebb58332f9db082349ab87fd8f1ab6c14afc9dcfd2fa5fe7fd11204df7d214ce6ca5682add8e51da2f22ced32e821ada629846178b732df6520fcb95aaf6afcc51662105dbddd9277ed89db8896ab34f171947cfb2f1f424b95e22bb0b8000941260e7c4e8e5ff14cbdba6fc46a53bb577eb9305753fa08693ffa0d1bef4f7cb2b9abd60e24533e275365067500f2b88eff00eef10083c59be87b2bd013f8731fb0ffae690464416622f6e9227b584b9973a51977be771016ab9251d3f129f095f0d6acc844a6501ecc9daf3ea323500e0cce2b630a6e0d65f3e1921d2cc73e1acbbd9cab682bfdb518b728eb21261d9eb11912f59a55c21e08a78f06b27a696a1ae0d9d6c288a76278a8089fb9119522e0ad24382d377d07723c2497b08fffb30752185c1a2bcd6e326a3be001ffc7b17c9ccc245a030b527d730bfb37166283a4f0c1ca9cec8c80397a079ff471908a280e76ee609d9c6cf2dfe1af3c1ae823abace5d23a14a86006f9e89de959caf9b07bcab8008d9728c4842e726617f8e1c895e6b6672ea1ca4d12a0b9b63d9779a9b660f9687e1b6828659a663f2325f18bd8538bb6258c7945c168009c2e0f4e733cf2c57c3be8a5e0c06a3b28b0d646254f30f9648b15a2b8058992071e1a375cea0c861d852f52dd86ecc862fee482f75dacd2b73975c33d9a07c143e541b44e0e2106a76ce9da2b4015a982ef41d2f44754da572f47c35a55fe2394c75cb38b465c834e2fef2443a346f33b3954900542dcdb7b058b7332e8964080404456e99f723614eb2ed5cb43406d95db45a6d102b5780b345d50a3f2f8de29c21d651d2dc103f73512c2466329cb298e6f855f39f00cc4b4657392d69956f66b0c0dc01639dac668e91f84a766b9d523ea260d5d6d0ae0b6bd43fe90a595fefb337364fa94c2430d1c03653f80350559e5b834fd3dc3c964d3a7b4157eba2f1ff803b6f5322bf8baea2a3969b2119c41f6e706bbc24b2e7896a094f98b818a31bbdea397a6274899124e9b9234ef98c77123537ffc458f6ad3492587e2e88e70db98f28e27bbc9a50d4dff97d8f9561e6df85e20d939fde7973f5bc0acb8d76eb725d14ae027fecc5a7558fe9d04bcf0d71c366f0625524121f16aab86eaca2fc165ca711e3f310214b5567f661c459913aafba9cbee51628d6c025369e6cb9ff42a3f1dc434f0795c8629b98372467c2f1d71dd4ba5d610e667089db2e8fd0aeb7c00c938661f16a11a5973f26442a696936fc48ad3069a7bbe268d5b1ff9084c159170974d2e962683c66eac8a71bdc6278e72e778503075643fc6bb5aa5bed051916f66b76e8293ef36dacbb0348d83bf6a9e009a477950a0225336347265b8b69abe2f984e6041799efcab60b09a5043b0fbc3c41dbe7bbb39d9abf8b036ca139ec6a06106cc711531a3710fc52613faf099cfae71c9a314d462457ac7c5069db2fbfaac99c389dab879450e5e209cb177c849115961e5a9aa017a75cc1cf91f1e586c8bf79c02f380507c78a6eb273671936cb4e92cda4780a9d2ce2c0ee4d6b20a5014f6918d55966e386af1c78c438afae6bc9e07d8547754df0434499c7e26de51b543bccfee051c789a18098a753c6ef9c8c17d5cbf2b934ef3d7b66e144c5c74d606718b4fbd8400f3003c4e515666eb27726b4fbf5c2bacb58164e682ed21bcf928157d40eabd2f44de6b13fd39eafcbc89f8671f4f39068721db938f52e530019b517a30bf4815ab01a42f42652468f98c29bad9bf68ef3202693c6d8ec79ef215562153c05bc15810c810ec74f593f91f5e3b0acbf45caa0f1bd7bb2cd93bb240330ab662141763e5a1567d3d0627bc31b91c7b5f1d0ffce41aec62ad6d66d0cffe971b91c2a71d54f33b42620227df99bd1a47fdc0e6d6eac8449bdd05e7a23e7add204bd9646333d762c3ce6b38c5948e50585db0a507544d6852e9789205a3afbca5e5957cbd8fdf9b1c95374e3e778320c42d936d743af73e0e52da22b127bb92f94cefb3646d622b25312369f19e8b605e6285c998e4233f97d4293d6e47bd55d01b965eaf93b2af2474148cf972f15b169069db53d4776d10cdb9b935334ad7ab5903b28a5ebd401e5a9630c28708d8cd034a2ccef576250284deaab442a3566f318464308f3aee91b75fae887dcf410abd5594c829dc099482da8ab3e4b11b56aaccadd911f941ee452949ac8bcd3aa1cb91a3739fcdb17b2a08111516c2b123b169c1b5676a361d06d4529592819ccb98318b4da35f2cce12267a156d8c9066f9102dde795923a91270c63bb074dfce29cb84699c79b038d5dec88741376b6b1d0a46cea230643fa181412530c389e869d656ecdc42a54691c10cc20c0db5aee85145dec08641a48ea879424831b6994afe194d59dcfb415fa1f47f31de2ace5ab7495e4b5b951e920fba6d9ef370daa391c47efcf185dafa61d9442df245c2c055b6d0a277f5ccade22ed6202fab3a071b275ef28681d4bbcc430a3c635c14448bebbfab2b17f729b5491d1519386a9b8a44440eae66216bd6ade6cf76c169230957e107bdb5bae262c7649c8b78b3010ec0931071081cb87a7dc4de82d474d4d0f2f6b89a51e08cc20b01212b33e322d5d917cb1cd4cbce2cb7365c98f354760dfc09c84c63708879c268daeff51e0feabc6809603a79eface1d01ad1cf9fb7d0b55daf5d5a15a2f64369308e5a558937e026015515cfc13f42b6125ee75e0aaeb06f53518910d7c45da2a027f885c264a4df592566983d545b93e6dfa6c603e31e9b64115a3fcdfc63d906ad8f617164382b4079281de0d2041c0b6e53668167883969a1a98ba4895e07c42ca44d6c912eb592765ab085aecabd71020b63ab064bd1cbee7544f7794ec0c17f41d6c02bfedf98a792a451d8e6c0f97178e6a7c9c5203590fa2c57ef1e009af5fddbade73a43f007e5941568572e1bfc9508b15e57b3b2205d02867a45483d329456cf4dd66d29aeaf63cd2a8d620b6d16ecd5c3b696c0eeb1bd13da3114511a6aefb94d9d0b9b1398d23c336202e3a81c215431d8f0dbf93461b3a0a4ad4e0a60e6d8ec76fe9d91472543f26cc37b1ae2681a55ae67b064c96889a4127b4a2856f2d716d88b32e09257f0793f032348568a2be5d4015c115f41e5a2f775c86ee61971d5f6d1a05114fc8291962244be143cff7efa6c79d1ad33816636d04","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
