<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b10236d630fc92d1dbf21a01bbae11a5b776829ff50264b37492c7232c9b2d27bebecbd66531745db871fbe83b75bad6f49141431fc497385db5c17df5f314e1430874518340a1a030bfa51eccaaace3248d1a8bedf60e2ed1e4a0ad334006a85522c2e6e1219688fe07d503dd49adf68bad8f4fb03bc058a4796f88fae8a22c7fbbcb5f66f6514fe6a56615cff28862e8990d68bc2468b9fad91a6e2db8f5cf66913bd2f9ef0f29e5240c457348801d3b374dbc448edfd502df010de99bb8d246e74539454f5b51293d47cc8fd7258ebbe5b6d815a0edbb252eb0da8d7025d81c812843484148870d816c1f6d8f1fe9578d8ceadeeeb7a94a31057b90f03351e1ca98340f645e390adcf31d399827e16d76bb22e0fc7069b332892d7b53903a6230bf07449f5b1a549e07228ebafb128e3ad24579a88a98614eb184268ceb7660b912701b9e63ad27f1145aa37e33b6cdb721b842799ee3ba0a498801955107b1e2aa307ced5267079f42a37b9049fbf9382871a469638ac7861649d55038bb73c7b64cf36dff4ede5c5003b2f494366e753fc5b0201a5a96dc7a8bbbb606329b0113a81e6d4b6d8f27502f4609c1400d52afbbfcb58dd58b7f52215a9a144e233f5524d1f44a6cbd07f2232bc3f789aa196c0effd9ec05665005f871f3d9be4446a2602a557bc090b256a88c9b8b224549fab8ff296e9eb89c399a7cec77d22996c18c4924ae8d20cc32381228fb1d00ae2e58892bfac8112a742cfeb142b40d25d901a6b54d075081569ced1c9cecc4475d17c66162e62e42c1219c67a21f31129794b54d98d47d14e02d252d1e71c168243380a1d5451c6bea6eb15de4d5c61537e6cdc6e7b9d730ea500d8cde59515f9f7b7e645d54eb16d77a75a5a47ba1d6401e40229166a385de30a6514cf22615129f2fb6f475559302ade575a4053ac1cced439a0f930559acf28d5013dac5bb69d45186b45ba2e36603db6244117d45b93b5281edb4fd4ad645613e06a9fe5cd2405e4fa364254d9388571364cc527ea85d6158e08c0161bee24fb9310f8ae5d8c1681e9e90225ea5b4f86fea3f2fc16d97c50a6d944e827fae13ca83d1222dcc98af6aaddbee142762c31f79bd40110ceff3d3cd6ea6095140584b4ffe0f798f664c94e2a6a10aca9ace5a33a821cbddf2f3fbea9ba2213d454d8343e89c9dff42b1dc8f8cf614406f95d0071010adb5cf91ec4f56e107e0d377b81b6045c453406031992741475d3b4eb2aca3025d289182721f196a55d546e6bcc015300f431b63e52f2defba73b3e2d3beef1776a7b8f66eee643705b3be30b140db0b51a63980da829c5ae8538c2d46bda34ffdbe38596802ebe6aaea245e6091eea986444706ca6b8d950745cd9ab6a1df2dff8e5daa7fbe6a4bdffe69f2a8c59aac3d51d2b4bb2549b16b72eabb03525b4c7c593ddf08696c9bb228ff6820a58bef902374919b2cca0690be7b8956413d5633c5da8784949c2329086070c18467bb2f02a6ea2581f5a98d0313980256ac5858f6dfbf4db9b6250e425493a04d1ce17fec638c363cb29903f1d04e0fd1f57124411da7b0551c3e0073470a6f31a13020f019aed882765d171ea9047dcef2811a5683f2ceabf1112cbe2485c14d1195a5b95a4e43c11aca46e9a810e9146807f501811b05d5235ccecf4d2f486c7d4572bfeddef9f1338adcfed2fc54712e66109cbddce612e256d737b17b203432b11292124950bdff78bbfb66b42f1e184d7f9fa130199c80635645d500da3b1bc11ff7d0768c19430dfbf0843baa3ae821f270f33cffd55a37358680c69ce721e56aae4197d1a7b8b76ec05465a761a2205d126266864e79e515c4e665c7db1b655964329738770ac92a350a50b86f9cbb492f9eab8e6d0265b1e8686369bc5e6f89957c8bb3e4e61d1662486caae2ecf5d3c994999f721aa1e10f9e8eb0dde9b0baa6a8be562695fed5a79b6079ae3d1a3a5969ce6cd00f6f4d295a5cf5c5e0f3d0c4c6f9b0e549d909db34d42b6c3a2477bbb186aa6d275c65f37d6d42fc55a74c2b0fe3124e84033fb07a0ae87f83ad4babbc8adf30f835b97093dc281a766ece8d207b0f60b36b3975f14f723efeac0996d5b08614a61ded96554061895cb2fb3da66894b53c58cd9fa8c5426a08ef7ba6164eec12a3e49b28d8068a7033cb596320aa142cb29307cca0e390282ed546c44c708692db77f40dcb56e32f15ceb401bdcab8a54286160865330d0a959c664028f1a43a48392e07db6a5631f72e934a3badb031374669723473b640fee0e8ee2e2a951c196dddb3eb6117956a554b0783b27c8188c888ad5efebf401c9ad8269cf625819b98c02d03070f3cd77683fb80f9f78e280a3dccf0011f9ccaa8265b2432bd9e0397d5d71821360fd98855d2a43876957621191419ae3f2c7622909d9868aa1982b297e69d47687c6db7542a5549efe5941a2f0c6cf692a55557575bcd985c73a31126a1d2292cb734c0cebf4226104d6c57628a1bba4f525b207531cbe40f3b73a320de37a9a5b83affb2058c49a08983a10b6954cbf55c17aefb6c4ded4b5a50480cc42ddb5b4dd3b2b369d32c46fe5320b1719ca461f3d59a320de29b065c1652b1d1a805ec91dbc56437099a06cc818a8180bfd9e1d25ced36e8c0da62f29ccf72082e3882ec9881461fc23cbd11104af0e587f6ab793928d3849fbfdde588a2c24fd6cdd2a7e6be697077b2349a88c10b8608adf8a1713bc485ab05304d385290e0d1f5b59855c597744d97dad0f827607f094a33f4128a984b714184c36c04ccede696c37de1f6a02cf382052132d4c62fbfbc5d96fa5d82742eb1b0ee12a5bed12e6bd5c1fb1ca40f6c9168e7ba0ca8815f6534cf4c44b23df9c5892d628f378fca3a457d71a79f14b92643c5cbecfb33d3bb71a864f878fa867c74565acf880191d74e01cbf7e8a9dbc536de4fb07d98f0696339aba4f5d412d477d41b899a9267291b313e4152096fc3ca756fe595775ea6d079f104803fbe8c89b1c3b0d68dea3851db419ab30d3088a41f402f7afc22d9a49ccc1188a31e54bd49064ffe1aa62c36a7785c233c5bb75a8093a0510e8a24bde09d8f7fb7122f25d1f9a17f9353fcfaf6d8b392524c6e0791d253cd4d00fde3515aa02e5f2cc50d1e3a9da84dc7a8d08cc8e773f96a1da0ba050ed0a30aa81ddd73bdcd457c307c4c17aadde78c9dc41e5f51975962ca8ee70d8082b72678e461919fc490c62bde4c303ac1d4804a9af8703575805dbafeb413598118edeee317c13618f27eb78a2837d05890e74047a8f6966cea870772593410c70fca2edcbb81b824a13639ab3e3166693dbd7c69710a9937bf3a78f5b211a2d9d6aaddd1cb508d5142a425ec81d53ac63d97c9c7d6ebad2ad32e5512e3551e1253cf803e5a9c159e1329367c5ec903289e713bd9ad8acc425cf47da5683e98ec368f7c4e365a7554b46a4418e69f73c4ed5819875245b2fe29cec494b24b41ebe0ac90bf374df35dd04936254c1be5ef20f9d0f4b2c54ca25fb2f1a63b6608069eea7ddb3e569fd3c6b21a624ff0ec5129b148eab2ad3cb82a5d6afdb0e1d1065c8bde2945635fff13231ae9f082f86536954b316257ab0b2a684ee46f498d8e004dddc3dfdbcc43a05b6e1b295f4ec397487f1758479fca7c91a5b870fb44adb7c7cd570d05de26597be09a1c859a9e047e9e41a862db702ab550c39e22ab569fe217367eadab5ecf9b963a1053829225cabdb7789c4dcdf73268694886b1e30bfcf0017d339caa22f8d6f3df81d578800407f74431bc9c1facd8e341c43af29d4feac1949ec1eefe9abf62813bd39952f1ea9dddfd47a69429841e62f592bb44519e499109ebcac2a0764419c60b75e51d215492c019c5c4268f1eee87ac55c0af926fedc5282102c58851dfd1117139e5a0a1d7fb610b986c118e14e338215a47da71f26d70826f77a3799e5644e004231ebcaeacc30de2ffb72df3f004a3284daf25341b7fab93c75d05e6220b1c5f1003986dbebb92e7d26e9225f70c466b404cf37f58f2b4781a2352f24c1bd274cadb05e01d2f4d8b37f663bccf8664141ed720d007af789d45bd543bf1f6d78357476ca9154630355659e88baf261ed25505a87d80318a48efca2bd3fabaa5d2a7bcbba195a406538bed36738460cd16755b809d59d2b80da771c3df8f950d65f60feeb6c8805e9ddf4a0ce97a1495e9a88da94025f6bf82796b991aa936f2b637c5e38ecedc00e3d5a2b5b6afdb022216cd5129f98fe2737bc3d66dffdf1c86234d2807c368f9165ebeddf3536fb51847ce5a84dcf26dcec42fbb07fe7605e43fa5ee5e11d44093101d504659ae9ca05d26b23ffe6e510764e69ff14c278b4a38714a565fc240b3f8bc2c6c3b11bb6bcb14329e24352f6c13579da31fdee3bf35106152acf3aa6d1c433ad2ba7a7553e842eff2e149b6f3ccdea995cf27af7a1fc0d07576b095e2059bd38edd03f6a60c3e9a090eb66b01f808b778c4cd6c756bd8d20c9f6243034e63b274cd323df2218487a3128695c449ca612bb439b9eb98091e0592e31667010081a877c55f2598fd40ecf08812a3c82dfc69364bf8c34f43e9d678ea643a602be7d0df714ec6bbd65f4e2dd59237e3142edf4d37f02aacc304d1de4eb1eaa53ff95cff5ba50d22e5b3220c6144a96930a747f94ab8cd53ab702e9d0b302c11123825a5c971df62ecf092b52a2dde8a4edb1fc61dd3ecaeef7e7bf037c3f1564215307651057eba0d53b9f2dfd2ffc0f95d51b66026b0a9742cd7267e11be7c145310fe4fb491be081a619274531d089b8c6408ca962acf313c9ec62ffc016b1420b58e80f70998874eb7240b74f6ceb3056109ef470b2bca7abb94ea115292a26820acf8f9b5904e8825df3e1152075e254d1efa8439f9f29e83e84be69c3ef93750f927fcd62b2dcb5899b5a342c0b9ceef7a748153913de8d5a0cb444ce825f9bd58835a096ef3057c9cde274ba6df1998d783cd6c24374e3992f1fa470cd8317bbb2110965fe70132980f04dd7cd2ae2fae3297384e5e335c7cfca8137ccedaabeb99ba656cbcb33ed86e8f3ca2ec65aa6928601aa96a571cde62917ec0a0ebbc2bbd8020e5668c171a479dfa441e47ab4a593f904e792107b98938c1ba21b82a2874ebebaa90bb11925d01799bc5a4ea51f0724d72e5484cf9d1963ec0df715cf72fa31007145c0a515255c91e6ace22555db7edf39a4396589e6fd8fb7b234d0d2db309e812419a65a382741d4b03c969a5c7ff174c7fff9714a7f29177a5de38e9e4ec762400403d624ce21e5e8fe5c6797726039eb6e6cb3506a90bcbc660c9e895c6d15d3f1afbb889656556c841325888f1615ead9293e9edccdfac815f748fb7d348d5b292160e6c4f034707f5ff9e90ca6318ee21cb64aea71e0103bc68cd02878896623c0170a6a8bce04679271a14e59c6e46a64f00145a57ea6835ea89ac77c9333a5f99c0757c1453e7ea97e38621feff8193663e75e711be4e5ee39e24351fb6d8a69c01c55c538f0336bcbddc2a46c04ac310ad2b81d2c1096cbe64bdbff69843ddde8895847c7ee58534c0d5748bcf46602ddc1498ac8f6f1e02c296c4333d434066292c7e127d0cc53a0ce5c97dea40e8386156cbe967096bed54ed54c1a02cfc933b06bfb9644dd6e6fd740ca907eadd327af28c9bf89ce3b59e1de429f1c8dbc085ffa7c79b4d41957099e6b1511022aeaaa9bab4d30a6159d13a6de0fe27b5b607045883f335aeee172cf6a8fdfea7948b9dc1412a29687478d46b5555d4c33538f3d1a0fb46cbe5c7e002246a039cd0b3eba6522257c514cca2e0723d2d7a6731b473267f94542a5d4e77e950ab11090c3e17e9207d95aa4f6a84eff01593c9236c6b659bf11f609e6f8255e4bbafa39ff49d63af9309c0310d4943d36ab486d125e03337548bd450a41f1e8076e4b29bd7057d2681a312a1f9dabdadfafac8bbc1e45d2637587574096aa3887384c20ee0b02a1e76f23876435fa4070c33eed574ebd43f6fbde1638842caaf8840a1d61234f7c881eeba7488175e753fc22ec5d0fec18534afe6218df5e700e8d231b4d0e5535f8ff076fd8958a1c0c7c5776a83aecd31016f58d70759508d007c5cc866aa2ba362351c030ff482fb1376503a27ce968af3c6e5e873d1f57f37a7ffb5156b15e0f339aef2c1e066beb842ba2d09f2ea266c9da3fcc47a08aebb049821094c4b2f6c2e35dbd7b3f93e889975a1338a5fa22e15ea1a2f19c446f48dd18562afc5dcf907b16d911ca716b1be910830aa2c8360a248f918b972a29f6fffcde1b2987cfecfef7c0f2c627d3fc6b8fcbcd7a10dc341c0d2b3ff5aa7cbcf428d47c519643f64d65bff9ad80b86a9e17c3cea000d26cf64bcdf9c971c45605c7a77acaf431920b53de10efa34665019fb4212f5d2373ffb16ec9a5b8c5ff54b0072ed683deaff38e35da90dd372125ffdd602c7a995f18d264b01c5159e03b1254a5ba3413d62486d84c112401cf8ccbdd7a80a0f88cb8a338fb814d716ed1ee3c4e181ab7968f9eb591c3a4e0380493f8afa3b4e74a4aac8e1bb53b622577f4adf39a923e5e07f7d84877aa2b976dda9456ba164dd14d4bbb102401c9e8b04f15333c572f61528f8d0f22c6e9942f2154d8c876aacb10d83b2955f28933a7823b6d89843c3db5d2be62ffcfcb3fb5ce7a6055befcabea6b6ec3aac84c8fb5d77999549e9ee2cde74580e472bbf1e4b951986be6dea1a6ff9948f015819ee51480512af95d68f801f5fd9a6eb7310136a2f1b0b46e3e5ab8cb2e1e6b6960aa9080ecded022f3d38bf308e7875d2ea3dd84732999c797f6df1062497d1d78aa4ff3a78a2c8035b6f3e04ca758bf3a3151449ac87ed953acbf56beba7afa026ca3773a983f15d8a47062ff2be53a4c81267c166228a800edc0adaa035d7f560e81e2c89dc80ed6d5c89896e29434952cf8b3514974680816881dc3ea2b425a4db12e2f99cd16a766ac6a0e15e738ae288e2853de5996b8ce7103883e8483be8b33a258eaf885cfeaa76f71e0ba77fa7608213121c0677baae2ac30c7a5dea154e3571af8a7e2e6a9d5f166b473c722eb8e23b405cb054e9a2a0b0d209c7e96a4121b255744b3afd4ec366e482ec9cedf7670877cba16dabab848de38516c12657028352cce1c9e388b4d8b501178a71b7db73e97075acc0600855de5df27e44e3e73210e27152603f6cf823fb79642a908c722b4c82054f6aa32b9fc6f8a18c9f98c1dd46c76c2e496f66e5c361b628cd42604d8eeb7b33b10b3160cd6056164a5ebdd6d97c5c45eb692e83d3a81d3b07b2097644bf9ec14f6ff529ab4862effcd5bd2fbaf95218659c96bdd4d06b91be75e50f786acd071b166b1b9612acca4bbe2b62e4a3492f6aab77e4de07ea9544c80466c58afc5bd79eebdb8eb639792deb5c56fff5838f1c6d4c9ba21630e39d6acb6d3f4a347ff9b98248c2ee86d08e83ebc96ccb8efb9c13db4fb682fe243c181982f8a1612e01aa3a7d6ac4238496d556aec824360019d925ce1d6da1e2c547dc8ae0c1ac18e00619fdeefd27f17280e98387f37f10a718a0fa5844a7f51ae251892fc8a9101a53ba8906fb4e37c5799fd6bf52a753c586947f8b820891fa7d62e6b714c76f75182de0c0009d4536c76cf35035e0a9e18728158fd62372a2e266184e4ac5fbec2094ed92f92f98c60a7ff109df2cc7720d1b70df65613645102109c39a7e29b017c53fabd5af5a619f5e13dca5cd76e56fb9fe25914d8202846e62bdf54021db8314012df0c7f140f149e1b71a5f90195c55b51c8b616cb117d0d30ef97bb4a278aaa18298ef0b68dd9a2e0514ca708be7a19fa68cd0d7e2a055b4d38c7ff836f767a8f8d24be00756a084940270bda27da3724318fde6960e150122f43957b7da59fcd3f4d8206035212a43aee87b2803f8e772a06ea8960b1a94dbe3baa0a1215c31e2193a82bd83fb17f9465c6cf56e79a53cfa9bc14f833e8374e47900471c566ca0a3f23f33a66471f154cc090654c85d0c946d962f04b1689a81148d89ab1ba184f9a7f0f6dae4f90fb8079d6a9496e106c84163efa226a97a3c9e7055edb9de11a1d54e45156a848e130534a9eb6928526ff44b65a542713a75f0d71a3cbf0d28e53313a665c659d6b8cb122ab9cc55f0321b476cf3caedbad0cb28c2c3f204c00d0122e93b7a989d61aa85cfb3247381e10e0e6ba6f33824a78b71ec23f15e116d76cdf9a7baa17daea788141c84d2bb58049f46ca2d8767f3260e9563495f46c1a2fb29bd8c530aa7da63baeca4783b5aa915ad6ca9cd424eea3a121a5c3b41420e29c303d52196de4742a0decdaad60fa41c3f167af1f59fe34fc5b30105b1bb282eeb585a5c69ad783b11f009f8356c1cf6e65bd861dca818e537872bda0c026b1825aa0244e38e6f27875630018019a082f61ee19b04df87ba128bd9c098bd1467e040954591a7c569978da29d634a77f4287945a597a9a683f4d85ac2bb1990f9752c96f6cb468f33c700c18da21faff23985ee884eb60755880f02d9825854cca8aba5d7d88904c6c1c6c8a760256635a61879162629b2deec8bf2ef088a283493a08193bd98a9f19bdcbabf99fdea4d881b987417a6f16b94f87eec0999ee762302559b013588efd468bc45110f7e9cf23a02a301bbe4fd0c4c8cb99c7ee081bcdba8576a1be790203985475c9a6d51b823a606b7291487b6f2a3594d095489920b186ae4e7c2db2e5b3865cf59fcb90a62501cae0347fafea68dd0b2e8ff880c8c4e424708d2ac975bdb71a1616010377ced3e5e61631eef16e771ff3ed1569b33af090bf8aa52ece3944ff097461b2799b6719de776aa819402b8348d856d0509aa61f4ac4f576d6b8341fdaa30baa1e55ebbac723261d13e35a35fb0f2a6d6f090a274a61357a9fa7de66649858c593c71cc134c81f2adb798b62fbc13b9896fc875efa0821eecec61d990afe8ffb9869b9f3a82806d715f9b42196f0f21924c375cdf8c2738518cf6645269d15ae149033fbcac19b61ba66d6525cc73c88cb0928cf80b9c5119cd34e3f690e3d82d137df3dfcc605561e90fd20a8aed030b7e1cc2eda1af6f5c78f4b70335161f883db5251ab9dd1ea87f73edd865065a9fed2296e75feffb1ecd24a870f358e5dc4a092cf5c8b974e140267f2c1d5c7440f482b100244c369c6bd4029eea574cc0bc1eb768f418849fbbdb04e0a27002d544474e797414701ca1b075cb06a222c5a663eab8816549c04bcd6f816eb4dc2668f925ddcab1a5937bd79f50dc537a635adbae467b3568fd61aa05988452463d6d46a5d4c8e4f4cc774755797abf8ad57a947127f89d6f0ff525179e663193a01791ee250b96845527a148d1a63106147b6f67a5e2ac82d8c8f4ba6702997976784927c4ed05f73fb43dac61a235549cc81128ec56650c3d6745e9393d08350f98cd1fb6563bcf450506160f9389cf430e3f3908ce338d37c9926c9c1cc37b22cb053faab793b429a7d4f95094bbfad2932e5370a2646d9bf51f22dc859da1b69662d84fb3696a2c48f9ad527a2186f61dd445cddef7beb59d97ebbbf983f342042c2fd2cc278f88067bef49dfa59083d34a2e1247bbf209003d450cfc337450eabcc2d100e13a112c78400ab9b87542f8006aec32d067dfa249cba19409ad0f2b336113d9f1704d17a49bf905b404cc87e08bdc33c2a7e13cc2b499a0537cdff399de5fa49ca57f4b17f97b53d3588e589925f30a5ae7d23fa0fa3f85f89c4333efc8fdf8be8471a9f11c16138c40890b58310a485d55639a6d133ea69df9b6c5ea57511d9659331bbc2824dcb90993758b4b12449a1192f1e1ab1140554924dd708ea1fe9b97b7769c849f9c9abaed08f994a5a4d44a55aa652babbfbae6cdc8e0643af2d62bd702b8e3e2362034a6df636f45db0f512c501435f9a4ef886f5681f9a7b6f5d9f9b1533181f823feb386ea8a8e8a87bc435eaa77767069a318b3f01b5966133ff1703cecc9c5f1d76e3f5cc9003bfc58fbde441407ddb09be345860977a8a060a409743e5ee0c10554ea763e1b2b8ad9be5101d5178881dd7144cf60bcb730e0a32ea50d003e3857762d7b02dad131a2fb354131884a75b7aba4a91fc658fda05b75fddd4401e77ab597fd929c456eea2a8acef0601a584c29b1ffd07521fa36b3f2f052bf2930d2158a965d9db740f3992c5131ef8bfd0c24efe2490e9cf8261d8f912b35c101463fdf7a190594d0a86cd983f64d56cdbc958b2ca62b774443b6ae257058db3f94646a5115d88997624d5d34db8ba776b01a44fb042ca2bd9b830cb6047aecd35af88081dc9ebc747b62e39dbc4c9bf14bdaa9eae34035b0308f5bf97e9047da02284b1852057ff018212c91279c44bf9aeec51b47575c1a4bb31645d81c54b76bfb5f051c00ae89cf675fba9f302236c7da239c30f62da158d71eb45e80e45a25bc54bc4c03f5cc9064e961590cfd476c8da506cf142409b9d2578c858f4650554e0c8a006b31a70d60e31b9d7cc7f98ee77bbc0e5d61b02d305d637eb8c6b0b9ceeda3fb9406157c81ddfce45568ce53bd5c4a345db90580e37af59d18a2e2d1f0abf47765898d4b47ca9fff198c7330c2d33caa743cb965d9d1f37ff2db30d6a6e09e1abf0e5537d0c4aa765233658f6564cd1a504f08e8b264b5150a2ffd2681f8f960bcc094f44ac35af147409a41a3a80d97dbe15eb06113c40369bc144c3fa042994fd9408c9bdea010f9b52d369dda67509cfc48e84d51b564fefedbc44d7b9bab74ed997aeb703da2a4213c2bcc039232f3b6ba1883d065a9db0f194c404cd225a1d6f95bd1080b8a8c9e34f1fb8c6c62dff354e938258fde30bd8f7535a40298fb24c7fbbeeb8dd33e32e5159e309a08388fbac934f30b9538209e9e88c51128723b4bf064ab7a2c7ad7a2d689f73efcd4f162bb1b497e007c1942825aca83b671d0e11eaf87cdb75e16494e099fc58833b364da8b76ca987c7843307904de22c1bf1e0617b857dda9444b5586bb0727749b63e3df40022e22d30933ad9f2e35bb19d232ea82227e049a9456e54fdb09565016c37078d9ea0a32db095682a31e95da71422ea1a051aa9d411b6342891c079fe2ac599d34d974a9807f897f40b1e9885c29e7780f13d23cdfe1db4d4e802eb41be361b999baf0a37003930836f57f4d06ec6bce7701ff81b220d0a670b7da166f33b6e83f925512fa30da356b9bbdf8de306a2793d9ee5d3a3c45304d48e3965bea2255c8869e95c7b1f48d8afc38d7ceb2ff99448bd8cbac1fcac3cd41245acffa05690e63b46087b91a49dff296b47fed4b9115a09d62b9c0ee2890e5fc5f34a1af2b6d9e9eafe880091d294c3520330e3993aa1eba6ff43d50ed2608442c6f38947afa41d3cdce2e74dc1c918b70108f4264e7654f7e8875812999c70f6485e321811b2b63623d9e1cb5e7888b43fd59ba9b246e34ee22db10efb4e363333140dd9d5f1513f401228a129832210410799def011fc88eca7d58a1d49add44912659e57c7d314bc14eac8ca0d2c7a7976e2a83aa5925b2af130a805fcc3f3ceab3772e47e8d10dc2534b4d0797d18833d56606690995347051e9da0e768d602acf70f351384c5d6b59a5d723563934a20efefdeadac3ba852d3eb6c160de35220019f3d8178fc68e1aa8ccd73e746b4d85cf0d7d8df6ded44023d77eadb62baea5d3ade01784a5a336b2800504783a2a94052d33ed46c311ea27a3cb584abbefd556f99276c23ab53b02999c690d4893ffdcb882ab5df73f1230df7bf509f9b29d4a4eb4f85dee1c4911110aeb67dd68b032c8001eda767d33a9a5e013014173de3b1d9713597c25a0c45e71710d513853d5592145b5a6341ddcca5f591f0f5003ea1ea8f04af8cf7f8903ebab4f18a23373cf5ad47c734da727da84144f80c62030ff96adaa4c2a86b7740d80915626e3af23d53735cc8767fb6fa163e7325ce3e55e24bf4ff835ca897acce0b7b082b0718823f8af18c1fe15791a0e377af63315851fe921620f5cc9576e5c92014a101a5d1b7d83afe8b22a04a1e4f90d175f740ed3a46c8c6162a6ff797c3217f83f72d42373126d9d2372fb81155a87f792961ae202ea9ae83bf88aebbfd635b240d2c154a2b3544d3d11a2d30e9a7b25026f1bd57df70e3485e3f38572a219d5bb91c94aa1e2eded0efd18bccd30650b625737957783d52d3068fcf7f22322ee686635f26a150255f2e0876979ddffd330d2aecd1024eae17bf54f36589327e1ebe3a7378fa6ba551a0754187a5abdcd31bad836cb346407b9571454bdf46c6b1c203d2a439a13617d863783e51d454c41a11ef1977fb880df580bbfbd2861ccb76a9db2687399be4e137126456d4e353841f4407b6bda085e59c700b53feb6832c31da398ff8323c8b8ea6785d187eea6b5bb87c4e0d29b891e052105080b64003ffb589f99392883a8ae5ce4cba5ccf60b37fb9947aa35d8538685257c7cab85e9a5e03e0a66648096fbe2061464cbd27572622dce898324e87aa87eee914b0dbbb4a70afaeaaa8e9f47656016f7ac4e17a7df0c71a4bda553ac429bef21122d9f334526ff683e2e5a3cb4d08a080f8834483a0dae9a4ef4f9b168d5912e40615d1d1facb4f1afea5754c4ce17fc482b7a80597cdab816ddd7f00700457d02cd1a4fcdc9c7a706324bab46c55b48974ef29176db7b83dd323324660d9f5014dd662a7f585debd040f8c058095b73710e4fb325457a78809a2b2fd98f6318be3a414a8765d91688feb18bdafda5886f8ad316ddba0bb83aa1a65533819d6ba8baf76c5ff6d5c37d9ea9a998c5c1b6abe5dc443baeddf20fb27f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
