<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dba2d8fbd00b8299164cd664e3c0307141fac6381bd44055dba360d933514c128cb1c5774224db42414912ba15428ab51f2a7402b376f03591c89adf8ff323d1e112f9b63334dc8d577d256624889b279779765a623d485351c74d9f7d5a67ec030a48f253c6fa268f3bbbc6c737750300e1c3ab9032413b3c0d77f85677f021b2f32701745e6998d0509ab75bd773959dd6ce0a5da77d8eeefdb2e8d8f7dfdd1a75c792a6b3f250d2f978658208a472b9103b2f746786792a7a4e563dbfef85f92ba1d3c74a556d26b91136818516a7d18c43d577c10664da0dc30fe20b56f2c6ac4349122c124455ee8a788b10ed4a8604f174a1edd0cfe9fc632f5fe20892368ff764451be9c96663a74262f7292b47d16d1199c52c8edf663c6a20c5934c24cbd59008f51eabce7c56d012cfd60507f8dd3c229656a7d6bd0e7a19895131b67c09ae2ca050ea62e16fe58355ad1240e5173c32c0ebb3b1a0f5886fd00d5414254c92365721727930369965eee56e8c77c17c031000409465c9bae447655c4d533c23a4c6581dc7421203b887c9a0df6d4a0055dd95e30a0cf6ccc468edf33f5dfcb3d1c8b33b69e18c5deac52b8f61748d9ba8a8209dce7b6f5ad2c94f0c19d63b9c900913ad0a0e258327b33fedfd1277a187f84e41815be1def776b05a6081e97a839d49fc156e653c10ae84d15a15f923717ea22d47caf5b7c30dec7d5af60aaa0b9bf3739832914058585fe7bbfd4341ea52308fd7ebc7faab384751fd5aef36c989ec4f523d86c76a339b5e32116484ef65812fa8011c6be8da8742b0a675edf56730c407b42a490a67463307fd3d2eae11e1e9802be743d3c81f2c62b512a772faeeda7cbf913ae2a36b4638105d56b14ac6a1d5c27728d835e134a117a40bbce23f608c9b8d8074a657cfd7bfa9f7376280354cda7e2c2859a0d63236364d1de8a615c29ca83c34af96490f32710f8acf153628ac49e47f718227b40508eddd62617a25ccf9ad74ed6bb858539c9a60638df0aa286a00ce877a218b929419899a309fb8adf35eb88177dcc482a3ed4916251b487c4f1150327d9e7d8d16c23876a3bfa9c4d43c0ca630b69e591980c471cf19b2b66e66f6709ca130acec4a058b981fdbe76c2aede50b0286252a73fbd38fef7892b28222d65d3e067fe01dc2258ff4501b4db093f96e5def3274970e15937422b0241aeb7006c694f98350b45fa9325dd5e9171a12fc0b320537ce43d88e221e5bc58c13146a91b33f04ad4011c17a481e7694c2460549b7ab4dac3e68b0a6cf34fae4d1b98d12503ab55abb2a3c9bd4dea6642e631c3cb482dea87ac7bd51fa581a8ab41246a12cf14aaa5d18d037d95ab9bd0310969703695a4c6aa7b8a64d476fdff4d1bb618fe5d4421c1f50c1285531b9b41090d7892e9dd5701b4aa10686e60381942ad139cbd9a99d6e7e12c01ec25ffafe976e141d17f1a881ac13ad361ade6b73aa68d8a0d72b3ca92bf6c3cfcbbedae12d09bd941f7c72e6b141073cc7ddc2728c715bf82d5f04af9d8742eb2d59b6b6cc899e1520ba10071dd37e48d096d718e0bf51fa5fbedd79d07cf2bdb3c737099f8b53dbbe66327dd6cec36d6d289282cdeab89537740201ecbc396dfe4c9d4339443e589cccf7bb1ebeb2b9ba79f09335e8caafd9a155f8b99ebcd4b9461a0b43dbd87a44fc6e62d49bf5a60af50c9c9033cf5ec2bfc0971e99f4ad7f8106d7ba483a48b936c8765701654097dcfec028fba10ec45e18ad3f326c8f85d575b1fb2b39aa49622b7e6fb47476009e0942becf6526967ca4327af5848d65254fb2f91753c1ffe8af74ff75b7c0f436c46ac193d3de2e19938d12120782959e1ae782c379b13c7ec4e40d01cf4f967eac3db41ce2c0fbca4761d85befaf511d3fe81e38b7078acc175f2e1db9b73e03f87f4c034ef94d3acdea814db380b6db0361de9725b653bf72e6517d2084135fbcf538ca414d2a667289a9c1859d7aeb34dea6c0b741a42370f2bd947e5f56bd0b260a9a9e627a32dd4e422ab32a7408f19e499f06c6b00c6a761d5ebc2a04216229a1d4f8a100d52542738df2e64ae8d23d9f103356f231f7240bf51d2d28687eaa2e3edffbda5a63e02fea9110a2c2017356a4d2cf6f1aea7695a97eafcdd4c3877b0e521a16dfb1fa6819ff3c224805fba444c6b74fbe9aa63170f08d851be258890339bf77c3c25ce2777ff12d61150fae150eae81d80179ab09da75017aaa53810ab99b4646aacfc1c54592c8071102d897f433ede369f6f6924d87cb82bc8811d091787330559e75627c94ded7d664153497fa74c8b9cae49328058d26b728ff0483896d0f2f73de5e3f945bc527342827cecd50bebb0ca18e5ee47023461c553273bf7c9bdf96184317049c0814bead75ea7dc2b1d62cd8097f51fb84d52dbce9c5eba985b6f77cfbfd17149b222898a287b0acfbdebe07b0eb4919ce3490c34e6a6d5bc1e5aad4d9872d969ba43fd21b6e552c32ca18ec2a7835fb7cb02306bca2d1e8fb7d897bd9cbeea84195518b167a054848a2c410cdd2b9d85f5f107be169dbebe56f5959b1a1926405ee3ce4fe77daf47d8979f624c74373940acaa9461ec1f574f079223041760447a6c015c77326e7d8bdca148b55bee463b958ece19a68cb6274d93fe8e3335893546ff4fc51343794a8c1d19de4bbd01e74199e8c6eeac2f8d5ce74efb75653f2f553ba5257b60338d8112d1146fcb03593128a897c6a35da14f98f4b7b4af52190a0e00e9cdebb04b5b572193791e3247792713f23f2c6b84fd635cfa44107260b7f23b92ce74c6cd077ad6511b6fe0f8e1af7406238f667c6bbc27fc525011e08d0f3dda0b94093778c4997d5f3b6fb2d64a3bb3f1927926a72daac8c4a7777e6e5fa36c77393ee5b575c82a0a7042c71ea88949c924e33cd0ef28083fdafe71d984ec4883b716928d10101fa31d061f470303c535373a6020a33dacd0a5f7f9adbd13de5436ee0d971d0f654a29d083896ac231f46d6bcd43eeb05b67a79272b32cbc28cfa0476946aea2bc5e9f0fe5a8b9ee49326edc612b4f2581d31abae2ea7d575fc07217ec00b6e32c3ecde4c8c55789550afc1e56b65648e267771ecbda99f0efdb3d611f2a3b74c590dada4811c2dd15ec8e184792e7233dea18827704d777d8f2a2c979c787bece835a4fc3f0094f70cbebd6aee18efa9348fa3a3c4c17900397f618a18e20cd02d343b2352481403a17bded0c1797aab1d2704e61111ff6bf5ae26e89ddb9f52fc0feb57dabe11f18910d6516ec14db9bd9e03af273e45c8f04ea2cf258073521dd05814cd659865a565092273699baaf16511302bba4524ed2ed720cbce8b2acc1f04bd19b59eb5dc347d01f26ca963199900e1079f739fc27dc9af7ff1b8a0800cd11fc3c106a184b1f64be2b38b690d7f2cdf62443c51c3209033f14ae003788ee81cb60865d7cefba0b94021d62d453ad86674592286a7106862c848d00ddaebaa45baea11caea9d05cbd938b3d1ea7fddfe2cbdc64b832c2dc13b457cf7db4ca5a207c68ec20287134123caebe00c1bff14affb1a5d123c09ceb0173476822ca1631d8cb4624367efe8ba97caae96d9abea7ab43601f48539011ad16605ed2b3f39a532f2b8cbe6c5ffdbe3e2f39634215b27c67d108fcda426dab1cb4018feb82e4cf695cdc0bf1e0d326ca9dd2b20e9b821f7171c057f78eddcf88b9fea84f1b03b127ddec1d59a5d637e51fc105698fea3e1ba59c89303eff1fbee44427b8533631471141d754eba47be01ecd163bf171178ff60dc9d2ccaaecbdcd9d62981b7c50b7cf4eff451004f461182abb6bdd64c8079e1de3768ec6e56e876832fdfaf6d183d6e80b9b82e3fcb31ec63d3b581279362a4c31f55bddb5165e2c1a8861568e1a5ca4a02160b5ec434226be6d9b7e3744661058c3871362b6899906409a45acfabbaedb5afca69ef5ff4e99c5d37213378faf4aec6f7e1ffd385c07d24350619b340d3290091346814d21f4855964153cc513bf5793d6b6528a1828c1f5c06db851e433ec45f257502b5b1745722b3b4e09f6356ed7b0217ba9cbf23bfe98fe59c28dfd9801799ff83e091cfacf45a9a5046689fac60070eadc3f13dc7413599365e15157617adbe9be91c7dc6cee5c754c945366562641091ba4373521e7d84adebf2e7f202690f75036d0d33c1c03e03b4e336fb8c37c23612bd66055b5c15863e135ed144619f6bab0284ae2240faa18b8ec0da0ceb4f58961baec5fc67410ae4e89b5abca9413fb3bd888a1e972a46cf8f93e4ecd04896328d220926f38758d6d4cd613c80f8143446e9a5b771e7268c474a2bca1b331ed1ae65c934e901ce30fa53c027ddd175fa2527a4fc733225f2774ea4e023941f5d99acbda744cb72567e08836869f78b0cec211cfaceaacbdf14ad0bc90909174c167b2297351f1dfdf7f99210c6dc33c133b96699e2d20dfc47301ecb38c5a9a0bd39aa78260d32c44036bcf3101af1a6f5cc967b327d9a1557e9ac527f1f4ad8bc5da9100808589637cca9723ed721477d5d0df99dca7e43126eebbf07a87c734932d82daf7a79d282729aa8132e7d4e78d8e6e1203e82b56805b4a2fa71efb9e32f417de48f2cbb3576d676efcea189dd50695801d1ee2963b5591224f2cab08a38170f1c77ada106093f8eb71a94dd23fa32971bac091ed69373cc11a83caf150402a640b4e35714b5626ba024d8b427c721aa0471b1454ac3df150d1f3023962430f07883817a9505ec1d3aba64edcdd60513bd42790f935a81eb798527f351a60009a238d6fa67cac2bdad25128436f6c152afecedb242b1b85dee15b5ca447d39736fba3e5770262de85c58905a322377051aab8f32446609535fb0022e07a5a9c54fbc63a255b42588e1c7098ffc6c2d0641bbd68efd744bd677db9ca18b970b320371b342e534117aba48f81a4b89b3b61c857b50fac19a95fef72a36637a3485c3c06e491921e86cd2dc61711192e94f099c76359f9449563e17da1a042bca02ac9ca8e43ff93593f120e063e046317c397933cf6188873a993f952e59af27cf3246ad9a99328d5953efb3561bd88586cc0ca9d4fc732cf73495a96a0bfb501c8a0bf3507a0e45431ef29238844486dbb05f172b021a9640a3998a105e396fb19f6f3daeada9384fa16a20272e4125d1b9d08704dbbe8c55d946495fe2bff0bc6a4775e53ba4e9b0784b5913d173dd3c221c2994461a29f6a272cf8e08e00d41a5a6f604dea93c9d10d054eabfd5c25afec3f001f0a51064c5eb9b305f335add1542aae9f689c2521c070b9b795cd347cc666d651a6e2746abdcea1a2b464dd4922fa788808f219d469a504bac404828286306e1acee3a6646a44700d23ccbca36853780ffccc12e72779be6830ee3e773a508188de519127f95fca86ed37af3563656b8e5fc8212241783b26f7c70345ed6bdaaf99a5b2bbb037d8f678ccf158a466a5e979fba44d69cfe9a91d45fb57e8d96739b176914497b1d49953296b96b7ab043c0540b49569ad7514f76dfe91afe893442d763edeb67c99d7b1d528c39afc9fb24d22415a1e537d7f35625f55a59344b61945cc0397e142638ac1b45251e5266f593eb3a0f8ec3cc5abc08c1b8656381bb795b83020fcf9148b39fa49b73add483a273e18422a6626b5a6701a5302f795d47572ae4720cf9bb884f7e3ad9ccc1846bc3a629670ae38244305d853ae33cdd9a6a0e706bedf8ac688302610a780f80c00d4ef0e1540a4a644d15b1ee8a0c02a5e7ca72d283e06d084a5411525b5261aeb392d4e257cd78c42ef1dbe0049451e63f18711ba56bc3d22a6391a1fe11e35b702e85c2a58842a91713fc7be6cf096eed182fd7dd1ef719e197d7e5898705829ea54bdbe298f3dc6d279c91c852636ace3732003a54d1a497e9f50c91b7d22da51f294297edd2758323e3a2c5018b0272f171fa837deead155d5e8cd582b3a21bc70af8112a8d43e1d614628266f2c8dff775e4270f5b974b6bd42ecb941ca17f868a54cf878d049314a31a682455e49fc18f6d9f153a453dd61da5a2d86443dc2992efcaabefc16031a22ae6cc1af2f5dbeab1fba859fa3152ddb105980bc6c8a837f8f191a270974d4c7d6f0e55a706edec2231c374ea6fefc5125ef34326c5d46885b75e79d2a3034054bb430172f21d94547ab875fc8fd71a416fe8f0fe4547224f9de6e5af6aab0b62aa428f46db7613842ea04877c35b065ce3934b2698a23af2d6fd301b6beac76a756b58fbea32c702cca58a8e9c36f81be8794c981d3d9a55d31c7934351e12438aafd8e7e6bebc3fe2da42dd67c5d2442983deb99f110ed641840e2b2b067dcfdc2feb2e6382e8ab12496a7d45134e3b5c2734c993d84daa0b9a9bc7f31fb000f1b3e403105752d4e3a0a16e31abc0c951bc0e7741710d42c354629bf7b38fc2c8c032e64b1ab3f19ea39dd422bc90bab66dcb2f6a6c990c691867297c2a783dfea0364ad4d8da70c7cd33d0141ec0da904fe786429f8da2b89302c09b31f67dbe483a81559b6a79ac222803951cd85fc4044f9244ca5aa88996f193c9c87efbed838219ac1d2e18e77b4d77b9c40dc5a0f06690c74d1bad265d0c2b1a24b90bab7d9a4af0a5b774556455bdf6f080a60d6ac7e3d62886159288cbb6bc3ac23a5c74817b8afd9b14ab63a8cfbe0c260b091ba6d90587b6ae07e5aa1d04bf2d16d7c030a5f22abfc337061e0f628b21fee6c2f8d8933b455cd4f5a24d32c2e5d7e205e88f74ec76a6e2f3cc6e6ae6ace03f3cbb7fd2e9e85c26f7920825a5f9cd1fc2960fd0182fb13ae59ffc74e8bb3b6b1048a5b453c80cf3a05d89f2d0c5060f1217fd7e75984c0902d6cf8edabd2ae0eeb77422dfa5b3fff72269a3d3b67fc807f53e3d8a3568204fa18fc9a5b1c36ad1ef797da7481257ec0157672d9d1c97c9c607d8957d4b251aef59df478ffb1c2804844b4364661e5589a61c99a87f02a4131f022f3c52cfde9e43d4465626da15ff7fb519242c77ffd75478d7a7d5bfda164887f4ce95ec949872ffbc4c229484b9dbe217f627402f762f201dcc934d54b0cc617fa08c34f3e3c500173b577b1a0c125300839c519a2ee8aa22e7dafc44f26c6382fbfa88697171cc187792205d3c258c3e625e2b8681f8cf140e28938dfcc8b50cec55bc24d5953602a0db2513bc87750c9221ae9caf705867656321b3138206dfdd252358b69f6d7b14f216c345190decabc40fdcf016e36d82fa222ddad902281c5299c3a889ba3bb392c6c55e707f45ce4cc1d61932a7463c7da67d15678f3f0a39b0224f79d34ced20c9965db0f23ffb9ffebed25a4a35b3c006265f741f1920a61dc42004d20dec9143115003f1a6976654c501354755694eda0c01803b8341a9c70cf069d30099ce828c906cf406cf0d9f65edc7dc857253702dcce5c8c2c3361fe498193ce876766edd4c5186c7305a14f819a2d6baa24d9644e437aae30618db8b622fddd161600d04ed2b4014d636c96e04a45821d2fa6f3094acd64fc45cfade230fb9fec849499a0467f5be27af4d71a7302acecc9015351ce669fdcef1cf413791b96fc70d9ec3be841349630896d0390bf8c527806fc17b4b84440533c26110adc51442f02aed391b98f7647d73888d54981d2b090b2cd02578dac3ccc75b3217927aef48684fc567dc6d6c8d79ad4331b61b6caef1dcb5db2f7bf3c97750812c779536f57033aff3838f88a7b2867b09472b8501d8f6ac37f9d7b100ab471abd1efee04a477d4c397d172dcc3b5987790fefb4827acffedb7e9f11cdae382b3c1a7eda5617187551dd6f8fcf2934b3b4f80ee9927afb2bbd921daf63b8eeb983c77b09bdb08e05fb2d65fa3b4f55d2cfe1edd9cb95a1e672b95b50fa8ca92b38b34f2b3d66d9c03ace77a546816f37cc5ed1849ee6b80ad8cbd4e9bb25fe1db8f993ccad1097fa7837bc725d452e37859423d5a3eebbe6339d8ebf0dd4549d88f4f27333cb81e9581a460f7fac4bfe1a20f225af98b2c8d9d9604ca0dee6f427c02f3f8674c4fc956b83c72cecd541db7881b3f4f5185c04b539bc2455289c86b067b953135755f304198de181bd4eebb5fa00f86f9b7d46d959126b56caaa59b133bc21f16ea00e1244532ecc1862eb44da8ca0a17c66a3e372b3f3e7233d62400cd63a612bd50e0bff7bfe4674f040982cac8a1350ce9e580ff0901f080046a94c1cb944a1ee1c2ed101e84609879651b36def755a8ca92a4de1a1b6cb24a89a4bf9fb36eb0cb50a5b6f998c69dda72443e769b3b526b1d358439d031a6f9525835620412e6cdb80141e66e658a1a64e05a7d1f5a865742dab5ecaa6839ed03bd2930ff601b8b5acd129ac73a2544fb8acffb78a2a565d81c5a9b3b9e332e1153bc5aa0820f749bbc24a65cde99f967be69da211b283b9fa2542a690525ed3b44643ffd24f23e49dfec043db3c434fede436efe76a6d32de78c01ac93e31aee20801d770cf8213dba4fc0fe5446d172a36f464f5abcce3617a5a7952b5bdda984898533d07235567813b06f044a3843268bc0b3717b08dfba5da0725097857af6370992bc61715e446d80a4e1c4675b13432e22b46724ccf01f163c04402fa25a1730af5d6b1b6920b60260f5aee6ee208582467ca80d60d56d806ca1d87b58f6582acead6053c575c0e49bc584435224f45e3d880b8620e6ae90fb7e937a135c1d42d5e1e76ac99c4cf267f6e90613c6dcc7d83ecb102a2cda733551af6ccc9f1c0bc7f3a488accd28204b3007cf83ac7f87ff3727b08c23bcf7508108e68803be3769b13811eeed1a114e6711bb338998530fd4dfd9bcac8a8e31b232c965c6f5d8f138970e3b09ed344f3fd9d395222894c5e12478ccfa169a22b839afb083e576b07f97f054b451a213620a65d60675d873500cfbb95733fb7334d5360b2118736100666e2fa44074bd829d4bc5a65c33d078f1c80e3b0014a1ad8848108237a756dbefc40a14d69873837bae9b1f7b6ae0a625cae61ad6833e9fb21b23854ce00b261742a0ffab22557f9b26e94a7d9947c7b6e4998e65bf489e25972cd1dee11c6505a7aadd2cf6feb25f5901ac5c74f5846bcdb7d9060742924633b9449e610e9c163d64fb6c6d4ae266d49970286f7fb577e13bbe26737c9864f52eb3283e72200256fedcb6ba2f54d697a4c25cd68814e2aa51ae5bfd6c20f9ff9a17227fa23493d754835410bf5a895515f851e729b1b648edf869a86154f12c55c092fd847c8440a88db68eeb7b5e5efedde2e76677ba9fbd2bf60c1cc57f210babe6ef5b79a2bfb663e9a0b522b0941de5733a467f62592f19535f29818f930bc7c3e670350ef29f9a69646129a704fe2856fa7b6ba70b4947cfa71af17d560020421501d49d3ecf9b2429c01fb0d0ec0c2af11dee539c610a83b8576b20f7e0d06066be904d43587d632a6d644b4c56088f937fbbec6ac87432d00b949b3e913c8bee09d1495442917eaa62c4bcc0643f4184f70167047bd9dfd9379de6dba8cf6792ce873dcaadd1c32f2def3caaa776b450fc895d2751c6e5782c0d31c95737bd8de5513d1739684cae6e5f845026d02d6f2969c1d7855547fd83cbb3cac36866341b32f26c9998b273c3ac7543e3261be29cdf2a511153a0c5443e1f485c73a53037a5c2d2b63500e6fc57ab5a0cdc4fb35bf143c877c15a1510c3ba4bf719760d38f5da17bd034c96fe129cbe13ec35ef9b06769f4b4174b6c7adbea5fdc3f28100bf8384fe019dfcea3c20bffbab9b5ccf36680633a4173155469efebe799ab43ac61b1da135cb322af0f5398e9ca789089b9ccd66a981d03df448a8e6caea01599e31ac278a2ffdccface0038f2af0a6ec6a632fc942a574531a8547324e9f9ea93cbbbabb6574e2ecf1ab6c90fa3518b6a974a1343c6a764f7750637a32b0dee8c530fd085c97415fdb95ca937427e9925dc0f48c11b523baa359fce10343da4621a062665627dd625545ce8d4a715d34f4b63e4a211f1fece748713710715f57e5c2ebbd78aebeca78866a92d03e33e786678d050421c55ffb5f3d2bde357a55aad877983f257e214e2f0556d55b5e4630bd2ddc570f4a5708a76a34d85f397171240415a112bd4c0f0e92bf78d5cc6ba805c6707c0de0e0cc6c54ac96247c2b86dbfabdf8b240bc557953758ed1b11e0afb09b2c94fbc58cceec566a21d090ee33652cd91a2636294e6540190605e0aae5750058fe8a23ef85965be945e20ba8e2f8b79291de50ef62da568e18e377a540470cf7fce79485ab6d11db3369b10456dd1444cdd4e2a99c178faa515967e55224cf6e99b3574fa17b5431af1cf7c17b50328711aaef423ee903882a1773f5781a9910537a501e44f1628201a8a13d0ee633b5b51a40da0d39d6acefd733a166cbe6de75abb4dfd384f5bee5595a2cba15514390b29ea135e3c47931207428eb9c58d5790105cacd31184bc180ec81e035ea906c5a0c1b1d184b44583428a19ba60a620c5161afb259e9b2cc0ccb59d41f9a7e5108cf4504a4ebacf397a3f1e1898b6a972b121001d8535212d6ab985871abd80950845a8653461eebdb57344bea75ead42c700780a0e068b6278d1476c0c10c11a6246322d66c220454504ceb62cace8505cdd9bb92ddf8e73b24fb6bbd35287ff35cbd576ccd23a3977b2ac140d505be47d1be7ba8c333552a14067d5a5beb246dee24f7f86bac8699c658993733032c4b0e5b65e6f18068218b23f1e7e20601ed1ca4244f5a563d5d44684779b0d1bb27e4da40cab6ba3a65bd746a2707d8735db1e78fbab8bc2892fedbf8a83728860e227bd6651c32ddd4eb84b311688be3cad139dfd0bcf4315f512a1c6d153114800d6b3e66e89970d4c66aab1bde6e9bc99944bb5593a3cfffdf30e98f3db0c64ed732dc1d3ac6b198391a6e72941c559cf104ded7474cd99fa3255f5543fde1d8faf3766351ec8c856d7c147182d938c090c6eea03716782cd890cd972a2d3af7d4f8f8e9ab02c412c356dcaba2d50aa14e2ad49be0e31004edf84de7b3f1546b12b775c825fbfeac9579e382b7acfb472db0f5a25d3921df9b4631380e0f7d9d941310894df6858e842bd79699119b3c95640518682706bd7faf068d2d715b1941c619dcd6af6a8b3ff08578c355f4a93ff9f38701f390965665cb6a1ecf36378a0b11b3de7e47f08db753ddc3349a01bea2dc22f332d20e9935d0562e83cf5e38aa3ba31c5407c4583710a71a364cc1eaeb9c2637185b0c0252aede894081ea4903c26185373f5dbcec52253691a6b7d63f87d0684c990455a98674b9797006febf6aba7f15c79ffc35c70355d1d2f97aa8d82e69550dc3fbbd98ea9a796be409f7757972d517da0a23c9b5d330936a882617017a5fc7d20c9012fc2987d765e30cc71d4a596cb3bce0fddb533435157a09944bf553781af12df75564148948ed67af45ea586ff6649c5f0270b3c6ccc74bced262fd50b3c7f356bbf6f7d0987229f05f44cab9abddead4a74314e762c87c6d03e1d9754b3c0515e89f5710aea6086604fa7a0a60b325bec301126aa24e6a4dd2dbd40dcd3771628d0ad708a7c5996c1cb7d115930ed88f6a5e763763e8699358984709d64674a317547a7d8e8b316b0377f3c06f21959bb1bf685fd499ce89edb29ce6c0cba3cf3053829e97febc3eeba3ef6823bcbf99af2517a218f632fc310ed4a058c90e4bbcd1c796220fb3b5ffd1fadc3dfddca73533a6b2de2507a4876f5bc79d75abe1a2eecc7fe1b4108f848ba87051514f2d982798f691a1977f6232f7f63cc5d3ffd4de0336439993a347c0b50a71d50a55ef7724c633266979f28cca430fb51e943259e2267a0cc2258a597554c57a13d16104ffb721e851e69d7f26c3c7bfc41ed72e66797b8bfed53a76bae70929e203388e49341924d0fbdd19f80bcec831c01b97185e1f0d172cde8de6b5a03f6af9f9c5a21ca727549918428b361a16e77c7294da0654894922bcbd12dacb9d88acbf10cfb656c3e5c51fbfadc15ba621d7eaaf8544aced0f575b5f269f1d58ea209189cd64b53a0bb8435d2c736bb60a39286930db886f9d33c6a61a8de265d5c550c0f5348bcbee8cd78efc59b26b1efebcdf997bd496ee5e810a906e2bc01a3454058c91f04c4ca2fcfede7bb94d3067996685dc8f6547577571bef7d559da10bab417da520df23a6102dbf26ad963d47d58a4fae19495807c872dd5f752cdf5a0872e4870bb998160c495e30d75f0fb73d1c3aec5f1712bbb1ef1d9553d9a12fa2355b6782559d1062450d4b4d25f75caad4b3a02d2c0cfbf4c4da1bb491379a88920b41424dd8746b1b04432f9e74e1abfe2e0a27e74955e96b53c0792b569ad23e34fb94a21e979428cef139546c1cf90a9e0402127334c72500a37f86dec9bcf5213897cdf02c7c8f3f6fdc3dab537ef032016fe14fe37ac2f7a06b95fb8fe288f2a7cdae2f7a39ed27bb4a54fac4415c7dfe13e372a33d736139e2018c94e1f97ab1fc509c7232566f8b962429c7c4305d710c5f9d39c9f8149149daa02ae642df0eb4a3b756a602dc634e8d92e013327354b3cd78409df4544c35bedd41daf07f1611e4cd5d8945339f20fd496a82644861d75ebcd86a81ae25085a559d76a6df3459858dacdb063363d0b7b88ab1b466d39b9ea12482f1f98ed4d3702851abbbac9b41a0f1328208b6a17035715389bd46afd1372a68b09be87b1be591bf83b9a6406f78477e08da1c184687d92051ce7f5a933aacb07015eb5c4fb0f809f8e8b039089949ba22987c7d3f5223a6e740d18b27fd419d5a18151bba0fb7e4a7d903fcb54ee2b32d51e3069bba","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
