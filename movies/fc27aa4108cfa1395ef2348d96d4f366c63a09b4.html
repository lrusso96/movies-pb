<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2fa4fbb7b193282c6459b7f2f9f03c2fbe2852cff9298d0b8e5622e149717edc4c61adb1409d15cb43757af020edf21997e8924f695f43a34607d92e9d614f1bd79caa88fc751f13216ea044484b7d76a3af7c3b03c6e558fc18bfd7b27531f4b7ff9b5db1628f023fe49677a3cfe0db0d0f147dcd799a2548092a2448463b7b2cb2354f4c06da4a87929ab69473b7465db9d8459ab8699614ea68532643db4cc43645238a84f0da6171f059fdd2f4d44c8bb03aee53aa7fdc983efaa1af915edbfab160c8c62f0c1262671bce4f6b7c2bdf85cc8a4e05a8dace08b17969ed253c7c164beecfb1e13d69ec8225d2c4d879f57a1649ae554c3a57bcc10e9474f6553f5f9c5ac046fe90d0a8290b524af026874e91fff2349dd5595f76a036d05c7041f30855a40c0736370bac8dfe7745a415e2c159a2b0701770981c231e4011d274268a289c9fa855109962d0a367a21152f38af5502197c6b4dcd28166eae654b1384ebe2b973656622ab09365f05c7eb34d6585db187e19a60443c94cf85a7d5b6c572663f3179b2c8a9daca4d5ad5a0c2add9b975074c3d3c70ef73805788665166122168dc7662aa2acd7a2f31aa52027e9aac2363ca7f91d14d2e7b97f72b11ddca6ee1df662894f528e6ce9f893d57c645fff80b4a2024f2629b23bfb887e9500adbace6d18e46915e8661ebb468856798b19b80217f7bce251fb85da4da865cab0255b025c57d96c7ddba7502f237b4c0c6e3e82b6e2a6f349225257998e71b8ed33185aa1fc5ce1602a9043eabdb44c87f8af9e8833a9239103849058ed870aefdcf008c66fa8b7551ed2bcc47e7afae4e0b2c28ae4dfebee749b9f98e2d77f1347d11cfce89168c31d9b689d15adbedf9af5c1db5e5d7346ed6f9b8792ab486ddec34f6e10042f4f8dff72ddc647fd2140b67566cb72f3c97a43e0150ab9be8f220c64d0fda7524358cbb666f0d9c4b24d075169daf9314c12cadd0fdb596deede6c859ce1377776628b20ec93f7629a8b45928a8771118be124fc82119cac662f35aa6ffe398ab5120949298fd81457885b68ef1cf98d2e8a48ba2f8ef2097da142819a930fc1174b90083a28e1069c934d363ef142cfbc0465d94410c0629d971b7cfa7a0f026dabe664a9f0eaf3549124ee7d52d4ecda543a0b5b1f6ce2c5672c5f370931e3d748b8a3a89e057ac041d12d788a703257cfd1caded72a01341438585ffe933ea7aff1050f4808d94ef5330ca08290f6095a506960df68258c0018bbd10c08b4b13222dc1517a5ae8cbc822f3c8f60c218545d04e9efe86a6cc1c61424ffbf8e61d99350baec9034617985e9b17fd5abed0cc2e14351a07d7e27153a1533ee76d6426729655e188bebc32c2c8ecedfafd9c8d18f28e17b15a9339e2c947f7fc0cecf67799844310960293b9fd2b85dcdec885e5f1b3da2cd2fe4bb22ca532ce05f1865da0146a55e37da27b398af9b6c5fb6a297b88be26fef025bc0fce3f9c96f178927c06d4a02269688ead4375ab8c4ffb92ec0948a78e96ed6c64e986d72efa4af67a8a0c14f5863d41a05dc58fbffa58196426d3a2adbd13ff161b6dbab86326cd7998c837a49fd392994f44edd24d387d528ce3422be94eb2e1682891c8ba6df4c8e0143162b8c0489f34aff2b5c56e9b95b1043748c8c76c004eae76a8878852dd32534ef335bdc61ccd1f668716ee126a5ee4cc5aac903ad1b80021308772756f77d25ba0a1039d94d1330ef3a1680627a18987806a15780e5b145d887d150710e3dfdfb21bf882f65f15749aa51ee0032ad4d97a16eb33dd577db21960a63e430a5020a4b28456d59188206c6145fea1fffe861ae22636dcb06329beb0fb2d1a80b426705ce9d45f5de154147da6a1dd7480e3be33c1dea0c7d5d1a26ccd0eaf9ee1d2631934b4445985eac5265bfb30e1538f10575e514443758cb793f44cd1383f4a51204185b33e094c0bfa917db3595d6273e99210f1f3ed3b1ff4603e32badb648c50007031c2977da971bbc582a17e01074a17754780850755b7a6c4f6dce8fe905693129713f5b31c50d7faed602debf4afde49eaaab4cc80b13089c2ea92b46d5d44ddd98e210872d451564c53f53bbfbc9c22d5eb809c26e2f688e3902d73819f5f6b7131b08ab4900df05c2a9b6bb497a125c831a65233feff131131b8c21bec05748c2d04fbe06c8820155e9c526468371f77b811005af9268b40d7d08add8efa2826475ad3dc941e4be5ce508049d33e95fb25d1d0be3da24f4524e8462b46cb047b4aac163abf15d0e52cb65a34c5cd25ed489865a708d17b1333c0a9d4dc63901e349e2c4eb132e19f207c2f84aaacfeb87198d673f2da64d302ac08db5e78f888510a167960577b23f2620a80b1b528998e11fa86681b93287730c8986e6f506078e84c72af81a74f7155685043f4582d2d610944e15e317c134c8329bc0b8504b79c342cd1cbfa30df8295cdbca726f9dfd151d45d633fa072474b57ad3daf6957c3ca869d4fb417d2cbd8b2cef52613b8d8faa402e4289f2b1a861ba7a6544b466e27f4d1d966ca9cc1a336de7c4b099c3b953a3307e11cff29f278ec922380debf3dffc9f07ba4e0f031060f44ae6057b7861db80d01bc83f9ce71aa0ccfc546f2be9b860d28dde24b45673cc86e8bbc3ed8945f7bf49be0df7fc2eae98a2ed8e1ee0bf532e3ae67f695e33a28e725b6e0bf0e93dfd549f2cf805b9d8bb8ef33616d9825fdc554b46c4875cce2195a0ec05d32e33c6f41b3e8f2e03dee7cb10fddaa1cd23e81ea3402697ff3f923e7a1213f49f0ea1eea2f68fe633827b56644126db8e647e0af3cb704f8638c81b8c735e0eda49fa9008cb8d9f95c84d00f56b358fe119a9a59cbbb0858727bfe06cc344dadce33d969f09949a8fb3237f7c2ed523e900469ed0626f56b9fd07b0985ba4f7a7c049c601662423d6ad43e806e50e91215d6305287f208e7c4bd5e5ff64d6230de45109a8ef026e0e072cbdaf4a69484197e8846c6a744cfbee9939d0a24996d8652038d3c1ba44e1653de19f8a87627c996f85330354bfc83b796dc14564abe49d45e8d2468c5d8a851dd9a2f06b07b6dece2c2ea078a51c227d4a7f94c0e47a1194ccafe7ae1ce059bbfc18c64cd66be1616977180187071c91350713c30318c8f06018c5c0ae0069d5422de0923df60ef9b2e69dc0e72e06fc000e701edc289b72e91c5457fb0f22d6dad343576ac6eecc2311c07e6879e946a0c636af5acbfe48e5f888168a5b75984fc44a3699c738d3531dc79705129cbf06d0acee723c49b1ef7232ba1b5917fb816f75481a4a4e213dcdc02e9f351e5dafadbd3710541b26ce44620f6c8547d6358f84d2f92b6f56097f03c6ce32b1b31e1030ea8e6833df7f2f88f7d6834213659ef0ac4f2a610adac109d801b4161ed7a44fa3f560f9aa5e2056e53d7a7fc52b02e6d9938d69e2d4f376242de9608568105f84a1fc0ec7b23aa92664dad0f267e17b5220917d7be56eea32ad71fdb2ff45e1124998b81d7a0a7a5bcac0c185490e4742740c394a8686b0f448a0adfbe45fc17f7d6e4fe714ecdc64e655aae5cd30d9ab330a9f668aeb4192559ddc9d978754af70bec896b2f0b2952ef39201f552b551a5935644c8fa58ee000fbeaf9175e23c4d6f835a8af9db20bf980a141c116571abb116665429a7b3fd36dc7e0941bccae07b83f4187708515f8e63666b3919c9a6bafcf691b0922f8a987bec5aa8537c787375a14eb14df40a398c297ced2a7754eec319b1f56b93ce73e9d1a8dc6b6ccdc18495671e8b347be4727a7fbb18f152a3846f3f43470e212f147882511926fdedcc3e32e39655991680434a6000e0bfe55fc1fd499da9c1a4701c15cfa15ef5523be9cd715b4f09a7d7b5be1a3a135b942525306f9127cf554e9b7bd4dfaf04bb928c88ed6dbbe0aa2fe9b18ba3cec3b7f057ca6990f4bb69663da5c362eb2095ba629b841304cb30b65948b11c17d817bd324b204744c68bdba7b9e84d9a15618bc2ef1d0ca45fc1339957ef584689042333207f90c0fb1683d36d32bbd4ce0cdfea1959f8b6e4a0a68d86f81746526b8d53d17f1be22bb79faa5b2eaa16ca778af15e4582d16b1847409c13422cd6f4003e80a25bb186811dfefa15047493758ccd9ab55c17a9370f474cfc06a4424bb8a20b677527826d3c3c334c847084216f7710ec15a799c8d028928838237d80fac91c1306018360088304933a659e5975c813d964d09377c0c5a161f8f9438fb805f202493c032b8ce01b5183e3a5f1fc23ccc4698181fa3dd317be1597d5e26db8f9e9ee9aa48bc04d69d9a52f3102dbe3780aa786fb1281649f99d9909e1c8b949a1b62acddd28f728cca7ce95801e61880aa18e5fb679cbcc122b10651916fe1874160a2f089cb5ca7f190bb024486f53100a1ad923a6805151a4c50bdd17ab5c9c6e5fd2d1e72b42de95b0757fd40d133f230e34ce256e4eed45d8fee1d77071baf1138cc199f0145c56868dc6dc5461040ee9ee086dee937536943dcdcaf0b2b8c8a36acfac8e7523fe54c1a3c53b2d713a71ffc64d3ad5aa6d20046a62d95d306ed4ead004a6494715bee7a4682843546d7466a6054e31c982c80b245af35d8dfd8f6e69eb4545031a11ddb22483c0f63d3723cc89707fdb82f160452d2ad052be4784ea72399f8354527919b94ea4dc4676bc9789285c0122c9ae8e0d7097d148fd273308c516bcbb7f3d4c01b4a0038ab18827d0d61e4cf6191f099cf76cd03cb4b77ba840d4561aff89104660f6d28c99fa3816ab69d313509a071eb46bc44dbb66c08eb2b7e221ba53f5abc78aa3d4d08933fd374e2799049a215f84be47bfef33cb69f3e259f127b0be5e5d2c58a994f5e2481157d4cc00aa1568d97bad8ac267afa0778261941ec6e68ad6c30ebc2bb6e8a2ceabd6075d50403d3d8aaa610057130e42ab5d3e9c4957e2836e34a23a73a18f428e19b4a064406e57206ace4a13cbba30507b793b5cedbc9d24fd9ab04d6185c013612abf222c87c55724854182dc17f3c952555e64825444f811c04ad20b070b9b764c2ffb40d1e9889dfe353410a47a8631fa6495c9828c022ab365177cbc64264cca8b1b8994874326a1f7adea9b9c21a0991c0b8968378745fee3e955379fc577f899ea87e219fa3e26f10240d43f55d2dc74bad0cc18a97c9d956f36a1360600a70f002c931400f9faafbfe58b7e874de08df66e2ce09977f205831460ff40ce23f201a940a4707a48937f09588a512e1d77146cea87fdb4879af987cc70da5da3ea0ece4bd5f2e8ae191e9fc87f77406697934a8f1213d9a83e40aadbe8161ae824c27835da2bd5d3d220d6ecb43cf67bc8d6b2d0c53134ce7b6e772cfd9934c978a919ffbfba9257300126728a03341b928a4d92ddb888d4010b98e39af5100f3256e941c166ddaa42a01d8d4209ddc7ed4d7c993799e57d759ec957864a78f151cc6cbcc0943736dcf63b14e9e4032ed248cb9dae88916307f490a39ac2bd774b1a12dfb4cf2f3aceabd521925765941eb1d56c131d312abf8c505f97251ec667ea27fdd5a7f88a79a5e3370db816c30ade3314a5c9e249d5c697fa8d7441290c4e73685a9cde10ae3ea808746485269e769aaeb0ce7375395f4a7c1a5d14c3899dd4dea5b3be9b05dcf55a65d87db121ca7acb85bd24456c8c1027bc3c30e0fb90ec08aa2332582e5df49a59546bf47ed2f8fc74aa3d3b5b1c94657a46520a3afd291f4d1acffe294608b7267ec7fdcf3bf10485306d5728988a0c1a22849e1683c3fd6378d31703c8e6f61b7f4cef862b5bafc01ca498e453750ed4043c067c77b06f9bb177952c30615e1944abdfa2163f65362e901ac8131aae4f147526d0f9b2757924db987142dbf72a8460c38af6136ba21bebdc0662e116e980563572fda8b55663b6b5a36db3a378ebf0461c86f710d9d2cc523dad704346d72ffb967871978f89ad5f2e2ac8dcf65ea62faa1a9284d58a2d1f36af0cd80c3fa37b7ead89418d031fb5b1bed6a348d77c6904c4037433f39b12f5638d16fe55c2fc18f85a132be7fb3305d66439da9f1c6b5703c50f684fd835797b75fb1c817a14b93be84e6b7aa150f60204610e59b7dd3464a14a1db26ddffff1d7c14b654ec4712602c641f30a299e2d61aeedc95c65389396d75cb9411fb3ee4861ca1c13895ef67e1a906242fe283a7008c04be3bec462768c60b6202b57d2e13538f3623151064a1514d89a7b9a01ba3b809261db34ab12c2b7098e17fad33a05fa9a0b3516d07a893668053e5f5302bed558a22f26371404d204b42b30f854890d532523c605dfc581127a68ffd28c1e90ff59d56b137dbb1d87b7da576238c7274b909aa6b62b9c894d59785205977d3c6940c58d0db16c6726a51ee1fc89c49b7e6905a4f60f5b30034adcc4327b8bfb15d5fa2ebf9f142e3387417fa212306e4c2622008d1432785e6ff8f18711c141ff4a4041730ba8e474e5f07d80bd05c30a61165684e8c01f32427e4431796cebef5cd75bbc0fb49c30aca0d1985daa807e3416d46aaf11885fe250e04d463604f3e774b17db5f596602b079ea7923475bb217b648bded384749f3c1a404b0124a5266e6aa0d19ff50248b0963b0790e09319db0dff8d57a9a7e1a624f41926862e46df35ca5a6cba90bb94d9485f982bbc699a7373e12b797966363144afebb5f03ed286f1176e4a18e6ae124e464a6b665204a0570227b990b12538b1c23b1fb0a696fd45895c3a8c3650599d9537ab87be5d2ba6d000105c154c63eb659424173f25e15a957e3a050d898c5743ae925c7ebb01b5e3823c2e342e9ed5fcd585e339735dc4a2a733fb84cdc777c169db6762b399d6df9d5da250bcf2dec35aa325bb5ef7fd827608b2ce6225c78914425816eb393317f2de0680f9fc5315ea17d96a397c45878834f55e0ff6a6034ee89c7089cf7474ae83c67a946a08e8ef6625a19ec4b15bb4ee36b30b64b5a7e765c13d8b89f6042afe002a497340e0da4c173a4a0dc4842682f897aa2b87322f2bc1240dd472f0860d866d8a20835a248363a2c7e01703ba92d16f437a71c27da763a9bcc7dc4d9bac864a46200ef0e09dc92ce472707406f3746e33837670052efe3e0c28e15b31961bd42a0d1228c1aec90a75f006d8f85a8831af7bd91476cfcd2d7af97146fab9c341ca591196f7fe0ceb2375cf9f65aa63e79f666824066ff715d4a74aa97d0c15b47c8dbcb490b3d3b9563a7f565b20148cddbd098348b6dce3a531fc93a7881654826f99c5c3e9f97ed6ea885ebd9393348ad3fa43bf4a9ea5d467c380b0497a4d53810c2fea26c9e2aa57c4c030e3a851ca9a0592ac3d6f2d52166eb0a522af776f01d6e034b2096c59876805d417ad43b5705f3756eaeb720cb83dad5108e74dc1b0fd28b783326256f97ffcbdb10ac43b3a8895d9c43ba3756adc0853da77b4a1ab41a0b09e138e55b41201ca3d80c0ccf5e5c49dda1106bbe35b496071b9aa82451c1c9e936150e2056c89f14b53c8a8627dad4ddc56046a5175e1efc72b3e38c2608eab4f1769c5061284209f75350e8012e4594676316edf93106b16602dbb80725843c050369c397e978359fece238641f37d28eb675ef9246c1196dc83300494e2ca9f6a88eedbb043c1ab328585d172c3e133f62f21abeaa89d8371373ff17c1afa57069f2339c79a487170d5349c1526c72e80817fe1ab2332b11014cd6fd563f67160435fa1ab1f8db29428ab78851d77497e4e2f21df3349b554dbfd12cec4f2722b9fe653ce9a56165dde26f0577ed3f3c71da5b59496379a81d30aa9024b6a670c08c1ccaeeeb4ee57befb0ca80fc6917fe24552d6b4bf2ee954fbdc2633e63f4d2c941ae722439f3f5e4a1707b0fe6976e69d807fd3da7f53b3f3a914ccf654f18021e878be174fd399132ca0b0387287b73d37c7921af4d7333436a3edbb24ddf6832c0390717ad2adfc3fc8a55e66ca0aa16d36567a779718b26cc3000aff76029f45c4eb58b3e90cdcb2f52be319eb75e90fede2ecbbea37e1fe7635e6e6cc5baf37b9b87b1807c7094c37fb033a702d72f90085fa76f2e1b9e95bc54d2c28c64bc5d5270d44772f3aa09cbffa0adbd179f6db592c85139097ba400798182b7f67693f6bf2ae1d1d7f4e034b5e6db999e6809176594843cfb5cac2ee829eb614c21fa1d8892c548def0e4fe273b4ccf50781e066e2497d666492bacad84781dd5e7c5a3e5ef3c6c716c5ab3b48c67baf7755859f873cbe23e0ef8ab3b3d5cbc729b0fd91eb5ff2289ec3784f4c5b9a019090208fdefc22cc2169bc0d8265d16f2a3353af4f7d5bb84bf8ea944b47231318f16a112df5b26101613771f32a98e26c70d92dcb6907b5b55e49b3e58ed0d0d70cf3f5ef977c5cdc5bc0e6615666f48e7377be4f9ae23e33484cb4b5b1ea04fe83ae69a28784bba9e972f086203f039d7eaee0e3e7313af912ee297816bc22ac0d4e1c72e19869fba150764efaeb65d1b2e59fcd01481fd01e5ebd418546df62fb6c893b74deb4219d1be51670525d031f61b4b3c63c823846e2f03f6649aafe04525e79a940e43521eb8c8d2bc634373e362561ac577284e37f66d5c4779b944a84202ffaa7a6b73f8e870d3c56c2834c857cb5c8ef520630e246b8948ab1172fd660942686714a1b5f5f7d9841a3ecf38338b699404a649e89883e20cb579c841ce05a684b162da75f79ce29623cb338cac0047a5b04d635cc5d915288c7a0af82e0ccadf3e52bb3e79fc88b809fa55ccdda661f60b85eb05aa00750242023a7924b359944ab38912ca7415c7e49f224e30d06c1c2f12e5eb6b2045f3d67bb9f86b91b398ac0b394461882d172e02e8faae4ec16d28b5c414a0596f99d0cc87dbcd3ce5e5f25f4a7e64e0e98b38c62ff47f6cf26cd77ec6d0c6081ea62dde1dec08ed904d227ae0e8230ef9b8768bec77445ef38b010d1b3edd631a092147e9b7eec8ae2981439e154b2fb0094238eb92f3b726376cacd3c8df41c61789d9133a07feae46a31d81c60335bcb6bb29e5119014813e418459cbe56f8afb524c851a0d5cd6aa7612af25fd446708a8e128ce6dde62ae2e2dc18c5fda1a237628210fc1b8c6748956dec6c85493474f61bf1bd34b8e57608e91064e7680016d13491048f64f3e5784558a400141f824fd3c0d37f45d161caa06a7eae58c7238f08c3cc58f5c7af8c2ae1dc06522d5b038cd71697337c89c71664e69880f1240b69514e62de21586ba6b14f0ae690dfc2876d86ceb49f2e9322b67b5113c85650461c0fad3957909758f19722ad643c88d0339eb05eb03d7a26ddc4323ab6a0fb44cfe81e8ed791b4b604e172a852fb2f85b672e40aab345b05dfe000e4bbeb6817823f3d19b42941b7cbb27e9603e06fd03251a3aad17d4499d5c90cd38cb79b73e3031d05946a20b7c4f8168138820fe1d19601f23cc71cacfbdf4d815a888e12d2cadced58d255e55ead36b5bab93ab41d1adc7f566b879c39f64b5b2c44f73a119e809b80768ac6fec9233d608234a8077e32e66804dea5ae7a2267cb962bcecab98bab0d5ee1610ea06765a831239474f52761f7b8626a39022100e29c1bc45add54cd02f1c907a7ec64464bbbbebb7965612d00d161131e140568c062a77a285063845b31a093821fdcd1b8ed6f095a63d644ea4a5b24b3ab16fa954fa52e231d55b7acdbca6e228c22dd78f8f4b9ce3d10d023605751e530b7acc327fdb229ba7d1afa080404a021669822c1c23e2d94e906632c550d4f4181b5068337ccaec13b17ab0c0ce41fbd8da9c2d34863cf8af73232d8832854dd19fbd428b6ea2d21fb81e308969d0b1f60321f6e4f926219d0d5a97afc4ac3aa888ec50ee2eb028f09a8fab1e7a84d6ceb67d1762c00ad71f35b9176b31f25050b5c1b8f2531c61cb4cf727a47366240aa9f44bd6f8884733ebab8a0d0e1a875c6450a46d3a72376ae30c962f0d666999e5e6dfac5c31d4bb277fe43c8696e7d23215837bb2e67d3c62ac579aeca3bcb8753775c40fd993abcc7c6479dff749e3e68d43f3f810c87526ea4b073022acbe08161f6cc14fa31ea3875a3567a97282317e8e44ee0e2c393f1719ee79abbe11c39537b9139ae99ed38edaf38680885f678c367fd504f7a4c69719ed22d2cc36d2665c5b1281475892bec3c9c4a8f1287d74084afb93d282edc31140be12ba32cdd528339c9f5be72ca8c8d570be4f453195c41f42f202e176044c66381b58599b2881dc14e40e1c476abdd411846aa52e1c69967d9087fc1eb53d25f9e1d78643841a8ec7b68c70fd74c547f74f8789415fca38a858493eecbd6bdb4af7984c896567c85a1610f23dbdccfa112d89b9f3073f1e4a4fe9dadf85ff68500b2923ec245dec9ff514705298dd6cbef75298b286e00cd8e993f65172a624648cda6cae20e3c457513ff59c3732aac9176c1c6813c5a40d20c5fa55d93a569ff324212d831476ecd35c5fe1a31b5ddd401ef9e08658d0fb00b89febded81598cc55a861101751a75009997b87b68e48e51707a4b45ab31177d1e8543f723c76f6f25b708cf5469530e2017403306d205afd011658985846a7a27ec27e7c9166e349f6a9d9011521eb1756df604b29ddc80c87a56ea1b760a2b7aa94d9dd0b6abc7b262f79f1fe3e17a8088838065f69c9ea3d7ba54f38ebd985892a8d3f77b2bf37340d77e4a834b0ffeeb68b7f319bcc67218e0258f4b0f64705f633e72cc7277ca9d51462687850cfaee0126815e3adb41ae6769cb03fb475f96f28dd926c1a0c18f1ea906d5ec3200eb8bdc2eb7109a0c3c14f672e8ec19826fc683771b77bb2208376a52b41151e489b77d8d30640ff76eba98fb3852b57ca369c5036a3cb7f23b3046e4066aee83c8ab8ec2ed436e669f1e011b394042b6b7ac4242c7dd97aaaafddc0e8890af808cbfadd88707c6b4593b19698caf601f8535ffc61c7ce9ac2046c85395c3718116834826aaa1171a898b3d53efbacebb037271e32fc520fc0d9e46e0eaf8be581f7bc691a6db80a3fe25dab053507b8f8c5dce47a97484a116e0d501717f6f4d61628f9556a84ae4a92999e4d17d77b23465fd6d9967ee86b3ae202f7d7640ad4b582e038120dea0070e44576d331c6d7e7eca1e8bafe505a48bae405f98d4f960ec7afe06088775c400ea88657e1122006167538e0f7893e3e371480146235d3f06c86bd40f54a45e3a8dc31598f2b7a797de47c956037e688491be36e782189fd06b824d80b06a8be0fd1c747f408e6d22ab3954ac00e40e922723da02eb9cb81f956efba473cd0eee62ab499b564aec25b47b8ae746ef0614c18fca5b90f0a8b07e218fe0f8ba12c6fd709a426a4d7e9b14687bba8a656115aa57c13dbf24ad0ae9f7d316b49d7f48159d5efcf22a024340f612fdce642fe2f379a77feb5e06304a4aaea3292b9e6cbc6e380a4e870b19fb2d88be77902a5ca5a1320618eb2cb26e8df349b503f47bd1c4040c1768b62dd11841b8bb266fc46fe713e2dbc3fa78d271358692214a55815d2788110f108d8966f25d131101d98ae79a774080ce0c1b02ff35834212fd0482c8fa05fd4b4c74ebabb9137fa96c5bc2a2d80624a2feadd5beee5d410d16db60c4e2eba1cadf417e074403a0f2d6baae177365f09ebbdbb080926602d0781a5bf22b6b2ecfcf309a040c110d2577e362bb8e7617d911b767d8cd30ba3ae038cea47a05cf27b1feb5400d541a1e3d2140aa4e419fa940a1f942096e3cad0f36b3f0b637dd1c56851c822b84ed954b6d0632f946005149e963b9bb586e8f79a8021b9e53a07619f2109e2a2083703cbc1673fcacd79435ff8208b6605a20dba3c1e68caf5c078a48924bc38d86b5ad58a7f65cbd4521e078f33322068ea1ca2e84760f014209d8ef9e0b1e903e0b668872bb8a1cbb4442f5b9e4c62f2e2452229e00dee625f4bae84d1354affe35a2ec859eabcf21367d533e8e81b5a0071edff03a82bb32731b8f0361a2fc3f79d4bae29852564b58b4d032dbeb7ca4e06dc35f8ad4b25d5568450fc2d864177d141adbbc27cde8ccc2c673b611529691f213a0d2b2c8ccd5e7acd9a4c80b57880a599da557b27c6aacea7cac176434b82cdd588bd4f1a26dc324bbcd1baa1dec23ad85d5911e41b2818ba5afe3c62235ec088ca0a369261e4057f8f884c614ad10597b7a0f15fd8ef0d5a78b9135f471c4562a87daaf515da37104399ae2a82539b349e63f2b13272af5a662895f8ed46747a770a4907a1b0b1eb36c571221e414eae7543b5f54948f33c527386539d572e71bef3e25509276b15e32e7237264985018aae5b35498fdc54b1ed78ab2f2315760e84af01f673a4c9dc48f51ac68630fc611956f54c527d076d01b2416e2d153a37a57505c3ad633091aaa55102d2ffab6d10f927e69007ac5350cbf8aa59ca5a35a527c50bdae22a2422e576985f30a042f1920aab06611990da25c2e1163c51dff876b20361975f162124e355e4b2b0737805b05b62bd9eb486987c36c6b01ec0ed2c12013a5699e79a091cf1270cf569b1fb2991a2b16806abaacc9700f7597a02445476d3ea58868495e3ca9175d5496a151a159010d5fd8abf59688a4ead891f6b772ce678a47f06aaa70ab4285641a997b5202fdd65d5e91c245554e67d4eb1ec221b52553552675e86d8e0bb379eba0f2f4b1f8514913be31e84f6bffe8cf4da9ff2b6bdcbd70d2504277cacfc48d0775bd6df6cb44c7ff6e5d7764c8b52ce380c7932df215f36280be6ed46418d690756bacdf91cb32bc3addd5db867ab05ba062a37678927f08adb06681cbdca5732da01a4251faa6a69adcf03423ed14ed09a90676cf445","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
