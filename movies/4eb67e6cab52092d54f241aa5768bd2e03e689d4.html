<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7fa94a23d748b6bd4dce8a1d0b9576366f7e08ca81ab7f1b0f57db8c2006debc5ac23fd7f92f857e74b321382879d05d33166d07d56b63eaf18c5f7ab1bd37c5e47e628452571c659533ffa96eaaf9dec6f0346430d97efc70b92197c44aa43b1269f6dd50099ffb87b18497b66e26e02ee768abe50e6392418ff7add20fa808749d0840e664caeb44114551d07042d0ff43847bf9008684b976199266adf163f109e369cd85c096bceef897e4730c82af409aa6fa35e232aa3161caf3772ac2dcddc98bc708f64cf6688ed9acc7d7a3b7942be3500e4d7ad92f5326c3f96dd552a29ddf501b1700d1fbc265288328ee5960ce3816fc8006bf921a6dced3cf5b31bf96065d93c5c2bb26c2ac45e65864b94359192c8759f0ac226d401562e4afdb7d5f0940b0cf779aa9bd19787674f89450af91471e0b3036c55828b633f6db7adf2616a6e417781f1551a0fbbf5ecdf7677484ebe456f113fef0bfe79e7c5408a219b02e667fe4d86e8be3553bc7915a2e9a90cba9f51a7cd81da9f72d4c8d99c5b48c3ff49f3ea98cfbde0eeb997a5a89f86904ef6a950bf7eb9eaeff534f69cb7128acc8a56a4e3c0c35cb0a54964c1570ba5e7407bbbaadee95ada44063da8f5657862b565c923c457ff21f92f7a961af8eb2e69505aaf66b6668d7807f0615a422b7943719f55a966acae45ade834e160fe26d66818dcb6dffeab7448c41118b6fcee7af1a280ca68e0b488f450a043f6cedac54b82c3ba5e76ae9d0c0c7b57dbe75abb1cbaf4c0cbe74461932f0c23c5a307464ad6842da2a943c7643b082e2b52aaaec8efea0d30589a2629f8142726154110f0da886938bcb4e8ea3860504f882a7c96d432a5d13f388c14d3ecc629411727de550660a30344733b822703fcba9bf28619062db4db771c092da8b8401a1911e72b33408805fabd04f3cd46773e35acfc8c8550f904a48e0d3dd720bac31272f112e3bbe17f89cd67a2b81ad3bfc2ebfe63e877035687e2a2f1a6762248fa0922302b6524acdf398bf1636204312f0da297d1fc7421079be25bc43ba9b1179438e7566ae323f8d2464480b808b23e3cf6cd5d7b033b78328163fbd516cb922dfe025988b42203e76b7e83bbeb60e6b76c18902c79bb98ef214c4c8f86b056c348b4ddeef16d50674f2d8176819aa1896c3155825197736a23d5e7f0409373524e3fc8b2312d724fe28a768e25f800d3c92b0d346611729872e74a9e5bac63570d33edd9a6d6dbaf36a3938202616cb6fb0522510e7052b3ab71223048522178fa8109a232586ffb1f67c9b9733397f01ece108ea542b238591a83a9093bdad41d18ee36fe3c93844ba1503c652d17f512e5ad117608e4e195cb3b05ad862d501091204f7d8f8570cadf7f7752d56c3f056174f21e39188179787f6bdc43e6ead994fe6d87fc2727ccf521f7c65d0ecd705a4819c0d43a82a585328b479c7b6e36fbbbf39cf9b9d9f290dcf11d0f375d15f4c67ea1999ca402ce6a0cab31246b3c93d297f1a492c9e65772807807c4f2f75aaa23bed136de7cd0a7cceac204e08ae83f51bebb419cc8487b827ce3fe9856ed43c55c5305714e1338c15ed13730db38b5ac952b4c74d159d9fc7dbfd1483e55af23b2b3c0502ec8c01faff8875a8a30f91c0d110f704aa31ebbf1744b77719276131bf4acc6964afae5a509ea06caadae6951b257053e8f39a7fd2d30b26952147b2a11def9a04056dec081cc76360f27138dc35a998d27549d60ab5aca16f4559a5509918a9b7bb6c59e0de559307abec6c3fe81f981e0be3ae90356486159b6d4346c1c5fd83f0d63d0eaba9ac4a686143d547dd05ac926be540d5b009c34794beda52f9f9762f4a6e6221d0ad7acc579df30cf919df4d7a880c53a626b65255e9cfdcfc40af3a3d6bc2e1f17d79271d93a2caa6ab46ed7fbcd015d49ff11c7906f7f3c74804a093da18fe1df933c4229dcc3251bd9956f0f9f8c9fc51ebf32bf49294c6c1db41f7ccb5e09a74c4511bb9b29d3bdaf584891c5292eaa86382cc1a455bd441e971ac1fb11fd424326d6d80b7b39b1c3b656260682c7d0dc6475be2e6e724dc9e31ba78027bd2976cabfbceed23ca7b062021d480cfcd838df036575425367bac8755660dd51a6f2bdac78ccb5588504bfb90b14768d3c8adc02cfe7996cd2158277acb4272c0f6883c5ecb5a708aa383642cf7d05abec6f3d19676c0cd64cd07c247cff21ec393e1a5f9cd76cb50d976ca1adba82b8a4b1d896af43d9f713581f1e6ff082227bd5e73f1094fa5aa9167ab8d1fc934db5b6976845825a48e6863745d604794ebc655566ac88d2e4bf0757842f605e819aaf0ba2d17e59689339ed574a9eae045bffd2da4b27b820ee76c4ee3a685e4027aada39bf10d6b562e4613692fb1d4ae5aee04e2cd22f7f92672b4a696ca6a6e7756ce34864d4f39f0703bcd6e01a4acb2cf17b051e339b04c777389fdb7c2f34f25d28ee9bf1211e7c55c7466c993aca12fa6ec939182cdc99036a7341f7d7619fbb2f72c58e7e50ca20aece2444347c7e05b6b50ba06ec80759b29217412964e3f9ca48c419c323d52d480724d6eb46a15890e22e5da8ec4b9b052c00d2ddb6aa917a1a59f9d1a6f219e60d1fa15ad1ba0a895c710729db4ecee48301fc82bdb7679d4aebd0ad716b191ef7b7b7d84b7ba7911d118e6ec751c876da983365aed2b1dae71ee01dd3f6f3ec6f18ead94df60d3d1ea2677956c7544965d4dab84b895f41a00dd5a41d3667f3c3b15ab1a18fffdcc81fc827647d3e70a3b47ddf0e2e5a6f540e210f072753f47711c18685b613233d2debf34218af665a667ccfce397a0e51ad853a76b48becb18f86a3272126a71263863071e2e85801735e1bfd1a38e2f260048a6a07eddb3cfcda7446b4bf71916500fe447a5de07c1bfd3a8de719ebcd7c57478f74dd554ab1551128dd778b4d12ee3703a7375480d30ac93461a314f30f83fa8917367331c9ef1f30af86aa1d5d3fb8e6f12b482c1ed185fae2ed179f05d13b1d39a5e775d9bbdb731f130fb32f1110255d033d2978377c74fc64aabc8530487d765014d88fc684edd310f421fe0c77b02b6668fd0a93782a23a2e6017a2787699163060ed47032d060f985eed9ffb63bfbc91eecede281e08f1c72f8e7fc482c4fc79241aa3f41f8c54a355e4604d513c14463518815f355ac642c890bcb0d02d928bf13e548e0bc7e0c48ff22ec1d508bb27826f90b4cf018d734bc52ee1cd8b96a61ebcde084d48717b88202f6005f302a764065bf15ebe97bdaf450934d9a6ab37d3e5e08df7f976bd1bac5b4313cf65df6a62392df089c1d54fad956c007def93980ecacdd98be78adcf89acb61fba1254831532f517b1b397eb7fddfa26c132d0cbf46dea917e1c48cc43711694da7b7d70ced409a8eab2d27a891918c43efe69d879e499dc375645df12f26f75606bca2d1f50f8a96efe933e2ce0139ed1f18bd2c3bbc6c29c3b6edbbcbca06f4399205711fa063fee6c3f8715172355681c56f88bd0929b2fc93620332a90e3058ea7171394f461a9b71a5c49d2dd50788728835cd55c419df854bad19a78d7fa2bae5a9f47e7c982b9e55c380bd24785734ef562bdd3eb40f63faba9765fca8eaa122fa4c9af0b60de1f5e04bbcecd9c4dc3508a9f676a264c9a1dec9fbff27c83f043c195bb21c5d1f8f6f28c6254fc577cf4e57c68e759f64f8cf992beb94f1458c8ee9e097478a47cb8f476fb56a694ee956f6a3009ea6098c52728834019e738684d8d82edb1446ed6dd99d04e8cc99ad551d63daa0c16f36f951123bf483b690c43c3df91e7b67238fb48d8d9cfec1c896f9a9d7a7769007a52e6c1098f710dad974c785903afd95b2d536a0bc6a97b54a70eb4a647afa8aac67c867c5e3f8c2a59a25f12a732168314d2fd036f7f9111b1e7e2e9b6746f0554fc97c4cf9975252004be271488a0b135308c8c839f5baebcf1fc4397b8b99a0b2da527c39786cd4afe425f438f274cc1bcae58658bf9812c0328e8bebef43b60e8534130b957b6acc4e8ec63d34afbf1ebf5c49dada6686045ed412c7642004ff926faad5fc0a5cee3d2b8054936a6108557fb08520d95dd4afb2ceb7be0eacfa6e1b0f90093da84d2eaeb1fe2db9e705cbe0cd67ee713eb9e0342ab39b670eb46f99961220351e2a8ea421e7ea21c2685d08eeac13347fabf0807e45bdda538ecae85832353d2b3bdc038de98c6af3e1482380408d5af5b3c8333e47c9a5d8d304929f88fd9b31a403602392e4b4df975feb5f0c4866aca54dbd37fd66de5ba45f6e1ad90b7774608e66aa5764e43b8823d25ca26b3859704d413c5b1e1df2d57d998dd3c917a250568ca9deb4b609640462de480a8373dff3eae8eb43b92bc1fd355b9027f258c43b89e1eccbd3235cf9c4989652190fb3a1b744ddfedf53e39b6126cf462bc1da58b82a657d56e12dfedaea15acbf7f196e536c1b8f59e54c3edfbfd5488e4bf8fc6fa3e3dff5a1e3f35c1b254a07452df6d734cdc5d9ff029d86c3034d30bc3e8127e4053ffbc62fc441b1ee6a0ca59ad219bc4ade01fde797ae43516354db94614e88c2e80c923d2e820200031b84830af9b3ef5f4252d0857b4759fea7e8bcab1ffffc6b6ee361985295a0d9f9d32573635521d97eba9c18491f73926204123b5f5cd4de3331f78183279bc040a7c13ef0932e9fa4103d0044503ea07b9d673e7363c87048a61c4fb776cbad5de336b95896767117514879d82b2ab686452739ef03b28ab1ead2acff14cf105ab2c60021d4d23a3851373a3ebc51cfa223c1dcc6136c6911e3386a172f1d9adf499e7a8db3bce1833062e719ac69ea2513289e278bf31053241c555d5f29af0f1cb5ed7c7a4d274b0d94d25ac4f600e7fc1559edd3171a7ded641e1a4f2b3bb0843cb59ae62c0032e56be527c376edd808e77abe6c2a667e1c506994affdba4b03e6457435a65740a2c32e98d3224f7e2aa5e30128869121b63b4d5885897fcd3c594b424af0cb5df01b0e8b7dc9ebfa8504d32d74009831e6deb1a5002d9e62509564448d754f6a16d1bc1501a7c65025e7e7f4ee30bc0095f3bc89128bd9c45c2a892f8d6fb9252a81e302fa143230a2ed7e5d7f4947bc36ddcd8d378d0d5e143e96b1c7e47e4e4496e96894bff1a69acd71340de4e0d3e9e51dd94dee0ff28393223c34a56e9e4a7efaaabb5bccb8c7361908d6d13988e1ac8c71c2cf486c970d21aa9fa36d699d18bc33a3a0e77441bc6f9be2a4c4a3650613bf841fec347410a58b40bd23a8ce736a5f15349800bb7ffc9fe5c2ca689d402e372c56e35085bd4eba5b02834b788a3b55705573d468795c90f9524c2f3567fc730a5f5e703db811dfb36882c1d5414ecb29ad987a056c0d58627894cdc883ce2cb1216c7ecdd9af9d6f8863e8f973cf48342390eede88107dd62c530ed077cb9b9ec503638b95a460025aa92417cdb386d547459b5537d9a1400324ea3fecbfbac2e12054181b642260614b11cf88bc1198585fd902040afc2b20635c234fd277407535f07781d34233a3c02e004d1880c882ed85d79a453d229ebe08ca9d28ddef99fe4e3a38652ee6e417dbd6339bba0abfc7640d8a26ab87c628bad665dd61e62f402179af03b0e95fc588febee036335775b011ab052f421ff1fd7b394eaa97d3c28a96844686d6c2159812185ea336b05ce2ddddbbfe502993583d24ea5e2434963bb697de292c8ca26eb81fdf376e2161cf741c8507b1b1ffac0148f23137e4d91c5f4665a47a01af256eca9872d98acf4f1a08182ccf4ee19b6a96f7a3988218758346887c847548649b9a345313eddfa56ef4d6ece86e75d1cbc6193d349bf8259fb80f9100b48e610404a7c33b0dab3706398fb049724a3da5a3908503ce060a24b0c126eef3b518433ae23c8fb1e64c05b061dc196d5ad9a1483bf58085d84f14794ee8baa705326a240b44083338770455c5224d17d3b787aec3ad8fbee09e59f94be91e5556ce636fd9c3a64a4c9bb42da3c6efec0ab4d7fb09a59cc4c83d90e56894a72b88c37bc0c4f430dc3a4ac31f10d545735f94aecf7dc20b174e82f4e8b782ef65d11acdd7489bcbce44118fd353857a84f6e39fa4524137f09bda99d667ab00f637963a6cc3bf86484fdeb7ac18aa98383f6e6cf908f2748a97ca138f74c0b2470fc090e2bb895d85b4fe8c345f2ca6513f363d66b29d1a6e48a201fa524f8367f3579aeb4820bf0b81473c5827fae836c63059752a90d03336a9d4d1829784aa95a5f223e2f1fa51a76b1205d501968069e6beff86d877abfb3832a89ae07cec01042203f7370ee96096c76bc4b7bc8c2dfb6ec1dc9fd2d70e488cd9ca3c9fe66a138544419f404afdea2a0acfa2df60b6d4e9e4176a0437726cd828890b0489cfb6ced748950feac92d53f35e3188c968f1aec646bf64f3dd0736116d551055f3c6f9ec15fcd6c3be35747024b5ef24edbff2218165fa30cea535bd0a1dcdf0c4deed5f9914637f20526a1f236d5a007815a9ae036ed1e6a7d852d259363a4bb620b704ddcf5fbb7737ca2f30603e392f9a668c63f125d3dc519455aba811c19b6d17766874b3c4009f3902db27d853738af2fa7f42f86b0cc8a5c4a3768ef0e29a41d069f233e373d2d20c2cbb3e72ca5f942fd4313d0f5671864b0ff2c70cbfd0a13f58af027fe951c1ec14c625889311fa1b1ba6a96367a4431336ccb7985580649e00878fa6580e60ae8b5946324e2538bfe84082070ecee30c8aa83f2195357f0ab4dbad9e25b0b72d56304eade9384368540c8f8adb18a741241587e7b8a6f47b2e4db7ae99c63e70a79c1735cf60792d28635fe2886178a9eba195e4341a649069b6fc04718f20393cec1f0782ac3166711afffed66056cbe9ffdc7d0faac49fd0138ab17ed4c0fc627dba58687f403e59270517227bba57571756cd6f61dcf7d1eef1fd443430cd61b8e35ca33b6e151a2824192bdb3acba49a37f62511a003038fd97ab4cb0255c9a4fd236407e9a6d8dd2663c735106abe0992f34964874b6962bba6013cb6368de3dee997fe29deea550cf66f861b51056ba19cea146fd30a79cb115217daa655a3c26c7ea3b09a5e9dfc8ec91b2b687f4297a343e2e3a9602c0c3dafef91af8a5a1e90d72858d7bad11729e7a6948afdfb85c8f0633f536105bda6385ba0d7258dc01bb98cb24cdcb958739038bf75accdd06ea2923d1784f37ac190c3b4f18733a2f37a9d6568c2a1bd9bea9cfb90fd784342bc26ff71c45a3f42780cdcf99c34c26ae46e668bfbcefc0a86319344758b44286af8737ebf05a9f92b912b8da6ad19a8c4ba58e6541d2da8cb64caf85cf35bbb64279049f45fe1202e693b18d9e357d8e42e8369a0691ac73979f0e5c98724e4e702bbd5f2b629d8ba737cbb871e099ed08fe3f0aed2f6d6fe69b00c8baf0c4b70d82f69fa6aec0efd31a3d9441cc60aa2cbfd158d368368c05eeffe23a763c75941188b160005ecde82f586a4a443025127d43ba9247851148ef7059d2221647cff0c9f97a7c6347684147937827a699c463505adfd48d411f33b72ff36c00f0edd17a65163d1d0ea59700033f6d0498680fac4b994feda8d94621833332ada3ae5565c525d3858e19b1273d29c81fddbcabfd927884de09dec456034549e5554c15174dc9f24343abe92db03c48e8a271efaacf8601dd362898d75595e14b8090110b25b4be88deb69dc7b9d47c876b49e7ac23b9809e48021e474ecd6ae4314e6f2b4e91422f362e6388349e70d2e14e607dec5d1db5db3995bbeaf44b97a3990226e72437b07e373cad2f9e30279cfd386fcfe10421d5814eddd1d5b909f8d283080af70821c4f804e21b80e4d63b02609371929ea178d0ca49db36ab1ef1166f0fb362aca2aad7ae4e30cbfba8e9aa66fff9bf32cc37aa249a5a8a44a37085c673d86468abb4f35efd34f489b4ffcd032a5fcd75cbdd759e7ed56b81563a367ea5ccfeed87ad075cce0e6628936909d05bf5ad8bccaf4e0105363a7ed147c6d8c4db0d0c299c341a2494793ae91e87263a7e24b7a5b545cdac7230bec8b6b9e229eba3737d0cc6745eabda193ec5de49303ab52b3706f90b493b89255b3d66c63632f8b0d90b05dad8ea78e76282ffcf7682934ddfa19805a6bdfa2f21a8d8824761e7cba76e5715eec0931fd085eb1e57047561b0486eb2812d995599c3c0546af380709430dacde55a5612520339db0c3e76418f5e77efaf4d8bf3d2c2864bdfb4fca35cc018bcd7d0dac748609194839d0724c07eef4a4d0746272e555e779e096083a60e89141c7548ea8b09d4201035413e761e86ca0eb83c12d50db47bfb3f9a4f8d8c7dc65f3309baa4411d459dbb701975068d04916f9946a9a3560866beb9a5c1e0831bf212fc692a938ee3f0b9608768acb312f8685b1d789b5409281e1f586425f7ba5f70c73e7e248337eb99743c066e8abeb54a68c0dd25664eb383b932d4b3df019de248ba1bf0c250b348dfb00f3f6c237bb8ce989ab0a89ed2f144d440545935038c4e7f8c89fef4eeb176a282626c4ccc4436431e7b4ad82fc5f0dfa260d1986a5e0621fc104bbf348f905aec14c8d36b75d5200040b58c8fe78d7160d2d41fa25777d31db6201fddb1941bbe99bba83b063feecf6d220c0b3e4fadd6cf836afd0b11c6882c37dfdbfc4a3b0c5f982d3ee4d89d2a5df60d7c771e68aff67354efcbfb803f7d5b4e4023efbf4c5af8844d34b2d923c29189848ecdb47268f73d93557002f324a55b600d8efe6e03c86b52f8538ac4366405c466381f31f5d0a0f8118b6634ff7ab43faba514628b88fc0775c268f9ef2ec785df7cb3eb1a5f8c59653922b5740f164fa7b98ab7bf496438a527f186baf1b51b3cfcaf3cbaf776f92d0d6fff0e273c701331e78e4c7a2c10ea242f7a4ee092448c23a0053e3152916bbe91d5cd1e78e274ac18812d6ebb488adb08ddb77b4ec2c947d8378ee520e93923983109bdd5cca00eb61291cace493aa7379ad0f9aecf58bcc3834186acaf53beddf3e530a89be8a31fc1551e6c296980dbd98e1fd2042617ed7177cc91ecca3da48dfea1f60581a1e3fcf8cc280f68088c7c05c54a93556ecb632c65bc9c28e4fb749f14f4edb28f03bf16846e953f5068aac2ed47db6afde05cebc51dff3d0e7ce68909698bc137e24056cd1b7a5ad997a766e38ac29c1cb3b4802740ebecce782eb6e20ea61128352b34ea57eaaece8fbb788d4607243778d242462f8cad0b1ba70b000ce0b68f9bdfe08a0d707123b33f4afa91a1eec6f862ddb83ad52aa79488ab068d4467cfde523bd52903fbf9ee6164a649068bffeb2ad0853de02b2b8191902bde57b3a05305234345bd7367811685fdb9a23fbb8e2c23054616708602cefd52c40c3c08d2de520e7bf5708998f7a27b128f24d6c9f715c5a4281f139a1c30787a4613b56bcf9d4838206d44f5d573fa138b3a3f83fe50e58acd01ebfb69de2e5333f9e71cd715997f946c14fccca358f44d3fce857865a0765edd0bf0263eb96a3ed5834393f62916355191491d7c8e5e55fbd1dfa4763e613b0fe4c2603f210dbccce20d911ee74cd89532b7742778ef029c05ea476a2b519b2361ca15c16e01bfc3388833ccade1caa46946f1456aa13bca37416cea2515e50ce156fcdb556393fb8f059ca53c71fb2dd486887483a2817a52804202931b423d4e417235cb4c24270475fd205b1d861a070511ffc0911d19b9304b772e539888165583cee39d2391eb9902664858592333780120822eee8561bb77e62c274e31914d6e924b5526efb7134fa392d6e3ee2b0e9c26f51899c1bcb722e607f145eee5e285a24cbaef06dd97f91f58c85a08cf71beab96c18cf11940865cbcf17f58fe0c545f6eb295805dfe7fead20ed238c33214cf889da2acf74c7c9ff9976bf72075870fb9e64f3fb050d2290d151930d75a79c7797211f72b065e8e850ebd3f1d9acb2f537281668ae9648033a39aefb42a6b925e83bf5f10abb3afa8f6ffc3930a0f26d792c8f217305ca45cbae9c3b6cf6e9a875caa22387d72ad917e7d2e7f41b7aa40e51ba63c7cd23c4c62bf4080f4b7cb955670476c4480ca231578304d07843f200a41fb4686df67babfb7381127cbe8fc938c35163feb41404492220825f854eed6b2d6f6251f96318a93f81e81e6a8f189d54a3665cab6fde84dfead6df5de4bbe3391f85013081dd6aa4246b5e71f0be248e17eb79ab7696a254996eb318acf6e396efb4ee4d3708dd1ef4d6f9d634ceda7b7cf920bad0cbc91e868b26f62fe0cae48391a650efe63ad89dd55a9ad47f0c3d4548ab187ca24892b237d432de7f47ce12682ebbda16948157ad6fe6f98d0481ebdab57d634ba0cac713fc99fce34f3367bc959c10d9b1427bc3c6ea2bf87d01077ea92f112ab4791f1ef3469afc17269c902436350a97dc63f1ac36272dfeba0d2f2fd0a71bc1bef77596e6148c412f706d6c3484e99e92c270ccf2efcc01db1a6966c9c04476331d668f027e6be4426a339299466999c780056ca9e58647498568e3064ab2db11d338782f30f3badad25f8f5e7b84117c128c2b398d6e2030ebd231d56e00b91e44ae904b58ce456ba4c0c8f03d79b60805a7aa7808ae52d47442043a1dcbeb694fe7fdf8b4debb9f2d959b1ba1325e3b5d04e29097642fea955242645180a19204bb2a8bc5533da5ee6f0153659dd32a29281df18f624d82c72a536278cb05a420d21eb1a3420776e3d92f2f7344a2575f2d7d9056bbbe1aeff7a70e6ea7a26b188990b68bd64d791ab8207509ff80d30766c92e0d2395a78ad96e17cc4b11fa8c64128e483384e7d71d7c018cb774a73f351edc53a23326bc824b3e13e11c58be3e4f0098b2258b4a8fcf98a1bc30eec15ef9694ab9aa235b7a0c80cfcd19f6be4ac2f9ba22919e0f48ac81358d4515a9a439cf05d32314a0060f86c67a220b43e4f90466dd7eb9a49d8cee143242bea1cf138feb4c4c92b5be4fe2dc69afd3fca4a80e92c11fdbc741403ca15e4ec96575360fe0f56f1e8a70c1a9add59f765b60af4750a209301041f1067f86f8eec2b0653afb941933e940e7fb44d93e69d8c66a153d65cdeafd003c302e3f1bc50a86de79ffe657fcc0624af066a965122f3cb3a5437ca0d1c497f70527de13c7af59c85730694c8ed6500128d9faaa983c1c080b851686e4d13ee5506c6bf00a4f9539b37c7878ad15976f4226c67a4a373c45eedd010124310003c58f926cba6b7a25f4fbe447fe313d95ba92599b36d1672e2ce75699698bdb9dd93a1921d926ddd969ca0192aa269945d1a9555881ef5190f4df0090f15feaecda670660b109a48402982a8b9b2a2d301a74dda898d859ee1b87450f078674cac5e08518411e471e6b77a0ab2f626294b0523118cfe085c530ec5fccb0d3c701df5f055ce622f6615063306c02ca23b86f3ca23d933009e59c9488c3bed8bf3623d5738b0e5c744b0484ac9cb6b9a9341cbcddcdec193a601fcc02ea5146df91fb6a0167542924b5de996e51753acafa9acd3ab61f27329b67a48d28c8136a38c5a3ffb9704672d32d9cc96022828cb9415cc2e398c019efce00d2b7fa77d03a8fb85f5efe359805cc0963dc2091215f245973a6b4e1dcc839c722343ed38c75d71924dae2155d660e326d0a276826183d7403aaf2d90776a6747b4701094492ca0c4a0461b1ef1d2d77eb8ba97ed1727e240a467ef921e1e458923dd7828a58e0384aaca8c82b958c20802d172d57961dbe849202104bb96391c83c52c4ae6426c9cac17704337aae072fa186da8c067c5608c046210920223215d9fb37496149811a9e6c73a9fc5222afd37e3d0940c7729950729e207904c55bb0abfb98816b81fe305b2306e834750fae72cf4c82137e6bf79c0ace86bb4033ac9dd18f6c8861b74f3ab2eb9def6cba214517f376acfc6d83165915ef551f34668f8719d53cd4efa83acf52ccffd506e63ac8d67c0ca6ac33e41b0b1d3243e99034852a1e176688db7c6ffeea56be50cd63547eeb45a20cefe5fbdae8602b5860d4c15ba157b4a9df1b1f6bd5456c44fad22926e65ada64d7629a9d80c40329800d8ff7ad7f06b34abfc3a1b3485f9643d2561ab5d3dc3e02bf91effd0362f561c859cc082bd1cb2796e1b77f4dea2a04851b16d229d9046a0c4927d552cf399409f4ea517ee89bddf134760a5233b093a28a8f1967c03fa17175490074397e9c984a50bc2193c98ae8a6b33d4d0ca453020b2004061b8692f85e72171e57582a83aebe8d73880fc578b3d4e73fe1287e16bd406aac0f486988ea9dde01db2b66cdf2967542517a0519db35b885f2e94b99e5034ff9c6794080c47ab950e9fc243f4ce7077f4a2172d97312b7844bc04960147cc56ef8a1cf8e1cce318de2ea4cfd4dfd8cde33ddfcf151bb0487b96c1d55c674181c33e25fc4aed0ecbf8f266fe66ea276176505d2519f20affa16593f523e6c7da0e4de05da9539d14623fd44eec30e664c9e5263c2d9ea4949e1fadccfc9bfcbb6886eb912895db0c78389bf1df7ad45dae831fd184b12801657a916c5808d4ebea2545727f466b4ab81ad93ea9256a5e7ef23890f9ba5471a4b1219a2e0a4dc436c250fa9c1203c8320d730b807e3803b07559547f4bbcb144736910d3fbfbc3fcf8d09d81c6faa852f4a57b32afcaf1cd94454d8578b2c50a46bed226ffa214f01f891d23954eba454686fec2b896b72771ad8382580e8488212537be1d8e56f8a83a6c4150a59d4e256b818f9ad7a7d4989cb1c71993792d39413f831585ada165492455972230117ac11c379fd24de27f42038394d6957cdb17a8bad67d7b527d490327414733e9c653aeca794bd82","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
