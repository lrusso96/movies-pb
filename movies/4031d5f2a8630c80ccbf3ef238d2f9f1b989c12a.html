<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"714044a6caf706947d2c390ae0b52df6702e9d85bedbee8608e9c2cda0340c5f98d1be2590aab62d3566457086e02f692e6c6469bc4aa5b21508449c520703246ff63053935b3633354a6a264784db14f10c2745e446870425bf57795cd1a48c687e130883b093cde3b6fe0584d8983e4fe1331e28f2e53a39a93e49d16ae3b0053d7f5d3428fb95f1c58b6b93f6994aa24488b80c140f15dc5ecb0ecd66494a62499a33b2b968a2152d78f080e0dfca7c78b0f83991313775f5ff06b39969cf8cbfcf4fea3173ea44898bb659e3526776f642b9ce7af972865862b29d1b51a2988ac8c1836927619c32ed701c158e7777a9c1cd3906a05a70848ffe54b37dc45778ac7d8e896211a821630e362d375fd734e5d813914ae66153de7a6c9e37fa7b9a3cd6813927993e78b5e333df05dfe2ef1cc56c5f60ae9968ae34b4cd46547bb6d70b945c91900c159c215c612429c291fb9ef151d142193f510d5df9de23c76281638c96ee6ea203c08760298e61106b26daf07390400478e35e95af19e0ffa5facc0554baee1f16a963ae6ae4834fd73a6e7f3f9ca3e836efd06089716b856de52b352ac53f7a1d65c3a481907395aac3efaa07cde5bce94237e550449b7e35d834407ee8929d10c271c93ace9b37e6054516658e3474e8d99fb7411a37ef907ea1b159edc5ff54ca86f0132e22a5fdceae8c42865267eb2bdc25dc7a2b0517db05b00406c0373a56f017445322897ec33c7621810059dad7530f02a4f0b268b4b4a16dc5180cedc1b06122de5e61e83d608103e87e9d2e6ce9f4a786af5dc9b751882c4d4399acfa299e683e04e14c8479b41968b19a3a2f4176c3d4d8da0d75f0719e6cc2dc7ca8d9396b3a300cbee70ee9834d1bb68da7329f4dabad68e530425b4c02855192ca8fc85c0d854879cc0966bf3d6d940a9e3dc8612694c8e107a042894c085d276c9ba9df5ac5cbd2c610d6169c0fc886f8083c3f0a5b0a2a66e7e0f2bb30f0034c2ea06bc5e369f387e13ef06d1d086f0220293cb3887aa190f5fcebeb822a9e3e0fc21a16e342b63164c48003762cbaaa15f34027ee70f2eb4059c7f357313f91bda6be9e32f153eaafcb533a22b3488ef2743853cf622d07219d43214dcd91ae91cb0e714cb3b823b6ef2a758dc70a31188243c077f18045d28c1c2d8f38221db9d57ab210c497dbb3c2c9ef5d09708c59b26827add5e320fb812316b96186cc681935fb8116d5aa50d98200781977e276f58790739a038b3f9c4c26de169b8383723678f31b9a48ad064f7bbb236eeaa184a6beb5b8827136bf1c8ad6819ecc5957bdf8415b2ea823e772fb92639488fff52c7ad172fe4a5f6107fc998a5b1c323a1c683367cfde2df37a3d0d892631e61e854d763a3e7241dc76f58b17833ff51c331b7f13878247ca5928092ea47fcfd0b770b952f34cb1c3278d9b0cd9650abc6c9045930e461d3808bb67313f89e9713fbb159dcd2bdf9f3947feed2ef4fb77def92a98fc07c08a1240a5def73ff3d9c0ce716ca745cdcf9c702efcd81bf7c0529ad5e4dad56b8b9059404ded83816b7904be09a6f85a43400896fca4327e9df020ebc5a7d90920becd5d87fbbfd74a2cd8dcd2104675d9bd3a3c2ab79da77c63db3a2af8f55e029aa09ce636c2b3cd46f612a8404fa12a079679c8687dd5404f0df490ec05b4fdc67bb5230653b6b1c283b07abd88e8518ae78deae927c4300134b83690e0b6232cb48ab2aee148caf3a9317af99792786d80c0f69956319dde3aa88e16b9d22d1fb1379e46310b38d039d2adddbc594bca75bddd7d88010056b2292f50af768ac61fe738eb85004c96c15a056022ca41ed7c2c9cb97bd81ce4615c4a9099e53dd871e00b4516d531e7cb4c9864dde9bb8c69f62f4a8703bd93d7386c860b51d5634f0cfc5692b42a2e3d52eeb1e1042e9b46c6a90da08da872b03086acabec0324e1317cded8bc4789002cef6d92c9e6d58d1fc1fed3da9fedcce0f476ab22bb341b04997a9bf746afb4119ecd57e615b3596ad489c32df2240a37c354fd1fed7df210a47253440e528af042a34e1057a141064f7c5855894a4cb4fb843c60532de741e91efe8313ea6d1c2c13232b93a39fadc7855438de1570d5340dadb99f480806b1b29915b95e953766feb4ac4f4fbab0a92631d1cf2244d43c49fef3a939cb7aab904ab254380d95b675fc5933cf5286c66a19d2fb26a7456a72dec0266ccf31d2674ad9b2ee16435223b9463cdb717a97577b7425e06db2b78abfe6b356842ec2079593f5ce9bd28db234fac24f3e91b8149941b2af6955bc67aaec2bb320dcd0bb8400fbf3adbbf773213de58fa69dd8beb3adf720144f5fbdb04c15c0a81ea7a3a7e0315a956e9a4207b2266572162cca44f8121896229f407e7208db57923d7e5e22b3538e5b522beae847336f04a655881ca227d759f5a38f6d7d3eab62d24ef65c78c9bf735f53640cabea6c6a664b9cc3140ed8f1e0afe88b7745603fec5b4c00b07c672956b388b8f14ed3cf237546e9729d676a7343f5cd3ac4aa671796d8f52b9cf2aa10ba9176afdc890b05d7ac9b4c8bae3ebe29e6cb57c16f3bbc43e7f43532dd000609615f990739868564ec104063e209de3c03056969be2d175b6e37bd3f375467c4af22c9de13aa5795e827f4b89c3f529f30d9bc44361169d8992ce61fede4196483f9a61f2ef29e126f3a5669cd4c539cd5ce9ac8e029a1496f80c321d1b138b3373e03ee74262d96f154760c57f77dce35eaaed3953ba27ea2c19a324c3e531f292f07cbe67f939b2a83a82e3f67a586a74e866b0021d699cc9f62dd8915b2862265e24ff2fff928803e7ab75d73146ded5bb497c4fc61db7e1e8d06e70b41932af4e03681b70f2a10a50f2253d0c1fdd524bf362be24a16bdee9e4134dfdc36a890b6ba09ed179e035305f7fc8b56b1f978a01dcdc20f88007ead97e3881e6003709929b51ec310691eef4b07efe24989266ebc42b0728a77dedfda319397e97c23909e6095c75fcb84c6c233df0f791054e29ebe9f4f9bca3c47229c9f781f42af6f60325b430dc1ed81114b92467769b998aad312c6e9b396573f18808e503c6e4a457c3328e08cdbfffef37d1f49b50d4b29454fa7d77c74e522fea79d2e6b0d1a6edee87ea4ddee345bb364b32cd16b8ce8b9aa1c2dbdbe47cf1fc4d3c942375cc5f1b15f89bcb7f54429cc0fe2a6f786d19a69afb37a6122bc7139133da6075920286cda4c28e98d5ab00298e503e65fc98f0937e20a12b5017bbe434bc0d88cd4a37129b7c0867192d717f794a726cb689a97e96c88d4f405e344a194c9c6d7a34ea437cf1ffeb3a85602bb449cb0380945f235884d5b8c3c93761c84cf0941ab29f025dece4b3d4ac924e6b82f235e7ee677358468f5b376031d72c1bbd180a00323b5a2e5fa4ac1cfbcc8ca16eb1e8d184a9afc79e8d2ced7ddd15d4226912ab9f57509201973516a73e4580884a174704d651cd0cd66b1f53bc000650c26b9b60e07093f8efb10577ae2b0e0ad45e7dd1f15ff4875d91634ad0b1e99279cd237e1a93e1496f519142e827a173ca118d347f1a8dbbc85ae375e8a9eba9dad39cffff599bcdc3454076b7f39d358516c59ea50b75d2471cc88f7679e9faffbe2b74514064f450b28b167e772afb1f68770223c7bb410fe8ccf4a1a33e928288fe169512e9542e75da96d2db9869b258e0fc01787cde19535f444670212fea5766ec7c0b91afe07d8bd1e318d36b568be20d3362900a70488a9e62bc82a6f498e7624e69caaf20294fd3390239c4012e792f284bc7fd42b2dce69bf8aa5b66dedd44bf81b257b4a913e021d393170a6b1d4b50e19e10823c32e59bc55391fe5d33ea3e1258e64691d4364d26b251c4e122e8537cb9b0b5db3ac51155bf5eb84c5b22c673f1db4782a551a541fb8e637b1073ecb985e40b9256ad88d1c91723f2ca69cec2a60d4f08d6e0f6786b1b9366a32cf4f5394d4d1c99975f38af515c7a7c18c702a6c497c4119f083ba5f2493cc5455aceff4a1957d15940bd6b077fdef89d75317d6738aa78db2f1fccfe7df222a304120658ee7e6cd2d143af576c279a7c7beaa4d0e24b36161fc72027c1a490bb6e3095f6362809e31bad4af27091c54b7171cda47fdea36e111190e448a90ba94b8117c2aebfdcd12c25fcee7a239c378052d7345bf91b4544ffaa527741f9d6509b2973b711a6b0f33141e3dc326595be473d19ea6093306529ed9494e9f1f3ae862d5858c85ac576d5da8e603269bcc96b3906c08f5c2822fc04b6ad14b684f1c8752fc82d7eb3bea92a07db933b5a4dc9819cb77e48eb4e612a78a1ed08bee48633002d5b6d0f691d6ad43a61b22cd4d2e4c61a919b9c28adf3b6e3a484fad16305e46b2f221880c2a4b192a09e70c7428dd4cd27190424f4f8b5c9856c7f0a1a10ee0b307d8bff9a0586c14ef36330dd864f2d77d1fbd53ca74d4d1873dfe0d6c3b6d8cbe2779d6402b58468e9e863386687a52b49980ff77850e53917bbbe253d0daa3270cde1431aa88ff20e31bc1e7651a302814d8afe097f8b784104aa17519ae254a9267ade5696e0bfeccaacc03367164f8e275c3fd5efe7d09233edeb3150c4bdf27d7e40cf0d5491ad63a6b3855f61ec51d5f38c58bb9eba3090b06ab23f81d5eb8013fae28ad10bbe6ec9d47a20f8f68b03580b24b8b8b750edfa03906429feba94772ab33ff8d3329501ac82b858d9ef8b03a4f025d81f5292f6e8f15376cc9c4d07cfbffdaa2f26b50384aaa1f350be7ae82ea2f683da2e11cd4c7e5985b46ac448ad09533e2b9e845f1044d9a0096b9514332742b017c7c6402442259b75f2f14d19f488f980a886e1e4dd7ba588075dee27ad65d42ee7e87f97f5fc56274d331dffd133dc7bf3d354896579f3a5ae98df112ca90f8d3c31c26e841773bc9961c0609890f0562b0ccd0b12a14afbc0457366d14f1f897831f411d3cef677936b11843475ee2d8dfe01e995186ecefbdbde3c08e62641f7aa3cdad39ff66976fd2d82d8ce2f3a4949d3986832f7bd8de123be99259ee72b7d11fe2e5fb2132e33facc4862613d43578a756585deb6291cef92476c9e99f0ace4fc8c6023a1c072a51195b0293cd146158bba731e5ddeffb269dbbb8dfe844f6350379d7ea9934bac840af9dd3e83a576d97067487c252a9149305dad2d7d1f6035bc37dd4cb3b2f9e8788ff8e8c1ee6832afb018a197fd02554f3cfcd0e0e529ff3097e4c3bc04d1393c074f4e66ef720ff755d44558c32f3c0a0f0cfa668f2b7e610fe625d5b1474a498c11ca1ff2070bd5d8f27a4bf6666009d5b074be8c6c6fa0aa771e9b7a601ce4e820f55aeec8e24c8d2b7b45f3922fd93a20f30bef972be3d605efb20da5f0ac7dcb15b4a5df2d2afe562715b1a25220d12d079c9f7f1f4d58f5dd0653bdbb4530a1235b389c282a3511570345d5f40ffbd8d303125ab291e1ae32d976124bc66de717c90e668f07898bb2f747914ac0462f13fa50afe3b5f5fee00b60c0c62ecf90adc23d50dabcdb029901a681fa47766d0a7cb682c6d171c7dfd856f793ca512c5084ebd246d66184a2ebfeab3a96b7bf3c2975886b0f9ada57f6c2538edf690f13ccd357791a471be813f3ad45d84d9e905ac6e6ca6d45e8dbad72e16c4411138cde3503c8d4449dfefc7bd7cf650595ea4baf505b7870489452a124f4e34992a942b38a23f279fabdb32de95e7fc6376a9c4635b12d0b24cce185c8791941f3704424fbd213034adeb860687efad5fcb01f39c3e75a240e220f7677ea4500122e41da68bfb2662a2802e3f37ba5ea0f75942d42f277478cce8272cc908e5e50ab6799204cbf64eab6cf322482804efef72b69b62b43d7bb303f76ea70c486a1b8cbb3de35d98414013dc54396e6f49b527b35425f2fb584b86aafc4063a4077db35a9f5c5f1e14cd4f257c72537b998f255ee62d293b7334e1e0738292b38c9a6b576d303d6d4918a0ac5d92ed10fa77c085240c17971a17df32264c6fc9ce853ac40ed0f023e446b958e0857fe987f590c88f6f2e675397937988e770c1d0f6f48abd9c8b77859be5c1e4138b40f8931e6b428ee86ddcc3199dacf79d6b8dfcd4db568721c807d2f805a18db7f1a66a8fd1cf1f07ea98365007e06fc7e75aa1c60be606cda806c246d87f15f52f3e948809eeb91945f53572362f35d422caf9a2c5af1b769b145dd8ea6b2808f40b3112374ca048c06dee15e0cde4940b6e9136329c7faace918dc44194416993e6a88aeca3f4dcd06a6f0300d478a49585b50f0eba91b201501b5fe0236c3f9aca43811cf31735ec067bc7415327b36e4aa195cd07ae3b6e5778c36afb4f7ffe35b9df207f0302247eb4764a29c607333dc93fb7ba8463302ec34342428bacd60d36eeb56c2bcd545a358297137f72da8e0cb9518bfb8cc64bc80cf1f27c20e8be623046318f58986bffb5f489ef0fc000d028fcc8f872ae53d6608d50ef717f8f43b97b6adc587673e06555ac4a636b373186db8a7663b7d01804ef3c2c62a8f92402c45b0e35327fb2bba94d958aa52ef0b9b5ae0e37e13477d10dd66cb3b6cc9fcb5068559caf66da04b092e479b7faaf75a50f853e7dbb514073410c2e21e4875a7af8c199c048437498d5c0bac210f8ecdb09e72ed4a8592aea7d373392e4db2e6ada62d3dffc4e106b44d6b862291c256dcc07dc8c25f40add1ae6ef599c93bbfd051b112b384f66a1a01761e3c5346f80a548da184b2a388dfc00e660e275a9c43737be7aa98de7b8483f6aee2824c33fd06191487f1decb0a682dfc726ba17cb1498237e0b0f41f5049a4b1a777593aedb0a736d7184090597edadbbb1abbf0f335eea4f9756b55fe578dfae311ddff38b628591bacdfb34d0c0e64e570a0b54d45f7b6bdca575849dec379989445b0a68cb90b97e43adcabd05341ffdb5811adda2821d5decb1424c50ff9673d6b59e0591156654085833af3049449d8f80d60fb35f7c4f660c58aceae35d33c6085641e54616f4b0ffaf6ba1f20dbfe785765b5a12af3e204c44200e050e437a9742cdc9a72b66768332c33ae94c933456d6f49d778b709c57bcb30719ae27d3eae06fee1bf067206da1dbbb5d084123508d56d8b4da9056f11d62e7b8fe8020e864725c64b68c0670cae83635c655b23fb6a01776b66bac383bbac7b7e8f2f14e9dca9fcdb952577dedad3779c9378ce6e10127755f7406b8528919fc5e138361c98411a6efba36e60870b8ed70f36983063f2115b9165dcc216d38267e392c7cafdc2767914881bd77c157937192d32a0d3e26a2a6c55f82d0d58042449327e312aca936305e11ef48dc950f0063612e7eab8882784e2a91ebe10b86e41a981be156fcf693325d83a4c7d6f259104dea07ed828d9c9203192198031705a85181dad473b1e401475a9460867d5c7e3cff297045211adc285917ecaaa08c8449971440c25ba16a228b002bab85760b167017b4747959b3993b12cf69a13c0e8334651a9c118b40db90318f5cbb83371e1375d0e507c29cc852943c392165c4b85212fe3b76b7777c90adcb3dcc0fed788b0d7c55724cc18907890b310d7cecd76279b0bb8e2b4881eb8a08354dc71dbd65882960b54b261af60fb8e9d905aed706b676e5b5d03521664e5605eeaf1eb74505029cdb7a6fb422cc7b604b766069783a2b06287590bc25a75136799910f8a8bae3403a96251e620c25cd378f5c5c6e89ab8b75b12c1ebcc6c0352cc51ab0553fcee3270a20673aff218ec4633f9798a7e0628537b35f9e1ec0396776730f62b1e25f78f4d8f67879db3d24e7d72a4e2596405e13a7203dba6a98340e975491df18d94537da44c50e061c8a3c5d2f1dbaff621374f0556a19e57092ed72332ce8191ebd07ad2b8509f39e9dfc426ad8196695aa0eed7bcb8aa608edfd302eae9d1a9a7e7d382b245ee27dbb7864fb9d0002fdbb6498caa884e8f08abb7425c807b67f83463e1fb3f3e26ee703eb5045b9130a6d1ba1938a4ab7dd7dc01d1ee2cd73c39f4371f7d5c520dfb660415a774018cd8e3fe7f89603af6d70b90b31eb5bc1c1c4dc64296518107ca144700163034ddc1d8c27996a9a6f0ae1f957461468ef5c25f276620cf1c4377326d1a8137c7e9cad0e128c5e57767796a8f90376cabfe612c9fc9230566453b05390cb615ca32cb33ebe9edd7336b1158ed15b1dc2f5bcd2ffe097a1f7c6338a0aa037b7056aca28608dd8f79ee4899e2499669a2a5e42512085e438bf8b585ec7219b163a5263cb000d9026f6c11dd8e710060f9609c25c0bdf901a356f99e49f210c49112543ea3188d49236234e5c19969c6a395090de8acf94b2a9d5e6c8339edfb3125c8a25d2184ee64e5aabcfe1a3eaa9bf365a4831611031ce5295670e9c7d5a66df40d6db51cee4d833b8acb90576e3b76ef413d9cba2942d69a88afa9757577a929b82be242d6b688909f5a8f474861df3403ec1d3b601ffb415ed926f86ad39104c3e448f31b38680e1b40745e01469a1d8a6a70dc1c0b70a818c620b99259fafddc36d0e88a5844d09a1aa42c91a66f3f628a188c1768afe2a67bc6549cdb633a729dac803bf40521fd9414a019afe7007b2da133e1392ab8ba108e8276889b4c25e65876b090ba1cee385fe3dc1e0e1c6893e945bce4151418a7dabbaaf8b22c9915f6ed5f333eb77919a31ee32b6829c91dc28fa94f97e15b6ca83e103378bb427c3694c6d43a69ce585bb7d859f2a91d05995f870bf365eed7397a330bcbe9e7b6dae4507a26fd418fe9403f3f3f5adca5455acd8b1778b1249ec70dfc0900f7e356aacac2d32b56728f9741a70302c22bc9008523ddfbced6558c23b4e5075d6d0d788416e15e935d20ceead79da0147e2a52e137a6a62d0e54decbec279d6ced75c2f02cf05b851c919e0951daf862ca69d5866d71d9616445aa25230439147ba6f0a961ef033be5dfc5192c4eaa6f72b43013d7de441dd261db94efb5b272a3c0453b526e77043684eddeaf7fd68d4d0136b6034d8ba81ddce5709f8143ae79586054288f28f3b3563b2bdc6eb6c08697645d5444eb6ff010cd499dd949c75579fcf45d2bb3a236e34a32a70f2b9102d2a8e202dafdc8a7601475b5b2427817254106488c2eca30c2178aefb5d732b9d2d17f77d073cc05a95ecaf4c60f87bf9beaab07b70f6a5979565eb4dabf2a5d1e1c1eaaf83a56bae102a531ff34d6f94c96c502a4bfbcc87eb9df7396a21ba4ff4b507e78af21b8e1a985467e966662c778007e34dd0918c9ff773e3869244d6fdba3452afa7c578c40a0549314e1534b19c1638d22e2180ab880812e042f9e0252b5f23888772ca1df3ff30c7afcd00b74259c0e52b9ff7819648f44771ac0ab9c92035cb62a7c209468f3bbf09f78888505956b3e8676f38d1940fc572a9fa63913c92be04555da19819db3de49b2e66b04294ab81510e177d9c15b2fca2ab55dc018c9e809895a3101c316597c111a0a233a65d1d2fa6d4955142ab7fad3b0abb96768e784cb87cf21550d472281ee18d07f07ecd2c2c578ed4f44d874369094f587bd0dc3219ec65ba712cc4112c6654acb655e7b741071fec84b2e493ad96fe16fcfa4940b7d4c76004b50a5d4c4e82be205c122befa8d8ae2922e056182b0dc47a2289965512c68d7ad97b955d5217d5dc67fcf07ba1e1d0d356a94a868d048b0bdd309806205aaf5b5e1e27aa331a2dd4d787040723fd7296a38377d206e479c3b30a69b4ca7a1e4b911f82b14cc6ecd4fe19054e153d6206179103f982ef85921362cb06289dc0698f7c3b1be5d3c567c99420617c719bc7606d3ea4accd1b57e15d547974949cd05fbe97a7ae5013f458f2be8a9a303a95c6fb7a2c23b5156999e2b0419229223d40d223c86797cef9a8f471a1ef848c6e1cff661a7419d67cbca4ba59a5bcdeb2268a473725437259d5534bc3219c214e4a2908a342466fd1a655937a4fbf6e02cfa7e03b43f42fa1ce857b284dd341784997b11c6429de13c8c473cc54280c1ddc958757e7e1d894904118586331795e666d99e0665d33cebf550c09258a147ca1b58feffa1c1181d85c082a7f406fe518a41aeef92743a438703d3c98caf2aabcc0e982f126e0d1996ec0e14b16d62c0be960391607dbd31f5a4dc6810bf78d30327726d31b56f9816cb931b7add5d9c7b23bcf52abb12b727b709fe0f6695da16da4db24dbb97ba7a75d9f03e02d8f293f92a295d8d7a291d725c6fd7927699b924b8c23514329b6aadbdc2f9f71c7574613f9dba0d2987ff43904d8ca25c8907e28e745ea450865ad1891b7d0c46e47cabe3a910899ad88af17ce2feb11e8c59718dbc0b58159c2a24e0bff333fd287a8093124941bd38ad07a7ab5fd1ae15ef19b4a115a32b45fe0351d9965092807cb59c4e912d4fcd4502a40c4e6005d1e03286b76bafa86efd5cf5adc0c0269c809cb065ed73900a0ac7bca7dbb61d711b9d7bbe4249c4c4c70a1ec889fa0b3729e77e23097ddc86151c2efd8289f58ec790de53cf27d0355b23bd2b444271e2d5353de86f4757b4c7166c2b2db60d80abd8211236dd681d1ddafef38d8faf937fe714d248364be3597ce3ac239fef2b2210901600680d625c433fc1ff9437269b9421b3e80902f738fed2b3ea0d52a8b58c7b6ff1fcc5d19a82a5099338f4267b158506bed7287505255bc2f1de544cc8a8d00372bba9d054448b20e5fe803e29d1d207ad5356021c73fa80b7ba7b683d9574492cf835ab515a5b08abc4d59b9e4c28a64e18b37e3e836d9a724734a83d2e50ef5c2ebae2429a86d5cd1da8f71d3fb288cb2567868d2c2580cfed3b2b95fdc4337272acf08b086a475c709f8ad92f856e71b1599776cc5c7c819dc748b4958f7497943965f0fc8cde032884f0f66adf3eeaa431c87cb380d63c0d5bb2db4c0bbbaa21c6619522cfaf6441b97e7e0ad2c7620e1df57c7dbd22a4d52b9b1cf030e40207d69f50f356c6b7dc0669ff281c11056a1dd68c08af13f51e0197a00de0ad74d9bc5308ac91b097f003222e1eee15ac296a117c5eed2ce4ce5c697557ce53810101aae04e96cbe13aa0604c8d473240a301f52a48e90e1f055adda5e428bb63a5fa50aebf674362a1438a78f34bfc2cba5a903c7af30f8c4191925d6cd8323c492f1bbc651b367f5b5e27de17e4b01bcab9709b63bf02043df33445ca2aa2327f1c874b6775ee4feada2ca73eadc5a941e01e194af3a6f68d14548913c54782a062dc94885e990f7ddbcaf096af2841959e36f03dea9e180c001614ddd95727040de627be286c48e3fe626f918d657f24ed6cc62710ac6b933e4b408ff9a516e79a0f5331b89014a8b5d187bb0c164b0c4fa9a3e96906bbbb915c5f828861f96dcb6ee4967fa113a9c28434e4acdebdc9fb09b024439303a0ce2140217ef700a4763d4d4bacaae3964b736b06da3a0c6e8b39e4db64992fee825e1876fb22885bd93aae824caef3a39cac3a53e152c9c8444bde427e2ba89568f823e2c290632f302963ecee8e88b3261749768f618095500fdf6f2ee02c1b912c80d642e2ec022ab2852d35f8f56fb7d345e5e58af70c8a90d6e0162e3f86257f12abb4097c63d03d2b1f6fc4687b06f907c9719031ce85a42eef3e8e69fe7bca1474308a97badcc3cda99a56f4545ad429259befaaeb7b7c05b793d5758a8108a5031943f8561cff464d7417678b625572eb98b37c769f49d47fa601fca145b029dc7c39a126c27bc6454338cdc75763ba563b88ff70b739e7e1c478111ec9b8ed6cf80308b3ac9a3b250628e70219fa09d2a8f6a0da46f2b8df81fb59874682382b4cef09e681ef064122d8daef2a45e4ee0bc4173b5487d37c931e3f7c03719114ab37379dcf6a3c916357c214a68d9eb9e77fe4a48208d3df7f2b8f4105eae5caff729e1d48fc0f0b45c550478a84da8f0d5ad313065bf63b8ac974b0643654fbb27aaa2fdd5b65af0d1db72bf8959f15dedd50a48ed2111c45e67c38f91851e73968b8fbdd6a388100c218682699a95e28356e14171a44e709590e3e6d4e41e07fb8e0e1d4569009b0cbb547cf949d5005b03fdd07dcdc650b88e366ad875664a6cf9055d4588145dad01cc23d3b15ef998bc86d1dd168d23c2832964eb89fe8cc8f339515bcdc724f3c799ba17e4e75fec47aa9164b0c98df26d1d8e85a82648afd4e5b4e2caa1b9b9e9803c9511afb688901873a8397993d330b69185edb4da6490811b7ef8f2c211c982766d4725b9cc88db80ecd60f089be7cba2e644db03021950061397760c40cf283d6eaf249e00acaab72654e10d24cb71f0601cc8b077f5eaef747be0bd0b1349918862808f8b9c74eeeb0e00cfd2bf054bd7d4b8e44cb30c2d314011ccec0d78f1bc768aade7bdd7f115a3e9cf714b26c75e5c611eeabeb60daf5ab48a481feefa39beca4ec47234c02e8d81e00e21954b21b2b277d2c7901c70a82483f1a3b6f973d159817642a05ae6eadd9a07f17920ef9ec90ab63197f416415145049b4d9f8f6dc2638614c874840c1ac700324a01c539bbae17411490159bd187cd8828864cebe68d385171e9977df44d8118cc63f87f3776af686d56c50f4c6288b874487673fef9beac81e68cf7ec3a57978b6e111af22394d9f25dd796f9e1f667269cb5ef3e0fc71245a559ea2bef33f91829fedf7628429e26942af0c31b321fe09af437299c7aef61ee0760f2e9e32e39c83fd39072956ece278df227c019c3a0ed89254923be30b677558c851ad6e1f923e92d66c36d47d441018552d583bf03550ae3047a8ae7777619cee2882e5332b89a066ba448f56543cb02","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
