<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7fe719ce7a76aafd5b7a59e4bf49d72bd9e1df160cf0d8bcc05672566a8f314833ff5919a075f3c80fd2244d24ace5274b15807dd583b501128ea101c7091e758d2c17b1f1438d1222b4d192722bd57b3f994e420658e955904992e51d7b85adab1d1309a9b43e4f4ebe85a98e475058fa8bc9b72f4e928f02ca99f3ba9e9d457553240c15577a5ef88add69223d3158fd447e371eee708544d26d93b839363058d4d6a4ba56e09ae105370275346057d405d2e4e3aee268741c648b5f6bbb4af4659b844fde9be0567dd28ba765ee794411335688c7fd72a6dc8ccf9397091f674aff4e731a420c88c4be65d820eac0fa5a035a7a0e22f0e291e74674a54b7ea3508b0b2c48f1cd7af8abb26f6bf1fca8c286790eae2fa9c0b114ea57e1c6c03801bae0a895cbb0e3afc4ec355cffc59500f8fb7fe7e74d5233b3fc3892499f38266ea9c26592ef702de95335508f05164c033954f73276d89b183b53be1c4749d4f4c8ede6f61726796f1fd40ed4e03fd912b2a3a020fad7295f867f247feabba7b4bc05f14de07951ea4b83169f9de0c4bfc43b04ed0b527928dd35f3548e5d03b2e4eca8d8032c9b656b3a4b9633fb3a0b6136848baac5c63c8c4ec88180c196fdca2ed468d9b317c6ca3ba58e011985717663954e26b820ecb9418d29a5bb761e105a8af64690746adad0860a4fc6b64350f8c953637025241cd2bba7ac44068e35921dd7d622d135ff36f276e671669c5c47bb087033b811ee88aa887886695f970e7b9e3a8816b82883c33f964121f69f620bb53a390d5876ef27908d9f32c8dd5faa48a29357aa65d906bffa1dd3d831238bfdb4be7c5c97df076cb6c4d43d9c74ac502d60cb36ea7d0456aa1b7b87e975c8e24762b1e9baef95a488fcac3dfd3c295ad7aab567c007315c3ea5b65f17224c88929b7d2adc8338390cf4a6e4778839789b961d579674beda9d5e098202b25fc32ab596ab18e1f296871b28cabefcf2c3ecd3e1faeb374f792b59cd5b21d9efabb49a0278b6731cb95a03d46f5fb50c198a29a7e7b145f6cbc5ad613b804d922afe8821e97ef81fd0e7be3c4eaac305e9e82ee09291c37ce34b8ea54bf2cc702b2526f11aee0ee7adf378997c0b7ce03f7cff98a2576dc2f0a60bf0e98d448a5bcca6a7d2a6e65e1a0da840984840caf1f1fe29c62797894751558a0109fe5785f51db4c0cc7e77f629b56b959c0d521f929255c7b3209514156b40bbfc24543508696df377a7efdece8dd10a83248a9e83666bfb7600543122327b5e3fd1a4e09043df2a6816c69c0b76cd53fa1d99717cf4172beb20ab884aa41d803a049f2264f4c7898205b01bb47c2bb52229ed0de7202855e08a5f77d3a7c48b1aa3dcf02cb5b7b30afca272c640dcfb1e57b92a3f2e31c167edcabf3afb4ccd2b4c1b397fe84d98dcae0c85f0c940f0db4fc49a3585241f0ebabeb11d44c7da81e65246abc46e1fddd9dcf7a1ab9e1d0035a88e316d7a9d96f7ea586a2bd7935633ebdb08d6b27bd0767e0ab1a70a262bc55bf6a03d9ed13e179152286c71990f74e49b5b706550445a55ad5deb48fb3e87a17f92db2b5f1b7d1b0ce09e633796714eb6e08b51d2734ec06ca0f0c080144b772b28cfdba58bcd7a46e0ff53791757bdee842d710e4b4e5b318227d6edaded7b1ac40c114575e57d87dc4e7398c1b588cab473f6e767ecec51d801ee7e87e705e7ebd5054a755b156c4e4494f4082c19f92f4678ce977cc1fc23fd0db354a40524d0186b183754131d65b093078a01d325b3e26e1729dbe946598718b651d0920e196ddd17bb64a95fdfde15fe32f083573e6e78a0057fea7600a271c16e8a0ac7fcafe22bc1aeb6b3f667c07ab13f5243fe867373bcd1c572302d801183d3881a91bbbf4e2e739215e61eda7610805874ff6bb2d3e681fcc34983073d4b2cd7601f04da6ab03a6e4b24e69b3c8addfe3a83573771b6f256bec0a4cf2d2ec1376ffa074fa32c5492091d3bc58569b67567c5dadc482b21921c7faea9d51dfb0feba77cc5bc58cd5b110044d4462ebcd2d67672cf94f7a7593f831b7e285927f301e5061ac8a8307ae0455694d665c48966c0745cbed4e46305ef0f25b1dc2ff074d2c17af90f9dba0bb9022547f774678ed5928ec3c00366d1d952811bec15cca7f8eed3f16b45a6c309570bc37315597e1e356c615601b92c8d8814ddd231a94cec2e93050b1c2c0a5dac4c25a25cbb42ab2e89a6707e72f17f93de99298d065b68d9addc39b8bba3d40185e96da8a371ae7b0d91f16643d22382f166caf8d4f65ac61a7b58813d00cc4792d1d4e7c2e68f19f8c77eaf7d6862992bc1cbb61d014d80c8bc61411c944e2d7157423cbb7dd3b84da1d504dee1f09ffdea7e422a6a52a198e2ff2639fe4a163bcdf64e96c3fddc662c8412986320c503b29294a887821d7d9ce86384c7f9d5f96824f47c2e86f47d3991eb79c170df48ad3e69f9da4d076dc5df3432e6ceedc8462e5b8ce4c3690fd7f0e06a03080def5dced24efe3facacf6608ba0f6ccdaa23e31916bded0165be5f3496dba49d812cd65c4cf80dcbd77b0552dcdf3c90ad296115bb3e92e039bd07988fc04ba8cea8927e143a342138b51aac9d6027dff774e5f2132ca1436a00f0538d9f9cdb464c3a69e0cdc0791e7838bff8656b57ae0d3302fc095d9f15478a1f79a096adef943d64985d9806f3e8f676786703231b8d1700b3ba32d806aaf2f7f4bc1599bff52c86fce77b794afa13ab717e532957cd1746226bec4e42aa84f6ad445878b88afa8746cc887d263b3e004b2e4a268969ac369671a89e054211d37ac447f47c1255644157e9696c9de13acb94bba1a4d3e2d43833c4c8a8398633e4c02bf7d7872366405f4f12145aef6eea3bffa16491c052a9e99124afa03abbdedad04757787cbf80900ee26a8f1416faeb34488e629d3f25a2d8ce3206a0580af6855a9027cfec2df71ef5913d8452c737aa7e1cd41d27093fd25bda34ac27e03342e6fba9aadc99cd6d209addc2329ece846d3184d8a41b6f0bb2dc4a77c330cc6b0281ef103545e77874599bf91cad2aeb3e3f9c2c939d086cd2a1dfc43b68b2daa216e2cafca04494f55a98438b30ce40d1363aca91451cae9098464da3a33a38576f97072917f28e6b9c82c62fd3a1cd020c720406359cc0a5a83556971692d4091f25ca98bc0d366f2d3e6c505c981a6c1d02eed79ff121979f5767accc7e577f661c260dd1663c5099f16fc85fb93ff0bd32efb79fdd721d4287abbe5274360385970e63945faf7fd70d21eb96f0021c625f5acbddf3a5cd3a7f48cff24792f16d7107a5efeab7c1d85a43e05bdb2b6fdd19b17a0e1c0cf0be5b4a4970f81c403d80b3b23ff65d3dd12f5f068e429a1808fdc04204b4200938bfa6c23642f204ef950b01681694be8227203ad1e8e65ad1fe77c6a5de63a435f5816f97e9573f6712d062ab67ca26d21cb4a45a9182759e6a3fa011e2644537f31501b3457f0213abe06f6cbafb99be5136807420dadc49a67eafb6ff0429d66f71e2b6cf9a25f3ecaf4e05be3f74f262d45a864fa8a4765b196535d300b77f19185d154a4b7221a24178e2296f60673c5a807be954ef610fbedb852b013f1b5020087cd71512de5728e626603a25f68e41fa407d36879b43bcf1337483d6ae07da79bb386fd0668e018521296758d3d900fd408a767f5510d656a9f6312d27cd96c32c3bf6dd56710dc1f1968f74df0cbbd9d05196a6060da49374d27ad2ae5b8594423bfe21c27fc79b68f6e058b5d8dd033933e3e4d9299dedca09ff2a7f28770b5a2f8a65444ae344ba6c35aec7118c854e0ed8c6e466918b3a8ef0ac84081bdf8c99fc9268b9e66584c90790dc832a7a1f53540a753954aba3bc5fba1beae368bcf694447d01403a28ac709fc6ed5ebee092e7b20e104ae6e96023c062b295234c40dbdcc067851c30ee5ec75fc7783a8bc33ac0f25331bcfd5f769c25d25b6f63d99f498ce5ef229a8267a47c9b20880ed9b4591d95ae463840c17e59bb89fb50cb567715c0dfe38d78774869675e7335f286221a484255b7caffc26aeb0b02e63d6039dd8227483d96872ad1a519b99a1f6b55836d96fb2c46ce1eece214588f11f213c47cec7112e5a86174115300d7663f9311ee53f4dcc56f180ae6e320232d2b4b540f77f287f6b4ebba8a75513f1fbce3c7ddb38a5c1872fed1e5dd15944ba72b0f6131490b28ef9250a33f407581fd83b91694f8a2efd0e0b7ca09bc813a5c09c044a5a86b6c0652c019f37febc5da471b998149b9721e2712cccf5075270666cd0960dc2831bda31f88e6d34d587c887f378c022086b97de48ad3b52a8fd68ee403ad724e42553630ee11d0a56c06ddcdfd71b37450e12ecdf947ffeb35659d7e7be02b4fecefcbd81477bd83feb2909c48258fd483cad34a0eebb307d8a859798497f08432023346737137df23659a36ec6eb93606389d942612640e608de39be2d42b8df7a80fa2a1fb6be395150b7cd759430fcec4cd0cd1a6ee63e0ab623daaf24e9a5fd25e2e6db8352951a93aff16661d115be28a46322010972c539ecbc96db6939093463867d995d90bdce9cfa39dcc577361d6ddbba1a9296cd2e7cb72d9471965b73c49ad911428b08c72b5743067ec5c7b7ebefd1d551fd83a0ebd85c2399c66ff4aa7bb6edb512d74310f4fb50df1eaefe243c861ebec2be8b58c97f45025d11293933b4772b2882a28238f0ca81518df4da408a906516b08e3f086d3a90aac4f91f816d13f4b72b6124d994e0f54633f5401438e0014d5a0984ee849e6c680eba5d51ecf54e5297166d53ceefc85f1e9147b63d0a6e54fea644f83ab7c579c0be9f16bd404da4f9e6910dfb8bfca6cd6f4887b686f1f25ac977776433c0bccac382916cc96b92b98c70ebd65c6783702702aa085611252cb9b267dc17fdafeffdf32ec0726a16a583229f0f9d8c9a491593396f7938cf269cd84bc1063c4996c51494455d42cafd8b6c8b4f75ce528fc49befc3c98ec4b04c6ee154357e9dc8d8e0bf95dd5fe53775da637083799efa156cf40c5f13a571617e186238b6e0dfb59d3da345103993ce5b33d8db5170b5fa28c9ac06fd478e05233b0bd011de3a5e214c2f31caae6c72693b6b38c8adc3d00c3777f3bb6ae34a90175e9916ae598d6b782011e2fa65c6e94bc3452a3c62d119bc2437969f5c494c994769518f7a9d7e4c864d3302b0bf4e28c0773d295eeb7eea58432bbd31bade4f2ade07e5c551de4eefe0908c474765e1c991a76436df2b3de28c8f4a85d4ff4ba52751e6e8110a7c663e8029d6285c18a8680b0121b283bdc88823397aed74e72d187be04e5b412125846903ded400d6f1a6e00f6207cf305726683e520192cda63edb41c00581d9667e22609466be43e3e2f2e576c8fab324e57902cadc26ccaf79c19f0b4a84ac9dcb9999410406af820334777c8483f87394ed8dd850cbdb27dfa5d04f64945f362e5aabd2595cab094facaa319bb8ad70ab3cb4db419ac7ab53c7a303cfacd2c980c6bd0dcb610e6ea364c3cda90fdc618f0eb088e459b6b9340da1b485053939082841c2ee173ff6162cc3d0fa35ee5973ea0f7c90001c71861d199d2e8b4ce92c6fda98cee8d566ca83b004954a5c0a6bd113c37ddd8df591d1291549ee5dd2ab044adcfa94f165b689ca87b2cc69480866baa614414c55faed5b8d2cad56c0030dff665b67bfaee83030173b10e251ff1e49632948bdc965029aa843ad04211c5beeb705c117b175b61b8b78202941c5822e672dd7c25c22b4a1ebfc7867b23be38af7e7e4314552537e698ae8e997cfce68b7bc44d64b0cb4a32f42b8cac08258bcd1ffc4f5367b3a2806e2862a11d48fcb57d219c2638a09c8defeeec45e99b731df959adf43e421296b254a2f6dbf348d40d04460094eaa9614777f2b8e8e5111ec5381dcdc6fa8defce336bb54faa29209ed6096c9a234f8395788ac91af85914c78f263a1e2ba522a9023a128db3bbd538afd6b1272e79829f5273adbbc0bb8757a4c46072335292a99b9a60e52d2e29f7f217e56763d5dcb1d8726357a7b11813f7e637664cb0504a0fe4f7686c489c042156f1ad81ba971e5dabb5fbbb56ed9b8395220b366299c7da4eb78344c4eaae72a6a44e8d786520f95fce916e65809ddc99c31ed5dc64481afb7bb8607f852d6fc7bcaaa3f30701a218d8336858bb7043a3becabda1ae249d33280383ad90d1e9b397190ea4ce965bebb93f757b1a96adb44cf64619d2410db30e0ebe920ad22c62d70fd0a7c0363302082bfa0016142e9eff82bc3507dc56419dbf2ad4f454611a06ed7429ea5e7cf1975e12b94e5cef1ee3832ff215a022cea6b877030fae804d9ed3a8db10ce3d3473a0ad2baee37823e2e7560f4e4cc72bf0210489f49a15d379ddcfce2c6a972bc2601c3b99cede8d32bd0cc982aeefaa991e1445183ce6b3888fdc4d2e810d833599f2c00dfdd7edd17380e79eb1b884f71e37c4856b7117abfc673f6583b50db230e81320116177f8a3cbed84cf116198a2d4c9dbc53a10d04e6e9b4cb4327d5e098aa8caebd1a1680ae672d1308c773af69714e2587daeed54b47d45603cf2d31a245b239e51d4de893fa02011de16dcfa0faf1739bf41ecb4d29e3e6faf51d4d86b6cff5d9a4d51ed24ef7f3abe3124f45dead9282bcd5000fa07c7b65d10c18faac8cfb8b3e0548d01f5e1ba73eb7efa524d5a2a194060dc4f5306b38aac4cc5377e98cfe87c601d4b7d50a9cca857fa819171a1add2bdbfe9cb857256f24fb6b1885f1fd822d47cb9ff4559529c45732dc882140e49b80240e1724828db3fd6130442f2f744833b731cbfae914a653a1c3646284eb705a64b528f416b7ae62e5081c262a4b9fd13185d9a7bc8d3a598fb623c88029b8349f757bbee4b616a0678034998bc96b140b1a0f703a07e1b075b395bd834c40359d551bbd65eefde9fa9df1c178384e7a8fe93b404c4a5a35dafcd4ca568448bad96d262061b0d1f7d7e7003b5a02e9094c367b7fc5945a82ee40baa96c160ae4e8b951435584026d5490a3811016db6bbbfa24d21d98f98c99b9f0ff688528b921bd3d1e93ae7e74660a0cfdc7dd685d016305f2ad8500f92e5deffb9ff6c15f1d7eb359093a73309110ca24ee0f1ea1b97d709444cf4920b12b60d970ddad2c6bcf4cb2bb3f5c7cd5cb46b0a8003aed9eac899074435fc6ca04bb116e5e82e31bb085ace5689fc456b695b4b018c6844f71881133ba95b061d16c608bc612658726b89c3c83dde9f156a2cdbe7958404537dfaa9c78c198aed49a01fe3cc677ff6104c1c1ad95e3b0678b3e6a7995bba7b6220c1b1e22d87d89d803d16dc3c2662f47308e82ef1f25617552147d9faafcd24cc4970fab1c32765eb8893c8b546c763dd7a41091a4607b98eda226783e6bc70d435933bfbc583a734feeff48e03ed91d15657940991d8d4a80997c9b59e12aec9a8a13a30deaa379a3af36fd54f1e050afa78acd7eee662100fe0454be8fe7f054c2ffc18c1be88e0ef969284dfc9698c3540ba452e7d87b20df7d21ab89e376a9ea0a833f68bb7682d385574933010ef695a961a2f0fdb7be18829f0356be7acfb9f2941140868b34eb5a001171dfd14c8ffa932913ecfc5c0db8da17477206b474889738c4202a1a08b506f2492172c4cdf01aad12bca73ab34731be13316c3612b7c2f61f4d7c4988d2770ee35c968ae3e423ca863c0f107df4631fc96e68d557bf437e3e73139405e07d9f6ec6a28c24d74636d8716504cd784c9ffb323bdb586c1a06318436722d10a3ede47dae85e844df6e874274394d1870c47ddc1fa4108e170b8154f3ef8c6657528ccfd2522de37a4c9b43ba0ff62bfdcbb0e462c37aa349cf92645f62b72074fcf3d7322e559af8e4e87f1b313572fb04014decf2ca3f0c65213378ecbc8c0fe041f3252611bb6f7ef1ce70a57494f7e84a273483e8218352cbb4838af8dc91b6f6f2e357d67ed7dd4a10c873d9f8e64aa4547ea22201717f9d3f7725ade8235463a59179dd84b4f94d81dd7560ff465abb631dc45b8d163aa7abcf1e88c6b0376fbb69e2ea75f4f7167acdf5c48c9c19ba8ab0395075f0e5732b65aa85d62e14fba6aef27961530e33a026abe479c36045155dcb14ec1ffc9b1cb1aa63e31d407c793a7a563669616156a31333f7a16cc6657271a2ea5ba45bc72d8f50ac3cdf5f9447e6e4cf6cea594aad69cd6c4c76fb5e1cfd7f62747211277efcac589706a64da9eeaa2cd71305340b5673413ae06372402b063288a139fe646b3ba16c11be16d7f057d019f43dbb86ff7c36203d7208843e6378fa72496252243e3717c341f36f5c3bd25b7ff6c9e5e03f6702e521d5687ce8a25537c08caa726fa31a38b757bd33f8ec684200c436d264bbd418595ab2d572c5a7e1771f4fb630a311b2ae45a2ade1d03706f9645e5fb3a93890dbf790019f84fdecbb11039305c66d99669c03d79a80bc77d5a97f525cf2ca6fbd0ee3f190fcac14ad573660a60a57f9f31fdbbaab856b330197083f4eb22ea64ccf0a3a5f2a95a28b9aa6dcf10ad59b7258b92a51262a90d1d322d5ea0555898fc67c56de209229b12999c46a3997da80779dfb7137937e170b93412239bcbbb0e318350aae6f143a02a5be66892f0906e012d9bbcc09db70632537c9008795f69f871fb47c86437e3ced0981dd367a4175ae1e25febdbd15c8b76ad7c67fd977dfd1d0cf1e2b08e032b35ea40fce5aaee647c5d25d4c483ef45458abad8725dbebe9f8428fa16f517f3d7ae03af7b3396b31dfe514ecbc22f2fd0eebe6b19902894f2bef398059e282b034549fa2b90b73dd5e24c07bcacb784dca5026d341427b3827abb218030d6133aa09d0ee619eee1f40128d26842ef5bdd32260974ea9e3b1e18bb7444a8d1a8fddecf0b81e741a7e05fe916813c445e60989413e9e55c26fa64bb8b4f1ab26717d8f1ce51d5fa635113be2d2faa81bc28981f557dac1b0464a7a00d8cd3a29d58a9a19478570fe1d5ce8b277383254bee34ee49dd9fa3195a836f366892147be4e14dd9a605f3d3ee5f897e868492a9f55aaf4260d005555a52d2f59345328602112d594343d9ff57d4e27569c98efd4e06bfa7a62ce6973b7133bdf8529401fea87ee355a21555184ee4423c561b8ee993b7a156100d126dd3d81d67215302b0a0b3e0e1f3bb19b402d5f6ecd7a27faef47ca0438d25da489921f1449c426f4e9d7eae828e1a8906fe238d72fe2851b6559411cac0f68fe7b4ccf76d495043290ecfff806eabac90e1c63138a01128e80661865ce1995cbd614413c0eda789630452145b9ac1c694e3dad272cf0d4fac15a0adbd3cf1700111e112d2da002e8ba78a804c051def748ac7f38960f11284c877a54d61e77dd90aea4c6561ae40318f6c244059db0d076f0ead69d23b64ce409be791c6db799693b6af284c11c5101544ae2fb87892579e24caa1b863d9d5ddb4ca468d5115c65bc4493312e40d699466654a645bfb8517b53b4f795be0aafc19d14e39f32b5ce43b5b41d0cb4e9fdfb54e3bad3b0d4a787bce569846aed43986ad871e3cc771ea039de1827dc187a8f02247435e196466d96f78b66649cd62c806d5c990e3627b5925d9c92a2d3d3d02bc5ee1cec00631475b46900f6075a08563177f127efd25817f9990c7aec64f2db4a069db14fd1de95c8f5f496194a37efec1412f68c1800f0465045b51a855e85f113f67d9678a0a2ca92f9da6357fb1b6e08c858002e1ce764fde9b45d560f75c20e5435e32fbb84776dcf3fc5ec314e93b672a31d931c3bb0c37207a7ec284b5f05dab27db2bf6cd2ba7e0dd4d4c7315fe6defafd0d50e3c34ff047b9dafc6f4bd22dd8830878b58870e8ab0e62c99e906a668f48e40d23c4d9d3f3de959c2bc05bbb59eeb4f9494d7c62e759480741d5c4285bbb4fc07540db19f981e45ac54e5ec5eeb6e67a00fefaa1ac4222475fa878cb9cd2c2fe0a578c24e123242963411bb0b0e09356a3c0f8ea7de798b7d7e4615af26ebbff1b8e8abc4cd565a32ff29dde1b9a567632b40ea2fdf5cea3ddc30164fe760892742056a6f34d0c703fd02af807a2f17edd22d7343f8d48fec80973fc1d3621fb48c8fe54829e3c6b5a711dd6701ce482a05e545766385dfb2937bbb34c5d72fb218c99d4ccac3df7a3a82add2ea7e031b30013723f175367196c83f0cc81e5a76b3fed8b8f22bc504afbeb9cf6b7203af4843588d8e08bd6397f4f33f2ac9e8db06022b619fa1043ae8258afd2c3104d3795912a4a451c3db4d9707d66c70519350a55a945bace7c1c8ae94cbe33b4b953e2a03f2cac0dc9b0d1fd48870ce9531174bfcfff8024cc702701e3333dbf7a9e07c1dd3b9f686712d45f8b09f1eb5e2dcb516a263ddadcc4c169683a0ff6172c33377f6658af3848b625b3b828e62d77eb007db47b6a18bce42bb6b59b2725b3979126cbd6bb2c9890396a66072c2f4c037d556aea46b0c3e38e4edba3555f2af576842b2d1a0e59f6be1611fea292cfc0c64c306d9b2f4f589d5172d2f1de943e9d17106ac6e8a60b46cc18b52e3641ee77c50e04a0410a0258ad1cc95154fda54db5aea6dceb7f20611604fcfb9edaaaedf66c06d4d28181d33d5686ce491d439cd222cb2a2e32678180fbe33dfdf4df7642d299903e3eb21ece1120f046e7eb826feeadde9aa8fc768d0bad537eac82aab8bb752b43be265d30f9f815cf7c9f191cdeeaea9b8b8c6c6ba71a85c921ca31a26756aed2488e9b4ef8cd7b78e7c09f80b9748cf9acfa6081a38f91a38a219ea0b57c5cca4b69d411c2bb3c9a62f55e1c7cbd90af884b78685abff3df3c7296f38d08d78d4b681fb4e8cb0ac3ce79fa677cb81004af764389a4da01367dc68f762d1c1e0d19f4bc24b4ca55e51262e6cb8720878b8fb882a0149c59dc6bbeee2068034a9b1c9e9800e486b2187ea25648fb78aae790ffa44d393863b34f8c962d80d01dd9c5cdbdfe7ad1668a322e0c1853354e76e2fa40ee782b566b0a29a2e21ab49ac6e7bbdbec6917c54eb0ce39b29fc5875aaea0c06979d3db0ba607133c51cbd80b31bcdf2782dc1368941d273ad498f9bbe694a618403cd3e500b17b918d26d1ca9c2d065649c78fee0c0a802fc7ef98d743fa8dbcc815b061ec02503586fccb0a7642eb297ebad5f70428b207b90b71d9aa5c73e68df3728399b49f6908520a78513de94102bbd5bd5f514c3e8be9c92955124bd6384900dbab47a992353bbfacf7dde47ff9c6ad0c35a635cee1d6d4ece717cc8103d4e95bfce5f08f482cf2a38d7a36472b2dc93e4b325615dd1e7137ec495061692547699581bb8e32c19722f2c8355811aca7c6b7666b202f09a14410c4001ff8de02f30f7bc5c02d1cc9e3f6a02bf12fe3950fbd65096db601b6808a354eef8325e6b60d5a7f04e6772dc2bbcf44d699a71e1805ee36e9f350371f5bddae333ba49edb24c19d173275e81558ca2178cc16d8305fd0bb236321ce29cbf98dd4d1b094528391066c07c57c2306ba3a62e55bfc1340d4f31e5e7f494a5e60f376c2c3500d80e993958a3253ae4b14d4bcd55df6b86246e2bc67cff811ff379b870865f76c8598c816115e6a47009148444354dbe173d69cb7572754312b66aba4b490bbc09d25cb7acca786aef1dbe597d6c1cccaef7832844fc2cd50822cfdfac79d8ef7e14c52d0eee66299d6422de973b4159499ac0c6f0d07cee5c59fcb700f28fa8b945d081e315490829bf617f1030580079988183be8e99d453fa4ba5a0e878382624e0082a72039abd4aace21d2fb4d0a4fcce80e8116bdad1ab8da89918f0f3d375154cb2c4eff8c804a9aa2c710191411de21f0c6890f7f269233a0e8947773c931c8c9ed4da32a5d6dfaba2292c17dbf5fab02000dff0d14952e5247717b88345e1348470ae532ca09bce8fdbcd20fc30bf5ae1cbccff3149c5c1b748450e825126f4800b82fb7d97466a5c92fecb66cac8fca463391d753d1c7a808b4ff7e2665367ff075eebd9349962d37c5e39ff242c434976c1620a97c86671a2691251f402ab02b894196be73e4502d6a5e26b90938ca006f603a72bca44bbb89d219bf999c937f86a6903901e89543b5d3196732dbed29b9b97eed193afdbace950825cdb35b0c3f31b6f2673a12416afd16b1762c1af95a2668f147c3218fe72573e0d1841ce29450365c4877941da73897e6e31e29930db0fa80576b8409a4dc33aaa34065642a5ae6b329de181278ce2d8d3670c455288f1bf86541f59e4233dc3652f71d53c64d904b25afdd0a0f388b7131eb64addddc03a10727d1de98c558ae7c6b314c86422d853050eb05f265b4ee74a2e793a1608ce9d07d2877a6dd6ded3063f8f4800e860af15958adc4d79c360b79e4b148d986d0b216da7152a09d03394e089d55ae76c371acf7c7229b79bfdbbe0e2de35afa56d75c4da3af14369219670db5439d96d3bffb08e6b3ff7cdad650abb24574ff3a65e348713c791aef85c114d52b535417fc767b6932441daadb345a1c7ed82adaa7e63cecfc4b4864b916a9599801bc4fd6d4691fcc0d263ead8f3553ebd7d598a6ce491cec679117098995a2a9d3b77238ca5760a791264d166a8029a3cbfd4ae5b17d48c7ed1cac703de7975acbf60419a0a9acb73bf995d726244c53c397fddcdd2b91e3e01ad5f043085e7cef671ee0808ee60d1b3183d6659afa950bb7c18e94b7c615f54b3e0a1834e9a6a87ba7f71e41c076a11ee06b3633451f093036bd35728436b4e65b4706d3e4000d1ad57a489dbd283654afd7260c88d229d8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
