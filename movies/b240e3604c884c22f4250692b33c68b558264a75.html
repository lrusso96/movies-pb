<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cd2490a7fb080834278f1dccc5e50f7c5143705d477afcc8e8f530bb7ea79ebe390540a32575b34c59d36d9829e43c7ea52bfc3dc770539a63d81c9fbc13b0b253cf26dc5656ba97cac736bdd519005ad168979352db18365e52264ca0e55455723fb8cd76ba38ec2c00e388e37825a79677e51f5b85d5b3875ae843c79ee1963795b757e33f58351412ddd4c5bffefa5a2e434ce3a954b7b1eec4efe0feed167a147632b60f1f9ff4cd71349f157ef593e0166fd156366107c0f1f302bb697916765a48676a77cd4887afb47e43e1fd13fd81d3a769dcfa87c03431daa08a7d66c5d5a1c1f41b5d1bef929be384accc377ee8efe538750cf6c9fb495cefa09764cf6fd62a8cf586a6d03fc93ebdeeb3e4f570ebe3404da1ab7ad3b2acfc8092eaa955b1bda252c82083a287453007ba1c31e2fc708a6432f2b2788df71d340cd0b888a15b30364fb3499eaa31d473c21c49980a3a9264b433286e4302168683015c5e3fa330457810c5783c657249d0a583f89ae918035409947469510dabf020193197cc83eac83b73d1fd23b47f7387f1fe6294509b51c4af80507c616cd0d2006da635ef9b730b85e5fb3d95eb0bb88faf64cbfa4d5a0f17226906fa06166cfa3f0fc0b914557864882f4619d12826e5fa67fdd3aa91719e16c13ce5a7345198f69dc3eb5ec4026c0a9678d7d77efd1937abaeab9cc1539f748827b7856ccaa53df2bf923656307a8c2aac8a2f5d1a7b8401b0dabdcf6f7488fdee6ad06af341e58fad902e0e575e1656200ec85f04ca4a168631eca9406bc854d6c477b78c9351deafc2c00d717c68dc0c24c28d040c5b7cf3591be99d4a687ac9c914134086985dcf640e9bf47e8fc260a507cec6791e8bee739d48c8b0816f1c8dad2dd4deeac7d5092349b0ab18a885c61e2d1afd4cdbda64f99475f6fd020494f975d372a5f73e90518e358e9b9a1d1f899e2ae99d4afa1c81741d1a5089d4457c03686aa8d3c7a5cb350cd163956b7c4e5d8c9e978f7f9192e2ae60cf43932e2d4c645057b2e3c13dab19273ccc25edcea606d89eae66f25194c1eb7b5f68b4e66d8aa01a471a483ff64078ae77ab5c7a005f947ff64df89a920b97b0bac603e87a7adb253ca61463c95272b0ce749738a39613772f656ea94648e3bff6b42a6be136bdf3b4dded9862b4f687212b368e6ae8fa53f7ce5e229d0dfb07739c54bbbec4656dc2d27402818588116da1f0ee9c5025861e35d37fb9d2b6e5435f19017fd88aeec76b3a146583881604d34494cb52a7ed7dba62a97f400aaa9493245d75c48310357653eed24f3c6b5d2beaad8dbf1ea8f7ed17c752d9b767314075f6a81387fea3eebf7b89ad26a59b66c37f48f3bf44f527911bc1200089525d112945890db43c2a6fa80187f642ee7e78aacca496624b7e355681c351d018ad6c4b5e8d53805d017b34f89ae5308c78e4e500211132e619b4aa9700eb5922190dc309c2673337ad94f8d9fc729c892897f34aebf98ff76fbb5fafd9abf18d9231bcb97bdc8bf54a726e4c9c981c1b8706856b54b1b8698ffac0b46cb5065a20d266326300276db8ac6488430829e79e0ad2a9b2ecb4237f16a2e030b33819551d010389298fd142c0ec2519b50470a16d13bd7223521f0877d31eba8cac21d8fc41c35f24b4e1699fc91d6695ead698c371952922f341e8215dbc500afd4bc309b7680b2884f18869e64052cfe6d2f409758194341bf6faa45bd4596215298168d3768181ff3190103dad440247e977f48401fbc39fa94c1e0bfee0eac2233559e869147dc18f88c6a8f600969f52fcc4db42bee6dc15dc89c334c37d56a513b761e834f92041628798e98e2b9a33f7b89316db3f4815e9ecfecb13b3285b14053969906025c4018ef50d3992b946955af3f6e04d510b7d4046b2fc6bbac3810aa01f7e3d8645325ac1d9089cf2af917397f1fe61671542d3577d1a219c9aa6219d3b2c6c566287a213b30e007bc5c17e120a46cb99938a915acf262bfa83f164a4f3720bb122d41fcd8e9bfaa343b2934525ec1e2a37aec4983d9b03c2aabfd716cae0b3880849a8b431f8300eece3355af13be2ef0b7af1b326a438287130d3003567710324a49b781407d873cb659063740635eb41c45459fa353881c47b9a068e669b380b7fb8efe6ee54483d1945b7ee1b7143879311181dcdcd86db998e21b3bb15ac93e32cf129d459d411ec7a0f33e38c068c0751f7b5a579690461bcdebfd82431632880c842cc760ab6911c8e51df51ef88d4a0c891c65f399b5c49c90c3f1a62d2d217485a149a56764dbac7583db23d49d36ccec544d39afa1196289f0507a0183ab0026ec70e9b3f6512c9d44d17817f46de7eb88fc9547daf3f2333821a90076fd31cc3724feca04792f7b5ce0cafae3f52283ecdd05670bb6166bc9e8712861f37361611332f7d3a7365f72084f534bd490640f82e92f098bd60d98979623600152f0267d1e2d2a6e3aff5d73ae0e41d6f0597b139298382319bf28150f6fdd5f79b4d02b2b87170c6e38ee3bba70ded2b76023e845351c254cefb91b7f7deb7280f63cea6fcbf9bee4f14e279f02fe2fd740d4bdef3d12e369d77db86e6fd1b698be6f24ceea9f41fd419ea4bb5f32e2197bca83f2080d6904530291493b6ad31543645fe5ab08340d2710d93b1a4fa018dc6a473f5f7c35e106df42ecbde301c493f078619e1f3c5383988d3d7e2f3d0037104e05a426ccd8b44948db82710c8223d60e854fd3c9acd13d8a84163097a64a56a5f2c7133d35f40516d0d2d1d4ed775b8b86b378d28c848e0aaae5598d7b4f84f808d02574ab6bd76fe5a7c136bbe005fd1f1c63b466b56d02b7a32b402353da9528088de5d2b03be581c34a699e2d26aa20aeaa06d755e1fa2446322a4752320bdb6140f70da1514b0eb0609d21d51e9e190151cbfab691ded13dfc7356f6a9a478c131f228b3731330fd7c8fef70abb6a89c3f07d7f64f274f94161d3f19d1c604768a9b2bcb2bd8e98f05cfe29fe80fedfac552e8087d3c70ea50cf2f5be1f36dac9ebac3a76938900b2d39ce55ba555ce7f7412ecbc0191cfabd9f17d0b4ad28597b732ceead16ba8a842d5293646bf65f8e9576233946c01d57e7fde8073190c75c1e2216225dc2e7408eab6b69e7e35f1e2d5a1549fbf05354999c4ab6c34f35c1681b1c6aeb9396895ec0098af5092d4d7fe0da657539194293c73cb16115770e5e6f5e939685f0f04219c668529914e7d741cf7ee406f9219b531eac90485611cb9e5fc83f02970b55315333489c0656361470b8ffd75adfa5f23c0e7899512a3671628678139478d783d08cce30bec7001d587d14dc1da619c7fc1ae861c042282c102c667219718c318e7457b07a3a123ce055d3274309b1283690b3549a742564ace812f1619faa78e2ba57c341303aa0f11ae2451a9fccf98dd3c0639e19c2d523bbbdffd398bf8a3f811158d6b0579f9d8f05b0f033efe5c6af54b5598f72e6600c33fdc2b1c6fe7fe5a027e4203342270e397a910e4ee0344daed32dd91620e7665c9949d0ad5e4e362053453648d25927851923755427a9322ba7d700c8d88697bab8c00fd05293e64ae75207d75ee4d6659c1a1826a7e0a77506a04597caaff163edb20baadd26678beae2d86e37b4d56dc3ad75f2adbd52d27116d78c6d97d6932b6f155f8e6e432322aca455516d31a582cf9e41b03c20b36af45709558c9c1a05774ec069515deca7f7e6565af7f2d8098ca8fcb62e49ae14344ad601f51372ba4b4d27cdcb0031396cf84908741d2652f803fcaa8912f69838c48ef6e3bccaa8fa86f9a0d6ed4407d760c6a91b90460236791fe26fe51b4ea8a3098f87c573d1dfebd34a7fcd481f049b3d433f17d97d745947d067c28ec75042b8ea3fc1ed940d73546d4670090006c37cf052f35c15c8397e80b670ed639533593ff328da66b9f9c06cc6444559e33579a74cf3071440280d2317b6b9db8f9f9b031d1821f9578f415ba86c5d7b0d623f54150054297b3729b3792c436960c1f42efb0cf41c0ca35b8714a48cfcc417ca30ef095d47cc2184f23027f4894da760dccd87c5c4c7136cf07b2bbc0a086b6a1d772d401dbcec070a2b7d235e23441fa8fd83a71a21d405dfa24ce7cb70baf8a28cc7f688d72be6f0ddedf47e2776a5fcbb158408c47b4963d82ca6794ea36cbcf6d0821a3634032a21b322cfb10a6e507cde8b79754b71529cdc2ab318ab216dfca70453e99dc21fe7b0b99d3f7efaeaefcb2ac37cd1c40e07c01a3629988cf44601c332f3ca840274c7c69eb8cb21be5c6f1b79c832cf069e9ee3079887765b59b05d561e1b4aec3984bc17701a187148edbf62f08226424ca4ce03d7b99cbf10ed5d9692589625193f4354b9e0ea8290deb4875c3aec545fa214f44956615e911e58a0ed769a6eb7e4fe5f269528c1c1af1ab77126784febda01cf12354d323570d221527080f841ac6fc9929741c29aa14d281ddbfb4b6378f4ea8aac84e63823a43f3fa7061ba4a0c977cff0c3129ccbb279a68e48f740b18fba96dd31b3dfe6f64fbf5a5cc5704674cd8eaa8c6afff57f3bfba83b62fff2ca8f5197e5915058a3cee30c795d71f5591adb06f775a21458fa3b323e8f9907cea87ed3eb3d26b8253aa88658ce6162346db2a968bc73f8eb35727f70c4169a252336c23453d9849ea9ca28887218b504f71b226f66a1b63f47e2cbd2c0b7636a1cf6d126690dc77f439c7426490552f4b4362808f4c6073a1ca1f2d7d122de42db103f3f6eb0fac78a19313946833b145b41d58ff85648bfee960a53e61afd377d282de6bbfd629c88953c9e37f9e762ece4e4aa867efeb32aa9d6b94ec5336c7e0987ee1e8790c4a99bc4de09e43b1479b35599c73a5314987c5f1ed71497d4412fd7f5a385a156d187d897d27270d60df3bccdeceb46729b08ede811dbd71758485f9b94d8c637dfea2f4e312efba285491d98d94ff81360e773230d36edfe2c3fd664a9b349310f839c676a096ad0d494750daded2daaf05ff73f69fdd6b7755b0b48fc4958d79135b7d06f26527ce4d61727a795a24fc058816b9bb75bd82b6a64bdbb8487b01ce2de669fb5f54287b6a979968fe6e0f3b63c8ab97d329eca2f37b4705695e26bf3ddbb0f7be268b2d16bc28eb7c8ec1900cf1567dcf8f57af85c243c65406f21ca859bec59888d3a6eeb60f4a64f6c11e2c396c77f879e04aa6eef72d165ac36c731279b71fcffbd718df46a4394dc8b37ebaf5e4f56680938cbed374a036d1fcef1547c786e70ac04bd2a433ee389f77a7f2bbee6bc80960a6b9d72d33deffa1b71b195c4853a68c449c22f12f23cf8e3d8da00a6a273846f55b5ceab3147cd53f7b6486f2fb2d250bb14d582abdab972ed38c7772cdc633c4c8b53da30f97f129b07299ae6a882b66c6fd71022527fdfc9c84ebb06811178d2e57df21668d6bc02fd34778c3efc62347f5f5e63f9a34d1e79e42d4ecf7e3906f92d75b8cd99eb7ed285f369c3b2baa9a5d5ed1d04b17f0b24264e5e699d78f046afc26d2a732dc63408e0e7ecb9d5f599e9b9b5b435d6a6ee878296815e80aeb0a2b636741cbc3396fb964b430c886a11439dfb854d2747d7595c3cb77ef925e1cf71a72d30e94a9fafff6f069563a909e24e6075a256940bafd4a97abe829f7d093747804f4175b6ad0f150d5e4c78c54beb8749f44cb84fdcd9cee45557e59dd093a2cb0bba49723b149517e602837cfc01b2524d4c5b996d41ca7245de884611337d28f4fadf16a4e016d8a8c7137e59bffdbddef8620bfeb7d4c069e5160da5a476bdd8cdf413aa25c0f663bb6d41bb5a5139815d65cce4d8c69704b8f09b54a45ed720781a678cba4436708e1871b165ec9605cf567c5cac5caba638c907c31e862a8cec0ba085a46cf399231cf0da6f73a293fc128153e810e2038205255d76e8216cdf1e6f6a995cd5fa42a5c61991d8fb53a08037a424692d7908c5fdbecdc71f6f3e382fac9ac5027d6a778cb8542468e566d626fedd64e9ad6e20a8ddaa16ab45d6dd268825f8364e91a26b7374ea5700f867a28f7d9cd066a3f087771fb190cb363f266617a80e61f9aefa8269793c34d8393507c513c8664d4535bd2da43d4c2a2c78a518c275c51c2e6c74879e721b7f1ea820587261e7a2846bcac31a8252fe79464a9f3d4f56a97ec8f7ed3a1e6436c65df3da4022c3aed5bab663a744ca552e258bdfc2cf9f0397f1c744baa799d7daa8eeea5da54934662e706e79224bc8cb4c7c1623e0f64fc4f92605fae1f691c659088cc8a790173f0fbff9ed18005240f3eb2f00ecd6bebdba7d74253efd5e0f1f24da08e834014ecbd1401c9eac2c810db7de839d715d59029caedad3f20e734518e12c071f7cd97045f809002745d85ddc46a6f96b3f6f2e51b0e4803a0b1201f75b0f38a792520da6726d7a6cb22f109acf0f3b8e1725db96de018d62a940d5b9b2d0f2d5c5b13cd34f210e767f3033d7f6ef87fe1ad08bb0153136bafce2ff57ff92c91d9d6d90c1a1d312495a055b82870e3d2956279da78ec7a3e133bd9f0d8d3387525cf9a0c92e45f3a598ba944cc05e21dd5b891009d27e796b38c8a08e55352858d34948062beb360606b49c34fd9ef18bd653e229852214a90ba49be49f5e53b37bf3763451669e23dab836d51b1dee335ede61ac9fc8dee4634395bd43dcc123b4591ac9c831c73280c0fcd284ad12941cd695e5ae6f118d3ec6c990c795f604e66a620f56917b430883d8014c9f2b7668edc4ee69cc19b0f7c616399f918f2499de40e72c3506ad5a4aa9744fd746af1e34e9dcdcc6756d33ec6859ac6694c54186b68143ae6d81c3dec8aa7650a3bf32336f658903437a180a5cfea5459cbe412082c27f33730b90092dc94d95af4e5b861b716d27987dc491f490876d7c116592459d2c7c88c2e169a3d4540f1cd2617834eab352b4b758bf27b39b7baf3e03e2e050836fc8e3651f7ebdec916d96ce1449379f5d05178d8f4bd78ab2c8cfe440002e20170b4b2fbca24ab312b63481a729885c48aa5f4972908660447a30881a6a2e094e5ac369ad2cc1dae5d880b44204c4c95df671a3b4e6f5fad7e09afea0d6166e621c990dc996521480476dd2bf78ffbc741718acc8099227c33d281e42ed43a17f071d37527c1266968fda76accc06e2cfb688301395d0a2f0041675a7fe3b37bc2dee142deb4b80751a2275ef6acbf829ebdcaaca81d47d4956e7e5d8c0477fcf83e8544b27dad49e866ba41f2fd2f13c7d4c04c6dcde6a77d4a7068308517cd821b5600657b392ef0e9ed26eebc016aae7a87310ff612b3bb3d189807b26af242f76af150980b0a5fc64d0252db2e32f629d600e09496d505cf36ed509a82fe7274194f6b4c3d1a387b9b606b7813558627b99e1183a55708eb1946175a226261b973576f779a5269ed9e88fe5571c223ca092a5658787821f397712f3401fbd3d5da053af1a915148428daf76b12af18d5736e5e393157ed5a79638ea93476d02f0cd61af6ab2b79f6efc728953766b4b0d9931fe1538df7b4404d9d067ef76d70b92c6c946cc412b1db0750c6d2ed7aeeaed851f6c266ff158c5e89c9b067843b59d72069796df0420d6e5ec830366d047cc6968d293caabdbacb8f8219675d287b8a86d6967b76670d83c0b6b290bdabb3d25ad8daf4993668ae7e47e920049cf8de1e23cf942d13f75d980cdb5e79b198c0af858aaf5bc3d3b5ada1ac01581a9648cb3cf36e4ac1ce05309e89504020b1ace118011c6776c1c65f5ca85cb36e7a30e1f1a90027887fa563560c704d8657b827dbbce0f931efd61b3e8b5b1e70c204ac15ca9fce028e8181c0a4cacae58304d7c31a41051cdff50acd091f2e354a07c5b11571deafe0c4b61fca7beafeb5190b7b471ebbfcb4fa7107720db1836570c687310f4730e74091cd715f796de3619906976a46841eeff3366c4dd3df24c78e101a20549820719ca437d07451256787f4a624e6edc2d754fef839c1c7c3b006e96efb6cf4bb14843dd7d0ad1c65720b88f6ddd14e64c38f9df12bad6b13af2e942b317a0ac6cd8e5f074031da19ceadede2b2dfc4cd7dc44951d9f99aa0b194483c71aa842d0562dd4a8f5c9c19b50a36add346cc52466517e5fa2b49a9ecd0d3c14658dd2243b92d07aaea8ef932454661806a2114814b5ce10cc142d5d2575258f00f27e2071f8202820a2f23cdfa2607926d2529f6baea2da8556494d88a17348e6d51e5633c24d0eb785b97c461210fa74674b770cd266b41cfe207fafc50f17aa61e61fa5c327799231186e3394e7a1ffef62409dd095ac9924668ead1a70e4d285eaa14c9b83f72c112d7876d36e0dd76b64491fa7bf1a41c157e485a3a886b2ae21ebe4561132445960e0f7af65a3450e7dbc56d6b894a465d48f3c32bdcac1742a25479aeac32da0c3292af45b6a8cd6ad37f70923e84be0c962aaab348ad2b837c5a38c1842751ddaedb6572a647bfa0813a91cb3acc99e8e9c28a24690cd5a1d84e45d7986a712c740c6d80ce18d39c9fe5003322a31b5a9e7e53209f07106c965421a11280a94a80645865fe0239c06bf542811ecab7c03b660e6e21a3a5263a01c3cbac3c6cbe614b9de0994a5c157b6932ab74287eb982610ed5fb3f8135d6ca1631d4c49e47f5fe374a6a300ad703d27697e8f5da54d8d89c1bba8d32e86548f485941b1c681f40bb9b4dc9b6f7a105d1d73aad810d45566d4ddb845f36b820472cdb9545684b9497255d10bdce92d6d1069408d67ad987dd9f7ee64c770f21d6fcd5b0c6128d666e42db28812391ba0a479046fa460ee7c84f8ffaf72a3f7f98977bfef810f47abf43b4c15084128b2264f970b5947301b355a0d271c20145da3814f56e54ec420aa9e7e87ddd8220ff8e3bca7c12254e227678cf391df98b261e75faf82808937ad03e76f3a7873763a8deef18031a5889dc48159cd45d7f59d24d5d20946a962fc31ec672aeb5c620f70904bf0c89c4c510e6e7beb2de659700f96b063e7dd9f1dfa2a190bebbd4127ee124f76f01b54d12ce05d973a978a921a068d12437bdff74017b9b3389fb34565d4da7c674213d89c238653d2e67d8f91b592a4401008c0eb72d957d7c3026886a936c2129c6230a438ef381f0a08aeac1551b1713a27155c6e8a43223e98181f22792b185dbb8a636b28dac73b1d339ace16f02e025deecdca32611443e1374b69df759f3410868aef11d833003ee1abe467bdec24e7b95d46a5b387d595f7a29f609615ec8f8c6ad0767d72198f315a6998b075bebbda70dfbfe871e5a8ea4a58d0a832c36ff5830e1f03632b20bb6f37431b7659143391fd623cb5366c4ad9f8be9103c8d7b4f7f3f9880dc7013de836bd5bae1736f474422fa1c972549e59bfb2c31d547b106996151526e68853f597ccc1b3b676550fa1b6d58591c699865337eb954760ede9cf27dee17afff33472babcf6d140d88bf689ddd4a2161b061f742eb50421b7775955ffcd99fc078b09a604eaefee98dde9bd215b4c882a8727f6879cbcecd22bbc3407502f37cb05592a7ffa8a31e096f9e8b16d1bad02baef32ec276628e4e0711fcab18bbcfb58534ec6b38db6bd91a8ba12571e83a4c8d2899835435450be0c4285d2b4ad188c3b64ef324d3534e24cfff4be892a7bd2a24259201667bd47546146b3ebc3726c4289766cc04ceba2b4bce8c0ed26061607c2963fc95eb02a75f78e004f84168ee72c7153d3f91a41420aa1a401450e9112e9c7260c7718dc67b0545fa3343ad1be41e07f9adb033e79f72f9181dccc203ee385800bd5401aff1cfa03f4843270493346390e035c2313a00fcc4199ebc2c02197f701bde3c9affcbeef6f823a52c13c42570fd063cd8307de9e1cc90449db439e5354193565f427f133ef31caea847e6058241be1c6b896ec30d97377d5c2f2a349e49c06fd2f12e5bbb330f31a01d4b70ea6ae0c05fdcb0081da58b55232c40b07b8eb9272bc4c28874e4d7a3e740f656a49202930f4315f1785c9296b0cdf1efdb593e554f030da6a95e25880758925c2c21f83f6dd6834e5572f65d7ba36b8c59ecad817b79a078fbdad47673b7b05191a19ab77ef15499080e43522aba888048614ce8521e4e7bc62fb47e8e30114bb01c5d140a4455b38f20d5ae886ae17ae3c58333571087d172e5e036860a0c35cf98f20f1e509da850d301eec6eb5ba60ceee1da7cb267e54bd0767a7a00c6c0462d622bd94553d781b43ce1ea436fdd1dd96ca43ab0e2a5d4b94e4060c497ccc40f192e5e72f395b09187eaafd4150bf58b994f0b586b9f6b49cad0b26db0422b8f23a45ef13545f9c904616430f0a3fc9575c012c8e3a33fd7d252b74570fa095a899e9b1974a6cbe2545fcad5967ee3ee811a98e96853008974d13f2e5ff83fb28a4f4b020e4b6ef8aa1b90eec2257a23d8834f5164643f6c75983e8d6b3f0b1312fdcc4a20d9723d4fb8653aedb14bb42dfc3ee24f6f3ff4346d7be97538b1b2f374ab89254cabed6d4b907b40fb110e41f1bf41f7b86b8723d0d140ea846e01f0769c8916e1beae06aefcb1d8d86360ab4e7110604f703fb047ad6dc40d6696ee87ae41d0f095bff414cc2dbe913502fb3e36f4ee301090be05b15584ea2d56e44970c97e2b31eba7f718d700650116b93b2ee9918bf2c6b8f291231fd0856ce56258f45f2509e654d11e75dc82e5a7ae74b60eafd1b05d3fed30565c366cab0c3d31ab56dc8b91e2aee56582a4d5e3a09ec24351528e88a66e01ce23bfe58d646458b90d358c5fe0b78faf84b593056187d2bbd03779c70775490310703c7058e7755aac8529a869bde1ccbc1eb20babfce3c694af74400a056a4ebb3341f49b871fe63d9744d7b018b32184255b5eb5d7ffb3228d91f3b376b6f5e750795034a8d13ce5d67ffa495db2a2d94ba4a4a20b757ce6d2f032f6b0282b30d2aa7e4668d8b97393c594c6ea2f5cc3e3fc0bbaecdf09d46300c1ee6ed3d387c32c94908c1eeaec59a199b274be0474b2282ffdff746210cd5536704f254094e3ec524ca668aac20a377c9f041504c1b2fa062d8ccf3784572941b46bc8753e3b598486b69e24cd7d8a01b6739d1a9960b9c5e42bd2251edce747b1ed9ab3fc7f0ab3a227e5067a1983aa1b5b466de98eedbca896a1480e6153692fb31beaf0c14e5ac703ea60d01e8bd8cf28122a17aae438f9b19f5f42e4d40e582d881c37419aea83d9e746c8a82b8acb9b21e6239463bb4c68816f49468842a58732d7f176b0c2b2699cc0e2b900dd8c780295f4bc3a378fd46a0ab7fddec86fdb089d032a9828e62d5ad82f58c4b515300ad5fb0cc8670017c4c1d78fc9751e6085e1f5d9e64103f1a2d3677f1916dd93908d42539bff3de456dd2a5919ce33523cef9483188ede65b69ffbb7b9c4683554c287b2661b5d006783623a75340bb7e33327fe1dfde09217eb7bad88af566b6e3a5e92b6cb1e340e73009f5a226784b2165ed2b1c65ba55cc4ad550a9f0e312ff8c35fabe422b9f89567ddddd7850cb182c91885867fe5f8cd9e8b934778c36580fab2b59aba7beea7da3f11949cd498e71b2a0dd64eaf0945ed782c8b81c219d2a5e8acbb55f339db54186b6e4fb022ad5a55e3c76b5fc5a45f19b9d3460a4d1a172dd6794b5ffd43175e1ed6010ff1950c2d739836f90e600dad731525eef0e504eb428ed9a7625c9136693cf5c75992bf60ac027b012d96451192ec91984c745b98c17f0df34f35f4663e11ffd04a61b1eb2ec800a73cfcd0268c188ad95bb501f719fc509bb9b6403a38215a3302949b4cdb506c4f5e0ad409056783156f2d9c01bce65d1f210f327920679171534466f06ce129be757cced7b1c15e3f31537c6ec03656b9a487b0d3569e734627343cb29a6e90b4006467d5f393fbb5f665f323769aaa96ca3f43f3fb6cfe3987b522603059b821cbb2394a326086bee421e8d9393afd71ecea7943ec11c68f876ab21224731788bf1adc48c1a3d8d9ae570162b6d8bd22d5280ee7595cf81b00eccaefd86da3aea20ddf17d43ae1722199532715c225e8e7097345fc0e94142f61c68d2ee0e3d335206d2654e0496b1a938e52a3bcf2931f1066a4eb53a30fa1b35abe98974333f8031f1dcd3855ba49ba83bc75816623e3749f8a010b680dfc529b3f1d300e30c14dd985790f1c52aa0d453bc3be32688d36fea3ea4598c7a57caef16f5a145103b548f9716327fdbaf629ede59cc688110b67d6ef4c4ba2f6246f0d5a0a96090596f0ad6363feb1026cf5a008e998ce400537a4f0c6b7c1abdcf3bbbad3f3ca3d60a9953780bff321a7adf815ffb03074202162c50afeb02401116ed26fb4f2221b445dc3cac13fffeb3b6b5f81fbf73e5a8c34c8ebb8636d81aac917af5c35b58c3f47235acd2ea6945b99d132cd56c2406f58a7f7b7e29425dc5754dd53a2037df48f642bbc18fe9fd5ab5e01fe8c944bba35e1d5c92176df057f46093adbd7672e96cc6cad66ae261030545a63b687ca82911dd6bb030c00bbac6d8bbc3ca306ea4f1f8ade158d778d1f7eb4ce9c1b4e8e8b8ae19cbb87262202cd7745b279535575dd20e965f7e4e526418f9b8f7909572fad5330ed4a86eab00476979b2f9d83f6d24e0fc99c738157aeb74abc7c439ddfbc561ae272149e41f2300a4c34d0f218b986269d5174dff6bbecc95a568161c2a22eb5d778e79c6fb5170e37337e3b815e797d3dd1f124977a26f7ad1acd0a67a728613c76d182e7bd8da353edddd806456251dddc75186f553f9ba1ca9b9a5720f083e1c7e3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
