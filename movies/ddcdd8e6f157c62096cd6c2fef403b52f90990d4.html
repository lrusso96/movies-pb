<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bfa69c7175f0b268b5d1baa235a609b404f382fb64131e479a1f7edaad14f0dc09f2aad32348f45e41f966b306c1a2f224101ea52124ce701409a5949dade1f47849f8f964df87816bada01f58fc96df066a4d4bd222630cce4e4b6b0cebb918e9e036c474ca9f4828be4b5bca54cd1ffebd256eed20a6e463e176bad82e2cfe4881f6c1cf0ff9380f63c0deca80673a16e1cfc747e7703ba05428afbbe1571f382271f20e9caa9198cf1595707911c8f562995dfdb50715e5603d9ec374328fb5ca137aba85af58205ae80666061f5ac6f9afb888d1e6ffdca7de511139441ccbcb5f608472505cf8af27a779f71503578e7909ceed7fb94cb9b4a23c462cb8779bcc09a83629644f433397b4ba0fd56f242d975181207874c9562f16667843aa12c4f56cd55270dd966dee3aad198d784189e9db66b921cb6bf5d9fd02257eb5c07a9ea16de7ae834ff116b1b7527eb0f7df719b58a86361be69a24250186a4fe2f1f8c8c5834781bb1443437c4a30d0b5a241c7a5f669d78c4addff2cf4a6f4d440d24aa14efe48d0072be634489d1cf587f668b639fbe3eaca08f0d2d64309ed96b157190abb26f81bdeee506cdec029dab26543611d12da22f36f74cfc187bb6b5060f1309f9fcaa36fd4e4e9b1deefc700371ad65251bee6c808bf22a5e041aaddc44f702ad1a5364004f31e07f3e41c2fbc358910e98c9c5f15592e27da9ccc72641ac150b836e4602b81aeec5ad101b4d8663c13b395750d24c42a1472cd6766ec3190889b1d54f353b3f6b162cac7096479c55ed0708973f8e36da7b53c2b4c95c085793136ba3ca88fc36edd31a75bb1e33cc1b9e63910b53d364ba61dc2d165993a587a7dddf866d5f84dd0fc3f85bc525a7bbc738f9cc587e1c8d329cfbdb7f6c56348b28705f90a1ffd5ededc552a5d30fbbaedff6d3fbd75f891d63b60953b0684de6f1b9f1289a5779cdcf3515c2a369ad21cd6255f510232cea7d81c57310b5c18f590077c4a383edbb3cfe2144b24dcc285c64d1ec13edf2a66057deda720b3ef819e07cae295ac37c030f02dae2c508a813742f1105d9e3dba864a8ba6a283b406300c9ca9d051445ec7dd383b681b9f1ee001ac14ff4911ba740c0cc4719cff7264448054c43268d4051eb65e6680bdd563b19a0a3ca83335283091462e483665c80398f4147edb7ba02fdd9e60c69720c15534b85b224fb6f35a316543cc6e28e6e4cc46b218e28e07842800ad3df7462b4fd6a07c700da0b6c4f1f2d051388e38acb0e3002ec188bdf28fc0c79b133e9a32d2da6cc264072a2fb9066357bb8044968cffc93668a1cac4045ad30f19930e71bc2bbaefce7f1e09ad53a3d31b9f33c4d97fb0e31df252ae37f773bdebc2dee047f26eb021c2bfb5b0a25f6119809414ff5f4ce4ea8bef21f9a2df7488e420ab4dedadf9c82ded7bcb931b44d7b691b8b528df39cc44b5d17c357dd7b80c292829d22b9cf432b7003b3e435c0e86818c49b2d0a06c5348d81d338ee73b12156fd4665e2bcce558040d91cae721fa2d1c4a7d230becb4367b89cbc4e2aea27c47e691c536d54e46b21d72bd1b470bf7a78910920fe7d115e2ec360b3d6a36596b9a32713e1a63d052231cf1f145a3d70264a24ec99d0e01d9cc7c4ac80c0f836a9587f7c2cc736dedf34faf43f3794cfd70586705906fba3bc572a90538b0647b7ba4781b8183fe89c3c38943ab425c0a0fb585b3499f434a33867c48fc3cc0f6317d159a11e2c3746d5144ebcfe2fc683b026c378ba41820420d23fbea3934949e2fc50d95f4641acd3320ee6ce424021bcec160fb15630a80dcbce23c2091eda0c40047ab79f9ec0f8b8d104ca8342edcd5d0e2ea529ad049b929811a78e55378573de496b086356f303562f1aa24cf11faa6e3c47613a15da10ce79c9f67542539232c84188f4d86a244e3069d265c9a3fd89ffdaa4b0e498eaf8284eb7d4dc2dcf658fe6f9a04d02426b18a9685d34e5ee4f10f435351b4a2ecc6017eef6c634022f6d6fd2770c9125f531645428cf8e3ed97788ff4e23998c70ed5ce2b541a16b63b3b9453e32d41584caa19497a54d2690a50aa794ea5a272557e0493a19dd54385f0bf4d365a1c0ee741b7e403d6a0ea8b1966cbe09c03c1ad7763dad401324532d6f3d5c0bf7936bf6354eb9681380921b193c8b0f9c7b11351dd15d35b3589c672c9a02fa075df8ee2cc3edd9adc102822258c16a97a0a9d1782bfa09e9648ff969cc230fc73becf04c905f3abba1670fd4caf74cbc0074be2eb8ff36ad5bcdb7e3ca5f0a728bf0cab0c73ff9c30959459ca67d7f8a96cc204350a182a976813e8c27140e9d81622da31c1b714b29f0531c98fd13a234cb43d1c5e9a71fa32f23b45e52856cbf67da166e0dbb2958992890f8038d0b51a41b65a29493a499acec2f2691f49443693dd23cb15258c1197ea11b37308c04cbc377fba06960e41aeace358802436bb57ef07a924ca6a077ca2c147f056b933f6efbe3f20084d7efa3f2972745b79d403921156f691cfca82f9f5d93fc2e4f7eba5cba72c080ec86cd3914ce2adc65c6a0372313cdab7a65b3f2b3c368fb9bd468eb90c7bb3a406a2c21268a8618df7c225b0aaa43a4e2fdb0dd25f2d0442b2036570fbc1d94d992acbf699addbfcc7c19258fbbe1dc5dd06931b7fc141c62bf6948758c89f515b2a6373bfa849d0f52089fe558d4ae2de1caf91031f2f84ae4ced8535420538c2337d3e80a59f2a12afecccd4af7a6cbe8a80f239dd2a22d689b170a029238c7961a64e9218e2d2432cd639f311854d502a629d5ba08c1ffe60115ce9cd429933eec724875f8558749946742f731a31a22754712fa88cb62bef445b3e3d2790b2b0293b9c870a44a22c2d1725a230353ab2fe5aededb91d87733135cc34b9b0b3da04986d927334e4c40aa2bc5d6922ae43cb109c3fec57f1e5f4689d95fb5fbb2a532991a32703c8268f25ce9877825c892bff9e99b457aa77c21fbfbea8c719f1c7c2c2541eb82e77a0c498d344ce30fdb42f5c68798149737208583ab584d42a2494a321e1108682b30cadb20461ab990b379126044367e7cbd4c08d45cc5110893c5d64f10992e77d3651d12160ddbefab452ebfeb6d395f20339104bb1a91fa5d9ff47702e3397233c93b487fd78b2646a6d6f658cf6fef8e393897e79d149ff612a1020abf31054ca41cf7727f5ad6f5ffaf2255c0bfb90aa03df6b867c7cef2f3a5e88905d1a901ad87abea6697deeee2404f76fec15afcfb20bbbf2e44f77d37e5159fde79a8760e9c89270169cb6e1070c5fc2b9e50ec9f6036331acdb0f4d22940c0bea34f15660b1cbc82edef8bae7ff8036459c2e6bd1d9995b88839e87b5aba80809d9214f9d660806e609de560a9fbc8b30769f31fb9e97851685236139b34c1e672cf71d3aa440a172f6d2f5c6296556322954931e8e551f7971b088d238209c77857d3d68be6b6719eb164384645416670ac7d767c3e51983858af0beb1e77d3cb07672aa0eec3a5b541a2cdb97eda148be8801409424ceb2611738f6e6c273e58cecb65da38a7315a7ded76ced42ca6a748ec6f89d8e497391d212f54655010805f5eec6c73a07b79cd9ec418c1c7cf132c7013307776bcc0866904e5777f0bac21aeb1d0935851d6ad2d05b2a7b9e07552d9f848962c8d92d5dfd701c1f777bbb17f6903a1c79377f3d99c85524a7f4a165b06b0d8748a8a7736aa0ff05ebd78735df7a4ff127a5bb43f9fa8b07bf5cd72926393d7f601acd79a420b8d06640487239a0f53765363459f1ea87b66ee8bd876b07e6e8f69ef1fd1046857f94ee69caa17f267ebb4c277a05d6e190de9333e7cb7e8fc217d612a74e56601f5887885cd84d729a0f8967f09aede643650dd2e4671ca9786be45170f94aec9f89ffedc2fc042fc61d18e8f9e0b97f924d34096af6dd70346cf87fcbd5628767505635a4d76f618f0edfe49b62444f7cc6e6049574ba19745f01ab31c399e0e46d7019258e4fa076ee9b4bf20c9bccb43160432cad10da0880a1b40b6d42a69e0c2c5e81863fb09e9dfc46a8c082cf75fce14896025b4c3d1811c6855f28b8a0e3531aead46f79a5e833246ef25d498a95fca00c58915d8b9fa6fd62f417a687ce6b03aa613eab98de9d9e6961700f2b1014ee6c42f4943bcb5d346b0888cf27fbaf55702a473f0723e19e09009101149473cb7ed726cf7dde2c1f46fa12db1f942e0af66e9500d9f4a8184564af7c2f57a9dde03717e564937ca7f98eeb35182cc713fffea4354056585e74a77f3df3a4b986b712fcb52cd501ea3668bd22f19853d47c1e4d36ce2b32de49a6be172da8bfc4e1ffc0d09b913d7c2f08d7b58800123c219e9e27914d988a3d51f8a268d80827641a48bd0695fb19e045736e3e88984068ded2750ca4ffd387e701b6a38e6b2fdc6072d36ae3eb669f87b270adebebc431098c9cc7a0fa9679e0287fe5ab8771aaa83a5bd500472058a096b5f92558354a3879e951bc2ff450e86c52ed8710ddf6c5275c12310f7b4f4414e5022e2f4b82dd21509e26134b611fdb321c51daaebcba32858a0b4d88b9175da3d51c31b3decfdc791c1b290e3ff0e058c832ca883c28d7966511c3921a8ba0420bf8978f6b037ba064705061165ae359d9198c07eb333e5255b2109f9c8d85c3d0c68e5ab879e71047165a8ba75b8884d7f653734538581f262dbaa9c83d05886529de07153bcdc537f26d5bc9269908b3fb134578eb19116118222ed2b87dc9d7096f6e3d970ecdc015518dad3ad4634899527159948c94ec228a4ecbcd9fb133911de7deb3b221e6cefeb3043fc33ed7d73b35e56eee7a7c717e2024f925e1a96a0fd17185dbc080d1d5c9283c6425d92a374ba145982fa6a201f029d686cb6d8e5e08f21660708fdf89d8c6070978e5868c3fbfea441d65bf43d407e1efff585821f142637911a770109b763d5b9e9573225640af737d32837997e6d139d6a81bfbb99b4b12a37471bde9e2530737e3043606079e3ba1a280ae88cad1e5e50cba03a8a819c847d4c6f9499df69a24a3c3656d18c78642889e1012a16ba44c3b145a67cebe62b6c8cfb504910c0014f6fbdbe1db6cfe758b2b94dbe36a01c2d5f68766baa392e2f986f92a976708999d065ac5e9ced70ab948ae35e550420a048000ae664396f06a92c3d295e79fac372d07ffae55ab69aa350515d4d1aa3b9445333f542892df7add6d51d6fb867be4e1ffdc9603cbc000f01ea207a639fa06b778e56438434d477fe902eef81a8241a5161957373362d4542910610be9bb9cab9ef09d0b859ddf3e905f20f5a093171cbe50ff8162329dd28e2c7c3a811273e810becb6ecafcd3b8934d15e8441956b01b6a417b3a7432c702ae9523a1339a5f79783eb71950089a94a7e3a3978421ed265f1ea9b1c2affc78d8dab587e2d53c4a4dc3591ca5f24c52c8cd67516f5dbe7abe996a6ee54c77ba584cb113a74815ae5bce504b4331e5264074c4c3b9a0a99de5578f6acc3654528d69dde878251677a27085d717c066230fd04a7eacecc9a93531cda13da1ba088c2f918b0ab35eaf38be6c5a1bb161e9435f4a18b9b02331db40eaa5e4508e341253fb64ddc8e1bb03aa5e4bdc1fd4903ae3b8bcd34bdff0bd52dfefabcc9be86746557bcd63a08c3a3caf27b1cc3e1d274a6fbcb0d9e932e7bb37259eab0d342d7f081b53c7a207331f3fee530faf1f775b855672953e293323c22f879572db676fd050023312e4166c7f184c816ac429a7570a4738c5dd908914d858105d2a3ffadfd6f24d1d01eca8e7c1bcad979c618b13c8f0adffdfb0a8b8f062c4081cd3a431347606d09e1a73f22a04168120fce714754f9cda5c34983c3a778881d2b3b7dbc46b42c9158d6c76d802478fd5cee1850f41ab0c84aab6764555bdd8afa792b74d3b8a56ba1136b3ddb5cdc0b5583ef70745f09853ae5b3fd34d891f06ab6332841a96de844816391121d3bb6db566047e29f66d93bc5b927a4888144091e1809ca7072e3ec74f75c7f48c330c08a3de2cebbc41a9b2e5b819fa8217a251ac82743b859a9f93f3c19ffeb4b512e5e64b10ea44c8c94d1c330d74392686539272839e0273913060f572886a40b26e4be61df6d6f6170fd608bccd62c1848d429d3ce77646222f84a144896717376599009ec6678663b83fdaf4973cc368c42352cd05746e96ea800901f8e85301a546d28d340ca3000a6f669af1c0f4df1cc3f4068328b284edfb9e3d0d617a6f72f6354493ca0f3c2afcd44c22e8b1b2ffb5abcc76689333a3c265474aa9386d6781f11127204e6224202142a63e3fdfe89c81109fd48cf20800bac01995bd4a82809030a5eb72cea0bd79ef8378f0ebbbdeab58d97fcdc2123c9f75d960ad88011a0f19d9d11f862c51113f2210701182ff4de35ecd6018118d6176feddfdd8d2277c419fc8addbf4076826270b65b4f660ae7cfc0de6f7f1217758e5c2d3c908aebab390e3ca757388fbd1bd900f7726faf898c77216a9ba02a6f495792e3985ee10ccdabb803de87520f7bff703a6d0769c2ed4bff696840a969c699e437ab67f9f12666748d3f50b5e26ff8e29bab76bf119cbb144c59b0a41071a37607312fa981847c5eab6b389d45afb6182807758761e69bd2eff444d127114a02f933d4a0c8d6d175feea18a6d38cf87e9929c1a29babffa34b7ab1040e960a9e3389bde2ee2b7ab32d11508ae0d7ecf26cca116b609523677b08c0d191bd8529210a3ed9c3509d31ec3ce560b9cb8b22a1cdaf1737b42c0705e93399cf8d429edaaef05a0152d9015f1c242fa1b82dc9cdf0840485e3e561ca4819d421dacd1fa474db01ca4e6eb9e22d2d09a539ea6ac117f4f5beed6ecb7b4a48ac01cff5636f44c3ac68fc00a28445291be98ab3af3d1708530dadda34ee6131f17d7b70e42fc132ba0356d66ceff554e98abc1daaccfa34f8d522c773edd865fea43b3400f5eaef2b00c05a6ce8097206542040f6d19bebd5a365f78715b7086a994008bdb330b5660c12eee0a9c73a4c391050d6269bc9444bb90d2159b8bfeb4ac64d263e043d2dd32d2d966a19658d3624cb19a7ce6ecb4cba0fd4c20554a9456a302f46c692e9a17c54ddf3d4012a713f7d0dfde02fb912bbd73e128132478e4765d369b7b93f861148282729aa45346884b89b5bbc5d79dc302ab26a823ab66def6f2d27a6e2c104f55ac4aa86967d495021bd3c58e0680898f5d3d2996a81a3293d578c0d4e285bdf10e627d5f1ed2010768858ccaff6227332aa89ff2be425f942c5c3d01a2d96026cf5fc4df2f3eabb4c5d78b4d7c0e09b7849813a04b07af043c43fe58bedbd93d33aaab901e5c1600677c04e79f65c20d622ddd2c2930340b9cf9f9331d70b7d1b2f797a7494eb02c21d505a0a730cc1d5a4dde6566c3615a615bfb0065bae2cb71b25da0b2e16dffab5ddc2c377755811b6f7dfb0c60503b046316986d55af07eca41c339119158ad79e2eedb97b644fea5e2b688a0942a0c5abb96fc02b251caff579fb9c08d38a6833bcb39e4051d57e825ec057f737ac10c74b6f96f8f468a020ba2c1f8e2b72e82921db2f07c801bdd2d5a94c8a5ba0d031f472d531dd26ed28a48c4398beb1c5311a3713ca5642903b544bd68f7400135685ffaea6412cbc3998462e3fd8fe2eab4159d4ae7b3d17051f57c70808c136415d511d35cbbb7b9c14fb78e3568676e1a1a239101278da3fb226363d01d6b36e87ddc341b399345bd5c03f46bb97f4a6f61013bb8ce32a9ec40df60c492f3706e22b6f146bc5637cef12fa33754c53ec1e38bc8b3cc89c60dbd2cdcf7b071ac1fab76a9cea24b52f2a24258effdd22dd3632117c0673257926860712c8611479a06593f70bceceed5085b4e5a0649009a57709ef37319d0e0fcfe836b960f88eebd42a290a347b5c4a68f17ec3d04e1dca5ebbb2f88152277e8b9a4d3e106104d1d3f04132f93ad1269e2743b0c09e022c35a444255cc3e2ad53851f6138dc14a81f4b928402fb1573fef43177e508a34b81f6ef0188e5263ef55dd9e74cd1ebfdbb517fba8b12a94d2d9b96e484b2d24e18294f9c65bc041b1759dde4d3f2f1c342d729d768d996d10e5160b33d237ef898bc5790990612ff68453346bc3f785b15abae5a12f7bf6680dc1c344b952253f9d9c085b34729699a0938a4cbddde4d18f34bb7ac3ec1f68cf088f778796c8f886695cb27d552c0454724627be0692da7d4ff54be73bd3e4642bbff3bb533b5ada4805401ff4262d3b94bd5bd92aad86b1abce862464176ee66fc918e383cf0f9619271a24ec2c2c18acd988cafe2cca37a11c7bf76146db8c9fdd6ac3bce3b775c2fb753c608b7cc18829261751ac1bce2382170eafbf78ca3996aee96105a97fa8b4f3eeae53325b147272b1de2e3c5541f1571cfccb060351e093f2f2db1cb01c973d3857734339031f89d7922f087d7b03e4e8b5506284e9e922d162b820ac4fd77fd497edeb8c24031cda73039629d87f9774eb0832d2b59f9ddb73b8cae1c52382f0c1b0b691b1f22d33ea24b0109290ca6e90f290ba9d53b94dab73516d9d08404c5aac0b4de03486d2b26e7d5c33121696478b3fd9a64a021711afc5e3cf87ccadc72ed860ea1a2120914bb3c12d52714c9da39d2bfc7e8d6dc2da8131f6b087aa03f92d7a25fe4c8471609d4b41693c90b58899de012f6b0ff2d6749fbc79b178cb60c6d7330783257db0a2223dfdceef559d6373129a7924962ba0c01c4881e6b9a03dad8cff3820c998891b2f02a61ac02f8d7f4fdf1cdac6aee828bca2d99d3b32411a58df8e09a8497d0d7090a4862dbd1869a964b3afb203a0eba78fdba18126ff9d0a98b07bade6723a7cddb1b6cecebad68e5bc546c5d9aa0c884a0a9636e5501798fd2ea54fc060d0f38b052c2eeb72f42cd1cf75e561f2d6aa84903c033800d0ccab26fa5e76de4fbb0103af8c1813aa72832941681af399e4c028b51ad0a859d78c6b25ba3977cac5b3656a583920cbe1a821eed9bf2c05727f8eaccb9b22c55422da1657de6bb290ff6eea6939580bc93c0f9dd499116c5c5a5598af8f2892a11a174a8caf78b7ad8ed606963c6abb662f94e5292ef3ad584873557e913e28b75cfb63e41e65bcfa384d94753561e2896244dd612c4c3c3ac44478ca61c3fdb98eb34e94c4716691a84f95785ba26a51396be4f8779ffb9d9143eb77fae839e2246d219d1de2feaf6609458a0d2d18de5b49a12844c3e38f5d9dc1fa88723a49e43735ffeab913ac5ad6d8496c7fedb069e9fee6c6ce20a57d7b292194a473312d3548218ba4db6864aa6b11ccc5042779f0dc86af94e344fe685986b2eb6c3147386bdbf50388284a3e1c901697458d67a28f5ccffc319d5e63220e54e7478d1a99c4f7a9c4dde5919db8a4f91d6de4e71dcf1340b9e0701898c04332674c9699b59a20742e3ebb58cf5ba7bb9778403802bf37083866f8045a6591cca923e20f5d029da3278db7794a5d247bf9e66892949ca66af0a0f5ceca2f8743d601ce88fd55926f0c5263f1e14fc9a408a6eba923372c2c42fede23696a42b466017c43c9a4dcce97d5f166f35896a1b13072f21f8a2a55627f6935cf14cc3e2cfa0e27835d54ad9f18bdd2c01cb24f6f4665277e9f37ca7c21db6dbb640c00372fbce2177646bfad050e883ff9d9cf3320d3378cadbee26c29c3876d986955c6faf17771fa96fe5dcae414e567d8bf7fa6c8e720885c84d3cf8d9db76827e1d812e62a9c43c15143f0b87eff851d2c8e1735f29a32c6456f341978ecfaf4e67102e2eacf15434bbde4ffd3c047021acbf39531bf48dc80b070994c18e5bf3d9517325cec789d0ac0bbc013813c15e7296745043f45d651a262c0441191bd6e6e24dd130cc0c7359143842e56ab4ab2de77994ccabdc6c9bbf30f91af780a9e8fa73fefe9115122ab448b0a04ebb41f802033296bc2a669ea06bebdf72af91a1c9b1ff37c7a95e6515fe621acd0f44c36d45c7f79fa579cb814bb059abd2f632c14ea156c4254f78a15eff6a24472d7646c4cb1ce4bf28dce653d170ac46b5414daea1efa8b59f327fbab2ce82aa89337de6976569fa316347b40f879c5f573229dc77eb5619310c207efdcca8a95178ea99a898bc96c05d3962ca4d0897b821c105630e88b120e80aee4b0205a82dd6d91f86f4c695f0d49ec43f7081b3a6abf20bc4968f742e9edea0497cb34fc99d7a35a502f71df1e457da98fbd7885cb42c38a51e2911db3fbd96a5629f84ab2ad3eeebc94072eda52fde15497edb5d9bd34664eaed8f4ecea9d88a16ff960068ffcbe94173d2ac581551da16ec8b83c76954f6afc91c5de193b237d5b7d433e62a9610a3971db068ceb6b5a787dbc1f320529d0a8f15bb9a0d50c708595aba8a1878505e1c94fcf3b943df0845d608f1d0a45e3013388778cf5fc34333190b5c32058169929819aea52bdc3813fa5e2ec8a7d3ad326d933a3735837a2770faedb25e9f30fd7fdb4b26a6cadc85f17eed0d6557eb4b55c4bdf5f0d92faf01356f4a560aef109faba6fbd98e35a290c09805934a82a41a1a8bb5255684cb904b5e138a0b445aa42d31bb3850c61b7cce93dcc80366ffca0a5be23295c6f5ba6794eca9dd0f2d2d4de4b8bb89239ef12d515fd10213bb800dc69c2b2d7462e60519befc84e21ad7b60782f6eb9bcc1178d51ea352d8c69553544d94245838233a3e04a891bd7513fcb0a84416163e0caf90953361c8eeb18b4f5a1467f771412938024df03a207e6578142a53a61f50af371bc35ed4d7084816459e3a9ca91a954d3082b3c7609c22c7b5b95ef30a01cecef89201d1df5690b1623b49d7a5f6120a5aa715781a837ae0d082bd79cd8db619b399e42b8266c2d31649f3e4aa56f3ed8dcc36486570d356fc53cfe1110c97884c18a31dff6333cc42dd3d62e4259cc62f053152b5cba78b80eae76af87d27a1b753906cedd6d105a19da345d9ea5f8de4f1a15c2e7ce76399cc2c41f3a5def56072bc0e1af710f4aa05a111f5fbcfb1888a6996ea35b0b3cdcfb6625fa46284d2ddb88083badab4caffaa84b7e8a1904bced7282731d0de18f4008f597ced86bc0a130b89dc5fbbcf69f25649b69441d04e33a4d5532ee70164225f088b3a66d9bdf920d741b0507b86354b4cc3d97c1abc19336b1a54ff2d1531047a5c1416be1ac03559099e1e13d5164c5dc5eb8cb5ed545f0f2be91bec492a5d7b4d373a43e3a16e7c387d80015a0882c3ce0c939a1fc2d4ba9fa5bb909bb268c96dce2bf7961122e861ed91008ba646a5ccd0286c06b15fdb6b4f0379617f4e1a6c666a6794c49041b1604395ce4d9f7870097f53499adc2a56620dc54e7164ec1a9bc54bce074edbc99b5a9682c39f0b3fe8e297053178526f9639533ad019a4f93e7cf66565907ff89832f1edbf97a84e0109cd88bde77edb77ef9336f4a7d3f16ddcd89aeb18afb138bedfce853c3574b13b95dbb0a167724bfb158d9f0938be7d0547fb52edddcf9622dae2eabbbc13d0032aef74306a80c2c074aafce2b8dbd0d0bff84fc14abf2ca950969a12295da9845b2cf1d393c542f4ddbe6395a16fd6ceba15997e31631bc98e1076a76a80ca5fd4065f488cc7afc9a30eeec4d7a2327781f3bfe38427aeedc9fad6b93940b6a124cfd6fc7c5f7eda61c05a20f66370c6b49eec38b393d21973c3d9e4e592ca116e4d92c6363927bc7aed1b29aa23989704e34d29d8db15b15a639196555bfb632f066314ed862e1b8a9a5284540f041a830346a7a0647681025a708cdf8ad34171af3e7a086840c49c2be1b06c37d949e8d9685bc2ddfe056eba063314206d1230c55219907fc5951d95c50d6769831c14d4ec86879e5b48900ae80946e9d39d89d3054b733ae18e0689af02d46c03655ec4d05396d35c6ee969d5a03b79dcffeff38b0dedf027c6267c407fa914395609aa26dc03d7f28660125e5a289499d715aa80bd6c4b2c93bd21fe794a8c26ce2a07da8e5dd559978538574e2a5fd4bbe12f0b79f4923dc961eb185ccfe809d1fd13ec4bc7aa34848eb29a7ed077216b1afbc41ff87653c614b00514c94e0c799b3c3f11f24e3d5efeaadbf33385c9aae6f9de03f8785ab3e6b4635e5ccdd0e7d3c654391c3f1d4f020068c14d9e93ed68b3163082fb64d2185b26135aac3ad3a7d4d2cb3c21f1632b6b8d93f90aa0779d2fb9856ebc47db330c8523ed050467fd7ab95b1f1a98d862967720efc25bb0953f86b6d9089fe0cc0928ce94667279193fd534871b0d6f05c82d4913c9ebeb0401d724c5ca2a95195f8d99637f229f2be694bfad5a20aba3e21de66673c0dce0ad63f135f5c5ced0256b74b4f5289d7a2a2e6381e6e0aa1d71abe51b3a3ac16d3415dc0d8b7e1181cb3dec042b4478d3c8577f181dc283287a7cc8c2c29dbc6c6d0f84ce79d4680fd2da4b428c680d2c266147be6482ddd63155d3d4e42aa863174748d6a2fc5cc71c9d0d122e335d742a37e68ce3b36f5743c322c2c37937294f1f533e59dd804ebc48b8a0b6b6df0a7dfcef9799f82c89a53dbc86d1e1e388285942bcb6814d7ae25d62883d1b2c02919f7e74d558e1bf632c470fffa2b0561587f9272e8feed03f83a7f9ad34d9a33ae0f74f5c1e738262e3ec6b92cf772142c26a0167781e2f50281a864107d71c9fca95ac1000885fc98c5f842bde0230c2f50f94e41bfa8d36aef2efb072013f90a817ea156769be5a36bee4956b2f6fa3d4126746f056a446d9fed7a131a10d7b3c4b8996a644c6f23836c63b3c67b47b802fd38e70d0b6660f218ac588b1b0e509b5391de851","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
