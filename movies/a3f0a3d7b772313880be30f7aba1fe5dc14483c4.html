<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f574bac58e2015bc48497145c76e02b4fb709fbcdde59ae043ad8a7b83fea91c020a8a8d09240dfc0b461f514c2efa3f3f10dd57a4bb5d9b8157437b52e5f5ae3d42bf8d01267db85cf5ace279ff5bcbeeb7265a3af14066409c0800ac2e57ae126142242d0e614579c313c51510b74ed05b86d8a8931dd62e45df5084d4cb43d61a584f59cbc27e245cf74c5607b4ad42ad644a038e69757211c189ffa1262f31195d2ad367330e315069591982a7b723a3a6dd7b59bcb906684d3846f63d4021e40d6fe4966d6aded66090c75c1ed2c11c9bffe0c1c3775ec69f1eddcf6d71ee06525cbe4bf57313c586e8287d0e757359f5e80f2a882ba695b9f4c41ed332362864feecefa8376ab91af10875e3b176901d11fcb2cbc55773abc6767342abfec8706a2eccb0e9e005eff7c3f8199c55aee0b368218ed9989ffee4367ded10046aa10918a4193a5a8a0c67503e642b359d7ec635a480f9b4549e5ce932c219680d228f35fae870619da2df14395ebfd0391e9036c848c2897b4cd4d8cfc83198099b2e06442bd4dff9551d2f2a0371067b09b8a7d1d312aaca5a8de1d122ca33249bf1e671ada1cfc4a4e78580b2d5170b8e7ed4c3ff1a50b07aff14dea64a3097c7d019dd199ffaf0c1c0e1d3bf058cd0593cae278e5dd02301c74541accd96f5b11f0d214c035372d2b67e81f5eac7be522625a0af48fa723033a2e9621ab6534dc0cd2bc0120dd6592438c9cb257fb40869118b0300e00e749f3e8a7d45838a8ba80abe6914b39187518d430a044f7c5c4228e903d3f7fb2507daed933bdf4397635ad6f1812320f2c965dcf944c3a990dd4374fae6842b8f4716aa3a91dc3dfbc917e852a825dd31079bf9702bdd37003e968bc98225fc6ae84781882242def6514161565ffdcc4d9499ff4d8d98ad231e3c2ec5a057dcb71c882f4ecfa41258b2cdfe1c257b124d247dce036662fc8839fe4df0ca0a8f6a498a78df716c028f7fa82873e771033dd9c1838a8f4c83f04e7dd672efa7fb9703083a7fd9ccf3baa5921c8e3100b0c89d73410978c50483f88e85dd0bed5a54f892ec3dda2e2fbdde9ad6f2290de7703803563c7a0b66c54018465329f8c9018db3828f19da782d3a5530a3175ae524b00b793b52d21e75773d6f47f98cd7ff043196031f7a8ebf95a6527a344d741d8d253526c7c464067e382ca302f9b773c09ddb45c9f57b4cf69c686eb8ae2da97e35b252a7ce2f380d2f8ac18c56c9954182827304384a548760ae1fc229db4c65bc8536702e3a5a28db061a0ace564fba8c6e5685fbd906d5dbf422ecaed6e81b1c02d653a055223578612880d564a1634f21ac1f32bd7daf2b672e6eb8bd33820e11dd24634b73e59b37ae77864cf5d9c93cfca009e7f79a27b784cf703aa55f6bd4a1d909f0fe95545581b1f176911093ee6d87f073e59058c5e751f8127b30c9439ba7f865841f1b3f9b5cd626a54c92eb5c56bc9563d8b80b2503c34409e83e535dec49fa711170b919f295611a2e247f756930d4b6728a47d53ed41f5ea6f1332d132b45070ca505283348ecb7d40b2c9eebf0b77963efe9a5bdc0ffeec6170ae756db662e98a9c3b342beb13c09775268492b5f0cee7aee2a4adea0f9ed8f7261859b157425d376e1e197aa911f24258a7cc7b59822e836a6e4b551af4ce21034804ff8c78bfe1d4a7fc27ab8550ace05d96bf4bc03fb728ed8d2d44a9a808123286b3cd274b355ce917b6793c96a9b4481d20668f6b003714803ba066e990eec01d538191aedef9a042df40734f7dfa4c6f2c9ae4d0058061730ee360a3323339dcb1cc5b52d90ca4165b5672bcdbb42f1ee60427498ad6b2ebdb60db42bccc0f0f0d131c7b1ef2b29cdb897680d04c36b61c5c07e82d8235a379ded9a77c06868474e1736ba3d42ca27752eeb6789eb56759e886dff6d3bdf1c2d3a9140993975e36a9941e3e8ec04767eb83af7783d1769510f92f5ea3a0acbd4a242c354b2018bc4b5bd2a8a32c3bd87cc8c95d8482788b4c0cbb5dee7f4cb5ee715980580d1002219922ada4477d859cf2e81af166ba3996bbef5a75fe1e718cba921adfcfbeef1a40b838faef70ee422094d2759c904d2999d54121df69a4389d3b3dff37660f4ccc80af80df9bad077ce305598d48f3aa76e45ae32c44bbe02b1ea6996bdd92353498cd046fb1921ac359e0536f54da9fb4599ed9b4d894d0eb46687a7da10a47428c10c3e30a0a21a1556a1762fb9f9314d527bb9d08985a5061d1bb5ad6983938235398b1517f8b1472648aa37d1081ff7f80d22a34807c0435e90e90858458f22819aa0af3182a16e99bb0d10437940b3daa64b1a18c634a7c74f8475757193c4cc73e8d030f33e2a166f3c10780d263783763c5cdb99ab6aaf3a14b3b0ba393ee5e2d62b2d4dfbef949cc67f2033dd9e92fb6e4f3a0dbdfce1650f814caaa62ffe3596fcd847bd52a3390619e9d7508b50e7eb63a86bf54e44e23a3ac67452386b0764976bd3cc8bfa4fbba95ae569a46a7b282f17de38222384f027008ba6178225afdfae68afbae96e8eceb54be40d75eefa5b013817b8ee68d16e10e1f85bdfba7293a8dedcb703e8e488dc7366495d768aa856f4e95066503453c0828d9dfa1b48ad3aab0b9023fbf487ea8b23d2606511409f970db9c1f9655013c8a825831d82d82da432491c6d32b059e2f80ddcd8cbbf4cfc388b7dc7a08d8053d83146e8c20ba52e3805ba66f93bc5c04c98a566ec54ad69d83ed31c83bb5fbb9a93117869ff44aba9966c378d255845922c2bfdfa1157e70c3eb169dca5c4915a53a05460d451c012d150cfe1d104da09f62c0e8a15964c3f9612c2d961ca469333fa422b2fd58b4cd5dfd6f76bde497f2591c0702f4c4657c232455711de45d0b20ff9df8aaf1687c08f8a21bf3edab674a19e37f0473e4f1b1ce1616d7fca3fc5e418b75c05cb03a56e6f90b0a83ae762f21c4aa19e7cff137140ab3e8e0f90b13d762aa055de18f061c0f6177da5c931a495dadb0eeb5486b53ac4a4f6cd6292136ee6227c835f9176e9a1f7a7c6002eab8728d9dff50e1ed69483b29ecdb58606abdaf2edf36aca17a4687d5e22a4542aadb05f6d6083ab9ea59bdda47a8d531965f6ead8c8f6ae8cd2ccf1427b7bffdb22a42147fbb4596e215ed1fead572d6d932f0bcb640f040f64483d6d9a062aba82233c1130bf5915ab7e00428ebe717105b8f4ef6ba3b561ef4e8bfad8506c32feadd883f1a320c2a9818dc0fd70827da2845aa6f8e34b8c8f7e13d95a7ac94db1c5cc7c763eb059b27c799ef60cedf35bd9b910db1e3b7304e6940be7e416c6ce601116a88f4e7351640b913c2b6ab82825125b9102fa2ea5b606461693b9337949c6d2b2aaa36ac2a7dcd2a12980b44c4a0400ccb7631117e9c8dadd645e8c29491a3c937d1fc2a5940d22f219eca8041da8880d79a0577ccf37f9c1c08ff035c22050bf5f0306a27681d5ef9cbce7a6bcad0cf82e4ede4ca71c90be953005ec1a63e224cdf83b93ee6e50497d55448281c43af68b168e6b6d8b681cc196eca63f2cd548a71288265a6157addc54195e32255ab3634383f72fed7f4f279b715b8eb7d27bbfae96d475ca70bd964c145b46aa4186821c737f3087df27787f81c0840e892dd3e0ae629a76b26cd4c3d3ed570fd988a951ad3771a6812e18ce6be51b2f415001b79358c82ffb742e78a5df19aed362598f5dde6b117a67c4ef4b1fe2d929940d8e51cb0850483319d8eb0c88474b468804b98afd613af334a2172749d49f8b0edba903a4b553350b9ae4574f7eda7dcc8181233d78fb47d533869115f5593927f45c58e7703b5aa03b7839abf146b87980ecc5f089177d825674c44c1c00491b8b956aad965d742cf952e891a39e63d68a6f4c112cc39a9536a9a1f5b8f32d378a94eb22c776e646db8743352df9f4e5001b3fdc89de2341d5c0cb04eedcbeb5cce92d6c092f74461880c94bf1fac48087968e5bb4acc377bbad653558ca1656c559ad4feec890849887dcb9143c4386a60596f552079330550fbc7552e3d5ce32cdd3594c4d679b7939ac993b6be2377cc66617e6eeb3046873cb8ff46bb3cf80599717dcbda0b116a758892230ec1115598ae693584e3f1e9a8aa0adffa7f84d8a8a9246b917cea7a43d8dd4a6326c7f875c00378eba51d945a9e435a98cec567535785b5710f08cec6f231c67b0fd20fcba52e7aaa65ffa7c722e103daf05357527d38667c561803cbbc4f480eb14533fd5d47b71f15d83b1e544c5c0000f06e1a855909ad1c4cbc255287f4b0af2511633a8c19cf037f299342674e0276a1bbc62a7233c426e44eafa84f08eab6c91f30bc09688be3a8e20784c2583d68ed5dac5c5119403eb447aa9cd1a516bdb16c6e6b5499148d3e6f56231eae934c664e05f548257086914025aff9cf39e766e607c6218a6c9c4048cf34b06094cad4f5cc3dc35e9ebc3f01a45cc3f68eda81df8ad6807953caa868acb2feac5051e205c4eb08894dc99e6ccfaa4b208b5d7d05e4e447274d730b578a1c8ae41ffbf1cc8485707b1d869f6fee5bdd59b1b3a64db3d7791d3335296b5ab8b35e5174e779d9170cb0287ef48e3e5586cb6f6b2d2045e23a7e062b5561b0c326d9e6e12c1482f59b893ac71516798dc9b01c72f83c857cf1272e8985daa2df9b4d7b896f4421fe90be8f9cacc8f2cc5821b2ad8c8a79c8019f1cb1e5d8105f70ede0cbbc1e72213b77aae9f5e9bed5bb1a0846d1b74be07ba17c7dc347b77c26393d6c5a9f9f66687c4cf8e19d9cdffcbfcd12f4134e3484043a2f436829f8ac118f6d121cc52aefdb05d313d55a0022e423d2ecc8c3ae4786b75ec16a57748258977c00461973c6b87e8270f2a837469c5bdd68e1c14a8f80529df8652f604dbc42f0ccfc5d86555f71c75170b2ed8378467b5778b3037a3777f60e52c823bc95cfb8fb7052e646787e3aaa454ad4f6146cffd147566986ac493d6e532cf7f674f503e4fed584cddf74a74e33349439651987430b1122a8e07c98c992fdd42ca1e8aa1f4d9b14edca32464665d4eec27546d01e5bfa5a5746a5779293107f98541e2ca5cd17ebd283fbc90cb5ef2a1407181c8cadc7ebf4804e1ddd32a0787e32c9a97df601fa9413ee2efca903307ea750aa96ffa0452726dfebdccd780f92ca19839eaa9db739c4709d32e33ba6a734f845998249dffe89641e026576e28363d58ef3d84478ad0387ea17a40b6c5c879c25c24dd0eb7b18ec34c6f6f75c92bad358af004b2fe67268c134758bcabdbb666bbb758a89f3bde4b92c670b5a26f7ef2be68bfc8401c5775bf178c2eb420cefcbba6a4edec2c0c9637d5fe811c19ba9e0673fa078421536631592ca89a30902a6679ab037984b86dc303aa3a83d61081c44887b49744c8ed17a75ac1d94b4c60c37fde943560e242d75542580c373b1b124bc82b346f67a792fefcf517eadf4885834ee70aefb6353c7749db67061d36f8b9d6d3cdd63ba5782b473ffd21a77d367fbc10f58f21bbff2e34889d269ffce4e03b4b3f5525dbe1b83d1466f5c0b4fab453d5bc8f60fbca45f31ad90275d23c92fb45e28ee98e683144e0e3622992b4de0e5eed678567f022e4e95ddbccdfd21d8e74f023c914d214f2a717b05a7687ebf3ae5e28fe227d0b25d7f3279d16dc1c526474d0cfabfd663e533f4ec5b3de0edc42576748ea86b43145be1887f8ccccd6591d956681db76af0ad93a6a9da911527a3a76de4e453cbb8430750664fd6ec976468b0beed2217def7174854c89a397a23abc8d8e4e33fb322dca329961d68fbfae5196b267d101fcc55d2007d9d2afb4ab9c9748cee1fa3a6870095f3d19cc501d34a12e3ae0e35e5f6a9f1f7ec88617723124baa961387302ce83727d3981212c7ab0b71804d202e15edc9bf4d31c7ba7cf5ac89548165ea84acf7058e54e01b4d973120e344af3bb8c8ae65578793e7f5328d4a9420783eb46d8998b3e65181bef848e14503eb407364bcf6050ba781d9b4651b728d40cb4fe04c6196acba0a3970ffb0bb805f77a0871bb8d896698434a858832e446e65db15f5c8596baae352488f556f68175be100a1ab39402ec70788eac6e9f17c3e867fe548ddaae0d63fd82810fd775b6893213496b8314e515a747cba8dcad582633dff21d4558732da7f4cc0d8df4373b4b29a08afb6a3b21104c3d04eea0bf610751945d235fdd105aee81292f60df8f09350404458a974c03ebddce775e9ebcf737893cb29b3743421816a8b2119f31dcd642d1c280ecc79b26a8c5980ed31d42f050fce3901d02936921d4792d5a7a65024764d08c779ee8f3e213f3a323216bf8959c0f584cf2d1ce2da966e9804cc5031b4fb07fb99eea96570f19d507fe26ab3981ff3770cd5a25d27519a03fe85cb09d50ebd13c13eb615122dbf2b252a39d2f9d009a72ccec7c6e18b7e181940f34dffe21c411c3c1d29ba9b03ce16db26bbdd3862a4edc35f1cd8272a51d25a4d4d09a22a4fc88dfdc6f993f2eb9bf39c33bde6b25b68e05f103d1d432c0b838ea0745556462b786430cf03c2c040f276cf8d32bd810f54d918c34498ebd2009f7033a14cf8ceec34758d5a50065a97ab8fe64c30593969c6627bc290667e9efc4df5ddda55bb093f8f7ae30c7da9ccb3ac7b498cdac43d8ddc1e82bb813fc82d366c00a31aad29b18cfb69139eb2c9613273fc3102d73c37aaa8e72fa67c850ff43d29b5d9fc42950c6f709c94367506c77b0a2aef702175a42a7616c0ff3ca18c4cd8e3d4d7a8b4aa617183dee03a2462013efabf92183a78105eceb970a39cccf720f38147952b5b5f8c5d33e41e27950a59883b892d8c5307f31d6af2b5f4e6b9bd8c0a44d6a477294fcf4a1280770c754ccf306a36acbbeac92f9d8858360f0c13566927f4c2518d45ae73cd816344ed6496a0e778d94578c172e26fdc1135ef047c68310f741923f6ec0d5211f4d908d9aade9be27ef0b28c60957da8053660d5c99d8c0c7c783f8c8b662db7fe036d09a145648df901c2f65f7a2a99642f3e4444f936021f8d7d662f65f74b42e0416484c63ec130192555119ac910ec8e275e817b7a98f1bc875a6df75ccb477b885b008dfc54ac186b6b1b08944e16efc4e12396c5806a0decfe23feb1e088bd64590a3eb3d6e4bec2950c616b098790ed1e934252dbb91b3720321bef794bef86ab63ce7394e910d58a2bf0d1004f4cd0424ab6e797a92553e6c43ccb26048089b8acebbcf4bb5423405133ea7210584fde7cc6b9906202089b5881046c8eeeb83628747ed6094754ebd5145b61f0372868b4762bed2ed56770dd1c1505760224a0003cc90c623de5ee4c11fb0173ea1899d9ca011aab3fac8d7dc2acc7afdc4914b5761325108a4396a2d65c21e1430c330ffba97a79051305e037a0bf5724b351d37c421434d6888051032eed596c75e861d7f68c1b61b409b1d099409b4fb9fb82d6144c73cce7ef91d827055307795d705560edc51ca27a478cfa674f0405e5a12ee2883d42928eb045cc0ab0532c9b3d1b5fe9e40b4c5c237e88d84d77de51f3986ff67c20705c703265fe36f84c9da4f70b9ce0d30e319a80ef2c7c4201508b305d95190b13ff8015fcb938278b3dca090c02cd35d0021bfa141991b22ad7b9d10b349f61ca169a8fcd43b620c90de24f3b765a8d18dc09839d64816512c4f1d4ab73e67489f80b992d81d4856c1bd2cfe0bf9bda34e20ea0f00a6b7bc6cde700c1f5795286cfd67be7439a894cc954a25e5402f3db9b7532648afe5b4b73a4af7d4c5521ba03e53e6cbeb51c0a168d8d851fdd88ff7430768b66cab0c5507e8bc32b0e35830ad14f7c4e54e69a979f31de381909e8638c0558880a1f8431489e46e2ff063a24b4b4e2d2bf6b799debe862e4e05b03afb69d67caadc9b42777be4a28d71848da8b06c4c643d58b84698d1eb6a736653c722cc8ca3392bdb05b73a6f1cece3615bb0a7e3066b9e9c96fd09dd0855e073e92108fc0893f9551c61849151c40edda658b0901c62cf48d6e34d8b36743f37237b2e6d73f6704dd1302e874154f8731e249e97d4cf0296e76369a950141d27057d648fc82f8291e9bbc3408999178cfe3e229bfa11aa206c9bb10aff5f06a18316e1d69cda4feef9b2fb0816323aaa4ae00ad37f7cb937e28e12761b05128a1e6519482e8ea7ff927016295e6843ebd63f7066300ad487adff952f59926565e944b59c56e792fe17feba75cb584a6a77769e49f7c853fae79a30a20f4ca3854c37881c4038192c3c86d522e86c52fc287f3ec02f895394889789f20964d575bd585c04893e599ab89fa2545bef11fa952e0d6094676911c92ca96cefeabbae1eb63dbb801279e23a1cb115754c9376a9cbd4bec8872a383e5f6659afeed731add1845f7faddbdf8fb948b0c21e41a66d90ae82575bfbcc695bc0234bdd7c864fd60c3e7b57eef01b1da81da6aabf22296b1ea181745c4dac8b5383e917f413986bb177203f1b2dea53ed1930f5330e6120f5a244ac947a8936ae7123fb50b94dcb4f1ebf90f8d281bbff946ba8300abdd0192670f1b4e920ba3baf588f618f8dac497d26e801533ee03355ee134e93878238094be3dd9292a663f60f7bbf0f358f8e6beb8d96b8bd5894fc6be2ee3b3bdd5dcea31b0940cf39bf6f8ec1e445743872f2b3d428f8065fa986d8314f7b2ed1fbcab320f62c9827b5003e2ed356754ef4eba81cc5211362838c546554cccd96aed9030eaca1e333b332f4bd8a893fe9e36b57119775870d564a0701b1e9f542f4f4098279d89c8045bdb84c9f9736113295bfec4eebc44d21038b2c2261d0ecaaa6d9944d2ee97217b3d079681274d368e49f5983f3b601315fe8002a7178a4bf9cd37f6f55c2cbb2f5c917601fc7b39a7b9a858d87e2d86c5d537548e33ed0336ceeb736d7f51918e4d46af5610626fad9dffce339ceb3494b3874c65eed400cd109a52c667351425d4a60ce059ed8c0f0c132b19cd1870fe37f01e81e6abbb2558d45943588ffb6c1f51fae40fcc1b290bd6ed4eaff079c58ad9d3c24a4fab16f0b5c09b004254ae1515ddd1d293db0380ea1afb24e6aa5b59ac4851e671413ab32eeb80e58685d7aa3d05da9df36f1c855acd81fcfd9670ce871225d4e64bad2de37e6a742ce4614fe7733e61a91178cd487a8990d7de8f1cf4be29d6d594057de537094028a8b434afb804076a4b719b8c1e04e02ca1c72fcd12131f150d4b7be6af2f7f6d1e4cf5603709611f4053951762a20a47c22525dcca261e9d8e30163d58a56c98782edeedbd5ec6bacc96569309119e21a340f81be8e99da8fce3ea0106de38da000065fbfa0167bf470cc9d08f2a7706d3e6ae20ce0e03d0e1230bb56f9971af0e5e6dc5fe8c38496974f9c73183eecd9b5e90422f02bbd59e981627c782d791c1963df1e48836a5d7374ebf3365a27e055e50f5ba973a9f4a4222e14e0cf7edb8779acd5a9c0eee07e1b07fecac0a73de6cde81962ed67df17c8c5ad33c995f90d7824cd03ba97ed2bf046cfb20bd7a173a336199e6c37052dfc6896a060988710a5a5d012775074e97c703eb5e98f2447cf7f3d366275354943ea1934c293ba8d015f8e7839fcef095f661b7c2318ceeca3153f961e58a8587d46607055b5c842a238e8b56bd6a9f0dab982ceb719d805367fad505ccf922f1812461fe141ca5e44ec1c8f8d76651b3fffa5eae6ee4c8672b139c02740f96686e47c856f35a33173f2d8d980aff29d925bb23843d11204970931e1c9c388c981f998ca4d4fb46b74c1b4ee28f1f88be73fa0122a032f43dad7824731c6716b71beeb3c2a3819e18a4eea3dc158e821776ec5ac4debe2db7a23d76363ffdde6736eafb7c677021b0edd39524cf0203b5bd60be5140314a52a9362db7d30a526ef2cd0ebd13be0dc730dc8c3953ae9fc0405a2b1b1e8bbe3f59b0b1997f0f73475fb459effad494b91b36d58788eceaafa5a65e87515ed811270e59a75cbd22f88fc4f1b89744cc7bcf11adb4827d36125cc06f7481d2aa08e40f063e2e25c9aebac2f4ef734c34ad37f470a80a0a101447fc3d7b8b638ccf1cb7a004b972e41a1909f628c0d9290a77a14fd3688821271746a905a7ba4d5123454b0a4f6a2338061956c070da211c54657ad9f571bdec8ce9a26b227e4812f8661e643b76d742b3b08de72f3394773f12a407df892d13bbe8b4342518ab75e953d378244fff773aab723be805e87b2b999cd689bbf253a3c44093f724f4217bc413da5296db91ba8da55ab21c732601b2967c8133ff36083b40ce284484e6a59b0467aead3df3634cfb0f3891789d529c0adacced0176d159c6b78838959de9e8b14280b982b6aafd69e24cff8db79ad160dfc68b51a415092a62c70d5366a1e0488dabd19c65e9b69fbb5bac11ba009d4deb53424f2f1edad2d3edb96b9b2fd44f8c247d882c9c0aae2e85b38a02f7486ae7de8a773977879d353be7aacf5d61d5f424c91c4bd98d98aa4af32419829878d14f201d620259c7f566d17383af7767c5073dc6609324eb43e3205510030ba646d1ce38d57355656dc9b385111278ecc9de0a70f0a6da72b4b267b81c7c445be77f09511d0141bd0477f7a43d910a520599cb1ef3644883f7a32eaedba8ff8e0c157de32d4e65dd3dfa7970217edfec11454dd1ee7538ab88f36de9a2762cd70caeff49c97476915c9deb3b79b04c656399843d190d76272ee8d68b53738b6957b06a33a69c36d61eef605d844c815a19d4ca4ce86e8ccbe06f78d3e716fb81c99094fa93c44f3828c93a7f515773da66deec76525f5b941e6b65489d2366a434ecd5383411c2b09c73020ad3ecbe83899cc143ba29d8abbf89fd0b9d677e37fcc73e28c6389ba7aaa411ca556cd488520be9e2680bcc0d102ce04fe80bee3529fa28e5e124eda7032fa16c139435387bfd2848acf09801fc0259ccc7c284c049c7a65e6e441363850eae06d87f9429dae7450633fd9fd020a1796a5f4fd76d33cce980bc68f723c8d6c599e504a441ddda1f266a2b9d8a17d855a7c5bf46cc0b225c7cab53f78d820a0dd15ae337c2855262d8f799cd51a2600fb4f697151da20ca2f9aa4504a93b558ed1e31d877ca3e17371835f7931867b219bff8355aa4ed2e5e3ce1fda139e49fe9d3f016fad4bef0e163e662b093e3915ed7ed22bc0f989c7f24d83f9760ad670a40a0fec76c0788a0b97774bbe0b08647b0ef4f6c2a0ad670a00f93192bcd6414b6d1612c3bfa85559edd95a305a75b0a207d1a1e54130036677562f8b95ea1eb5bb74654f133f0047d27b0377abd961d4a456732d39cdb09a04b26f818e34bf8a9908944a157bd6bcc707ff33d3e8c6ec7a5fb3f7d291b66f72578a45ba498ebd9d2ef16d3ccac1988224928fbe569dd4f5426d5efcb7b2bd2b49789bec98f22113720fb089e191838b763e90a5958c9e8dc652c2c7ccf3350eb294a93411f8e40e2b45c0b75751f762b964ce6e471d1ecf1382fa6f4d0779701ec26712510fcb1560c9dd6a7bb497903594d6baff1fb555da4cd1f67075f56c6f3f0f67a72b9525dad4f3113b9ae7a0d2a3ed49e6abeb13bb3bb4fd02bd88fc38aa03aa4c7ac8c9ba3fa46e5e9b5673a7948f1820816bde65ba646ff8d7d53c3e48f34ba42d43f3841c743829c20b0e55dff6ea8936e99fdd5f6f3a7e951e08b7497478433971382a30471a0ae5feb95a53152c373a2e7f4bfe070e41dff39db82fd0eb820158d506b5ca0372a1d2f45c18458be1462d57b553c2770ed4b9a19a47285c34fcf149060efd4ca66ff998c475f6cf0568e1f2f2b730a0064cecee63e09bc459c0cfab3e2123a3a6f304098a78828e17578dbf20426229e4476b2de085e84295d2e629007f995ab6f08d1d48f754ed86645bd92c71e54504731f8c98464fe802badb480883daa05a6b2539a8c324d2a562de4b70bf4367dd320b07be51a44a0a799fb34f892fac65e0775cd5aa26f61dbcecf0ab375473e528f6ae38a4b59c9719f7da8d87b7b2a1bf1e55b7df34e64ad21af4190fe2794b73805e227980bc6a08c7dc5b100acdb8bcadbd98a4f2983e41db4e36cac258596bf875a25421a23025e063572514671714c36ad76d4368862cc6a96f4d2cee6b9efb1ce8f1fae9726f7067e5e4289308970b3b14bed411396ef121cb2eb5d6033398f412132e3ad66ba3f49705e6907ba948a0804edc88645655518496e707d03549bcfd7dca481b22663c73a4820e6e1fdcba1171b8803caa48942aff243c5b289bb86cef81200d5accf4ee927269b612a602faa80bcc62af551d516e8da99650f025b80adae1dfdc6ae3c0a3c6d58fce1cded1d8d418402c66e819e832231630fdfcfae758a2899426a15f34040f323be8e4c06c67000d5c08c7705f90accd00946382b590f1e06e93d218204557cde0fe59443526d30319a9efa6cf7a4975c9050137493deb4f59302f9b39d56efee60d4fd104aca729e323711cbab403b0f12510cb44a9d797f7158f4022392b24a7d62206b073a62e6faa09c1c80a789c65338c5d468c59d4710a1df28e317dfbaeb7a0b6c0047e82728569c3249c06505c0fdb1d98cede1a66a4242ceac2bc6b137b974160467133db209cd7be70dd2e774dba966312663f6881b85fc48264379e83d1446336f4f6844d5fe8e78bc420b1d7575f2e512f7310db6861ca6bbdbeb4bdd5ca6de313def4915aca15ab66a813b9d46a70276201475a8f9bb159a47d4227dd290740432b52c0d9b77f20b62fb19996b27def43ae63077d5301b2d4e9ac2c52167f9041094c5b13ac4f48c230992a70d4d4737ff79dad78ecf43b1f2fe967499e3fe22b9add5d5108f074a633460ad5c97c4f673dd8063958b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
