<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d082e2822cdf9072c7d7b153173d3a54f09ab0045ee9ec82330b8ccc88bd8e20b7160a03ed34deeb8b1db6343950e5c313ddc0cfa2d00f14e726b9f19903db8a55bccd987180cc90bc420e83bdc805a1a42e22adef829e282aec81ebae25f6fe37528859bba620758e0a7f088fb8b3f3f0aa18a93bac7f31a2cba10e883e6c2e2109546cdc7b675609fd6e002e8b67cac04b953560ae1d39535e4135f9bec1fd9e55b42a57d624be12646335f3ec6be7a65071aab0513e785be3166377d2a962fa3d96e95448765bdee14db572f306125d0a1d755708e6249a9b9ae03f2a87d2cf79e94daddcc39ca0ce5deb6004b3e840956cf62d34520d728d1d046c933e830d58fd5e6c359dfd47e409d053dab830669753504794880f89b8840074ed74a6a3a284db00168ba3d97fc0c78d72df1afccc49b906278d5ca0a374687c5dba9a8d636ed89aee0f41830657786a97b97a639f1b02cba22edfe38f538e27429fc614f0067c54c4b5df4294fe2b7852ae74d069d47fd5c9de1c520679f959e15ea41843248adbf6c52573a8cc4421289d2edfdbb9ad9b55e4eb023eee5f69bf536f3bde36943a229a0a29bbe630a53f9239b86b2ffe2d0fa828ddbe3c625fb74685f3ff07939ba64dc0f265aba7c4a11ab6a342a0c14ce0efa06c99dcf61eeebff9b94d6f6593ad5945e3c79968fea2182fdeb62256129c59fe8e0f4ded23fb9ecffef9e6261021ba5c91912aeca5827869732ca225e7aa89a339ba61d457c377e6a9ec45a2767a875deaff51516191edf5e16e27b66e967452bf6230100810fab7a4e06c4027f1858ace6f6c41b301db6fe877cbe65180e7a9bf7ecdc882f26412c3ca6053e8cda3faca54b4a0b6ced038ee522cc6070ea5d6305307afb46bc96684174dda58fd5ced29dc4fba07b9b03638e2d2c7a4d25d16dbfa37bf9191291c81c7979c4c508ca111637037a38f691ebb361e1527e0adca14e66a00da409fa7f287164db8285cd9fae46aa729bf60feae3ed7a194f016848570f788a49655233fcba5d873c05fa02ecef7e84e5701bf515201025c2b4fb2ddc0f799fc29faa6764d69f55900bd3957e765139c43bcdb58042be1eafe24595f684dc71eeff66b22af24c9f07ebe3bffc2de17cf1a4b3eb739f65cdc27f781c3c7e28064def53e4f814ca3569cb7d5a6055a470372ccff9601dfde9251f4996b0a1576f99fbfe7eca8f34ca4ec2261fa60e8b04e4ce7c1c9699625dbba2922edfa540fd3a312b102240389afba206a40f2011f19d7c1d86e5acc84ee6361df5912dd0ea2b88067a14ebb454b53b5a6dd5edb4b6c7593d986263b5df1e45b39e8b7ca54bc00967cc4ac1741095060fdf953d54160809b7dad6939c1d70b4c0d4b7c9d7d9ff35d4279986d2ff4753307fba8c96fd84fec28591d590105543049f399e3f18602fae73ae7757b95f1ee2d3cae3e65be27a4465bd4e226a15f4e206e4fa3c56ee6848452a00c47da231489a16fbcd2df44fcd3c9ebcbc18aa62348883c9d713b63833cadd700de3aadae9efa08ebc2870cd575a11bd62efa6ee8235d8efd2607d667ea3eb4b88d95efe1c334eff7303a13b54ec7fa911d38ffab7010a194e519e4e6d50abe8c546e2b01905f91d3e4fdca9d0deaab80170826afd5e05c4a7319a7380c7824ff03adf2a7cba66b739dccab69875588088e2c2353d318e6a37130406feb03074d2335316b8bf5ac6ca6551b6a8de5ecfcbb7e0db4a635db8884a0ed001102173e933ee6fde505f403bc53593150dcce228b114ec6df06d7859a1bbc83beeb47fc94e62004c1b89f159e252947cec5f03e4bdca66913dfbd74882e10ea3888d94dbb7990fa74cac4e4de4a7495f662e9c635140f76b3d32639409496a71b7dff03338156c012dbdcaf98ad772c4d84f0041b212c5b9122b56f84f949ff8a0c20f3719b777d949530f03cf20b14df3b6adb3823c53d4764c80df098ae8b28637cfcebe093fa0fa7b65093329d103feb2f2e2cf1bad5d2fdbd80c5ba2231190bda489a117c9d53e1ca73ffbff92a42b2ad2db0afd9a3b49dd5b17676aefa9350297001927705cc9e47a8c24495d6be5d10791cf474b7a73d30cb270bc22cdf1b7bba59bcfbcb838286c550df5fb62387cbd33c13747edaa2f409a9f0f79738df8cfaf2e1ce44ec8f971404a3b747e35fccfb68c495ec195ecb39762fd6997f22b41187e17f6418fffa778ba77635c763e9da0219520c6e5d50630a780cacc1db5e1c7efe82a165e03eafb5269bb08ee812f04b4264437de057b2de28b9895bf6ee03fb1656e11779d82fa065accc861c0879b08c9f0ac412b0d5d2072822358031af48dcc16fad39dcd1fad61153df747c8be081091bc06a8e054f630ebe4e59138559e6951852de19519829f0d02ad7842b3f108d005e255a3a3ef3ecfd5113d5953989649ba678eab25937d55e0593d4598aa82db19508d210d8bb1699f1b9da05dc4ea70ed7bf5a085bbaa021e9063fb39d3d0841f79ebf4403251639812ebd2518f0f433203ce768f885c1cc9808e5cc080756221f15b4f4fa1610226f0176dfa1f68ad0ae074066d9b32d4aa994b3223ae7ef4c131b8f687aaa4a73f2af30ce088e9a8ba9d90b1328731fdfd391a3490661b167a97240e2e975f41dfbd30cce68a29c62361321545d395fa0ab86fd7a393ed947e2e75ab28912b56771e1fa02ac68d721115fe2b4f67f409efb2a33988d753ad6d95098018bcd727a6a35e62288dc7f6d526cd6e3ee8c8d9a2dcf1d96ce6b0e6a9a1ea93ab53f6e4692d8fcc70bb5e8f778b385642b62182e9d9ccca9fd2cc1d8fedff640042e739305b1ccbd2b24a068437b143bd51247ff8e21b3f3e05a6564d2ab40994b6ff878b731d2426611af1ac389bf2305646cbd7936dc1acf930600e19729cf776abe01397cf81fb5f7849ef131a2f2ab79ccdcd2d32a99ea27ef25ff3072e17b5abcc743d2d5b2f9102c6b7a5e4a3f002a8516f2aeec7460c77962bc3651398f07817634bd3a65ccb63a7cae6dca4fe3c95226310a00abc0d94ab771be864c1530c06be21ae8035cb5db0f0564785419f00a9a2898f5231fdc5a55d77b22714ced2650b6657cf49ff80867acc7ff90f8f333b2e573b634bc31f2e019e88057f1da77a3533831c1fe9cc18d2767f8b4b036afe7c692e1afe8556b5b01a7961c4b7a847ce88051cd61634b0709a272ecb656bffb726aff95159e190a48127d5a65e10ed003bfeba38e7ce80b61d522c1201c96de327bc31c3693e575cfc21f296d4c69609fdb19b861c7cae19f1fc7bfd1c5b899aa870b50335ed50e9e68806e4cd8421edfc992f655c9bc49a3fb7bb50f8d6afbc6932ccb419c7ff36e9dc8e0e793aeab38f1eedc350b088263114085b7dee7e43fea4e31f246e74a68517abb4e833b2ba8946a04816238bf13bf611d9b7e73107c598e2ba6cde5ab4232f5cb4cd73292f73468ccf598368999733476c3e1558f290ed285f72dbddfd079c9e8522a9e11e33441a930976192ca158006ef818d891782424a5de332a4faa14f907a49c49504ac6251164142b325d06a1182da5d23eca54c4e7b512d6361468135e457bec87cc035bf701f26a1120035313d116fc73fe30c9c1e8f34d4333823b4cece677d182d19a96ccb0ba47e8debedf62c03030e741a27017d1e7300ed62fe4a9573cc305760f216fcc0e9b21d135fd705a5fe493d4d6bb8eb69def53f1cecc51a863459252a2514a3580fc68e2ed10cf1d45a3160330908c51f646b477327725fffbfaca97a7036096469e56a7a3ad81b9d6622148ecd154f6cea097b5a616dd0700252d254058d23e27e8fe6952364c6b50526c6433901f58d0c49ea9c27df4c0daa2f19ac5c85950645075890dea25a5f6133ff5f0187e3ba2fd212b157ff8a84e9eb50d8e55d953ba8ab372bc0a44185a4628d18d60eab4297cabdf0a1fdc4edd7498339ed3e07acacb1dad6db2a6e2bec1698e35d98b41cfd13ed048d675782f7cc1709b25fd0f37430dda477f6ed737c0d9a0b322be85f382848ceeec7a69abb4f8e0b642302109a8d565f5bf237ca8b20e6d5608f64d3ad72c23659330796bc00b76382db391314950262c64cdbad9f79bc7071937d06527574e0c2226910d9f2b71ea8e5a93f9a1371819787abc2e3950a39bb6e67f0dd6f0f9376046b6aa69acda0119124b28c1e432812d6c870133bfbe10c2db7e999a5328aa6dc9a0a74ffc4e710048a11c13852f242f5780e428c0d5d6639df51598f38ee63a870bd331fbdd57d99681cb89c7a0bc5c39886001bd705b49dd65417f9305360e5a09307a79eb6a0313a7f4b1c811378bd2ba1f519274e247d946941664ff405b318a3dc42478f875ecd9d1f2a4b66216ffb7d6c4c79410d788dc0ba96097d4412cf6b382c4bf41bc4311fe75ed9fee65d85aa07f4804a92c938636a3bc37281a84b05fef2d9969ae40fa85295cf6fce09e3fad360aabfcc634761e8e06cf79bbfc2de57da6c82f8ebe14b5bedc8c97476a2ffde727d062839f41de7f96448cb3573cda1669f96f17ed8e57773cef0658d9b543d2f4e30df9f19ee1f2940bd0e7ad61d0e4bbfcb2c36537343764a86981ff9addc825f48320daaa4546c830fe307213cd6f4af56219a025b3f46ad325ae7927bad3b6b18322af42982ca5d71dafb0d45ff8cf6d91ab04fced7892abac8a27d28fe78c8690e1b897175202dbe71f4da4566331d6317537f441e68375a331b2482522c786933dbf57949137d65a435fb69ff429af5b9661fcff04dcaa05eadae5ae1745d109333d0576212215c7f6f01a248b273282d58b1da2e0743385269213df9dda320c0aa23c72db49fa7cd5655ea07636df9a6d0cdaacf7cf03b42ddacc1eb8c1ebc10228e39f59932d557e9788029c0553ecc5106810bf789d34c840ca86f8a6c09912bb0f47d9e096aecd7f6405fad4488b504c92d18edee17f43d4bd3db7d19d65639e803dda9d5c7fa23dfde8cc46e45efbdbaa765b78101d9742907e549b101caf72d09612d21854bee9d1d13de583257b7df0487aa18c53abfcf6046f4d831321b1ba94b32d68d9c8780663119b7396144c347351816e07fb5fcc2b98cdaae13b5186d28eec00a3763e3de04acd7d6ddff84f6ca065fa95d7c81b504856f550b356d19f64ad62a1e237c86a355f35b2783bd970023dba49ae6e82eedaefc72dddc081baf09a9505c332fabfc18cb523159d52d6ee8e0294e41dcb56cf9bedeceed07a62e5d94e23e48248a718478a4b769070b53518d63a2ef62861ee9b11b807d7e278f12ace90c077dbf73d2e2cb98b2618f5aef1da340f890601a77eb955577ec735d772364bb3d48ce84048e54d642cfee49559cbda37536e96914d65edd22cffbdbcb489bce806b3547b6ba637233b33445fdb4a926ce7f3fcae3e5a98329208aabdce09c723b521abd08dbcf4c8de282ec6535ca4bdb02888bc1e5a0a89287877793a059b006ee13bdc9e8168cc95965037bf47e0f8b9613cb655d2deaaf39428dcc74f45052605c321189f7d8799e8a6106aa70da5202a56aa3218d0449e191bf2882a51582a90b9b7708da5b67820705f5e626850f440bec086fdccee45e3d4a710567b43297e409e5aba84228fa26187c9cf9dea07a92611b1cbd262a22fd02cb8f008d92ba726fe760cb5837f760f8a1fa1b533918e06202c11dbb9461e914e965ad227b6d736863f0979d2502c8ff53e6866b2c6f9e154284520b0ef711d10b7c534a49148a0ccd24ae08c16e2aadd8d8a63748663a29188ff7034138e6beea9af718e131cbeec4f4dfc9e34d5e080f612ae647d4dbf3c0d38ca89965461cad6850f9fd683f8fc96ee3ae4ed550da478815cbb6aefe6117723c6306144cd9fbd79c8c64c9a883f5f00ad490298cf8a85b6bcd32086737c9fd17b6e3f8f617cf8b0700555d462ae2154d1710ae6753bdd7a0ed5eb4fac9d6c0f25b3eb87d794ccafdb9d38acae2aceca362b47f774bf2ff35447a08cecd655129da27374e67f84c4fcfb329200267e884502327fee89c402ede0c39ed62b8b10e0621b5eebfb974445e69a8dfa4acf3c5fe059b5006bbc58ae3f8a987664f2a75d16e007bffeafe3872e595a0d399264c15a42edced8584da341e9b5eff0557ef1c1cbad01d1616857dae1a64cde086d50c9d32354e1e0c7ab62354c53223cc4ebed96ffc4bd6b70f696dfd14e96a1c17b62c1d8f02f55efe19a6e9f85edf402b2710612550114617d2a54e3ea079ee21af2f82988fcae91f84e5efa23ca8b3620735460cd02b14dcd21206abe654430d9abb55c3f14c4dad99a9c65ed66bebe2ebc8ee4370ad9e896422af56992b3096629972ad54278f8bee0ba71955c8c57fab140962da1314b375f2685937c5f5094127947733c33beaad75c760ea8c01821c19f4f0375961ea82572f900d7f0c0ba87d65e7b904535a111a240d6d024bbc4174050f572849f7e4b27b8a1dbb1d40469ed74f74b4261e3aa13925a86adcad0fb1a20959bffcc226e8cb776621efe056f9c5b42c390eba6d1cfaacadeac0866b085dd4cf819cea9f6f6692115982e90aa62e13f5f20f578e2420c2df69dbbbfd4c51494bddde98ceb0868ab8c32ddf80cd1ac2b62a23505184962ae02f7ee4f2e13af204074d9aff363adfe94ed0dba3a506d49cc0cd39689950b2879cca98b4cb06189bdb2b21c362059cc6dc586b9bb1d45dc132932a9799fc827ff7eef24745e676312038851285d3f040d8204133d203d200da9fdff77ba8b4a0477a7e35e7aea104dd5b7673f1cdbf7c43da522056ba65cc703986892b0fb3e52fdaa6ec8aacdff12a4ee0ec203b716c96aa20fbe503c1ea40700a6f8722f8fb50e1d7620864ffd489f2b310c6d683cde7d1086c401e2674fcaf835714666ce80142d58b9741cd61a8355612eba899430d00bf713c31dc6fbefaba39be616c0651d886a79c9c6b47fc43a3da4b707cde7eaf01c4f4c0ce3ec2ab407564e15ed6f76b356dc004048975a024f960adf8dca54f21c1e5e9faddd819cd561c248f923dea4b31667aa9fae79dadde7c7c4f85999e6c0471c1390685444546f90fe2d78c3a799ae693359707c1351156f28e7d0c42fca196ec8ea62a0ed20da6ed4a10a85fef4803c2669eb6efeeed08278fc75260090dd89497e7112f7f3191e05448aea757a3e23da454791d06a62ea3fa55db4796f1e8bbffb580de73b0ff2de197cccc820f30ed3eaf4831a28a12e6504cabd663514ae6471c307e0471eabd05cfaa565dbadba2c35687af4a7a1643484eaef67af2c80a79d136c120ee1f410ac022c053f98a0e0471bc2e56f0cd15742b36ef7c65b056020fe6932da66b190de690d0ede0fdc8a996db457ff592b67a9ad60b9678217b7b0080ca669d1ecec719ea78a0a4397858f5cd161071dc3d1dcff31499767bb95a5469686609f1f48637a2936491bf43570de081a6c88b236bc77668567d66b3fd8dbe55c82afe8036613c8009dc9f9f303492dfff0d1bc4895a099c562c5e3842a065562f2e181680fc209a575b3a8cff94c563bad24070aa952c28bf8c6e4d65efb8cafb4283c7e07c70fcf9c7afbc950194e2a63cd502603a05aa04a0ef56127797cecf1e69a0b717b770f024230451437bf526221e0231cb9df391c67ca8e0fed1f37a7166f30f0d444a5a534c7b7fba2084a9f979334c42b8d0f91fce674ed5e978202f7c99eb55381f9b65ea11cbeb7a7c3f104779ba9b9c89cec3a9d90d9703df9d1a6d5159707d7377f86948277281e45bf01db252b63e4748fd5cc6e6632119f23eb95c96d7e571d22a36013ccaa9ffbd9706fbd6f12587c9c5d687db27f95d6ff85f62028fd489a054eeb9726df8eea9e430a18e405eebb085826b73a4b687f7e690f2febfad995c7db9a1af24933b8fec12c8e532c4302c6d89728aadf7ade112799a1ebd55966c521305e18f6d7945d0b26c8329ad828855abd8ee14118fbb8bc719fe5c04473ce630efc91b07fb82d627a0d6da6367d8b1582ae408e55eaa8b4cfdd0e33a1ef4013dc37a219ccd90644980dc5853abf7eadf301cf2da7c7ad4d9322718f09fb4d650c0318af291d7d470b40eeef8d0443371c14352351fb4986970ce84fc917f7ad4178d72cdbdcca378d4af82fd0ff217d8b50b2fb23f61ed2e1c7d4f5e53926f00bc723a87f627c1b6beea05d248e1fd3bacf5dc66bf9139f00d69f7fa9f38fbc635bedb539b96fc4437ebbfedfc983172c42e9c0007e0dc7ec67c93fb4f1a55a5bf67d3201739958f920ce55a1aee3372e85ad5441f5cb93d3ebcb547dd0973147627557baeb76114524da01cbe933175c78c691c807bab5b427d010e68ae816a3efeea0d59fea053d527036ddd58d8fab378232cd5771b058797771fcb64ae98a5c45ea1361389a6e45d2a030aca4d8e5c8d7bddf429c60b0a8c83005f9ff94c233319302274545c1666feaa1721ddc6f0d12de904d024fe03838954c417d5294fa8edc790fcb46f832daad2a371a557f9fe966021b63f359a12ef4b084d55123b40c671f1d4671b5762aeb6c32744e1ad886296b2a5ea2b1342866d95c280ba605e5e4f9682fa7fe4ded7fcfd0a0e792a0ff6ee01d9500bfb44cd1989b40db73d19e31f87a961581e9d647719a9eb338ee475d68c593e7557c6ea02afcefaf2b586ceeeb77fef5d54c414170f7aaf0fea8e8bb5b7595469818a0da0032c940523365cecddc3a848675c49f2c75e0b22b8b13a7c4e9df409cca042a18d5b8a7e3810b6f2d1781977653155a5ec75400999a8b3f0251371fba4077e19a740abba44822f572a8a928812036fcf385a9c439a5ee354a8a6bcdb2460fd95bf7280eeb3ef8e315ee2006b73305bfb9133d81dcd8eae54df23116034ad62c4c57d4ef978b085936f35b4be2775931ecf6e73830eba2a0a74f7e60d873fc24c52693bc4b83e03150c62029f174c69cb01d5626899ea7bbf7d9b3e26503da08b536bed233cc2defc9ebbd64641745b9757cbe0fc9d1a911a79e0dcd19cdf1834a4a796c343490dc4d366f62c34795ce2607849b4b539bf7f0bbf0553c9a9776f8d5c0aa497d76f2f8697cdb425b6759973d532115c22e4c4f0cb860f18128f6ea0aac1365cc0083e01ef8fe4055d836f901f2bb10666b857e1640e58b5b0cc856ab77e635a95f2bb4a7f80509a4cf460373026115e1fc457529c3262f56e4179a39b767d092147cb6524cbc5df652f7ef9201cc4b8bb3a9bb027f0d9e4cfc0a8308d762e6fe98d05ed990b3eb31efd06e895a7e7440e740a38bf598d0a57b14c0cec2342cc0c9bb51ddffd1720697e201b8be6d5ab86c1ea7cf7de8622ae200ba7e27b9ea7c49e8177d2a784caf0f3209266b72c0b532890f7118e866bbe4233bbe5bc73bf0afb77e66af180ef2d164d24d5b9276b5ec09d0fa044833be90334cee8b87a80bb4a1f6dea47d2b2420bdaa55cd372e87d6228e7c11f2e069cce17b834bfa4812b308cc7998cec1c158efd4479d0ad3581349e18331ce35138d5043f3872ede4f1dcdef771bb819cee54ea842f7ccef0e8473dbe3482d385df521d125ced73b70e9a90580a5b6460d53881534b3fd524c8c0d38ff203c308cf7bb27b1fa980be703bbc0710e58f48a5dbd2da325ef3d21ca7761a516cf6609957dd36cf4af1b5599e0111b3d0603d8647e09b436e7f0f1ae04ed5aae193420db95e9703d631eaa52bdd11a81754baac1ab8035c34c2c2708f7332682def0565a9466330b2be2aa31563765c47d0008c380a159b49c93aa3bad3ea4e8bb192094bd337b2f161da7831e7db7874053761303fcbb3d6551981422bc2e29eeb52003fe2bdbad9ef32e37e736b62c28f2d9b1dc7aeb569580cbbd81cb8e3dd890d1accb522a86b963c88499fbf9be761ba59cbfdba9fbafe6ac0c20796f1548c4b2b4b8f937602a7db8d498cdcd839d2d8843f4b5a138125f746e35435ff3f51f142db6c224b9fea2c03254b6c0f61d2ac4c4cb9d86e224af91d34659856e29a2c35d58a0370bd6f727034093346fcfeb35592348c828eb6c4a80152021fa6107c9573eeaac62cbb79b6dfd2ca62970657e6d14ca5b5fb9c0ac2dfc66c3793db0d84208efb99be33f1187b98bdcca226d0c3caecaeeb34bd94e1c86225228f9a52d063a3225dbf985b7b71187b43ee63eeaa284f01958af9631978623724d4d2ae62d57fc92a7ecfafe7ec5d63750c59921c84e7841a5b29b172264147bc7274c231f25c04a31f1f80bd62d13496c9c6f91205bfd6593406abc464603d054de151bfd377c4db71d58574bafe4a51cf4a795ea053dbd1af1326a321e7657539452191f0f7c0d9f88c4afde6a2db05f7bdae575cf5ee9683cf485c8d873fa1726ba95eb13a6e67867e97251f4fa879eb8acdbce3e9359ff34b51db34adbafa44d7ba7322244258abe106a4e346c44fd072fed63d1bd4bdaf1c309fed5bc7430a5adce2a6182e98acbcd7b0dff2a20f0f7d97454bacd944412b919eb77deb6ef24980b5d998a30ba45c450742ef9324c2b81cc9dd0db56f0cfec8f69e44ae4df5f1ab6f44212fcec2745e4ce579fba46904ec015ae95a5f3080092b283b68f1c11e207fc92eed42954c65c7f55288722df33fec95d4cc29e1299d5777bcf8426e3c0aeaa62857f9ad3ba4669788d63dc60ae212ff895f00c5e2ae56585218c50e08c0463cfd5e2b9b6a85ad66abf1d16801745151101a4f1c5d78b2109f6125ce07c9f00e02101120f4247a0a175b1dc2ab0283b556aeef29ef4d03f137266c5f4d5b975ff8cf6144f0145d3889eb316c5324c609a9e0d3d81eea3148f28f2f54c8b2a0e45e640807eb24d8649131ff639d88fedf335b3551b5d6ce0aaf293657d60305cdff086585582a5a5785b7504fca0e3fa9d04dfeb8536cd7d5fd9f448d03c157f6149370b2de249edd8b9b13e54527cd4302d1326e7a5263a41c02e91963edf2775e602a523db330333e8cf55768a953fb625f7ec4148a44a7a6d2446819dde4eb47042d06f9b2ab55b879b5df8098b799c3ae0df8510adca10094ed594e9736db0ec0bd6b0ba6954659874c5f3e3811728c5a91f7b0f3f9ee40e1b81a89b0957bdbc63a0cb85cd15dd32c2b74db4d68197b791cb2bfb8a01cbdf2e4da6880058f8a94554b0901f21b50898427e96ae1e98b20636db5355e54fedfcfe39b107f5b56c31d737e10bae0babd5c9299c333aeea2d9452b8ff3059287efaded89a86ad0264dec803e56917f4a665f5baf0fdcba60435908d870c0f7a8f4341edab01726c11e7c8bc769bd0c9faaefaf8abe738eb03ba10361f444aed62037f522ae811b6d6fa44272836afb3383185ccd64495cd6e2cf048809456ee66a5d40028277fb7b3e9068a5b0db83e2c79663137c63d8584de1375ddefc854945ba8d867d27f93c6ed6aec44e412b8cdfa9078297db794debf3276e02e64963bc6f4e2d04a37b771ee6abd9a059ab33ac1ac0181cff9cf7d5eaca388dcd638f10ebd9f859cf0e761f6b180ad0693e0dcb83c858926316520fae3ebfda889aaaa8eb94f637c5db659a0c3ded0355eea05bcdbe85f52a872d89ab042800039154793f8e74c1c2324f3eda2f24674b5188a2bc9238227d1d2e1736fa00fdb8220419cd447a0db09857c6f4639e2e137da24f7613e416fbe78596ff64385e1f5d1805572699146d5d7f901bbf2de162d69c18f622b1521b24caba5fe4819cd4ee4550c3d49dc52898a1f31c986ac020372fc11d4c8e893a4b8973066362160a9a78b602d12720c623d56365b7621b8f4be890a6baf09f5a4d4f27aa6842d14b97282cdb06eee14505132f3fbe48dc4551da22b0429af29e73bd9b480fb7e2f801802dda36715a4ba3c7a8f0de048e80be16ecf5bcf06236e8a605a108d8ea97740e0471333aa6e702b0ca6e0fe61202ad86a56d1b9cf3099255d2b22c7e47a546389c48f49551d47f4bd7df8bd8a3cc0cb69c8f1fb216bbeb523422e5cc2ae0ca23f243b17da5cbcf01aeed54e3bbff413233a19534401771df8becfef967b6d9e1e900d169d6b35b6f78a838dfb7bda63a70c1a9e97a28ee241e92261222ddc9aeaea90d2207289555cee8e5492a200b242aa11a773aa3d0211762e03d430abac7557902ece7047c700762c53c46025eaa4da1ede176558c2303e10676e343fa7d69345ba35690a9320e161de45b1fcf2f0b46b37604f85c4335dd21052aee6c3879fcd97395ee8c808d4a2ced015ad207be182bc922fe66f931af22871918f04217f145d77562cdcb07a246efd44ea0e12c9454537ded5f5d6de1086adbcad2cd99645dd75fcbb46e2484428ab2b596b74f47700988d95530d53ba264447f07c4006527f23def66a6f3c11ff1946e8eb4748cdb77b82a5f9eba37dc566524d9b6e04ad8fd39a2daf0110e3acd0e9ba0ca007f38f26af930f4f93810b7bf079c455a69923a17855b21b5fad1d8b9f52f9963f8ba03e628b527240453022d201ff5cf51c50ea3b8270fe9d3b982274c75170ecf49d111b5e89fd6ddb200fe6f13f1ab461bc3f785ff8e99b8ad54d152be141e28dfba9cbe23cbaa50e1ec039046f41226d60a57135163fce1d6d129c4df3cb744177ff6e26ecb6120d5c6f1295806690a035819fe72bb4231002e2a23fc388e2ec58ae655142c69e4fc0d21203e1af567912fc56d26fbaba952b9feef13970ca601b4b57fbd9dd5ba8d9a93e6f10e5dce75e4cf44d1d4f38b9585aab74d265154a6ee06a3754cf47b1dc553cdfb5aa1328377161e9eeb4deb1fb8eda7b49bbd69b8c30f6521caff21f1f3a082c55293f637bd6a2c691fdda7387961311efc28c0551c428457ac75f87feb90a420ef66ce3d4f832c030","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
