<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7fc9cce07b15b0dc852fbf5c3219a825cd18c5dda71164bc75dbab0e63cde76350928fd463af161b7b3b69575ffd69d61cf9fe68c4f703cf092050aaec9d59b11998db38cb114ee7203ff52d9c88307ce95f34fc6e8a64fa9e99d8a4bd1dd110942cb83fa66ef26af01648e531f582c8f6532386e65b57162941ae06ed3d0cc22db6a159e0ad0932e172c76d4ee9dca6bdcee34daac6c72316d50965efcdc532805946738fed49c784737a919b01a2aef5b89c7b05a54becacf50a74b94bc2e3e4aa0381f89357f840e31432c83ac2b2c70377ce4a5bfee259b5555cc99219aeba7fed781ee54a280b9edb26c0d64601c6abfc40fc7cef9187e0d2445d486b04a4d838e20dbbf94622ac4f294988b31c48c739192fd5f019a7b36bdf9989334ba255cc3abbbb6ac251de919239a39a689e3a695501fa8276c23bd64133a025a4745fb0d7d063d8ed1884324717506b73106088d1c7076c53a8825d7e01e184eb8ca24632dbd285f29b6bbefa0a7f931c727c2d38960ae5df9eba4a51b7b3a3fd137dbe81134f419b4eb3c6b6d1fe7fe9fe9f84a7ea1bc7ecd431a31295f4a15e73023149e63aadf1f663cf323d81fa80ec4cc51ec425dfcc121ba2973e759be1b99a8be2055b9f1570c226f4be87283d7d207f6696d3f9e8edac3ce2f53736a12a56023e537c5cd26bc2de4e723d4dd1389e2ba8809c4e98bd4ff4b8c1b24ed3c07680a97b0de09bd76cbf14bec2e22fb46898843f478850949d77c5162b51cb0b8890e9b72f9db0e27b84d07f71a6da70b3539b33b2d8c375a606788ae3c29190acfa21ce0995c584bc5617241b23c3646f34ba1d78f65847269457830899736a9b5fb921bd9650a04c1ba0c54953683a7b5cb5d85342b051abfe984a33fe3c204e60762b7e095172bef729b1a543b81471208d853a32682135532b1c0bfe501b9651456837cc8797c634fd3c95e97daf432c279d00bc7958fcea5cda43b817e2c6f990c2ff293b98ea91364ace5a3fa8c073df663d71aa78c5e854dcd47e39ad2d84ea0cb3d83e5eb56f933349370eb68f50235206a867e4907481ad0d7ddd753b459dd75646a36d9b51a2c2c08b3fa06190bf414275f4df5b2dffc797c14bd735740bc29e7cee1069948745fdc792bcef24a4e26c8705924ae3f0ac6e5aaf855727f56a05ceedb123b653093426951284c50a8eb9a6d971f50ea1934c69e2bbebe29a0665d4a9293fa9befe6ac80ac6cd24cbffa3b01c7f01230ba3ccfd697671406422ba067d3f42cab4a9615ccaca3b4f698c87d13fd0552611fca3735fa6a4e06412214c8f183ecf70c11948d70d8839c9d5d0490239f63b45ad8e6bd98317a8d5a3a8721465686ab065d9df02c0200ec0f921dcd546cd934afee349026199c2f0be5e9d3f2bae03b8d1e7c6cd597616051c99912c351bc1b90dbea0027057b3d6d1e909841c9b346b682b2b72fb391257c6188f932f0fe5d40cf4720e8571aeaf1a29122fe8d198b23888e1b8c82a8ebbc42ef6fb99a2b5f773b6c94f61a08f3a0302cd422d8e1a1878c74b036c4b6138266da800d39250810bf11441bd2b25d15c7bd70d87e0ca646caaab00c280704c40bd70132f71a9ea3ebeb698a71ac80a7236743262d2cb9bca2f5fcb85ee2a58a77b364155cfea76a8bd27320d1901016c4e981167932dd58254d7738d2466882cdddb3251642efcd6db058edc57052729c22920c2df3fd0105b441a19892705d972d1fe3ba35fb100196d83eed114e3d9e146560134635352af89561539ac807158eb1318069aa61bdfd722674edc3313f9426cd00c8436f6f898ae4aa43955867888afc859862aad583037851755f461bb53ef04da68478bd46a0a2400c8cd8d33ae24c4471b359f8dd5e2268076599ec5adf6068a72dd8cfb3cd8d940e97223fa16dab907eaa5e8e952107821fb576ba4808ddeb19d4281ed5b9935d4eb013c0e7d47a91986bb109b1243409d7ab72798e38997a103ae45a04019bed610ed1bfbb5797fa7af43ca0c22a461399de186b80047b0f3623f73c02ed0f6ff54fd1cab41fdb389868f8641b839d8b778fca778f1951bbf56263241cd1669543c592c3674a674b575476531d1d3cf8b5782f08de05d3f42e3f114412bd4ae0cec9510883461e276950c4f81d372de2a1530020abd80ba800f67a19065497107479b3e9499a256f595fe88a7f96454a2e64137eea71e8d336e621c41513287ed0efc3657f971001dabf700253fb297f484ddfdfde152708c56e37f739806c2c1af1f6e3bb97d711ebc8e3f8a55745dbab31561ba83527419ab479197c5a3ba5cb25b4e0b18d0b68f76d0aa20cfe3207a91937857bae78a092ad6b7b07d90472abd71d9237bb4199ed0ff7109e166b4a27f4584cc1364c1851242d5259fcc8a52fb778b778151a82d5f3e93f84d6138972a1c0754a8ce04a913679f34aefbf7dacb5ce5df6e2876435fc85ebdf93629318bb07e893ef3567c81f43e934cd5e8953712d6c85376f26874356d99e33cbdcfa45921262f85edd7bc98bd71114828e49c2e5462540ab0b4dc198038d82271c5b93ff77884f6c1e029115947639996785c057093c5515534a0be8ce0269f77f41bc82312d6e6f28b59079f0a92426f15c1763ed69efcfc46a910f4e300a1456f0fb969a6a76663dfd5f1c7edecbb71ef2b55a3d25613ce24c4254431e116665e67883395e4895a5d5afd19350a95b1c206ed8de67a6e9b590abdd311536279e00518794b06f76ffbd02d37a1483c18289231cfdaa3f2f64903054e37ad3aab3a906d60d3a67b6681cc2e257168786c4bc03b53dad6cde6e1fd79ebe3594936e6bbeea912c0d945d44db92cd5ce9a5f253f8ffee98a86ffc20c1500b3c1d8d30beb674235b8b4d084044783e3b23ed2ce74c027b03933cebb2abca3f39dacc95ba8e0cb7d6648a839050af17d52a4765fbfac45c4402fe769b302b54beb06e78aa2eb58fdbc3cab0d7cb4bcfbbfcfee859463026ff34c5889ea382a2605d769c5a44ac863a881c68ff244f62a14435e074d0d04049979dbcc9e52f6b62ce25d21aa01466a2f13a7299911fd186e4b84b0cc4e94c5c73d9265e1d3aca4cd4e7720d3d9f2da8926ed3d299f85844b329020fdec3fcd474d150fc8b304c4f58b436d8369fc4e829fc0644e11ba5a4f8dd2a23096c81fe4781748f305464462f71614fd1d2d542b0886de6e82f7b33e7fa782ed089374e8e6e9dde2d1a44d7bbff3737717e775e614548731934e81aa17bf0ec3636b14bb6014c31a56248912297e5e15901b61cdfb7245c1a5147588993c72a458bf1b6d87f652965bf29ca4e9c129a974300e0944ac61cce9e27fa6e3c1dfc56cb06f480aa6e8f79d8c183085c54d508b015d30808665e26df1b246d963fbeef0cd6feff2eaca3c1467df9076e5f70f17da2a79aa61339e0179cfe6f9f9e1ed041aca4bb07e45b883a3474ea8cde491ee2b72e36ca3d43cd86d0a8a07015b609064f1428682dd54637e42fdf7b52d0ad340efe73a504f974de8ffa60ade75ec4ed263370e267bba498898b090f48b959fa78388c4bda60c8181ae36168919004517be51da9187b9b126616f92e18a13d25e781138bc4adaabce37bebacca15b36665154c051b88dccab0fb48d5e0b168d3e681b181bbadc8510c139f5380bb8a94bf507866744775bf6b64f3adab1bc940c2a3299a9c2b8648fa3dcf6735c1105b1939712cf8ba2988391a321578173e99a4bc5c5e49141d13ca172ff27d9180ebc31fb8ae6d5c79ee760ecb3df264d31230db1693559dd33401cf03571b58adab19d80229d194f75661e76ac6699359d6addd643b74fac344b93949b2e69fa29dc509cfab2c2f64161c3e0a85f5f31752b8e4d646d597d5130c7d8c659eaead1344f29e41f2f8e90bd1709f0833ee17bf6119f84ebf40c332879829cc9fd395d423dc249d18eb25aff15c5cfe61de199fc297093950aba074904c33aaf9f23ada4f3fa040d3276e9cdabe417b6bdc9062e5718b1093185fea88498ec187219ab4561f1f0fb64ac072e073103f0e9c18daf3ff6d8d2eb45310063f3a5caaded7a00cc9cb3556dd084dfbdc1cb7ceacbfe727e554b8b9381ff76a5c35d7be692845c2dc950cc597fa08ae0e7980d61394c0dcb0ac16209c2f2992d12620fb0765318f842666ba47e333adc8bf54d8a4c767069f42802d3991f5149e8b56c805aa33c6a7bf9a5aa12bd2d05c98cf43d4c145db9b9ca82a13b3ceebb22eab0014d93f34d23c9fe058f32325e6cfec42b55cc8a9faf89bc2bbfe3527c493e1fcebc97292b4762129d7f2ebf2fa4cd6047b36f7b3573e110b71b9e90e3839facdc27f218f6d04ab676cbc95921d691f11cb02d66508c6f035e5989872e5fe69690640766e8ff32b00fa8dc06ef34919bac73215eca3448ac192925b776fb8c382f5fa0c4c9c45e84628b8c4517fd0f8a4abdd4bb6ea519b9ff6f7e2bc6fba0aa31412ea84bee8e366d2c27d8acba088f0bb27983acdec1e8b6c05ff90f1cb2b9a8cbb09a7fa08ac36ec06cd40f742cdaa400cab8dd724db73c794d8e396ea96cbd8d410e6af2788bb23aad91ec16a98ef5ebe0c4530e04fa7e499dadc3b9e21bfdd86072ad213994c4839b4193b4b15390421d4e4f338edf0112b2e8bd867637944093b88575d9191aacd6236ef3ba1a98d4f8dedecfcd2c13c6b3e1e595fd96af08ae0f7df2b3fdc6bedb948d1283eb74fd129c3031cf00db5d593120ad9be9af19b48b7a15c1d1c535c7c4ea89f4bbc48eeebf1f67cc18a4ccb72ca7501c809162ec12840cbb4f78d6c9cd66e6abc139d3da31bc2890648c5b12fcb405ceabe0bbc764ee3798c4ba94dbd05ad2b6f8b40da937aed1b9b48c963c282442b7c77817ccdf486a91a7561f4946e6bbdc460839ffe5911bcf175bb0ec5b47eaf42e1466df6307169da7dc91ecb4f51efc846fd3eba98bca9d219a4a0302d7329dd5fbcb34b92eb915b1b3c9e90413bc9efb455bdc8e20afd7a58710cc7dcec8352ce7223dd3d5f59b05f3744e831417bb80e79c4a00cd9d237228c18febd1518ef81d58b9d071d3e692f32770219a64ccb8aee67c648a75ef724fe4d67d392815dc55b361b36dc61f3d25aa8e42127ad6f50a0f3cf0460960bf0fd64b679eb732f5b68255bbf25d223d3c3138f29b5e7a680cae7cc704fc24c7d3db7d77c130009a89aac37d068d52f7b18ab75817dc087923cd8d4e6b2a77cd8be3708dbb23808019e6b39ea65bc3ed53689caa6bda5575954778a0d28ecd8196a2ae649d76582640f7c2c7b227c90ff8e2715e7d15361524b5d5f18acd698314134aea06191d097ed2f6dc2552a6e9237c2dc411554f846bd8672898ec37da5ad0119a52e4e1ecfb2cf120e0ca19b63d1d14635864b1a584764c12ac2b841c1f8768552b6ad0b156522091f337d43a784147cd074411163a770e23de402f981d6d720c05c45fe3a0cac956d37848713e05147409f30905b02c45ef717ea0b14379494cdf37ce99c1038cacb32943ddd370de2f8df16eea3ed479083bde1f0c5f3f1bfcb80cbb635b5192ad99e7ef50acc2a738b20591be1265be6a6192bd62b6d31a11be72dc10665ba62639c71a4fab45e6caca6a71fd67614e3dd72b8dd93984834322504c26298fe8b112d814e4111b1bfa4017cb4fbbe2176b1c9cbb7b4cafd1ae14de29c5e658583dcc12e1dbcc853ff1da014af32f973909080621b683e96fcd82e4d789251da2dcbecbcb4f0051186025c5b5587ca12efe9a5b5fee43eb379b160326871b4736d397c1824f763243af3ae1fc2eb44b8a7c4bf87718021bf11ebb9eb5dd6f458972d92e223b989aaf6915faa7e48d01a15603187638e85214c4ad815405e0312f38cb33d485551e4026af9797a7f0c50015515a105e81187017832aa454eceec57a36f631de0c0a14000c20ee70ee1e0f46f6824b8a462ba0e9db7bef48627f9e6452f17cafe2a3568c19c9220bdebcc48cddd12e6228778ac824c11eff3325de0f72224c8e6f9c6afbb7019d4910e3653b9cc9c7fe4cb12f045902f9576192ef451a2ae13e2d968f188c77e656bced8df22473a81418022b4dceb21479f83de51005b0752b8a27b4af0e595c7a2c30c1eb8da3d9b93d53c0afe149b9d3da564f2b7aefeb140f45a4c96c59f78c9a3460afad7a6c4bd1aec41ac5dd763c0791296df2d1320d1d0d0703e2a7c038ccf9755c85805852b124cf0071badfaf80ca72d274379dc833ba47b2fe48738a152b84fa0115ae01a464bc4dcccb37726fe2f2b6d4e521404630aa6d29bc84361c322b5560bd804a9cbf807dcbdd0f24b66f1ab7efb5a744d865455c24ffe8e63654fad02e2a1e8b7f9ca88137188e63056b2eb262407e843761991aec6bc7e32327a1f04adecb7295b87c2feb19cce45d4a507210bc8cf7057073786c07d7999ca18efdf50363126b635e6fa779ca7995bb6f387fec3622bf14dda60859fee21b218835acfbb0782164e6f59e1b2306fd6bd1f8ecee31b17e29ec99f4f49fd9e36b093ad69f3e811e9dd9a797d7b562171e94c448565d5038608b740c96fc28504ae85509b9668dd7cc54468058ca7549a3f600d784bcd633637d1d4a5babbe294f9fce7af99bd6071b3c1d51050d2a77335685387c411aeff0a982fbca94451b5eb8c0920e9c7591c5f3287f69f3d01b1bb000bc9ad834e176b11635082b42e975a5c41488082d2bd1eb933a998a6253fc4bc97fac6487ea50b1e98fc397ae03860255348ec1047b0890df2780afabc6550da455fd1b58e17c90307044700ba4d96843fdb0f46686c8a4d508569df75c9265c74ec10149d8f94d1b469f7f9d81b4fa9e0cc2793e39bcedc1de8d8d5cfdc3d3ad9ad3556ba07923dda50dae30880e7e996b2ac534b9cdd16c42ac1003eebf8a30bb0103262d43640ff229a28b835e399e95cedcfc394f310f21134b77ec73f1d292c6a49047e27c27446c9e4d699646d151560f5d3a72dcd93eaa5daad42b6958c75e8c4eca7e7463d1bc566ce5aac706547e9c0c8628812bd2a2f7702fd2b3e1697c0627fde33db82f648f6635b5b95330d3e4f85dde31a53aecdf06e58dce0370785f324be7eaae03f3ccc58c15bb3dc3742979fc68401bbc438a87e43b3d3b5975d487e44b60fd23d1626bb9e922514c894070474f2f7a06ae477d39a69e7eeabdd8c80fcd56db6d4f49e7a73975e054675144c67c97ccdf05662ed5dbe583b9cb2841cadef888a6ea21d64527071494d0cdbabfe5211d76cb4f66618755503751b3e4d43b510d4db5813ae001984f1d5a147b5152412c7acca998b62e65cd07ff4121f75e4e42e91a6580caa47bb8e0aff1813ab6068d228057fe47dbc852a6015b2260367939d59446a71bc1bce7661def2508321ce4731a85a007734a4532e09dbd6977075343d6431212cdc9355d4f30714fe653e714a7d3859e020e6cdea54bf3824eff38ac1e6e2af657935246e1ecb56735d9cee330ddf7d7eab99dcc1418ee09e355e0d03b6c9d140488a1a92c009e8001b1165cf83bae5a104d8a88cbea06aa8851ca5493f5bbd1e2c70a34c7b63a0a52657a87d789e6aed4ed1f59aa2fdf58efa5e6b4f02aa1c40c5f65b4a8561fd87a5f0021f9952a360ecdc92105bc92fbe2a3acf7bec21e5e8790e0460464befe6bc76f8703fdd8462559a57097d79b3348e80c0e517c6892950d090c482f87c1ec5ac75c711cc3438b739f551011c69ee440470470f2c939247704761748f519ca7d2a359c7ed2a125c7c7931b5de1955d1000341ebffa1a25ac90ecf29c3fd859a64feb6249c559b5e763a93cdf47f6a65f651e29692236cea7eac2cfa8cfb620f591adb8ce1286459e71a6b74248db7d46f85fd008285984c6d83fdd6b9757d7554cb7a66e5c2d60d513b3953bb801e490072d52f233edb20e2778dbcee4994d452007b71c64acc2b7946958e5282f4ecf08abbd1c90a9eb59daabe583c6565ee4ca378589d6bdf007e2e063bc347a9ed2dc944349a98fd2009459514cb6e071df643efd654726c0f51602f32933c3c0555d5a4aef296280b85fbe040fc4bffc11422f590b2518538c8b1ec363ca2fc54ef2d860df4a07117f7b58f1efe5f857b3e02297035ec579d653c8353ae96bdab3bbb683f6f2f2ba2569b13814e1c160dbf1195c9355c2249ef0ed1aaccda30a0fe64a7b512df069ce1c2ba41d4e2460052c2cb94d2b12fe31f8098feb99c863c593d9d0d7e92cde949d6e37b3fb9046883f26406f1383a3821372c1d473cc8a7c1198eafed3873772ff4770657b47f6f1f38018d7f1fbd0d5f3a1ee8e99ddc3337b69b37f2842b52b8dd186c70318f7daf02574622d2c64705a97b8b6237fd91273cea13184bf2588cfb991910604573603bd0bf914578e6ae47cfdc41a5a4a9a3ebb9ec5d748a0d2f726ef005bed766a60fac33193e7136a7ecf96c441a10680e9c97e7baae0f4ff97134eaf55cbd9349b4fe20d910bb022d198e36758f30dfb845fa57a50b88027c471bf3118bbc014e4935da447cb0bd631dad5c703a92c3c5e163dde5e6ed896c337b96b6cc86b2caeff583bf436cc5777b61544eca68b476457cfd521a31928fbce13b57524643aa5e92091391d31491d740521f0aa36cbc4592c8a746b8d888eb2da43b35f5d1910b0ea9f725f9ab50ad0f389575c18fc3613aa3ee3518504d2254ee833596100f0ab7a5617bd00852eb431f0a3cbd03adf2dcd9fd22788541d1165e330124b927ce29c953e46a31bcf9b336f3d897c6e2e4e1c55fef71a0640e2b4be336a25b9c5d7f17c0e80d657cca67c9dc14449bf30a90459823c6cdc2f3a73e54b3db37388ac628ac32f5852d4f007c25a1d9b7c21f40e22be1aef0cd2a44cad00b9bd3c96d85573943299e2b4786046746229504a83ccdd22d3ec440bd4e4bba65fd81565f0d86c4c258f5757ca5919a6197c16e4846985c8af1ad446f2a95aa53ec12cb85123fe7b91362019b2ce7408257e46852798dd1438b2364d69331b066450d027ec9639da404b78abb14a6d043d9573529f7a6cce24d12a4cf156dc82b1b2ef594ac9399272ea0db396f46a5f0dd251b518de35bb3075072dc7853243a8865de84bcf72e7a8333b0ccfc05e56a7855515708859a465802d61e0f8e1d0bc4622a16a8a4629e4ae0ec4a729179fb9bdd80332d3803118774eb8ca9d3d215ebec6b7e3f8316a104869d9e8a6bd12efebf0117c01e4c37f967455aae9b35c6d111ecd29058b8d28d3c3dbec41f92bad421986982941ee72daf490e1b53844d796304e1566ea2a82b466c99c16cc039c197c1875204965c7d621c68041d1a5090db5f3d288e65589acb4df64e57b9f014236bd62313574cfd77e7be5fbf7ea93f648e8c9a95bfed0233688644094884f1c492949975050c9e921860437e0e29e654444e2a0858fd4844e93f77fb6ed7882f1ca963953d4bae7cd596ecc9232cbfcccf19071c64f23a4d223d01cac7938bf895f7ba0943814504ac9cc13cf713c7476c6f2de2c6e4b43fc0a45738676f40c227d2ac0882ffa728473b6d232279dfe39acb07c08ec0532875ca576b371b10fcca5522d51bd439bd536d6495536f3d0b9b1b1b085c9d65a7805fe63c1323ee4bcd97c1dc681ec818fc0451dc4a441784256da219921dd9fb1e932aa36c6034b88dfcfec4879757e2a95f2fb213656748d495673b1d050969fbeea32319fa1b0978f901e738cf7a01d7bf94f28b6de4e4fb0989ab7b5a48fcfb4b431f93c59999064ec67c9cd20651fccb73d5534aa4b076abecaa0f247e397cb92b6d4de52c4bae29dc4165a2af79ba47e7e4f30d651f43aab175a6b8a06a4ab8a6bcd1d0ee49132a4998a7a3780c7d8ea70d000f0156dc59437c616a6e722abcd85defe6937ec80b7fd037e3b63a77b17d4e4cc6010de99f47ad14e7a7a48096d33e204f7f0edf1047eb122bf4dc85cf40ce677b1e6c8c1b93ce022b17201c8bb4be3ed11921ffbf8f0021c6fe9d0f21d2f5476c1dc3a0e3892f1dc8d2b2ca94076d231b69ab68d17389dd84dc9e994648bc79187fcfe94954a38dd3139c0d6ca96f9a55dea63ead9041c1ad1eb18510c26485ffafd562bff18d819d7bc41c4db88025697023eeeba574a54cf305c058443c341e611b574efccb6ead264222d677f99587834519894bf7a64a0a51f2e267c8cf8971ffd329dd36119628cc8bfea1e8395a3f0de449da86bc0530ec53c052e4191db61603ae58c637d6aa140cf8529d200a852e208857b1f73f850cd4891f3ac047dcedbef6346df7b6b85b89c653a0b648b31544e2c7189cfa7c21267e99c1a9e6c9b52d04707798cd0cb13d80fffa3cada608aad322f134b9f4f55b051204ce0143f7eb19715d5a931653c7034f66d8552a0d10e57533c7ed6ec2768562e64e3c8bb924971a3def79d58ab392a1d86af4532bfd9c2836c654578493fb28e1417c5d989dcd83824bb80df7c4dce59993aa6f51e315d9a55d7701c30fa052c977262d81ee8c02b4802ef7e6eca358c6338a13dd304d21a81c2c03789fc3b5fcd5a2aada3b9a3b6fadfd00fa6d37fa6f9c8d072fb3741c161a2f65ac316486e3bf6d5aecf8b78760afd4ca174ca7226ad8342edcf7e8cb05800dafaec3cbd06df2b5e20f4625935dd44b79256cbb8ebe9ccd19bcbac53703f7291c09a03faa9a993a42e645f041719d3b95b6b9b49fc4c315a4fb6d867f4d0caa76b4b2f282a0bb116b2535cf62987718a799c37275618d5209a94556de9d8bfd1d0889df75a9e9cb58ff94db63784877c7e90a1af48595755750e541de8eb487a8f1e003b585f130d541c08693b63aefd8fa82b3bcd1dd90c8cb61ea1b18724a2c15475a26a0997123f40aff5cf4252094c48bf22bb2699d14260977baff79379a1f6b90b658349fae703bde081fdf6cba6a83b392ef1bbbd86f97bd9b16f108b1c36c14d05e8be2ecf9a5e84d1693dc8031e89ad0b38667ec432f3b75141e518075fdc49ae9ae114891bac99b09eac4e184011f908b393857691554be8619a4f452d634cacac1f954cb60419c97e56a7a0a9edede5546b344b8799217486677ff39074c43a8feb5a9cec7d713dbfcad6a78ca3dd9edd20fcd5d07e736edf78845ebdeb83748eb90d59f7db21d675b0cede4740f19b6b2ae724a5d34bb8048cdd539b3008ca33bd8a7bcd4627abc1434e08b07fb0baa72fffdc7d38bb8537ef58b231a185ab09f4ce07c656af407a6ebf7231826e44082cb8004b745ec59caef65335b3e49366eb48d3922159723d3a5699a3699802eb60ae9aa6105256c9cf54f0e09c13ff920f440ebfea7ab6995c405b176b962d3e6b44ed41969a767101b4107df1fdbb8124d3b9b67f5c92dac1c585720b642f5c32d1a9b9bc1c197c12b707775fb3f08eb4d6bf28bb7eebf2a41e9dcc60be76dcba8f3722df49778a7cb69fc17c50945e02f8e18ffd7e63c38e411891c5dbe149d2fb1e65838b58f36579c879875779a922df0130071ba25ab5517638809a3ccd0ee5c9d7cde6e234875732a196963ac7df12e1625cb7214d230af2e37082267f5efdcd6548b0823dc8de109ecdd777452442069ef181b049ee8678eb04b4ae1951987cc72a52a3a9605342c5b4369de254c0a032caba4dc3dc135f2921af81256363087886fd2c891b57a987ef4fc077040f2c800376ad4733aa97925ad3a84c1c8cef68d7a6f39b7a2efbde5a356c5312065742bf189445ec2d96cef57906fc976ce4c322bb371b0e0782c0d23c1560948702c8d1c68684bcbc76e3fac0b61ae57d302911602ef514d7e2af6d32166b5cfc2837d94fba8597ff8705356505ceff91d53bd50068d218da0341a9c7305a04fb142cd722e235f239f9dd3e03762c80acb2d689e8b05f8b3ec6a108fb8f27e8e2a898bd0066c6aab1af3c19a33b9e5f56f394a90900c849bd1732303fb4412ac8086b9309515d2d9f5b5d00a8581263106cd71bb9b26f102ef09cc9d76fe80033cd6dcff4dd2db9a97d68bbe18f7d22704988885e64d070885952637d5b2b688351ee291f7cdd3eac9f88653969cd37bb4457c93a124beec171b984f39e97a6bfae4d179a3ffcffa5f8d2886921df470f10f1661b2497d50f55db9157021abeda96c7f90e416c6fed6a32c71e248ab5e9693689f67bfb8802504b9ad3785ed235c9c5bbb1d30b2077b66698352bfc9b4c9912a5bfdfa0f693dbb76b43c75b385e511bb54edef0c242894baf1cfa26087d640d89f5ffd55113e74f40cc12e8ee18f3ee400f0225173407255c98e1487f3b9ada9d3001d31c40fe340b2c5877d9036ec72c16bb3064c6ac38c2cbff0bd44164f347e52c7473ffd024b2a5e43e5417041801f1d7a9b7ac4916fed94fe0a8356e640e6fc0bc0bfe7d413b1b88323f8a83da1c88b16902436c1a389e0d25116bee147834604929baae6076075944a80fec39d93e93ccd012f174504065e8734b18f4cb0ff3c0161669be8bc1957ecc81b36b0027d7f1754f4b9d1e170b1a341e32ee18e752489e65546fe652ee90ce626072b1cefeb747aa956f840fe089c04f1ad187e3c944e067f668a622c361c8aceee37e8d6ce36c8feafe243f73fce8647062dafbbf877153e1473a1e29b33be5ae2986a115d9525a83467a41a4a4fb0ed58dd151e6c9fa95450a41a5289e49e7677b97c78e3963ca5d7bc026599d6c2b91b09183d1179186b956a62b21c3b184890aad44d5137772696588831f00b338fac5da7cc91ce431fa73b09aa5481606884956c7e90254f986afde5b2804bbe1362be39d39bb62cdb0f62989631672951111e1af22e43263b3776ea1c067b5ff33c713354ab9cb3f9495f4d08305a0b5f53b1de1ab52205f8e6b302f9cb51fd2d7529a63e7c7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
