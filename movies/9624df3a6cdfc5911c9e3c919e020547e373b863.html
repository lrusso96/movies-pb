<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"891a7328c823027d06da115e28b4c6154b479068bdb313ec97280c4f18ab3aa0793e19a7fd5554c82ab9c352a4acc318baa1eaa254f5d3233ef35d1bcb68b2f0b52f2f24b2e468a1a9e5e92b50f6a22b52923aae76ff9c8c54e6806c082d9b6f43cb73946f4b6e583eb5b80cc7b645f73d7c7fff0675bdaffa6604c7d1b4d27c2b90c157c0a2958f5e177c923e19cdb2a337e62094fc2089bd92a112496f5c52d69c42b236735bb7a89f70f4b4c222c0970140395817cae7d9a231dad2f6077fca9ff72cfd6eb7ae4e7bf9232ac0bc28617a18b41af4bda2df37daadfe7e2921a7c52018314208d19b78f4d9df3135266a8c1606dcd0df473328fe3e3336bac458c011ffe404c71294d995df070b8e21d6e8961615236e368158cf8504537da77d5eaf3060b6064aabf496d789cccb4c2c8600578a49132c8d145152045b8e17663df321dabb5f9b626703a2c8f68d240522fb8e5a9feef66a710cf78ca496260ecb44439b68148fead0e9d280b9cd7cde92859603dc4b426d08f647cc4b3e6ebdf702d7d37e9a21ad5258f4286350968efe81e399203cf5fce676b0f929e508c04f92604bcdaf32977adf76f6f5a86c15dd6a207b502d5814ad742ea1a5353bd31c13cca8e637b5cdbd700e783bbaed9b844f30bae562750377cd83abd8499c4cb8dd30a49880ffb69e04e2b610411a982b6a3f905ba76b8d6002492173ba4d9097cf573f6fc7a030b655c510d3c2dc2c8ab6385709669981b7bb1eef14d35690c212332d6421fa636fd174a9c854419876cbd56b19c85ca0764f595536859474c83a29219eaf1ee2b70a24eb5e4f742bdeb1421eb506c166cb5dbab281b32bd57426b82531d3037522dd7394763373a256863b659f4dc400d854ddb1ae5d120138fcd9d443ca0d752964f3cf3f8da6d09847896fc446cde44a391db3a09c9d3df62326377bc8f1e86c06c6d376a6a9fe888fd1811fb96c484f413021fff6e79ba5cfeced7847040584340728a9249dbab32f875acc1b279dfc86d5b4e1d60f32ca0b12e1049410a7f31dc4a470fcc1f341c20bb29a2512afd793a22e4cdc771266997285a34f78d644268648f9b0853763d832b10441cb9774408f1322d92cfa8f4475e8daece8dbee8647f9b0d6011f8b98208f8375269ac7c563bdbbba6f8e6e07c21a571771d0e3eee2d5c9d4ed6f7b54852a2a21bb6f8d726e0373a793ac6c1bd31d5258888936178b5eb8429b9efa7a4d59222c76f5bf32c5ab9e4109360f7863ba6d7849e4e1c57312978708fefe7cd10149545c8206cbd408baecd53e09db9db680d7b1dee240fd747c8c887a3057580db1aa5301d800593b13aa058302b51a816d47a340ee8fbfebf4468299ecace8c8c78cdd481e94f2dc6453ce3b3e9c26b716e311b254bd21cd2e29e2dc949aef9ab259186cba2f9ff0d053f9a27f739db3c80f6939eb305cbccdb25ebcc24fc34d0cb3e19d7419271a8ef0c6306442040a67454961361253954429b23d318d4b582baa8a3928309d25f89b521453dd2e6de6ea62cd7fbc5b9166d3d2bcd56df5c8cc4073ad149ec767e7f937552e66adc212769a9844a1994099af78d83d1141a11c7162a57c14d326ef12ac6a7e9e0ccaffcbf53ae0763aac07d96fe63dbc0f9a5c88fecf547695dd30b200a75ec16a88946b5fbbd8d882c70d0c1d99e47e006f94065fafbea8044333639ab0d8ced26b4f3e1533e6b7e098fdf9e8280bcdbbe5026f2e056751590616a63827474ebf84f568d95f23f93309ef2fc9c42da1b5efae27dbea2d78afc759f7ea9f468e7c5b8aa24509106178ac6e0946982664a89db83d8b50719eee6b157f80dbb98fa0e1a18dced33fb3f00ea5d337ef39e255f626463502eaee738e53e3fc43e836d9ad97fb5ed6a9d6bcf9c67e08d8d3853a0a177e64263652be2600aad2e0f65ad5f34238feab68ffabf85795727935bb7a8966686e0b5f07c344bbb888454eb165b86f47493b3af54942f994f41b6cf2e0ac8d8be64e1c32ce525d243a3500053c9edb7ac469665daceacd3f59cc36f30c52ae756a7ba1dd76a83752fe9ecfe89961d5115e67a014257255c949d940057da32e361ce625e5cb673b33d2bf420d29d002a58e210db03ec7863ca986be4073f37a56cda396b8439c612ac3f229d84d8b9e8fb054a4a65b89c967c0ef7feb68bcc9ec560660dfd76e8a8d5625987ea4dbc091fce0a10016bf0396ec55f2b857153f29ce4da0c99d29fd79216b9c488961b3677d93335939b2c5bf30c289e7cd22f25b251846da6d2989c598864bbf5deeb306548cd101e37180e9d9c9a1b429b9b909effeab18e82f59f2d32343968ca30257b486d2d4befe5ed0b638dceca830a9af56e9c91813a08ddae6be76b445f95c514958cf0817dc6627b79b6ba7f80a4877c0beece7d5c24e495cf5753625c2af6ced5a2d6660ec6853c3acc1b09451378f752c21920049a55649362c47adc5aa6165e38dcf0c0fca2ab52803fb5a1e21ced86baa9897c2fdf7feab9e818115974e761f25d16d6ddfa6df8e78667a95c12d06dc0ac3083f0790033222d2a6db15016cc744dbc0c034ba79387ad1e1b7091da340d7bdbb49537ffed9082701220d360d0ed9725caaa8596f947feaed006777c7998fbc012e05f829a4bb2f776b942121a18a5f1bf333f886f79722869a647f8761f9e85f88374567ebeb57f713f7276f87680653f4c97c319d1eb07e053fa3f552f6d53494907db0171fc37d6d42972a5f568b4a76a50922ecc9a11184329c9c51612b246fa4c59ff7a393195b446abe2cb697378f3cde3120643f2595c990c5fdcd90fc4defcd9319e193b274829002465377c870460dffe03ea7154f5bf555a23db895dca092f01ba7d75c103567dbce95eeeefcc2b3bf223075ce66d6f5f8f9c22eb57df4c9c3ce38e222c71754b5dece944f56b0e0f8938245957e38bae284f1a2344ebd26a25ee2edf20316a0baf611c75777efa0ec1e75fcd67b4a59eb2e144169b592cd745c275df89cc64454578eaa9ffe38ade2a43b80ffde9870c3f75d146d3e2f5bb03f1dc923dea85d6267569bf30fa2a1d0f58b8a555b6e0a5bacdb60207fc84094cad7d5cb9b77f95ba243c6746babaff21b7856066894a2eab4ddea1e0e15871927205218a6e0341f7f9c4c10b5c41288b83f6bb97acf6ab6508bf91392ce1dc479d7294288cbde4ac6efda93c6a3e36d65e637a3b6fde5294dc8859a9b312d0a1628f60b0d375ffa1956600391ce66398861977cb1549c2c4ac500d9d5d90f367a6477fae47ac02d87afaa87a6bcb482366d53d51474ab8487d4c899f2ce854feb15251d8eb7b80ed085377c9f8a05bd26ada911862b402c8a955f493ee960cde2eedd3f5b26eadc761467e4727b33d4d05c70d9de9b749afc9fc3bd71231cb5af11d43cf0712b66fe13b7afc83b2ca1693602bee10299a6fed661cea29b6873800101a2b0278d5786d7b825884ed1974433943fdfcb5618ac51cbb583be63337219e3442d0bfbe4e485a514af18d9e1996dea23496cb171b7c67d0cf1468bb67b5e399cf685112d6a0cdb5911c8076d85874464bbc5ff3b1a2b5fcac027ede42c4031294e3614227b9b25c482074233d1c754ecde37b4e307fd45020e2eaed3f1bb1545ba5653919d5ca59ad543b5ea0b97fb64821f4c001c87efb10b79280566fcecf6032793d8275fdde768766dc33bcbda453eb2840b9cc0d0da986e2d1348417082674572542a67793b80663f7a98a70585a32ed71d1f301f1e54f1fda71d1fe14a7397ba59bed53fc18b203afc65b8d87a08739e1fcb8366e4a71b6cf5884223c0f0590614e70230629a3250cec62691a5184e481fb291bd02692bbd04bafdf5ff9e0f88773569e8b8e185f35d1f888844a047881419d1104edb455ac8840c68013a49950bad12e2c10324f81d139cf7f9584a93d9c304a19d01245f7eb6c46115407680a9a84f888a05dbf1730f6eefa9c82f0c84e4a0b2a4cae1f8f0200fa53f49f0d3d5870ca737071d8398e24442a85ef24cbc76a377d16d56eb4c6c5f31dc5b06e998db03aa476bb17dc4f576745bd9b92bc4016f184cef9c7d0fdf74419d283acee21a31d18deed222cdf726fb0bf1361314ccd328e4069198b6159608e81af65981eb392fd67cb24dfe935f6bcc5d5257c49c64f1f7010a85308992d974330bbf307d1eb0cefb337ac323f888c5c423d164627593ec43a635363f3033c2a0a817d3829d18611d6d9342bcb398b8f6cabde6d1d4f27c0e46b338ea068918892a64fe819e9146067a49f48c07536c998c5077315437c7be55d3f6d90f28e0a417ec74e3d9d87cb5ab747d64150489500dbe81956cf000d7ce0a2f82c0587a67678c8d6bdf9ae7b6fb63e62bbb410e6d3c69340a86cd26489d4313fdc5d170f54db0a0d821885db183469e2eef4ccefb2dec741c0ca56d500cf494c17a73c5f930032bcd862c25bcf5a0924194b115c00d2b2cf42e6c49f596bf9ea5c79c2fef073790a88188e6c4e7f358790a41be5959d3816ba47d0c30462c1bf5dd00594f44b7925647a17f77932697b9b1b4189302b63a703a515895cbcb349ffb1082c0692078bd334db04c9112039143e6f1722e8d3dd4d37cdfa5ec22627f45c74c8a5d037c5a517b51fc881ba18a2b0cec001aa895df290d1649734d3e6edaf8f420cc1a6fc4111508ebb019c00216e1badedec84bd668365a17ae5c75cb7fd0d87d89a9f3edae8edcc961f87a831653966f9953a4030d41efc5e7683b5c58851f75d148b2a6557510de2f590dc73db33c8e989d1a7a823b15925260c1627266ffef9701d400790cc374332665cf08652dab74f7411a559b04e934765dc1c960f526cc35b0fbe3c5e504d21bf8cef0ab8ca9ed0ec0b16d048b7ab9074f5b1e7ca729a052e750a3c7fa6006f05c037dbd7a108247aa8f830f0fe5ab496a249b6e74b635afa5d8bcea073feed57e895fe58de5b10a7f16658602085564769db8d8dcc391c890a21eba1a981c4f91166e1a65e2329a8dd759ccac9b825c383dce01ed0c492868e9c4c014b493cdfca135f318b1506261cc4918d6e027bd5ffbc75a6661249c25088a76ae798752f1711509eab1f7e9d91b5700e055ca4e3c71bd041951b352e9040b71da4c5b93c464a0fbbb1090c2b2abd08eb6148332728739063be63dbe7430eb847ce4acc7f43179f2fee769b76ba6e3a94cd7798fe45167bc21ab17ef2c86bc5424d2249878bd9f62d09a531b23861a22557521018d52b176ad838d2e52ca00878bd5dca4c7fa3506ad85da4dae5ec5f0112156fbca3b006788d282eb5694fa359da24668649bf2dfa66fcca4e3427a5144920d0857903af6596a028af5635812a54ba2f1624b27c2ba26378ed27c62675db1ae9cfbb506bd60704e13625aa7c53efd478575f81325ce2c511dd2ffb47b6c15afee25167473099a93adbe22e8bfb07aeb1beb0d135ec25dd0af1c214ecb61cea9be287e066d3e9457462c2659bfa44f5eb9a6d2af41b6b426ceb834500a93cca29bfe422f2a3dc0d0f98542bf921435c272562ec219cdfcc5a874a1a3eb77866fcd8f28b08d3654d22464b57643ea6d9c0c6ce13d05a98cf96b5aa198a2f5cc850bb2ac4506cc9275649fd39b54bdcbea124318dcf166d7ccf7d86b8deeb1b9a1cba61fc8ebfedfa4a036f77c04dcb08654e679e5b63ce6606950813ab47a3ed79d591380a5208dcfdb9e67e7414c32729f26b926c31a12db18768dde2274818e5466bdf974089b197d49aaaffbf717a6acd1b674139aaeda5cc83514b06d5163ec7eaf58540120355e51fe7097c8d1a9b8ce3375311022f3041c5875808be1bdadbc0f210900a12eab6ea83e8b2a1ead1506d6a9a31eb1d3f2d163c682edc0740fcb1e7a424dca708ce651b637ed0e861f6d69cb2b5d44775baba472a382ec9f6ce80830be03ae5b9eece36d359b8d0ffe7ae650bfc501c1cf46adfcc2506db6146de7bc464f95a2a426891da89178f2ef331ceaca8ddacdac802243c594026c3494b11f48835ad16e9e035525d163b6f70611c04137bf655c0574b6422249dc2c2e0d2dc57f567360b6d4b4966128cd80c700ccf289bfb40fb808ec6aaf4f1a9b8b18021adafcee880ebf14c413325f4309a83d6aed6c01e9eaf7ba2598c9cf1b263625a18cd422ad325f4cc8fe0de6a522994a495a847c2b46c1ab91e12c3b215238ebd914e05c54d6307c7b44412cc2f1187b2ddd5262bdade87bf3a116e09bbb784ff58cc4133650e6ce18f26f3afa1c3d606916f8b88b987a2b43f7bd00344918a091253baefafc2c12cf183dc4d36294a7e058e46214277db2af0db1cf2484e545243b54d68855ba1f47a3f34dcbb96de6ec87b2569ad02870a405a201619a487c8d15a87549bbda23a203109094671534a924a816374147c16f4936f6ad0f22b656f6c2e4d54849fd02ea8d161970d73e1003584fae44380eaa122b9babe939881e27f8dca779c30b2d001d3009951b5ba6382d1a8ad3973697b10b199b2b02427662086352163f3b08ad96922f442d6fa4b0039a79385ab6d39c07e5aab729e8bd5274d9312b9fa4bcccfe9f0759ccb3dbb4cac2b15163033fd5a04ad84eb9511588498b8e1b392e88f1c85894606361a864c39a1280dd51cd4440cde39339adecae69eec6a3addb6d544d4756c36052c5c49829c09a173cbec09ed9721da139826e688dbc6ba83e0e951796b7d67f43ae310163d72e9f9eb9fcf2768d49c53e89aa3102d478f8279ee08b1387806b3e04bdb6ba096cfe949662200a3ab2903a2715b81947fb351891e28f6b86856afd635756e84de5bb207d82a077719759da3c7f4d9238ee19cc4ea78e34e1090d557213f369966f2371520deb7cb5887dd07dbb120451a889dd1f7d7382c9a9207f2f5d1a8089b49f7171a9c60b73f61e23df0ae00f941e8f56ad02a6ee2adcd33f996fe1fa3d32580b4744e6d39791eabe9058d330d40be803a3ca9b08a6cf07703087b09d474e459d10eb5a1c73fe30a3891943d3c2d529dbe421e88f6232581aedd43faa3ceca32729052043b6de0302fdab8bb2a5d429c64bf50815c2a28376cc1c9ce0563bfb1f23245d1f1ce57a5a1016b53e031ed349fbcf74651ed2e9be7273fd89fae0128c493caa67a34c02ef7d583db789682220d91fc75b0f70dd197bf674bd8e15664dc5b6e4f30fbe0b65392da0c17e777cccbcf1f77170cd046875b38305a8b354ffe059de4427f0309ed755f63390186cbe3225e80880b5c6fe2d797786ee0601361d4cc1998a1253fab407ec9e4986aff9b2228e0636e54f3668c3f67a8c6ff3890e60eaf4c88a232d4fd824549efb69e5c52e8814592422e32237b1e5ff571a2f04ea8f1054b5619abeb0cbd91c39df20c6d9b3c3c01da0ab8014572e5ce0f9cb5970f89cdc6545d14c3aac7b5267f8a9c123df97f68006a0f2738325901adf940406140ffe1caa78d6af1940dd691460b6afac8df14571c4c85c59f20fb8a8526d2c5cdf811348918b1b2690dd970815b4e028bdb2a537cbcf3300cd6ac66cfe20567ce8ad6b69cb565bb50b77edb2503a4c634e15366b246add505538e6097bbc926211d1893e8a38e3210598da3858f87260107eea119b95defe68c0699006328b35f4c1f472e8e99f73ff097aa56b7d77dcfc225e2ec5a4983c1888eb21062ef60bcde349ac6513473f3945dc713b80ec16a761613ece0722a8caed4ce31945f6c2afaa6dca19046c3eadcf9d41ea7783485a459b43be6224879800b2c324cba8a24dae494a3c3090e4ac36840546d3a88064ecf9b5e041c34e2a510c64f832b0253379580d6dd1bc3280f09f25e8fbcd1e3b14bc84b5ccb39deaf77c4f12303e522c7823449a8cf65c03b2422f565acf7516205cc8bc9b1325aa86d4072213dc962a37f7484b1a9a673235d4a25fd29749afda009c3833a4969c602f7fc5cb8c21adfbc2dc59349d818e32c620e117b26754cbd82de668f9f256096b53af8f4c669dbb399a9d14b49113ff67c8ab9e28de102143f23410d29a72fc8c7fd239f62a658e1bdf2187851d4b36ca59fdfd8b1e5ab2c269a9e3a19bf491dca1b13dcddc803089f827c6877a34ed376bbad882c29b97335114d22c65b9ffe41d155ccf68a51ae1525ddcdf8d656ffeba04fa6febd49e6f9621c9333eec534f2eee376432f3feec76bcc3c59eeac08d58eda201c8c212885321383b328fa7eafb848e86a9d4e6820255415b859147a3a5ebb186dc6e386fd4bc0f790bc0b54d43639abd729bd12686f7e7023dd60f8548ea5408c6621750239a0cf9b43ac7f3d32f13bfbd517af4dee5def1f955996fa2246483c16104d1991975e8411e1cc8f2a5e3a17934a79edea1f8b740bcd5bb0629d9b039557085d1182bbab060de036767cedcd34531545744dab603d7bf699b208453b9d38ebdcf8defa235916d14e93fbfa9a4f7737ad674c920fb4c9ef829991bc5257c5855210f626cd32e5947a9ea498c87d93af547cb2093408e6df9ac1f53a2d1526a19b573092302a1a8f0d7639e6b43b5d44873eccc225dafd724a0582b4a3a97016c9a4f1761acda60d61b1f1f137d21ba79ac3fcf1442f20828379390675b120960fdcdb448ead0a140a50dee8673cdbc150daec7554b773c20c38c20b6493b92bf45e340b49e5b7cf158eb8cec37daff990bc1fefcabc2fdb4c367b8669172fb6b13a58d7daac52dd1b3f29b278238bb2c5dca55a6696ea2089f144c0193724faa84f32f682b6af50e2dde97174e260fe8a64193d1b344cc3ccd319aa1ea126d8bb9bfcdac74f5c1919d2191ee23926f282d547a98005806140980db656f068926bf55ce160b04e4c75990bc59090360f21941639ee13980dcce3a61dee4488beafc0b29679683126ca2b8ddcf96546bf4822d966d7b0eff650985695564f7e600750fbf5d4082dc5e2629911a2a7b7520db632983943d563195016c4e108c02659d3158a82150004d1b7e4d1968b47466948069ac3d6f4516ea62e7faf7e55b6293e29d19c98cfedd65fe8076b84ef0c5fc3d91ab07b181f014afce5578d8d26c1c88baf2a257a0da5c61e55861ec3afb7678d9af12f533f050a271400a9c9116652219da7d0e3ceb056b52e3db1ef1e2f33a86f36755bedbb08e5126aacee124c02f8b0c47a28248a73b927cc356f638840ea9be3a5b6031019d619f4d55f797772a3beb1a20f64fcaef84d830e1242110c68953d243bd5a3ee7df1a2771f3b47534b1f0bc80b3784523cee49199cb7d65ffaa515c63bcbac20c59ee53fcad027fbb7efa956303025c715fc5785bd19d29fd6ee2e4aae6bc121298237774f0a3e2bddb44113b09c782f4077e5c2c93efa577bf67bb6be8556d0899b78c3394185166016da76b54bf2cfb09c46605a0c59080daee75c32811b79822131802667d438363d9c55b5b69464215aa57121bc454aadbff4a7d5a82b07fb837800ca75fa718b3516e39f8d2a58a502a232da86d57a9336e8387bae156d7a446e9c7cedf60308b2ac259156347899959aad2319635da1e6fdda8a46ff99ee23307ed13044c70550032fa21cd4efac069b0d3a86386d70fefac0ba29a2198fe73b8ff550331b70717e27e59504dd37d1483c010643b2924912ccfe1b8674f56dfc6fb167e1aa2c78c7a50059cacff3df40b979175bdf8e5bd5a77a6d0e53f82bf31e2bd041891364049508463de1694b5c557a15b89de19b3c9c507cd08c9d31fad0bbbe37363c593d2b1c8d6ddacf4907871d4f0e7adb3df8371631f65946f940b5e395bd6dcab4cb477e07ace4383481fafcb74aebb4c8febaf6bef95051d45953eb30ebedaa2f9557d0b18207bd529c474a61bc59c9e63a5f5faf4e5629ffd6d38f911bf6bcdaad9a8f4a0a0690fcd2e4c20ce1324488fc152c116edaa92dbe5da4d86e5ada5c813e453510acf379cfa68c0c39c70f8c737ea3230d8c65b9717cee366b7060fce5c688876794b7e65c01d076ebe47dabeb3504a52ff75889d902b4e3016897326a344d8bdcc5e670bb73a39a926f25f985d2b587325da3cf14fd5cef07e2005de0c6192820c519754869d374b974e7793f5585e3f66cd8ca96a5c64e911552871841d27c94ff71d51318c578d7f4745c03c2b5a74e921c476b32f25a60b8d9338d8363a327381552a00db71097a39309fcfe2d57897746ac1696d3e29109ebb21432f516e2f427771965bc624aa99abefac5f39d957428e7d10a93acee3982c3cceff64b2d5ad69245dd30d73b1990d1dfdb3eee7ec10bd287452cc55e47cde07804bfee0e680f66de2995c5ec66c52cb06ba4cc81b69a7b9f728595fecd0b2d0f3fb6d46313e95bbae466eed114c0b036dc55304e40d3f0f98f50a105858216273eec7facf929c9d54c93a413208f57384be50f6fdd78192b53bf04a4884abb780d730a521ec85c8c92bae5a1c7c127a6495523557dff9a0151d15c83116bae5fb3d25b2737fc212f6d32f9f2187068e6d1202221ddefb1d98a840f23240a11007ff9ad0645c5bc95c516b7503814c856dd7cf32e280445fa50512589b1bdaea8319b7fa0624cb229399254b2f3e7fac31068e287d102366a08c2b773278f127933b7ad94055c16a139169aec17118bf819a2ddf6721f51fbc9bfd36f338953650ce02cc5213e95ab667b09c0526685f4072ab522c12d787bf746b73d805cd1fa605556df3008b5d2e6c6e8086f0062b14e04b2a6da02e8b95d1bd036237d85dcdad223eaa02adcc7271c759a1afdc44535f0ed561a8cca5fd76e1082a32a2363eb3169d7d74fbc2e344864b7e588d2101f4ec0504563d4a96e53398e0317a634a49ab526866e61c894a181375b61940beb6b1d2551b20645fce216bda7640bfaef985be0682027f271d0149ba4aadbc349a749aedc88a6e6f95b9fe0d293585b24791e5985e39c509074423f7da8f247f2e44cf483a082e402f93682a4a91dcd37895048d665a3aeaf928913de37fc6f6c716441ea0856e5109d2635b18aa56fe6f27176609e45cefe39e0d47760aae752a3ada4c9957ddc20793c2ea22a32de127bc120e150617b57ef7fd5abf9b5b1c65c9eef4821261e5afc84047dffbeea4021c3a44f89355ea0a640f224e92664a2247d522b8029e7ae0e283e1c8af2521ea1cb5b63ef8cde4985e951d38e1157240300d962e6812f074229f28b812e33b5f54532608fc0a1137cecbf8c571640e8dca8e53fe82fbcf5a475ba987d31dcaea6da620e0e645fe2717aed1ee4c092c039700a4285a194f0ec7cac7b32fba68727b3288bbf3acb3250c56d881cf137802c0f6f523f35224fffe23bb5011a624c7bd6c46af697ceeb36d492c57722d6acae292670668d84fe1b25e7e744f9bec54afa7e00eafa4926db927f6760ae34fb670f07216f2260b394e0114b1a01902a454b6f7aefd53eb6fa348817fa512a1730e39dd4bb6496b05908d26da12f46f7b790539e036a9926dc72e3bd4d978e8822fe59a0c9e19cfde5b1610427a7e04d71927c374bd9ae933e9af1c45f6c834984a4d930736e3c12149ccb394103b9d513da0f078122672fe2256e802ec684a6884f26d1da3bf720977bd854a8561f4014b86219959f35cba9b669c5d9a2eb533cef50c7fdeca7f389aef455347b4643193c1b63ee892eaf66c2fdfe9262ec2150af651dac3d58094094e842187ddcc8c7267446ecaa25ee8c64571674dd53dd953fae50c49f2594eddfbf1829d15dbb96edd5a0291989ff798e19ec69acc755b157189d3fc66badbe25915a1cc69a9db7be77aaf809a37b1d78758c16c5a2129b2793fdc42e4c18bf4336bc31e719588882c0cd2ab91e10f278452428be150c1b41a907ed6e5c7d290feb1de031e37d2574b3feb36bd18c0e69fc3170e6fd9508270698c33455bd178b0c55d9007c2abd142f9e288bfc7300346b12fc0b708c24f7f42ca13e95f55c4f346ac3d541d2ac5e9db683f1251e4ff7d232a0268f83010339c54374ba26d04afcaf0beda39ef459596ba2a731ec7b972ab6f5c2ba68c2130cbe7f9b601418ca0716511fd02d2019095cee2f42ddef56542a2b7f1ed0cc6da5d2ffbd542efbe8b68a9ddee8d3e3c94eb1a2b6975d19f37b3dab6242b6659cca7f3a83439ffa37d67e2f20ae73731fa8dae33d7779acdaf5ab499a0c3ab6b629d46b1b92d974cfbcc7c76759c3d7e041d4d500d142ca8f3ce61726d2d8a95223c65b02ecf54267f337cd6006afc9fb8445e5406dee8bc1e422e898fd31b319252f49b96929458bcf438a5bc9a3a6a6dfb4588decd87c1e05986e467838ec8d6779187d5180efc80abda2f1dc9300304877f1dd2d2937523dca7cf1c45c835db20a163aa39a52941dbe2f409d830f007fc30d4af9d20905f21e3f37f2e0eef806f4d05c15e1d03798a5d20ed5a3af00ae47d68d5b9ce35edce5b070a2791f57e6619683b893f61d765b2c803c1bd41ce6afaff613e56470e2edd4dddded554d129401e3ad67db03fa911df32191a3b8d041301c508cdbf433429452e2911b5d93f902fc81cac652884378eb4dfd382155ccfcfbc0eb66df51734139222299e3b09880888afcfd4b0d545cf891ef7cfe86b11f40dd1a37e640a007ba04fc9773075da39201a3b342bfd4f70687eb7bd319a31ae77d6ed347cddf04a2b5151b27eff161fb6b7e91bd084478276eccf2b24a2d8efbdcedd92c3419462424565dc63d16d9519c2446ee12afae8c95ad079b0d0e38adf74693c71beff71ba754e36a46eb2ab85871b30a0336ec00182825d2cc70813fba354529b7f44d8ee4bfe88aac7100525137ced9e25c2b860a2dbe5485b5f4747b7e0c5822434ded0438a9251fea1d1a7c0fa32e6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
