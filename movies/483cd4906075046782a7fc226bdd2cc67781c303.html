<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2515702e95b26d09288dc645a40fcea32f0ba1ab146da82ec2b19e6a54e3d52a7f3a3266ac5bd3cbcc10ed53690e39ad005d5c122b18ed9773d42239086d92b5996e2c9a5a07f116cafbca9d51f19dbeaa49242d3a3f4ce0ede58e3bf77fa2f24ec404fb6b73c91fa1f498d78b812a93fa047802aa527bcf272e7d54a754f127b212bab781b34f76eafa31e1c1c099e472bf7d597d347c7bc1bc8b921f281b05e099ee7f9cdd8ceba26e3d7313a1faf576c8d86b26a1e5264f35e521e6beda1667cf6fb1198908d2fcdce3da207b0f5ae078d79a7bf418b622a8157ba4d0170c49b3f0b6e7029925b79e9ea11f8bef9b6f7233c2bfb05410083b1ab8e58e256d415d9688d3ffb65732cd7994c86bf5924683420a5630af930a14f029656f6f973700fc1316d6bf82dc92ac7a74bad6cc586d22381662362026d76104a90c7ecce8b355e859a956c103354f3a78df7fc4d513def5ba28dc17a8585722e5bc3e7b45de2c26e092be810249303e403d31b9195bff151adb1de06b3437fbfdac55f7d18734a79dd9d088b13ff3a17cad328e0fe36afd23d799c5b73efa0cc9610f58306bd73912f971ad27806bbcab96d73865fd32267253f0c67a86e57e99e16207566410e7fe4695dd747c59dceaa16b7e07e898e747779c648c811f9f8a3a1660c1fea548f3cc74996fe42bdebd7c786c725826ed283ded939289c7f8319cecaeeb525e595bc1c5fbc851400e4c5460604fdc93c828283e2c38a1182c40c79786abc1878a7b5bdce08d3eacc7a733eb7622d6be950e55fd0e53c1624de084e4d13cb26449af55f7f36dfb3917c221d3b7599b8ae74d8577514438701acc8b40afe73f1ecdc606d2980d8b891678b2f9580521467e8681560977c0891fe326699c7f6f62591f0a6cfdb9fdad7f117af0e3ff07a289d14ffdb80f654c488c55b49d7747eb22aa4ccc4269723f2e3629d7e094dc83376e04b5f4dff130bd16082d30990a1aaddf10b116025beeaffa705243eb5c16c2911816b361191ed58732e8ceb726f87d6ef1c7048739c188a153e6cce8efe7f2062c7d569f73ea481be0e1b52c902aae70b2ee9cf2ae678ef31b881c2a69bc968b8982d7736372569cd9bfdaedc4da5347e827742b6a892c64c5c02c8cbe2e1a891e7cd10db36237de6b83e970b9e60ba934a69591d235123473335f51b62ababe0c91d7232b10bcd20a304e2cd28b72ae6ba4d79a76ae696fdb2a7c4772620000f0a1e282fc8032e14ba6f270e5ef8534e90ef4f5512fa8094b238ddf47c00b75d03c281b3f98a6654fd21d4a0033dfe1122840c7a903f57b65e695f9cf72de25b938ac30db2536db968e0e8858761a15d5fa1ac3ab7cdc8ae618e890efd330981e0c410494585cebecc6d22e666f3321fc8c11ae29cdb5a752e1107e4657de810bdaa1daf313c220b7d554674816aff932b4c2e8526043109a11a4a762df68c3bbfcec13596a3544447ef2252ed1558842f524a51191be6300b557f1870a2f54b9fc0f7944f2b45ee519c42d911398b0d074fb79c4afc5c33c7eec2664fec0700ff80a5fdb21ffd1d2ac0f4ca5a7024c40677bbb9b20d58b8db18e521c97a5379357cd6210dab06f7e6a5ca0d5e594a149c3ae37c286909a1c36d6280900e84e39b68aef5443c9190a35cb3848df57ed112bc98ea4d1d418477cae5945bcbf459a1626ff7f599157fb32caee3d89f799fe2f1eac180640caeaad8ee7321c318a55aafc2d3190d838d26b2ab616bdbf732a87865a590dff24bd1407d5a480339f6de3d8523ab2e76bc48326b22acb1ef7b2ed4c62fe2cdb1ce1c9cacb6e8504e4331af8781c67cf4b4f4b072159033c000a2112d3ec0e18daff2f63d7ef7a3b3ea26f2eb9a31455ae32cad811dc6675346dc429b127c9b6066eb212f5fbb93f56ec5233a26a3519d7e7d8d9b8be86542ccb19700c7a0eddfda76c6a43b8eb380eb211eceab6c39cb3cb627c19f602357b9298c6b51ac1b653efc460314b584b59413201f0d64c3ec62971712fd4931114c59f19703dfb47192124046104d1ed31d585c0f69a5c457f7926c79da038f1da0414de5ef9045480de51bf0ac22f68c1d1779f268fb7fe7e56e6bed59a28db58d9a26174151f54c2d0763bd44a1bab7259c98b9630d6e4b25404429000dc5aa2e035af845482b6ae979672bbad64647a98dfff8a8606d073d4a77012305e78b19dca3673d49419ff2d39af2cf8aaf7b8de53d035b913be27e715e4cd75b9a5be04f815d9ed9a12a68935c0cda139c1ed1619edf95987b272d08b45d09f8a3c17bd21562d877aa760af60f245df58602fb665913a2a40a84e3fd7dbcbb895ea067626712aff1eafddc6f375694ea305717d00ca6361bd347f041d71da7774f5995ff075d217f6ccdc9085347ff3a136e2938d1dd7d436d4a3dfb946bad3e03a193f6c9119207e89029e8767b06c89252749feb4e4a57608f37aeb3e1e9063992c48afb3ee902213c57574d9aceafe2ff37aa257655e6904e87af8f507c0ba4979adb9661162c4418b37849d55c37e1073d5864eff2695fd7e93c4b0acf6a4549ec1c16b802fcad3aeedbb7a5afcaabbeae0752da24530ccf47f0659b22a1647b7241188be64e0a88a7ff09e27e95cd6b03c441d338f499299adede420e3163bbb31e0bde4b6fe28f536c3d032503b5ffd8319741f92b29e8edff257878a35d7765681fcca9fcebc7b4a5edff5ab1d068ba10e83f3d9b356c952923156339d62e7f5b8ca348cfa381bf622e3b6942f9432d9de23924fb0cecb7995f2c243748544fec85c62c7d10b2a479152be7abb3a0106793569eb70650c3b25f7c2b823aefc4d4932b44dc32d3b64fb23d77bf03f72e63395c3840ca07a8c2bf17333dbf24b520035ee82e78ae7a0a743de87ae98bfe9a3f478c6af88fb0efe0b2bf402c60ccd41fb050f62e25a612b76c60b03e67a3c510c3b8faf239cd44cb4adc1563579a6050c898747aba16fc93a9f3791f4d392e33ee073282b144f5cd6150a4db300a18c4dc9ed1c83abc7c1af1a8f66613bc764422da5d5bd44a125a530737bd99cf2f92951110797b8126e092e687b29c4d70375f51d85bd5d200d4e6106b8ac662c51b70344dc4c830d9e90e2ccf6baf54360e6af5063af266f18c22da19c6931f1ca2b055778ae0111efe4ca5978a7c84ca26be562398fe04e7db988a1c39540987bc9453b3ec0865f8f0e19dea20e2e9f95e840a384034f4fb9a1251a8345048744097c9508af52b53c6aa3ea1751226fbd72a2cf3e5fefc62686383c5dd6bbc35fb0c0eeecafca634750ed51824c1190d75036e95432439eeec880a506be37eb516b6bf6d8401be91898e769df21156fef073d6f8bb998ba8c7d337ef70147a6a79f881b190129b24f861f130661f406fd59178a40fd1fda1838e6cb7200fc07afee4dee04a4b739ee6884c3b5638c202a76620240717ef79eeda42b75d67fb91950c89935fa06943c7c19528fcf2a31bc0a8596dcacc4732012dada7ca7f2c9c71b8ad3e2171a6671518b3cc27c2c74eeb4e9de0e1018b9cf69b517cf4398781b076839bf6ecabfe56891bac3f511bcb85154782674669ec889d475777fa6170e42d7f129fe8ab9876866f9bb89031fbf567472094c02cb1ced8b4beabb3b450abd33741d37e58f90894134bda9024e8805d76def3981c1e8b620281384c660f98bb9b84bbfc645667f87e09d049a1363db2d0dde23ce0f06a0c843a5678cf8322e1203bb43e4c5d3b953e8d567d0528f5374c4fed8afb2bf91abe2eb663497898f9d2b914a7fbc4fe4abf440d0bf0a3e374bf70296ac9a9425d5d8a7ae49de14a2a100ce54a2023d535fc2528b9c31bd1296a28e5c702584cecd2c65c9428f35159610ad8688b0e4240d42861cdbbf9bf5e7cc3ecd7a0f9677bd2a4085151d4eede2a73a8b838e9b7e01954e58f59562bfc797f0f7a4579040075fe2890ee06e508b198f379c5622e5e54cd78073c3d9990c933be33c8c1250613150059af2e572ce1ec1ce46d842845333cae359f8e0c108da508864d2878dfe48bfc5d1d703cb9c1c168d680c14e9b572e49c4d0bdec328c3964c8146d0d0f47b214b3dbc57fa5afc38a895521e3752cda7f8e3e81e51d1208b0e77a1f12d0611de2e71873fe878ac4b390c1a05dc5acd7c5a9fcc4b5d26fea6503831b056e6f6346d33cba4c1d72fd0442605cdac54c16e48087ba97962c53c5e2a6698badffabbba4ed6e1bddfad1a04eab7209d368dd2d80092eb4b30b6de7500ca327d4758edf27028956401cf1dabdf6b77243c717956d388992613098e92af394c38fbf10b8609bdb279c1980f153dbc2336bd647335d59d19c42adce8d79af9a8ba17a21fabeac69d2b76e04f33a9643f20f2b515c92077c7d6bf362a67b752dcddafdb63e6f144ab31c2ffd40f63157a29de19749d9f115ba2d8f011b7b130f3c3b4a47c6c44e0f2ddb24f302164b716362b35d33a08b9f1d55479289774539bf545a415068fc5710abbb6469c8c9ca737d6ba5669a946ff50661830a52d8ae4b9bfc7ef20f1b3aa680c1bc494e9651cc161da03230c7e95b223864d97017f5f993f7c36e4410ee75a0d5cb2d383529d19ba5f18f9ca9aed5ba714cd83b556729e4fad5aa5cbc7cbb26db32b7a0cce9e0f01da13a92a58689f72cf6ef5c1b327a8e3172d3b3d96d7b08abe1b588f33a3f7b3f33bfacf8b69ff80dcbc445724a992d7f8a29eea5f379fe61f75339cccf959db40ab78a5d55b7cdc56c62a7fbb2df31fe3c83a1bf933f1dc3772ab1e088f5f6327b5a11f0f82e35f504436de4798cb621f745f1c18c856e0eb60dbd63cad695f1062075c4de31dbeafdfc9dcbb7b2d8ca7fb730f92c9c97848b06e342f25e46d3d369f8c81b9b17d79f0d6485427d240b992feabe22070e75dcce99db030cff02fbc23e58d14a145d6a7dd31cb1c1dbf7e4a4a43f70b3b7c96d455aad90f3ec851872c7a2524704a00dcb3fad6a4fbd835fbd0d0419fe11b715b7868e01352b2cfefcd0c6a2ebbbb5cfd05b500243376b146741fb6eb9aa9000343720adfcd97e67cc7ac8885d876f174b085da86e22941fe47d8b9349986cdd4a84eb66da5c894a73e38c8736471c57316cdc49e3c7a0ac0434057182dfcc9fda03438f1e6b17695edd597982484adc536cfd21a42e1af2ba22a01e76c460c70703625890faf94c5a736c902e35104ead60436953293373b2142801a1265411808113a23e62ea8e54763761c29c7615acabf761948ac4344a897dc1bffe824ecc7020060de45daefb6ca8d9d271e765bd0081ea007ac2d95e2c59b5df3a4f785f9b40762372686fa4276004b89305546d6d8f183f96cfa85d841edc7aa16c76f14c4699cb6e216f95d3db4cd78b87b45755ca2a6f37e8aecee0b39c673bd414f95fdf03c22138e8822f71ce853f8f39ac2812725c0fab42c1a49fda2234f5e08d2c9a5a4e71897a39b6c68dc6cbb8041f9b7be01d7929a8ddbf89d31a123989f827779e82ad1fd1cf01672920d74c26b824716cca85b983c13d0830415e9fbb7c1f88eb42a72cd8b166d5583272a193a7f7c6a52f24fb4f90a73e889bb66ae9b5b49ded050631fe842bed0aa7720e22edb3f6ec862f90478bbe0e2390a57c9bebcbf06a14392bfb21825188bc0506c710b5b54c03e642ab28c72c124bd0cfc2d5d2beae7a36b5495ef9c29882a6b578b3b0ae5162cba8721a3c2da112d760438e7485e024ad3b20652ccffd1ed29a47622cd6d4d6f6034496f054a86c9dbbb6c76c2a9a9e95e2d58ff17c859aaed54bd8146b27efa50af59d53e08ed55d2cb2bd2675cb8e788930d12ebf9d2fe2ff0f4e2d9d4c6651b234c9646b7053b8c78a1bd331dea90231dcb4c43ecb4a4941987940b9f0bda1b70b79eccbc5398b4b9863f6bb9f9477b2aea0b3f5fef495ce992a496e30a38dde6b8c6828958df0c1872006a14873b2264e022822e006235e1800f5c733cc6e28eafda02bb8a5f715ccbd4bbb7484c2657bddbe14013c2426a2d3d8e35d069fdcdc9d7f41c4fed06491897096b4cc3284bf6e77d567d2942f504ee173cf3da9f3dd2704783a7b234c05e7234de8d159f881d29f4e0e91c8218a229515feb4203b59ee733db1c3eb69720a80a9e65e042172dab7f8e8dc8afc56282d26b56cc60c77ab77d47feac2518c2e0aba2c9a9aa01f8e8a066d5a7df7ea4749b5511537c4096fda4747a71e86d74b144f52694dd2be6ffddc77738318d3fb0334bc52102d6b39756aec8060b12cad3de23613ef2b0c53d9eeb3eadbc74b71e5666900e4dfa3faef95da7b63c5944afa4a10479fd63553fd8f418cfebf18c461e325d7be365563cab0ded97462074f42cf2a49084e7894d417aae056eb1b4ad6acca8ddb89322db96bbd1bdeeff34e3ac4eb57c2c33e9d193493fab2d8114e074e68fb8bd34150056c3938ffa5a4f8fe9cc6c01b5fdc4fc4309b957ffa595d15a2fc609359d9a9354e352b4c14391196dc983cab7802c8d5dd9ac91df4699ad3ec816085dc923b9243142d8fdf53c96cca20068b574a150ba3d2753bbe5b96ba625fe84b1afa934c3277632e0590f4e426ce316373c3df304c7c14e2581b7bd32da070d00e956f3b6b948595da677896fe1d3db29eaa8f4bd49ecec15e7074de223f20620f24275f7ff3f90fce585e59a92209c42ef8756e92ebaaffcdb58710b8296c24dc9695481c4cc6a1d4d03ab240113bd85a50726aadb710fa2fba1f48746559b528b578eca2cd6b2e41172d4e820f6b5116965fdad9d744383880aacc93c613333f9155a6d903a3732815961a1a4876f022773052d53fdfd2d90e08d1118196d6b01619753269b325a717b1ca8820061c3107b0ef86136956359689068e04d628a20845b63ac0209325d4102fd3b41d0dc6c6fd4677245e5d373e057ecdaeba48e5182d2ca18a3b84ad0039a5e4f6ed9a4e8a473fc94abe6eec09144330fbbf1ac3b249f0e829a4b5406b344adb80149f916bd3d7459940a4a60670da2434552dd70b4e4216c9e137568c413326bf6530b0aafa09a5a559e4221276794d86a9b7dbe26c33f3ac81c7387abc9e6879d23f00b7b3629b87c4534a7c9953282814793e9098ac1212a2dd4d1fdff1ac5d5622a2e1643933c067cc9dc010e2cbb469665bd8c09df0d00100379c1a923c2405d2dfa5a1aaa4ce64df6ebc92655780ca9f883f3b119bc9d186623506517332b0beb83ab966944a4208dfe9272343ffe529d996462721d0a790ac7100d2a0f7260eb38cb33b0483ecd34e75b580277690760708b37d83630da29f1f6ae5978c64c8815570c0787d4b4703abba88aeceaec1e0942497ebf3fbd66af8c59d6a2491817ffb952540fae742fe5d97ec3d961927c8956207dc03c30ac89faef36dbbaa9c92b8e99ab580a59abed22aa603945c54269f8bcf73e48354a3929f1392041db272dfb6d46e5ca48bf32a31863d552c734181557241c4bc8011d53e1cbcbb8c5f85e276f07e261cd6df2bde21be8d5eecbdd0f426c06901b67bcf967efdf2a17e273a32c352330a1c2f051a42d6e91b5c7bd104d36350043b0fa762310ad1c50087fe41adece606b17c7406b8f649f2fb90865f5ec3d9e3db32ff43a58eaba4a33d48e936dd982b86113d884942f68716383292f69e2d6094b3b409bd980147c3b32e6c9171d7cb921efd806b126b6cd413f3624700f5e712c38c6bb89b5f4c11fbd8cabdc5c844ec0f9666382dd9fa59f9e281d1683163722f60768aefd5621cc205e21f5e9e57bfa95c276e7f66fd1a38e6864814ada57610f2034d6c59120b25018ee0022e8fd200f3fd0f60fb7bea9b4a7117a88a6a466db0e1f2e71f99c034f6cf3d4ba74814dbf404d3231ce1c81dac6d9d384c9eee7ea7722c402e38c29d8d86f45e03ee671981de239d796819a0cc207ba6be60597cfd57f7b6f4f4a14ae00972003dc3fcd04d5c94e3437b7941e2e4bc2c780974e419954869feeef03bf90f31f1c7c13d369647b1a87269c61a7c7ddc90a8374876581235e6325accd1554d18b8c600caadad25532d630314117e18629e63861af1de7e0b2d6b2e9be50511f9045101f051b0754f8f7845868f5911bbc1792b76df012bff6781db3f233cd9833e856530c29371a46fe55ffdd5cf8a9cf09028265505783348d1f6b92fdb3326ec793cc372c74385a7d0395f4faa5a628c5588d240ca1b907a91e889be4094dff50c581432f8347afff815f337b29c2191970608de21cafa066a1190c6002e260787d7b6039ca3ebcacd2c754ecb3a8107cb9424eb6b41d789d986370a20d6d992d5972f221cf4d9b1ce12be6facd7e9d8b17893e4a2900b61e3d1999b2c466394574670cc69365c1f945bfc1f8b4569bfaec670928982a93fd77dd2e7a9164442fed6300253620fe1098b634d41657d85a7f7312456688dfd1e9eae172f0775737bb910d6c75bc1c0e81e3e43d130796b91d057f661e9cfa24689c5572eae3ff318fb7ba9aff5c2609391242f59b2b77ac1e8f87239113433029194060ff54d9156ec8f041b9afb233709bfeadf05caccfb8b2673fba3367415398812f43828de18f3dac5edac189ee2e898281a98cc9da3a282b93c0f9c2d0862d43af07b1c0bdbfcdf1e3886c470e818ed930d1a57754eb6db998e2ff8f5a66b939802ccada1e9e9e00bd2a936dcca26e20eae32f73c19c3115c98438a756aedddf533670a15dae977775eb2713921596fff56c336eaef617ffb7906f0d525553f84e2a9e9ae3755d311b435f53a9a8a8b7470389f66d8de281994a58d71bd02092c52e8f6adfd0132d68184123b976819dffe9467a4fda7a269dcc2fb32fbbd215a6c07d4cdc0ad7b204d01bfc8f770c069c3d8ecdf28af811b01a8af80946af541d2e2f41482d72ce76033bd943a84d1ba44adbaee9182a36c9960817af3c482953199cb394cf4efccc88162c938bbd25fead5bc45178c5d51de1d833df67ca963deebf89dbb30939d00b498706cfd2049893100ea11f25e858a08ead490e72c636bdafb8939446083d0a50b91200085ff67424048588f6ea22f122fc55962a623e37fe84da9219d537487b9242613321fa318689a945bcd58e66ce6b5bd978a287d58f2d959c55c96395763d9e497a9cf86b52695d33e2e445b8b45f3f9d566a9278f968758d2ca832467e42e76b7fb2615acacad09019af32bf2e3e64fab81b8219de883bf6c025a0ee7b230c0ff6a9261edc4b2924cd51bad238f3bd12c928605731e8441464e6b68d9be31732f91a1c3da892f4e67a75da2b2270ce94f1b9d21968aa1d08175805c70497fffadb46964471cb6927d1bcef0249ce0c9cb88903694c53be1655a6816e144ce922c445e6ad4da96f1bf0ff2f180c7722367854b45bbe01d66365eec1d54f7a22539b9a08d3e02489bd14650f89cff4fc3c87b4f9754acf11f277589029d1e871a70ba5423e1ec41b151e26f06489432e6d9e4857385285601ed30c9a259ecd3fed685e92a77f67dd9e890c7b8ebfb8982e0e6808a99a6b5cfe3080a895c38b03d65eaa5b678cfe630f6be9ec56766a56b33b423e386a0bf4a993703e9ce8c1f7406c77de568d26819445bd490da6144e13a24556b27ac6c6105bab39f9b1374df18daf9b3785b29e6b369af3b6cf01a604ed8aeb766ff951c5b5b5e9e3a0c9624146fade8f1bd643571ce7b5c0a9de5411bf6408aceb50b8f9be392727a8b70d1f3cd2deef0cb5f17a68a6bc09ee603dc08eeb0f0ffae4e3d44de275cb1583bf74279e2319640636c1f6ec6e563a4be0cb78585c8b750d4791cfa018623d4a35c1688388a29aaf330c0e83c8befe63b2c0468af3bcb1f4bd3670f52b7cef2ff4f96c0cd01c09875047b61ba383ca3d2dbf906eb367cbd2a5065a065b024830373391452ea3304093d040fd752cf13682e3735d00b0e3c524210a7ee45934d442344a3ea9af1436f3262ab75f300d1d85ab51692d962058028350e6c7f869f384b4df908c1e2e4bbe4bb6adffd2908cca2cbaca8c00f808f3f7f376fc9bdb1e74790679a248e1fad8276fe717f7c0986edf4c4d7040923f0d0a2325b09dd4088c06072576c54cb376eb0475baefa30c4ab07c71f5c06adc10ba4ef70994cc4694418dc9d8fedd6713933642a925aa718b9197f9ca7c77613c1d4850dea5cb4671a392e2ee09215fa3c7e93387d0346075a4405e28c6190350e79c778866153194776f16964f68e77cc20450d456f0fdbf2cb91fb19c782616966043f0944ed19b0a958aaedc2a5a3d1b0df902a945e938fbf25cb5739b86a82bbcd2c3130df0ac7b7c7e25a7768d42e38e9a46dc591f6da995f51956b63c8c29daee1637510afd137249ac813d4039d9b00b824062c1d686251f857937d9da132ea7d6b9c03907fd1e49136774a8eabcab44fcfc6678b54c1b628883de2437f1bc0c90c115b2d79eb541d623f322387553ed5828ee56c15f529a85ef3cacec2c61233cca6b4f719acdf1b88971ea1831e7b17aedeaaf729178daee5bb670baf137733587faea84c331202bb7ea6da6f660e3a332ccd3e795cfbac43499036c85a7325a077b4674665da75d489282586a55330594db0aacd1ce3d7a1ee18f1c04f71d7278c27e5a8bbb689a4ed2ac4b1aae1876239e72f6a60f908837b65262e62a809aa4a57f7c03ee49583de5dc33da520b1c290a14c7282d072d9e531670ee5cd763dbfc94f13b21cbe2fbdcba87343439515ce9fa931ed7c4b61523ad731e86627d66b0dee9bbea2b557a5a4ef771ee50cccac7d9419a87a7c94ab472f695fee7511003955b77e9796ac1d6da255d95cb98597e38783dee6742d17171e336029cac76837c4ca3630ed4c591c30107cbf3bc34dc4c3802a9ee401fd64f85d6bfcc6f9a79cc366d313c4f46194115b1ca73fedbcf4f788ad7862a0d6d5350eb7dee8d99eb2747c5b62ed1606462fd238756ee05e23f4969f76307e79b992e645a81e069dd9833bac37d5e19d7a740ff3bd75cd52507aae20fc133206c58faa18572fbfd874d80b7bfbbab4626ed91f500174e56008cecfd28fd01eee6ae6209f3af56fe54d66b427c84cdd06950a6e51d360fcc06cf7848a2dd775c36de85cc675645e6ca02f969e49a824d94a3097aabe482844db9075c1204148fc16b84badf5b91b8935d45de932dc25d782e03ec896472fba775506f22f875da7b4503b14e5a8b8ac23444defa291e3007b14447d752a3c9c1e77abeb51a468c02a0c05b5ce6a7f9cd882044f081b69e85243b6f2d9a76faa7e01009417b9991955635d19c158253226b49402f4dd2607537cc0629adbc53dd35cc7d7a020b239fdd3daae1d3f03afa1210d2e86a3c7ef545ae20aeac15c715e521b6214ad0f762c98b428ee6838da55317e433652a41d01744039e6e21f922a1358c3e774cfbb583c7b88c2d1487d584d0b69ed5f779502612c5219d4b795c737ffcba0e1ef25a293f8a23fc719492522d6fe21bd7ca5ae290824ac27d580cc94d3aac80c48543f685ba222179c8376b52ab4378877e4c80ab222e5d0848cdcf7d63b4e0b95afd7d07590c4f8e9eead1620d0a7c7eb01732f1574be056805c530833daf89bc1649596e37ecb9ed5ca78170bb9d525a5309f53e0e444e573ee3c7f9a63eb5b1da50e23aac1878749738f18e3496b8121c928f7b7ce21038df48feddf98033385f125772ccf27c97f9074e1e995049b4ac308a75dbde819bfe0820003d3b444d38cd00d6aecc086454ca0854b7987a2200432bb84f5d34d838da6940362c2258519f5bc3c997f5890e369bad28a79d123fcb2fc729d12f569fd8523d09e10add670623dd9d46d9a8ca3014301da1cd32fe22936e258188af3bbec91ee7ed2079062ed25936bdb3cfbcca76980d16119c9c92a4f95ebcfd8178737c113e920641125bf37fbc11c336f8b02930ff5ad9cc88fa2cf10a5debe64422ee7e3a26bd1eeff6e1c46db1323d471834e9cd42186882280cd8fd358437ed575f27edd7c11fb568f59deaed5405493a5bd512eafd54c1e78721a5fdd7c1dfc6b2a7e0a8d196f9d446d2e4a791663fd8b0927acc98a3d42496cb32c767b33ae8b5b8d9d739af7a6bd8f954e75bb478050936aa909ccf68f05b971f309cdb80bc207525b92b84d0388185a7a7d1f27555a3fce92c0e0d8a2a78690b903f7204de110324c34648f5fbc96f9709828e04665826cb699e3feb1217948abd1cd7f198c7e0f9a48d59aef5a864115da62c51e40b648bdcb33237eaad242d4ee0f3a15f4d15a7a0dca24b33f404e1f86873b467a78379a47866a0535dd3e4100cd4f376f6d2bbbaf60c88bd1a7aecea4cd3f57d10ee62cf4400e2f752afa89c30ee10d7d6e5ad4ee30e5d1b2df1245b53268b181c3e4517c76cc8b3055829be83a9a1963513587c8506240fe1c54a1a6dff5fe9cefb37d4228ebdd5b1e402f9ffdf2e77279c9758b124fbd55eb8ebc85303ec4eb158f46e52c4e81b9207d7ff7bdd78ce1494706ae7cc0bf3773183213ce0cf6261b27a07cc9b9309aaf72f5a1e5a4840bc89ac3c61db34f5e4194593b56c7ce9e374549b129cb0a84432add97026f59abfdf6d1478b87d1d928eb9b99fe129f15aed2ee1afad2453f9086a46095258a983d71ff2eb43ecf762b8a42c8acc2b7a38c4b1cf42825e92cd18cd9537d3f5e8c3b11a68d579b740d2dd1d78602ce0fe836475ab81f13a3a069e7e21b51de2f73d32b1441da31623f2ebb0077ac964eaa7143c30cd309001ac01ef4f781a8696ec15e9acb7224b4bc166fa2fc4fb14532c64e8410a1b8f7bd362e9488fbf5e0df5c913d30246a129b479388a4625be915c386463503ef108173ab5da1e84dec397c0f20942035fa150b7eff918ebdf20c9f8882ca51f60881d9d05a6539fe0fba3242e1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
