<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"115c8c5a276f39603f7ac525d14e409bd75ef31db8406e7b69f80d2f89f6d7505ff4889986fe67bbbe4fb1c3c305e779fd155c0b6617cdf7120fc117a643054a3cb1814128dcdd1f4b1eefb030b4894e22c1c1f32d13e3115f9edbcfda8a54d5f3846916b7d2842bf7de53507413180c9eddd2cb148fef6c094075d847adbcad169a9cef2371ff964d25906dfd43da66b848230895b04bd037085517ad8c3cb1a484bf8702d6896e5fc42d05c73380df55a39369ee2021903cbee496d29d6941b5c7ce7a913cfb353fddceca4948e845bbb276ed8d2b6fc5a37a11766f4f9b89c34ce4c59e0a03a657b646f7651ff3bdbf8e9464bdbd4c68984cd02976576ba6b7d8908f2d6b17f5a7ba930a8d0f5a4226274dd86066760781fe8dda4eae3bbb632bb04e54012adb8c41ba8ff6c85d9b6da78b64297204d103ef89326af21a83b79c8e1523bdbd1b34724f68cbc9fd90a2bc4400fd7a0f9a5b68a6aee28ed79d3d6a614acf34dee11179047c3003458c293fdae1119b8154df02c0eef06fc6415a27e8dd89fbd9b8c12252b0fc3260d75309c8cf1a1ac1397fa9d60348889c4d45e1344c2ef14b00494a4325df8431679b697b0c6a9dfac29c05a5f3441aa676f8c9ca3d3a5596a36993193657e73e8e0436935a6f937069853ba02dafa8acce31843946a728af24a392899da0df1716a5d0b54cbf1b11c12b3fc344ddded65eb30baea315284096b9ede7b5e3be660a92ca16827e4f5fa49fe1a3983fbc59bc21f8870becdc02fb2f3cadee519d18f6a480c9c1238818b06898903de3158bc99fc54305796a7b7c11147d83d6f74421537a66c57aae225499c04629fe179c04c0ea5d465b42dab87d5325704756133739abc955073eaf52a6ee819730ca47f1dcc50d269c04f5bebf672808109749210c174eac947d150ea5dfd381013b294cd1af9051b4c4b5c92673b0a308056c5c6fb6b7009907cc76d0166d4672dfeffb8e90afef420958d2fe084e7829fdbe096b930d0cc6c566f7848de621f3ec8dab3272a019a62cad7f0f21359a7a71da93867220d0c4b2e578a41e2b32138d1df32fc4e72331886da7a04e1b82987fa8cbae4e4049fff007de95703cdc62667ca3d4f0c15cf6e45420d09b85dbf3274c6680f24814d34c907292720f44c04b80e4f789159c8fec922e47e6c86e9eb39be6e0add5680647fbe5705c99a087a5e40d7198115234ddbf90001d43364f3fed006b9290c5b7f8405ba63b990804e48022e9469fd2dd14ba4d850803ea6c03e86c50e7633ddda957d341cbe4d50b6ba276d91a508c1eadc4ee57f189fd303df72063f4a82ae9aa47d7aa64ab30905dff36aae79814f8d9ebfa0b6eaa210459ab0ecf3bc77468c5ffa60e58a448c2e7db049945a8f70d2b366adc1ba39846a3c54a2992417cb477e107d75407b6c95a242d6805c0a0d70955d8b7641fd36db856a89f52e1e75a394ea9939bde7d018a700db572e8320e1b883a3f1a106aea0be980b106b11ffc473a0562352df6da9d2bf5105a16bdc130ad0ab3a56e00851b2ebaeb4871519e12490219dd7b5091866b14549ce3c94d3badbed07b05ba61ee8d1200674000bf98906a6ec0cb5114ced7b8b062f7e131fde15da81d1caa1d3af02f7cb394a846e19818ef19f6513805f49ab1df6be1d9133fcc856dc64304ac5328ff1195c24cfb4d25434978842124d7c49853c1ed6fa26f295a9daa2366435a16588f01ebdc268442aba8b86c50c31621fc81278def5b71e6027aebc49a921b191d418fccc810f21a328f84cd0eb7bd926322c93d6c4ab146264bfc5ddae88480813de66ca0e4f0fa256fee120decd20a0f784c73776ea1aa38057afef7675f48e6b9afb25e98c5d01585afd222a58f2ffa4c367985e9656083949f51bab483649f9d96599f521ce7940c5e7afbb9e482063f05dc2ce7aca848fb73d1c00072dba99a3f66b38d7528b915f5afab8de24da1b10cb224026dc8c99281bcb05fa4d1593d2fd2b7c79c69d39e69c1ad09e81ed09ff6951623dd19b83902a669e243f1a6e569a2f82cfdbe86ab579856fb8d0df8a6afa336522cfdc44a3d17a2e309e4dc06ab5201feabd94370eb969b3d0eb9abd65dcd41dd4cd203924e14b2187226812863d306e9f74784ba423c230ae7096866cd03c1eea50b6d00fda25a60651510e3b466b7d1bdfd68e975325b565971b13adac0ec1617620aa9cd0f0c6030bbe25168a834f0d8d9fdbd0c08c39199946a9643e0859950c6e57572331897079ef1dc7d28ff4bdffd6512a30be9d577bbcbe09bb8a5da06de8b3e78d4b43864104514a0a958ef794152fed6842083e139a087a3e378d663c1f6d59391738af06bf4c1039a0c1c0cc5f2e52611442c4e46eeb37a0a944b93904ac8a563dd11c84559b20d98683ca8fab258e35ea4da3657e2e1490129183b5c6a283fea26472691360410ef2806eabd1ac58986da59e44924781b401c4ce05634f1950ccb78891496b1773f2260e11b15c4fe01e678f525e4a1d4c0e2faaae2fcbf997e01549f50df07e779728060cffe69c61d08bccd74179764b11cce3b768f67d3881391cd6ab3a029b49f225df37451ebd9f6c4136f0bcc35d387378210cec9236a59d43937506a5335392aa0ef36bcdeb8cd4e0355a614f21247cee745e7f0319823b49eb8d593dce8090f37e1f8def4ca952d43e64d4c83fd445f493a9abbb41ab532a5d83bf02813a3dc4d91a5e8aa10127e0a45a170a3fcfcd6ddbb3b2987c19866a758a9086a0909f3490e3683ba1471fadea2b04f7b17cf8d4123664fd01f6999013c9534b8e64149ba5465d043610392b9e7ca5e5e858aaff5ef20019e09021e9ae8ee69a1cb03df7efc32ae5e8687b928fdbfa32c6d388f14e41c4a66fc4dfb0c621d4382f14fd6fe865b1549150d428673036f3861e76c13c363ac50ef725ffdd991a2adf27a2a1c6cdd9595e5cfc03f735f0ad897a5df4f03fbff1de50d0d4be27a3f8cedf94a7699634d9d1911e1366a48659621577a2c9046d27304ea46a041ca26b11cd9e4dcbc1e31c8ec556f3c44e56a1680482fa433a728eaa6b0e066aaf54e671759b925d9df21a9bef66ccd78356fab6f06628435f2adf381c61f4c85a35e103f00b54254b748cb4e68667ed9f21e478cb1cf186f0aab9356ce9d53d8f8286de450bc7c858e787e019df7e5978edff5decbcf774777a5b373ae9300e821230afea39e3d4d2db3ea09199b75237443e5513e738324b279ac2598c698ae730800f7cf2c4bee2fd8baf966d224ea6542a60b3b34d17774e165003d2dba7ca2050c034ca08ba03c10aca45a2acf47d07d5b6f3b4d46db9f4436322a0a7100e82d78fadc5505ca4175c0fc6531cd5b816607dfb3ccbaabe6c3065f808227421d2cb652dcca3ad47d8d4529696e1bd9b292cb0a0bc18c54e7350481771056ed178633f4a3fa04ba3a109512b251345f0f9f8975cc84729622c77380cffed0f61d65290dce69ee786f577db598407e38602fc47a794013a0a183401be71d57239c53294dffe24bf26072bbcde9c77de1b67dd24edf5d7e913bca9ee1b2e5daafd01b612e0f76f972fd84d973c69f18c50d6b4ac5814e0371a6e4f96b39d4a936570682b3b39f5a86e1a9e0429a95ff08a30dcbc22d55ed4580c73b08208a243ad9b53543c2bac91b4f44218e945a2df144c35e5c552c63ec31305622ceda961b2f6ca69e041e87bc0a30a07adfbb4d9ed35ff08ba66df8d9d6df6ae96d82f4f248eefa26b54110da827f233b6c9c8fe1e5cff2f3ef87a33afa9843f7b366ce1be9fd780adfc4d563228e6c948bf3462227c3492c71ee08726e5168d4acb3968e076f3b431d36ed7ecd59c51ae9934fd970d89f7c9c777ff1444230d87a00ef947a25acbbac42c45945448db5bdc9639bbe7430b4e06ac0a5c480947960709a61ad04167df6b3cda64a1026001aa73aef75999b83d47993c8f731b554da1f2db079644230b5ddc517da30276ece1a800a58d195e9a589f9b72f6d8d6c24e5bf4bc197e3ef888700729ad104d00ac8cd78ae6a54feb61643f7e6cf3209b4f1eb1212ecb5c0f065b4a8cc2390d8d48d6cfdd369d2aa4ab7f0c221ccb09b07f2c21cb9d474ca5f153150866b87cde1a1d94e8c24ed2adfea007625be764aa83b724b260f9a3ea8eac5bd92ecb96b78100d8a340f3fd5d59dddfdaa03d73f5f4dc5a3c6d77c4c25d29b0a4ee5fc72cc5ad6fa5929ba82aea0aa735795bc3fae3cf0715e59bd8a8892ca6bc61208c204ccdb2d498abb5594b4609745ffd2efcfba52cadbba90c9cd09e48dddf848b79ac71c832df72273449a0e5354b5e72bb89ec35460e5327c781931486bff02c25978a972c05b4a1044baf3d7c0f42a43a3b4c6a29de9ca9f58132c7c28da1bd99ca092717898247d5da214c1f074ede147fe1de2fdeb9c329a267919f4856435cc50176d8d23dc161d00ebae733fc87caf9a098fbf5058cdde41d0c814bea19b710630d6a890cf4ee2e3155260c82cfba4d2c1958a5576637de5115bf9bfbe5a8ffe6ca269b77bed56771afa99cff092ca9a3352b1f7b0a4a52c500c2195bf895ff40587b4a62fec66dbe15ccce519e002f70e4f82181d0245f88393163cb4f941330fc64686d7ceb6777ca02feabacd716530bfbf33f537a7161be7c80ceda40d96ff2100e14c3a08c6e08257aa9b9cf541bf360156d3ca49404897d7ff8b9ff6582b5caae2a8323c4a4a3d408c66a24db4a299705f21cbf56427fc42d2c2bb74db76a07a889d019dafac3f4a2356e6a3cb15df5e1758b7c398418fddfc262554107f2f6b1dab99b16e84467696368de0feb71f67af4900c105284e846d353ad4a048b215f3f4af4c3dd0fe01516e40f60d79ae1288328275f890f484d2c2c63f2026140788cb788320f683d2ff7405fb68b38412c7b13d6f836ca80aacb4ed4e594c325fa822b76e6ff1c7344a0bb3e467dd381e769168bf6453bb767be31b6a4afd800c757d1905c6b5938f71cf8de1b6ad84cb83d4e950d04607814bd2026dc6852bcb5082e4d9624fad77dbe6a7906ad4f6f132e15e357c561a0229226ea075a201724a260fd3afa06828c7fcee1166f104b0461ce9441a83ae168618fab6bd38f25550f480b983727eadfc9fbb8d79b97fadd44ae61015db980b473c341638a022ddaa471219eb7832025d5b8afd54e2fffff3713866e07e254215c0cb9a261daed082386aeda5d9ab68ee8fcc2cd7009c3261f29db05e2f7ecceaba2144687b4106e71844085670dca22f03ca51fc58852e556238929a44cbe6741f55b95efeec4ce8557ccbf45773697873e30dae235a8f5154a4c6462f34a70b478784c30b72915b8dc297394f3911b3302f68a32b420941fca0cf56fb1ae838269cb8168af6187426ac0de8874a04b0849f098a5d9f8bc18c8eb3914ad927d0ce640e9abc89d41077d4f749999e07b521911294ea7159c6e0c86dd3321a5f89b657dec8b70b30faacb8151632d2b4b437605dd5ee73976525330a794183ce0ba4c878b3e95aef7a9451277148bc674e525ce8eb51d681a52afeaf2416ae392150a3090e268dccd45a45c73195c90d2cb58f2819451c7cba27ef8c18353449dc23380bef6332af69b151417cd5a89340f08ce4d7d4c154111440c263974332e89a7092e418fd796f7c5dc347469884dfd26179c8bede75bdefd39d385c8fbe28a81e54e0b662c480e47b68287b6dfc9a6df34c8ced78898b9eed5ccbc957546794c5576218c37441b46d5107c559ded4c444a7fe7f49795344e7270ddb94b4407ed371f299af6d08ec71f3d2e8eb28a12a6aa0e697fc054043a37b20f93e9952bea49d8c1fac16cefb59380ee8300a562e06c63977f0d4b7f18ab536056d369619437538d10984b3662c0d2674ac37845a23b55bdf68c0522bb7b32a10a75b4f4146ae365b86f0024b601664e180765ebebd81a6f2c9806f5f7ecf3cbdad24b81aff3d9d01045634f7b3ae16e52a8ed51554ded430e8fed739e7bfce3148934b57ff6be1748ad39b367ee03ef807f6764a19421447563891f8c2dfa4d18ef5f432c192419147bf429d27ed0ac511f42a4e2468e1bc3edcf1cd2f992a960a838b196b5971c9919058fc4871b6e61fb3d3e6d33233c27bb7183788da04cae42ca8b50b7926a83199fca7f6da9f07a0dac83b3610d35b2f25655ece229d69d5350243aa3d6136a5f2579b4e9fcd342e2002ce8a322b060da6b3547f7da1071a08995bc543e64fe8fe26da977666c5987027b874b2abfb0b56c1e27e0714b9584ad1093e25e8e13663897a3d052c226a0ff633aeb2d537c6b75518fdfbb12b6aaa6e109166c3bd0db6753ed7fd109c72703aeed551605e6f72a814c9e75fe2a48bfe98dffcf48f882ff8c5ec8540efbb51a2a1bfc8ec93c310d7bed2bb28db27ec8eb279d5ef596058104992702d147ebc9d9e120a3944066509c84f9af407c6104283fcf2cd44d18656d2bc97bbfc99246076089e860ad0a2c070c9b7fb26bd3f5e50ff2d08269443aca5c3b8006dca21bb8cdb2620694d3d2b86073ab17f1053749457bef06aa2360af5f6a286f61c2248fdd095fb54f4d979a23abbac918fe72c0e123942916c34b5b18f719e9d810e321fd14009ffa23d5ddb357fdab6842f010a5749b377cd48a2541315c484b7e7a93e0cf1dae4e9328e2f52c4a9200d3e255d0277e3a7d24d148dc98e89d2d04bf68ecf32fb37922611f486c4bca2a3394a2aa9a9084e007b84fceba7bdf2dfab68f5e3c08cfb88162e9ce93b13ae2f779c9f5f56a838eab2d7763e6fc29efe0cc066ff341f9965d9508445f811e9706f503f302b81a96147b9b90431c5ad7e5fe0ed09c4b4a22df01a2ce4f6472bc5edc4226dea1f8acd6990d6f322080a41092bb4b97ff5b6540bbb6d5e7cd955cff5ec84d181c235ed48e0e242e3d7b3bea64b1ca4558da343ea68e7bce134ad1169f4ca5665b15fa8cef9db8eb8bb8eda7bb30ecbb092e1e7ad8c6eb90bb09f803db3abef576bb7bee0c50f58acc0cc68ece3b83c9263dccdc68cf03cc39edba21b1932f003338db4c7f92990a6b26945510c6f8e8307fa7e0e3e0823cc0d49e24e86b12d629a32fb49e0d088a359cefc341de4abef54384bb109b02313f64a1c28ffca7a5d383454bb92f94c95db875746f280b3d2e7be51a687eb55ec31c4d4fb4ac0c8e74ecdaf16c2fba2a553d8689a502be40a4e822bff28480a1f46036b109cbe837276a4d7cc4697748cae4621a7f76866425bc700566337d331a1548340fb485c411a70d706d83ffe1b7e9ce0018513f90b781cf60034d153854c29c1282a28b52288f65f8182c1cbf8f5d82c90904bc26a6d9a37bb46266c1ce8113d38eb0532266d320146206ee4718871336aef30a899eee509e531f12b55d8d449204aa1b9c6460b528b041948f6ab5047b69c5cbda2e03ba02614a671498af224407629a0f9e01de93e8b27abb0418c4f314e05f42156e0e11b06c913972d8f1833cd9e54e6535fb1d1743f84c269d81e17843be79c1fdb89edeff0ad7fea4abae405cb449b75e2336f57b2ea86bdd386c935e4fa52ae845aa63100792e9fdacff816e9e1b0064e278a82b1e622a2d05e579183f0a9a76d3ce6260a9daa7ff56937987ff62e47e407ede94a60eb820214beff8d8254a4319a4d5551c75e4c14fc9e96868f8adf80717fdac4a86acc9217221d6e284a32dd095696501cfbdaf71c0ff61df2586a393eb829ac15c2908544ea292b84a3cddc1b58d5ca4ac0a86149c0dad40f6e82d801a8d651a8422bbacaba9b9cfece032129ce72332b0e052ac81a733f46c44fee08d5cdf553b239e7d71969eca59fb27bd7031bf76c1d996650eab576a77f13cf200eb7fb34238c9090e6348d347262d96c731fd74ba8d7e68dd302fcc5cbabe37445636b4fc425ebc71c8d59a8f645435cbc4a6615d671db97ed5a3bb2d373c1efe0e266282f236ed5f4291a9060bfa8dafc52f6d58a6afb1abd6e5cd13db7e4b0c602b98961f19e514def5370c25d59476819d6ffce3e73b6c971dbacf57b3d9f2d57efa8a59a39b231692ce9981c2bff88c0e1e179d545e35bc06537dda9fa86f8680091aafe30ff7183e7f9ca38c3f288f08feae76b9d13930a65457132addd37d9faea364093771aee51eeb630f9ca4b44e5b73766eb7caacde4cb0c1047aed415e165408f42c0f3d92151fc5faa1c1f13caeecaf19dcb19b430397065b5572e94ecd2eba979b2fb16326da5142777007e25bb956edf6ad0ed20588c3602491cf135de02b9f0a04c7ab5e8eaaedaa58c17d0ddcf58bc002bd453ee7b835b773e6477cb0a789e8eb40609cf893258ae0491dd4f3731e983f9ac4dad3f7b9de4acdcca1850cd5dfe0e4cb804adac93c8113c5d644d94c0f9a9e56c6891f793a75b17727c8951e66cc9e076d40f27c5d784ceb2b9fe1a5a8194ff04268d7e78682960aa7bd26df66a8ab5b9355bac6fa7bb5542a7366535b322af841b68cb72ae88d3d9875ab08b5f2186684016ebc1a1567d63a891370505b76bf69eb2617be3c91aa3b963178f6b911127b4d21a652bdced92aa1e147c5f083765e3757753b7c070eb52e93fe8923c5d98e883dc6951b913b697025cbbd06cd7ed3c68fcd4d704f0bbe814e81870d009915877afb6095f91b91be3b65d64782fc0b0a944269593c9d5e48244e28afbebcb3689219f6013a81944fafcfe0ddd8af6d0c564bbec7315d553cd2e8eb42d9b14fa6ff5e302d2da8cf4f2369fd1cd9db4d521d481471eef3cd85f90e678cb066d570e300a1df60f44a09a653508f73dbe67abfbd643f3e560a2dfd2f96ca7e2d440bb8c7f335ff421bb6736f5768c1a7d4be1b22a4ccfaded6ad36b364bd2581b74389b8580e127ad7bb82a005e5df3d827521fbfbee25f98a2029e6661be11303939970423e3e8fb14d41146ba4c4e8a2c98d701c9049007a4dc0f000f7f9742502a302f5caac2dd9c44ef99dc449835d9d5a6c786de676bdf76678536cafd93b7e9cd900e4f0624f69577b7fb9baedc1ccd6d7d398f31a6f7e2975c297d1706e6dca01b0ff266089c8919e4a22d2a7ce572cf49794fd1f80de00e9c00bd84d6fac9996241d86cc9e61521a735a4de952eddef1227f475b13ea7a4db597128298bd2d12e41885f82ba5d5aa233ad44f2985616a2c7a60e9195bf8f713577d3a80e50598da4a294199de11175b66c1ff39dad2f53adeec1d455ce9bec70a5b77269f3856b54df98475ed8f18247e3c3d97e2c43f8dd3d0c5ceba9848d848ebcce057823bc40e045cdca954e5483d93d418dba01c398ca641d0f068180a61a0fd009883264f2614d1cbf38fff3853f5b8838e25166bdf084a3f4afe1483be09cecf0ba0df47a053028a132995d35c097d524a026bbe39998e598e00c03697e76ea58e032580db5082e95a38a7d8fe1b6e3b143bd67e85655952f21392a62482c8e78e4594d48e5ae514b8bd010eb86cdbb9e4d3fffa0af3d8513ed6e28ee69f195dba488bc8cdce4120b652334d21ad5bd0fa94a369c03f89183305532fcb06d8e5d4fa4adf590c9f490fb72a53793b90635f8bf97085b4be03c577e5da1c6675560d30152232500bc4006148548ecbf55b730cdae5f5e4037fdaa54b53df737b5da5ea6772c0e0e0be0dec448ae0a87ab85d154c8d3810a9b91768040b20afaf23190516d0604aa7a8d7d0f87e6d0a37752f009967d8bdcc64ec7882a3f7e56de3c283fd1280c51f66d27bc7acb07436bfa2b7d1baac08537c62da816a03d3f7cde6668d68b54b3274e65ff35713f0b02767811b781854893743f1241cb3033a8f5cf614b4ec15469ef5fcacd003dc62e73f54675f0c1444513861d9ec89d3dcb808fecd659c4c18b1b1219368326b796164c3465f57d9908821ebf352b49b307f21c456a6393b7012a963b4e844219df648add3de2d72acf2b007d3d52562c237e70c005438581b1f431bd20f4bfb7bb1a2da115e8bfbb0cd1aeecdd5a75f3f033f95021a8f31efc965295a908920bf0954dbaf02b483953a703cbc62ac5955a42e5c5296029a01c5f494b0fbcbdbb0969872043ef8ab932fe8ce1611a75ac24ccd7b2ce2a32f2826a5a4cbfac9e6e70f6a90b7cd9155128a641fbdb42b5f2d5193ffd578a6f97dfbd023b1b955f2a8d5629ad853c1ca355eef06a75e42e29e0b2c909a809be99bd78d9f76b1c4e2a7dd477b25f6575d1f599d7548b39c681a1463b8372a33f5eb57adb14b4749693c9c4cf018c163efdc8aa08b1c1af86671136a73f881a96d264c367c917e20f1c1b6e00222c4f4471f4c1d19b94b291356837b747a5eb61e223c0361138f28ad6ede17c07106dd606340f35fe9f8e9dd86449e805ffe78b245b824e36db6dfe697458304c815fe8ee59c78e021bf8f8d576309a135a22f4a12f06c30967f038a515627117fc39a18d05c1eac738632ddb9f130a065dd1dbad31f5ae5184f8aca778e829958df82164ee7780ac557481176a92f11fbe22072eea8ab7354f07e3ca3cac4605a48c58c52eeba55d528c907fcf886c7130ad4703771f9a7456ddf398ee5cb8035fe4d2b1889e25715b7b69df2d4f92acf1d680f5f17dc6d613848bd3f0877d639092e38aa7d636fd5950485ea73e16d3fb91f18a642ea87838d9753140aa18b5ca58a7c343d8d5aa23738c81e9961ef071607919f0598ada4b8906af14dcfc92dbe93b258947af187e108e86c96c71c1a1df2fcce114d218d388ed5b596eaa85f2d16d4fa70972fe9c6ce00e4b49a9b6cf3aef99e449682e58605bdef489951427c9a2bda3ebc432b38cc3e85c54ea57c88cf8a34a424904092a4b534f1bcb6eec214a038cc3211c8739cff9addf16bdd89978a3cbf3f4ab9b0a182a11ffb19c69d1ad1ecaefc4fe344f87eb14669c6890656d3feef2acf5dc8569016d61d943384866de8029fc7f4198438320573cd78df93e1685b3f98bd94448b83fe42f6df402feac8c8295c635548caf27a993a424904d959fee4e36106fb48e6518d7765dc8053012d84f16ef5852f2aecd59335c82507999f589296a49283979a1a57dc7b057b763701298052d78cff755efc09700a66d72e1fbd9d4f152cbf9039462260ad58a549d9e7e99cceac6dae20b524a09bf3183e94aa3dbbbd55aeb9d71d8b035ef8918585802b4c44d860f8d73e00b7a5f49bc257a3383e68910365093b16f61d41beeab5471cc35c09d3800430830e924e1d6a8e68954d845dbc020b4bdae3aba53bdd371c25306247edf81c42e1f4c9f8ff335a573c18c4188b46edf90da9ea517d4d0d3aed1b1c37135894c7439e94a8e1d40b9af80a241163893b9606ab5dd0c846a9cd5c0c016235f783fc61920ef9fe3cfe2948d8e17b3ae5b6c27f7c849ef368cb27a3488854aa2a4b50396377a5a0929b430e0852b31ace24828adf8eb00d1d441d689f6982145eb3df543c16c235d70704f82eff61a071a911e4a3ea49b953856681c7d1f0666eea98140858c1a3bd5b87bb0bf1d99c5916eca078c2a95d428fa8f3d893e2fb9bdbb26346de7972aac0cb6d3ce2dd438694d96081660217307cc7ff97f2878136d800021e50bc611254f63c712ba54e8b4f93d3dca9b4cca10249adffd194f619fea061d9731649383d95d4a12d60faed8de10f4126d2631482c42ca69f2998d8a1c0879f8b66decd87596353dc6ce98096d2ff65309d95a1e4d16826c409473c13e90528229586b11f4f22962ff2cb674fc30cb816d48b1d11a1ca7fd53f8ae37efce2aa8a04a2a0f4e6635c07a96961d1433f05d3c25cfd9c9d42458b35a878c0b5eeb56fdacd683aad74f5faa7c543a7bbfb3bbbfef7a1212fcf81fd612b86459766d7570a3ca14d573bb83722518fb0d0fe4769e29fbdbf3d039ba5ec8630f333fdbddd9bd9d9e3e911181fdc7920bbea516a4ddfb2a9f30ee383f725959a0b5b9ca8cb3f449aaf3057949cfac4511fe2b6e3aeb806bb35721e7074a934f7d4bf31daca0b73bab0d5de0de2cc564ebc76f7ed1e79dccae8af28182f6c55ff8209da454bb7ee914ae854ccb1438e337c297fd7f071dbb0b991f199123e676b5de4fa0920a8bb90c57b25c8265ac18e3a9bcb94f6e72d8c817907c307da1fb1a6de8b306b928797b0a35e976dd62739145fd656ffb05d6f8b348d988729276be4a88ac17bb686c951ecade197bbcd752f3c40bdcf4cd88eee5137af7c5da5f208d72ac65b3d64852d920c86c43a59449e50213557c23a7f170e1d4c2b5c9354c795afc41ffc6cc93c9ad05cceebaea1ef28a9dd8f79bc1ffcf2763c949bd83982f13cfec00aac550ce18919ccacd4ca23633fcdd209e9ccd87c01c4c2e0be73c558f856487bf59d318200959f549b5d5acdfa80fb68a8f0e4ded03d8f328d1328b0167de0038d8d9f87697499b6281dcf4b56e8d475e18fc93c587073635414cbc0438fd4ef8c9195fcfee8d71eaf6fb39eb26677e30aaf4fe52e70aed1dfb8289c379522e3082c6ebaa8a06e77965577c757b0598fc3e8da822ade42e2ba54f70420f8594501058f8382293f700669f6cf93e13bb1a1827014fd6398051ac755226e26126384b70a3fd23c1951987ed1bca0e130835d90db31b34b8d234f55e1e7f11705d420ae4d6c37fac4f36e188df954bd1b720c1d84cb5db18764bef328d4d4518eb318adfa313f8642b78766ab79404d99fc012415f4913b480f6cd3d74320f4ca89ba943db6bcbd1f65fce94732af1f77ab5eb4dd9f51c9c3783fd4d938b0456769928077dc4701e5d18b3fd2511db976cd1e5d84d29bc42f7ac6febf8ac14ac64e34c43478eba56e613555d417394d8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
