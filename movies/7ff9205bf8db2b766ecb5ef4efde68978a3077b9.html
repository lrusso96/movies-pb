<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7929e402d3ff1db0ce0ec4fb87434e419202ef5b6eb150778507267e7b0b8ab6ad5436cea1121b743e2d6c4faacdcfabc43542b9b3568a8a0cb2b5e43f6f1acccdade8694b55e7f88e93596d408fc8a591b50d3fda5c2723ed08ae652b7efe43dfac747c8c29d3319c42957136b7caf6a27434c4fcbf7bd4962e589a141abbf500d78a4ec60a8565b2d483b00e203fe1e95380e3a0f50154c45b8b39f38a65607d90a940378ca6c1f2b213884b3f02cf54f0faeb5876ef43d99a601a470817a1da510fb312f4294ce89357cd475e1a65c4f15fee69291f1f430cce18c325de5cd240833160eca52de79d44c0b587df21c7865b15da9167b103df0c52a001eb6d5ca5d4b5a877d229f72e75f7cce23a200503688cf911c11f223f1c1766c03229058884dfff884426ee694694cd2b688282afc199b023b1a7b483d3d586a44fd6470c4d4bbc565ea6653df9894e3fafcc271d1847d152924a951a687c4754ff7326cd78fb4c99d6139622ac5d0113952d491fcb5f8a8aed8b9f00b850fb9edf76651f43412310a84d1775aae37f6056ab17e086fbf1c3027d75c7746aefbe78c261501181d89a7577aa67ff1cd62b8ef232bd1195d9c64eb61b104d4af7fc7af16b6611597ded1c0e76bc1c7aef48cb67acbfba6c1fa280c2b08669bfece5e70dd562c2e59260a0094165c8258418c63f12752635daf4ad4605f8c013e7195dc22fe77df6f5271529cdf87df575377a75596ad8d1dd2987817e84575a82937b394ba671e118772d0abba0bba692d6c82bf9dd16533348d34aecf27a841e63bd6d76ce86ec9ec866e39db901016c6e658e86d43ca6edabf1ae746fc47a2d6220026c54e7a07ad8376b91e1095e431610e3e8ccce007869ac8654a20c74f879862e13e286d07cba7db70ff81dcb968250b547caf891db9ee401950b48c04da6798a93b42949cca2808cbc2bb2809747a679cb80bbd8fa91f3c4ca827461e1c3d3f10b5ad7771ffe0f7c84e585a9591c72f93e15046d4ac72a3f8dfc1d1145c7df4f89f62de0cbb5ef0b4aa4bd6e7a334c5dbfeb0fec17e541b045048f3d3cd40da80e813e2d42837253aa20828b6a3cce17721116da07257fae92b79e47a7712d01b35534d293963d56541ba3fd745de0bb3e263e1f4163e5b860e57142944e9c8c82eff6642815f98d2214726ae282401d1058117e30ac8500f50048db859963d25496f3e9de81d396025cb64236cc0b592b892188d87b3995f14d3895768827c876f9166c0b60bd0fe30e367575a6c73333efbfe8b9983032ea98401e16d2ccdf5189407964e41a8543947e9b9bcfa92c4202ad17d7470ff4fd5356fa10ef23f6d830017c01b23c75f4794e95a3387c01d6cc6c76e04e9223abf71f953741c2b51be39b49e45000c00190b9c547a883a8c6ba6ddff663c0cc8ed7cd20b9db6153c1cd2c6a8ae1a6f920de4fc4e764c45da1e852bff641064a54047986ef35f858e8e09a48095e8e340e982430039a3314a9453221def6f3483a67eca739aa81de41f12a53a405c23a83e6cbbdc9e078403a5aab4be9a797c80d520fab772ccb28f2fd635d09407e4e471b20a096f02f5c753627f4103fc8fad9cefeb7893aca84d9cf585098bc222b04ef14fd6d0ab227020dd8d694b98293a3711fea08ea0220988a168f43f62090e8a93bffcf430f5e29f42ea70de5be9f28bfea91fdd0f805e21a65027b1284a4e510b2808fbdde13645e3a388c1b9a9babfce84cd050c9780f35793edbfcfac4161d0404bbd97e82b5f4b2bfc844cad12c7953d26f0c79a7f35e43b3c5f1378bc0576a37a150ccffb0926075f0e3296d1173d7c3487313dffd4299bb50bfe9c6628fd65ae65f4b30c28d3861d934c000b8817a758fa715a6596b8db95b89e5383dfbe0767ce2182c5468af8362851e09ea0fd82a82a146cd498ade4c73115a391600c555189acab08ebd3a3c323a08427e5710485cb8e8de5c9a1e00b39608f355ba89a668e552496e597cfe4dd410a1b7cb76603b433e9a4fd85de892208be00d10cfa0dce03d1b9c1385be5b52da1ab1302215c0001fb4d954cf0e8adb7bee3b3d5edc3d19d4fca8c200f2c50387a6c02f70722173f28b9e2e299d1d3126333f231cdc86a2dd8435df722ee83455168ae051e60a425a60ea2caedaab621526d92bcd6e33bffa1fce6fdc00ba8097681a292679ad61f9240462eac02b76f2a011ae79eeaa39fd9663c66e6b445103f79bb52fc5bb48e15422ec0fc174a024d52b484bb7d825d4d435bdcc49779acdd187d823b4ac6ed1743e1bfd3242e475a9896dd8f26ed4b053f82df94a675d48780590d862807ed6a1c2f9f963a9672909984b854f70dbd350bea0f2c1faffbfb064a5d14da62117c474b4b734ae7ea668f0f6767958d3522c602d0807a539bfbaf5a4251effe94ccec2a0468eae26feae7ecafad3e54bbc9fdc28822944e91dd0f30723e35184069fc459d3c4c12ee9e9342f1372c3bd0efbaf3684654977f7a77f2f3df2418c020e3c9bba0d842cadeb4c3dd14e729cf2d95bc47c5260a46919cf0b263da414bf81b0b34dfb1768cfc5f7616b85848d80a1ee0ce6503dc46c026ef0896ffebaec81eb31dd42925a39ce31d22d13bae4ca3779720eec5391b493f515e2d88881b07f5404e0d445afabd10043a42a4b0d6bbfe46a323c9e79fe28015b1ab25ebd207bd93309765ffbbb6f47355f6a2a021692139b997f7d525bff88d3dc6385cc5fd02f513ddbbd85a9e9faf87be4c43e39f54b24f7f67adea6c2c76a6bbb9277e74f0c7c24bc413c6f6ff47eeaa3d68203b207e16dc0f40c5b3edbb73932577a043ec137f64889693f82551ade58706572c96ff00586b02d3840f5a3a190855335833a57386b8bf76c119e534d7624e6b0c3c6b5a2f7b81af93a60d3cb88c453dd61c907c6f7d790a7499795722c9252893cbc960f7f9248e2092618851cc2625bdf3816f5cfa1b6eb38f11188b918de086f2d7d695edda894d612e106906e17370c9f86a2198faaf3497f5eefbe3d93c30ecca72ae85c9d6965f718bce026c0984c92c399b2527281f16524126dbbee5bd8ef6c361627c05f6cd82a8de75205df0108231788e1956ad5665c6598d83d0ad519f32a7ddb4522a2f045c0427309c6e82cc6bb4072c46ee1dfccab50906202cec0bd53ddbff25be25f2dd5b3ee5660685a15a7e712d8c67587dc773efd4a73cd4b810cff13ce1e745194143e9a0856a5b25167583743f57e6f3a48a3025431100e260ad23ae727065bdb622cd1fc131b59da6f42a26016ba5e9fe4862dd0d1a62f905d09744aaffcb092206e7b985b0d7e1fd45f9042db6b5b94ff93618bc5d229f691d9b1f931c01af779a3fc528b580465d289127d75e7e479a3fbe4280e8876d6d07bc319348c13d2a977388123a274c990e26d429712c62cdfe3a66d0f6e5f6e36a493ba0fca9b35124dd675326e90ddd56972667ad1ce93a332d6fd5852ef0b5b20a6dfa229363b07f5b8cfa7f6d91087e014bc5d5b098da21f9a6412bd5e2d9028b5b6a601b0e5bde7da0b550d365ec49f4d909747dcef92bbcfb1fb77f80cac579dafc6f819898dbe01c215ff458fcdbb32300e17cdb1227ce2ed57122a0a500f791f93f842a74d92717055139cdebce4e1932512a3d81824d58fb68d53c13e395414b932112494f03c80b2115aee591925593a6b63f73a5a181e0b78ef1f57b39930008cbeb24b4d59c07fb15a00ba619bad33f1584b45c4ce501f28d1ff8a6dd3a0f9dc3566820bb7e4b677a2c1916b5067b79c9bcc8dfa736f5d95d3371b9e08a9340d6ef62d8e12b5d01d23bdb188ea3f20226c9ab914f20934a99e692b92804e239c59a2722f4fde212a57bd3debfcbbd31750224dd709db1851030e8fc1317adc2034e6e41a5682cbf64931e87cced15d3c4ac629affc4b753bfb556bdf511f0f2492113a95ae134585ab92584dce7c0ce23a6bd2a721ff27e743f663fd169143531b816765d48b16018e752803944517356ec127ffc8dd0728be75863b36b0da4101125cf552a5fd879499e1290e8a4730fff9c3a02e95a3d150cca1b63741fc63e382df331b5eb00512107c2883342e2257f87b8119fe0e55514ed0c65f4a82e1e28e19149a34b79a2c01c54ceded97cdc10ace7a3b8badd8869ac3ff8f4f7a7bac50e086897bf810f4bfd404ef19d58e0d8c079c85cd78b3539051410a97a9e7bcc1ee6f36e31f9b903b6c646560a590b14bfc5c4c3a021c8dcceaebeb22d73a38423b211bc7c5e032e3bb8d05c9cf4fafc693fbff973c7cb5e01265f8ef4f2dc79122bcba62e97af82e33120a096265a7f9ea6cc813e049dfcdc839e5ae9281f6ac683ab45d2ddbd6d4a5b8b63e0d9684ecdbac9a1e3bc04c3c4c6abd0148604d697cb611df980755b3cf907506986bfc97e4e3b707c3b01f0de23523de3d0e1901c0a0bbe92787c6557bdc260264b2270ef8112eb390336c299b11e7c848db198788a52147fa7bfa33c6c411ff1621577213163838799ece0602577f3710d7cbb5f84097e2f34480946d4784cd7f48d6d44e3f12f2390e3e98099deed86470c3b8bec1791d35a81a67028dad7cbbf66f50b4afe783bf5ff1256078a9b31745353bbe8ccaa7f9b4a4bedb856b2bd4c97640bf2adec9469a6fc6e8ae4cd557f999461526505821e9a85aaaf53e47ab7950b8c6607ed3423472e98d9c532f4960c8985fff7d3e848d3a1f3e7f242187ff4b0855b77122b81798f767407d20424cda0330c766f6a65ca639b9cec96ddce5ab2d859946962e5439c6d89bd02c0e2cc8b830920494710bacab7d4c4670128778cd446ea5ea639712490d4e36845ef14eb42f9913c519a5ee143df3cce1b43b099de165e4e9013d913106f76f770bdc1039fd6ffdf829cf16647a054bc0ca229a6568a772f2c46697c99f6da990c5d6c8d8a5d9b6dfb9ac419650c7d2e74017499a94bc905b4300cb1458acaa2f0ed88263c03a90adf1a81228468eb6ef534265fd21004ea02508f9b07e9bb0e54b0f0dfa8955e1b4b136967efbe2e5cfd04a0d1eb60841d4d1db7f2f75dbf18f01aa808554415254c08ad12c9d525bb3059d015d211dd2906a4a23c2f99ccbba6bdead39dbcb66876a4bbf8fd64f2ae2a681b906bac5fa3ecb6ad40545412820511ca9d1d58ede0e6518663659d7a41da0ac23955ab7525083ef19e7519dd516d923b27019a0a46dbc339f67b6844d7975250c72d2e64793cfdfd8327e2540428073580ac3311976eb98693770661518f313abd040ddf54f7c63d5180dd5edb7c452ab0c78092f1276c78b4ad184bdc790ac2e7f434d887e1b7c1cbf78d7e0ac6443c22c78d79df44e5d149470c2d9a329ce8c3cde4a4749b1fe0a32cc7944d6420e3cf8672bd461bf9540d8b3afd380320b9f0fe256f57633770a67ab0fc9017b57b92df1ef7b28d494996813de7cfb6084805eef2675096eb862d4e3a77c027d342d89b576fa0fab47e16a419f2dd48cf432603c954e68f4663d45567dbbc01faaa9f84a49e48f07f8a424d9af9609e13ad707ba0bf225077ae7abd330c5318208c12a4cf20fd9f29db5e2149b58ffd51a7eaf572f59999a75b9daa5d2b53dcd15aad8be54f052886cbb0be3fb1e767da8608697c44e3e2aa1c23ab47bf0bdcff9757ef2524fc299edaf844b676ff3086c0a60d572fbcb9c8c272fe158c5db3df1c3f69b3c3484bc3ffac65b99694bbd96de3f11d257be5e467be0b0f062fb7ae0ff551fb500c7f9cd2a459651ca4b64106eb78fa4f278fdf0eec339e7d1458befa5d69a2b3a3fb6a5d12946e6be98416fbec776068f5629bed9ac2917145677529b25befb77c00daa87b195f3f14384364f3ba75e990d03cc2dc764d6a07406cfb399bbb394c1327539aca7dff822aab6f4008671ee66fe72df278dcafd82046eb831ac3c88b8c63ef8084f1902132452984799ebbf515a7bc159d7730f099022c687a366a74a9ff59a2b5a32c6df1c7cf015bc5657d38daa9723c74953bad1331afb8e3d064d3896d9bfeb54bcf790f1ebea04911adf49d9e04c89dede39e06081ea58a3c04fb2127784f196ff9635d0024a743e580241fba4977268715bc9a9d440ea70416f452a39d0b59f67cd3151d2b39e8ad776ce163527d51beb9c6ef5de9e47159a87bc5c874f9c140a053e0bbc07add743dbff756c6ddeaf8881a07180825e56c8d3ca93d80098d7a6d432c2ff255286c29c7b63c7332dd53302020cecc1ed5bc975228dc8519dffe41a80ed9ccd6c8bddbcc5b5c6e5567553d2ad9f651a32d91b3b8368e505fce49d173b6bbc7613157328eca77a8410f0bdd00f6db79db11609ff55edb8c10a91bc5471ba4174b8b40e9c3df63c4eede0da8e088dfe43f041eef13ca86b9b8276d9fd919dbe265a7c0de72c9f3778a8fced29732a7b59f60f42ab3bf385b30c43b1b5cbb24794b3b07fa641485685a37f4b5b70394048b644f67645a0c3120dabfe9033d09883421fe784ba59994a44b57f07f7a4e5bc375eb61cfc1c4c9d41762c77dfdb23c0649bdfdd140e63bad0299378f768c5ae24365a6211e326ba07134c8e0e36180bfe011b187a5c7469492837a783296e7d5e2acfa99635eaa2d3d19611d1fdc9079adf83586a2a7907859abb5cf3600c1b00be593cc633be97437b7c2d27eabbbed2043714555afac8b4902934e4839b925a349c9ca606f4bfbaad48b07f9aa9300a019e4943299c3e911593f296dd4cbf2dcc19fea0a89f61f306b8f1cdec5d2fa8fb516226a9d996e14424154d5fa4aa0b3a6c73ce456ae67d90f29a30b945104881120d980bac67545e4509e870bc0816efe07b6fe0c70edd0aa4c86915d8b5db84ddb71a1904901e5defcd1f2eefa34a31ee0ce2f3b561b69ea34b787fabc00f5921918f431af9c4fb8667a4ea6cf5eff0b070d6ffa906505e76c5ddfe72eaf385a7b9d8409026e0609908c60ed179755b58494c3c22e99f30cf6270c7fd5e0ee24470fb69eb935d15f969c5d962aec6238c1bd57cccdcf40ca979310e77b4af7e165020fc725c1628038554f3d7f83b28827214fee743430b395e44843dda94be409b6cd3ca3db42bd77035461adc174006df7a3769ede53caf8a657a46f448d1c32f01195739d4bc52c804a7b4205aad2929440db392aef7f74d76b69a5e95347fb723b67b84d54b82a4796e8e70f63cb857fa11ea13242091e51a2e4c16c753b3def01cff15d84a1eda985b9adaa9e1d67a4e7a43f60e64e0675ba214cddb97348610ebeb46afa5958e6e8526382f75cd954f47b5839b3c807fa0f476d77b600d45ca5294206b571644bf443a7b6ebd5a14f06b90ea613a9db2cb6cde3671a31a7395c457abac9186a2a2ea767d0612e3fc25b7ceba35418a8260097dd8b97dbf32307c5e55774b1db85f6f92d08cd2f8f873b8c7f96b2f92447c10c67cf7ce2b6ce992e0b4cfdaf2f22ac4c6c18d0260512e355089bb2e8f3111b3686b3723e2fd324133e4cbc0a526a640432aa39628832873e7f75b36fbc03d9714ba379c4617a5fe96b678e5f3c1df7de7090b4648a9b71d6458b8d8f099c2d516b5eea99e55ed47ceb1ca552bbb920e073003493c54fe7d83b1472ca6ab0d6ab7f90cf3546e391771f28718722b86871dd5f4f8bf608036373bb2fcbd4b2d38632adf8b6463b9d130d7becf925a53500ff47fcf1577b52116525f4fa28fcde2c8414521915b33b8d528cc8f98f3efe936c24d20ac83e6b4a10180478d1ef72cced2eec6fcc353da28f2dc51cda623fa9794e095403b81ff70e481e5cf2bd179a512ed0fd9c8c1acf80cb8a35424f9173c681290152eb5804bcbda48595e631f1be44302104efb447fa6f70a6a6bc1ae4e669422498662c0aba0ef8d34ebab17c9f998785922d75627e9ff1c4a4fbd8140e01c7d9f02a62c9242d409b330de58e4dcf8d8f1d7d9af1ad9f34fa095440652de234cccc8dfce2a40eac44d965a7f5385dc338b9f6dde6ad667bab8732f17c3bbd1a05c476a69197445651cb3d3bd1221f97dd21287a2428b54aae813ca22425c0b1324e9613a556c346b5df357d46c1d074299e743547430d50fc82f91715132d2faf830fdafa9edb780f99ad6957be0987b463aafee5551c8a03b4a6b7fe3337b3f60c3c053c7316483f24c2933ff7817561cdddf279f3dc777242611848437920f4f07d47272d1152b467de0254869c2f3b3eee12bed1208bdd918d7ac35f6ef0ae5933f0e493c70fadde6a7058458566406fbf9097571357e0e3543482738f803e31916c2fd8e63a529addc1c095cd9dae7022c374aa64561b4f23232452c3f06adc3e758be0620aef3afca736b9369e6ff99c19279c23e6beb02200ad28ba64fa9a04249167b6cdbfa4f147822aacd57c8376b92f4b51ac2f7cfb36c639540e02e1a7d6589d1dc11f925a977c3a57b3c81c6f48067e629ad94c5ffdab462cf2354d6c07eb0126180d9cb9d942a421494d9521c0f9eeade91c0a5bee3b407018659a5aeaeeb3e4cadd318d8976afe337534520f5a43cc266c4e466dff4ab715aeef03274676189fb0cd6a45f6ee388cb733e0b57978cb48e151cab49b75a00adb1a7915b1e84bb924d2112cd396bd5f869b79730614c4b68bad688110ac3cc6dcb75a90a8bbc266aee313ca97eb0802fc155ad9d5277a017d4b3bdf8af67297c938c58372b4a1d1b01eea4fb25013aa33e475d2b1494600ce2ae114b014b9732b4d3d4c9736e594def58d9d038882b294b5ec3a15e391567058793f7054be34ce0e8698fcaf0b672766b13e175a6a93cdeb2ba051b0a402d5b532d22360334a6492022fee2a8120cb2dfa086996f7ee848c52c555fcb468cc239a25c1853cc36f86b8ddaf802ffb2f3859f43111da4219bc15c4478bb7ad8da1fe816e3dcfeb9bd9608757a7b5d6e14a518213f946d4d52c6921f3dfcd882424e9cbeeac32939518d909ecc6ff39e84d42b3704ec97f7ba6661d3d7bb3b399b62cfbffc934faa4870325aaf5566755bf2eda813a7a7279b74a0cad35aa4b8acfae6f4c74b1befaf2c92bb1a08474452262e2e7b01565823da6bc855cf4246d0bf2bcc2f39dd46823240e0a0c6389ea1949a136d71d0d527f32ec19f7d71c7fe35e526ba72b0eba817684eb7e1ef5dc4c891bfa10d0c1e3f9a02cbaa97536f66f4715743a5b97b44104ae497abd70c1dedfe21d90c23e3ae5862eb58a37986d372e1654184d3d804989978e441365f2837a8ee136da9c4f4cae10f215cc47491d5276a9e94181750a34ba52692360f0970a0882babe00cc752cbfe76e3608f4d4302956123a950384288ece58c0f27e62112c5dcfd08ac344cdca1348c3dcfdf5705098cddf1a95a2b1a21d1a9459e68cf69f2e5689e439ba47e7f695800395a4a5eee329a24bcaa52451697f5d2aaf5b9c8013ee9d72f1da0e56331b011b1be8987d77d680bd6b4e8a93430e24363cef0b46cc348a1e9235eef1ba1cc007ef9779f74ce30ae411c66163c129f761199a32cb981560de280673ac3a233edf7ee9e5808b7fa69a61d6724aa1b7f5966f3bc4d64cb6b04740c190cc900b212d2bd08aa80d0acec3a7028ddeb2f5421f694d884d8e906ddb5633c9262724d288950977bca188455b383297233d6103439a583622a2077e10b9ce11b44888dbc5764b08baf85dd86e328a3a2af9d9322b5ddff0c04d259b72066be7220a9c4e960e0b22e273a81fbf305eaf6347eb1c11988f9718ee6f1d0e151375a58d4894fd465684eada013f5d0e55bf2a51b1762657af9e8e9e70150400275fb569865c2cc85d8516fe6bef59207d053cfd6f24efbef47d05793eb3053b63c8e4ee5aae566b9b582510d3f72fc1cdf4711980bcaca7a57270c42ac75115fb0355c66ceb1751fb7016a739dcdba3b2096c59a1ddc1b30c53cc0d6ebd018712aa7bc067ffc6467541907fa5ca6a6d583386870591240b87e1e010f3bf602ed0b56ada05ea155b7baf6e81ad76fc38dc44c2fbf4159cb1e2d091ad1c8a5700967d7e41acf9aa5db04c180a485615714c27a2bf809f853766077f8ae53fb0dcf3112a762d74c9f331e11f4e1c03d48e6db08269fb94b7b4d6e439b3558dd8027eb87b2a78990bb25faafd715977ef5598c85df94b731377b8b0dd2babd4ff48432e2bb621821d004abc5b96c3ead3d08b9872d5c0b4aa097ed0268b387a56da1cc7965e76f8b23beae7282a6e44e4a5f56db9a2a976f1114b2304abf5ff90ee87b6378925fddd933b67022336d91f72064007729687557f7ad76ae266bc6406d1efaa41eeb20bec144399a9415ea58eea1ddfdbe511353a344315e8c194d42b458d165bf870050d1d4ce5a3a2423c18aa1af2e961a1e44d1353a387eb2d3625d4fc0b405fe62b8da8574f846f653c8e48fe36922bc8c39db3605b0adb7902a11c2aee8688e93baa01d62e43683971aaa5ffcd0e2f320ea6f7cf114422c435289c1d2ab2329d072b84b899fccee55286d6455570c47a7824888f957b7b0b2754cc85bb8bac7d8f71ae96ba4aee0f93f328d9fb81bd5f3466d436a6df0ecbc4bbbf7813a5c605e7aa613a0c1a7b4b95a40fdd4b64cb4fe7fb3ffc309a4f569bbbe074de56b1a6a12e8d687101fec0330bca4016e47ce2c98224755ac598304f7f71acfd891e7509707adcaed8219f32910f4673e55b83811cb9f4bdcd1f0310b763760fde4b0a942d03934bd167c743350c174aecfcc33827f35e007e9cba4fa8e02a45569b6eb3f1b426cedc35f67a9f33466b6b3285370702a032a4007e737ca27a955f7c5cd7ce5b71a3c13725514bf1f82dd7d1d4aeb888010d4746939fa099f8a66aa3b15091c05780cf8ba58fd84acea6d68ef19cc6a6d4e693dc1bb574bf723cdb2ddc53bb8c21533943cc38672783fa0bfe90d0185c8516cf05fc1a62045a7328e08276c3c26cb97ab461889964bedf03e611f984bebd172dab1eeedcb2418b16aeb6f37a026894ce44ac47ed81e15a02ccfee497cbb55542b7cb17933bee86b6dcf9809c867555997b8405e64a7bdcb3c75506d7c48e62a38b85b2e0a595d437fbbc5dd14c3c2685fc9a31ae895cb4e09afcbac03b8f09789250a3cdf12faf4c17b73920919fa6400f6a04581bb682b0a77c6140ea72c146f2dff0189876cd522b40b14b0ca0ca45f125f8c32448b339167b9f658922852d6093a37c9fbfb7dd587fbcc651c688f24e03618bf78bf13772ecc1035c63c3a8371ca76b88361f0c240f2b4a7b191b0820f4617fee30e3c22b446d6009ca030379b94dbbc8bf7dcab1bf374b6bdc78fdaef09bef838aea1a9961ddefc8e3685fc0788f5f3ff2e609f6a865f32ac25b75d42293231ceda3b83600e981009ef39963131f44eab3ae6c82fa7f92123a1cd644e6a509df4bf52c28247ff1efadd1996b9ef26b7397da460fe0dd1f291f19d03ca058f42e229459e2e0dbe2ba9c0787d8d8ab64bf4e0914287dd2a40445682634ca2a5edf8a80104b41955c91f3cf881bf0614eedb3a664d0d8439476dc85d62b1eb8d8313ad893abf678d6455e2ea2d1204939ada5c4e6dc751f98590ae1b2c37722569ef20985be7c43ede79e779f2b4358ad1d23ddc115c6ddf53f27bda98e18b3f06b6b3c34ffdbd1cf45745fbf49b4cd679769b005fcc664b87e3ba47f485b12c4c33aafb931060184fce423a92587e29ae9acb43c4fbff66faa1b1005ab96b0b54f977480cba22bd8d2960c96d1415ddb635100e7309d26d3a50e6d127766844456d0d4f6a7ef854d5d53303d8d9510c89728d4b5dd244dc669ae1a893a546a3899ac0c83dfd2f64174555813a4a9e94c01b9c3de27786afc3001bdbf5e3916e8cb8cc62a97b60d7e61a36d4dae2a144decdfa406a518f697d6b29825e8852c244465af3cea4a5e3b489ee9717d23268e8887d961067a252e8a34576fa5535d3782f0342a5b688330463dd1b28f76247551b56f4315a521dc74482f47aa07230917147edc1d2703943886bc5b9cec66bee5e6a08d436443e8d7835e59e832cb9c8f76c37d34e2d878b82e1019d9a107f48f071655c5b4333abbef28bf84aa7fd8cc4f9b4a84223ee353a1a8b7cc3e2ba0c21a485facfba34f5354aec7bcf1d9e735592b9ed549789b239486714232dd7627d76ebc64c48e82b371a715986c9775a5f19415c85451820847d083b90227f549eb0970d86a45ae83eec6cb52e80f93c352649cb1923628759ccef51bb59d44e91e1279a3f97c9ae56d65841983aa021399147df0e22763aef0b1833ed599ddb9cf05bd7accdde94cc9cf11434c733f669ca717e45bc8ab7750fd28c142952f35a61344257c5225d7e88ecca0daae2c2d6d83de64948b17221c7b27c4237e719fd86abfe9d78eb1aab2150d9b63c8aac54e2d6e79b54cc767d9f3b12cbe8a3e1d4124d12e16b65c204eae1c205e2a270cd62b1df4251ec71bb701b0ac8d79dc7569ad1cbb218cf3c1cd31d1d0a84e69a770029c7eec903160653ef65b20fc702b6c5fed3e516e6a0635785c99dbe9c4dff4be267585f3ed04fae1d908331705768809269b182410f49d6ee22b23df606797bf816a72697ce6b80805033d6a43dc37df360b98ccab7aaf76edf190f7d68266a4430ac4fd011d1cc86bbd57ec5f3fa23335030b7ceea78dc2ba0f20cd5f7503acb33484127327e5f522d21b72f5f12f27bb1deccc1ffd8682c687be82014f86fc966a3eea19c4e933ed58ff7ce1cfc399a61da92333c2b7b0c9e4907f8cf72594bed186bae92f38bd4412b6e976a11388221eadce705c96d3ee9c4cb7626ca0ac0c171c2ff6130ab32d7670c5c85b6286036afa48f5304ed93bcc7ab86477336cf6dd2706ab85b7de2b01ad0576368524feab7c4765e026f167bdc1dacd1e07bc4658e53384f23066d622d404ea8630ec597090f48f3a56302886d897125180110539da64011586fb344716cdcc9f05e4d2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
