<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3bad6f0a5da98f572c2b2aeba1aa56cd5b8bbc80b7a3d59546ef77f1877d552a473d760c0cca9654a1534ce4ef35a4784237e7992dcc119688b8a21516346560880e0c1e31465ebb46ebf60770fb4dafa9bb1774a861f00a304d535ac5d5675161b18c363d7c2a1834b80e72094c608ea39322524d6df5b6d78638340bae326cdccc65ac5c9f3314871b4eb39bb01865353883524df3cd123613b89c02807828d1cbf91e2e4858980793a471355bddc57edce13c2412fd7709d6efd7990ba5b039ba1145010fe624fcfdf0150094b082bcef3dc0eda0b18647861c4b175b173c286243ec8657350e3e607980f4615031f27f4d20cfbf9dbd26b425e15c9e7806fd10caed3e27ad34517dc732e870b2a11ab06234b65b7eb47763bcbd2d605b782f84b5269260e555dacbe8b2f08641aa1bdcc64cbb9dccacc4108ff42b07227d91ada1efd6576d3fbfb30a97b403fd7c6611dcc4fbcb21560bd6b7ad7eec7f1d03e6fdbcc05b4fb2db133ff3379661825f92f86d7c1b48e60036bc3acc511151d8f3b7b716dd77ba0aabb8587bcba44a59b915614c29c2b0a6f58858c9a5f088a9b2768fe1271d4954ce0a7e41ffa5bdb3e1dbf6bdc39d5ae40c4f3b97721276efa210e1ade28a8739255f1cc17ba6d3fd00a070f45ca530fb8d7255991242c2850deeb41e98845b96a72fde4f9a5f245e205360cc08fa18e05a5657ad28b501aea4cbcca233af464c1a1b82af4f3d44bbef79f396ec46834974cbfb35b7b9599dce5afec76067171a54a87a29d4135133a9b1355057d06a75989bb04708eb5920e2f682a2f63a4d67e8e7d64a40127e6a7bfdb139d2b23b1cfcbe9dd1a984a67faef28901384f3b9d06d248e573d4dc5b483d8aa40d9f12f056b4c8a3d857a0e52352a3281fa6f912e2c9ae96db6c7c41a4ec66e6e98700a4641484efb9fda8ce66a04871e2448bf382ea6f3d163ea6f5df001622499ca35231f41a2893706466b87965e8803b4f6af87a256ea5c53045cfca77a5d691db791566c6fcc97e35bab6b6a17948d16ac0f290a1ff5fd063eb76e5e5e8f92b9518322928b22fb693102d6ca8cee98a1c348abcffc7bd7707ef7fc08eb794d2c487267781124d3133af6a1a60bcb85fcae7a3afe2073760c404f574d5bce73cbc641e432b62e37bf46d1043e57d739ac9387b08636ca939433f83344b0d9b2a2628682e4802d24962331ed239e12ca6ef685404b1bbfaefaa8dbd2d80b05b76ea570a73957436c8df4c239d956e4ffa4e323376a38685ef3335a6d25d48fa954453e5b0b69ac4d9b225fa224ef06204cc218ece84a442ecfce28e1cc0e7d92fd4f9312bfe98e0cedb217871612c086483772d5ea8f16ae74b0705252ca46d5988c28288564e408a98755b0c9fe593a268e492f869593b5954a8ec7f2ee91abbad153e36d81e7e901fcae10c738dfe5f279f40556f6087e459d0d24a9fd0dd95879690f55a2b1c0c7763e994f421610d5459a820766250122671dfb66f5f8498a602c2c2b992ce58b028443bea7c38299406f785499ba1a3712b17f936b1d31b4fb5071994c51be8b0e786e321538ba072914ce234c83ce71d2f6f6e508d9efd3ec29aa2c9ec9752b5a3c7a7269acaeac07926045bd6b6d86fade63d01ab15deff69464a382451cd84ee3f017803a886e2cdec188be9278e313b4a0cce8d7e2f1031f0dad611e4ded141369e02d2dcf1c538e3e19c5dd66a295a537b6b861289d1219c94e7f37fc84008c63435db553c0a4da2f5db36e25f985a0f842db9ca40274efe61d08f9b55c5e6e442d7161049e026aab901f6b8b3f4365e6419e4abe5e5f0306c14cea02038f1edcec2f0714ef57ffc2605700907b989503a694772f89aa6d06b8b15d08a1ef959f03158080b67f7fad910187bef1ddcf866b7a887980a7f15c1aec0b033dbfae1b54b8a63cc51ba5994a7038cd32cebe1582f4f98eb7d2fdaf5e908ab74a7bb320523c8e16cfd07acb007744ae94c8546ab4c2c4f55668b47860f31a58b1ce08c3b5e75e1a244bd89b352dfeb60616f3f509bc1cc5d7abc8900223cbe691f3a87ec3e9adacdd3b21a790514b6a4cf639bc28bfa9acdeb61f082d6d9b62faecc90dd3d8e68a207c092d16310df04a33c39fa279bd582c00dc17fa78fe14f31c02f00d226239292ec678080122aee3e6f46a6fa7195f46d2456fc5aac89e724a5f079b4e1a924ad8e9d4ed4125a53ca5d8ec37a41ed7aafa273934478bfaa75820cbb79471a70c652ff814c86dfba6f0e41112c8d6f65afe51bf772e51986a48779a1f5930d3cebd28d6d470f2e454f408b9becacb8f83a98931eaa9a42763eeb967641079a8afb2a7d8994a794b86a9e0d57b823c97d381d13cc82533aa0fbcef38a226b01335101e1d65a05ff6fa2ecdeb3bd099d2a2fee68a8e79879db729987cf9ab5ce759a6b4bb862f1554999a78d46c8e42b94bb2fba6bab8f145a8331ab26078efae1349f59873366eb1e0cf675bd7d2d1acf812c92f41f351a934881ea18942b68f1a62b7d904d7410aef9fa6df74bda7567421c822de0dfd6bb12a167866b6e7fd4cfa17bfbc7d84e0e058d84d8f088d2b983f593e503de41a091f7078d5ed4db535b9a0a20264244e4fd58efddb44a27fc3fe5e1f9c942ebe3dad428ccbba18c85c073bc0f2143fa6979bd904749938af400174eebc022d6ce3676f20b4e5fcd2ee983bedea8f0296847f77da26393cf2637b6ed4c45daa9ad19bb1a8b6e16f08437eb9d4e4f23be2ced3388a9cd7a7cf07baac7abef69da8a82c44aeccf15ff80a2741f59590d45eda50b47f68c5a2bb3d2316193fe3b469d3862e5ffef966ffad64bbd917b66e3a20dd7cece971f954da9acdce1c9d1ed8667cb9d86286557f2201f12bab14995d1b458d637bf56f7eeee7b27b94fbb0f90d45b1ca03d94355e5009e9dda4536099205bc83940b7dd4b2558eeb59f1f412005a86a8f823b2fbd87ca82bef3ce6ef972959e1dba31b4c7bdf15f5e91421e934a3cda6e01aa5671b6febe40b307fbfd56f94de0872a8b0948a25dd068db807608c589ad7bceb8f4c4058849fc2f45d62aa349e271cea4701cdfcf887a7c0b8ce55f6f2d08c1d828318e41daf6de2a0ccb9280043fbd877e5e5dbbdbbda2fda3e3e68deb3dc3c88acab061cb32e9f0db311da80b93b56e416c21798870c56ef9bd9889c657c07043d1c6506c61d0683fb9c48c75c6d0a0462469b35d40d889ee20db0f75da59e087a26e8aed07b3c64a10e568cbde1fd775839cfc9da40e41b55e79ecb209d5ab227dc1bc8f18211b5d4a077a7ed76d8469abb0ce028771f4112ef72359cb84ba6998a599aee29e0d0cd1269aee142ffa232e7d513416aa1c821fb07ba3b7d12e23b1b7771cbdea0cb0e20a7d76d5ddaf23494540e67ae9690e17b25618bb799114b422c104273530284d613757bfb9ca37df049a2313c81a0e4e35b88d52aadbee1e2c35bffd1203f246f3f4e8e3399a28628f9affa81b45a058c697b1a96c42ab7555dc524b00f59b4d52de65898e5a2240d8096ffaa7147a75a16229b486c4d4708ae31ad735795e2257b7d38c3e862fa7635e67af3341957e3fe758a3da8051201aa9456571d884ebb79f8d431c0daf9eb2699e6f21b986ae81cd8ce4663a032e1b6f16d74dc1f23e3ec07821848023dbf42d55d13f2049fb1c05d82f39a9582d36ab6400f9a9cb550c6c6e367ad089981aa269853c602e51044d17939eeb00a04dfdb54f6d5853296a46b231b697a49145beb7f82e4f0fbcc0b3548cf68f1c2e44880183b4700d2da3bbe2759e0306006cae293e9d650c70906ecbe3fa36c7d3271d93203b61b06a632ddc4ea7dc731f2ab0dce152511a605b7316b2fd23a7b32331635f26a31ea10ba27f1ce7e827fc27b528263d1266e374a7d02044f53b76c9cf2ea4340836e3337895df228e9e816ca1f662c9a6e00e096b2c2ffd9c7f28d582d10010dc1113f753529704768180d5787b51f8ca037b28f96d45da239b09d373c71597691466d630c3995f32b022eb39c199cea77be477b2420be62251966cedd6586334e72e8f6cd8da44b226ad126f55a30e4b7d8857e08f08da09fcc3de40b35246b9d4cb299c5aa7eafb3a42a1e46b1a7d095d4db4e70179bd7eaf4730f11c633779dd1c68242bcf5324a45713b21f647b94db33f2f0167d224c64906c573e91694ce08bf3a19685e72fe1cd179f94e078ca18779d8832f65b93afcb6719ffc81418a2fc0c92392e66de25ac4d49eafeedc594d6dcc5a8e2f317830f2d3f0aed9d6cdd14f276ef9220de500317bb023d201ee69bd6948978cf2ec18374c700154f9b07ade40f449e84ddd38da13a9a996d8b527d380a7a68fbabed24c28f320b50c91d27d578fe58b8e166795e122c8178b08b392757afe14aab3fa5782031f8cfd01705169d7871fad0823e1385ac1f628b5cc7258f4eb05ea4d5f4877c50555261ba264809767748a62756571aaf912a9a8eda4154aebe9ad18ebab4fe56d3798fdd64b26a7b45e90d9fa0157b21c01b3f8cc663276943f71ed4eece905002e8d55d43d40b1e7ad86341741354f4836a6f015b2f8bda9de7eadf55632886143b7ae67d93cd8bf67bab65106c35992302fea0878fee7164ac93dfa97951ea39beb241c7a44a15c87531e2442b3f11960bdfd2789a91a030dfc9a72fca96875c16af168b94a60cdbde1c4e039f4251ca62c1f8c7f49009497cea1cff9e97f2b5f40d6f91275d50f0c41b854292230c13db0419d35420465d26c38f7272c2e03e3de65b992715a085b2a215f62c1b52c014c2492a5fbfdd7fcd437f47aaf8f44784bae29451d7c123cf80b938029ed679ad761a2273a12debdd0ca7c92f80e68115d1b9d9ee02d8cfcb8e78d4f4f444dd51e5689455d1570238121d98be94791828e7a39190e0250339d5f6950b0cd8a2b670b9653a7dd0945fe23b9ea21f7416db8a5ae439e5b176ab123920a46ee7fc1afbda6c777f7f4c20f745c46d0d3426fc61b28d7ff80abf8b6bdbf578b6e9e8a36f9d775bd9e2dbe5530fafa3f60ecabda82138d5a4ca36621c2765d220b24d19bac2207f3203cda84b7eac96e324253f157f55623b63d0026f3bb342899d5a20f8301b94351ea4a984d11c0d9eaa77d20584f08597294d7b1f438bd09b778bb03adc7d4af7e04147c4f1ba610ccbcd0a5703869300f040a282d21134169faba1181a6e2cad485a865d635da5f12e14f11f17a5596f3514af2c5b25829848b00f54b4750e5afbd2a1f85d27dd1fd93345123e29017c38e4a5fa1a8b9b0ef195f96d1de2b5d6c2bf5d597213e99496bbc51216062a7b48f54ba5d75c708de62ef721502049ffe9b106d5ca9e8a9d8764db105b7b606517a1d49ac46c725307a1a8863150193ccc3da898171244cd3629b620523ad3382e6279682f8e281b399b25b3185bc59892145555e413c371fc843c58955db8f935b8a3c3a54116243481fcd86674a80f5661d1e99de7944852231080c1dcbe4e61ac7240bf44fa7abcc082e11708c0f9b5fdb00fef033b553db8dc87dd6b92390c2bbd7c450e83664a47cf6a468e73e062156722019de431055855fcf933e46896f50bfb341def2eb9f0c575b665a4f4e83e7eb81ddc2462ef015405f9be79ce63d522d800fb602f4a81193a32812a125ad428ad601131b2861b5808cdb84f893c760c1b1ba7b85181f8cd543872eae6fb96540db73c13dc4d3d7b18b19ebbc1a28e8553f6da3406af598abcf4c208ea7cd63994f347876000083516dbc45af177218ea1e305f287c7664c4c9411f289294f45235143756583d00b8b9b25b15f9cb02ef0df678fddc89bf06590160fd4eecd43aa6d55222468fcf59cafa95639ff317b9dcdc98ca0885d62614ef6efbfa1f4e48a46aada9e54bd68d0b77455bf3717e925faeadbef38a12ff8fb790b2ab3ebb9be24611dcdb3c8c816991c9d81f55486ddbfac150daed5eca20f3a6a524880e74a3111ab5c834498270f8286f3f1d434bacb37d66b1fdb3faf9d5015a36f28a8b3c751b01ebf417b56343671b5d97a87748b59a7da854888f5fd4f2ee7713e1bfcb15f5a0d4169432fd58a50142482a74ce91c3943282e8b186b8a449ae50dcf6716e9ca35eccb149c8bbf7c823359eba25b937a431ca7c376353c50c3bb21dd66e5c128eacdf424a78069183fd54778990222a22e4eadbaa70e138e1868d8ff778a66a83175df02581e88995db7367b716fb6891824ef59294ca776c0b3d39e9fc6b598cab0ff4cc7345fcfe32ff9773e88dfbea6bc3d6c8ef57173ae1b442612ff353a48af87da0c166cf3fb380dddc420dceac517d2d09f1b9cff375f2921ef41039f4ee27406efeb0655e7149f9a230fe49727456127237c051a26138738d807502ae4ec3db5989aff63a323dabe92a93d3387aee9cdbfec4661d06f10689ade3e88e7494716030db72d6877b9d9bc406f21413b3e55d9930bde7d4196d2c96406a7341eeab6441a20ad0f43394053cabde8c0477a7def211c2ccab2141cc56ccdb8c64b526fc00e2a26aafa775dc3170a61c4ecf2c299cdc6baf6977fae72e0ec25f6329c430fe65503815200ea715b2198fb7b6a84f0457ce0c8fee25a514ccfe715842c48bb8eadd9ecf1e187d2d5804447330d91da3a6c7d73b6f16ad791f6cdbf2364527fa551bb2bbffc22fd93ad176d16848e5201572295eff7ee572c9953b7c8eb076b6014ef44f239fa87eea49256b1e06fdbfb4a978083773cf94c43b6ce3a069197b66fa452601a3d05c171b94aaaf86710786a66ef4481cdb6c7a7537a33d1145adde45db4ed12bf54f3f757a0afdcba9c7eb8e53c13e8d6bec9880b750cf696c2e36d319b0dec6d12f2b8b634168f2f044042d1672485e7f90ba0c18c981df955b6a072c7f746476bbec54328f12f6e04cff707d03312a0623dbf4dad9a56070add842c28bdf95722e9e4fd2138abc4642cd6a11e8544d8285c440a2f7b48e942ead360d2e3bd38d7826d6ed6b66c8b7a690960797fc336bc126fcda0414bf862c744cbf70a3e3f468d1ce714f89dd166d9dd3cab788035bb8c6f00a3e6c665a1b3b7222ce51216402233444f2486ee19797d8e607f49d20a591b2839c66e1f816b64e7131b957349507a421f8721eadbdd8be55ba623268e571ffdf6de137104635d34ff438687b778e4bec1a072cc874ba4bc3d4a2073f48e03f13e238817356a98b2a501cc4bb45bcf6146d8ec6ac04ef297cf7436437d367f86d4ec9b05f6a6bd3ad5e14da924b4d857c7fe27c17bff27d1bac109cd0b20724e00767b3fc8c38a1ec5e3ba25181af2e1169d302a1903fafb549976aaa165442af2aa315c876fa330bee934db1712f9cd346fa8fc7260aad9ea7f3c592ee2805023adb9241be50fa34e6e1fae84d933f13d823bf064e033d1aa583d215b895ae182e3a524e92bc35d1b003c058f76043a7e8b8fac5c5c396a32df709b4aa0c6c070b95498b4e9a7a3de066bd2643f36bab8a5ec6d1f078d0888f6da25213621fbcb2640bde983763e87ccf0c19f431ac856352767f57ccdc1be7ca34982a510f769ffec6a124cdc72b5985034c00be7cd70f461d04b068e650058fb5627d93451935b776dabf30b921ad80782b89713fb3edb594be666db62a96f648b8c77f0119a59f073075f2207c86ae5ad8e1bf340b4466e880bb9f144eda19f68721507b11ed2ef52fbfbe74b6f054431628e4c01df6fbf214f945116efa34b0584461109f1d51bab7ec73b198fc367351a11b0bb15b676d8b49aed04c9cd8008a9e05a8094eb720866bc0606f5b0bc116c7f2854ead7f49a0eb1892cc4d75ec7da9f3cac7e2383d91f9f4b3900178a800fbcfa56ec17c383cca202423885e9bf37845abf14b147238b258c76c69955956143992322d3503f83cdfdbdee43ff18a6c597f8fb701ace78621ae92c09d4ebeb6484f6ee87d28b62194b1145ab5f22c040fe3dab7e9464424c1b25bc94fdff5fa58ef522d6f3e14b931df04a3343464367c88afc9f05a117b32b9783ee94700ff566099e262d0886a019325678b8637338ba75769a44a915e826699049be8304ed96d83d60b126ffdbf951ec5b15897987915c09e39836375ac2d6fdc673ff13e21458399f717ad3f4f60162a6163a0ea37b93bb7caf8b5d1749f6d663430f4eac818c194a59fc59839d3e8d6112659a90d0937f13cfe540a76ea470fc3787f988368ede75a92d3121dee02636aae34072e95b361d028157a1f116e3c27070218e1c2982c7b4a48c7cf453961056c185f93f1bb44bcf98443532bc9c4653be6f754956b0db7bb2ee7e9cfa7ffbaee52be7866ba870b4cd72689abd8c3cfa9816bffa97afb24f53b601e481caf72b6e8a9e4842dbe1ca046117d1e236bb6f1824889c5e481b6d06cf5e3cc62e0363877f35ab389316a0fe329cb9af9dc0ed884a46fac5a8ac76c7982d4049c0034e8ddfb1cd45cfb59d9bd18f8de84cf1e13c7155e72a9691457edc363caf88292e99528e2253e8e6d05c8d722d0b4c315b5ef6b650f1b28ad9584daae73b5d6cf189d2b8bacee481917aa0029f3c324f75124c39c87705fe48cfb6b5f5d24f5717f0ab223f67ba60769a29de6bebd35e18b9b70ec54125a719a85c8f03ea6504c239ce2177f3ef94d649e6db02d6fecb8c2fe4d33fdef75420399910e615886be8d3ce643b31b8675528fa6fed20ce494f05b1554cc844c07b33d2691b20b86776effd2ba647c2441ed42f499f8cfc1f3f4cc885a47c0c654be542d2e6b4f1ae8aca9aac40daa40ddfa26946c92e7488482de59e81803e1624b43e25b0c2402442ebe1de95b3e869057f137c1d96821175c3b81215254e3d8229ccc5fe1886e769a596786a2d7e19b89709055c7cbf5c8afa44a349928bfab30eadb49135691367b6be16dcb1900ca7a604d7cda7e872af468d9c53e03c6fdf1644de621cfe28caf36f0c2384b1f2fc4d4986232d60e5c05b107499fc9a8e8b4e34fe86e573dca6bafa6ddf9a3aec9116fb59a503a51e0d82c447f7f32b8456c69c0f5db97885bd6566c0518f005793933c30d8d00edf88f20acaf4b04291ecb51341ff73f74f29189d71bb0a319fbba170adbf4fc858c97f5ec2c8434a37d3827dfee3cd53a689c36af1541737f6aa1a933f061ad81ecaad111c5217f653df919ccbc72268888221b33e6db20bbd8621772fd54b6ede0fe2468f0ef09921c73ad128506f10a2e83ac9db19bfb13e0c951ed277b37a3d19ef3d998bf2a1c0f1d27931abb97689a47215eda300dab48363b99fc2cbf6d79cbcafaa49ee6a3e18e63447022d4d3908f4f6a39546652c2c9dbcaa2f4038216705b180b0337f6aed4e316f8fddeedddf708944e71de951a6fd734889b29ec30cdc1567e93cc0acd191f43ce156afaf7a523ba96b99d232a7765af7562b7c662de82eb090176177581e889103797fdcf431cb7e3305a45a9c2ac82bbfb5721864c274ddf3b965a2321a67e91d487cf50dae29eda53b26488bc14491a3d6fe98dea142a19cb5312c7a06117fd43943bae5035f0591793686708166e16d7951cdb81ee481a3100ed36099bb5e56d5bb0694cd40e3376f32e9e0b4c76f5347851a4243c01b6111acceee8b84983446a9a41883888f75b9f6b46c0aefeb40ace3f2eb193d1a37c19ae91333b8bfaa1fa95934de3c47be9d4bbef64190a21dc5b0ccb05ab959296d00c7874bf8d4bb946c00dd3075717da2282885121d0aeea5292c211f2b31e0bb3eb868b6c08dbccdbe2396adc33d7929f194d74af241fedc41a389c913cb834c8e12fd4aba691493710ac9619498762826bc3a5d2878b6a7c1a7558e4c890847df0a6bea2829a7e5b9ae946c0d9705a4170942edc8d516670cc4176eed3ea7dd47dd86acd503161d0df4a683cd420604f71deedabff4465f7eb21265042bb1e8f3d311f3c5a62fcdd6e235dbdf321e9ad49613510922a163f014abdd3b722ae27976949392a51f10dd4dca0cb1589b2f0a73b7b9152729c720b5bf204b778f6c82119fcb173dc564840f9316cdb7bb444aa423ace49df248e2f9ef8377b5f886b48a10b73cfc9e5280877b5f8070d35f70fd7909eba75b4c653d1668da9eac1d2c9070cf3c4603d9196301c1e633a299a871c5457d134e7506b65ac6ac373f8233a561da43a9102b22cfd121a375df959b4e7cbecd0116812fc86e359bb841d890611abc058a9bf4db5833d06d68ded44677ddab2ef917b6e3383b2d38d420d47ea37c848a1321ee6ce3c22595f48763001cd7e875ca03ba976eff1bb4c0a98116117a46bea735cbbdf3634e23b19dce9e02039b45c30138379f5e8d97b13769ba90ab72205a85d7a6d223853b8d43f984896fdfd78c1657a2654fdea4a219ccb02aef01b88d06416eb08e1ffded8eb8bd160f39a6edcfb3b3cd90cb78d94e8544e4da01933fb9f2d48bb1b0b261987da299e9b54897829d025a7beb6af24b7f0989d0311eae1a3699bb3d8ff2a2d92c06596b68ac764b3d79558723c556bd7d1f093505ee1bc9215fab8b08087bb8a2abdd1d1bb8959a342b8bd5a51bb2169664db4b89a4e4ec45a8c8b2c43dd48d11e24c7ea6864235f39eb4c0cb8337a03ba62d0087349040e85177fcdd2eb086feae830ada0c3598572a0ccf76e241e3cea6b4686a8d81f715e38572b2ffd5caf2aaeded5d804d55dd625022b154adb765e847d286d558353c9b777f49641f471ca8599c7c01d6d60df0a1ba1a60a4d30657665c17fa54073f9a2db1c1ffbcb7afea8d45fc3eb9988f3949702f447cdc724bae4183124728ec6e790968a5d972d5440b5bfeb947958a30628e98921c8fa14f50e231bd532e0db421d9e0e3874c329dfeeee872879e1de5ea90dd06eabe8a5ca0f25582c4f9bb6c1ef2b7ccc43bd044f855f02be1392947985c7626bc43da64734835ff3cf5973b1c91fb311a7b09bf9c0f86fde84e6f2da29ff6c4ecada60ccc88cc69b03817edf13d722d9928fa6792b29700c3e53e33e8bfdfbf39e1ab4209effa156cec75d366e4ba5430c6273b64af798e3e245d61cdfaf5bf616b7038ccf011427ce4ecb254b2b7e26b504c60e4de8fc640f38e0e1f375fb4ac45a70aa8e167f20ea310f8b93a869eca6665fa065a1f4b3506167751b617eafa977da8a42db04310711ea62efe37e3ab1aec6e29c77f796845dcc9c7d8d5bee88ea7449e0b312f5c22314ec47e71925c9bd944dee8f52504baa2e99595f7ea7bc63f75f3725eded227778df8d30ee4cdc61f10b059d5948ef397a6534cb720482317c5e22affa8cd91748334ad41bf993a9cceb63606c60e16dacf2bd16e3d070ec71c124975d2244d3d37c1da259aa1fb77a16dfc85b68cdfdf0e315553f3e8769d4da08c99db52158b98c05bcd64b9dab466d3fb7748a80944aeb4381f6dff9f789dcfc215b9a3f3cd19a1e19bdc774926d41b406c02467a9f2796eff5a02009a09ad26bc2e8b2b562ccaeeffa41870928fcee3dc578c5e4a60c992d904a9ef7c248f25b68c3794b198370a96d8511d635e64dd64bc47e890a49aab80f2dffd7d92dd5fcaf1907bd48e2355557ed13154a30c056e9df3fc16a4fa2a2104b7ca1f67d566b640e020cbc7090c8a1283cbc64610c1112d458f8122e6ca5afc4219a908b2f6edd4a2fb3aad120ef5cc6248d4f282a26be81d86c3bfb091bd1d9f01151c9767f0ee025ff4eed97d561f0d62f4aa33d81b1758e176562c0aa9a11a3e4b99986611dc4ddd78d56e435a11f85adb90b22a737214cf38501cfaf4caf07ec90a1ed6194afa23a54898d9998dcec35519a7148937fab94e8b1eb64df96eef70027d9def7092e84e262456db972e5bc25bb898466d2a28ef9c7f8a1acdb5caead715d2b9869a59b2b8e4d11f7cd9b1472dc1fdb87b6db65438a301bfa1f82e04a4e0cb847a43af6118a50e859ba1720495f2a065e7c42c9cf6db15ec61cee6a59ba89ba0bab1daea97f3a09158ae2f3a74f4dcd667ed64c3a95b17ffcc5b5bac63406e0cd7b95b0ae5e98b6e26a18d3f1c8e79f6063c5fc41dc30dc22b0f571f499318974ec3959c61b1da14ede456234b6e203a09ece8377f817a4e2ac93f53cca697779c8718d48dd0940dea8b937bac6b815de40918088f7b1320dfc1179ea286bb85606fa10e44af3bd65febf4cea8d12c4867b57184683219217f89874a02173a6b948048a4017b4506bf9c4380e7879af8413da490ce09133ec9f1e00bc132ecc6858c7a3da430dd92933327748dcb27dbf094f593ab4af49e66c1888e01ee43c7a04263954664b9ceef3b18dd498aeb61045ffefbf006c5eab926b2b4807e678e286157a55aa4f4da46300c435aad97e117a9feb775efa7aa7296eb064719724c59341bd693860870ffa87ec731ce1049f21a59ab6e34acde979c1ef8d5bbb72ef1bd72969e7e7572a528445538209589941ecca80dead8186d1c39dedd45111ed5f28c7941be7ee4b35595b3d7207e4d92df637d6774c956463d9f2057f7dfb80dd2ff79de607085561c2ce65f52a9b646a32ec8147b00cd33eaaa8fa19d0032c9bc29136d3f0869d06375e9fff157c57f5483a08906c4c7e05b827a94704bf8028ef8c6e6ca2cc5cdf3efdd379b1ebe6f4f3ecaf33b20081b1fbb9b49f0bed987525b9171294c6760186edb83446048c3a5806a0b6588964506a09de69835873b5cab0cd51d5454aaa325ec8877bf7b26b359c264bf40344d0ead5c5301ade23cf7b9c29d6d5e0cbf6fdaf12875f58466006d27b424d7690dc82cf0e45a394164c459e28cddc479966e4741d0b520ac060f35c710fe0f3782be8f4c84822975497e9bcae062ec76cd534d2d4bf4ce94840e56395090bf795a3fede90539f4da605c891","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
