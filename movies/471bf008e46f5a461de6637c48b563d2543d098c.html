<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b2ee38a1619ca94817b549ef96df4f30b86249130471b410527d0106ecbef7f850badbde4b4c798db8330252a41bf020a0a90923779c975823571cf78a978babad5083f162f461c237999cd33f7777d5b894f82827868410ef53b2e839e6c8860007535eba6ff5c2411a0d500ccd703b960171fd59fc7535a1623aeac8a79a68e06c8bca339ca536768efc6a97cb03c10fa6ff3eb907dd0ab2cda215000c1152d4879aaa1b34d5d379cf6a543f30d5538331d432088b15052b3970900466b41f3195df16f554391185896e29028e24cddb0537effdefd6bbf8246b4c7a98480f92635e99353cade031c0662a0b4570741a06729bbffe54f1e76e99fb37298ca7f67f6d78e32639a303ba41c7491c75deba41f3458078d80e673d73b45fb3c2159f356a174d3f9c5c917115394ef1d345ed499af52a3f776c04dd3ad95b42f508e4ecb8bd7cd7994f845224878814d6cad3873fa6dfdaa7734b40dbe9f3b7255c390adb1566918008e6b05a8254653108943963cd31e533a0712ec9d53fb7aee4d6411970e8ce1dc7355cadabb6ce57c04b7cde09f5a6a22db82e310e157f8976dc036a8b18b582678d70793db49baca3b0db9e686cc9c87e16c461cad99edca18d50fdccd4775c9b84e612092fe368e437b000b7fedc8e20fe57f0290b491792fd4360aac80e1a66f99ccabb6045a293cabc91818e537399841a8d4b926d88974d4b5b7be83869366295c08ef357e1c059ed5d4081dc6530a4f99647e17a2194347814195d8b21a4dc194bb710f966c022c5c339c6e00895a2088e8ba2837f825c863e1cddfa2c4883e188c4fad502f3c06f2ca9dadfd548232f513d59fdea5d58f6f29678dcc1de02497eb11f31b86b9d5e1ebc6160d47d59b1f5683636a4c780e875af6bd3b990e0b0b3f2e0a810d103434507c691cca59cd8f2741c2674cd0853178877ce5042e33e723ea2ed7f71fa50e4ce96b32a558195951d60a64663866ea85d0617cba35bf7f7632864d413bcdc115930ae4408a969f8c31dd1135f3d391532da427261f559e16df75438ff50ceddc63f390c01f61199a70b56d859a23829eeffcf053f475c86fbbb802aee63107e0aba66f26f7448720bca6d4b1caf6965a71a9578feee5040ec8d21eab83c77ba6cc44688b3f123ef751e4cec2d94f291555f26da70837d7d77db33b550043bab884c3e04092f24f36e825b26474ce193895b2c15e1b1bec93d768c2f6ffe11f3eb57e801ac1f74cf66acdac466548882f8eb5774eb3c207cf2bec2fb3c0b506ed5b22a5c3cc8425785c6be8ed70f21f0570a750074ce9d59d6560eb17126ca72790f8aead2b54baeb1357108d07ffcc475e7df436ac267d8ebd8ffbf3a387a5009735af33ba293aa76fb6073c36136684e2fe76ae53fec1a303a18fc2ee5c0c6ae3b1f91973987f087a3b15aa279bfefa81db58a2826923f9c3c5c1db01ce83bea1d837cf7c64005fcca3cb02ed0866653e64d7f340c1dfc2285d0afbd3932ff05b257614d6ec1110751da33fbdc3b5d06e090969293ca293be545abbef366d3e847f9544f864fb2e1ec3af45c163bcd1496d5b209e08ede6bac83f4d77e5154debcef5e6afaede6caab4f4d9b158d0a1a9733be4c95927b42ca9276224362e84913ae2bcbca9f4703e9618e038f0f530052137f995fa85ee4a326f51e2510d5b13c21391365678eb468efb5f21b8ccbb8854a330c4d00e5d55f73035d6db7981525b49d46d4ce2464544dd87c71319535f2b6774e713173c1cedf61a81b7d171d887ee143c3a216b7e18663ea32185905976bb8285e7d12dba871f12d1f72bde3efaf835626636df66cec79cb070b028091b88439ce8f4365caa8bd9c487ed7189c461a523b182d514ce181aabc71a213cf4d0f73d4bd68f6194e0ec9acc58e2ddbe0e866228e85d697371afe9f000e0dc3f7e248b0e0c97df75dc1fc78291d6d67be980e3890a712e4e16578259ac87a42f3fc75505d8e4931730ba0ca56660ffaaa554d0b14bc35299ca41940ececdd47bf904f153d9da43f5dd93ba4fbb002d542311a4b01609e5652faeb911c2d8192430e06916e3d3709322921ad82041174bae4f6e482d71ea889c756eb20a08dda82df5502f5da724cdeab64b177fb12312789ae02f5bd24c0b410a107af46209b7386f41226128d65da6cf78589511b4ba713ae92eb0c843b9eb868830548ff7449582a3b7a7024c0d14e9888c927ca3e67c57d3351a749fd8433e133f896a630e8158e5ada1b52a639f7eba50daa5d670bf340ea04514ca4cc3c15a34d8c8c2fe1fc442a427a4ba9cb5079d28704f3c6f84d56371cc2b57f64c3c7d3eaf24f342e3ad34e6b6e4691d304c0843f078c0f10aa673520da92f6a66c6217d49e01676d69e81add0c8e7115d8a2d2815cfea786afb6d9d154fd52b95b7d4e9cde615905bed6ebb35f38371558e8576ab29faece6591d6c463f674bcf04e52200a110945738028d58d817bb2acafca739c0c6e68dadeed7d57e556d58043c030b30cfd9c9e43fcd832f489d2cd763ac1f7db01b1a558e5f327bd2d4c3d2cf3bd6619eba0f1b9c9080b35b8df3aec2c3dff91bd37d932ddff5f94735654a57e1ff7ff4e2d0e2151cfd8131fefd9309adab2c7565355afae69270dd2a428397dc2ac22ab13996244d28d6b7ff69c8f1a53e22c42bee78dcd7d329122f9e7290351795ca555edd89c9857e12cb9fa9b16a4f07c51ba3b63507d122f6c95d863170d5bf86624905410b3d430ccb697d0c2e50522b1be865f6950cc5824e16a2678682a0111021097edf5512e485bc7a32c9957b6c3b075441706217c7a0711eb17166612c8650780887ad44afb6e10257c8ad1d845f5d64c92107a5d90be056b6927366cc02713a720d32336108925e0f26c506e8146005ab23ef39f929f3854f5920f4f0a71143f99e5b1d690105f44d565ff6baec8d498af579688b4e473a20d9f9acac3d9b453a089402d50b94935160ea61dc920f9df80c0fb4706f146fb2045826478ba6deb264571cac8b4cdc0eeb69ed3df174034927c2d13d7914255d9dfc0476856baa114108f0ba81a1ee7059c39e400ef30924118c01569df24a1135593d85e0c5d480c835046f8977c22012c38f271dfe25202ca4f8a105360921a07047dcd2959ab8c987393f1b9e1feec7dd2a87b06a16ae70793954991a14843f5b339f731bc4c19914afcea06fa3f17eaf595c2ee40fdaad27440e265d04def592baf5a554bdc3149608f719d0fcdacf16127cedd1495d70a7751e8802074c99a805a6b68dd422651a4a630a19fba3b3fcfa05ccdb3e2cef8d1fc5cfceca6865363bef0cec463e96bcb1c668d2870c7f525229680e2397caaafe6f20cf323527e0be3bf1b79231e03162007f4be3ad483a9ea489ba4e9a3b1625cbe003cc931b047d752b0c06b03a2130addb77b73eaa08c693a785b7903ba3def336177ae1e0f1ea69356002046dbb868cc2ebfea8e7c0b897d045c343dbda7b44c7ede3823c2cdfef33d856f82a5a2797f7a169f6727efa3936fbe7949430aeceb0628ffe04135f4687461e6caa9ac11a1a6fee29ed110e281968826666d48447516c4d08df613211ff2774aa45620fea995315eb3e333d6a8bbea25bc813610c82585adf0d0dd7e8af670155446d4261dbdfc42e50d75c3af716029261da8d84b3401902f499abd3ca802533f4652acd894ce04145c2923b35a663f6a85b2b2ca740117600bee9925441cdb28efca8a7daad8ff678dc3f2e347eaf05336ca85c5b0838175b38658a091ae617f418f819050832d979134f67574647606dd1fa50b0f27911d7b9c23d0e46bb8a7bb34ec8a60d2e61581bf16313ae7bb1e44a56f31075a28ea0b93da477ae57dbbd7286b4cb278dd33504754c132e0d68b981899afba640c821ba630e42b5239bde5d1368851ead6594febb3b9084798552269e1755588de6b1ae50943072b599b3ad394ec58a8ed33deb58edf89a3498a2ae207bcd607a8409990815c4f02875a562ff99c27c00e08069ecf22c0cebdb64f203770476e6a26ad1ee13545f2f69a2b2dcc5dc9f61504d4e79058fbf2ea3bc014407a2b18a48f7dee2eef45808fc176648f5b7a4561838ab61207e650d824fd8e1db06c15310eeb2129e1fc89fa22e18c2efc4fed7eae2e9bb39a6788032d3c489b416f7444fec8930e86a2b678442bb069b33ba88be6ef2762a38506d0b78075ee203dc35f3496556a7d1613112d518ddde7937157d663c1fe2cb4ba3be4b14df76da317f382d2ac0b4e1ed8dd1f2c8768f50169f4db309f0e8e95453682c6e404f14fef175390cb31abf1b02e592cb44a09530b9f5b63b862517f4e2c39a1e0e8e5c6b9e6491660bcd7c54bdba1026f1d0fdbaa0ee7701d7130c293110ca406de9cbc7a5df5c901c7f4336065ca68382afb1e8fd0691fe07ee2b4cad4ae8dc888edb5990316285c458503f5cad8b5bdb4e33de4e58c6ab9a34897341e54f48daf2e19d3ac8f666be0c15d900ac88573e110cfdde6d01fabecfa8c575c435ccd901477ebb6564c554f9ddb9b4ce787590d58203ac04a57921846432f62c52f21506cbaee38f09abfba0eab3ffa91831caa18d620b18a9e1243d24707a6c2946eb8fa899c927e49e3fb7ecbe5dc4ae0da10945af74922292089fb00fc91c64404cd0e706113c279e526abf4a1af8ed62eed0f2ec26007886431adc9f39139eef83a2686cb129287a7f9ee82268bd441c85d7e3f8ee816900011e325ded3fbcd4a9c135ac9114d3c8e5421d243444366221130059734f0d7dd2bf24798672a000577026937c5f295bd1769d8a6c80402511441d025f27ed6edfc0c8b1fcb1513492c8b7bae8c4b4d2b12e6194e91bb9d6deca48e94027ba02403ce2f286126eeb136192437660e481ee941ba42eb3166d058be94223583ce6030c19c9861eaba759eb4f5c6c029e3e134a1a78c0191c42cd97f02753d36375d9ad42283535bec61a8ac171192c4f076c5a3d1f424d469d314ed504aa4a34d563bee1af9009df949b8eca85d9c93881320a0806f641ccc0fa2b23e86dd824039919750ab4b889792d5d9020a2c98251d4bb6a6f5259cc8cde93a4f53563c6b0f0d98847b3f12683ce1bf15ea600d622c991dd527dd10690df13a93dce53132cdaddb1edf889dd14e6973a38c634cfc1ea8c504912be4b35e4d82d1edfaadde7d98644e4f91aac40b9631d11921d1731ebba568749dd746b5540f69a58686779c533030a1e04a6f6d4fc99a6cb845e386a4c080e2e140f13e8772c23256c9c68b1f81b630d49ce3fbebb45b9c661a09680adc513434fd21054f2404f29c99bb430f7d7986ea0312f525b2503e57a05cd9ce70752c276ace7b874fad81723ff778ac9cefb526eb1426bc7b29988cd64d0e3a3db5713574f9aea2f72f8c6266a4905df7965b1732d07f4113776600b6140d7bbd7b81531432472b7d4808795eb0f4cc3751197373471d62917c612336c637e8ef9f4c54ab2a3747d08b5f2390f87e56f8becbe02ae3d7934f564cc9bf80bf737b5329c396efa3d07663bf8fe50dbe0abb7753f91ec7aaa29d72ae39ea40fb1cc59f4eb3a84d0a538e8a9b392e8f4d296d78c6d497f688568360d17d2fe5802812aba9c7e73bf6af21ee93de3f6608a4092e607722d6604c748cba0ed0e7654c203c958214ea86817dde46c6c513fe970232c79643b1332898ccae2de29035d05dd1a5078f82c9d28d41fc2f5171a965e0f3bcb6269318c8f979c6408eb5868c98b1c6f2ead4fdf2182ca5d57e0563cd64c75bfd134309effa1465e587f668a4ce0349d15a84a993594f97d6117637f998fbed7d493ab0e2db1a61b11a10af5ee848b2f3cb88a624b1dc2f94ca4757d549f144bd9986d97b868cc84286edeeba4aa0a26d75a68c9c7bb213d1f79f474bd04b6b5c32e984c9d98523854ba4c650a36a827e3788dd3d984d014e452f91ee602e99bfa81d27929ac42b40752e63f76a555f9bb9d3da00a0fc410ee1db1797633f9fdfa9497949f852ad2fe4db558f454921e10bbd714c68f757c85f865509d7c5c3c6835595de8dee9f0fa45a773d377e72a1f919410b0351ff741a8f822495d2174ed68dcbb691de84e50964973687fcd861d4fc20ca33490be18074be57ee94c54bc28e24de34d17a0c18a6ceb08dbf6033506ff96a0cde5d2042997b201883e43a237836cb0136ddc789244255112bc39795ccce94d7fe032a9acf3046a8ed9fab3d1dd3843eda67e1cbf285e91bcdf861b2f3a6e68375917d61194fb13854a6732e1261cabd97b748bbd6fcba16a4e036da453284e2885892e271e1c5251856dfdf95754ae38e6587d21539f67e50a8577bea97d7b87e744be6736038a8e0995ab243117d3c0169dd71bf11d68b1ef642903f42c2ace712b2df6bd4c4b6160121908f40667736ecda6875e7da4ff2c8bcef0a514577938a625752e2e54203d112e8ee31468f54e227b892dd43800871d7cce54f2285deb6252656d125eee78985bcdfc560a52303a96da9efa957e092ff1cd9a88ce9a12fc82e4f1069d2eca7c4ef6a8820c5de957622210e103f96e1499d75fe7b5c8706dededfade53c46dd8dbaafa516c6fca4bef76712af47b8420d852ad3536e98b2af9aecd511327a5d38cb88a622e8a6306865819f9413e32d9c0963d4baddda594d9984555bf3f3deac953cabd4a773882e421be9fde4d7c844de9717dfb60c1382b64ac4feb2069e2c00728498cee8a50aac85d18ca2aae88b9f00df56ae704b396432776f2aac9bcde8e8fa150e8a967eb3b89995afdbc452d5f3f0a96f6e00af3ae3b0a716ade69f26674fb543d672b6b749d712097611e1897a81888603602501db822532d3edeb99ba91d452a02423c96099fc756940693454c3bfd0c9964db655b1103c934fc27038231d2fb89a718c10bf7dbceff0aedcef1c34dc0b8e9c7c9048e87e7da386fda29d1be79d931074a120dab19e3d0a1af7f9f01d901176e1ff6e35277c11667f1f5a300d296424b3f32ea88b1d284df37579b10ee53d13ae7da5050077e3efe3dbef7813bf3661f291065f275fc41b6b9dbd69d602027397ac147918785c44688a7cfeeaaa60f06149a0663b47720020fcdcf172d4c5c1db46f7bac59538932c2141219e524c6f6206cb5ec20b7b42ebfb29d0781c77f7c6659fd7f070c97d75afacff4dec86cfb9101f40cf4c291ca6f7c531da20cb5382e2f5abfac628c19b1f1b39a8dabf5419b9779f52c84d7f2557f9ce4ddb2fbaf50309b668e32da761a5bf7f083cc617951832f92bf1f2a9ee79d06e343f29054a969d28ca3eb38409da98445bd2f93450428b3db28ed1924ac3323d45ad3ad7099500534b4c5d4aea0920bc8ac56389560c0757c43745d23f1ac18f3697118fcce2efe34133104172a14a22b0931c31aee9650426f054174ec3c32ef0bcde2ec5308e590baa4388433c22d945de8601eb09f82b947547dd69b49875b8603bb7ebfc9b72f7c9919dc29d4f755ebfb84f92dbdfaa947eb4362e8d0adcdada1af33e142fa7827e0ad1f2f1424139388117de9499d0e40d8d5c7597c61e6aadc4752e91d4349a2fbb4bc8b16380bc7b34ca17c1cc9dd10f0714782e0fc03cf5f060d19b03eb6af22bffc99b08ee2fa0445028d19639191f0eb6518cfa97c4b95ee6fee95f4963a47bf781375749a1ce40b626ab01135d42df65bccc4e3216f1e500678494796532599297bd81b033b2706c9edd20d675d35fbb4d7297eb72b94adf90718a04757d2c2310ed3154a2f2e603f64c2d313b6f1e8592ee620b9e9ec140f8c81a1e5b51d8a871528464ffa383c04727802fb21163e3621191c4d44165308cc403084ab11c1f639c884317f3d0f6cc058e582071a1ff72b1ef2bcad1b6b2c9b47a8e561708220113c1cb8fb0d7bd29978304a47ee377c188097cdfe642dbdccfd62323fd10a5c4212d9620d6690ec5a77cce78233db04c981fa18a904c3d6aad4c54f64fe968ba878cdf29d7ad1e6928c5be8f0e11259c8c3285549fe7d3ec742a5e0a21b5ab9e2c69f08ac8b49de38da1c5a660afaa402f06619d7b4305448be2550f09b2a8ad9569fea471f18c5bf37f6eb6be80826e55389f3259dd750acf80615d9024c8d5bd5549b0cb5681d7c1958e71d26ee69c93ee1b39f8ff5fd2363e343aad9ed0a821fd49dbeef6a5537ddd403a2cfe0b7fd09140d19e3ba8087f1f4114f3954b22c9364e6caa1553f82e42986ddf3a10d230f71ac8e97f8a9957cf92e1433baf646b6e5c3643ab049d3a6ccfca14fbd17cbd4cb5a5bd7718daee80523ea65d0804826985d8d929cd953bebd6b7db004ce2564cdbd5f1ae120684724463ff7fdf224e4de832ff24d1d794f856669512a9b0504e81050a9c13ee5c8bc8baeeae144c9fa3b719f965e028a3110a97e37b675835f96aa9bd686330c9e8d5e2b5d5e344cf74964de42a5f47f10bc52cdb7198e9a283b64f3dee96da12e07b9216048c81ec9913b796f6203fc12d61f31d0a1a58de326aa467b18a9c67f5d162072b2de336882c31c7f4b1e069d3d5472463e5c5c07a5d5ba5ccbbdb9f548d52ff8126a6eff304f5ad5ef408aa756f8811504569cc47bb9e0d2e82c455b1e403f39ecc6fc3dbe83c6e2500de4d5925a37d793ca24f78e2188da70ab56dba4134b2e34d752a84ad9dc4603a7bc9b3a185309cb22314f825be261d9051086c442f77b405436b05d38e3b60593926a776b009224303b1524a284da2061e9458cc56318daca9d1df1e3e05bec66698db3b7179b63266030a457546115d67b35db2e296a8acca955d98de1b0ff34f87c525361ef82e89401ccf2a647a1584d0db277230167459d52d0406792807d23165c69357548322ce37bb1c114b03bcdd3fcdba7b73d0d2b3249591d0da19b9ad263424719c206aa0dfcc167e14388639090d6a435dcdd16f0645cee87dbbc07a83fbf433d3c1133e155fc40ea2989eca9b9698f51997283769f145dcd19fd9789caaa37743b641dd95795a36134e0eb8c3857ecd4a5274cc4537ed1f321a6f2a86241436f5b134bd635b6125c3ce5cc03da8f224cc61c7bb499d6048759b057c350548e2bd0fa0de45ae79e3e7a6ebe487dc79e944b0d4e108ded7338ee5995c5ed41982dd42f82cbecdb454da4144046f020bd82a76ae9afce6bb2d3aaa29463b3d3ee624c4b028116c657032bfe930b8f1051158faaaa48df1d8d4df213c5d562ce851f326d919cd93bb3472e43d414fae1c300214513fd5aafe111104a5fc2355b9965c5f26fd2f79dae383bac48a2083b3e82a37607a3b82dcabcb6655ccd9bff82f7cebc3ade7a906e4d282d948f3ee2334d0681001e93843c4fe50b676f321038935287462361234f282531d8879bc2e48026f7e12796f51a6e32b865076ba28a8333da4d55e6b076d0f9bf8b284336722bef6e348ad7c858ef4f5cb41e578e333ec87f29b48592d677f887a4130fd9c9f8cdec019de9bc88497a2b68238f0de2027115c9989350b61a9b927f2634c1143c670d09938ff16f6bf8c0a29acdc23c36a830b45222e8a60feba695d9808ee7c5df51e7238f47361fb47d57a0c51da87891dedb2589d210a07847f79b78ee287875bfdf05c839897c7bb4b1d27b45dc55b475ebfdd72caa4e4612eac7ef87797a97cbbc0d41c4c7772ff5d0ae9bb0fc32e0a5e23e23bca8f481a4fc8a4f8d7950e0177b888f651cf1561f01f30b445aec3ceaea4569f373e692d119a75246cd9917045b01a2cdbe3326a8a20b3649898cf26207592814ce24847083e0d6ce590611fe71d31452f846318ca292f86457888ac48e9d72e8b5d46e10abe06ffd390789ee6a4362733e7e6ff1c87b72f4205e43fd2977b6add4515f6fb0847264fb5a5c47ed1f1a838004d922add9e5892b74940d5faf2c2f9df45508115ecc5491f185d69bef7b597aa216913fde79d7cc072bb612539d51502f84baa183ec61bc90cd551fd718dd19bac6d02515260fd24ead234efcd3deb46b83d5831007714019d33888c166562a0bea6eb437ff20e81450cd3604826048ab044c7e05aeb27c03c8bffca7c12c70a2efcfbedc20ea57165633bea38e1c001540e2ea9eb1b84751ef7b62f58affd1e2fbf360fbaacd27beb1fef93203b1599d07628d4511ec6bea59610aff3336a5a90f05ab02a6397ff92e33b8c711a1977c264b4b6ddb6a6cd0b4e5b8a7688bbdcac5a1fbcfa62c948d90c36ad7006b1c2110b7a3a4321fd464ac092884beac6d27cd6e8050cb790c2ca3b7c1f0597705015e93a6f70a3eb5f7c7600595182eb9924e49a556895f6af6febe94aee471b4260d4200429798246621772bb2891f51f9ef73acbb8e6b818dff546d82fabfa75e2cc25dc78483ef5ccda9d5908cde52d6ddb1321d12ba2ebb2d610c91eca5f42ab1ef331a3b6899c0781dc7c4836fbfc3d764b2c38026ce5a97a0734ffd43db7abab6251a318a8945ac18aac011754902b69e22ca85d231b5d6ff1cfd1ea3c69da18dcee8defe37268713ac9c87da8aad3d51853a0a7b6ea2c0bfd12a44a4d58c159c42765065265031afd9d5141c16219841995c187ca48e420c4853c125fee6af2085a7f930db0efb6825d35a7e59e1708373d9db11f9b95adc3574c0fbf7155b08ef360d4ba8c085c86711ab3ba7028f16fa237f7e46a996e9bfe0d5dbf19ddf23c03132166e7e8c7d06a59bc9f1098189a7ae41f6aa77c71a90bb80de3f29d6316fcb1111ae3becc545a4fabb0e450025bbf42d3ada90020d366e393ecef9ae94a7a7e32c9cb60d646a5d8216e424b8989d79ad62caa73744ff647c6b0888108f2575d173a9d553cacb55abd49c6f8afc10a14459eb5bb04893517faf165836504c7a5624da4a91a887e8b9512debd83a5fd16d2b8fba29418115751607ed83c215f5c0246336fcb88fed29922fdd404ddf8691ae5f56dbff19646ba5a7be3752edcc817a5b1b53b9781cd5e711acfae46ea0fc310ad1c80240f9caa590e3960110ab001267cf50e2cf4ffc479be53417b4f12a22ab1f3d11a063fb1135a5c469d1cfbe42bbc34ca8088684f978928739d24167284e2e6c277c0ff25d861fdb3f026fbce71dc905aff7070d4d4fdaedfb12c1bbb11371f17099ab3e51c24d1d6dc98d0af7a4684f77a2c1e093623f4d257346f89d8c417fb17b0603c8b6ccdb2ae1d49469e7510119ad858077976548252fd06bda759ec5a03b7bfd6941d03010e3e635c5e2ee1b9d5025532c179489bf875d8077083bd25b34d61b5978c76bab888eecee546f5f3645d88592d3fce2ff6299df157664fb1ad109d3d4e1751c764045d4f7df91d7ce666ab445ec0328033095b4b26815a8c1cc503012da333c0ef92293e27efffa90619611d29a17064fa537b04bd62b5f8498108884e05744609fe3cac3cab54178a1493f600f3859982561bd97eba17ee2180db28c98e31cbe6e155316a29f8b884b6079a46270bbeb6be389a0737d7aceac2eccfdbab0f7e5df2cdaf3b1c59cced705caa7575c2dc5386e730c44723c9da9a3c1f5d45cf0192fc76e4749baff15a834649113185dec7a191a3896629022a883b376ac9eec8b642a0aa8ea46dbf3c17ec430cb1eb77152d6724675e09a6b59bc4c74b2354938bacd864fa2153e3b0503bfd17d29b6d214b9a077d9fbf51528c60209b69dc256ef7daa08fb82b6aa264f876eb10005f54a28377dffcc0972bd90108777ee57ebd043f3cdcbb372a9c442e00df2e80dcf40419a7b5bcb44f7ed93fa781848787dda9a00e04fadc08c0fe0aa398dbd4708a22d7d85bdf64c0fb45cc3f4d8011214a68c76940ba83c422cf5b47603cd07a0b75fbaddf9c8cb7b040e225a168158f02a762ca402e2e2faa9d66fea510148d6d86095122484fd6af0f4de4a07fb3d49d6af373be6b28c6047b8818779d83a5a142d5aa8182a059771b32107d72d1c52cf21dad08f15a8e266981d75354674c0a942bdaf5f0a7bfc2c370deef22d06f746abf046f11a74e319cfd8b79bee36a3e5d43a0b4e19cb18f5acc492f7d1a1fa97e7264d25ad72a78527a8ae733f048cfa9edc5d08294b0537db7fb839f9dac9764947e41a4fcb923e1414097fb8e587f91d6c42ef397d10e201bfd45d8106821261fe359d8531c69245d1b1ca9c058ed5d2e34a0795488a129d39091805fb1db6f5a22fa9f20b65363b7df00b8a85f564f2ef194d274ccc6ccc17cba695c6cbc78fee8af3551ca08185a9e8fa535e0b70ac32136bbff03469095ed867ad7af3ec1479c67ddbe96255107418ab6c8f34b53c502e199f30be153373249a1d8e51906485e119d4f5961537e86cb1ebc1d24520580a0a7c2fd783e9d77cd5d6bc5fc9a829102e72669d41b0e12d0c9207955026973e13495b95753c5a03d416d0fa4390f6ac940eee580ddd166c46801222ecbceb6a39df0a11fc00bcf5c8cbfcd5fab0a4cf3690b914a087f9d3833a538acfeabc51c9fb8ed0362e0806923bacdaaf099fecc2e8f94267def17ea3e0f8c823af9a3923da464b67e5375b30553a673304692e467f8c202e9673a544820401bb707e9c493004e60e42a231228b2a9737bbd49fc1b3ebc54a540c2e9a9f2cbe4d8cf213e8a1d691c7a421ef0592f31a1361955c57ad56f2cd39ba05768d55f0b9e2f73e488160992dfb465a94c0334565e13b602d23dd71be665929aa958dafa38d728f10d21365960526a32a351f44785dc8d1e6ff6421905fc7df81e13d7be5abd1becac229d8ca402b0fc9c0d69c00cebb81ec5d8cd6872e03018c9bd1533bc7cf23a7439b8c733310767eaeae06a5b468b71f7a488b883595317175ef6a55ab1436519b0bb8587cd35d9367fb35b77030529967b6aef13ada0d174729b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
