<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9786b331afd7f761594f8ba1cc7eefb0f853fa65e1944e7998dda477e18ea0c613fd72a70d4af62c1dab6a111e8f12ed6f8c0bf4b74c564ddc2b046bd9eedbf3bd6a167d1b01f8a369a9977f196c027ef672af226c152e01bedcf12822da5eeddd744e3bcc67ee650798dc439e0389c2a0450172263e212c27fb96c5b356b2545427e10390b9b0936b9e65105540d6565d8e20adb02a45e658598a2d0b6f1d97d6f94c50194a78ab13d0278a9fd98ea701be6594ef50587f9e2211a25366e6a6b36e9ee05433fe1fc2db4495bf9ec1b2883bd58d193acc96a2c4f6a4d453672f424a72e59b77d3152baaadba7367d043beedc7ebbe986a13eb132b44747c7b3a3db5a10f28e9ece610cf17a40369710334bf318a613568847a0831542c9f6888e142216f002f199e8ced2878dd381cfd2b5b70a8a12c1850ff0bc686478fa02b93f0eec70f9d19634f77bf80db7f37d993d4c1a5345e9f13cbc001cc048fb690a71a5e0ff3302f92afaa7c736c30ba2dfea7b16aaee5b960ba75077bfea62b1537f7e76469a559b37fc2d7df6ef12c069f31a723ce1d5a5c3041ec6bb986f3567450314dda34f77b5bd72e94c8db1f4bfb86f08f9ba1087aa4201fefbe8e03eb6c869c3d756385a28840cba312ce4843fd10f2b0f0a870d11fec50c3222c5babf805479908d86221df5aa14f9ab76c63547dd3e9d7b55e7d6e2ce06412f4e8284616e0992dbe812b397c7bd88b5fd47767c65753d11099b870a269be67e63a3b5eea8395855e876702bc2428c85f91ff87ab5fb85943424c16e2724136f2ca62e637ce17fc80cd40c148b9c593246aca17745bf231f257c7c1b24ca4bee6bdf4bf518ccfdecf222d077f3ef20a2501d3e3743a864e75c881ef859b1ed5b07f1f6d21dd54a0eff9e6624adeff754d45fadaf95cf266a0755d37e5856f0c99bd2a8e6c97f21afc83f27d6f15b52e412de78586786c55168b5060b4745674f853a4bd787190302466e230d42cc14031d5806bd022d552a73d0a0376aa2a104344e1671bd0e660cdb17171fc5e1d21d8d095df843c163e668ad1fa779cc029f133e4096194c4c76a069779b6b5a3157a0fc3831690711b2572e3769f752c59d0c7c82578f0395494518780d429c4e02b23a74b6346bdc80d965c0d9bef791bb1eecf589f887d9dec4a2f0b5bb181c329a1fd1eb27eb9ef098a549aab9955a42ae653ec3a36b46d9e199d1163d3d52d7f8ad6b56244804ebf64213d909bfcbbc63f1edd6802e9427a26ad1634f4787e0fb276752f739077cf7ea0e1eb5f630007d12616d90dd0974d02817a190744c8d7ebec273b76efdb72fa633b3d71caa39dd41ef093f0e242e49dd523cf1e2f04b3443c5da38a095f4cdf24f8b911d80c52a56487547bdf069a0eb0e671fb5e7709cd98c88160bb7e23c2bb168024aee72c482fc1559944576e999a6c5a5be4d84706e12b5e605b40a27a91eae0aad7388b85dfa5a733ca6b0b3e4667d49f8531170cc6b55b53b790d18c9f7eece96f96261d8fc5522d86797f0c545443d5e7417072ee1de1dffde793599c5b76863cb0aff496e913f90a90751eed1736b82c7df0b8f55f3908e439062315b34642196aabd55866437a07851d8796e035f8112736bad6125d73e93205cc93b5010eb5f3963891d4fb8b8c90fb2178b903041f486a7b0ea83067ece488fe1e346b67f57491e16df8c1e891d67edc60cecdbb937da097011615f31009d4b6ef666c07a6b4d0acf1f591d38943444c0872823d5f18cce42c892e1a323ae866a2aa08a7dae310e02259e955f56c25669fa91e6ffabfe67498fd8eea6cc24508e2abd895211507a6ca8fb9306a91137631843df49f26b879d79b53b538b094aa54d8384d853485b5f018098cf14de9939021d105d8f83c11bcc7e0fb52432541083bed337a7ac4efed949c6ae64ecea2a5369ae57a45f7c1254e9886d51a09d8fd3fb4b90b85d52afef576a366629d43b937fff82fe0778172ba550e2561d1b8ffbae0b219410e93f2295463be20c8deb71d1a43c6d15370e8df9dff46764ecb200760ddbec65965bb58cc5d5f805afda20e115a65ff52fa52a7fc7483b7d46e694c8a023749b6cc2a8aa0fd08e4f8a1c32ae73855829d14639308538803a4061f2056e7b92a97d46b5afb57e1e336c2964e0e2155a2d933317372757c4e455309b8282d975b2b5486bce86f7fc6d0eac8085ba4644a1ef8cb0671834fea9d7c274beb647a77d71596dff0a066fb437fbfea80f29d647c997a2f4b8d362f970dd95e296bde98fa45b3cbdfb5bbf1568ee9c86b6334bd664943c8a82854ac344c36e8395f0665b27f4ae1bfa98615b70b71805422976dd95b804a43982632e901992e5ed656c010c5d92dbe3966f94a622db21fd93f80f269f582326db068ee62038e19a74a6d3b0cc8de8bd01ed1e3902653923fe7d6bf5178e1a2d0207094aa8603dd84f2d3c7348eb0c5c96c3f3b9614e9790c23331bc49e57deb0b8e7e8b7970920bd9e8d26903d19c5aab2c1c58a51b13a4fc7d32a697f2209f22c1d3855663ee09f79aa9ed1cd00b81b2397d830542538272f2a1b344f828ea85ff635b34262d7d4e91cc4db18ddc5907d6058a3b13a285fe2c00f3d30a46ca48879cef3ff5f4f543b172de34ae3b6370bc83269148b7812cf3d90a99b78f4083c4a9f25b27155a659be6eb57a889c1a63885af4e97cb2efcf430a2eabc63e712f22513c3dd7455c59250d9dfb50aa85beff01827f9cad7e3a41f81fe9a9a2695eb8da63b4eddcceab5eb3ae13a3dd1a4654af65ee01b2ede0dcc000e8adb0b0ed3e99de0e8bd7bed89354ed0811bf3fd09fa21852a1e9f715fe65dd3b2817789a84924432cf89c8509d5d9ab548567ed0865851eb19d6aa9f01bf3a91c8ade7e811664dd9861f277e7f5c481d7c1b82fd5a3718fd4f922c2b367ff8bb218a38f56e317cdda24895f011d5e296a14af69a94026235d0bc49a9eac4a3c0b1889baa3a1763bc1ca99decd749667bf71357e448d0ccb5f43b68a246f09421044b62b62dce28a3126a1e7444d322efb77d76dffa5e209503aac198aa124b816e9be54d963369f590ee5c5fee87f6887dfc89f6c4bed9aa6a69e641ac08a5a3664c10cc6407ff9c7f0df5ecfba09ba2b4d9167eb3c4cdec5f329c6d7b63f19d8d03caacade522a0a0c3d9ac6e82f333841bc8e773d757819d7b7eaac4aa5834af4a8526c723cc7410f1e1d2eb79db2c39ae43b1c2cb7f5144ceab81cda7fe840111cfe115f23461b25c844a010ab937c6dd9a03638b114fcc28ebc71fb60666a7dcbbae7b8fa3ecf04b2c0eb5a82d6e1186b122fb74a61d9a8f508b52ab081aff75875c974f2b5d7b85d692605b1dc69a84e9f4a56645550138e6d4d3352fa480eb4197fd6389f16a948e3274a349a1b90ec636f254b32625c1c545a4510e4b0b7ce742cca73ad6a421753a4720dda595d9437cb72798fc1c61585df7cb1c64d5f0af285f3b7b6a935c9c434587b3a9da2dcc3d82c95fb5f4844c8897c1051dfb2bb4bb6fcad51551430ff3c279775961f70b61aae856cede0a2705dc6069b91f7b67849fa3c6b67a9c786855c15f86c009fe6ea74f5d0cccc7cf9a73b1cda743ab32210b69cc8c5db091ea01aee3bdb3d6866c14bcf9bbd83f7c2619e417d0a87f427719fe3a9259dc6414547059b4379065962dc79d20bd43bcc89bbbf2ad6581d8b578edcad68b43e44091578df7ab776d41101cf8399c518e4c2059a5d570251f1ce11b124fa222c0c547f8ba844d60cf50ef375dc256a1c8be47bc6be6fb541366f5a1298c68ea39b30cf123931fb522aa7dd8a1e24fbfd765db40e9de641e4b712d7a372376905bac8a5590500e57c3e8d9c3c41152596590066516c5c66c4c91c80e684dde0239ed4835711c158c1c5bfce9c4c1fe1b9b50253324c122ee8cfd6456267878b8bc8471cee0a3d068348cf3870fa558ba2c7309e4a79e5fc3d352b01056f24451c3425ebb2bcb19ed279588950dbc1e4d298176789af69036bbb1e8cafbb43b46223dd27c53a56cac8aa999233299bc3dbef31e985a58aaa4cd812831d8a932c26664321555d0fb5a7ac49d064dfbd2310e1a3ce9a7cfc34a5125a8da67b4ac5a45062f442b57607b2fca83ecf56fdbae8fe62df27d9332ded3764d6963c654aaa701e4e52713df3ff594552f2bc0aeaafde9085c22ec0c68d636eca25545f88e6f8c3e71a3bc892e1f36f1fc6b2bb923c8b4bfe2073c54212ef15bf777e5f893399351b92006c848eea327e1d8e3141102a43d6f7011ff59f9cc6fcdaf22fb5e86481d20de5dac40bd67a909578f2b559b16999b79137a08e8688e41eaab58fea3aa5afcfd2b641e8e99c53493d55811a7ee519f2466aebd622cdefef65fb08eb56a7fe6e4fddca082622f897d36d11a263eb1ff41ae3c995c11409115cf9c9c0c14a9fa1b306b09d070eb0f6eb1637c0c2754348874483cacbe7cb35634006d3a150dbbf218de8d592308fedf06b7d301575ebfe48c99374771840404ba3105108389f3a5e4413f07dc59c944b4e4a9ee460e31757f501371b71cedb08fb1494df82c87df7ede0e0d3009c3ab6b0f7b13e3f84aaf5d1446f6e380087199e540470fcbe128323a845bcce6d5fef63a01f72157e59ac75142d923bfa1a832f71f12fc246639d2cd3135cdd3c1ef7bfbfd8d88d1394ee03b3df11969f0424be5f0e506e7a670248bb2c584297dd32aa84fd9074b9d4be6a7093be65375171e627f10bb0fe445f96395ebdc94062687f7543245d0313853b987a86b01b211ead3109fca501f682c9831041e28d2ed8c1eaf14db784e817f1b119b46490c7dae28e1decabc3c5a22e11a4734605a56499eb4ff3aa5da76f151235642437c9aee7df7c5da4a34ffd4cf4cc7bc080634047ef63d4cf555e4c55c2c6551290380332e888027652f6eee699d4f38decdac27092538f2369325d3291c93ea2e8ecc96a095e3d8cb70dd1f1fc81ff057835f14af02d9111580d5d4f21d6aa5da76b3a1a158ab2304129c5cf70492fdf2a282ff0a371502575aac216282b81d89883b54fd250cccd18cceb5337d656937610c4f9b58c998e508e154509228a94c20cc22e86334eea9822a0d7035d1e48bd9c6a3e982ec73d0d426725853a3dd3a69b7aabbcdbfcb6c694b32f85f63e3cd0940c30f65d9751f4b2fbddb0bb42928af031e842aa330aa17c3f1a98a24c24b935bb3de2a5dc92a5e8398241961913accdf8028b4db832a1f80d700063990474a3e499f85dc8b661489c04a1f9af7ffe29fd7caa7fa042f43b38fd188e3328001efcbacf53f74dcbe04f476c37d09d292b6ce3120106322fe59627578b611befb57097e6267a58c5eff3a607a8249d69d39f85b693746a0648c251e50b0f9439691bfe5a627c6cecb6a5d0a83bb4f3c6e9240640855f85843138687ed60b8ccc90dce750682b70b1a194f54e5dba04a79449c8701fe8e4fe554e0c699a44d2971cc090ce9020669010514a3144e1c3022de24f656f35afd95f21b6b481a16ed46345178fad2bd03a5aec04a7304f6f831a4f7492c070c187bb75fbb664f4cf9c74e596ca86f9e0aeea7646dd3746df3eff1c24a37d6b9c71468f4e3d80c5599e8e6ad7331e7d2c9a0d009b1543fcb88e1ba5641a0a16a46ab7a22448d3bb851567623c8cfcc72233781375f7d9b316d0b8619879e8a66269a7d4f6bdce789e8814f949ba4faa3b3ab0446170fc68a3f1061ff2e9492ebe47c7a4fe119238d7b045d8e5ac23c03994ad167e7af1b686e1080fae3befc252e4a240aad7c624bea50731781805fb94cb1c2a6879ad79c5d55dca2bb78de157f899d7d7524faa7f3f54de8f8c8037bc8411af9fc969d556f537cfb77d18d949b2659e19cdd467633fadcdd27b826ebc4abd06af9464a29f3f8ad3ab57b4cbb5b9b704d7df81ad0123cfc13475a840603fb20249e9d9706a28df19cb69f00c135193d0dcc4a3e45fa94e64dae9d7c6b573b037683359b827b48830c045f915f644af68a73e15227540c9dc0ec68cdd4a85c30b9e4a51aab4981e18e78487ffbe9ed64a13430aff880e7ff07322784b18e672aa7f5be83f7b1a856349f42057d397d95b680b1422c6198e53df2dccf67b639d580ac77f068ae7a67d9cbfa85b3352d4162bc29475533962777b9f5eb97358c5937f252ff070d940c018c4c620392cde36992378bfc4d25dc789d66348edde8cd62893b4d10bb2494360d31e64af6b7a84caf7a49c87229065be0dc522cc2f46ce94b8e36e0e28e48313ecd332acb8569232b56bf3e58d643c2f7e3a74490c8603e790015fa4ebee5e3f13856649e7e2069b57d9db79f753550a388d0c23acc0d29fe45a8fed7332cfacae01d9eabc20c3a68cbbbe3154e174f0d3d1924c53c7eb58794de8c32f907a6c090ef84a5595c9fbcdc9021b61e204228772f3653c8b2699ec5922340b1c057e558de75f2e9f1c52611aa622531727955b8880275d3904ef607c01475b878f1c967d9e226bc67cee216ae9e333d8eae3834843edc4a61c80736f587d933fead100491ebc2efe558393671ca2c0a44aad9a7e5cfc22932a2b893ef39a18a032ffb40be47a7ad6822c73d66634ea210e5874a64bc3ebe06bac226931dfb6c814032d57999c2d59e2d96c93b875bcabb753baa3cba463097e49a3acdedb55a1873225b74d3d4d1b297ee33f7bac7b3e0fced22de8e3021ce232436b2dd947fc1c86dbfa095d230d75e07c31a5f094d56370fb2b35fe8d979f42a2edac26db8434d2d4f98ad712b3153b123a547ea7d1aff5dba9b19c71786c849467db203532795cc41a4ebbd24abb6d04833d3d9b8a93ce4ee461ae4575edf13b06df5f8107ac484fd15f40f2762b461c946402d84afcd9b4edfe3e0f5fec144502f5a0284ce4a52129f5d6e2106603e49c2c03b5b5b04ee163da2e6dafe4bd3dcff5abb1aa4682c1e3c52a64ade00055903d470d450faac4a52d1b8145bac0b152d5ae0f2a1c2230b77df111a4f14b719a43353963c0b691f5ae609815f2579e6cc6053c023e853b94ce3039421f9f7a9796d4c0ba353bbe75eaf6094539961b2870a11efde2bb301eceacbdf27795497cee7dbb52c7571e22b6b445de5c6512f3f57f0b0e5b73a82b7d039bf119099ddacefbb2796e196ba987f0b597ae0fbcdfb62615a4f8c2d678a66f00509b3127c9fe674dda93202bcdce5de5667fb5b3128ac9a780fb6c4af16246fea0a69ea4e34af422e4c4f004050f2b633977c1e0dcc5899240a28829d84f4b09d37874d8e0540de4850d9a8c8b3f5a0718742b716795e0632a782fd5c6e42b597e70f834ee9491edf48617ed6f42a15d7a64e632418bcd4272691b5337405c7351cb9f471e3ca98c47d0fdf88ec54a7d7ef62611a637640c04bf78b7ff715fe8d174142f36d08d7acd33940f6bb8208ba673ff3b5a089fda77f8ffd8a80c4e2c7b9fae6d78955d60a469d286ace91e3c64aaeb547b26b4b029d233088f210cfb2a891105760341527c150cda005c04db53311078d19d6662267f4980ec0e8e4e9297315983d10a24190205780ba7498e284acefdcc72883693e6fe8bf00afc678f46490fedcd9632c455997702688880b12c91810d38f8c077f042eff5422f96f2948ea5990b7bfe688080edc1ab1d7e1add921f9a3d685740c0786f07bab3a2458bd231f0371db2dd185f246fc8ae8efd7b5cc4bc599ce6434d70a756ea42b085919456e77e1a9142ad2e6c69e1517f3304442076fe11e2fd854653c7a2a224f7b0e5a2fe3215fdd0c64a5628f8e3cd22ab5b7d5f8fd4571856e2c12dc12697da36ecc728178cbde6da66b3835944134a6d9c87a54f32484fc06f14c4f26a0f8569255fc5378797162d9eec4432319718f29488cbc12d3836a4627d0556b561ca525a8f31b9ee099be068e56d0183e5a338eef74998d1ae76509030103460b448f32d9f641a31674e0a02534b0752600951a93fb14ab74b6418aa77c1c1336b0b242202d31af4c46a9763b7a26d24c263ecd7cec21c652447d824f6530decda97bd5f531fe4f13dd120f3d6ab4642950f462873c3a0d8ec549503859c707e728907b3cd9a02dc0c7bb9a022111b0af5a6ec0285597422522d4eafca0f1a68c1004c6f3a5eb152dffe57a832c7195d54ac419f3051f379f58d4c599afadb5e442314e28708837f2656bacab0d1861e660b80ba3e52a5a474761176e124fe3678177a8ba47f276a78edd2f2ae316a27b200b5feb2c00523162ded3ca9fbf5ec82245de5f24feed397d46ff78695d8749a42944020429a56adc9a49cbca5c931082c96b81210dd317cb21053294a22692a6ee6245c3a14ff25f720223d278acb5c7cc9e8a24f7e7bd06d56347ce76f9a5ce8744d544acbcab8608c8b03f666c5095ab5942d0a82ee92c0c3f36700724f67621f5f4448a0eb7a08f6964dde2a8e940fb49d18d7d31c973c0ffe319b085f85b1b00adf48f08d253fbe7065f4e41ee02f84663ea38cf3adacc897600ffb36f100837e00d0a6d8837cd4094e014b8c650a77b794a195e07b87bca98bb2e1c2e9895403e74700122c6106d2ade19be821ae3167b957603e36b85186b4f7c27ee63d766f25cb42dca04f714ecf180dca15167ce249f7428bc3cca94e4846dbfc0cea8b2e4aa956581d293eb5a19edf677fdb38bb6abef144edf6b77d34c5a396c8fc474eaa34ba82429e813920d24f1d8c8b64a7591868732f0e8f9798198d99cc2d1504bc840241842b88af1f9e744735e566cf8bd25248474c3795ad6f2f61f6721b99e3b635adbc699bd14f5514435aa6813b3557bbb6a15de7f573d26bfde34091db0437364f95d44d01b27b88d8163c45f98178efab3ebe62afc43a5aea3c555ad7fc23aa06309ca7d44a39a701d05ea17a00840fe4d0a53c99f08623c3ec1eaedd5f30a33a3565bb7c2619b50dc3111ea0cf10bf04ca5ee1fbf4360528cbc2ba928b6962c6a6a1ebdcab3cd537750b07b3a151d083b6f22b9f6d26d8d77fef8e302c7111d0fdd0f977faa827d1b44f61972b98368d42d477999465163fa1598115b8c278a3326135fc7c4f78e6991f7be7fd9d00957513a4fa0b8c8d6dfbef931a748950c98ece2617a338a1cbad1168fdf6ec8454d209a9790a659b126c3c0d060c2ad52312573bc94ac3be606fce481687176302116d2a3604e3f4deac67e051bcf1cdf2d3d03dd0cb06fe533834969bca494f94af3d5312690ef21394abcee07e31c25c5e67477aa3b814e2ff7b7bc7377b5a242070e2ca9b2f4f9a5d9601aad1f995af52ea1171b0e8712ba23ee7488005c2f8a3e3366f309f2543be56c30ad33a39497f96df3a5d09255e75e05938af842c0b82c680fb0a9cbd86b661dab1de1c796c7fc688819cc42249bd8fbc6657979c3a4a6c9ff8b18008de2023a484123de2f86bca4c9ed5666b48a82cfaf8952ea4c431fbcadab3f8fd2a1766c2007567ec0a78699a3035baa3a0c1c2ad84b4cca6dde54f0ca7c46596196cef375892505f698f326b0ad36f4bb7992a31e37ea77974dce0ff2e8ca41661278553a428c89ca0238b859bcc2ccf11139172fe6a81ca515b7f970031ae15bb7bc581d926691777a501621b444ed9341cb8c05788baab444ca8a9f8c0f4b3152707788d37f7cf197b466a9fc68c29d69ae0f59e8c9fe215f5069c47657f002e685124380574249e38c2280eb6579ecc5163cdbda38d798171d448d0bd8eb06b00a11968d3f3e638572c9c6e0e69e124f08182067d4879cbdca49a902ca3dbd6509d6403437b1b9c41c4937918418deadfe948a90bc98501b799eaff96ed5a2eb77f0991a215e5421a0f550294f34638d03f2e44329b2f29db4706d82b2ea3acd5a22ac92e98728f008c050009c511ebbe9acf6bc758c35ddae27006e6e86513e99caee2823a1eb5ee72321219eb5f9b5bdf48ae9c702378e396ef017d39f72703c034d5282ca37be702ab8c7ac1b352ce9aa7f3335079cf16be6bf8bb2330757347350f4bbbeb37129fbcf69f41a44ceba85fb749252791d16b0e9cf9ccc6d1ff4c1a9c9f9c93eeb73e560b565e6436aaa90c27fceed73b58090c07f776c243e1faf29505e694dbe7cdd9b208deeca2341398f9f106d86bccba2d7edf60f3597c431a60e5f0399620795fe56362ef4bbaaa8a2e5541702fc0c97e2968bbb288aaec8153097ee72726153754ed55f56a3a40d8db2f55931a4cbcd41377388ceaaa9fc08f82f1b7057d9d0cd0ea6c47cc1d78f7534a7cbcd4838c51dd9ad6d6d3215f7a76e1045f5792b928dad56b7c3f11e03545c6e0da97805ebb4a27e90ae1169284177aacdc99f99251171521dd42961b2e55b068730787f21ca6522c2d3a01e1fd28ea9dd4579c73d692b7da254fa507422e462b4bb4b6de84d1903aad4f892524f94f6b7d79e3f0921babbcac3bdf2499c96eb1b2e1f1771b576de95a8f02234d6ff0b51f38d93afeb3ec33499956c15da8896f29f8e10c270b509be1b93588754eabf7d6ec5de877b568989c39cee6f70729e8ddc6ee33706b70f5e6b05eed6ad504446018819d42a9793721a17c381370dd5c7cb81f71572f90bdcdeb0fcec0ad53b4bca358fe53f34b2aae46e85df044e5b8e1d72dca1a02a4d1c6b9c5d2ca2338723c031c5bd0dfe20c4e82e111dade0531ebc8f008f891c08669a4576575a4466cb8bba40b3f2e1a67f985fe5e8a8d1912c343fa9028c6acd57e9c17d6614982dd823fc6e84e6bccafb56b75ca7c6993a4d750ffecfe0d6f4856d30403417063cccfcb14dcc28353030c5a64f64accbd5f73de83926a9a909561f396b23c7ad2a3af45a1293ebb2c69e44a27238caaafbbe3d129fad86b7ca5ea8248cab77ad0257bd6f3b9d8497c9ebd1dfbb40671f9fee7d524c371a31174236b035ccc1be0fec7839f224be2c9c86679c9d5c929d1fac103edaf55283b69d7757ae0d28f8460ca9d54e9e807a50f734ff4254773848d7b70609e48ce4a89530a3f55222b966845bb1f2b85354ece849098fb920fd47b3405bfa81d0ac8821b214c87fab30b5bb4b838ec69da104925d28fa7ebc71a260d57164383ba10fc6a8d3a13f91b9daf20ecd28b8ed9b60d8cad4c8e511278e2136d1ac2dcd2ef4a148a69b6f4e5c60a30ea601c1b58b49e21654bcfd9b07bacf12ab2a829e259f338cd2e68eaa4c71da9301c966064d6a935f4bc260f82b535ea8e4f8e970bdda38887de1ca5d0599a324aee371f5f81c455feae6167c0138a3c269f3442563fdf25f0c0d7d2a8fb073ddc088411668b434b529f7bedf689392af67bbe37f19d6b6cc8baf9a9731b0b15bdfd5728711d9ce98971b32e1d76951bc8a70cc1b474b2ca958a0d8d7611037be9e34b18ac8f8d24baa15b26e3fbdcacb12e3d71f5f4afc8ebdc510032a4bb9dc7b1a27e3bdeabec14a5e45aa2ad7505409d3bcbfd783177aa76e9ed919814a6ce900465673fbd235a22fbca8435ba6120e07953f59ba3b37d7f69fc80c5db58834ecc2b310918b82c1008bb9ad1287ce57323c053de4377845e878f76cdb31448f36dd4b036755b9f0f542bc69b2070df1e4bae04e5a5308c920f4234058fe3455f846cb0c5ac75ebe22f8f84c526290f9e6ead609f1d2d39a3d228669884694b701772f520138f04796b344d9797527eb6668c8d29078f32241b909d43bf5cc0e456d8fa29ff405d10d2c0520ea0093ae9e832da5964e30ccb3669a3539fe2d942b892a39c71396a65757c59f32c3f77a15bf8b52af7f28220b10ae407ed963b519e835127656d7b892be42266efb9ab34a548b4c8fa73b4d2ad84b0ffb4d4a756f44d926f041f4dab79846b95d563e8770d0beb42a7ad9a5db8b41c673ee00b26d4b800c31c0c18674a9d79351d07eca007a48cdcda90c24562ebb67921f91dcd345e55681021e289774ca5714e08225bf9fcee4d76ff791b012e97d4ce4e51a84533b4aaa2a2c57e5f75b5ee5d04e8ffc0856bb157441697d478463e4fa5a8c105c71d71b2768cddea0c57a749eedd5a25b32366875a2618a63ccda4634eab57371d3af73df7f09d1bf72260a277139ab2204c07bddb0867643dab66a97a8d9229e4710f3fe07d21f44c90a31d132fdd4ff50c65509b5708746cf9a7636a08b5e2e58f66d4a064b2e3a735659aff6ad4d11684e0ad4b28c3bcd1be3c323fe43bfbf49eb1ef797e75829592fa922c72deeb92eb6081b5efeff736161b50cd463c583072b40bf114019dcef185a0035656575087bd62aead430b6dbf1eb1d89b309591bf330724a7d5cddc64fcdf7f860c422f7729f91d358f35cfc2b12dee5069bc68e58d105d79511bf3008804a41192191f1a44af0478b3e0e39bb62dc661a643737b281beddb9d1237d5eb048db9b479e166503fdd09faa64e01fe6e5cf2cc0187ecf6c52954b5cf781c122b52acccdaaa7d6c7d4f83d1f1b76ffa3505327d37dbd05638287561629551377aa812755cd26f61c94a7d930ecf1713075a54a4e97eefd2ef9f46e5743566030ac24bfb8e9be56b5246c141bfd41b2385d7dfbc74ac50bd74d85dcd9d48aa1f5fd7c99d7ef940eeb31026e6b8a06f24d9aa6c7d6e2a837eb61c6731dbffae7dd9ca4e7d4f5ad17495d3a1799921c4a26ebf65bcce0b591bf94c6db24faa58bc3e70c8cd51392ee29b4600018a37f5ebdc3bf03b6380ec5a2cc13e0a0ebdaf0c80e0fbf99fb28dd9d8a1bd389ee8d552b783cd615ee84dda6b56243b3df1ed006ea6b6fa52af15f15b161716b88da431abaf4ec2e0a416379eb2133465fb6b0f4f994916beacb36d020661e2717ae6625fe1f3b505914ef1e335090daf09f9a72ba532ee090a960c77b0fd7e637b9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
