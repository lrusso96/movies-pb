<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c02d2ff1ac550f27d31f3d0cf2f40f79b05f03b497304bf6eeb7c74fe8b7640069b2fa10364a1baf499182e38050cc16dfd51df4149c4cd9a99f52fb8128ad335c386841e3761385d0e2bb7b347cb098446416eccbcec866a1648a61a8bac19f58970f15ce02aca7ae80e7d9b31973223894921a44948618551587707566755134e111619e40ffd5a3a520c624e4fb7d5669a244a592096229642d790a085b0e45ea52ec9dd108a26b287620d93f1abfc934b4e8929646c22f747bdef30b192002f994102caf3b999fb94d19fc65a1b504e0aca7a5fd94e143ed5c5594268f17e0e3f87e6194f74ce5be81713a366531c967710c16a62118f641cef959a3150d174f5e7a892d91803d3b7c6f1846486627a4b195962266a7e0f0001ac73d90f3317ec408fd3cf0d16cdf3d2ecbf4e2b31ccb8369f1c28e06a7088d3438dd0b66953bd39e6effd343113f2be1b2949a5366b32e35bbd5050a04c788c75909dd9316f5eaf49bceebec8ff365e1d1b5742a341b39b6b3ef94eae75a698be49f56c400ca5f7bb444aa221fc5f4af866f840cf6ab668478c20b99997089322a3774e5daab14a6fa4465a27a142df63a44ff1115268b2b2c1c54eedc833f6cb6cc90e50cc233135f03c9ab40dfb96e0e24284c1cbb5607b36096627e5406dd3a1fb825c3f2a3ba56a89d03af8ce4cc2f6e3e7b547e60bb0d13bb949e223ceda530c3da3d0e95ed222af9ce5c76c350327dc6170844058761d247fdbee830fcb65d63bd7bb025007413a840e3b382978cec0bf12ab6909a95e4540312637514cf453d10ce88d42a15104a5531e3884b11dc1ca7d275f3d49ae422e3d563384f621ab7a958a5e67fbed29ab3d3154a0645df6c09beea8755996c741f925245f26de09b6f68230903b088814cb9569e87f9e313eee6754c39596e8d8e4e079373f30a93ca31d8617edf98980895fa9d99f4def35cc16ec765a22073de03f7f160a57ac067e2be0b22d2f22f8cafeb995add3263f8602487e555435daa63602730692617b9716e8de59862ffe0b298df3ee3ae845f70230a6fec84eb852273d023de574c1482cd81a4d99e45fa0d7a6dbd96dfe8b1ad8c93d372d6b74b0af58ec1d837097590f3f725c4db73bca002c74866bd41c9f1bfad955adbc5a6a9f9b76c62ba62b627e1afa8b5c4f8bbd94596fa78ca2772fe8a2bbdd6ce4c8f21e6d6cbecfc928fcd23569bc187ea76964a319a990bf1e134f9ac54acfc8bcc5fe383c4be02f963dcbe3b91737a9100e84a99a6dc342f3d98351547bd3bffc0ecc16d650aec1384be43827c02eb8f4bff8b9a32a7920fb97b38b6a5b04831101e0f6ffb07e925edcae547b912150805a1acf5931126f44b9b038b3770e98736bfb66209f56fedfc0ecdd103ea4145cc5c193059ee790a6d8d20d3e3b6dfbcfab394dae2bd873040fa7ebd7be9277de6104d77ebdc064adfe9775259361f8f1ef76458fcc371f7cbb19cbaa4e6a2eed5ac69c7f3bbbee8e1fad58d41fdb2c1c3d30a96748ea4d02ed9e31320f7d6135519c37380f3d4d07aa23eb7a3d11613f71f2c204a2d787ed715c60204dbbb8ed1383a165ec525e3916e89df50b1c78b339b8a79db3a5df2010ad426f816da286c3bb3b84a07e4d5068bad8ec9aa646f122ec35ec157bd1efdc406764a84e21441c7e2b4ef057538fcafd4b1537eb4d7be14877ddab287d2f6b91fea9c8e357e9a884390e792ca685963bcdc7700fb03dd0474eea3bb21fdac2bc0e7b2bf01a75d3d376bc09ff3b0a111168a8e1cca20b181491f72e9b4b864acaee61821f330a5177405f908ed9fd58ea9ab9739118b0a3734fd394f34d8e6219083be91fc323351b4f0e8ead8a488553ec2dea123ee0407d9f883fd433da8fa3ac2f21faf770b43fc913b7eaad2fc6c323e050dcd836a619c2b70e02e44f5a5794a8b46535fcf9e1382f1e747f5fc1b42588387e47308c2bd7424fe156793912e172500e10e5e833ad5f51f93cf1d0df26b2c3fb093927bb128dc31158cf2b063e0710e1bff0a67b0e8e26abaa3f20145f54f46af6887188526af578fab7e9646abd81ab65cbf11b54023453b42daba416e9573bdcfab100859a55c6682a47ea18e250e665ae0081c23063f642bce3e5d03d87d9376c6d2b8e176f1ed23056d93ded7440b21b0ef8826855acbf1217380072b61ce0a9b7b96465fbc291d695d23c95f793602870afd6cd85e45e3c8a259a623c79cbf3c3faa67c71badcccb88cb0a52b6087ecaf4175c922bd9b4973633fd3586aca7c6fd681923bc87538824e4e16dee96cf4fa1de07cd1cf960ab98ac9f17030574d7185b93a36606c1d2866dd327bb79564e19b74c41914160f0a44ad49797ab89c70b60b5771a347eaf0a57dc04666bba5eb42e5334b33ac5a8249c506b1afa6e76e21dc7e4fb2b449af2b969d98304173c94310b65831e108b0efa0d112b7f3218cc51da1180d8da83215a222f7a366b2e6d5c11fc41b67a709ac824453925a430419c1abf16e6d4cc95051e4a359c3e3aa95dccacc1845daf012eb73fb92ea35e36e5ab62b015fd7a45e5ce35ea2abf8684e83ccbcf6442a2ae4e7b68063ed56b7e73ecdc8fb079c51353e6618ff9cab17642a664073bd4933adb1e939a214f08c79f34d80c88145bed9275901a32d9dad2362a9954032f1ebfb73e271db7a1458b59307413d8bff2828d2d9eb997ee99726bab2922a77d621ad4288e5cb45aca2df920455a3fb3138a484d52643aa25771331b6f6c8838df229f4bef66973311044d31deb7af526ee7fcc45d97c766d0f1165d98baf3336ae6fb57ef7bd3a288377f21baee42a8ef90d71e345720368a7eb6fb4872571c39f8f24b544d9aa232e0269f0aa3ea0c7dedaa09792a645df6f38af1722ce255de3f7721ba7c9cf1115f8f49b797532f73da973843b951dfeed72bfaffc21361fc3d4fd71ca342848bc8b93d0dd517fdc85bc835ff4c38678111139e3f8a45c3ed9f984854f31345fec79e0ebe3fcd73eb446af2420fcd3a696f179776fb07c6f3a2d948895a1d7530e1fb9413f4f2c1a5f54bc37369881837e76093c17f1b135d762304168f1efd5705f31c0396d57a36e177786108dd3d1306b7958cd131b9c8d34a6804c09ab834904b1a6269c35145495e2c73bb536ddee4c8cfe8a6c6a1c1996a5078a346dc02bd01eeda9a95be3c9fcb01609835b745ebd405af19c03db938b6f528e49e7263f9edf7e078a76bd31a01112a8b7c417aaafa4c7aca8a83983e49cb70d9bf0228082b4fea74c38312c71f9e29474fb3ef3f2b9f4a9e1b03e72b9c4fafb007822d4078d28d3b3973e9adc663028739ef4def40367b09239f128a4c4902402205381d025823b22e62a30c00f07345526f782292b0cfebc11e0609d4fe9f0d8d546385d1b866256fe24ca7e5fbeada4a1cde1d5c16fb93da073a9d7abe03d819567d5e8550f58c17383a092c1d00fdc384b03500aaf8222e93a9b852b6be9b3dc0161fcf9a9838805eb8c0ca9cc38e6355b0aeeec50ca2a83e2d80e65ad0526762276557348977116246333865b8599b03d673c6d5ea620c422894009d5542313c4910b53edb10848213f48c46fd87033a29085c20badb468b583dd8500d46703475537a35cf41ccc59bc114bf09e84e30aab71e5f379907709814488fcca928628928b162937f7a8c9d7f004d85424600587327bd23c0f3df64dad1a4f73b5218b57fa2a6b1e34c85cd747ca33341bf2e266e4b2718ea57d027a604d40b9509cfc0830dd84b36969f2db8a18d44c710f6ece2404f35b995d1756907fa41857a49ee8e1b8ce65c4a56c8d492ac38afdea7fc3ece128d0063f68a36bb426999a12698614ce3c330d4cf21b9fad6d93711a1420aca10f9e4130c4f11d5e0a9813d3936418ad504c2914a7ac81235b97e07b69dd606a04e16035613ed974478f10318c7509aeb9b097ae73b6fa93f910fb252ebda7921803fd1bd9f756130a0bc637998e58caf8412459a84c44e47abfb2af7964a496e914bb0797efdcd12f4171bd4cd114b476045ab3ddb270414b5d17d64aa5efc9ee1ae37190b433a004fb8bebd614c5aca0b5586d98971f80b0750c2aabbf8b153cfed235fbd7474b11882cdaa24dd707bbef415285829727bf5844456c10372d77b6757a330c274ac6fffc7e35134480e64aa028ac32c5ad64e1b62bf5ab3497f87a37a2ea94c916d0af48c959c625be9119067510e865cbbee87888de85a1b7b7b8671c140ab784ced60c64ad36dd2de47b714a3eaf8792f8a6f82a022b2b7c4f704fc95d523caf65a5f0f9f44d32f5b2aa21c446d4f01283fa116a34c65cd00598228d8a64efb7f286366359c511a51a4459d20b754a4b8c1f0be192dba88b44a2e1ae3ef84815ceeea94a692efeb0f5751cc0894cb776fa444bb996211fe5e7ac6a05e325a357ed03033b9662b2ca8584df88498b82dabe61896826e999cb15085dcd0e4fcb422447d1f5644f913fbf9a81e37605434540bcdffaceb90c20a31d97dde39d28958cdc826112266b7b3f15fe1b91d04dc76b8fb55dbde56a0151f91180591a2e02ef3252afa5a2ae54c213dc4917cbd3b12563bb12f518e40b05b6d3dbc1870c0667e9c0d99f5b11e81b9293ff1e0fea94924d1baf2de9073dda9777b710ac7e1b0fc75a210262ea2ba37608082470372992471c10407f0e9a725717d2d636ac6faf25800959be36cad654cd519abde46d27766a6eb1ea71cb841832335fe77b862702f0a624dfd467a0d47cc929681153874498b78f448432c48a61dd3695dd87dae10dfb6694bc9778a1102bbbce8c7fe544dea533e53a62ba76cdb6041640d5a2df7184a17cb00a4931679ad4f82922c8c3e635fbda8fe8a494934d9b97b7da4667d4af169557dff622ad04edfb04d4c717190415b89f0c505b4b77655287156fd84d6dad9e0c20019587f866491ddafc89d79898708ee9be825bf61e82ecdd42dfa5509baa777ad8ee11729457d85ac081f3d6fd516a8429e76159c8f5aeb96aaa2ef4ddfad093c70abf8c2e46713ce261f40caccf8f01bb72243eda8da589155f08f280203c3126fbbc8e291027b00232a5633d3ae9928acd22e098d40dad2f77a1b6d2e1b92bce32955c0c39eedc08ca04aeec9aaabafd059753c9ff044c1cd798d2cc59202159f4c577dc30056fe2a6e6888a3b872cce20e6433d954a8ec9d2192998e120a5aa9c22ba949e2edaa4162995e0639372c596f0f8ad687fdb4068cf65abc7f014bff55e24e5bf2b586293628f7d1576a0e120e31a9acfe81c1d21aeb8cedad9c7760e7e4c490f5bacda6655b75ba125e56b2a83a146d4d7ae15d1f5b6ea1cfbae1c3328aa8372c311be5d8d90d8f0eead1dfd4ff6e6fb846b44fd0e252708d54bdb69ae27ee583989a4c9163a2eaab9dd115fc53e7b4c134d837d56cce48769632c0981809c18021ca77454f98795597c02cab45651ae88bdb0bbe3a0c25ca71eabe400d520bc42097ab644a281d1678c0e23b8147fbb1c41123e0f629eac20ba3d123c3604218e8ab8bf6484ef50bbeb9acc0d897069afed1bf28c8e372fa2bfa6ebfaf0298980b3250713587f54846f6f1d7614cca684d7a5b49688f5fde079ea0c91d8da8d5a272bcb6e614a401b4a2f826b6dfc5d976eff63e98957663134643423a43deb349eae75162bca0d4007ea899e190ad7630ff22cc061a3d37b8ab1d2764d9f38e5c1730dc3d79a7b59bb93ba5060f4bd43e813e04163b2566824c1d6e70f3b2b9b54b45a7a66a067e1382705eb497f587e01315292f14292236d0d0385d8d7f23b0a39ed25085fed28863ea35c551c06b6bf559b10b2d7a6e25902d68a808af2f6d8ae68043390904719a92aa55498c0304cad8d0e00152229ee101b57f73af2743a1ebe98759d4b75157a3bc335f481583b93afcabc154696289f3bc002ec0c36453efb88317ae32f6950c63eeee3a09f19075e81b29855d331a362096d231340475fe203cc542e4a2caf3dfc2c7e921e0d9958feed140cdfc2c63bada965b48c0a1843b80833906ef39b7b9e11fd8805d299a6431d9b047d52991c3ab873fa9024d12372c56feecef7686ec664579c3260da1a7c04afddc5ad94cca8172b99227e9bb1abbef631ac4d57a2def82fc7c71425e76fc4a5db24258dd1156f6530e79d1cc60e3bf071035823e5e8d2b3a68e0a8896260a368b39027ecc09751b80bd0ee6b6a312cadd0f7f9ffd73bcaa22ebfec82f66a6ec18896ced94d93edd8b40947a43f9409fe62cce65560978a5a87efff312cbfa3b290a80203a3a7bd2b09f6580c3d50b3475cc537df4b0ed65def2d41f03c4cff1fbbc50805083daf68351ea821946a0b056150dbec8c3531b6ea333fb206d9448ce388d32c3c17b640dfa908371155e09ed11f7e6606330b83e3e9b832528750fb54557169d5b58d45da17af89dcfacb5ae7cb7cfa97329e53b527ec00b45f74aaffed81163b1cd098200b41bee931ececf14406e67f33a705280444e00c02504bf3e5b99b61efdb3f1fbc073eb80cad600ac7a3527d5d846cb722369eb0b626cf599b71af4a907ee99ff2552449579a6e63b710a11efe9d49bbb2274e5a01758a39a4c1ac03dd17269a47290390ed844619cf6c7d810d4cbf32ef11ecac50f65366419b08c6ed54b3b647e98cf88d58bb34b708ac665351fd081180675e50acaf87e338ae62f13ab4b2725e48a75c0775637e71d0076320550132180bdd8b3c0f925beacc0c631d6bbf93b3bf0488fbcfd5994f66c436492c54fab1228b2b32e7794d660325f2b2341ecc27e88f76de1c46e97fa0297ba31f8eaccfddefb1fc54e52e2554d3f550b5903f41c31d37205d364405833b709e51fe215acce18e9a43180c1c0d8fe069c173a846313e406596cc317433e8fd2e953ac4c4fcde193a63eab68b58ba6ceeec2bdb413f4f35ca95a4b85833a434e14b4259a845f665f6bdad4a6fd1f934f93e5c7534afa44bcd5b3a3009c77557f80d30a1bed9978689e69e09466a0246721a1ecfbe12ade5c5256488f6c45b59adeb4a8462167e109b94ece72611e44848fe4902e113f99ab38c9d613747408875574dadf73cda6c10fe039578b2c5042f2b76d717fe0b23500d6fccb0ee6343bbd87bf57bdae9141026eda779065c51373062e661dd85cb7088cc86813d7eeabbabcb1903c188a3b427479b87194a0092328ddee8d7111c2548dae2c3b9e1d190beb04eab4cdf6fc492a529588c8743f0b39c23c685d806dd9453bcd2ff91bc3238a6755d1985053c819e4a7b959084de13eebe8283db5c7f43b5400904ce81bd93caca6afe5f59ddb05b0ee3deb80601889a3e6de526837052e26ef6c0fad9f59aea900c65d2872ae163445cb8226e3d7ea369ce79fa1ca3afd2c58618338c40987d40570fe6a3b4862622c3444c4646bd674fff5daa1bd2646223f531ba31dc7d14544664511d92cb2f7b944c722366bace98ee88ed7b407fe351f8619223b8114313dbcf7014e9155e8d34bd83b45aae55b9d0d335a51cf6e6be64d055a0fdaf85e0ca3a0f51473e90456aaae174e7cb2c0ce6015a1ce6fbc65170f1349151d9210e6ed049096970b37f0faec1ad958251fd9481b6a4d615cee6ec5a13a4f3ffba437ba55bd8e217805a802b210c14de6b38ee08cfa94127102400502fd527cb437c0276296f5ee01db44f6ff51aba7dbf664df59d737edd758f507464fa1eee05eff80b4fec0af38975701c361de5545f87ab3f1fbed4850498ea79c5b9a6e752211764e092c6d962406d7fd7d76b30e5dcd2d2e8faf63a8d22a9676c90dbb190cd42fc6b44a359d4746b6ea6be826d7d969b619633521e1943fea25a1eef1742e3aa2a71b9e769e57d4d979e4444383bd3c68aa66998c8fe6da33d8ea0485b76de64b740a949eac6e5b7661333442cc11730a25a4f0a71e5ef0870fd58628fd0e72692761f53aad358116bbb91481fe605d69eef76718233b3cdcdcbfa452469b572b5ee0126b5649486362cfd6c96ec04ca64b2f97882deb36fb2b71026c40346921a880d7b17a4f709ae355b7788f69006790112deec78f2fab6012d11811a283b95622235e2afd2472c6ecfe10e4f94f62b45d31229c55b5bbffe7d21497117b9dfae6f31c97c9fedf71112aa6471fbee8715cf5cc5e7a67f8d5e582957c4101c451afc00c4af470e79d2d29499a836087a883631f479e49087185750b2b9fcc6b0e02972c72163e45e52f51555d96fecb99fb23a09c27d72a9f05cb9abd6ddc1e8ee7361f9214aaa7b59dc9f31524b6e4ffee0259c3918b8b263937e2db74006b3717a253ec0e8dbbf8b3fc4fbf6b7f0e964ff91fe35cdfe2d2e3676482100c1d1959ef7ec358cb329b4742268929a0bc3f7633405b262967a99812c6d677a9fac0a707c8f571d16a01c64d7a6b1efd4a7e4bb807077e4cdf18c21e134042895d591a9897e5af376ccc19ed1573c38be43d99b53244e38dc25e92def8549207180e2619c323acac0fdaf9e30cc3939e2204a947fe6ac0050583e5cdc7f3ea0088b4844af88bd38fbce3f11e5df321c3742c70868c65fb142515c3badda4681462886a6319166b975def7b80f4117bc074d5a16da18252f17dada9a1ffc8aa5b04263306ac6a0b38387e40024e413c9bb9733a064c36dcd322843231007b25b15a208aadd0b90f88c3311acb243440f7950b2044e28dffad06a52a03c228e2b724cc38bd33b41cf464c70cadb44bfe7947a62e506cce505a788fc3f2ea2c396eacb3f19948de1733788cf1b48ffcc527312508b5b01248e7699bbc27149addbef882530587b9d78fceca2b03d5fee797164ce833603e13fd1b60d7234dc414406cd8e5212c1cecf2c5881d764d7382f82692aac8260ed6a79f46921bbc82ec40a1f50d1860177849be6a286d8f75eba12b05e40303fb2d2dfbcd899d0c54a0b801c8d23e04cca7fa4f6c38f1b1eaddf22a368b745303155636007f57979516dd8295305c766e1df77a920217869c6254aff1479813afbbc96c0cd16b40d501cbadfe5e09f8ed4681d3571e4bd77e5d09f00d719ecf251673a10a7d6e864ecb96a63dd7f602a0028e34eef9fe108bcea17b0162f176b8ee0238f3c23b43bc43149dbe2b8ff18f50d18dd4a48e3bf178886fa2ca3463c58cdc001c27b80910abf6f05443a17bab7e0f191a80ef7fa8d78a850801eb465ce285306a1a6aa2f302325a7d65398a49de1b1e80037808a78aee2052ca732874c53dd75a4345760a495933141f6c5d964d5ed678ad04d5350c5faea6690a824f6482cc657e048a0df469f215bb507474e6673d67fc469a554e16e3d76cde31ac10962c6401f569ad7f0db92926de91f80be5c93e8f3dd18a4a3e58d5661ecee530cabd4de533878b1cd47b1358115873532d7b70ed405aec6df4c63712e867e1bccbf5de760db474fb62598968673a9f7a13ec2b8aa190ba94b361971906d3244c1d4b60a21bf2299cf2453a4577f25a198f9c50e2b3a43c31de2cd7b490b48f29a868ebc68deec0637e5e3f2c38496b891710e1e9601347be4151877f429a78be49b89f63f3681684d725f9dab630e11ed1e7dea3c19b7cc42f89e193dda3c278bf1bccea1c8e37778319c55a52af1d29f9b13ed4462fe0b10d00bfeb6e90413e997e198401db596e843db2ba9be176ae142685733bc590a34728ba72a96c12130e4639ddaa7cb10990ef4a3fd3244ec92bee07c49ce2e6fddc56b0dc52bf2f32341253d5f779fe61227a72927471a5021b67c9eb12bb4348724c3dd79f8b015977405d6d260d8502b814f7f08cac5a2e867235c520a2e81d8a26080f9ae348152bb9dd2a096af9739716d4609818e7f5e2a71339c473c9db170043c7fc02ec7d59f531d86f0880838589ca646e78bda4691b97a584937e29000785943200b7cde339e75c5a7bd1d5e3128ef98ad9101f1827692b5a5a514a11d20c1ffaa2f37b9bc237a7570cde21dbad4206a482b79efa883dcb9f837f1a329dfbdb9b7938631c2ad3aab89e0b6166c0a3e9caec7e44f830a361a2c1b97abe5f2ccbb68df6fca5691ef65e080365284fd54ea5a6934a15fe8c7dace3dbf2d69b8ba0034ff88c46c1ee5cd733e5a5d230bb2350314528168b66972c146a773e8d52b52904901df50652ab06ca1c2a7b56a265ef76917501ae82bc9fd1820c451ad19a4c20b7792433edb08bbf59e389f828362062a8fb0c6853876b4a4eb0affa096ecf436e6c1ca02bdb0745e796888565c03ee197b81d76245bf7e26f1f8523c9e42398918b88695d506b48cfb7b4bebd887202c026b51afbc176cf723243a6e767886df5864599f1db9dcaee33d26c5811f8afc84cbfb500e52d83b709083b43f5b6455a881a1dbf14436b547044afb97e669db58f3a516ada040601deedc7b4a3def70e98a60e2b3482b8efaa75c85a4df0bd600403760f417b08a680ca430ef742b2ca8e251cb0617d08290fa9c44965618354ff7dd0136baeecd3d683500130f85e94b05610087d483c553a8fba2a15c423c98d29b278dec80091a628d8359fca86e1a3ceb101e562404dfa2e0050d855fc948d788837f466f67628398ee8b0045df5315e90fe4f58cff5e7e7c4662136aa76b510a648432e8cb75cf4762e057f41eeb6b12fac4d4843f93248a61a378ce09a7058cc7ecc66a822a2e7586c047006ca555d8e2d698652505b0eb24b8830c1a39d14169d993a86b4a743c78a29d9927eefb49c54aadd3d499d89a8317782d5dac0d6527fb42201be7c6db4b85d763b392c2c19533ff1fd6174cf8642f5688de44ba557a79d39547f4e786162fb192e215c5b1d58577753fe20e679587abc5f18cf376cca830489bb6a783346ca3f71c38c80e67c421f9bf931a49c166b44d57f1ee681c0b5cd3e3d46aed9ddfcea41cce1b4ee469f493cddbfbf4a7f619f47ffb711c09b45a7d01b27923cdf7054f135d38c6a39aa8f80afcb71449b3a22b44a7ebf6b04ec27abb68d4a2ba603993657196e7a79ddccd8fe0d197fbe6a42588b583a4c6808aac4720557330b587bb3abe0d995ad784695fe441699b57f94712f505ffdcdfe35915db28462741ff3fd70f21eff0b607c85a2f70c987513ce372227faec0c335796f08153ea08cb029df9d224184be7bcd062a1100d203744bcc1158ae39c826b90ce4f12db9b6086959d23ee704ecc85dd6b82aa71094c1e5c58d4d30bccff1633ae756013be539bbad3208676171d54e668a7b55c641900c22f9d88dcf15d55196c6b10658b94570217fb3e0999639ad0293a8083fe33dfbf42ad0d93d5e7a8c1497d303e35478e6756a11371c83200caee4851e1888490f9829ad51204a1cef06b0e52d8e34f07d197c157402896394dabe40563f820ec718e6936b72cb76dd60f9b4ef2f1f18631051e6c8cee3b9fadbc8de7f079eb95db15ce46bdd320448cc72ff844081678c1a7839a62299a54b887a7522216c7786454c883cd08235878193e6a0d652f82ad1985bea638b82f7b595ce3d3a819283ce85e718846bac794967f9d8647e344a10be30e427f1325ac095e2ed922099a8162c9b33f72d9da1b55dcfeec1eb662c17d755d01fefb809714730d92eecc2579ec188474d8a28ac790e33b0ba433105b57024f2659d01f851546109aae282e2f5ec98530acd3cdce6d63d580c74ac4e926d74a431896b98d39c6261db6a985d179b86ffac776501aedcffd2b2018557b13be558b2ce14ea9b712d20b285f14a5118875419034c57383c3a29bedacd714d56bef7f826e35054c1810df7ffaa1065964103dff176e76d8b28d95dbcd4cc592f42997c091c2618910066c842635fc1d3a091b1436eafec85992de565ca593692e1e0950328e30df0b258ab72d461bd645dfa969f945b002376cd67bcc6869bd7d87b5aa0e02cf7ee2bb957ab67a268caa60cae4456b76b1962c09219de004e2aa172ca881d8aef637bb516f79f8260691cecbb2c1213f0bfa31f5d47d394b57b0c2d71e2338264e13b9228363342a35210128d5a7c7a1230b0854ffe650bcfc70c79b64c869ec6e8baa5c502aae8f0c241aea43d996afeaa6d7ff5ea998968924819cd7ebaaf06ad5c1dc37c026a83898bcfb64029696d3397351d1ca6057ac418bb33a80ab7a634c7b9cd353e3918b77f8636b0ae2a4f456f3801f4d0d82cba0596acc3800e0981f7847d7f8215ef4f7d03462c8ffa6a7cf8534adcd2994172a0345814d05f86d99a29fbf04e1c0e959af2339f6c7e38b7b654fd03386e8fa83dba9ca5082982cae1a7e7417d1f794d9f77f4f2cfb41b2504587242ed8df79703ce62a8569cf5cd0fd33bd61817dfab781ae5d43a7fe9e26bd91ab7af586aa1a9768006252e8fc7b9e6cfb8d1c74905776bf50220e7c4f6f65b8b68581364f107b82e069269b5f7549f63772a1fa088ed94e7fc39479921c17fc39f2cb742d764dd6128b51b0427c81d6ad137ea8b3d335a250c63b88c3dd3e6f87979345b54c4534fcd3436753d2ae32383f84c6fdd1e65fd48d6e192c5dc77df0cda9907437bdf995df906ab49a7b2b99330cb1c5526522ff532a0f54a073cea4768db8d075cf76a0f9ad290f61b1dd16d9a9c4ac9e90f71da6b891f4bd10b7b11bc9e8cf3ea1d861cd5abcfd1ddd6aa9103b3e9ec8927cf34407b562a8fa0b35151d215d12915a3668f7d1360295be4e7867f2b4ccb9fdc35c762e94f81cd272830201a59c2f15cdd32f2e8b2036381978b19ae23214a9d904db315cbf593b4ec3fc0e6fd2174ecd4ba99cb70e934de92583db48344d45188f19482f05c2d0f39118744ea9aa6ab98010eb39fbec27f3ee2e3bc85324a8bf26754b88cd7bcaa1e578beceeefb391d950212f0bda95f7b7a188ea20922fa1380dca65","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
