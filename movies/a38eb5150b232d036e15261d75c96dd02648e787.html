<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"690f836e10a5a84d56925e0feff43adf7f85e251893924c0d0e35b9c7d1a4fd55bc658dc50384952e4257874bb198fc417579ce460baf23a930db677a87851d5b81e17a7052bb93ad5a1b5f93accdc0f290b6dfd7e172e9d728673b5415614aff465546aec32d6a214181a697ee140756662f31fe7c0f81fe735d323d28794bc8b647f882db40ccba26e2c5bc2af466c9873224a1304a51fbf9cbd88109dcbdc1d32fc2ad3e6a22123bc7a9ff8f452234b45fc229b088d710094848999cd55256f6cb65969e6f74fbb5747883f6c25385f0e7f0e69780b945b5258e49587e3a85d79abad500986339b248a01a92e614e447cb342fc5ba9a78422afebb40c6246066b4881da5d77341f802fef574243178f1d3666167c70b6633282221c3162107503e3174c372fb05245982f168a57670d109f2317b69881bb8ae8cee9ed26439dc9a7f11448e8cbda88f9e358835363e4acc65241d56b1b52d644eca7cc1fcf704db5f7323db70afe89342fe75575042d40364cd1f3141ce84284c97cac6e59291e62711414a047cf000297bc810400063172c142b80a2872b2444b56842147759478cd3bc4d413ba3eb6aa78cf2ae4d874ac727dc9e0c92d15b74d297fb46846fbccd6324174e5778a75cccd4209041e9bd4a7081f80b8f0c4b006e430dce5cabe920d3ac061fa680cb881cc615b00de4e1b03e1ecf0f35dbadece9823877310e819e3a324c921875b4e45248f9bae2ef3766cffca6ed4e716a3e25bd1d49016cc8d8e5b836eacd08cc0e9887dc5608c7b7f8ae25b67dde78ad81ce7ca98d9db4a1b025b89c1be2f94f0caa447957b3d7f26174d2f3cf857fd58f78a8a51948ee82153dcb459f380618268638af7d77c8d0c6c41ac60600b06ffcfd9c2b0ddd8505f0f35fa9f48ecde89d98e9442d50f0fbc2aed1a6b0631ce8331d229d31bbac11db8763ce32cdf550c511ec3e9490889200777314712e19bd197dec091425a16f158ebd05a6ec3c7712cf5373c668696aee1875235feeb0399e81be1f5639b008a84ab5be6cac4f068b58226e89478deb358ec2a9cf9ad5efbecec5766351fd79785662661e66db85fdae0ad9c5c00c8e69488d5758b74e7b99890c94f5f83358152315ca9d945033eaebf5c24f8aca3340fd7712b228a43aa4ed9954e9469bca9b1459a88414ff3bb16a3cad110361f846ba338b1e851f7654d06668cd9734d22adadbaab601550a4634e9fd5d46f603e296423b139f3de864d9997ef47f0c85829d784867e9826864758884e63c815bb25d9dc299d4bf91c787ae272a8a1cea68d1716c555e32c5acef9c3819c2053745fbfe11cb93cfac344757777c3ba20b17ff014ec6a131e121a989466d54973eaf9769d8dd096fe0220a0df189da1ed2f6d0f38c0f4612199be5b0434818bc32dff61b89974a39b7e92c571abbbd9b882e31a85c46d0f270c476036ab7bd9b44c8ed1991342e29bb58547d9da734a554c779cc05a70c69aa34f3e414bbff69b9301a0eb3863fd470743e46368052aaf4a7a3c246ff8118e3d5439bbc3a54814eedfd150eb70b5da19dc4fdd615e2d83bc16c2a05237407f469db5627fd010a49fe82bb26793492e687e712a75e89c9cbee420bd8a0efbd87af7cddc2542934a8a0c9b9f197dcbfc4cc9e99ed36384800c403dcc184b550f12e004c61023ba31d1e4e6d115d217e540cfa0f797dfee2301ae82995df9d2a0c705f9c2a5872314e7b8f032bd901f6ffde1c0230db7008651376b63379a59fb40c1246dc5532df584f5448b82bb33c2754e6c299be6fb1847ba1623a732224ca7228c33a491f4ceb30abcf19846ed177cdb3f9f7c9aef47aac525be52381bac5719e93357a465199fa875e8922b402f69c53d74412f11bde22e4e1b1b5fc257918e0c2d76100e126cfdb18ea5100c01e4076b7defffd9cc8b70531a5b7dd2a580895e078aea268fcd8a269eb353a06e4de876adde6afca26218da825b7219e2ca3643c14e557d3f520f18e0c83a36b68b86a9af34660752113fbbf23c841a5475bfc6d3ae09f0fc40288d9fef102fbdac1da87a63667bba0e6e829b95adf3571f1f432ff7c7e914c358044dac544e18f9ff4fb41cc2b689275a4653bb58911273a5d594ed3eaefdcf5d5c6c83905c1aeb35aa9e2313dc0cf067a76134e3357915a398183b61958c1b648ae1d5f881a92ad2fe8e98a0485be2d106df992a1150d24c4b8a3ebaa1646a1f23b77fae9489b593ade6d062d83e1346c5fc1c860e9a0e9bf540c39cc93f1861953499c2e111ddaaf035d13683251414d894efeaa708ab18275844b36ee8747620686bedc3e334644f7b6a2a5971d2d517f3869d92177394b3bed7797e3b1b8d256531097b84545d844be39368537ca972698f8274443aa1dd9db44e7442dd8ead85b1bb8f786f449f4e428326d2e9ee1b1512d8e913c3979885a8b6a02067adfc167f372cbc8b583e218a1b7992779045d5f8cac2ff736ba97128eaf0f1db03d7362fc826a2aefdf2dd1d052e04e990955ffac8fab5a78106bf3e0ad6c4d4e0191efaa748ad4374ecd0b00e8bdff65ef1c5e972e623162c3e3bc4a8abc14944fa22ca228283b1e17f7b96744255022b4e2a7b859bcb41aa545628241e2266bda95cde22d3369c469efd335af7404f9d045e2692ea203d88b455b87d8f9488f1a64076957d34294ae84acceb7f5533c806570cafa5513bfcefbff107c1a36ec75abf368ff7dcffe56508f4edefca4b9cae10353c1a9100c434b0cdb8b0abd9981c876768537185ed71607f9b0149749622f7092d99029aa2d9a0195cdaef769a18d0ace25f87d71a1ed638f4c8aa4baaa692d7261a2100062ea9b2ebb0862eda65254de39a9070eb10c890e6c574f1694106e2803898355d4fe8d8f1bf3be18da82997f741a19da3712186bd259c925e31a0110b79db24929faedc7588f61f35af3c75bdc2cafb95f950ce6de051c6cbf99671baab25b133ca51eb3be23976bde5319be0f474ae63f1ae6a944717d0f6303af01d3c97d68ec8b633d70414916b2bcf122df1c16ee514dc73559fd89ac37a428f651ff2c5c843296c8d49d0bc7df3b1b1ad23a1554294d199f38a352ee9bbff61f667d5ea1b7c35c05e30779e4d6563c40c29a60c806e1bf865a880e9c07956a8e91b1bbdd7b7a5f3289f38a34f1faab9cb6eb1a1f310c7d60ad138eaaeac70a4a902e8fc51588001554eb08d642b25b1add7b3614dcd0b7b459e6c9a1075fa377ff57ea6ebc62342057b729b82e830fc2dfd2c86b175eb095660deb22444e2e9aa61c34178301a73922e41aea30999a1b2943883c25e8b9b745e0ea47de12facd02bcde26cae28610784f38f23545d78be10bdbe02de92d8e0aba81a807a4ec3647ebce8f2ee68c817ebcbb5f90ce240e4d85ed6a2a41c758575321eb6e3d1b0b0ecdf2066c1f9214a5026aefb59a55c131570cd363d790fae2307309450ea9ae6877750295d952553753da2349a8934199adc5f995ab3c5107811be62c31aa7227ddd74b374200546598060442102b501498b5fc74a727031e36c1ea7f9bf44a3c2d874df991a9ef490ecb622c6cb18acf919ac9e59dfe665085c1d841a2a26abaa091442a1e57254d6d69523fb55e4445763252217883c1d1493f754f68ef6a1a4c732ff0465c8627996e51a05758c37c33af8dd29a687e9f9df718e64cc3be20a85f7c94db0e767b523e56c3744f9f1d738d96d2dea62c3cdb74b568234f2c03c7596da20804c5488b8abf497e58a0707c5a4a80135e7841fd92eff286638c1f8cadc8a917fb85e977baf81c5068466ae3484ce741c4cf9e9a6dd252f8196c7c2eb6b207d2ae2cb3c0852d1b9c2ab3f2a52db22c0e41ceb6195377a8bef21708f1d398f5745d8c07863afa9dd048fe81299254eda5b2e0f725ef335ca99193a7c3201e8bb572accd5b5e17892d9716db4eba25f31e011bd4c08c228b3560cb0e5ce02476902831433a643e098a8c3cd177b811ede692c72b7b218845b7317fe212bdb82dfd09cfdf7f0bc268af31fefe3483a01eb4110b162a0fe1eabfd95bacd7358f1f82fa7d4bd5f795fd49e3d0ecd775b141733e5af797c498c9cc07cae77105822fb99a870afc33c7e816e6877784ba25a620e9f167fb947649c37b0498c6f1de8a778a6c0102f6e1ecb833360e457c84753931ee5c6c0abe6a2a2d67fb04c6a17389f9c8f565438be6d89f7498143595c65bf032b5f803e0399e7cd221456c79fb4e39cfda46c917c64f2ee77207bc565af849ca6a0a41386146e52a6e7d1304576c7bd16359648efc856a5fdbb3ea9a4dd42086083939cd336bfeadc97abdeda5592b68dc94c81c13730226b73f4478b3aea48de2ce4e59fd969929b0fa558dd465ff93e66fad0866c35e7faf1be1e93dc028f8b7ab7f4fa024014ac2fc1e066e18ca5606b2e651b944b8e9e2f4c98772e717ce8d5bcfb9cc1d7c4a776457c066011f70572d6bc12d08c4e9a68fa09b2ad06bdb595614d8d877c7620920bba060f4f1e1640bd0e0f25b0c4d416ecd1afc0257167907ecdbbd7e73294936c18a85a40122943975521dc85ec3f8dcea1d8351ac2f50995d7f762853027106e3b0ec43b0b7d41e19b10f4e836449aadab0779b5cf8fc6606b6acb332b624c629139a36a14e5b1a5406858b782464162de5787fe473f8de33089a14a8fa88d1414c366e4ca80ba3d48cc6727209c4a9b64b4fcef55ed1a7d7e9b30b669f5c7c362e86689ed65051d36b55ab7738e24c925b7a8d5b45b2afaad086661fddeaf9dbb75ef1f18a0129b8b34d36dfb53fe761b6b4d928c3db50d35a0465b9791f1804107a11be99b2818286c7dea6a21ebdde56381d3ef69f2abc9ea6ca4467ea7115a54aa33ab19fe8fca770d7ad208d65253debafc80215132a96b0fbfbe3b89315b067f3cc4b8be97116cce5dd8362af1dc0bf2db3fdbf1598ca75737f099c6f6dd19d392802c2fd5bb3c47c46c2be70d54c60089cf2814b5575f8d08ca6819a4d4e6e1915379d633f4f3a2a10814ed5ad78ab0126dfc24dd1e5c3a9bbe215c570294307672668d6d4283a570b73fbf0515ab2d0fe4ffac271819b1739df3d632b8baebf54a8ccec07f8bcb8a62db49a6252bf4893b2aa601b73a37c640dac1d6cf8e64d2c91112ae4904769779f43fd90c8f1b3282bd296ea7eeed62c52b67081601212f0dd2627567e7b0834bca9937b4e2ebd12685d5291bab43575fdfad94c6b9416913cd266f2cbbb36dedf234ad54031f473a7f6ae29d5fe66bd5e9cf58b819db442bcf79bace78b57cc5818d7f302e3fe584918a94bb2339f3d534593d4de9d496eda3c221a8874447e2aa26c0fb0b67ef2b09448f7fb75c7702327ed61d6334f395ea601de4895ac1f949d7e402933b639b53bb1f4c5d0745bcb2b069ce2cb8a816bbc2f47da6741fca8d8b66beb385bd2f591fa715dae21714a112df706c3f6ae705d4ab08bc59de93b19f7a6cb2d8fa1aacbe334dad173e7fdb9abccc34bc8c0d66e45f299fe5cb6f63a5939bdae65c01751e7eddf2705411491d8919ae937c5fd270ed215cc10806588b309c7124e4f2a1b335c56ae8c74c3bb3f7ec2dd48fbcc0888998bd91547b41ed4d91f0b1ff5593aa522233ffc5373e2ba47180a3c6d0d75fa5ece91bf2a937dc57021e0a7a8e4927bc9fbaf3489cc1567f390e9959a2dab66e21c5874af7ed00b6ac7b4a5e9ad8cd6f0ae92b3803d1e913fcebc09ea4ff6233c74eeab237bf829fcea8fd3e42d49f7da049c4275528e1370a29dd7315051084e73a9118cb1ed4e7dcafe15479c572622e1d530218e3b575bfb5dc4d42f920294f6b799bdb34fef5bf0ec22ad0e5e560d6dde92212bb2a9ca4125c8d98edd2652948a10347d82af526c98f249795b60cb2ff7e889bb3dd1554da393f90fecc9857bde6744f2829a148daf5c26dffe5a12c92db023f4588a5492b2cd5440599cb491cffeedfc94e5d1c4e62939ec106bf70388f69aa5222d7d152735adf52e18eba61d5cd82206a34e9a9c238d0170308490285b9d99efc6e46ac015aea8cf72660df9375c96b6503c069b640c7d955776f81bd3597f7eef529f2c2b4f224432a2ae0cecffd43dbc3e0685ecf83c996d90ee1bc7ea4ee71f9aac201eeca49a626b743f91e1315dde50cfc5fb80801ee959f935b8ec5064674653d78a64d9ab7d7f3953a650e77071acc990d6e1a0e685e52fad3bbfe072f3e7b0f01df67e1929664d6aca9be8b00a8db25f0b94c59f65c525f37b47d3362b91b1bb8d8d951fdc39d29db9521ed6642ec78b3f79f4e5795e3a6ff79c0c901b7b9046927cf92ec72116fe80b71ec3864f0a420df8aa11d8acfa90cb491d7a85fecc9b4556ce1639a4e0d0eb3c21f9af636d049877568b9d2125e0dd9e7dc72d2c052b9b305fc95bd8d5332bd745fabad79a8d01991ac9ff324ca022c48bceb362b2e2ad85eb9585c45e990122c660c38789faa0deb61d3dbfe9f79353efb7bf37354c6e5ca9d425a0a43a3228c5b838d5451a8b93d91988aee720c7f5daf13dd22a399bd82b811a99f8552d06bcfc8a58d386f0983b61afbf4191b5944eee3d2113bf1f53df21ec786b2a74bdddab3d21f997fee4bc8362c902033fe4cbe7ecc38c2a0bd7006cc8fa8c2e1c1a2bb34edf7ac04a5b3071a8cb8f6035b7ad4d76e4b33222ec7b1bc996d6ef9f3f1e3d2f7e3956abe0209c3db39e80e0154a780b1976d13f4ca6fe6df4bbf791de859f723822f62bbad4653d08473c36d1a37fff85fe2019cc92420674bceba5544062fcf1d2011ffa342867b21de9c623e5fdf78d97053a80bdfdcae05075f25bd43313c3a31a510f247181d9f2cc81ec877817e07a552fbef4736bcbdffb816c64d415dc7e753a0f154ba5cd1374038f31278c9dbe39b78d960635d892ed96f0db3d139e8ea9c837716cd468df035a36622bef13a2e47f2a042eb11d076d94a5c59c8a1bd330edf8751f5c31c322f8c3abfbc563dc13b569e8847b95e3011a0bd8588955bde7eb6fb9c47c42ed36e3b8648823efae5a74c1b208ced7ad5e19276259c1d2939d735d09d3d954e9e0ea3a7d7e16b9ff38b26e14725be49dd99998995e87ca8b9222a22a89ee06d2bf9874736e54dd330ad8d33a9a39ba768366cd46050e86047c758b55f2b5a274b09126b5cf18301e576ea83459c0f40f63ebc7d1b637b70f7a9e1008de97537d9b95404d1cf54d9f8e95ab4f534a6c792eb61b58f67a06a0d55c553e0d0a185f1ec20e267b89ece58ac409efee1abd52006a0175c967a8192aeba4fcac66da00bc0c1cf6fe50656c5be01f0463edcf7b4920a03909d74406b4d1fcf0d776b1ecb460fa21dd3f1187c9a7d4ed6ebb712f49d7fed97dd9d0fb9a14fa38eca42c80b9aec7e8f4b45f434a9722bec438dfd73c8ca0b05b2d169cc095d4f10e98f239939c90fbbd76dca4a158840aaf96f8f12a78fb35d3c8289c2ff3e2ee91146a177088403f1620563453fc651dc265656efe6adfa8480d0d85436cd1f156c671c0a34fb16c0c6904cfdb9bde41938054991350aca380882c2a78b2dca135163fa6181b56862083c570ed5722d639d49b351ad22544b5d44ca51ae03c653f871683f79f22d0ae855b5d1346958d044c2f3ba40a0b000c72225ad5cffd3c3b493a244bd9b37dd7c93399308ef34da647b8b902a068e93d4510a96b20514fd37a86a0763bc77f46346dc0f7ef640754b645f5070a742f07a5d8f53804ea0211e96be4025e66e379e1fe1d5100b96cb4b9c9cd8b7695698a1f8829b5d2ea19c945cde2e285ee4d0661923f75db38033e23096df924fdf1761a7e1a5aa7f53f1d0841ddef88d58ff70dc0e1c1addfd43223004c83a5625de6002b8bcf7b73f7c1512f695924b41e7fd392500b18df859c2b6ba0fcbd7543c8bfdde1e05c133f101719d11fcacfca95be17b37aea08f307d1628b12235b3f32ca520350934798c77602fe2f418459264470e0f0e51fe979d5c9a200bda85cbd144a546e31abb84ccb126230fba4cd59261403925d3d437b7191731d8802cdc4ac4d130c93ce91ba26fb1b292bef650fd54ea92fab7efd94950e994d7fbbebb4fd6d3eb994b1b58e9d45f7defe73d4c57ab1830a8fb988b142c4b42426b88530b39a70db50507c33e5f131b578df11a75bfd89037565df8d828575d986fb2c856bd04bbb4c951c6765767111ffece794efb49b70798d8f23d8dda83b9c0619cf2cbdf513f2ed7cffd4e52bfb0f8ec19ee48395b0d2e5f86b5b20f1ae06f611feba091a2be9864a2b980fc0d35448524719b474e5df3b39b8a6dd18d4ade21463eddca2cdb9d9fb06b7254eb41bf7010d2bb68e63435be2256d8438beca0b3f4475b6736748de2d5e4a83e53bd5b55783cec8ad9ca8daa6656124f4700aa6bb0e7bb3878f28b97197ce4d32cacc8cb85e8afe5619cbee4a193ed0f2ab5a8c93606e002e782c740708ebbe207d9f5133068144cb3b3ac5e5a6b5107e7bb3de9458b743b81c78632071743946e692e6d3c1d0bd3d3a201ceb07053efcfc1c1d0970bd99f6d4ed582419a2cb36d9e0bb649263056c8522275cd3b6240565324bd2435f73d91a8208532d192174af772d913a965aa76b51f75f15937b1a8cfb43002a70d50770f304ae4fd86652f3644cc9ebde6ef31a8d1f2a17b19dc0fd32af0182756a6bcc09ada54580842498f34dccd9a944d3406d51c00278455ee1ca9a550f7b6b27e4f0cb65b0f4f64be649d5b501b8d8fbb440a9d32955649aa1792ff53cfa056fb30e96743795672a099e02bc2ea6c183c9b3fa41d6e49775ccaa28f39ed9ed9442d8fdb103eab2b7674b80312bfd8c248b37e387ecee798316f9d085041620ddb5ad1d72c330288752bfbc4c4c2da272f01c13dd7cdb0e0f3197800d18b62996a00fc0454761cf86b963f6482f1584d4009f7072e8669dc599b537a692ade832370ab601e7f3b0a3e85c92a3479283a9bc17cb9b0994d2f8f08fb79416ad0781e6e17cf9b944ffb1fd3ea08490e3ff2e689b4dba647a3ee4610ccfb68804d223fd6c47d8e19665eb3540e2402a0bf34eb9c7b52d0c54bcffe104a46bed2b89f78d7683bb8106c42f19730768eabf6fa408449205644cb325cc69bb270829b7027ceb2137abb0d036d1aa21ef133284e615d1879def94cb76d10984dd584e5890e4c0789ff2a07f0be8338178b4804615625a0ff4f3accbc3c7a17de15fc8a44107edba45e5ba007a3e303389769e3ab52d6e8a9ea6697cb55e75cd2ffc8b825779084b7bc43472c65a67b78f20fcfcdad5049046a8c5eda0f8ba5bd1172cb2a4f9754ad4a19d51daceee572f3f698a079710c354cace42a6f32e1c00c82be5e4e54ef5bf0c85f0e2a36b2b6ef7409161e7d220b144eb2fd56927dbcbe69d9fe945d26bd5b319c173aa27cc7af3b4b4b1b809571ace862d8d6bf4f1bc779b7c5419aacbcd86a283b46c923cf7f8d83dec4c0b06b8523947d72c55bb49135cf3c5d5a6aac288e8ab1730920635d58665b62ac4c614512378c2568ff3ff63076a96a9dfb197b83cd72a7f3123e54119cb7f7a5985a66169a6ccac9fbe58af456b40ef1998cc5d10a9d2a525d904032583dcf874da5f3bda6897e4eebe5565af283e40af635afd5b21f44d6fdb7938520c8e2237ce489a86ed6704599d9aa3bf68d9b3c5104225fe27d76421257f7dabffa5e124cdd529066c91e2657bd3c4179114bafa3a67a98381269d7fd0e1f7a5b20a7217c5966f9cd3d11c727acc29f53f20e37c337b83bf25da6f8af973cbe0b76d2370cd4428761bb85fa4c78f68da7c90115294667ee24560226574cca9476d98077b47f20907c59b9d281b6ba26f7d56b0f0b2bbdb933421557de0f3edba3d93819195f9a909b67dfdd6e8d6318fe717c9a2337381adad1c84c37a0c1d34285cde3bfc2aae703461de596a3e6357320a0e5e587ae7af93068cdfb38872bcf71cd76eba7c2ba8d9c88b4259167d1d8383aa3d8d1583074c0e4b644b5a0c60408cd424821cb52d3f7fc056a7ce448d351c988dd1bf1290aa743df1aeae4973070db10713d8cc095b4aac475f2a0f6105bfa602364e86ff14dc7e9e023bacdc780c2437afa1d1aae21e84789d66d5ac4f44d84f8aaa10ea4b1b55406afc71d20cd58b30999fb47406bf23997df1fea53a3e962556a428865c504540ed82d6d4176b245c8bc59fd18603c72d7ada817213387d5fb174f39b0255d1128838d9ae768e27756f1cd42ef5e97be6ffbce5e13594d05e907c1ecbcd74c83f557afe99c797fc0eec8e4b5a893a648db778d0030aeecfbd47752a695e803281f5a269c3631228d8d3d59809acf1cb52c995f6ea986e8b042cee26e3c26cf16f4d2a2713d68a53c4420543f6a95c97874e151094788be67cf9b00ffd7f7685a230854caf668d48c18e711f2de9012ce4a039eae9a0ed0b914979cd2529d48f75c1798e6a03f5fc916a7b77c044a93dc8a8fdedfd3a661c3708fd2ff6f45abbbb707e00a21befbaf3e1b5fc67fa135ca8aa5c2b9e71b088e462a13c34ec80f6e4b615d3e77d87bfc1131c7ce18f84c338e29d9a480d2bc881a174607c81ae5e9671705c7dfff941fd3f644e34a9ed7b528bf49dba520c8034cf12dad01f5a87304df6677b214e1bfd1d5ca555fefade86a4fb89310473c2db6a84d9df219e6e512c0256133c653f6397431b23f00fa5b0d26e3a0349b14e19cbde807bdb9bc52c28d33ba1458d3e7191fe915c6ad0d0651b9cd7732ccf8c7ad4c0f93b6d1e05f26ee1de3a1a10d53fd72bb5d0c75d7e13cd8d69d77a9f86cccf270e7080a216ab72e53eb1f2f3bca4ae027069ffeeb94463abf1365f7dcb1fc69fef3b396fba10a5cea005e710fb5ce4cee50dc01034eb1cde3375e77b921e5520fab470d0230888671da0d1ce51c3e9a0dd922b4a07644782613e9406a2eb9a8c01b1c7b551f3cd97304404dfac7d1bc8de02f52c632993500dadd2c51e4acaf846b804ec780952aa52fb41a090c38b00b5f7a650132c9456a33dcc12d2f1de401c545589d16453cb1f948aa1a5a617e81c02bdab6e3abb0da50bb6f09986878d26dde32468013a7e295f4183c541f67c984419bb0fee0ab362628e21af9534fb3fb7470dca2cc1044436ba8c5aeeea113e78b2d7b8618b0de799cd39e0bdbe3f57dcb79702b670d2bc1107096e51d0190834437287e0f8ac6e45e0f2ae4279f07692b0bf4406d38347a065fd502ccf84d798f5b19e9d08c4ae82554f55ebd1e5006eeaa5d0d19735e94ca1e417e419a61a2a54fb40195c4ea34049edadd069b9dfa484f4d9e758d38329df634c77e4c4b0acf5d0f577de71aa31a9b72f08807633e0edb30873d7f3ca5464935c9db93cfd451b6fadcb217610e1be819390cf25780b618ccad4f19209116c4b713d34dee43a8d82fa31fad1a83a6ba774c1c349f2ad166c23663ecfb01b1f049c88a3de02bd57f7751d5fec05564636e7276a823994ef55710dd999721924964f29b0cf53a19efedadfffe9bbe1acba96a0e487038a619b60a313280e7ca6308ea335883b68adb7cfc9ec608f7d051ec4d686b4aea0ac21f988c503949c08c19270882a4f660350f1e6f03f5fa3f66b42675d5f7802af2909e4d9470e9ae59d2450157b6c622c97ca34729db491ceff022af47a7a6e652f7a2c1960b2b5d1f195ade908f5f5e0ed0c040b950bca2fbe3046bf134cbf6b6f808fb62a70ed81a5323acdf40465ea63c88424bf60c3d370026b39df41d51569176807c190568b21f5cf41aa618b3d4b54418e7edef2dd42ab996da8183ed5afad73c3f9fec78c4efb06934d797aecf9d4d26b2ad43a4116ad207467ccf57aa051b8e6626a343fdebce01bab80eca985f098506072160b4b62f5055998ced9a299d7a0125b1e1179c91e8e5851968831087c725757b4180770143236aec2a06bc86659b819d11b95dae482fcf3edb6b0819993b5edf88fdf789097b1c44696aa71e8d186cbf0e28a29ce822203aab9abc6e7595382244964f0c90a55b602a40ed3b76d5dde848e76703fdcd9f08a9c73eb3e6f21e8702f866aae3cdaa7637db0dd75a7e6ed95b8ad8547c73dc564bc23e1d01d30f3cc8e07f7081e815aaeff3c42ae27ec07880bffd6300df8c68c130ccd7276f8c17035360b58510874c5a7b46bcea1531a8d4f7fc0160ab640d97cf1ff593893adc31e6fded857bd09d7a4489ed06ecf0cb9494d6b8ca08df003d8bf1989ca918225f91879776ea26338ed2418c6860840203e922b56b24c50324ed63aaec0eccb1beda6ce17b3f9c33fb8bbc4b8ebbb4919cc2cf7060bada9286d3ffb5cd46df15ceee1ba79cd5ffc95c6fd5508ff904b950bc1bd4cdb7ac829e3a81ef2c43c7c52846bb211e5ea03619bef820290ef2002a47a1dc107e7d91f4907461a124bbb5a430a1411a43ab44e9bc16d0621b17a18aa4a8cd6b3943dc70de2f658e44969725b0503c68fe0efa582b0981442bcce8ce296c3d077e7f9d276d15a400fa721f81d0952b3dd7a1c841df1d1ad6bdbe2d3642e2e4f6d5448ddfbcbf1514ea364e010af56c6162a599fd072c3adc8a4d4d6c72b21f9e743fba13fc2b2ee296a2c729b93b9dc5a819a259f7bbbf5057edfab15cd739d64a56d30d5027636ff3848bceeae75adbbe8cd931144c35d8aa315f55c7dbb490bb105c032e3534c6938284282f815b40e2de3aec0ec3430345c4ab6b9a95859ab71fd288fcd0e90b47cd033640d846ea50f0e3d26aae4b0f38cd58c52d1607a772d7dbdb5e6c43e47e3db49fcf7d8b57c08e26e3306855a7122a61f6cda31a8882a2e8a189765e7c544aae1d593d3deaf8fe3a7eb54f1ff40cc18a46c9fd77244cba7018f33fe544026bd1bf9d1b0fe29cf4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
