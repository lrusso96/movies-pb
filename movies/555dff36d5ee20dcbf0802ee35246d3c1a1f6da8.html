<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"eb1478752928ecdd914585ae8727da461c69e0321d3ead449b54c2bd25747ab4f4537f29242b5527793b237b707f67e13540b34f11a3b81a71d53f22708b55bec3d5b6983a4641671773c55a54a4a3cb2caa44619c46df705a1a76507c699d2e8e4feb7db75c6a92daeb4e3b465c156c145a28030bc4b78f4623873241e4ea992498f7ecf03136432292cd1e3e8d0eeda0218f17ccfaf9175297f3ebe4a54583b168499c78354ddeb04d1f77e39ceed4dfe8d359113079b818c48b5c8284d459cb96291b44be899a452363698447bc9f2e688e24b6c02613560243bb73531249c3e58bd5f37c1fa84b8d6c118ce259a53391440ad766bdaca4a7c96d8d0a28013e92230222fc8a498d3cc56f5056979427e30b55d887311b4e69885a6ffd62f073b2fef3622f15ddb5f88c5bbc4305d9836296c063146b0af62e3c086d37884e2d272b85e5e58f5fe738e499ae05ab0760b3c1046bd6206ff906959680c2ccac8d0896cbb28091da380c7b9cbfec22e3fe00985d8328e839b746458777d08299911a7a06cab27685a954c69d5de225ea1037154eeece9a73e509d504f64ee14d95143d8b7bbea0f3a1745804475225edf247549eeeff00911ece9ab3ff04bad09270a72eb85be6c2e08a63ede02a0b65adb17400262894cc3b1efaa8c6f99cfb5fc08bce98228368fc19b02f34dcb1cb880e0f3cc95e6715b7e0c070dc0430804abd39fe5221095027c801f017c6b8ee90fd8210030e7adb2a148905c4eabbcc30b47ab893c4cb03dc2230fe1364fe231c71b779a9d2a4c73cbd0592328ae1a7ce65f986dc3c1d97921fc249da3c1a2dfe19992a2d609a6efab62309598512e0b3590087f610935db1c971522932621f9169a04117230d48183e7debf5d480538f94ed6e6fbabec85085c57fd8bdf557a044c23e9098a18b658c4fe4e45eb1fda8541abf03ad5387a35f9197df35f34c99ba6cd713940445064d8e31af73680f35017948094159fc02eb22b0daee53791ee8cfb5305ed530670f2b3970edcecc9aa9b2e644adbe2f9e9a7c1cb43f85d8d4ed94baa193dd0f86d6fc4fbd145a5b24974b344e253e1e3b108c9e266fa4db6d9ac6daa1592b0655806106f584ce449b28fc59af9f0e7e7a6aa9a4e7c2b38daee3704cbd9283df14dac5ad3407e071df862f6ea2b9ffdc48c4774a3cccb5504aa300fccc11569712f48503ea6676aad2d8c06df3dfec44c1a5bfc11d1ff179a59bc2b605b6ada4d814fe46a0b347e258bd1f92d28d731654a7471bf7d3c42f8e096e42045af6c91946405c23f1e3a69ecb16fba0b0c1edd3f0d63ab046ea9e6a18e7b0bfaf0bd660e5ee2108f86c9fcaea16432795ddf04c814e3315698f94007441028d7eef72fb34643f2498b7b7086f0772496330957b98bba90c61df6d65bba1640fa4bed566cc6683f153efa75bfd4643e2a5848ee0b8d98780ec76af13834821dc08dc990acf3df40739513d1e4bf6dfdeddff59ce214e1fdef25ba78500146bae60990002f0a94d635b7306504d4e36cfe043cfa13cffe4b03c63cba0092d7ee772521aa942b2945d9d1710e22a18405776762e28bdb28d9a7465c2ea0dcf75cd051a694083b9d89ab80437625bf5ae673edd21ba505d47079d2a0cd094a68c0225f617f9697e03adbdf836b3205b29a23d27a174b049d23ed5607cea41b556f4ba64d47cdfce0c3dbc2c799040312ac94a07bda9fbe35f83c4f8dc64ab764d4c7830e7d0956abd58ddc1d24001dcb01c0d057fa6dd168568de5cd8e284753b51303c802314a652941b100f3e4862ee64989ccd780af1043eea03a0a3bedd9fdff7931db18cf2fb3875bed93d7edb64a9e63452ca4dc649f98680d9e59d7b643d764b6e2909bde1ffb47b26eb02a4ef1f769f03d0d9295e1c4829c69608d0d0cf607f6ae377a27b0a59f92772beaecb80e9fc735e273e297b2f5da1ce6ce9e80073cbf7f1ecfc825e868322feeef9ca601bc7b607a01bb259c155d150343dc6613aae9262db1c5ff8427032f3e3c68c3b78129a853371f3bb758689e6f96f986d505d2005e49d4c921af63d25c241368dab8b1f7c271b0633816333820c77d1e272d9f20831c44eb121d825ac8c7543744466a7d5989f37a2a54d8a951412171e24ea0ea04b17f40f87d493fa3a2322b34817a2d9579a56b947e9bc8fd62563b422690262c2af6fe115021301ed07b95f0721b482914ad6b01664489c164c9fa09f56e79ce62333600a41af6fc98349acb015a5956a7228d2da68646d150679d18464d51f310a30173a5c003c13ac46521313966c43abdf6368dffb16b0595d675dcc8fcffde9ad37ff895ec27599b662d089358f68f50df2ba20c6e3cbc112a443f4eeea45d6206c4cff5bb95108307b2a39c7d1c76e177fe79770cc4d189079762d39ee25d96a19f6ac06e6a822e669aa243c48b125d217d4efa7f536bf9516c3a905f6d08bb41b799cd286c9b0914d2452b276e2b152d7da0035b592280639cdb227dac9302870fba2387e8c40df9969f015940de934add962b47db084452c9144ac82075ee2bc92f01fd30e8af2b3520d1e6f990439690c57a7e456ad6ff03e1c517448258f2a111b36f2cc9cd3bc961b7dca0951ded38e6ae151c3eb52912bc9521419d5ed2a8bfe089e0b68ba26305626439c892b0a244b091f8a6fe190944c15957e218db50145e6bb3b29bc052b18d5a93db7d9faef75f747cef9c50f575c6370b0dfb2f9d0e9e55001061db4a2999ec0d30595439fb8141235e63dc61262bc73df268c60b63e90950e23df03c07bcdd0c8352478fb33e58a38a2d7312144e7b25b85b80432e8a693ab787e35b0c3a3c420a2af7b4675df9176d22ec030477d7c01071aa19f7958828b7155286fc56cdb376cad68f702ea7f8531b126a8516f9036f8c4029563c5cbacc33efa66dce1c6f916d9f056497faf00034a0cff244c10f459c0acabc33e2cae041750b719a12fb7f4c730559298d70242c77ab07002269e49d632d9e17f8d59e33ff2e1dad4d6fa871cb2de66fd6882fbec1175f4b6b97ad5c9e1ad8f679cfea0dc2b764bb9e11484227919d5fdd41dd6b1e4d42199c6c476d0c2580c7f3938f7878748a4a91883b80484d72378e44635a8192802b05936f7f4d62c703d16fc55c7c02e4f8e6c6a1d38d4693e503ccbe4f77c5e4153ac1861b9cf5a4e19749462435d1008dda9fdfb7ddeaa5c07a7735d8cd965f45b6916383cef38266be4dcd82c7ce7cb8f4b9f5ef1922220f73383254a1aae3eb818decb264442a8be79d2a6dce67c2bd4e8e3dbe024403324878ef878ef1688d662d098374847f3809ed8b46eeeb9a675c3d693cd56933ef384be31bb6ddb8e290ed40ed3608c9596f3d97d10c604be6f30e7de3ca1b4e8784dee1620b1dd1334dc960d239ffca813d784a64ed65f3948f269c57e0830c0e1a33f70bf02722a4931ec40996d7b4a7f2abe5b7bd7c88ca33f3750e59f04423edf67946e98b9638738606819ea8d8c2593cbca2736f445a5e81d6899d105226a7a9efd3f4c68c277799c281a6b9a8f293c0868603ba1d558d66716cea6f9e599beeb45e98f18387a3fad3534a9583c2a189681fc23efc0cc58426a0aab812e35cca5b50215f737af7859e699892c289c5b5a0520d730ac37a7c335a9c3247a20a62f7a54bfecf287dca584c8ff95e9e7a9ccde3fe9237fdc5beb0ba10fff327856fe9f794eed6d13bc35da2497480b574ce745e7c9610d4208412e2b869801a157b231e9980c62cc6fa5e60c4ce6e6f3e1221547810ff5ff50dd4c98a7c25b9593e9d0bad9ac875d9b18c97a13365a9292d40a3595f0d11b2b8b861dd9fba778b009ce521b7f5bb2f48b4188b7f67774a5d19f8c4575aab29f3a158c3b30b41e3a4b99cd7c17e577327462896904998226120f1de2c231d1dc11c1e67d6d7c2d1f3cf52b567068fb969e840cb571fbcca6a6f1cbf32d4fcd31aa59d3b7041e820ae2e1fd4ee58f9599310d2b055cb762984bfccab3ae36fe59445543de2bb6c69858b196b11a338816fe63b969057684c87602bcc8a9d807ed644eb5cce619c9eadc6dd3b2e23d3c25d98816c7b02a5ffe9bebc2af897870f666ed451a0bd042b43333c1c4b7bd12c0825a31f879035d244edbd4de5c8b7ea8925f661e706cecc5fdad194d0bd9cd738fc6a2c2a501245eb56394a99952b5692d8bc4e1aaf6ee8a24cc663c7dccc0b6548c14dbbd00651177119cb6d7b129a9473f5346ee92dd0a4b2350ae5dc5e61e38d0de2fc8811d1cda9c28a3239a05a5ae334b5bc53ec003e716d9263e4a3abaede2010020bdfc491dda338e0f8d36b030047f503fef6b189d7f59bdc87c6e68ad0d5c8f6fcfd51947816bb85655653ffbdd7ff8520ca4b188b93f60e50774ca1155fe5b3e4b7990ac4265a55d2858be026e33fbf1aafbdbc741f47069a5ccf842ba7701f64028a033ed03e9704e3de6c633918b9c0661463a88e84b58267e5f145ec5ee2d02233a7c93116502b068dd2ee00be8f1f34ba5e3d3cc5b4e6bf61db7264cf814bd626ca15a7221dfb24f45c85eb0a13ba4f78627aae58e8c801a20dd1773168738f1814bc7e0324f97f487d77716a54a5ce9d42a6116ba9eeb0459e3bc46af56f5c117c911bf215c8ea75646c9d8ccd6c1326f272e67a287969f13e2941cc405d29da4beacf7a3049ddcde29a0e5aa4de0091c6e55960c2a1f102a90396a4d68625cbfe097579334aa5e0aa57dac8a8f7413374fbd8e288cf371189f3f4567cda7687d09185c4ace061d9fe53f971607670e2375f5d7c9b05a2d7bcc2d4a1f655897d804e35f36cf1a36b08bf1fb2fce02e9b9c729825802b557a6165fc61957e2e1b315508d0fd8f25b40fd4167c79860e61079a93e151baec75c2f7d8988b5b453d52dd7fddb1302e75508e3e0593da8bda9c18c5d883c67c3df84ece786a4d1664cf327469a0a9d39d32bbda0337d874d2569c1afde2e0de5d149cb7ad9e581c6137db86532440962629a011a636fad9d1d962082eaf3d2e52c6008e713ff8cbb083863152669efce07913e0dcad08cd3a74530ebd1eea036bb362ce762da2c7bbb3b0de4d44567ef59084f0ac916b28d9bc92d59b7d1c9fa400782f2094cf10c6999abcb6f5398cd16702acddc4175dd52ccd73511d20b88691d0ed550d3f1d9a29311a6ea93f4e010c3635cf7724cfe5b2ca49574de72f0c167888f62c0e2e4982759935785424335cb846f46e5a2791c17d7e1013dab45e4a56d0009d98bd58297d8a455438cdcbc799292961d9d6cdba46e06525783fd1b8ceb73e555fa20f51044b7211a29a0091977df70cda0affa51b8c1253bb4bab55ac8d5d5c121336dcf806ef6a1f5a3c59ca9cee83b1fe134c437f86294c7f8bfa0b6151dba173d3dc80f68efdf334c85fa7bd01637f87b5c1e96c2f69068c7c4e8f06ab3f8367c9a8a44195eed1cb1e0593342e94c21bd3a9e88bec9f2ae9f6663b1765d6b5698cc9a4b41c102e3919ca9eaa8cd598c0e662c281f47ea5f06ddc83f41b8524cf2cdc795fb78460df635da6fe50e8a266072a0bd0cd390ea1e8cbc57bc63563c5e2822bb3500bc60b6382e1e136d517dcd66e0084600291965b64be10ed3b8a3b29ca96b79fedf5eb7661a84e47d67870db48e53459861cf0574ab49341810166e85545f0b103659de1fbc5fe06abea2f5555be66e2e721cf83774144be2e80511fece8791a1a4725bd91e1715e480ce75d704d8d878ed9a9bb75615748bca556b201d507fa0148a1b854bc31a616a367331eac959c6e26fb5ae113d5b88752462ea9dc9bf03de992387f314f08aa0e593d5ad3bc7dee2fafc846a697f703c0a7b3aca44ebd62035c89e9886acef950964dc00c0ab3b1a8af4406985ccef8dafd9662974a020e41ad8044e252db798bb95a1c620af58e5b8d5de91cb948a997b3eef8627412763b22555a17a0f9ab0fea834d64ad065233bf1a123fd59615ab625b570291557d068b00350ff79a2c8b980967a39f94b73d61a42174d4ddb1acd17d4bebb369fd232fb49ce159d9b40c4908fd4db4a4960c6ab4145fbb5c3e7164e41bb7eab4d0b68cc19e0510eadc59d8201955ac815b6f0296d3b4537ac9455adf8c852171453988dd74767201011d6791cb1b9359bacc16efb6564853ba1744f6d1e6bfac19173ed48876147a39790db78f1f54e278629bc9cf7b9bd75183659bcccfc5fea33cd9e0dbffa7f90b013d83076af5424bf8086e225b9e108259842e023b4baa651b252736630e3a8815931bd9d9fec84259293ad8b364ce5c2f7e7adaf2be3004e92ea0d41fec61631c53ba318920f736ef9fbcd6ebac129cd5f260e5588b4e5dfd2e633785f7185f0cd09fcb2a56066dc6d7ee81b1995d5c3c9c74b5128e3559d4469c72b8b870fb708c1f5555ff1a0cf4484733367dfb6c90953edb2d30363f3fef448c5e34036b5fb8fe5c4238849c37b23e0c38ed96c5a22d7c68a125546a2042dcedab834d6e9ea5d2561755431673f72ca1970740c1e2bd65664a63ae3fec988f6161fcb306798afafe8a853c0dab510f2b115eca92a37f59e81b0a5dfb024330df1016692130689ef823154d250aa63153d12e06d18d5551804e323f12a1f3f99cd0d28d3106b96aad455234a8d8810340eae6edc462c03edc8c378adcbcb280707889655e146952fd61e47fce41da185a35d957a2af194aa71e414c006aad6f859724bab4bd20180810792879975de3fbed83c3f756b42710493d72290d2fe9ce7823850be336d0255aeeef1aa4c9dc23b55684d3c1f5b109bd044ecec14d33ce9f84b360684714de32a7e2fad45d527816d6f0fafdec7ba875f9b0b93b5c2053fe2e24711c2a509a7c145c260d65cb52c2fe355f6c0cb463a6d9dadfd7206bf8e5f3f2b00ec5346910eb4e5d069ac7a75732e185497d15e5b235f1186e1559a4cf466a2c6ffb803f79f83ea748b55861005059b995f24e7deee8662ccdd29836e60b1ba1d0b0bdc0b1fd79b577d411b00e26bc5a354050e0f8314414682a7f6e68d900b1f81b1182da4ef90ac6e166f40d6b2e0a19bbb29b6cb92a1fd9747a2dcd9655ce755fe29edd21fa48db1d26922576d50e93866bca910b3ad7520091c62ab140b2adbb66ecf21b0955d465915a12c82c2292b12f3158f20ce0bb0b8e1a38fd6a64916d26a39f3350acac83008cbd0a8c89608dffdbc7a14a38559adb24cdedaf5aa47bacf19c7d83f6c2e5ab06758ca1cefc0d379c7e625eefdd4c9e5fd96bcc5d8178759ebb7d25a0723966fd5a7ccd909e0de04f0e775fe27f05c5961bab74d376d791dcdabbdf29dee330300cef98777eed750ab123bb2952b43d3b00baca798345b59fe2cb9406cefdc5adff819aa445250f4b53c5bc05ced41983ee0ce64b669d1f32803f4cf296b3a5ebd0be151c4db7d546bef1f836bed9687a66e8d9bc2a3a8e659c9bc1d1e67338ac6801d77c0232447a83ca343699e405b714568078df715fbd0beb7c8944b7bce0a8ad4d77f7c45f0ddee14a9e1b026fafe2530fe5fc241d8c128a7c63c859a889b3af3d4011e018220db7e1dc0971c00d9153b2fdafe37c5b32ebb0d37e4cb5bc61af2826da52294cb15f2a66bf707dc0f4f46f601015daea621f2f55170fbca715b3fbe5153d088c4a2d207019496449ad9152a5b4ba484ff1a10f60c0071fdf73f25e3d38dbaa573497805c6c0ac4456f573b187f416f602b4658d406e10fce7faba871237de37cc38cfd4fd950b514098f33cdfdf0ca60f54e7f99577dcaf87172d9123d6454c4bcb8ea13c3c77a32d64fe4344e2b9fadf74510e7ab147c92abeb11ea676ac3c5665e60f609737494aea1f0b6b49dc9a10175d2eed703d32dd8f8aa27ca71ebd495951ad93aaba83e0c9a00d45b417901cba84d2b3701c0bb3bc91f8973fe38e8d81dc4d2a36937b4814c73c573932fb57772d9521e92b51d1f89624cd0f62348556fe23647f7b544e2bedc0ab3e256b87ae5506e0e3a0a81156a22dfd6746766a7873b8e54cc506a47507fa323be38a05f7498fe3122b23d42ba20387f0d0ed061eba72c6c63c268f8dc74cf418a3169b1550499eece10da9add6bffa972a33608e709fec46607faa4d28808dcdaae5ae7ba58543d83d004c330632c393357db72da08c12a3499607b8b86a2f360767d2885a5329a2300c53c80a9e5b1b46ae7b70642ee880583a0d2c216a7b7ae834fe8ad27d2a2937a821fe10dca49ae47f93b2bb90b0d069fd4bbcd316a77f1d4166e381f6de3f462b12eeb7b65d709d55364b95aba17cc2dd618e7902876f8db3906d5d3fe424a2f990f7b0b28f7d7429d286338a2c071f277008010c653718a78bf239f224ec92545690b937f3212ea213eb5ca736621f89fa724090a52e5cf404758623df4d920da2c05e06a9b83c0f75f7f304bada9cefb92c198dcd3f55ca39467dd5e76693dcc1dfd8b7c1f0ebf16a67916350b44d7a660ae26968e41e18e82afce5e9e487b33c13c48601966f99b41be86ddadb4249c72d5dc676630468c7b4580db9ef4f3d4d86c4bb86ae54a44be97ac958ce7ca777772b0585cb987d915d7f871c81cc0a54846342a60c4e6d799a6cbd0abcacd5c25b1d88dfd6885fcdc6502fded04665ddeae3da4694a218d941d79829aa76902a70be274864d35131d397eaee248fe2b8d376c0f2299a111c17585c1c00e75760b9bdcbc4e394676771405e3aad11ff14ebc8f5b40a656a0bd27a4be62619abd869ab3547a33f6917951b5f50c8d41b8237a6fb84ab73b9da9dc67ed11443753a7b72b3e49375aa392e232235e46d0b4fd118360d1b27023b050ac683fca22d1fcfb09d2d09934d21a7d6d8706aa0c8ddb6a5081753088c77d302098ba53fd876f03ab8fa23a0daa325e3d705bfccae094367cfe5a0e3246fd4f7bf071d4d43f33774afe5658c00f07447b75536d4c7367067c83016b575c29bb2710e3f47c5916a26734b54d49cee5960d423ed7b9612d016c8f91d19488cf07a105d2d8b982ebb815750d1b93fe7841d4787231554d067cbdf130ca0886e7b42895c70299ad367861621f6a9234386da551c4cdb1c2cab10795fd592f43bb2d3b6cf2def4f46981aa6eb7fdc90a9d75a709080fdcbcd3c3c69ad196ba053886952bd10d5ce1840b152ec0ed95f85d8a92e46b8cc435f99628fcaea12e898ebe8d4ba5b9727b6d28eae86d66f21ad6f0f67fc6e3a59269cfd4e4efdfcd672768952691798dc48522b6b50054bd3ff4dbf33286b10af3d7ae957bfe4d71d6a92990047f3794feb02cf55b8cd0059c7ef605cb05fbe21b55e80ef2656d233864c66959a9469ec7814c8d084ea3694ac0b7d204b1b82112599c67dcaec3363507acd6ede11e1a44bb04381fe90dc48fab3d37ead0571d75376ab6b603818cac751f65e8b154cbbe1e92c98c712cea399273260c265624e2d14384c9206c245137a698c5f19edaff2dde0dbf0a68caf7dd378fdcc97db9b332c51aa50cbbacaa4586d09dd2e0b841a50cfb8c5cd58d4d429650f1fe47f2813dc169fd00569defedf2bbf00039786c42ab6f0e6718b275e5696d32c756ae87a3e12d274a99720b9a6a86a002eb6d1f6b1a76c7b81563269d6cf65b6358f1d50d85b4dc8b629dc53d8102260a1b2693f3e21548e040270da0f865a665af14633db9c1957d64a56e8de51aea71125aa3d05bd011ad7b53a046411f2af7a9fb3891559baecad3e2e6dd5c8cafc9dfcfc7769d02ac464cf44388230e65e1fa9449eef8439bfdbce0d10d8afbad847a52117984e74cee037705c816f80c62ea8653d6655c3b9e0ab3e777b257f72430333ba7240e695e599e57875cd7de91bf7f70a903087570081300147ffb24aa2db27eaa4df6cc3ce99b24b291e0ae3420b5100ba5a140d54138f49e0490211d8294341e5a61656fb92e783ccba2e5337465a1a56b5d533858ee546ee01608857afe9a94a0543f1bc8056171d7d51e3387225df4a4a0a65cb5b666f8c09880be198bc9e9ed00b25821f013a5cd863984f7f7198070e3dff709a8a8e45ebcee545590368ce069acd58ff7a75608ab27b5f155b2fc28936d5286c15144b23ced5c58644cade7b7aa95228fc5513f75e907862aedbc8f3aa32e23dad7694b4454fc983e7077f60564200ce91cc27f091dc048264d84e9bfd13aba988ce221d1010318cd3af9f248880e793a405e951eb7ece74fdc45102ab1ee47573aa61eae967abcd817526620489aa3829ca31366c95bebcc828370762e76af4f81a6e00abd12ce1b88c8e5937b7d6745c29d019002139172967ca82a823bfd7fd2570abecbb46a6669316ac8565381fb38198b7bc8c232bd74de21a7f3a06dac40aa72a9d42cffb443f3a3ae283c1930a6a7acb280d64736a4cfed8d4aefbfbafc8f318ea992c0be62dc9c7996edf65ff1c6a3285332c5080c922a027082e72b4de336b6932312b29f9182cb81485ee6a15d285e4f51b20f2a8af322e4afc786f19dcaf1cf11493e01fb8d05f765802b057840ebf1718e0b920403641c788e1e945002fc62e7b6f01fa6c57b24fa53e4bae5deb78b856a17d19e5aa4ace7a60599a74833c6ef89337ca2a7e16363e20f4a25f93f2587c1dcbdbeb0c1998ebfc925e8c7deebc94d63080f2692ad8adf844be55d5d7d2d57d1595a56c10fd7e7d71ab09c4110b8b94c5d9021f5b77cee2b60fa52797db700c6c108e552098b1a70f061414d3927778bc034d2384067b70a5c4588630c4482af1012704fa013e607bc47dbb236a7c5b12e3313d5260271c1f98dc802ac7318c7b4aa0448ac57a9ca35e6ad2d87f6c9881688a1f710e481895679018aeefc9a5ac4b9e6142ba86b0bfca712cad45dd72005f039a5740bfc41e58841d596089bcacad34e18075d7e8e10cd1a29d71eac27024a670655894b834087ac2972a678c637ba15beff84e9ccbc8b7afd9d0b806bb6d87b857ff3ad4a54a4be7ee3d55faf3ba6a61eb92f11dab9a0cf320f5f5b99aa2d79a9bb8e34d8a43473787f0e932659fc8541395f560ed0703e9039ad4ca44706f9bddbe1158b802f3fe1abce53d54792e526882ac08395306b9102aa85e94b4566fb15e2453b6c4bb3ee4da8ee1dde6a038b0ff7281141139b95b3ccfeb10a7786acd83e0acecd0a1631af70ba5604e93753e55f1e61b2f7287818114f081ac71c7fa5e990ac462cc24629066814ba39592e97a50a1cc18623bf8f3510fa755b06ae28917f20d6c1170351dbc217873dbcc314f794dd69fd3b8e9700e83520a77ad6af9b31382560d02888b3a74306fd290ce58b815c5cb34a0ea4c81dc304266ac38cd32108e8244b2c68889328b49bc0f1b9d5242eb52c6b1bb6debe1cf41976a815a511e039df8a9e8eeeacf1ff74a49a1774b6ed63705094601fb550a7b4478c21f5f372555be19294a1470e800a60b60a96b70f12c94a31a45a2a60ba9e71d89c455254c403e7a7bde3976451aba4a5633845696eedcb4eca82bcc1454f81e0503907cce793927beb1dc9a46f41bc671e3d8e20980b874558f3f92fe6a0065f802a124459165d63dafc1dba61bdc080947ba94985fbc43d957dcd4843175a80393686ddee4c6e08d2738a2f9368a99beb066ce15b19a100f18353597287395d73335ca1bce20377e1952553fa1668961ff83d14b2e8a5b7abda9f7bfd2aa6d584ee09b0d29341f5100ab66caf76ca624682be852ba9bf29041524e754e2f233fca714579b4bb62c72b1a61796625fab5fb075f580dd4a43c379c48f6018577a56b436fddd2b2bd43e0a75d45e9b647175686ccdfbbd57f667b63bfe805ca7466f3835d8e4b90894c6c512f19432e6a2973696810b04b25cfc52e14ebd65594b105486259edb5510601922c547257a6dfeb603f2f5aca66347a3bfec0b09ac1fd2f17ac705e2b26dbfe1affb0951cf1a4199bd22cff7ab97dfa1eb3af4da5ba29cdc245491639717713667d0f33a1c3c39e19ae41799f8d4aab2efc7e5d3e902e7bf018ab9386541711aab7d7a43ce5722e7d8f9d28f1bdfcff80da2a73495780f432b98f4e644db99899927206e15085f383fb6cc362e4a47bd5f4525372038bcc2a931d700ceb5fd86ed9cd4597f257a4221e2aec92d0e7ef146ba48ca5cff5f4a668bffb62f33d867106b3cf737017b2e9ef7135438f93de94b722a8882ae01aad7f7f309a6c380907c81814c5dcade42963349463c57856ff0a7f03819c6bf3edad3e21cca2c65c9aa0da6ac98fd3a1d71d39fd1dadaba5bf40742d56f30bb63c3145266a12f57905c7cae94889d90fddfb5ee5dc5b8c652fb576f4833b69ed4bd1dd54c5492a5c5303497500f37a5c39d73ddaf5c8ad09174a172a01abf97c6b4410f12a157554ca988e7989302984a6772d65bb1a1aafd47edaa9376851159a9c6630f43d37f6d0710c66fc4b9b17349973ec5e98274bca0b4033b77dd28c737904ef12c041b3c581367897b59d7ba7c176b485674faf69c3b8cf6945f2383c571cf8fa7fdbe69fa21d75c18bb5544bc9f9b491b604d4f96fa18265c4dd413370589d976f2551a7ac1f3face6913d191ff94b0b2d52a869bc933b08465d35a439eaeaee115c3d24e962d54bedc293717913b0bd9a1e6d332ed6071976c3b466e649c500ef07b8e0441a765934a05f95277f61c5813b180d5f153dfd2595053cea0dbcc6b3a75bf9e3384c0c320ef37f65fb6d8efaf65b5649db05b14e5891cbb0e14bb42630cc69ccb4bb8560217a6158a11cdc32dfafc043274db01040619cb6fc3080e38306bdef973d371d7c146022ab8575bcaabdc2aa433e2250e4e53c059c87629212c443556cbb97043425e6bd69e4dfd02604933b511f7dc0275f3c5e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
