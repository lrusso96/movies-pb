<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3ef6acb46c9659f49f63280c83face351e563bae0a039e7aad386f346db098d14fc9e888ef3a06996c6c90793d6d14457d37dc5d4a3d042c61ccc6b6ae494e2f5e6de4c9f851a30eeb4c5e6bb450cb82bbd0b75263782a2775e1f5b6629baf5234a2a16250124226cb3780e01655bcc61ef382c24d87f8d6dbc3b3dc3b3119d2accd2220cf32bc07b69d0d2da016bffa261a6a00c69c92d7235d6c3797c11567b98c3422ded23f0a64015762efb578e1b2f3bde0d83d63a4f9231ce236a59e1f6237dc4ff913d009d5cf5dbbac96db6723d3f21ba43a5a96778de422af025edd9ce6e528a3354404a4bf85ccd225716a4f40c4f7d0aa38929a2b2000a1802dd20261bde5a0ddcf011f12fd51b2491c30eb5c1120136cbdf298fe5ad12c8c5c5ea82cbd23adea0f1a137dceb568a9816a73f1280f1a35c28ab11cfa5b2efa5d0d67e72d231c494bd943111d795a7fd1dbee1987d6e7e3067498c7303b642dbd2725d2bade250fd0d29959dd94ff8673cf2ab242aca413061f41e29fb466c7319d004f49016034fb37ed15b7d61aafef86ae3100c57a4982799698ff84c5b1a9a19b615f4b84753bbb776ea7bed3c530d0b01ba15b98444557ddc1756a9ce4822b5ca2ed042fce3215c7c814246634902c3ac1265dfab17b31b5b0254b2b618ca0385590639e132048937bde0ac67a463aa588172464c36b5f59347e4c5f3a2c313c5fa1b0ecb88a9bbf4c0736f801ce650434990515597cabf438a8190d730eb4cc7a5007cf9b4dbdb2baacc1b6774f93ff31d606b72e6237b525eb182190e58204b523b10b0eb383c210483950d7f1278b8c7dc1a714664b2989b5ff4582b37e2debd6bbd66f45db6b80ea62de366a5677077ef2b4ceaf092d697629285f8599346b5f421708439927448f3cf5be8f8a4bba85ffb31a6b342f5169d0bf975fb5d53a623952b97c084a43acc999169fd3a1a56801aa71ee30d299bfed8657cbc17d9227f048bf670575f435ff16533a031a8f5289828d1e870a034173d23d95952eec84e9a0bb5dee8e309194ae7dcc8eb7074903ff59512e9a2a8c879f15656f1c5607782558a2c0f5208ea00713e23339fd35045248de0cc59aa364238b78dc55e326db3e704e6739fb0ed62870ca13683374ae438e19397f107f4ce6c989bc40283d8e14c4c096838ee6183ef8097a97bb4a69cd2854e15aba204681d54f5969cc2c33e8fdd906cf0d40d5cb479868c9b9cb8ccfc22e7bdee354ec0b6597bb09811efb485b168ed86d39fad9ecb152b57b5deee1bb41af5dd79e95bbcd7366e28575bd2e05e08411af17f49cf99cd7561bd70f47a2282bd4d75cbe491585733b1dfeb4d2abf7788f93d8ed407ac26f1d01aff6145bc472ccf0c53fe37e125eba9b942a34fdea0089737837d7233bc2c33ed6d7a7745bf567beb1f9a938b20c171d45fcf887f3a164e8cf59147569e5642226cad06a89bec706f87d6c362e1f20cf22fea19e91ef766e8fbf2e31cdf41790f43b9b8e92d1b7d10ff2b42d8ef7bbdb86213983d608cbaf260162076005057d8e4df5130d760c9f95b745fd6f51589d83a0381e092b96a550e7248e025479a7e3b69279a894894cc5ea4a0d6f863420cfeca6249d13b436c54aa74740901d0eb0aa6dc0cd999cb55dafdcfd8d64878a96933adf6096aad06d877ed6dd3134dc7823967a325b0aaf109ac97c63de0576e489b682aa4fd7583748cd340f4dce4c12df70b6793a1385867c3eb9d1156371e19d048fc9ef56663266866c8c90c79a7ad3310f9749c0022620f344905a9e91e72b83907c43a079c24116326694f53e680e99c518f3e55d62e188fa265df20310c486ec781ea3b7a143e84d2fc2d5247f15f368ccf9acafff648248c9454837c641e586f2054021a15887f0ccdf3392cc8658c7c0480a4ab339c29ee08a51904a80a1bb46fb7e84fe72849b6cede14e6d7976b8f9a1f26678583bace6f9806362b5089b85af10677d14e162bf965da7629be4c3552de1febadd89e0e9e1853e53840ad6192ec401936ea2fd350ff4e92f7026cdac08d1c34a4a3110d5ccb1721bdfa6ab8c2b23270a537c6cc9c2890328d3fa3fb4e3b3d9b4fd1c5ce198b5d3bd01a6a9aabe34ce143753f8cc08137a57e502f927b156ff75d5d6830dd86fef3dd10c8ee1df92af9c16ea8d21daebad705cf9aecd73b65b13cde59bd262fa50af97ad9b413e8390eefb5d3cc61b03ea3f72bc0d0b53babbf0ac0d16f2d391a18e2388359b95b99a4eaad063c6badaa1caf940d574fd60540733b253561404cc86c99032d3941595545362d552f4b6389fd3450b07b92825c4439a088ee479655a1884a2e602fc90ed960cb2c2f7eb0a33b4d3e9e425a76038d05cc667ec5816a2998a12db52749bb90faca2d70218fb64ed1ed08c89cafe9763463dbdd4934b29335e2bf0fdca55024ec5c75550a784bf30a54831fce0ff3e464773895de14255c8c609d8cfcdd7efe80312a855153b38ae55b2598a52cb19a88e1bfb85193756aca4d2b3cf8445f3ecb570c867b0b45b30f2ee2e709864dd7a9dc69d1306659b47b3f8052d8bd61b0c06fa3c968323f6f9a6ea3819d612bc25cdbd8f9d989e832838badf0c2a4c466b47c089c16a15a2c6f6c6198330e4933ec0e5eb0c3f37be3b76b6f0dbb84306468cde378aa9611132daae34b247807f8278c54b7746d2a2a6dc9feaf2f87a83646b8557ae8142f4afbfac7f60d6c13cac200a2fe5e53d46495e55deb692e2a961395901e102afee8f6e519fc994c609a424160f06bf03680d4f15329818b4038d1548698f96a3a2ad5184cd14c23796343c7d684c7562c6d9dbad033858a236022bd6706f671d58173c5f4b81a90e93045b02034ab6950d7e00dbe882431abb4c0266cfc3e50e8a9b7de7b9d213202d627b431c74e27edc44cf94c6baf8925ca5d56b10286fea791d9fb6aa1cbedb365a25a91a602db294fcb9c79eaa534938f4dcbc05ac54c5ad7b48554f289d851d73a18337face623d71e17768ffc938d5039ab91f35768304ab60002a8ecf8504677260528324431001e5ece986a6a57afc5ee6639787dc1e41536002409d668dd1bbeb15837d1e081bef912c29b9efd729b444aa5ecf5703cf47ff653448cbb76c8ef83f439cd67b139825db8033ff279a844abf3ab1a9e55302ea28925265e07ad6c560b4939590b9937ae9eae7e1f19532c66c5c5fba9e533153800a1b1c3289dd964a44d9a83fc4c0702d0292d86bec0619892f81152df6fc6bd46f9f423e9712424e4bf082b76165508ac7d5457d4a00a3d50542895c3bdf7561722d47a3aa237d7b8b8b151ad10d550c6cdc3bd2fa362ce4efd2cc6113f906e2f6c54587a84eee42eb945ec3a684414bc8dd98066a344d5cb08517a273407d246d82f494eebebac72c0ffd1c2cc29062ccadecd8a1f20a4a878376186daed8b38c662f5f0f22e30b51f5e713e4802644106845c6570f6920a2fef9aa8a2879211f124caa9e645d40e400c1f914d3815475265df99f5b5c92bfdb908db38f5578092c085f95a2a4e696765ed7606a5cdcddbbf30b0b1fd74e7fdcb31aa2f582b7e8ada24a17e18475e07f23330e2e848a3b30e0a785f7c6ead6da27fe0908b764f6ce41463b4e684fcacbdc0ad9808af30481693a660493098bb66adeef522dae876af094ec034b7bdb0847a8db86ea8db42fa49f864c97bc89793d1b7d1a2c89f0133a70675b7404a8f90cacad1b45697c816b425f465167411dd9c7993beea8eb731c4e47d2dbc45223ea8e96f15beea92be93ac223b6f1d29bff53eb7b5f6989797c67a0e819b1a184c97d33f168dcd1d39ca53c9624d190742010edde640d2e2e87bceff4ef966cdb728ff32e207c73ae9bdc848b781a8521444e2eb4afefec81a41ee606eaaa68fb50097d8118122408fea3a9748ac22f768f826c5373652f93ec79f1c7efb98cfad3f0790d99521c6a336538b976d4ace8ba9ca1fbd6026b7f50c0f27c0060384087d4466701fe3e4b124be5f5919d21ebd05f6bd6c8706fdbbdba88f1f3723b6a3a6ce9e83618393ae39e880c753b6ec5b4a4828f2d7b5070166ef7df7f7cc377acb1fe9bf02bb71a770418ad0f37a9bf6aabb9d27216ada42046f6b5cd730cecae5b48c37df41d9aff7c2a4524e80280b1721127ce0c73ac7fe0c75f9b3b93130fc5a9096d32927e785bca8ad3f2b567948eb5b0be5d30fb60fa257ea605b7f96305997eaad820a4f56e421a7713d2f7b64e5cd99d3cbf10c5b685cbc9bc9726ee579f82b78c1946a6d8a676be4da7a3e172b9743c4147d9b8ee29847a130c8734756159477fbec58ee91ef90ea5add1d63b124ea73bb1a60d97237d96b6be98eba9c751581412e1c9b923c19ec128ec609644b8dd581d1033d6876414f7fc6b5534c0cd25e1ed12086a78ad4d88eaf6497b8c2a6229314e5ad5d497569364bfda59e391eabccc158eb1276e84fd0fc6005b512cbb39ac4583ab0baca559af9920172ba81badb155c81901eb1b2bd461b2ec8b559c80dcc929ef87f83bfada6bf16d0966624e3cb622f4ceb21287d953b75d930234831765332d80be03378055b89ea5c9181588a4bd7878d56aef8c9ed5498fbcda940c9a7d77fab548ed4672bb1674c1fff0798938fb43878d3abb1292c831cbb2c6559712d7c040e1302040111a3d56dd96c119853d1fa114c37dfadcbe11b85e546a5d9336ca17bcc22764504d5c31f5bee792b6c9f945dcedbfa319051efa459e94a8ba603f65264adc5f991fc32b77ac6c2089e76462c1a99236fe6fb603102afffc5dadba13a12f1b70626979a125b93ee4f859d980982707508f8883413556f6acb1c93a91371cad910c5d2456fc46f515172c7e23cee4b351a82a1ec5213881548c9648211d9f55acaee36fe5084ea31aa5afc9c57e921aad074bd8b87b0eae45095abd1faa5b3f410259f146bcb5bd4c6e02bb7bef1e9d2b4da84baabd306f660f88a5c50f880e30372c60bedb04d351f2f6462bd34868004a744fda8c111a1434836279013abad8acfdb33bb2e2abfa9601dc1df5824868cb17be0ae730e0fba12663f07d0538994222889b9589f56b0fe84d2d33e3a48f343b40623b797b82d6aa094d18059d489be1f6db4c196b90d24a8cf793b8bd9a49f26d7df139e189f52a417b64073d7e9a49a33037bdcc5059a92797fed565afda6031c244821e61189cab61a91b6434f0534a4a093073d9fb90b0637915129cb3b8c8e0715807c0b5f6e01bbdfe0b8d720eb17ea4ae067a7e51a817a3b9aa73011e4d70c30a2c8c7427be26ea70d66e3f0982c48d2fa6f39e130f22503d83887024359e37542f5093c8863a2e97eb7db54a230880d38fae998aac126c4079e454930ab5a08f6cce5779ca9df508f7da1994e5a2ed9c8d63891c203707e85a7291155a8eb724c3c8cc5715596265723b651f3b2edb135489963fdd2b731940a20ca51ff4fbebeba8a0b10becae14d2b7df16abaf636531b47ab05a2a24362e026c400dca336310697b57708c72da20699e4ef842b2112a66da0dc70ad436e9ee64ea8a6836a694718fdff3fe977592060a70dbaa8da55ecb97be9f8e577fb90bbba41d6b73739a991bf9c4501d83c9f19507c008cb213c875f379d5ea53ca4464c017ab148aaaba11a33d81613458c01ba8ee0b50d2ca4e84da1a88f68888ce66df7cb048c249ef2664e2ebe7a2aa79c54d8a8e01251a77fb2aa9e30e1d713e0ff1a4b57fd228436c3aa3c810e3cbb642bf13016c888edffafc91a217a612f67c6b793232d0508f67dd6f00eeac13ceb2dbf3164534bdb8a139be7da1303024c50403eca5f18e94a129801ba23189e85e34c770d619907eec5072e41f8af684358f72e70a8f623aa1fa97e51c5d16ed5811e194120076a378a0d721826f08c3f94e34f6a9da324e55ec47d2e42b9e0f3cda570ea9ed6cdf639c014d6558ff88ce80454730c822e23c73db66d1685442e5837e6395d1da2c294aef3aded21b0fff6c9ad029f0ccdbc1a5b08efc654ef9bd3587239741c3f7996656a71feda6ba717fba3a1ecdd973c8fd6e0fb9bc62f4b4010d33c93be32a7049ae8876ee82f23fa87b8f85923033bdcad46ee7fee4a593b495976fa67c2d9bc92c95ff8845d35894a18d4069603efc88d0ec78679461e04d31500708fe3a1a033193d59a35d29c73d8fc63da5546693f7fe183fc38ee2d69020d916a1110a6a7869f2d264b5305165254d87f6af8bfb5c10c1d12129c1822087d2ce6f92e246310198f32f68b6c39c27dacce847a0f6b6845a8c38b6129baa1b3ca228c8afbd7fd13d5366e8128584ca2c614379a52c12d183fc5c94493fe59a6989ae48f83bf8276b3cf9c95040ee70010ce1812d208e4af22d6f2e2dd474d183213e7f2a1d11610ee192521a81882540f8fd805cca8966a783de9011631b9c531997b6bc06aea649c3e180a4816248e6485558de752406a1722adfdb621268ecffa6c3cc9f7841a03b6c35b91c426e4f8f05a76ba5ae20997c2c1fc93e0167d9133396d77e4ee1225e321450622cc3acf996b5cbd0e7ab691be9257a3421e74f0e77214d70f4a05f7f81e47c4e0dac5cfebe7b2aefde76bbfe077d06601e2bda552442cf7299fcc7ce91443677b2dc6abd6c3433e7f50addff0392bbf22d1813d643aafd7da2b08927d4a7144fbfab112bebd3c14631da62fb209aeb8f3679f8a719c0a64a3ba6411d939dcfd09d1324b53b5534ecc2205e38f4964dbe49176fe62d4a8ee7ad40e156e8df08bf2635cb642dc975e8a1cef9e43e0c77d693194ea85b22c6588c18a6a8c33efba5604bf68da70b4bef23e71ff895c36bc7af344124c6195feda60747a3d6b8600826efbfa22d857a350140721aee34ef857f2998f4c9b89ef3ec543d6b76e0209c9c286b2a3a3088e6ca8cce62a635ba446dd041a1ea078e730719eac4d634f841e13056f4587c4de9711d09daa1e73121eb0fda47661ac1efe304473211cf4d59b33faba54c2fead2d16c2eb3afe1ba901a499bd61e36cef1a1940082f0190904755fa55a42c03e493f8ae79ba432a8a60ae3c55cf9b55633159d3d1ae77bd08476506364d4ce832bac7092534775902ccf13a4c1bbeb8b0de1789e86c82f061b2c779e2bec8e250f32a20d703d7b1be1ff2cc0ee910840b0f8bb6990e5c8cb36d1932c2f34c3126d5628bec22bf68772fa516cdaa70ea4a40c6b6c1d71e8af8ff20028934aca3d1951023a836d7ee9150b49cc5a016da26a992b3415d42bcf2e5d755085e0c0625c2728f2d3d5bad7181a6cc316ecd4b8219429a07e518b0fec90630557d36074f42bf56c4a568e29bb7a497a88603114172c9c9ddc4aed76062cd381c9fcbff7ac44de31089c7ac78f6423dd592b453d3ceb3f73e08aab12875cedc7c38bcd9f34855a7bb05797ae3a65f8cf99cb4b419e365d77f985bd88461aba4c82d448f7e6cd88e5b48c2f28df0cc2c433965dae442d55bf86563052229363f98c0954d20f97d9a68437764c98b19e9c4f9f0cb42fe0adab3487559b8c2179f25239364e838a692d0af73cb6eb6088bcde7bfc28a966b76e279ef89f218d192f3f11fede5c1a3a2e1650789f5ee4403b7dd7fe6e47e218dc2c86300787f4e0919aef4bc884383da37b61d3dad44ba936e77858c44b1d74452c7873c59b6e0e0a2e9ba3fe5b26804e8b6d1cc43734f5a2e34d0a4cd6d08b39aeabeda4429ce8c8ce87b2b588326bb93465d9c9677d642b28d76e70adbfd1070d5e953dde8a4b9ada303cb245b33d01386795152ffb92b30a79425767c954f87c187ac388d72ee2989dccd52aa1b19f7523b0648d167439d1bbe9710817783cff5773c9852cc2c677cd7fe876a48a915a9ec25677b18a5a5406ce4c6ff275de1ff8ce72f27d5d1664e636dee8f1a21a542a8eda40c12ce583bd69b88f7cbc7094be2bbc845e8e9b76815ee5043fb0cd15c92e8cfa007949437ff60bcd25d1855a1fbaa3e7409826512c72ebdd33166b1dd7f80a4ee940c0e56e1325fdde8435c79e4f7ddc42c5bba3d3b4dade174b448087ce60ef482a5137aa05a9adb680a347d317d4e7263b9bb7e22e67617c1edd1ac3eefeb442a12aa5467e73404a6979bdbf5c149eb6c40e0e1693e6585c2055c1b8379c19eaa1da99fa5dfb524daf76e265c638121361f182e86a840c954c6866c2114d20663742528118459c25e2aa8ead6a475507f1a7e9cc77877b0c56cbe277ba624730726dc4df294f9c3ca6405f495c092901c20bbb520a2f06caa25b9132b191c55d603f34e0d34dd7abe613dd76365ace9edc6a3de8a871f93f871b4285d6f84574cbd2eacf5ff8d6b3f71a5fb1bdf04a9dc60376a8c27fefc1eb3c76c95540075fff6cd8dca743860dfcf94d6e0a3c165f23ebad06d807e46155c916395a7781586bffe90a4b3a050ea61bb07154e80ea9cdb7da57228c7038c1ccf0ea244b7184de69a97eca45bfb2223854d391840ca3c73766ce7a2ae582bf49cbb67359fdeb14f1ab7ddb745d0408fb584f1e70f5b0ed374d64a852de9daed6783952a827633ce1098d9d9dd5a2af9cf3279dd9ad8757a259e2c91b93e8af154d400998bf29d31154793e8927ec85116e5ac2c15bde46e51de00356039ce6f494719f91bd0e8c944f04a4f3148fc4bc4a58ba1c9c03a4ee80bc3c25e498a8c9abf45fda8bfdbf66233f7544e58283e0bf63207fc8901383c4563e31032f611c3e217fcd9fc3401ac23a4326af64a6d46bb671b18576677d001e766dbcce3529f62516fd7dc888088ceeb6bf36453dca0de9e8840c64a55347a3d4d02d10a924a1662b8874cca9dff08869664ed81cc9afe29552661ef4fd727c543df6bdf51c0960bc25a99673aba80221715144ffb0ce8b59b7237fb3ae1e998bf1cdba4db7b0965567b1db25e3e1cb709990ebbe63f916c94a25e5ff9b4dc2cc635d2b0ca50e28c7ee6ece01aa14690db5ce45c593bc8d2380c5fb4536bdb481670eb26e37597067188c9e634e57a50e6d51aca0ec85e28764330c6d7b6bb59852565b98ceb78fd71578023296074128076b94cff725b339270daf5ef3b12e62c966eb4f5e4bebd8c2abb6121c746fa9a241267e4ec321134bd0dae867abfab2bdb971a79d72bcfed30bace4a8343dc2f8094fc691d10f90e437427b8185e09c956a0fb1c36ae2093eec38c02a651a7987866c1dcabd490a2d6ae34530f71aea4185354cbf6e322342915138d654742b4109a0eadbb82964cd10adaab3f90ff37f4d820eea21161eb4c6915cea8c24fd7f92101f3b4c24bafb9de3af01f88ce5899b7b93b50c582f745fee0de5c3e9fe65e908889a7144a9017bfca752118e1d192cfbe3688053c875a8be32e4040dcad87a5419ae758f04371cf7e7b5d63f65f132c13968638bfd9f8e3dbf84e50aca1ae8d7c826bf74766e45859796eb64fe1f0f9504043e26dcbf04a75250b3d5edda5a0a01a28302baf439aa068dd4461b92c92acfaaa34ca87bbe7e131c90e1c4a2193acbe396ce58603560230a80a80b41a08f0a48be1f820ba9e01d5537a405e6cc64bd221ebaaed81e2c430a88cffb93f279db7823b5ea7de1da0cf63d57be918c5f89867f6d9e4440a51f21ab0251d0a62b40dc930c081a79e4aab150e6c97f873c8c3a106c128df7982ac2e92641d7410b83da9583b03c0d9bf62ba46e24cd91071fee19cb3186a16d9fd48cb349a46ba692a67a5b9305cb200fd6abe72875a11eba08b7fc4b3d1e19e4998df9e1d2bfc5445c8fa0de912d29f37cf3239d81d90bd8e8d24d54615bfb53f1c1a4841cdaf2938b26411cba23a3eaf4c02754bc7592e1689986e4fab6a73a498fea81ffa5c31f87abc266a3eab0793be1806b19cea02fb76359c738685f4d5c86e6a670b077ffa059b2ec1c14babdbc88def352ab918276d3df0c488116e7067de23aa68cad10e8fb7db1bc4d796f5b5153fe0774970a102a37f4e4c49d413a9678825d4dbffca634eee168294f8bc943ffa26016011cec0f4dc9bc506d06a7d6cd9945af5e6ffffb1b75ab9762627ae648b49f36998aa7ffeda0bdedabcda81b1ad0d11486dd97cd7176c4547344eae9f316be3741a395618f714fc4953bf66b535ba0699f98187c4f2e7c2d46a61a24e6647893c60a02e6dd259608ca2a32ff5f50fbcf50546f3e046e0c0accc970dc2a270093b9fbe61a3707d2ab6aa278dd35dfd8adae677ee6e37a6e405ff8a6c8a730cc3557e171e04b1d2c221c08f52fbc0925537aea8cbb8d4dca5a79fafcf8c09ab2cb8e9b4720ae9ae205ac2f7e4bb277d4c944d8afc1c709e157130f770988cc1a46c2759ffca3a59b3f00ef1fd5247c562003beac5f62b9af9a7ff5f17e5406c70d11fea4dd25880759a86cc89d818338696ef2383befc8e3956ffca020faa7e67c74ddc091eb3f82acb7840058220392a72c54d486d13442c7168266161e6ff7d085f76997b6a5b2c783fac047140bf6cf19552359fdcc2da703717439f8f1e37e118f806ed73fea8cc27250aa283a414570c87277ff57070e44a5977f7d240ac4c2f6957eed6ab43625dc6ad53f18d4a648733e96bd04e04df97ca97e27acf6d39a9bd2dc6f5a180e420f2e79dbc549388ff6d498f9cb280760f9f144df0aae72151836c8ed3fe14c18bf4bfc2b2bd5a5167da06d0366505328a52c85c257816df96a3a4c92f19a6161e4756baf3f43ca85ea8568d942a593920f59eec6e09d72c0da038fcc013265dccbcef4eb3d15f66e87fd8c8aabb92d625e33dbba91bf1b5799ff811d3995b25fbfb7c8f39f4cb212fc919e1f50206d60450f34718a0f7108840682a80048300c2d8d32c742448ccae9f2bf5f2f4d92092a6c25a95eee24875f920791d9efd6454091eb52c3794099c45a0de93a1b722dddc23307388419e99862db7f6e82e977fcab886d00d72177e1ea36f60d3a3b649881d720abebc489613efe797f7d031170b173e9d8c59c2f4d89bb70956cc9db9f8be6df5026d16311ef7de6802380458c10d51ffcaf3a65e7e0ecd42c4dd790b3b4de68476d1361c47fa156daf35105815ef3e11594e3a404b8ef8c93ffeb630e03dcd91fffe8b3ccee689f9158c049a3a685767c5fb27e3103801eb855eb21f9f8382cdbd71ca125c51ed5f0163fab8ad8d92342f9e7e79ac88a72727f7dad3758070254773bfc41e5d36dbcc7cc2474a828fbab7e94aae06faff0f8a4dbb6f5e51fbda383b337227f5cf083f076a34bd9c855a31fbd2213de14a07174485968304def74dcc1838ef5b82a5ff80dfb2d1e1070ef29788e1ec71a96c6b07513eefd7be8e61b3403a4244487a4a9736b4789cf2650fdee0f06dee5ac1149eaa688064488585da9352cc31ae8e2de2b15e42c0712c7778e0000c66bc1f6798014e06ec89bcdb1ddc0b53a046d2f0dab910ca926081417a9e31150da77d7f7385d789a277be699171022aa4ef72796f7c1e29e36beb6e223aeb6c8c2d9746bb3b4a55b7aa11f214441cd4fe50815f9a23f4547fe89512204e9b18d41b7485f224063963e91b81e59f21710fe31ff58b9d7b25a6e3bd5422f7f8c6f9886352057188963d7ccd17684074645291489e695a7d2f6c1841dac5fa870a868e216c1683eb83dccd1369e58892d0532be640c2f380cbafe561f82cecf6f49d183e3b2aa5fb7708ee80b74d813922145520138bf904c45f4630236d518bcd15072093b664b993a4ca8fb95c66a85fb9075ad1061f22e445e545f37c093b683ad8688419b3088e36f032b83b02b123ae67a665dc866e0c75564e85096e050a7b5610f3ace2aac5fccc54a948a2ce30d3b967abac082cf8096619fb2d1b12143a572910bf9837cb4636900ee532ddfc7b9b3e4326ffe9310f60883c6557e4c84c6854318e221ef5b03a4218f6c9be5866bbbd0545c87262bf0cc342cbb4f7d4f47a302ea2191bcb5dde5ec98c6d8b3476f8bae05130461b18861915e905abae66b618b2d87ea261bc3e8ce579bfaac166df515deb74c6dbf5b63b320426170ffbd6625eb7b13f4fccf493f48f4863ec98b6d2b374467e620340543b17ee94cba4c62722736ff3638220a3ff06fff337b28f3756b5f87da07ce1639c62ffe9bc99a97900baa636fddc9c98dfbc83b4d5b8b1cef3fab67395e4cb996267fd7937953d5768eb9f13f2852c24ec4dadf34febae950024abe10cf58e8b45cb2b02ea6bbb5a60b413e7f805b46d559b6c0992d5938cbb5a4ebb2b469bf442d0ba422b783ac40c4c42b2d56d5259790ee1d55f431f91bd23394643dc0b6e891f456ea78ac0dc5a0dae8c119f261ee7404d9d8d2847056838180f50677769444b33f6720026f4efb8cf53aa6318ee0a763ae83e8dfb698d7e11dd0934934f55ecd732f51b782ec850b1b2cdf6ada845b937bd302c4f390c6088922b188bc5a97395c031951185e8b5a78b47a951b78acbad2de0284175212ac8c7d0a190d6e339414a82b209c8fb2f6132754e297119ee0136c52b694c0e940524e108622c2d40eaa4e7bb0c99b3e34af0040699f3a5e4adb4ce269f955738a649260c1d55700a820304c9a9e752e5a38302978310521ce8db2812767f47d4de352f015d69c3f79c1205d839c01c867fb76d75ca104bccd5339b23c9033ed0353c0b5580bf939424471acae86f76cbea013b17a74a68c5fc57d62e6e75405e2511caac1178a5e7e30d005d1278fe0a59028ab37fd9dd092aaee85efaca5738985cad3cb186f6287c9703405562c7f76ace384bcb2745d3a12ae1f3c4e973c2385b2840e53703ab973058858853b30cee83d600869037e5cd7e3e02c983e52fa77641fb4f5ba0514f31f64d2131e4d4ec60f11d775d9759987ebb34929325f49b08ae977661c8e7783c8459195e3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
