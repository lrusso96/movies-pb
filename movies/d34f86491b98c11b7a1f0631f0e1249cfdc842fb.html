<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0417b80d3a374c8019d0b8b17324df7c020edd336c0b2bce487653a151598dcc8a7031e1216141ac01fa6f1fed8a99e09836a3a3508c490d9cfb3b2586ee8a02d705cfaedafbac759d9adf79cdd75e7fae55093bef027810e932650ad2360ee78ad330995f649807919db84c36b3569ec9bf327d1a3e5e3d932d0f39bdc6a0b8f2fb71d54a0221b2685a40ebffa54b2c84f021af28fd82e2ec3acdc4ae1ad7c02aca37b1699e0351820bf7b5ca13ae8146e0da7eab112569a6b8ac17fe613cbffc211e40c6a0827a2813c0e30058deb0aa43e61e6b7ac925e3b6f0cd0b1073a40f46cb3851c23799f18716fb2486b9d7423c007ef32b20223572aee427cbb3ddd5ebdb5c9ec1b52af239fc19766980d9edc4e209de8ac178772027e75554c3da216696db74e5e89f838e95dd01a602ed8a0a060956a2a532afef14769262f7cf5f208794b68181232112ca9d61bb18c8635a8b1379655a78c5812f68e469cd452c4c55c476cb738fc6193818fbf05e6c971a06861e3e5dd9c1547dd7654758f15356252032b53908321d215776d097fe8b1bb4b3669380e5ca73a67d8fa65abf45378a0e8cc0deeaa0b75484da59f2fd389aeb23bd3fc75a6472e676b85de3897b9c97f5eed55c7a9c97c057fa8bb12e6b1740ea34fe14774615a49b3908403e48df737ebe39dabb3cb93a2ebb77cd50434d74f077e33989796edc659014a34fea9bb05c828864f6a50dd8da9a07664f7340ad4186c994645656e19b56dfb7ccc9c4f62d60b1684879755e933d984fc24ecb2ce286f86ec0725c8cf29ca198cee53e1b2f2e6d45fad4e1820b3b8644262f15920c5c2729deb662cf0867d36b496ce6e6c3b5667ead69522a388af4c91b03fe838504496c9c9474d4413abae761a5e45cdaedfd97e8defe2ec6cf61e35548112fefc91d31631d71d004bd07fac0cafb55fce99a5a81e4c6408cfa2017905cad837fe6c7fddd4176864b097e35f15b27d25692c0a7e8de9c96d8e76df1179ef967af86acf0dec158fbc5a2839ac7c6dcd24d5c7d46c7e099336500e75bfeef4bda1622a5632372358b3e4b23598e791a838fd8543cb65459cee74ba6648eb57fe89a21ef136d5039573326fd46d1bdd7e6c3ed5cd9b02b0926e203fdf5abc90bec2c7d9dfbd8a2d7438ec134f2a3d73785a4aa4e9ddfef1e96a1161f0dcf752e1fa3c53540a01f1fb74f5ed277575b5ea944b34ceaa96c947f6c5aa956783b5822505d0d06cb27627237dbebfb2ce5b5b3c57e3518ecc8e02e53c87a6366213f6e16d9a5ffec58d5e6b9ed1991b90655e53259e13860532309e0b8b522759a7b80aeb28b04dd5d2d1ce8cee65211516e04eb0be11a3960a69e05fccd5060c3394eecbe0f29e8eba9519b9f1650a09de907f364c23d1c929bc5d407eac024b12e1b56ce5bd3a0881abe8159ddfb94a6f9ceb517a38d4df2da642c511f17ec4efc0070aae344af28e18be696a6a00f01f4ac21a3c2a5cb40f594648cbfdeb528f8897b5ca25c2d9813a1d14f2f133ab1f146e20137039da0e6fac0368fce8a9e306e037991150b2083b398a68b214f587cb629f89e2d5b9758ce4e8399bfd5f821673e397175fec41a39b90b0ae9581c6890f56659c050b366f297934ba7a0584930eb27de3b2996ac04b3e6aac970344ad4636b0cda369e9f69cd0665e05006b864c7b8a001f60beedea14a55ebabc66ad6771091fd1a2ea9719e535ed9708ec98122b3038f4adfc76832b8a51408068f4f39e9b2ee27bdb643ad60dcf3c9d5cafb6484193bd2b04682ca03721eeb4df90f1c7ce6e65e3a5c1b702055d336aca40b88eec559ac8982ae066c8574f0e077f93d880bbe1dcc3f0c76196cada6fa4f67865330922f27eb08dc98c967fd119128d59df58c3e02e6e1320ea09141244b6b661fa0bea50511cb40e38695eb27f4757c9f6f1cfbbc511bfd53094672691438c228d7e90cebeb0445455ae96681b6181c981cc97167ceebd1f2fe17347b4189d60aa85561fffabf8a1b93606199930c66cff4414ae376176c03e2017746c825955b385ec58b409f72dd3408cd8c01bb343575a0e1fc6f335417a0a2194a9280aa6f34a195d71cc242493bf7e9eba9013eee3d62dc9717804e9e611b61063ec5e41635efbe4814118894c458e95d52155c9fa747a1574e5e768e98ff47d35010f11721ea1f09dd0b01c19e73ee85fecbf3aa5a0baeea373dcf7ad8c0fc8b17465117225cbf6163135f3a9daf72ca701c07c16bd24228e9612537a80b190612223c4c121832df3f362d3045aaa764ed7028c64d7976a3fc98049f989f3d71bae7fa343e43bd2b9f39348104e8d4f19a612ffef9edcb94428221dd01de1ac20ce31d64f3b243e56332811bc6ecc3c31ac5703471da8db7b9196368deb398d339608e29abdfbc1a8395a3a3a99161ba410b0228a41ca58c0cebb55e06a4d0d89d6d03e3fd20a271bd2d915abeb4f849bf18f3d4ae9ade03db27933c4ee2194baaf1de3057b365f9f66b5f7a9192ca005b8b096da4002030c7cfd0066b3dcdfd71cc36b87de9af1005fadd675259cdfcd9ce38255070d23331e7cc4d658df58102734c404ff606184f4e5bf2b4fb74e087a236ad12dc36e1157aa78957fac4900f121b7f725d37cdbe13d110d934c85405aff5a17620114e406403811cf427d9bf95f0b8c865aa35f683b75536b1d7b18c3446c49f94ec6dbeeaf28bd953c6137e172c0b30cbffdf4d45b4c4ca0fa1e92fbe293f7244c2c1bc5b8e6727cf86cfaaba289c5d38a1a8f5d7c1107e6c6aef2388a79e640ee673af227b60d886624b29fedf4c689ed6bdf4e18896a95e8f5c0ef248e680338591c54b1a673d455ef03b4232b133ee8471573fdf288e305cf2b5cf9e7c248327e8c2e37386e1e14fad2d3947a7df86f1d1fe874543057a5179b6b536f99c5600b1a60c522886e8949870842a59c20af26dc9d135cf3998a40c0b0bf835a1b9237c9719ecbb2c076a8b2a09b332115aebfc2caf7c2a1125317348f43414d8589b0ea8b7026f8d87362362c78c3c05b64ecdc6331e65df53fdb39db69bf55badad96e7369f62d169b24a032d8f2b7480f5d0edc877e8e8ed0fe8391c7ea6deecd0b8c33b3bee33d3ceadc7380f53b94c28199d429369e3789f206769b1d9c8db96760b182b985d32a0a9716f16cd64f6f3410c8c56bedc096b45243104730c7f8f3cbe671cd8b2e5a5cb80a730566fef2539b9eb8ed89194d304b7edd7c9959eae66ffdde57eb4b460cbd5cab4394b01989a748f467fa1c9baeb60619689fc27e9b93d38ee36d526ab1d8ae4779fd4f8e705552f0b1db96258c1a22cb29a77859f529355d3e95a3489df8cea963803810aff8ad73fb6372b8ee397556a10c31db3664fbc4604ac456d9ffae3da8524744282d685134ed7f20134e6b1574a4e0be95bf39bbb524658740c599b0301de41074ae3b2068e128610f76cd8cc3cef2da8e17c463c6ae700101a25dd6a85ffc0ae19e36469086647e66c4ffc95192e41663366ae0a5da61cbb550dd2b3c41a2e6bcfa77c2d8e30df76d87cce744983e29f0a9ac290aa27459de55c3f724c8f8c08bec7c383181fc8175775b0c90565a2bdad19563807569920bd59187625fe5fb8f75bd94aca4710d974292e8103fd32087af869b8aed1f27b29ffef8f0ebb653e4b6ef80706f4ab13ff439e4fef86393d767a0d20322cab2726b1efc9a08c8c5c17760dfbf7cbb009ae7cff1829c68451bcf2a5a97870750225f6cf2ab91e81dd925b9843c2d02f818923fafb67617807b6f751799fad708122a1984b8414fba2b50b4478a84f518e10f781edb41b15315d10a390f5cc63a588d186cf0a3fdcf0b08910c31f5d444da953b5cccf3b05bbb5c5748e977b20d32e4125920d29803c5134b05e6b6c2fed7b5ed4eebf41c491397320031dcad0133c055139d4c308db36d6f14267448a23c4bfd949c2897ecbe57fe7685d237d2a73999dfc461a429b8d134b0eec16e6f181e90b241987d691aa798ea22cf4668bf7962cd2c540eb4d1990e8267503a2aafead4129581d0b381619a8490f10688fa2cf749fa1a64695b22b04940e12256b6507d38140daf3c76a429b4aad48aa6ad8e6686173a0a5eae2eb95913f290125266ac2ba75f53eb6494b41474af32042cdb58823a7c3e6379bd6191487a53464a31f0f8616fca7488d5dafa0dec7d81511bb0307ef534b1149a923b0953af7cb9f9792eeee4296cf703dcef9a166399f3e6cb08d12d76f6cf380ba3a615d4881ce6f413577e7e8377ac4e770d9254795fd441b42e4c6100d2fb28b18a284386108059fe531d63c89610d23739ca9eae31c73593bba756144b5e6cf98b7ea90fecda00f98ea98558b525c2d1f99d36f4840c4d98eee4827483774dfdf9b5380c615bc974abd97f1473e570263aeb5658200c5e955e45a39701e29f99f6c86632e14fbcc8f494d6d9b944a5e3202551315a9b50080fea11b857cd45b119619d3355d172a8e54c7c8ac4eff45ec2b4d61b5b533c0b301b400ba0a236fba58bd72adfb14cb69b74e49efdf37fb4e13b0a83c9ed5fdced7279d301980c0798c54b7adb302d3cc2dbf064a4c460bc74d44e5700e2be13bdf08d0d6c9925c0c07d56b1e558af17439deb1f6e2e5764452801b7daa10d8a24d90121e9c37176cc7bd346506f65ff906078f35e8159df6466509492792bccfc18cc407d985fd4c6e9b4f720437008cedd2c7c1adf728f094fd66e6345bd464885255137a8a355b2875769d8bb12a77320549493f2c23cfefcfeae8fe0673e1274c010914806c7a4695a68dce5074b49c2ee159c0eb1fa6883d7d8bd1a564598de390f0c484d7dba927fd611e5f754d491848d8c223eb64ec7e20d6ae880af717d30d7aed3333f06d410bf789b5168fb3daa74587aea06722b7fdc29af91d9801d8a3b33f544846658de8aa92e20372b3a3302606b386f2370ea7f2392047710c4eeb3b3cd4f07b25dd5ffae340dcb8c88935d7353b7e42f54732d88d9b0f5d2120992e9c672409ad348d1badd4dc9307483e71bc7cfe26e1e0520f94f7ac6e7ed6847ca0e6ba382fceb6437fe147ae9e42027033be12d97dcf209984d7c44d7d1f795077e6bd7d76c6059c9a3525871b056468c7ae75c0f5c6faf9e618d7695b0448c2b3f48b585326708f1660c73358c8af341e8c42146515af480a37b46a0e5625bf39b0ce4e0e6adffa08ab8f943dae4aee79a9882778f5705e11e9e1c0f5938379ae88a7202cf371f9c110784af0cffc75cceca2017d7612fa5a80a19fd82346cfcd6100cddf73434f654c0ae9242555efde3bc982beda29c81141f836c4f87f010f8dafdd14120341c2afdb332dbd7f0c2de32536c995cc957eefb8993fc25df88a7c94b00050980b4ae569c3d6bb74a5952fc46ef3f0239ee6c874f86534abe321851385edc62ce725205963296219388e9f635fa4f9e825a73f1d8169291a3275aa02a3c5f208979d6e091cf18a8c44c3aef010a1102a5bc820df6cd01ef66f24546549d5109f8650f996e30d6129061a8657aa237aa0be47769283db5882a923fb041d6e2a7cba0b527f81ad74ae178453312c7dde7bbd6d01e77c4cbb6bc7142cb7d876cadc6e0e090ef5428a0c23eb525cf08cc5a424ba4c104acfdf43b907472af8446c3e4ffbf43aa871f8877732cc65eb5ec2aa935941e0de7f52b3f10224dc4fac31311838e5d63d39aeb2cbfc7d6d8b928377180892d5174468d2cd3aa6b225114766f9417f42c0e7760ea161d0c5b2baefe7175d77598c6286a63ce8bce4582f0935c8668ea60561c4e2350b76a267d092d27966fd860b3ca12e47c49b5b6ea5cf9eb63b78e4c28d77b4a083c4516a4ac07fc6ba1bea4435e30eb3fb1e9cd861c6ae1340cc9f29ca9615d6562b879eb43b1e4fc61a56ae78f4d2b16f1253524bad09806f259aaa56cb1161c77e2590fcc8e841fc2bf58b0a90f072cff9589a3670d14e64338668f5e74eab4104ac15f2000d22ddd02d188778357309ffe1217c476c034c4aa2057b609969aea7a109b49e768e8c2c7442f2f68fe012f07ed3937903ab2f49ad542abfc3b6635b6c7f0bd2eac4b5c448c193c1442864594dc9b69900a97f75bf080fae94b19a25467f45abd62ce8febae624b3c1c6e938ddd4d0b62b1d0dcdc3498324dbab03642460c645e8ea992a422481a3d8a200cf1fe9242f00410aaabddb88aac4cb533e5fc694b9fd5a3b04cee83c2ab1f0928f9f5296920bc0ed9a0403b2de43ec2cbc8837368369efd15513a058421087c52dd8343028ac38e309c53420f0c9814b96f1862211b673557518ef289b487a852e736e0a94b64c828f42d95e0b6893fa2748309d27e14c60ec7424804ecd7cb968baecfa1a3d7b2b3423fb19c2b261f171e8895465c4f0a0d56f656305c8f5f53a19e94922f40dd478e1ed6c177657cabb3335a994de6ae4a144249f6fc487e9b4130db6ee8e2bc278b0ba47948f2628f84d2644c8b205db1a5c09645cb3964197825d7f80fdc1233ae966b7bca1de843cb4577453a8ef02af9598728a244bb21f63ed55024bbc4d54704a65bbf15bb92cc733b1720346ba8858a719ec7c7fac0d2565de6ae099b59857b95ec639093653f4a3b40a9b1871055e888735b058ab584ad67f01037d92b5cc75b0f76938fdc336e69e2bbb9ee33e6dee7412c9428d1cdba1f56c96269404f3b30c928e6a0961bdcd4a1c279fe7c6d63e7753f7954a493350abef990248b0d26ed8421282db2cd21558218d36af1beb69231c161e75669195c27d4eeac573b1d0aaffb679ab3c47600f80d60a9a7967ba7d46bce3ca7134abdc25425eca62ab0501789f82393545d67dcf4592e6e6e9f2deb40f3f4c13c159dccdbb818e982bb4a4f2a387c3514aea7a64a6a0800a48495cb799b5ad58cf8fb2bfe8fc0c84ab4eb4ad56f3e443c8f812da5f5b0b0740c8c7696c1ca0eac9ba71f87730c41691234140161fd6840983b1e8b8ad8df435ef6ac9ff46818153c6e3160e00b980cad595dce4cf1db5a967eea4c7b6437a3e32eeb678ba87aa59ae8dac28a7445456a573c0e94d2713c9e83738f1d6f455d5e307486cbd47f54b3b14764dc4ca2d45ceeefbd31a8bfde3eed886b227e42d05a8722bba8b1ef82882df668fb5cd3d981f6e4dd894b1f9edd77644df1f6ab1529097ed3aa9a152f1f8c867537a8f902b552d174548927e5812cb9659dd24c5642c66d259f4b8e636616a2738b1bd2995e7753b0c55097cc792e276c0e70042db6bdacde0dd329512dfce21897dbf849caf32f623059ad70e7dd63f80515ff84785349229ec38c0a72bc3bb51eca838ac179910000f8b3d3bd2f88575d478b2e449b59c39053fd43de79d804aa4509bf017b4a02b2320075efe0e0e02d1d2bd00aa511a795c0d7c27fd3867fe2a9bfb6f7fc970d232b2331954d01cbd16efc8e63ef3807ab53d3e153073e5c63bdee3a9320d85b69077f6f8f46472db54120a42bd5787dcf603fbdcfbf591234d6d3d03cec831ea76bd310c2cbcf2ff814e96a9825ae6f3625dea34195dedae414963bccdd699cc4c9cd6ca81f8d8d3f4db84bb2aae349d7e1065dbc0f18ef6b547f293403c8a8c157d66d4eaa96d5d7e2ff8e66d0ecaee930758e1ae21ec2dd6bd8d88bba6965ea7fdb6c54deea6941c9c224e6a7cd0e479e2c02b8bccfeac1759ac0e208bc77a363f8456cd13b85a1bad58e13e4fd48dc4ceffe7e98ea326b421672c79228e97cee559c92e000cf2f69daa29da8378a9e440b8c197ae12da81545dca22f893cd37f78e4b2d630082494617874d15afc0037b361e6b162f7d52b1746862a1240dfe160213378007435e7dc2de6982e388cb5630fbd270b652937a6904537ddce8107095a83cf3a698d2593edc6056e7f1d776aacc7f594f2b576acdf9e2c570978f4336756c9897428ccb507960e5a28a7809cfae42f9895e644d9acf668f8ee6ff874f2157d11ffe56da07c32f0881ff349963f0c3f3d1a6c7031c17c1802ab3ebecd8dc7750a11f100ff8f2b216e8b52759c8a6abf86c8f40cc24e3051a460f4a923bd113656e8f64602d5acde023f4d353a18eb65a0ddd0d437d715c23d6143d3c0477ca1d159bace2a9d85714b407c4a4a64314e622ec63df81685190dc04e9e21f181a304cac41d5380c5907e022873ceb0f5187e6bc38d1331a7a374bc03552ce6108ced59a1a4cd29aa114cff381e9c6e7fec04c2862f4fc58864218db7bb52814b7f885c7459af8f7aa87a60a7fc9ebb156861ff06e8bf0a74201cd0573e24a362116a3fa027fe261d0a7e30b013acf828063c451802d42db4088bc1158c6d8529ef248e9faf1a72396ad346937208c3b2622515ca2fd82de2b08130dd7bc0b05d2c1aa87cf1fed21d10e1ab79dcba5e0cbb307e00760408fd48e9cc11c41d3bd6eacf83ba3f14f434720cb36a5d5f929c98b83b0add9e6cfee7ab22cff8a49ac8aab8463263d00d268bee9d667ed315df6ea1d5dc3a9456556acab85ad608a5ca2e739251fcbabe86859b87278fc70eaea70f774bd5d5a5366d9ed452183a6124d942eda43dd68b4e18c449eb7cf20d9d59d46b8e78ff421f52cb45f794f1344badd37a3e277abb265091002ed215b9bafd4cbfc69a33e71d943dd50ed9e2cdc7367edf24fde94f119d01275c8c30425f17942e6bd0af7322ce08b92424e3d09b101bbecdc95fb1dbb5ea83a84a2852f77412dfc729af961886b9541564a7603bfec6330de540274b0baf03b216ae9fcccae626f18f5f138b448f5650d4567cf608669cd48937cc46d536d8ad4c69e966502624f545355458530f9d904c9aa1296485f396f8c885b53e25a6e6f61adabb2729c3c495832e92c2b1ae9a9c2440a0692d8e94902e3c07714767588a0d512490fa15f7f2e6abb409bd890c7c0f30aa747e93ab7a99ca5d8999e79bdd945147c319f2072090fd1785c590dc17f179deac183657f4f83e8fb0c0a5e8c10de654506760d41f41fc94e43b28a33fc16efeb04988e33e7f5237adc38b9c44928e276c88332370b1e4becceb2a0c7693ef39180ec1235d8df7ba60f21eda77363e7843e789a5fd12f095c7762b21aecdb14e69c75f580328df537d4cecb7d89e8e5b963c881a97668cce36bdfe3be141e85d0fbc0066c0f50557f44fb8893e3507c3de48082b8284b52757c285e0ac9fb0771ece9da02d99659b1d3b1d10e70930da692e63873d3a2cff3a23d09a0b7720bca2e013df605f2323df1d11ac0190488aec810fc659b666d78506a111d3b62a6561e70a7fcaf14dc5faa748fa90d59f5b398524314cc22ee4a74c3757a302985c378d07a4afd710baadb973e87b2c4de53836ecb65073eaeaaad8824a919d4fb1569a239601a08c214e685b3385459de3e79f902b42cdcc074f27f3bd4b53b7bfca1ef174ff022c0e9fa4d6724a3b77c10a7a9d2f48240a48d1d91ab3152aa5158ffe2688d30b76b966a08dc2daf3a17c65fb5191e78c12666f1d4e20694a3970d26a9cf29f2ac414a1f4690720bd2a1f3c168d428898dc84af029d17028c847c76b505de026d56f9421759d281a3e81c7cb6fc91a222b7d7d704896fef62a91562746d8580d62c1e8b0b35aaea47cae7b1ace6a0d6eab485ff58684682a0afdeba9fbfcbf54c69aed7f2f4e84552469b85f2475a00f4635f5da08ec8e28e912e870a875c5f2d0bb0afc3bee30bb0daa1cee49220ab331a388c63900b3edc70daa69a9eb16bfa3b5df6e9c06eea2fd86d93ec969357a93defda42c5e1c5dd1b1ad8c3b1fa90c0817246346a5aa0117a44e223be3511bb990325e6dc543d164713ea81318683459f585e7fabad77bdd76d2e892275773ff3f60fd7a942605a2c3c4f1a267a59362f1bb7583b85e2f6a9f5b7831870af9c866b99080681962b1eb1a9a705e8f14d996b2fadfe032b4de8e541daa2918f84cfee39fcaf53d1d044fa05140c980e300301f4c854837803514165ecd74a70a124b4308049aeb33f611f61a9bd2b7351228fd1928628456c95bcab22a8a3815285f73f888918adf2f4ef4a82ab9cfb04d560aec9809299aa19d1487dba5b391992b3515bc939178b2fcb393ab96527c78da780f23dd8164ab6e7d756c7cc582fc86df62dab051fdd800229be0a6aeeba8c9c20ebc845c18021b31b1bd00b4c31076003bb9aab9f3729006fa29ddf023481801b4f293a133b1b99975467257b9de0953d1c7a960a212988c23bb05bdc575c0752b968aa33adc4663f410e69514359916af829a1818804c36a590b298e86ec6601a592b9564fdf81c4aac4acb546aabbe7a32335a853264961dbdbac60ca15edef27e6d8368daacc2d6f4653b64439fe1cdde78862dbe41e3bce6b8a9af3667c01efe375777497c2359f256622df2c016d9de7332ecac00f96e979b1971c3aca718fd96efe29e34113eebab8be27e37e16e7bcdac64c34bf2b8d3b1d4025fb1da99da6e799f4fd0265a390f334d1bfeb56aa7e9e10b76ec7f440bf2e3d3e2e65e4d6a69cb2c5755db91bb47d60051269978f780f0fc07f335c14759f92f1b4aa75bf411d645043ab7b85b7701e737ab641f20a2d056b0c1ccc2e9d3ec31f795afd56b286fa03d2ffab9b2e87679d475486fad8569744f7ce8e1aafb07842c1c904ec126c05f954752d8d5d98b7c8e800aac42097f8008958d295c47864cf413857883d96c11472b222c8dcc7c0d4a20e4d955cf8bc4379344476f9a978600ec6b694bc0d22e4130eb63ca4aabffabda0f99ed22f59c1949129bb5c04220b1e88351ea00b82d372595d8df6efe7e633542ee3d494438330cbe137c446a5c1b8ddc7037c6d00171bd025677b3e08ac83eff16ee271fa9d49fd098abf5545fd848cdc152a000617b2f9c8404a200005115888b4fbc811f887add82015586e3908510bdccfde6280994157cee4a6b4378f53cd3eeadcfefd4acfc516b0a54fcf4dbdf9d09a2125971b791a88b05e7447547911239a6cb7e28622d2022ce14c1196500b76e8b971926ce1638aa78b3c0ef523f4521b7a40e6a88fc11761acce410b5b11a40d076cd3768d12daa482cb7e8647c79b5521881df3dc7c1cf7b6a06a1eda653abc7a987d9456b6692018b4edc08a4800186a22778ebb7f5f26f384279e14347aca20f3aa17d8b706704f7b4c2c3d511a0193a4d782c1a592274351950f870f0f6764eae27bd36ec862c330bfb3e56a5c4710f6290767debb5494497eab9c6a4929b7191901634ef2a4f302f79c450e9b4ce479e6aeccc390909c51854c4f9b5c884020e18517ac71210cb7c2a1f93ee9835c89076a2a8acd8c94e07356627354d9b1c041355c1686ae9a27e0b697c9d0f79cfba7e1aaefecae225579b8a2167a601de62add737c9c5bc6d6fb9eca33f4372e7ad594914109bfd625a1640185a87bc3a52eb5b823af5f7bc5daadc01ecc2628edda71c47590100188ae35f7e1f06ead3393bfb58564d3bb6dfa7d280b87877d1d96dbb50a857b97561d755fa2208f7d940a0de8a74ab329ec02472645cf50880dea38f9de2318f03650e8c7ed62e9b2b868726a499ef91bf786aebe2e2e37e8571cc24ca6525573e7af7b383c7aa4ea827a2f6ba814dc8fbd976844a2b3f72e22f441dbcbb3ec09d845312dc6ad7a9552e788e297f2b45dd523022b18f93c8c8f99f85118f8a83bc3f8a0e405532501a66697f2cb3a3acd5f615678341c5caa72efebc1bd9e2783561a54bded04d591f93b7f12cbf01002c3b6d2b43500733bc6a189cee7b63a104049083219962e60e95c2d524c2beeb813904ad49d80030ed761950a50abd93b8c5609f7c2dc36db620ecc18e96a36cbdb6c1936db9c7e2d840bd12590937b8fc50f2535f04f43ab3351c7f18c858a52167da454f84a932d09246f73115aa452ee8ffbdf1e59163c647e8b3ac6f89c699095e2e517287ff445f265c8de0545e4d47df4fcc812f74b5ddbd1ee22944820e08cc6f3d3adfff1d9e5d24dc6b62bdab6d1f3a7bf4f695bad19bea02d3f874b18d3a519ee5265d3ff18ec09596b31acf3c6d889becef667fa4e1e4ae154d65de7b40e270a49bc2c32f32c7583e2db9ee5d3be4a90e4790ee9b7cbe9794cd581397e8fee1daca8f9fad7c32c168d858e6a80d92dc10489c7ce33a0a4f2bd3e7e3d237c23655e1caa57d1a6da43d9760894b85e5f7b314ccbca08f5936e9bf2e7858f654fa89e05de2aa99d04ba8b10886283cf98e9c93c925b3ab07b9e1aecd5c18c825f93f04ee43a8ac8869c3cb7e5d0ad3ab7952eacf88115eac219074a883d3e31d15e26fe42313539529305ea6c365065fea441b31b966c837021a10f7adbb465649f230a90e0f5fd5c969e42bb44549f1117ddcd576802064cace63902b844288060ac317396ea79aedcb407cb70c54b6a13e9d4edbc36c487ae46d23b7efe98c72be8e00c487d32ca561fbb72624118a2efc35eccbe4b55a91a593b021610994bdfcdef1ad279fb46077c66e3ec9a357e3cb2e67021d8dce426bf22b081fd1adc8a9540ee52c920b369f2f81ea59bad45ee6843a75269255da7c345362231a0f4d32e5aec82ca768d06c3693d915de82d7488f338cc2cb8d9f160957b45cbb662c21e25a8d569f9c7678a2deac279477b4bb2917ddfa31a4c6bd6b8f6225f4377bbab65e509e57cc1040bbc0a0528ccdb42b0ce376a95ea7a9d0d69b6f9b2dc9570bae0c379737f2b9cc2349943cf1d729a4bb5034a24feb827097433002c4fc74a44aa4b375c7b20bbea1f2bc674e5fd83195ef54165705aa200ed5857941565795d68bc6f7e16c9a11f57fa8430671225fb99050067f93b67d739666fbe1f4123a0c3dbd87b3574c18e201efb87cba42cbdb0f25c598d91a4516c6c449b139212f5168d3ff5c19259246275d223753b729324fe9fcc060b1a6df70f1e318de763e0984bbfecd54bfa3daa5f35a91ff8c129dbf5f51d56382da461b6dc89337430be42dfc667dd91d3c8ba53b8d1a8fbaa3f85bf4521554cb479c8f12404b91fff1c40626562a716936583af5aed6c67a68c408d02090e63cd9b64a11cef668ead01e12b28c660d9514211c831aeb985b329e5788bf52c137027c139e13b591f74211d5a4d923008d15924986879b7097db1f5cfc0a326935b22e8f7ee384a71dce53e358afabface087ca5db69126b6f1489c52c86fc061ca3a6df71","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
