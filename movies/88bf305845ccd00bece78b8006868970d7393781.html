<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"46b0174e8ce67e181d8f354b56d7b754650c26f786c87bb75bf72ee04641815bc1686eb46601be0f557464f1ca3c32f27bcc0a442106dde6515fa406138e8a256c3fd62c22f90bae46dc3bf88cbf9929cc1cc17dc3b1bdeb5e59c549fc7a1bf1b4571cff8844db433088d78c6a514d574825d69b01b51d9cf336ac8d6ed8cbbafd57a56f082852546e15dcd6ab96a01e15cbe3114e3ac99fcdf103412133d15a873c071537f432d4561afd7b0cafcc91d19a7cb5f2c7a82a43a122f04e9614732eb30a2e59bfecdfa6ddf3861e979fbc5afb78ca8cc82e500207b51842b22ef476bd581fa5078cd5751b4f1fef60af60fa4263d99bd4f7a0a921b9e259ac584d990a05f487d4686963c865c4ebe9b7c18cc912f8e0e3f4f9e4eeed2658841fa6c418b9f2fcf29bdf247e1f0094233a35dde89cbf1e7ac8f32162a943dcf91be6e22ee2be65e4aa6180e7462ce35e4a739961d6f1fff7e5b79c3339e8e6e04f89b72a57bb34eb4e96f8d443b306dae4e1929be18c872229367ef7e9ea9c0ef7c9ab60aed23d94d3b16eb9dca25ea83249ca850ef7c6fbfeedb64e2ddc4ecd6e86bc7b3cde4206a3c3a1a7ac38c00deda478a488a5b389bb6a6faf9e6cf57872ee3e50c928fccaddd44e2021b252be33e3d72292af5178c4763876ab16d6098c01fbe7b204c339931bbba484e66eedb1fd72637380b6fc1ec72fcfb4427b586ed497ce497c89e531a3baef12695c7ef694099453c5f12a192a502eeb1277c4b5eeefbfc4ade9a087eaa08b780c6029dec97376f4e39207c293c0befe4598bd10a99fa1dee3d7fdaa3fb4e8524890c3d008468d0dcee041e20bf1ce6fdb11c4eef7bcebe9208d34e0d81d68a993bc3e3a94be80fdd85542d1a21855c28295bd6f0e6659b3d01230d37083a6fc297ce911f427b80f850a75c3960d3b1b47ca33019e312db6cdf66df69ba544452ca44bf8dbd4e27266b177a78085d68972639df483a896bb6cd13c9c5fbd425dcf0b1aa7f41397679657ebb69ec14811029751eaf19dcb0ba875754db6be4bc2431627b0056ea3e80241028fda77b961e7c5ac2d5e6aa7a82845611aca4d5cd8e550f04a7b8e3e8d408e805e02084a23bea450c3d46b4e1694842019eee6b948c4b11fb06a669c83087e2be7b165cdbad0f1804ae5ed192e95700fd755abf8d22b2e6f24577f82603ec42770963f330a93060b5a6d27e0b30e146bcefd3f31a07833219065f2c44dbde734d4e2457975a557139007d3fc776e37a3bb629e80859a723dd638312c0c479f684ed211c1757fa8ed9c234a456b74d6a6cc81b2489681602c1910af9f62da6b00a26ba1df5eecbba63af8394e9348226055ac6ad64340db08c24e70d8e665c28d82ea3158e6a577c12e141bc2eff3cae6d9decac06dd905edbfcad536c35289676bccffb0b00bed1991ea4920898f711616d94f35e30d4a11aabd0f41c9fdf0c966aed81ae963b00d9b55a4288a4562354d04bbc7d76c46b24715600720f0d3361bdd2dc1d9f91baf0893a5ddf17de06905e2405f22e15401d230de47d37b5a8f2be80f85014a52a5cf410f586c5e39a51d8f648f1946759eeea7ee7586d8f4c8b4baa99cb6c2ac96d9d381d7a08b4607debbf387431f3e55008f13c27f945e7e57e95751dccc67775f330b05bd28e8690b9f02983f58fc0b2cc3eefb86ae0b34f2b52d7c9e620804b71db65ebef981f58a951a3422b6fdc3bf9432fe2e133e63749c55ef3b819eee73fc74ac8e990541547c836661fcb7cb5a95b439ff2c0444740187a90d6962c1974fa4cdccb60b71aca8bbbaf7d958e5266c0fbcfc07dd818c951ca0e71828e0a2911a0c0fb38eed0126b6b728fca89c6c14efc5e3a4af619fcd0b16b205db9b87ac97fa51586cbdecb013b24329a778738a0003c8af85ddf245f44c14b94ee3a50bd32454346f05ba239b32acd7663ea87f67c211166dd47df32f0f3dc7704d2d6e7eab1488e0ff1014c65b01509da14759d6a38566c8928f316f6039bb97a1f8ec00259a491475646774f3d737cfe582a2fff97dcf2807ed14f732034679925d9c3f11fdf11ec09196c70690d5e84e55922aa36a8da285c86c062d01072d17ca71a6dd65fbab750078032c5b797507925905ed34d3b9092501fcdcd271e93c5e6055e21d522fa277c613369dff33104f08e440683ad6423f4da8db5774b39b28cf316be2091b651bcad32f47df8df04eec27167001dc8a1ae45afdf5a6d2555dea439698f29fc5c9e22daf3541c8edf1f0a4c264a7015f7e10532cc2f61ee601fed740d8f0ad6920144e6ac15d2b4fb3cf77c2d23a24641cd1b0cff3b0e40a0f657a9ec090b93392b825f0f7e8816daeccf85e2fe1847b28378502832da4fb7aa1c83f2ea07d1e23b2a0fc8715c7e06338aae95ceafba2421578669437f656d635e42ae28f9854ce4fd2df0c7058fae2da190d9536c5fc7a8cdd05e44eb3a971ec8503b9db08298730466579fc5c141c418a83eb03c4283c63b4c6ab20156f95736cae70d1aa8b2f44b00aef90cfbdf131d922c91bc26be5ccbc6f4235f36d4234a9539d2003dd09fb04ce91e6ae12658c0ec923a8097fbd96faaf1fa244c4657fd5597d3c1c323f2623098223eea9ec63d83b5eabf13bce833054d294754ff23e8e11ac76ce44816f7f22fb93e3021c6fc57a5d2dd4e06efc5ec573764a52b4b340ad276b7fca5f76880ed684cc2fece069643a33fe1cf83adb1750b64c6ee4599759f814879773f85717f99a361a204c16bffc85ae6d746568aca2c2958caac3f70ea1ac80e0679a3e3a4e4de687448144077024cdfc4c64f5998b200c5926c2e0af85e881489b027a5a541b3fcbbe336ba89b1fdfae932663857a88094d56e7a94fed4e2763463b0b4249ed7a8f9c44c7d4f962c3f6ee2d31c7e573ee7735ebf3de741a3fb5e93f0190a92fe6f4faf60b99041ec6a88bd5dded9aca40e3fd3e80b4e42631a95e85ca38f4b08c30ec7ad330ab93cd52f7f31474765b65852dc487ea623b98cebd18764e99cb9094b458d2a04feef4dfc8c5fe342bb1f70747dbbb609743d3cfe7c6d57c4f9da1db67748a91fc63f155f10bd284f68d4a64a1191f3d828f8f99c1e28abb7174da1ec928948e4bd76e1139b53641d8a7fe946db2f72133a6d33575fe36b79b611567c55d413652b452cc74107fc591d4baffed9ff14c48d5913ac3d48d311616e11bb166f13b61aac495dfacc7b33b7ad77f9a6138fed31f656c7233d723029d69846fc5c63395a43a6f776a6454166cfade2153223f44eefcba68b768502785e4acbc493a619dbefc5b0f110cfccb8629a4601046c3660ac4996f17d558d760c2071d3e67b0e60e6d1ec0ad7d3e831f695b4d9b136c54bbc6152e0a00144f4c1f5b4dc2353a19df6d1b3310bcd7b4a78cae1494deffc5a752aa3d43bcd3540fe34dfa93a2ee35b1168cf455ad80c37d27a75038ce2b3798ac329e567a14f02aa25a378f388309d973e7f599e48029fdc42ecc71414caea31309a9d7a769b0cce517d1ae8ff17effc8cb06e4a10933ec5bf2ea676fb179cb4e9ccb8925fc518d99e744341700b6fda48a891ec20d64e999f21224a6157e1e33b05484548e3de65171cd01e1a91e408729eea7ffab4c0ed3eb9a7aeaf2940b44b751fd569fb5406bd875bf425c0170e9c805995e71350d0987974a21ab49ec78a913d2a47818f8529f440ec63471bd832cae81d26ebe5470ff9fee1726c494b0c4a427b54a24450168cdb0048477690a3e51549a46a2c81eada5ea42dd5bf066a7c4c51dad295d30fc69af1a320fb63339583ee6e4a2600ef1b0680885d0fab298d99349609e61ced50013b8ee95cf5550e1bf38bf0cea6a4211eade1293c4e372dc875737d652b091db45dea966761da4c128e252169ef9c15ff54297c1801d626a914b4afa005c773e4eeb460cf54327844def8c2b2899637ca5784a53863cc203a13a68a8a31ea4dd016e3d10f9a36d3d88130445d950e23064b0ff58b65183ea9f2a85d04bfc18dacabeed6f70e0168922d0efdf04a6f0d091332092f9cd735aa6138f55701baecd69c308322f70b9611f12d310cf772549dac5ed229965ed1928ec75e93f688acd76af69ce345da1f3ea40b8852f6752e805513016fe4e250d8f77c9242f88301545385e4f5b5f615df916d2bcab2cdf8f9b74b3ccf1e24bba0ec72d04c0bbefdcef511529f7f3ad43067c8a6bfd4abb4a3724f9de9ba5d834a6c184ffc3b873b005e630343032a8cb6431316948077f8c042b6192e0b17a5505b822bc242804e6271cbd8726f7dd036a17eaf11f40fd9a04f0442cd259255c1ddeb41eaab7ac44909fa689f0e87553e8c5558b8d9e94fc92a429d94e59c74574fe4be31cc8b73f22b7a7b5976b29e5fecbfedd1f54901c886354d3949b403abdb950d6469760e33ef9a87eb0a956816c26772a66e58f4ff095623f5ef2f9c549eea9f6aa86c2bfdb1e30e2048d5e59103f7b8c0b3e4997b778f09e241c0112b667e9e0dccbae94cddeba73a1aab0abf73885d5a1724c0a816f38724ad0bd38f73a803488bc92bcb34120b51e17ac2ca8ff6e7411d78bfaeef609e4196fd4f9673f69fc601bc8b387cb6fcc84efa1446514dbad8a61525251a9ceb697462c05a9f60aba4b410ef53249239e71a7002f98755adac0a10543129b554939b8fcc1a8f871b7d0c7fac43c4195a522a0fb37a2c4d64798fdf20f7a727e290c5d8fee1a2e42c01460008d10cae0c0a82715dc0975669599734f87abad582d92e28f591e1b25a54dfdfddfa4b0738210706d422c7f4208c2c9f55d0a236d26f8f1db2153878730ad0be1d342e14a5638c4675895fcb3508aaffd42a60b267c0df0b3884b3329002612675994ffc1f5112485e0aac233a91fc9ac0c89c820e2702078a90e6444aafb9dd5bf959d6149f24120c040cb42232ccc183f1f0da16533220660cbd5be072c18916563e7b4206332ad3ef6647ab34a31e55de37abc1e5889b1944e0a2493b59a30ee7b0149029b3557382aab96cfef558608a5e1e5a49f9c666f640e7e387206e8473783df0ea1957f5c94bce12e6eb5951afcc177ef614229d3a833bc6f0a1514db6975150fe1115b074bfe3e02ff7284233567c4ed365b94e67ebdfa7e4ae4af4241caa22c60a43bc3948013b815b473014fb2255c5b94dba62f4e762e42390507c501b6f34b00cb702917bae8114d9a6b9e855414cf20624d0c8e517873f843524316995a43c8b3e68373dc8eb9a26901d23a27bae3df07088f414cbf3c3fc0ba9e5e8dba86bfd16dc7acaa2d7c280660c6c7e71e42099927da6219356d306eeea818a2cc329ad85ef8712b36895fef4a6c0dfdfdb79f428618fe5212f6180788b68496580851eef8e1c6999b9133a13c3ef6ed03580bf9af24743c61f690874ac40d6aad24cd3dacb9e1da0c8ad929464f21528e5b8608718b0ae8c887743775a5039c48933c8b2fe2ffc1032d88e5a54a320d022dcfab38b74e77c81ac7e993fcb25134d5dfdbfe399d4d3da4052a863ab7cf321d66e7759cb12ea7a7386999485c260005d6d78d9683e29006a0fc7d1418782691fd02709cbc6c49a51d783a8304d0c3cf892c17eae9574d686aa1833d1f5c16b3ab4722743dc8458abe7e0ff01328a0bf428c49a48c17b029451da86ed0bbef6ec501844ead5e32001938d4543b39afb355b88e5f9b9892a60bd453c452064a4491532f22910b2088f867bdcf6eb40e8ef6c726aa3d038b641423af1e19cccaa684c43ca67920d54ca566624855341a23c238fd66af5d8bdd611940e28f6cd89e513932281c0d46234ffd36f2d71ce145d1e18850029bcbeb783d854df69d9953f7f7d6568ecb950cd392c00b2d0f2bf1e9aa3e80224ca0508917c373c02e10c6369aa18d0882b04cc1e26a5348bb9e831dbe6aa01e51b9ccfdadbac47a4dabfec072090ef82c319e8951cc79dfb6de4738a6ee93f45ca0b5f02bb5b3dcf62acc5f9906e5ad734d809b7a799c56c1e0119ce71dc8da7b6ccb5cc3475d6619ccebdb40e9be4b0c0d6885a15d43211faaddac4c5b4e41ed1b981d7af4500f6c39de401e9a600a37683d0cf49946aa8016a6f4d4b4c09d22e7e0a9568e60b5daec7da8979f70ac614db0fafeedd9ad9ecd88618fcb75a275cecc265da5cbbf8b39064cf853fe69322ec99b4c240286e40b242f5b33a1057c872dbd109e9fca8ee5cc15a5fa034740cebe9b679cdb0518ca4b4f22bb63c40a75d1454f8f2910699c2938ca73dfaa1eeadec53565ae9e98df0ffd0d2cde1c6ca13f8b8c644c1b4067e51f8aa93308a2c5c5fe148044032c3aa8c27562550301c3da6bf61831ab67524343685dba935d30879000bc72792600e7b088efc1a8b4082398db32ab53c031e692105f5d943d2590ee2f5b3008615b6032fc860a812dce73f829691a7cf7ee5328cb77062b03b256fd69033a789aa1c42569c89642b1d58947f5ef0065790965eb280bef381e6a20e545cd088add8c7c3b855fb7125d4108e50c8f34f798c42b30524911177e0c6fe367c6d784499d89ebf4be8dfdfd42044a5e43fddfe14e52fa54384c6c6b8fe3be3182a8261f5fdcc6418d1ed04fcf6f0e3bd98f31587fac322e22c327e1e27427dc3909cb48e783098884a2b34c744f551baef4e3826b49622747dcd4c741bbd6e07acdc39558e77689c223f094ebde9820a299bb04fa6f62240de22f526de500b2ae94b57026b82b384ac0bd32985bbc86e734f1acf19d46f9ec9c1048aca92bbc1cd45c02645250998b6d2a013d8045cb5c0b05e8540cff83203404cbd0cbfa977d5efce9fb5759e3130cc562374769e37e2a7d124ec9a235e1c1cbe8f0d8a6473f8a13c3bf49e8e176f4959c01b6b9270b46e33ed7f392ae9c19971cb5c21788ba06e37911faa31ee976c837c887ea1365ebc4071b5b0f96ec8a1ed6a9c4c2b11f0eb4cfea0e28aa399818cf76e8cbfdb23e25b0bb084122919b68bd8f163c7da3c97d0d9ff7fb7d56d2d5ba0f12fdcbbf02fe34bb2dde417f901e9a48914325f439ac90a8a1eb4ae9945566c3c0287944616e2ffe00ee2d0fde366a883bec3edfad21ccad1312703d2d25ca5dfce14fe464fe8314cafcb128af8bd293821e8afff2280a9d6a2e252b3a3296e594a3484df35ca1353804100925023ca756639fe5bb995e6f4071f6fdcd695d071cd9492efde8302c92bb65f2ade373639ee4ef548f4b9e4161d32634d6ac269612d17f23f00e840163f1ba17c6b43209f6e4f54824e3c1779c62fb9413e247e4684b8aaa6f867cc25264de30a67fd701198c175442ad31f35a5209408fb25960ee41feeadb464a206c2ccd5adc714884e568d57aacf5c834676ec2eecfe7929255477fa425e2e7d0a7faaf8f129521ab01dde5de8ba5a6c0aa24b84395e3f6d059c53fa71b757afe0b14794e1950d4b6f551dbd81168d3caf98484dbda888aced90f5681623e77afe80d910298d5c4f1fa048426552d980680fe387b84c51e55e968666887c1b4197d46fe2129570a7cdb4fdfa7620ed3950115fb365f4b535a9d03fc3116353831d6f2dd1c4d987af0350cae8983d0b5ed125805e31016865ca6185d2fefbfd8078c07349081d55bc51d6f9469740cc072bac7777ffdd945b761af7f0d45961235acd3b7b26e91753ca9c2f1b0957829c53e21c4c40a0db534b026d1fc51f683cccab8726863ddb2336aedaf7d04b83ccea158de13ff5cb285d6332a49fe5b3e0dcd0575c59fe0fe2d8a7d79c210f915bf6f4155cb2237956311b55c3ad6458552a20943633e5f11f11a3b9461841769d812986662521e8e0b4caa4c5687ab16382fceeeb78d7062bdf7444aece299ca246d4bc277c2c3bafa9dea53b3b164de9a50be24a98943f8fbe77fec6a4de61bd744ae4f7081d1932aaff24ba760774ad4c2b607f5df1141187571a203a92b276e770a0222cb4be6d6873815d017e2be91088502af320ace9f98f9d6b1897ddfbbabe4572eaed147fa6af3214ada2d99d08248d09c0987fa3edb6933ea19c0ec896a25125baa558aa75441578525b3a68224ad5990fafab53bc4470bff22df7140c19c939e9ca988c7f6f9752c9ab6392fe32a53d23bff565279cb2711d3bdc8437e3c35b3a7cd5b4624145fdd1baa53eaeb8f6931aadcaf6a1ac2e28c34490ab7e02a830345fe24200eb7a91fe7679daa0df6df9c557905ae2136b67e60497ea0f5cce9c117b1f38f0b09bb4d2a3fe4f0874ca52e21cc867f7100a111a4747eb7e8c3eb80d4e02805acee3641ea7887978cb97f6377aff47dbd735135e55b0193e2033078e19feae840009856763cd0e8d55e0720260a2f01dc0b0eaf05d12e879f317291bfcb4a0f6ed9c8a6ddeacefbdc5c489f82eb1f5b830cadd1b1eb1aff6d62269c3590e0c5d40b90d46b70851cbbe29550c8fc747366ee4b9663df032e0d0bf2555d0928d474a4bc7bb6065d3be541f552d6c1ec90b2a179126d18464c4bdaa86d087efb0178399be31083fe2f3fe9bfa88e20063b4df0184e224ffb06dfd6f9448f8e6ec0765f26cd2b1d2635731d1d38f5a8baef07f53b85e3ac8574206600f63b77513620eb8bd23b832722198eea4a37c358b28f2fbb58b4dfd42c29e0a97579e7532dcc2482682952faa826f1db4cb02b224a08739209d066926dc7311f9c20e83d826daf79f4e1caa791630fd2555745ec0bcd478474a01e79388fa775ae64902b20f0c445b4554b2fdd4b6c179cf54ccaddd15fc10e301a83fa7490134fe27f8a1559cdee601a31a0dde8c565f486676fe05bbd7b3c66987fd33e006fbdf9d51452eed14ae09ef9b411c77dceebd8c9fafb3f343d21d35bfc72337cb3c4b4ae214eb8bb39ef1b8aef2d83ec692e25c3baa13c7c33fc5089bff608e60c5090719398babfd53ca082d898905167fa6a2212a2993ffe5b1b5a1f270438aa4189781d9699d057f517ca02a10e102a3295b48d5700131b2983b5b26c4a72815986a153a1e60454bcabf4ee960de9c7d598eb857c48ac040c05b963065474ead606682c88d605f74e980ad69a7376395297a4cf9449bcbe87a4809b64e278875e5b62d0c9182ca9ca7d7bb1b4f93dcae80e96aefdee6b4e0187dfe499d0489ae3eb4025abcf27cb7bb5668a9d9be3494647596d06ee443db198b0ee7ad5235415435d1610c3f48271144bbfdc7290534b9ce7e3ca67dc61689f97673a87543f4099f0722ef65341af610540cedd2d55295fabda14629b766247c7ee5480d60c87aed3c8e8c0c2d79a8d4f53ce8bd19a849df831d6921f17d03f15cdb5f7921e5cd7e258de1c8e3cd22ade6c9f855c4274f9c53dc2ab20cf9d52e5aad6870b446a1c6713da2f6242245f25527d508ad25fa42da59602613dcea3200cf8174d2139837ce974f841d2d5737fbd51628a93e88c590ddee1702431e2c0f70fadf2296d3b72437b6441a267e3880ec9ff0dd0f388e91d4482922ab4f28d0abf167ff4f99fc3ccb7f2a3839db7d38d5c6f4201db22f11a41b56200ee68d9c6b55b342061c370640d19aa329188258875c32ef2f798c52a5b7c115016ae70598a64230f809645f2e5881e86c13aab317585888b9770a9ad93f08821ec7a036491d374064d2b691a146f83f3994488e7e17a14ce6fe98263c8ed5c4aa9f678ca5cf5e09fed2c89ed2d136b910a27cafc0fce2f6df7ee4c0d8eef8a6bb28d829678dd4a9e3152881fc455bb1a8fc416ad6047c8ef8c8d2ba07f09762cd7d2900eac026e954fc55d6ce51d5fb934de60e86a077f6836222dd4234e86e30044218761b86ad8f6dd673308a93d8d7656ff019e17435043093145d6acf3578d4f59d68ed47a7472479cd96dfe296e1c997c71a4e60a0038c454091d1b42d6d7789d4b299bc60c3ace68d35df9cd9446b8a703626feb36927a701fa2aef5cb54fe9c29a82db5afbbf59e043d8862a85e594edf8be9426e7cd512b9685ebcfe07e773c6bfe4d3ebb652704a7c26d75c51fc1062c99f77d92a31f0cf385b53f38ad13a96f611b622e98eb2c4da11c718b7ce6692d929492f6273d82ed91255b88f2aebe7811490eafe4c4f7cc5f0cf33b53ba8bf992f43843905866849f1878a2d5ea1d08507245d747d0e2747d0208bc1f3fa56c73a1aa26626d682e40b15c93922e532ff6af31e09a0868b66ce06146bcef213abc6c9b1f2cf60ab07ad3f5e5250f089f9992e9eb3368dea673f2e191e9af4ee448e0a255adf596ef189f744e74a1559b09617d4520f717a55d557a134a0f10398843c06c2d8de660db4b3f268483441ea938a00b17736a422291148d0471a2b3eec2200635f7166c5830d3ea1f911c167948bc9367dd37f0aa4b920909016053da0ecce376b0ba811b9053577fa99f7b8e346b2b394e7d0138354a7a50cba0eef42ed4f356a716bb8b279aeec01cc0e94375f0bb288390759ecd2445b6084d640789a2c0b2c29d18ebddf70c233d20a71ea2eacdbd29f4678093b4d3755ee6e760b7099d74477de0dc64a0f42c5e8de15621c0edc8897512f3005d267332e568174a6585c968917b61e91601857e9f8edc8e7c7e8e7937047738b950feb9a93ef680bd3a68c78c4a22f7b0892b2b3f98d93b51310dc94db91ea846203919b601cc537b58d70d5c8be77c62460ba43d851767b6a1134aa3bed47a9477d18729aee5ffa3de846847ba5754138cb81690dad5343bae890f3995a4be4a18cdeb7d754491f9d7d07d542b6dac53d3c674a4b190bfdf5f06b40f2f67d321c7ef989b9e268ba7fea4fff3ae717ec51021f481183890679653374b5ac8f24d27414d2b346104c0890da77976b83fbe709fa814030b81969f7063a15ccd61f0b82551dbe5e86a5c0de6399d02d4a44a0ddae2e1d0ce5253033372eebc55971fff8e4a53cb2f6b13e08705fea0ebb4657212333ae04b86f921ca72975eae0db8b6a202338391f3eb937b419496a19ec3382f12d60c79b90a1c2f73f1ee92aa44b79d19af045d6e20f1dd3b71636ff3f00b9c9d1823a200cccfbf28848955040da90a5a361421f2cca8bb61fc6c9042987784c35c7852bc392c10fd59991830d48a2abc15290d7bb90cd2e0f743552e6b6b492d201a63bf8a08c073c4441f8dd5c2c8a8f84401c280fbfef2b4a872fc1a0bed40a592baca2ff3fed012d4d5ca034734e1edc5edd5e6373f6326fc076686748203c90245595f3b63d919ddd220d2df25667d2d33a1f28f6303a5c8bbe213ad845bb352fe54703ef726896afc15509c0f5f878489743d2a2e402a68d5a4fbc8070b0ebe77b06185fb6a7c4fbc1da593a134735171378e179684c09cb44459251fbac4727cb68132033803fe314494d292e8e4fe26d39b8aeb996679ecd094890fa92ed533350868f2bb3eab4766a7c5cb7c30a159c1870442f2f2594966cf4e8421efcb13d8563a80f0940c89871828cf87e0060ecfa26d6d722cb6d3dd51de8ac0423d3db72bad65992faaa57f863b470aedb21f0e2490f01fee40179528d51e965eb8f35fcae87276ba5c9ecd34e57ea8c68326349fbaa9480258e2aa2ee6e2e60f044fefd5f23a773f20305198757c21d4eb5bc416dcb4336503f9f0d478867307818a0367966f1ca3ec49714c0f6e481e881797f054a7daedcd2119725cbb67cd160eabc0148f0c015d690f64f2b20542b021b5edb5ef37ee920a70d35ea770a22edd292af1980d6cbeb957623b687c71ebd1fdc64c6b58d084f961b74d1495afc62c16f1dad7af5216936a2da50ecad3ac4aa5fdd85a8e6bcccc974e0cf800054ae181e3b43ab33a29bd359cdef96deb13b4923e820d916219d46c8c81206a19e33a8b86b9e6f9fd47cf5dbdd6f29e8b77566428673c3eda7b262efa5e8d67858d6bd8f59daa7efda82459a672f5fa0bfa54b7f0b9d7f9cecc3061fed46bfc577b8a16e3f34b3e67bb34fd3cc674c2f1786d3381209d5a9bf0e63003db3ca0687663c715af8b691c6d0d961fecdce1f3b372416ece3d401572510a8bf5c442051e6df0b0fc1fbefbf7501cbea035eebc47dd1776df33eab4fd866ea12cf3994215078d1dcd3c42a9524cba599e39bd86308c6a43ab1fa09704ef665f43369507d940a1d07d8843d06f66c12d0b51519dbe28e32be36074521e4c625f7dd151b66f0e57e2088738a6cd5c5f66fbb468fcd380b11f26b4dc79cfbc6f1dd02b36a019dc8ab27df8f08a476b3002b7bf36842d9eda576fe1509a9864a639989d2cfa253aca8cf35e55f1f6fa906f1462f58a3b7bc6009008bd33b6f7af5bc037eca0be59a379e10fc8115dc2a126fb564109718e75060c0f9a20429758f5637af8ebc5cdf26891c3a9f4db20c0566e81fd3be4e49b0f7630651d20c086c717d96014dff32822f5c38918655eec9e40df14b05dfc8aa2873ab9979a9a3849b6d54369562d076b9645feaec0d7c9ef6a05f490ba0d79bab2908b354a2f524c655a2bd57d0a0f767765782a112a623f138fb9121fda905becd50a94970fab772199a625fed8895143b0996da5b646463782e427d66915b4ec10424924742b43eec663bef34e117fe560592be565b4e15ce7b905d1c5fe10412a2cb557c13b296ba2b3a7c56afd4fbbcc9e7bd521ecbd31478f25881b1d560d4103d16e0add64b62218d92abfc56f2745c4151153c290bf75777dc760b5835fdb7f857b01b6de71142969bfaa4915e06230df8922a715bcd2f0cc6109967cddc7646ed66abe158762d338e31a507e41e758b1eea75fa89f1545708a9249aee5b892a4458c5b8cce373c3487b1d35c2b6a9d8abfc3f254aecda850d0fd76133dfe3e78ebb50c29b1759dafc5c3a3fa3dd12a44462f6bd05cab86302c03f60b06d2cb4e84d87e018e07034bd394c9c66b8e03ce89275e2ebf404fddfcecc5454ce56db0630be815fe2be45f1545fead6500c1606650b8fac5bd9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
