<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"203b54da342666f212434ecbc36e7950951d5607ef85c0cd3df992a39e053be3a490bc5be41772bc7e23085aafdba4833063d371ce4a827261be9a923c1f82b69182c9eea664ca5c3afa4f2889ddcba7e6aa3122e568c816b40bb7a8170b83284c1d38a374447a6d5f63a8434a3fcfcf1b5ba6d6d1c437e8d21fbcb4f291076c16d0fe788b23c8cc6ef2a028fa242b4dbfa0f86bc5a8e1ee164fcd93b82c0af16a39d24ca37a73cdaba5a2fbd9f33d31f717e1fa2fc9a2c2821fb8b58ab14433d6442f668e1ecd453d26db7e4d5f984f9e41b2936d577f3dfd98d538958f89d210c653b32565988e0f8a01aff65f00c820622f8b6cc097b17a7a8283ba6cc4a387394bd852c5c55694a54c7e58fdc1e396fcf2e71e1f1db107e0852113d55b0b7001946f337a7590b0698d7c61b6ed6b43a565f86b7dc60166d29e1cf1a0caa0cd2f18229512c1608bcaac63d9b253dfd784a91d00282d93d939e9c1999b44998b1c7ee8689bfcc9ccc18535470bfa0146bedf43e457adf2b0644cb305353328a4670f3cff272b5a2017de4c80ce92d09135a5f7e27ff4da16cd9fa7a6f6f4e370ce768c9e7545264db8b2b784f672ef6201d8e5d7dd9494957b774895cb7ab0851153ed86a8152fe06b9f88d49c3a9881e2fc41e6a5d57cc2a5500ff66a98e7c4ad464816c941ef88ff7e1afa9f11f0a286554dabd1942023f2c15467758da8fcf27391af348e20637b4be0b0dc77a2f955c90610868443c14792ae020a1e9a4389b16e254cd5997e4b5cf15b172bb385c9e2d9826a3cc99e0cac39c79764d35f4ed6ae192a1f9ffe227dd731b2059074d0bcd9444f88666e2e144a27970b9ee81d56997c060562d108ba27bab14c792bc558b016369ec5bc5139419c940cfd2ed961d01098edcfdb764342f11f99fd0f81fec4dc63e80aa3757abc29aa78a0de65d51255b2ed343fd5c2088c607bc940de4c9adf2e5774b8b24f5c40f7b48d2137911df3e1a8f38d3dcbc2b3c107c868f27cfa46626cf272d42083884849a704c782b4a9244910ce1d49cfebd318da5b5e26d6d4680aa107c5866d0821e4b2bd138ba66844adeee2fc4107e388960725827eb61316c7002660ecfa0fa98b64a12dd3ef5fb07bfdf71cba6d4de6ce568a3fb8be7a440a84c5d943af2960592212c509d158c23354d7e4e57b80a983a01ca7f4422b05dee152318b9b1e3a8685156168cfc45f995d60dfd5d35a1429fe591706033c3ca114ad83054aeec43848a25e7a3587ff517e05784a3159474c3a07c4cbc93b484ab0cf424fe8474bf2012196d7fa23e8b22c4376d4e66c9ebee17804793cdfc478ab96a8aa611957a6e475149641df7990d1bc8f2c17414ef6ba3a72b04f728e8644ee5f416eabd1fcf43d19f7209867b6109f631c79642c6743f8887fc61c7ad2368826b659195af748b88eef7f0216837b9fd03084e4f806c78d5592f04fa787a58227b663a74e6122e5895177b82635980019db65a5d5c72023b291fe5a5688f104b3cff8720905137d65e5b4cb47d5de4708c2c9fe123c16d167e514bd3329be25f2cd5577074c0ce1d202d7d2232d3d53204adccfea47ab683c590eb733def28555c991105fb7ead7c32128d69a255ed51a9df48aacc59d92df275d1efeb1c9ccb1c29fc60e233f7a78131491bb3fe2d485987fc8b631cec69f0b70cb565d0c7294ef6024743bbaf96bff6382aca6487878e8510f2f46b7ee0740fd2dc44ebfeb065ee059c78ccc9805f78873bf9ab2e63b4dc77792e145b7fc288e0fc22319d9f9fb3edae68f6504297045f551e1e40e4c7f31dcc249d6546bdf295790e327320777d507f8fb661c31067ace5ccbfc2e516ac5c75072337b12b8dc24ab1465442aab4b3821d7d55a4e5e1aee258c35bbd7d8219089bd563b33d7fb63cd1fb64aa4d0445b8e1044412765072d82cff2f2c3b7d244472a2a880557c9a42f6f5f9b71b6f453b21811b6c77ba8484670e6a0a2c28efaf3df0591fe21c5b9f8ccadb5095384d460894b37ecf86e272574435df98cbf1a787af28755012487ec015ea6fc67bd50da92847aff44fc911b35a61717031832445a2fbbd8e2bdb2f554b95d8ee0e7c3eb74e1f3bb27970927aa7e246cea502f38a7d15b9f3e4e82ddd380d433cfac069ae8d9854ae522eacffaa60e1d4aec758244873aa22c605a2920f7635adde672fcbfe3d6827fd62d589eb4db7fdc250d239989aa0ef4b057db3009ea1f71e51a36d3f1f07bd7080ec77a7418af4c397a273ced0348a7c24659c12b5d9ebe3758bdc6a9efd81d47e1d59c2f462a0d7adc0cbc9f9282658abb2321c18768c42614eb404b63c3915497f83a30a59ba5f9f9db8428ef7e5f84adda16f0896cfd02260331d79756c862bb6c904a1ca1728971aaac8e42c93139e79ac9e9d0b7829b3eb39f97c30dd1976d46929eccb31dcbaf3d1ad8d2a598d8ec15c8c33193d537ed6fcc164f2bcd8a4797e5fda6ca7ea7307305b7a1a912bb36bc4babb66246d83a0aeacbea13ce6c276cfa266d8deaeaaf8810c2d150290964c5ec9ee7f8a2d9eb92287393827da42543c7b8b7b64166a013ff3f62729bafe3fd78b01eac7a609285340d104644a66854fb33e7993913024af42cff0d8ffe368da08c13139ceecda25d00bd1f19e70e2ffeeda21b3889928fd6f4e72fc57fe74f70de1aef6da128b4414e3dc50057a0f568f508390627c578f38fe569f8aedee7292e175e4d2ae61d600253b53c3974ec3b6d0d999a84388651deb7f7b5235390d12c61b2fc72bee444b26cb1b75dd87b1939e9c35c7b402d93a4418d09fe5e56f59c56def36da7ad31baeb943dad55908f56de10061020d608e8ed24535edde782b82167c0f0b747f1450fd3edea4c5c7d6d73019fc585b691dccc55b8674ebe7ae5bf4a5359d828762394fbcc686652d8baf8a221bee47795f40ad3ff097ceddf8cb71908ec0bd64138647af982563b75d164c153c1dfdba5df5bb20534c2df24278780464923bb0ddb6710b0eec1df4b921054677df0a6b2329853a309c68aa42ba982f6681fd9037892fea36a17303b5988de628248e0910c24c1978edd024195e4519b91dd46ab5d63af7a8aad8f1a16bc4393449e2b59adb049b4adc99c5fac8369ec6bad088bb35da010dad04c3c7eaec44967f60821922835d598bcd80fe87678d28ade0596463fba591bb430f4d423fad9349f847bfd4252d5a22556ea66a3147d028a6092433e8fd70ada3da7821fb6e28f6e792a65c96e38a3268aebf37c28cff1a92a25c526245dbc327a565b3b22a5f5e7e4c8fcbbba2f56ef452edaeafd8c4d5350eecf0943d24d92370219ac5596a95d5c7958db7a882804366886bfbc248b47f358558083739c6f016c2a404991a64a6e200b3dce64d18dbb9cf00d068ef1311527935a3651b3226bc138f478be0ca18a8bf67a9024534bb2e1ffca8cd1498009ceb0044c679d28c0402366c2a631840570c27d7e5f671cafdfb90db254c2e548ac839f7fa7a97fc9a14cacd46fdd3ff97d7f849b65ac609b359f8f60831b6f2b5d6b6c980c2985ad12bc5aee6e38384a3ed301c8d7f2e25028e80d3cd9a9f117cde531dee70638ddee9bfc5c150df30cbd669581bfb8ce67c0d1850108c12c85d3cef36c83998fd4f52932894ae49d3153f4f2bc8e5dd2dda436215901cd079abca8d6d4a19c62a043345d9f482d82d1586ebe03675f398b10da4e117f1a26fd5a8727d266c4e33b9ef4fd139a99583f06b87e43433d6508920bbaacec0e3eff6e4b921b1374efd93681ae70392dc9d61e9f828c299420d1f4c4314b94c0389e0a0575e91293d9e075ef0b7b350767bb7df6f5bcd00a0f7dc88c3635f6e762ada7ab4ff9c764ea6b4c23e33355beee8abfa12d26f85cabe1477c930531ad5b7f38bb462082222e612f51a84ad404f96116b1237eefd56229883775acb4480f573b3a73221bb39bd59de0e9163199e08f2275974761b3df5c69467efaa2707482e6573790cc924e5dabd2a51bc26d3d83826173de0ffdf721e76dd83c2ad67d72c6c473273b8621121564f5d8e607db0eb9e78160d769aa4ed03cc108108a9fb0898e173fb25f0ee5ea75d26c3fc26e1ed6897dc34ebee13a663b55eadccbe104b949afce31d171fac9291d1dfbf0eaf41bc92ec64ce892996d8fcfd9b9baa6fa22d5baed271c11810172d85d8cc599439fea3bf3da267fa38b39097b9e7860b9fe0ac99283df7703b1144bc3e8a926891016a987ca90d35d60dca3bb93a7e79c8a2de57bacf2a85443c2eafdce7189cb4b430968daf506138f74cbf9223f39ad0c62b73e67409a7159416ee26ba786a2fa5a7f14d0245b8b0bc52317612a26015868f1a9e0d551eef11091327a9a10760f10b8d402cb88afc953b8cecf9370cc03bee4dc379c0afb89ac1c734ecf447147ded530fe7f410ee01a0eb8ab75e4467c6937c54706bc39673c53328b1631b8c0efb76612faca1cfcb0b78aee0ce51749dde40a678c31dadaaae89ea336a325bb347bbf5035e5716e488041ca6568cc80eb251114b7559352d891874ec833df12f5f0819498dcb2bc6d7dc18fad7670c4e96b8cdd98849fee6c3eb24443de51cc5b46447a8a0dd882d95842ed01f501cc4a845ddfb49a8a423a4c83541ae5b92043af597600b617f791b9753ab32f0da41a1829b754ba08dde505947883f92e718a723f00ba1ac79196c9f98f48404d3a19fd0bcb1a3dca3c37321fc28b77a8b836c40220f4a6d28c0b6cfea2afda8dbfbb53ad961728cb626070befaeb5694022b86f75337db3c51d47582d0a7c0ddab80255ed69d5095b28ef5ee6082ab2d50e25b6b9f8e593b2298fe56ffacc7842bbb66f415b3feed32a093b0dc847493683241f7412957d3a454801b474b1f1949484e75d727fc934c2d771f487040d843d6023b9d68f63c541bcd9fea7a19376beef1e3348b4ce2430baaf9ae3552b2010c252c2216234e1cf95c316a98486549b1f38cd5baee7b77384919f7c84d8630236317e5de0ac309d59644454a0ad6b87606d1837ab818da8cfb0d20ab492431116d0759a372d328fc02aa865b365119f486616c316bd250d8e42c121faa907de416b619b22662432faae013a88f0328c393b3549e759ed60cf6452a921da519510433e49f487ca3c719d8e60d2008cbdf5c0603fd04990248f09667c1fde8553f5ec273af2a855946db58fa949ae87e1b3fa9aa019bc356f334310eff7d1514377d4fb9fbb74585df5f370cae309faf888a4082cd87d8784962bbc8887fe042f76e2162f51b549b49a05adcc2d758e48ac79cee894056ed38428e4b12746948eff3444df47fcdee6454c4e9531a01c2f2c461f8c08953bed7416e00049baf8af1e76391b9bf350c3366187b086df0f056e50dbe8ff936668b66f451ff4782aa84557a339d67df0d61b1333e601e247e6e0d18dc170a6d2bfe288f187cd46e921a258e4674b20ed176233bbf8b48b5894e1d23659c9fb7ddac6e2e413acf98e6ef3adb9bee2a89adbf0056a4d8ad911989938019d98baff2012aaf4c545883b49e64f50e14e0df5e2ee6f8c0082fde903ee7063f42c49e1184052b3fd52bbb43277b8cc25ae4cae361a8e6567b0d5fb8f382ac2eb3e6ca4d2a76b82aff77ec5d735f56e648f17ff73b8701bcb584f767113806bc95c04443cd878e7ef9ac1053cb03d396b7dcff82a72361643199f2099206fde37d4619e42fa9b4f4dd0c94114a41bc1446a5244ea35bee9453b7684a59d8bb4b5dac87212dd15111a395aea0f47e0406bee4f3a3cb3431e5ebd19962cf7981224e149dc0451d12c01eb34f7c552bcb817e13c7df629c9c5e0251e6e081873ea42df91d700d4674aa1539dfbf8a0b091733dd190279cd71ef702ccb03c96d07f56ae4b0c4d1cf87be21120e2e78c13473048d609c0e6c1943a036270b184ba71840445d28e81b264ebc9aab45199a0fa07eefc2167f696ba142c7879edcdbb22a53cdf5a181c4a32e0adf9f2cebfec1200f6d327537b1c0c536be2a4d692afd0b5c121de1907c6ffb589360b14f033678bd819a2a24e1d4aaa85791f1e7e04c79903e407db9de233a53c9a532eb3c649cc045d7640f02c35608052f4739b375267b7cd94ee20d6f4323801988308e541b2eec24e275eae1223901f85aad71605527884d15058b13dc438e03c213f0cd316e4a3696c6b329d21030f8b7be41338fe587496628d70d8a08d3a9f18095eebcbefce98f507d748638113356b45eee970a8ef09ac4d397b0ac19792493c2c2d017c660371c718921ef6c42aef5b57a1bd154e8ad6cdcd5c0061d5c0cc1f77a4520e0603e1c5d73ff5faf2626f8dbde48c57b5f64aa5c45438588dbcdabb6998e312a27af3c2091bb21801532bf3f905fa06b3edbea4a94e5cbee7124ca40232bc61378c3f675789598063ccf2a12e719f23ca0606daa7cb522ecc9481e9b79a28f40e7492ccc1ac33e15aedc0a70d6b1f3dcf3e43d4ebe236fdd084e8b687efdb393ab8269f0cca4eabfd196b33ef4dbedb4217b02d67f645b86ecd1d832757e4ed5c28058b337ed206ada32eaae72357e5349faafeebc30c06918460e85fb15cf7de7c4e9b2b7344cd3d621484865cb057172bddd4d992fdeb0277f6dfbffc1df1cf11153d86b57e64845cfeee3ac945f0bb7ad309d3f55ceddab45399953534db4a6c980a3b1883c97d787be3757cdf297fa07b7f90d7297d52ba6771da8e1b9e862d41ee2cf612f8a9c03ec50e4a7df8e8b2b391978b9b60680d9c67f013f7baa5ae8ba130ff1e45aadd83c7dcbcda861eabdbbb3b03fc162814383b5f10acf1326257fd175fb0222546906f065d2fa191144657525fc92b1aaf2bf361e3fd373c036d0487eccc01246b5ab9de76d75e38c91bea5108069d731aab63d29bacb0aee387eaea791e8edd471cf41499212f17632be3b27cab01fbf867edfc01c16ad182d580ee8ea202bc3e881e2831a91d835c5892e690ad3357b31d95ab33ba9dd27a54a7514655dd97399fb4bcd21fe379bbb27c728baa8b8b865131c860aaf79f30c69cc08c44ba20fe63aebe398351256b2c6e7f027a2314ed5bd974de81e2eaf76564fcc857c92afa4a8a4ab77bc75cab799d206fbd78d068b9f04ec6503354a91cbe27652d09602a08b8d8ca8e92726e10aa9c7ab2937361e0ca4e041d6945778c6f823f799aa4721775f3202a72c271e49c505b146c4e35a204c71b3c76b4bff36f8dbf6e08743a2ed90a387cecf3d03c261e0f283d2b365dbed31736f73932e2bbaaa2b003f1e71d4c31d13ecd687887bb72d35d872288bdbb58e6113b981bb3e40a1583340ec6b6bc3105003da95c7f23e8b464e37c2aea4c91efa8c2dcca5f99b1862c2d9151c44488d660c62f85fda50f74d13b0946617a8c00252e987573f2b275c350c12288f984d050cd00b6a1b9334cd544816a85ade31ae07a600cd60d2e6b7b374ab23fe3b14f2693d1c961cc4a539628bd004b4d767b7e45e06c6c6e12757897b4d194978583018f2dcd4ea08683771e3bafe90a68aaccc2dc997711054dfe43751e496689eb948ac7fed037b04e191116c0be4640b7a42dd4d66d8dd5a36075b6a8eacd193f931952df7f7930da1d6ed7a662372d0714c47c205ff805292573a0bd1e171f5879d782099292586c897ea7d4097c307079d7a3aca36af348729ff2437b8603d3c6f953aaadee508a676ed6c784b2ebee228649a1eb65ce6b72fc6297a4b7936e11612ec34b4524807abff2776883163985028df9662a78b78056241b471af1cf5401df2fcaeed3a4b4752bf366ec556a48b117111b486a78f2981689b9304e9d3ecd0ca0315a0bc90851a72b59154ac18fd08fdb5c80e465ceb51bcf8301b3daf7aa9df8946b1d1b76d47627dc19a34910d3727327581470ea91d3b49dbd44c113b4536978bf5ef853661811d076199d1356e5e118e125135c53991281d75d101d3cc9a8301b49899f1e13d2e3348db3cdbc9e3fd9704618d57e0778ed57233434f4844579568573113a7cd01cdbaf9a907814b647bb8732810b83f58ef0801d3e3b57dcec818414b14dc583916806d8d50affde1c9e98de9bf12b56b726bbcfbd27fde6202217f5e053dc069043c43432afa63695b73c97ee0ae5b4f747b52141d631e5d3bf0bd2f71809e1efbab58f66ca9d313a879ee7fb835f2af59484a0f1b2c220e8def7d5499e218e43d88da7fed0cf0732c4bae5d012947b815e00149a485e822c70da4028bafc747ea7c4970c91cbb8dd785f86504e1f851eddfec39542b4841dc157c16b07c9c58d941eb3ae8b7431bf4d3d68d7f75c721e35bea163d32e87c0bad7f7dc8c52f2d435379136992066c41b07d99324f5d1c224b43d2bc1e906d675420c31b3ec146acee7fe20c46ee0dbe905de52cc3e624daa567e59cf18a373bd1f8b6caccb49b8a1253e1af51d85789bd8211ad593beea54aacf7a5659f8199823f1658730c3f275a8a9ae31ad77e2a2bd9b403d82ab399026bb07314dfac3520d02e3a3408eaa61a21a2c2eb8826c50d4579dd81b024025bbfa4cb6056fc6e6ccc7ce998cd89c7c72f1f2c751fb1cc71d57c7386ebf30254ed4b8a44a640e486020ceff879d738be54be7ae6154910de5c5c3004bce1b2d160c0cae480df42081a31a0c019377fd6153ac987dc5fc14847b8022b6713fa148bd9d100bed2d3c8f664d6faeb71851f24aeb28a91802533d788f10e29ac69af0f4d800045571227b56e65aa128ba4ddf8fb1f554d3ae99a44a4604068cc41d507d041a498f64814c5fb95a3430fe7c9debe98a937d219cb47c8839908e4b3f80d36c48ba31a1f836674224a103d76a15f9e1428094014fb5201cb7c05582328d3ea887489b4eed070bc7891eaad0cc99cc840c84edcbe217829a536ff789eba2f5b32cdbbb2355eb7a355e2d1f46dec98df64258eaeebe175d4edcae5a125c65b58b29f40ee33189e02b6bbb0f716ffc9d16057dcf7418f735fca905b4d1fd304ccef4ca839beca011153b95abe059c8701835515a9c1e171d7a2ac0d87e620508aae28ab17fd17cdc0df061395e411461a2c71a50ee9fb3399119171ba71ad7174388f319b21ac4bd3f483ac0a2f7dd6c2f8fc461de6247ee7cd89cf8793fe943ceb943728cb03a2b07d9026868a8b7d7d1eb43771926f0e1121190c18266042155d71302d2cf83fb4e01fba90cee941619c573946bc52ea1814260b58944c0dd1c8e96f76268c3c2045a02929ba61c937be63cae4d93a6e0c83b6361668865a0a488523580b44cce79479ef7f96f0dc54f4e74a3f4c64d932fb521d2ae11a6f961825f6b55830259e022733dc20c1182af31f372e46d35221dbc20d464111cd2cd3591ff252a007a4da3eee2de98bcbf89e5f54ce947352b762459ddc449f0acca17f679d7aede0e66e009d96766bee4a6df482bd088e4047de206df1e58093636dccf3ac7b804115a7ea5c97da90cc629c2d56e2f2be3adc617de6d26a0b842e0b503d317e5cb031de6d1a941dd024669f3818d467db6a9cb259b0f09722b6a5abb41570d132126ec6b3667c5d4b6295f83072d18390011a5674348b1693708803ad0390253923d3a9a1b4d83c7f9aac2c5bf24f5e4576f1b0278e4767ff90e20ee00b75b4215b10d3b36eedde7a7651ecd8ce380ef2b9f518923f7f56ef741b847c94420638cdb86d84218e3536f64d3c6b196378ff1cf2cc45263259fe90108be2b816bd62af713a522c68afb92600429fd1e245d326f359888c1f0f128e96ccbe8437299e32fdb629dbd05c32c935790f3348f0300ee2c18a838887b60dbdaf8508d3890d6ca627c0628ddb5acfdd5024c0afd03e65ba26749f3686132d5de1d08a84102e533148f3d67a420e6167561e59a10a314080d8ef160c066103e4177b29d2eade649789017a8d61cd2c95eabfc8a822a811b6d804d44a6b5be0b03943a5ffb28123b3cb48f38f63d12318eb80cf295c25e81f1a6da7492c16db9e1de1434736cb642142d91c0fb29c508a45611828b6a61e2def9a301f5c20787cafc3e0ebe01d074551b127dd2bc5fade24ee93b575a45f6b29b230bdb453e7ab83965ee0eb151121bead0fcd38fc7951c96d33f11aa34344e62d5aa54a664800c720cbffe77b4c8ff6f85930d1a5e08863250d37a797a4ff97d122ad54e8b8ac998a600eec7784c1eec9682901e7a722d78c29acdd48654a846609dd4d24f4d7aeae574fe47d8a08d53d34db0ee2d4cc948191b8421a97c3f45e1434fb24235b0eb0048b0e7efd40352c3769791e774af58ce5715fcaa33faed5820b68148c2f5c606b109f3e4b8e7eeef437d083fe6d69552130b722722ca5e351a677469ffb27661e2073aa935d703c3e1dc6bc7e90ddb326efff285c85363290463d2f0612136bba3aee0faf55f85930a3753ac629feb8f92d079c92e22b9d749c34a12e811ec16302c23cfd88c30e8f2465ef9d084ceac05b944cae9e0be2cba5e3c29ca0f206048a1593e067efb4ddb2ac9e78427bf442cab943c8b981f4de57216ca4418dd36fa772aed72899de126f40f2ba797b4dcecc65d0ae5c986b8ad255ab6ad14dbd1949c6174f81db2ae9e9346c8ba18264de3116f68db52abb0221dfd2391507ef99918232994c52ca405955e0abf1632101bd6051a908a1504774b9587d23739410d239015d5ef537a7058a0734be0e5abc42102b69bf8fa222ba1e54f87aae066a415099ad8aa56b9c164ced4cd389ba0ce63aa661c7e7a7a65191c08de3ffdc5b354062c99d55ad45f8555fff2b27f6e86410ea38a45feb59462236756114512f3b17a618d15e2213787cfac1ec77b027a9702e7f83e6cdbc8f9b0c69bd3d1e90aa06f04138417aa9ef7c059ac5e0a177d2bcf6ead332768738615c36533eaeb3f7d3b407c0d783abaae6643078a7a3e8e6dcd258ed6810a9482ddf1b3596da828fd6fb77b81af318c3e60cd21b294c48c6867c56f56b8ca6a1ba8ef364a40a992190c41724b946ae9d3ee09c98676f133a9f5affe4b4285e262366fef27b686e84a169a7b5e2c1bb00f28bd1886b57bedbf1e80f5fa0df0861b274065d6b9dd3df551d19742c1aeaf0938077649f905ea66692377104f3544a5652067cdf139247a3c5b76fc6ba60585833fa6193ebf11bf4283054a95e236027a672561d122d7b014d3d2489d33a23cab5bb5fd2963d71d6473df44038ac75f95098fa84a3eab1658a753fdfae327545eda21d2bf4e6db3632eb39a4744fbe291dcad01796073367ace83171d45a449505be45734a6b64938be2513adbc5ec97faa876f6a613482d5bf7412e4b894ae8513fb5dd9e3771f6666170bc5aa3beebe1c6a7b88ca81fe511358280414fec08163bb32a6de550cddb25d00e2018d117ff57424014d82919221f32f231222043139daeaf46e8a9dcaa12faec1df10551f9b957966d88f663f69c3bc7ca206c2ffc28a7607aeb9b8cd2c03be990998fb978bbd523a79ed4594581d154e921e3369ddbcc6c8914cbafd53ac85303aef574b3af03cc84913d638b2c432917c56fbf10d35f186d25029cd4b1b1247e9a7a2bf4c1b309d613f9c29b65352e6be1a68480b467ad2e74202297578ae4215581dc16645d1baea328ed981f7ffa8172b909b2824b049f3dd5ddc0651511bde5d99fcc21b56c9deadd95b1c24995a2ffa918b694d3fe0b4804f698f8c5cc9d23ccc3fd6111ce275f3842ad41b61d9b0517c097bd13661dfa6b2676dfaa85ea084572d0ce17a53e5dc4250fd376dab6445b29405dc7f7942d52ea3baa8ef7da7555a8a76b961b6387e32d1e75fe6dde9ae387de809d085a226c4a104e2dc0dd49154a8234508686781b722ed9cabd2a8c25a4d015de2af98b64f5245c1bc3251b6a541a262b978713ce3d777c08734a5c2ee95ee3828d7360a4be3921f438e046cc0233496418e19a3cb1cea17d44ab7459ad25175a276995ba5ada4d86330a029037dd6355e4b2319954ef0d8ce2557b882df874cec70f11e81556b120159571e78d40ae39bee94853fa3c105121c9f06bac3349407b05494ff9390a940c16fcb29e90e8a95de5340fc8d2b93f6264606bb0dafb6e7d86ff89841ec4331566afc534f388382a8ce9692896475d7f7475ad9d75b18785b82e6142f3ed4a5b44290bc502b88881cec34a149ddf8ff0aa7adccf9e40d7b24c773bc6de7a5cd57f7e683901dbe8805fd9c146ba12dc0df7ce9ff1958fbc2785b0386c4a135b650baaad70cf46b5c4f58dbdfa4e3be5024b9bd0aae3dec22bad70d12ccb351f86b7f504a31a6971c4882ab16ca59734f309bf5e85b106bc2292d4840a0843e9009b73d0b2d9ccb0220328ece12c6d3318a3a8e7b29fc58ca5efa93d2ecd8e27c624b9bd99d70a7280d575d0c7939270978d6465c2b9570dc06963373396b8d2c431dbe7838d033e195cc9ade798ae450fe95ef5b2b4f3a4367ae423cf80764025284a193fe0a46e3948d215d9e58878012531bc2596051fa1bd0f8a0413f8f799b4b1bb7a1070a289f7fbd2db577036ba3dc38ba0938fbf266a500d08143bfd4896d0ff079ab6f754e1407b72bec3166776e8be37603971e0066ae739dce2991a20aa7e3ce48bf9e6b9472d238949bdcfae973442bc141c55569b8fa64f64bb0d5875c63a8409c2d04041621ee824db1caba6abc1a5c74250e2bb42da195dc332fbb2c2f69df971a6ff788561c83c95425765d0de85e786c34521630274920112a0345165b0cb22b77d064c3d91a36cf4d3429192b3883c6e0c79e4d55f30a043a0edbac742a725920e495a69c3e7e8c07807e44a596c273c71e06f7c868654f41e50329dd1e7102feb85d664e9e7494f96e78d40758e596ca032d41e3207968b584c31c0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
