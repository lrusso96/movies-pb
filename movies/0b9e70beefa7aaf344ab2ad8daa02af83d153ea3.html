<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"558070b21ca8e8081c55ae41b929e5329c05db8ab64b69901163a2d58ed73562fe4e04d5f92fc87dfbf3e656ad0abceed406667ab474c929da848d8ea5aed6809a8dc555ef6485fadd3a372bafa08ae77a58ba210189311f0fe4f2f3e883641f1325812586ab2a561bef6c500e00c7bb8850658f0815982b9f828d6be9d61fa970c39067ecab535851579c865799ef7ee31f88c4e68c95e4101b3e5542d3316f582d565104d04d74c3740413f3cd872b7ff89ad0121293bf746fcd05ddbbbac68e1cc48fd2b2e16fb78f21a68e8ef8223c27ad1477a77b4e61d3d3ac5a1fd2abee3d70e2792812b66c00ce0d445b58cf1e9bdedd19b5eb663d0a809a57ccdd8420d2050cf422db3c6e4fd8cdddb9d5940521138e7104711c259f7f283d03f3907bb72c4f8dd2bb3bb0447deec63da8a9c0045e82108799b80d437dbc56a4744571c96f74e2f8ef56bc2538632bbd611712232ab8461cd0b6ea43fd73e4467aa04ea7651611d16c2fcb57d310602120137e8d40be5d504a330ae2ec30971d97f71049128c5ff7b2230f54711a41f66c4764fb1b0dade28a7d8fd3de5c5cc9d03220cb310e28fad79c6c1246cfcb24fc0a766299f39314d3ba773d76467eeacbfa949ce17f96f76f1bbc07692529cdc105194fa8e8f2009416ce98ffa22c3c0f906f1236cc1e283605234d43bd30c842c1efb5032e4bd7befb182a71a6e902cad4fa0540501b52647d45cca514b37976a4cd1b52ae1ef72fc1ca0780433c90d9c4224ed8a48d6bc7cfea61ab8640e5ae6994b713c621eeb3d6f2cebb8a9e5c08d824e7944149cf9b8345d43adc8e8029a1c7541a355a31bc7028502dc9d92d53b384395b76e1189397a86588e59fd206f049b3165b0bcf1e912e23446025f459b5560656cbf519aadccad02931a32b88d95a98403e49c0fdd2c142c7d9612baef4732976d2f78d66ff31078d12a2a9611fac6e19ac78d9c086c12b9c5661a115725ffbae185a740c0c51fae4802884cd8723a27947167836fe3975a2e760808103d211459a9ae5ebfba4fc145160e3044d631731f24b8b01be3efa1de90fbc6ff0c8e6589b4abf3eedf7d96bd31ae336a0a63f23eb9fad2ed325d7c9df72e1a4cc07227fd4c44006384dc0bc94e072ca96c13496a11e74aff743cbaec3cad6f44cbf3e4c8df350eec0217c9678ff15ee419c23b33501b6e504e91339206ea4b06518a9a0e01837003dce70527ae58196a5066ae3223e59bde57b5f03a09360d70ea9f864e0720ad72fd3f8891f1eef31e37cc85758f0acbf64b9946398e6d86caaec26db8401359dbf27c46134ea0b59cff6e8073e34891873f9df40d281bfa0cb73a3581c0af1ed78b18b8ad2521252f4e3f17bf51febdec06344e7bcbb183469b1d6761ba69ac681632d6ecf4dfd88514cb16eb4a21425a6121a38aa417e2329d9ead831f449ea79fd7272e23c86c2ab223c956f110ccba40ceb957d7a8823cb95d800af775ae7fa1ce89ce8775f62ee26579064700aab994f4068e268d3e76860b4da862944095aab8dcb703b6221967dec736c52465b8ff26b3f62577c1847761238273a60127d02e1ea1c85aa7dd1eb056e303c48043a444efd2cbb20a0adf78884e82e845bd9079996d1d725ada18d9ec290bff02f7fc75ee0da517ac4c32f16aefb92cfb7e0556f854be6eac81e45892db3616af4badb7b9bf539c31a6fe13146356f6c2baa718b8cfa123f0465540c6ae48a7bd04b017b7487528a7bc31e4c55d54772d866d51699e29c1cf46711d8c71883512445029fc8aea0ed5696fda1a55330af7fc583e028caf924a0f20ca4ceef99f339ac7857ab54cf68edf8cc276180b6bf5fe1392458e44ae84124873b927d5df9d116af11b69d2e929dc3a7d509a60a9bb389f90fe515ffc87131e5f175b1eeb416897c8a8153597715b1b19c2a4318ce2cf117c5689a259dc070685756bb6845cd7b62088f4703ed854701e490a2d42bf594bbfec579c8dc2572816e6e01b6ed48fc03a4f712cc2044abfe5f2d75ef4bd99a38adbe1c52ba3060ee7df6a0a1f624867b4472eab79ccf7344de21ff52dad7d0bfec7d5702539efefe5add5ae1af3ad32e1d67e407eda782dac00c45025878633bbec43900c457bef5b560a02f298ed1ace7bb65303c5b02bda7e9ab9ba4a5ba98ea44ab24093a95742d923fdd06f0207692fb8f08f736ebb8412374e64dfb64b5310b1dee6305dbd61e3ac331dd454ee9356d1ac08491366c4ce2af159efe02abd95635f0e2508f2e22e274d45ccc014508daaaf5644f863f7b73a6f5fcb15de7f747641e62d87cd87b4ab96a25bc8496554447b5dd9703437c391643239ef770be1d16f43f1e11c775a5a8ab5d9a6e2ed3f520a44fc024598a3088ff875c323e964eaa575ffd07714090808ff587605c3121ebac8f777044114360b1f228115d0c798412285d94ee39899219f786d9d0bd61a5afcc7a0c9c9fef40df6590b65631fa136a3213e63fb8a46e34ea18853f68f13b7a3c84b13117dc3d98489dfcb68b1090ea6b50eb4a17f7728e1c606fc3093e75ef8326ca2603befa53ceebc284ef0f72a2968194dce6b829a86cff6afa9282cda8afb3776bb166dc62005351796ad27911242298a522c40c7fd986ea6694580bd1b9f355dabec2dd80abf385c8e47733992022c771cf13991d402a95e7bda1472a7a835f2aa77c2f27b288b8027d062de434f2088bc2f11ed4cc92856d9547ac75fb459c60d2d427a31c3512d08b4582befa3a2a16f701141d41ccd365bdb20851b0f82397ca92cf8fb55be34acff2cfcd48332ad27199ae633ab53bedd7139b3d9248ec67fe87796fef02829604a6014957be8a487b0849a453c74cda945453175492389218511034d41c23a2513eaca8599a9316fe5c73abeecc5e01cc997bab2016fc0301c1c7f3db93be0a7bfc68a16c46abac94eee859ed2538de33a6e83fc78190310d3f542df19df830bc6b6ab0637166f7528b3d683d54fd9159068d357f149e8595d61e5aec1ad9965c59ac0fc9bcd531b7c4f27961f45186d3ffc517fae1a60c176e345ff255fe184c758717529cdb4474f3c31c13f3175362212b6ffccdd9a65732593a4c099721d7d3604df28cc3690041e8e09aefbd1d24dd8965048554ed36f8d998ed9f90fbda3d7153be554d8cabe4d3396b257d85246bf0278c0bf8166fa46fd423fdad7e8e82696563cf477d06dc22418eeee4ef0e66b370e9a4241d4aaaafaa0c1f5dd0fb28f8ec2cd321d7c70a366dfc0d9ba94df060682677897f6a9a5e95d06d7fc0a49ebf8564cc26033e14aec1126af58567b30d19722beeaa82ff6c27f4c14e5d015206013db27f8c933804c7f60499b40c564278a19984ba3da4e3b4e43c748178f16fd1f584ff5df645bc3bf12eeb7ae3f5ec11d1ae46b99121b53e0df075760ee40539c9ea8c097d265a6427fafc43c5343838c8a04fa96058d539a0d9547ad03730413a373e8752f07517e95ab3e6d069b6375b2d84ed64ca8a546c8cbfa7e5285fb563a75b98e6f2176a1a2d16b14e4a9a4225a51de7d00e0e2b7cc7cf7efe285c1c174d62c9558bd734124bec6017bf7b3735a67a47d3396252bb1bf630f172e97f64ebba4fc2945c230d93a79daf1cef32ff7349eb0cafe76f8ce9b8fd1bc1203553fedc051380839c7a555b0d634114d0b1e572523b40b4698986698c0146c4fdd1dcdffe19b8e9c3c8deef355fe2553ed4cf92bae1369dde826dc2eebfbf70387c8058f2c5509943463792578d0f5925bba71f60c7a69d7cbc3ff7332573935db606e0fd1fa097567bd0d8cf6826269d85c630926f76513c4e972ce796df0beb01d343d8a5390c53a1957684c2f718f6f757c37f26cd3c2633ec28bc54dbb41144f8a78c1099928ac140a8ed3bfe2a72b8b9cf4ac72b66b0192f5304e6097296c86c71e1f64225790471a1d45dc62e97af6f174084717f685fef8e28512fd50cf7e636bbec7b17a5914989ce9fc22deafd9e46ab9387e6620fe56aae6ea248670cd8441e9f4210e1e2c611aadf76701453c497ba17e3693663bc0ee0f397b316672d665807b3b49ba955b139ead19e398dfaf61e3ad3de8c5f304c3b649660e602302d712f7e17a21f705aa29dfe4405cfdc2e9437a02458abd3cd1ce3044dfa17bf3f36c3fb73f6fd515c40256b05c2a928151e04f3e87b0da638ff096862bb59320d84b25ae4fa20b41b836cc3d918534001aaf244ae305357ee4e20366d1e30be5d34b73e4e81ad8691c66d96d94c109e9d1545dd49d3b3d942e7897ab928ca917b5ab890df7ff3c31f717e27884793035bb4350dbdfcd5204e6c2ef944a5b7c4266b6dde38efddaf809c8374fcaf3aab76c23e73602bf90d971ce4f56fe53eaca94a7f7a5b1dfa0456a5936d5d539e41c10f8cf7752717b9c58697cb7e37a339ca5646d8e8374f6899d06d7d547d9ac3a9221593e80a0945c4d7a461bc1d745233eb55ee38e3dc02f25c3a73806e3734c5362a0152b77be89eac8055b9ac666af1802a09030adbb8a5fa300cb795bb05e67e66c4a05672628fa53cad5dda5bc550fbb834608b103d75e89a8a9e6660ae0b416db19efc79e4bf0c748c171cf7fe2eff510ed6779ebd9e88028d3dd4fdd341b4b750f1d9145a430a0bf6859596d0e66324ddec5785b99b35001e2546748a8b9fef947262caa960f9f27871459b0f1f5fb48de067d5fe71323011884024423fffa1d46061e0cc9636280cbc0f605ad580e03da170f52f4612073964b8e94fa20916ff2248f5175476613b75f1f7d2bae9c3688f683577b9771091d9915b90786d870825052522f0515ae60812d00529cf25abaf579adf7795855ba65245de4e2ead7b6986a4286c519e44951b8bd13dbdb1eb5c1e9bc6c91e61f355707ffa09266af48b0e756e3e97f2073deaa985afc1ed8dfa4f2a151a85faf6b332ce5fb984ef42f35091bdce1c174ed4eb1c94f714c1c0d27ba28ad6232732f3358a6c44fd71866c1399fcf3e01725bbb66ece38474c201f46a60554b30c03d2cca8cf7ac2d7cc9a042e23260f87731484f0d53f5070faa235d6f91a607a4d2bd78747a40cd32b1df8eb284f6494b59a52d2eb515f7e7e3e447f9559b45b2f3f0afc9fee7c6cc90fa95a4a634c8541e4c741707f547f4c178695cf7cf7748ee85be9eb023c1fc73f0349c71d3004434da4357edd648ea494559fe6c62bba36f939aeeb2b186fe7e58b1e72b081028fc9ad82dbbade6e2639775fe85e0707af3f384947b833cfab2438519bf91dc05ebeb72073f9c460b0781dc56f5e24a2b97f4d556b10336978ac2e8699435e477fdfb4d691464349562d36911900a49422958c7746401a59be906cb0a48c468b1584ee2b504d4570bf9d0c653eb3034568ae2c43150ecd990b71f53f68953fe920a0217a6a5666fcca09868442405e6cdd9c0ca07e590cf5d5383251de2a8660c303498daa6c08e650d5b3785acfd0f660809c963ece3cb63a122c41a7d8946b8d90b11e5d8e92b35ab3efd1c1a3ea695db20bd851046f4c38dcad09d1ad55f0a96b483a11de22539175c9b98942c9288b33b23fad0ca68cdc256b7d279ae0ebd467f2bc4c79d54bc62b582abefc10a5732f40251146006324dab5ad677201756443fa8489638e35136d5cc9b73d51d618bf5f0178c0a76fb0a4c344231efa35f69ea1a4c30846948d1b3d9bf928b107560fc7efc082716a89722b84f18378726a76aa672f20c0a5c5384f850f7c332f6bae5ea4a1b3180689c9131409e796314b8df2460160a4515e8686684097a4fa85481d9d9a9301e5e1eba6541fe536aee157c3723f00b627fc81fa942595cdd56912c973f80319c77dae6f88e06b4326b1ba84a4230537d2b8f98570c7e2edb456938344997973504cb8e0354cc7f01316ce04839646fb0762a16e368a2a7f58a8284a2ea976c20f29b911645ab131ef76439d0c964c3285998dc97d8379da40eaeb16011b7f16dbb120edcda70fd4350077b4815d5f62d6f0de4993dfcf019d2fdd61ce610e3ec6c45aec4b6f2b3af98ab4e5f1003d8d5509af1279ad4f0f59e69691574247dc7d67320a56bcb161abc22df91c2ad35f07933211d36699401cff75abb44c69c4af18af08a77852ed3fed3c61832e866ecead59af5986b8df156152a507779da6206ef412415472338a80e7361cdeb242f1257f62e743cfcc45da5f656d2d3828c669fe801512a42670696f1a825034c83636c35c393ea40095502e298261a22fd14843258087724f719edc4a46b8aabaa4f927fc86362e5cd80cb8241af6f0a79fef97ac89f4a3a99c3141616179b44c8e19b66b762948b3a654af1b3c942edc213bf07f24f6a24b5c67c3236375686706ba6181cd3037aa623a8e60b3c5a6c036c51d96561d7ac6bf0b1d22f96365462aeb52d04960d29d31716dd6a821049144791954ea1fd186dd25d90bee24861381bd6559d9833454f4656101840bfa9e283ef96e492741fef2865a0ad5f0c1c53fc665338c8d209c7049dfb26ad2810af4f223698809fb1fc05d7ba5e04aa8a0abe4c01088ce07f7152fe6957aefcd93a5fed8a25239ae56d76e65b9cb1080c4e3ef33e0f23e4e5aa0f878beb07134bf0b5cd8227db5c89dd29698ad80456e7c4adfd45053305cba9fe05b20c354dc7d9c63bc30ef201c81b0203fe0fb88a530f8d86df248c90ec61ccc7f688a15cfd64a6d9bebea22014499b8d4d228133d80b3d3e882d6a7a83c01068982992c0c309acd7a01c35c2fa0dffd4aa58f2a6ffef518e001d1b7f67cdae462f0da712f9a2f27a070ca6feea42631362fdb45291c6d94210e113e9608f3c49efcb2a8b5a6ba885cbefd403f1ac9974a2edefed28223c5cbd31a22cc779622aab3e48a58385641e29ad4f22318a8a7c8dcf26020d07c74647a137b775f691fb9af264bd18d6ae430b3f06a9ac37dce10375046d81bf97b1f00d8012e62586762a36bb26c82c7a34f90fc4d20c23f8606cda49c6d06d1fa5330ecdf27e82b6ca63318706df56f0a467f2a33976b4bd515fb37760b248259a3ccfca2802eb0d17275370ff1a7a7c01915ca972e96fc0fdef548474c08fe7e5d08a25ef1249e66c78073d8160bab59209cff7e7fdd535d815423420555606e367346ee4c28f702c1657441132767c7d6318a4b3c273108f5e80e2774a5b428321e3dca8ab35de0ced9ad59143c69af89f6ff2a7fb4c3c869310527239460c3ab0a750b3c63c2a6394641c561bb064ffa69f7c89549f25e06487fd1e492c8a0334506f8f25430dc70deed9f0fed14613e322d322fbaea36dd0ce21037cdd522a227e9879cbc9cc93287793eaa71688208c0dfb10ffdf1f71d55548789c7cdc7d0241d8bd9583f858ecb882ae90df42571b482c7f6ba8e96bc3d856883011c34ce8d4de6fcf3b2952e87377dc82c83c1a79356a96f92c4557735523bfc50fe9815c751502e4f9d8d27de218ebb4a76d29282fcaf361024631ab4a413a9fa9bfd4e2db36b80cbb120fbc86a6a5b50057580bfa94e58b7e8e71cced1e3b25ce3749c9b08a42a2cf4a69377e76cc955ef6cb1e98f18696a2ed5d93b1030db2bd87810749c3715b90fb44cb2432c10bf5b76d5de67b6e2d1438f74aabbe2f9e295c17d450807742697d9cd9a89c61465a4f86af3c2b9d0cd3778494200f075cb00070683f130dea16e4c691a18665c6f02b41602c991c2f3406c52b9d8622ff728401c2e1ea29f0a13b14d2c0a33dab175073af5ee5d77be4d5db4b5068a52d2dca3cf2d3baf941aafb7ce0550054c85218449ab2921477a344bd2e423fb67d02323b1dc91e005819c478a6f46f93a5e0b58e02c1f31c4ce1d3115b5e7a6fd31518c74b75a21d37fb116e48470d699c84e8df2f7e86e18093cb24b716ec1ffd7c0188f84be3587f9bd9288bd3b2ba9a1461bce2b5ce26bc1fcae68ca7b7839d52dc67adf42621de0a9edea09b112946385728e6c18c4f7c947014293b682abf6b41e081980dc755b532cde125f119a194139ef79b3504844fa1f404afb5122d16d1f31ed6245d8f7d64acbb060d786b726aaf6364561163f789f70014477e9c625889df9b1073b7bfdfb5387bb79c571c89ead729dc21dab41d4788303a830b68d458680c1c5c61d6645b594dabc6ba1acf76d61647b4ef788d28bb243e856c700165d4583fdb2e8227cf938b974e321a3ae06a1a0ded70ca1ab170764fc04ee26f973a6bdbff30ef1046ef0c239906c383ad5e20e9c53b2ffa5607887a2072b2ce5ab7fe09bb5b2557921a3f2793a745868bdac413b5edbc25c432bbfc1f6a318fc81ab58338c37500327cdbc4383a2e59e367260e4fd10b4e11a802e3dfdbd08f57a54b3dd6eb642d76fe80bbf33187119c2330d840548dcab6916e68ad7590457c74684447a56e60933a6d534d1ce4ab0d4167d0003d71b080ff938f405ce43e7b0e6b1f76e7a5ee97758882b38779f71218561ff3f932012a28ac733b0761cfdcbbec90d7e9637ec6b5bd153c91352a6fefcb01f3f4b082e359b46732716815f1a2caf55072abcec36d2bba3bd67832b3ab45a9b769b81cddbdd1da78ef9cadf508ca53839d4520351695bfdd413e3b34824019c971bdb3cfd78abad62da9f3219681b1dcf6d0de74da179d54f07b10e7e9601d8a7495e0a54dbbc1c4630d6c34506b43a256f404d6606c523a4c4fca93c9c3513115856b3b3895ded6f6f3ed3911e32b5f10da767707feaf9f894fbbb1be60b08aa6716f9e7d0789bdd9ad93a39f888d7bea0659620f4877ca1f220c5e7a32ac843c1cc0e06834ab3fdbed293d711b937d815028856a69489b3aa3fcc4f94a98e99a661e975f9fac96f5729da00e5fdad5187c52259a8b72d9943705359b1057a44e5b93ecd316cda7e44d36e0d3698474fd6bdd9f994bce4d35cc5df4634e976d499c0faed2cbc8894aa604c6b08259b4b3bef08bb38795d6ccd926f5f3fcb4ce5ff638722c5f3f805125ffa3882d2264f02d74d28f659bac52869a65da18b3f5a24dd50dfad5369a46b8d4f642c1bcf872fac30effdd09af6e02c5b42096190c613f6587274a60fda3542b480c9aa4462f981b7c2c21298161a411977a85024308e9cc12e5475fc0de4297dc031fe43b30b137f7767e005520fada88e1de823789ff40c55a375c1d57c50fe6710b0ef4d314a412c9b91fedd255fc24a2a8891e5c32b4c1c9e1ce2869bfe4a8cc172505013bc95fcebeb1150f962c86d048a05fc034c60b684aa422dcccc455cf10c0cf4df6beb93ea4e0911727fba90b8e0822962262ddfeb6114fb4356a40722e1cc43fc116e603d56095dd325d013738544fa0648dc540673aaea2465074df6656d8572be6e4d2b57a90ae8cc5912943ab2362ce3cf666650166b21a8b863570b9e08e9b4a991876d09a45d77e9827d9ab13b95548ece32aefba4679ce49298dc27a95b14bd74d05553108f89aa453347021f0b154fd95718366b80a44537164407e425e070f2bd015f4988548dda0f89da8a0ad5f2c44199b0bf9b06b37ecd7107210a1be7d80844a3d007770dcc9f5ed069f91f42bb7d332d57b596e6080b7fb2f2cceb60e1158bbc2513348223d3c97e7a51609566c50980fdf6a5b91baaefc0f37d7e170b75b5532b2112c39f5d19d203a3892edf0e29d218b8c1abc70414fa97adb99ab20473bc14f47825c11a62b41ad9eb95c6da9737ad6aae9aa31df9446eabc4ead1d626127f6627ac0804982d6cc8857f632243cc7a88c8496e1453624c4d751c8343619f21e2ef3fcfab38d1663af9490673c2005b06b0f9709eacf2239e68f9b64c10cbe9b82bfd9651e63373f350d60ccbaca36a1a60479764e7b262270cd981df84ff96c5bba137d0d4de2c08daabf5502b30a3ccdc2b80873c4b6bf7d77dd014affecd0c848fbc7800fd20b48b3bbc5a36ceed248e3f1af4893daf0781a87095fa8382c1e5d835b6078b8dbd70b147c45eae6ac574693e023e5884beeacff8951002149b202e14861230dfa1220c22d23cefb26fe783f09d106f24d60a14554440c83739fcdd197aa8203642960e9946675a33ff6b485a002235a1b7d6d0cbe2bac7aa777941d60ec8a089c2523c07c5ccfe8d800f7c24711b37258d46e6028f36c45ee8bfb802109c9398b5dcb18f717380ff9605487d6773f6155928d485c7e44660d56113c6bb8714c2b141027ee7345976bc7565bd79cf8dcaa09d8d81f754ae54dad0f3e4f8e79360638c53e5ff3a3bbd1492a340c8a70a3ee3804ac8162af48e5a29266560150bca52b4679a9185dd346c5076299e6fbad3f7caf0156c381c039c650d7b5235aac7a58b2a8beaf1fb79957ff396a31887245e077da1b74576102c043a5e7d63321ec35c090836932472bbfa6982f18f5f5b6cf9f3845d80b1b2e468a2865fe9ea6926a33ff70de4b2c72a6b4cc16f1d7cb3b35ecd20056aa26e0804281b5ae93a08d6043c1fc5d47e23f9ca207a3f5b4443b29c222c072a3d1429c4c638bb176f197dc1d38bd7bc7608171ac307471b6eea964742fb1b84c4ac833a2a1f1b97ae33d7264d3896eee2da2f78a6f26928c1a21a3e26fce37dae4cd85b37610cc59573e58f764bde6df06df21bbf695e00477d5ad276d94bc21ff54235cb95a36c487ccd648ba19343a38f4105422f4328a500794595d176ad60bdf1a7c8b089f2aad85eaf0ef92ab677266830b28da775ed8da75bf70372e940c851140255c0750f7b0cc528d9ef78c6f426d7ac57c721aaaf55a0be98fa5392c27647c4fd4e9232c11780e874dd65745a9f31344e9cabf8574921e32ffe5a0f969fb2cc2c6485bcff7d41ff0e32ac5cf1dd88ac2c6aaaa2047aed9c5a085c1dfbb21dcb67358ee59faa0d3b3967275313ed5b18f8cafa34ecb0b8921fd8c1567f84d0ecb09433def809d47c22e77aa5ac22e8bfadb9d1ccb4fd837e81d7a803432b99d82e1cb29901663d9a400f12b9a5252dee5fdc1b11afef50eeff0d261c902f956b471b73cc32cfe0311612c5c1e4c1863b713983ddc93b23adc3968c8f1b9791e97a726edd4d30337d8c4c133c8785d8cec0762b53c190b0cbdf7727e5b47b2bef0277dd9d2a7540c5d05078ab6e4784b265a636c85a9398f3e31644f96834972ed466cd90a188ee520b41c5829b0a471e367d3c51f8c40cba30aaf7febdb562434f646c81c1a13268167bdf555e755f452c15d494fbb0b52e0934bedc810f885ed852aea83b98d5ea78cf036ce38ef0dc01ca76c36f2346b7c1b100d95741a151a11780ce82803e18b7c551336fd629f9474895b5afd99407eb7e7b4f8ad282ec41b78d3ad172e400345e1daa7c1642e7dea95f3b2f2ac4a919b521c8e8e68e4def30260d83f12f70a2b32d836ab1314db37891650d4ba1a28e4c15b568edfc3262fe62a15308cdc282b59b724a7b2099a0cdcc4a3ac4c66b05b12e5fb32bd23c4b0daa0e0378bb06924fdb4fabb748df087a27ca9d6d3bd07522c87e49bc1416ec7e0a0dfa1e1157b0c35685e5893965c7fa16af3d7c711962dcfa8106e6ea9de69cff12b027d32177552abe98f4710b3198de28fc091e590a6424269121e0fd11e13ad442eaed299adaa66fc52051e980fef227a259f03396985bfaab68e4d5881d1c9ec669964b6ef046a4afef04c22be0750c96929d43c89cd95be17011bb57c2226dacd8cb87bcdab54718ac96593e34a0f1bc4f6b1b5a346d0f456b3ded4b7b25d8c8ab0776f5b8f8456f41be705cd0f8ebf6bca0007fa448b2fd1a2963f4539f7221d98b3f362168afce9150a7b0b28b6963e493d1c4bebe66841b2b4b396b04a420f7a02c85b99be53540a718288e529f8d4c573200106c9a62529f5011f4900e12e790694c3ddf006a5ae09244a20124456631246517b18382980803e450c40b794efde776beffd3e6148979f4874151a0be049cc27af3344f2230a63083cbf8818e67551e49f0c03511cdaeef21b77abb0f7b8f948059bb45975664b0e624246acecc43f56c26fa3698ab8925b8672c6f1c2285b85b9c404d4a96a0bed1c3426b156a254d58c537c6524f5e0a44944e8b7300c3b16e7f1bccf2509ee50f225b1ec2bc2cf84a91d422b0f242c0d93da17443606b601751f833af2d000ba156a1159e72d49a46dd974579d32f8ef2e7f7a7921560210ed811a7b063450c3de0ded13a69d4e8304d412cd2f906e60bc850bbeac9da6a971505e97e1cf177277394db0b27d709b63e728d89c8ce9c897cef0d639183f371d76631d1fcdd4748add5d040aaaf477cfdc548bc41f307b26e4d13b7c7a731d69b20a8c0376ef60c5d3d170ce323a9c55b1635bbb7503ad9863c4cee2ef5218d837bac9efdb44979702f14cb641a3b74ba1fd328e4557e22b4f819a43df048e922815286d8fec57f0e157a40d121011d112b129b9a3471f9baf8980cc897ecb8367fa178ae0fec459413899bd7c394ba986622b3ba0ca39e2c13fd844d13d7d43fc53d9330276f19c18dda737f73411b70b06d78b5ed8844396c0bd2b0f876ef5df8b40cfca7be8bb308cc76fe66717be68db998d6556fb32e4daed3f2391d514d069f4eded9aac2631d577afb94ad1f01bdc22dcd1b3f86cc4d192a903a9acab2795e781a0091383a224e7a5a9d7a4c6790992e42bb399b8385010d47f2a26ea0af57ef9dcb4935c50a7fb792a1f48744353bec8fc2b1c219efc6bb60688d8277d8deb8932b0eaff10ea1570907c7122dab48d69bb8e96b5252c825d2fb792c008cf5f391b622976b2ccdf95c67a1d1cf0484e828594fe86621ffb2bf7d11230c080a326fa3798a5460f533c385e60e69eb3310d5a37b603a71b568428cf4b4da452dfba5b41172132887f664824ae498a2b0ffecde2125775c778c00eb7cd3e7529e258e5a16dcbd4b7fae8e661c7753cd7bad1307cf5d95de80e324a801a97366f4e6a6fec8c9e4d7b08d895ec2b74f20f1c45d99b6be589bf6941b396f04fc99a9e6ad64270e995657303d4803e85a75be38e462156e3641f448ab87e3b6512fb8253b026675a6867a120f86b38e73e241c383b261252f63dc086922aeefb350074f611cc1833e076a0c4e051f002a8f12bc90927ef2080944750b365184f417bbb0669186aa4c5c71bf0c8b0584db218b7a110230456d28b30593c78f0adb86304767175e4bc7590045325065e9d1c215ae07d1a2b3f32e2b1550f9cd66f3fd4873459c6947ca4f8b55e9513fbc19c88929ec040ccf5cee70ef1f1d18725b62d5b09905019cb75109bd4f9a93ea7446149c2cefcc87ae2a9af2266a6d92cf5003347fc233df9c7321bd2bbcf03d016c07a99d1ebbcf9708f94dfbfdb81c5fe190d4ff2cecd523d2b26b238cac32abcc5c6d753efa36ab90a392aac6d8390869b890c075551d5877980fb6f72aeec77047a1690b59bc5503dea9ac96d1cefc155ae2f2a826cdef7e4938a03a52876713b9a1e18eea3cb5d59ea01101abbc97837a78d437e1df5a7e7ff161fb76a4c1f07c57835259af0dadc1a5d70cc2f682f1ef5128352a833679298e2b790b13e895c0acefbeb8bffdf1bac00d3c1511fabaa15cee2f085105bf449a79fe06685d14936b9155df1a9d3b6929b0e33aa4c0d755a4014bf4a47e1c0b94deb30d8dd5ef0eb88e6ef24ae0512b0f63875ad7b48eb80dfae81defa5d2b40a55311163c89a8bbf2fc3e7e3febb55550348bc40f71056cb6a3e732241cdc3f96c690f8d57fbeabbbeb2420e0128dd7a9f2e976ed69394bb21862cb6d9bac23775ee1e948e15af801f57ae1cfc3655423264a55bc2266146bc82a469c6c5d42fae84dc735e4f7130d12701cc0db2bd75f26abaf35eed0e499c3bc93fe2832e562921e1bd2f4536c91fadf415979118c698ed3afaa7a6353417bb085917b5318de1e7b8718445245fbe58bcd4b90eb35e6dcb61e62c96e5840523727b7d24647c2a7e319eac3f32543457cc4127d2bdd0789594572e52c7dc8b55c803128329dcde16d287e46a38c5d470b191d4815762b7dc8fc475158ed238008f58cecacbf2bb247fdf17372b06a51cee3f25c23c3b891608c369af3f1c269e8e24c1f80349ddf0aa366d04dae96d3c404ffc13236db7a9a1351a51ffb21a02538216f04e9cebf2b8a1e476d4bf021d65fcfeaa659b4d449cce668aeb50e69bf3553af6d39e10937db33766b3dd00b4935f1a5bc0528b16de9687cadbb01d711d16f0e8910dc8bd29b7420750029cf4b8748099c9c01ac3d27f419fe4ce7191644c508d0bfef55835642a2717348c24d908ec3aaee2a18c7fb31350dd4f6bfdee0d9c1ba3ab03208f21981c69ea49a11ebe320a8eb5f64ceddad53ee75a37a0d672cf421370fbb3be1f6e092a0773e8851771dc95113b9866e20826f86469e8ca4d75c3ad6d3063c7ff9eb18da424980cdf615372dc618fa647329460624e756f65d9c1b561a0d3b73110a907d11bbcadc1804e0e04000eeac31de8fb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
