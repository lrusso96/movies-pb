<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"215906ee24fc2ef611c0790b279647d702afc5309cd947b1fc56cb43ea12d94d9d58f877f1a3f32665c71b0e9345ac07cea0bc29b5e58a20e61af8e7adc6d2f85a793669f9cb7770f0bef884ac19440cdb1c97fb4247c139702e2d1bfd1b72cc94cfce07a92f3ce10f668fda973304dab1ecee0789ee3ec7d0c4869125a5e05f8cd459d70a5884c2d55e3dd30f2cae1b9e4ce90641f110fbb63bf1f20fb64daadaef9c2239fd17cabdbd9c101fd0a63b77dcc7d872b54bb590845e7a249f580d58f558c101d685ff3d5fca47ed8687eee878bec10fdaddc0bc8e5e8b6d792a463784337b75190e4a7077c12b45ecde73508e1fc23714e36ccbb805219606a09aa4219fa81db972dc6a86a89393c7f26bdf3d63813c534d0f43f98cc987c3afc2a15bd18301a04aaab1acd2953d312f24db6299b579af4cfca6a6c80cf9ccaaec2466b00803323c64f1c2162d63ebc041f137e31c7af2eea2cee13e56c418768b83a300eb5182304c4bb0bc605e273a34635cf36d42f56f32e2b47d8031bf4c33ea6053480566fde95ff950ebed69f9473a6dcefaefa6e987b7f026b2446cbf7ff31130e96b50bf5e3ea97c8c2148890a81ffee8a40aae9a0494f3c0db087692af1479f6c561dd962e45f190718fbf08904566e6fa68748483c98df9a07257e2c3b66a3ec13119aa14b0f8c43fb298cf4579c15c09a6f3ffa09677b017d6f5148edb9f845b0887b8c87c255a7be3865bc395c3df7d2cf36b78e29b7771291502c78a5f97511a6cbba1a1eccf2b1a6e7624ef744a890ef0930e3fad8ecd5f969f115b83157e4cec6d99a196dd0c62b81f6570e8d19a3f7e938c5f4b34aabf486545cbe83cfdac32cb9c8d707e1e86bb402b57799e1aa916b70a91cac39677d8fcc556194b4963fba03a6404f28a80ef99255a471da8695e40e2bcfa5a8a735b1638c11dbbd55181c5572ff0f37d088d3451fab9c1d360990e597eb820270058d238d4a2a459157b0c91f4e74b3d3b8154eb7e5599c3ed65298bec05ff435cedec4fff582cf757739323d2f5724c963e88b80799fcd522b29890d25d4508cded74ff79774a63ceea14d3f50f1b1c111f2c92e465daaf9b095bdc2a6776562f2d2fca9cd42877d4d8c34cd2755117874190b1b2753b332b586fde33ef2bfa5b2b4b3f9577de4d76b373d8ea6e07b6d3ddae04a567c2a4daf8b2b9d1e95706d37b2daf6ef537a24bd15e31904ab31f31669c6c50b8852ca327a8f4a1c9cd827bec2888810a090079bac9d6ce5fb283a54b1b82d575d5e0c924322d1c7bb72fd39b13ad1601045ff6335964456346030cd2baf0649037f15df5a48178311d4f170b5467baa12d2f4481b899c83f07b131f3f5ec50e8f4c32c4621d1ec6a77ae9597014194e66e553242b664fd75039e2d26043273604433976df9c53aea7292669471c6fe6031120b04eb077eab21510fcd701ffd91d0517a7b0fe176150d756a02e599d9601ada931ecfa35700c2af1a6df0860ee92725ddcda8b074948faff31870487ac747bd12b4a97db2a7eae8a56fbf9867cb5fd611a8862012279c7b0f25d78251cd0481ae170598b9c45711fa1c3557fe24fda6ef88892e2ca0bdab1c2658c999436b359149feee00b81761b476f16a2510145a25196cbc29408b7e9087c8f576567d9638d5b25154591b61a0e4c4d717ae4f6e5111fe2a77b8a112c3f4b49c5f082f3559979f0250595ccca426ed0e8ac49525f85281a839245f905cf69f19c2dd0dfa4d1339d9dc21b00095ef6b09e55f360279f8c67714190d90928c2f54a209caebf40c818fed894101fb5693bcbb6e95744c1d7d5e17872886ace876a0662e7b1b718018d8bfcca84b7738b2b0ca56c28962c90f46b16db79dc4820412cbc362062f1a864051c8a4ed543d1f7a1bdbc20fccfcb3edc0f15873a62a8aa8c5aa01b65d44c8408efe57c85f975df3e039d1fb6ce30f7e97908dd79ab5fde8fef5e82bdc9e6a0ed59f4b0da27aaed163da0549eec0cfb59fd89ae13134144b70dd38a55a36a572c2b8e2e0fd79577c91bd8d969ada7fd02450b37d605938211e8e7427811e5b2fa172ef207a41ec330d28a1201f2ee353f35fe4e94ba119e51649e6ba2cdda94ab99a05f01722dfb0833dc60014e4db92af8f4303cfeb6f4db945d122d4d92c6ff05f614f94464ca2193fa70d6f61ddfb6b282b435fc0ef9847e0dbf39ae748ba3ebc2eba7c6b591f5d0294df945e267e970462133150fb19304708a38bbad6376effefa19facc354322f71416a92c5accb28af43a93127c1d96f560fae472f16fd4755b40f238946680af8ea8d2f04aa0fe4d023b297d185a17e219c051dbd8a56984f9a7cc3bcbe360e9a0551a2e8447308691853d7582f137777070524e71c9d2bf55901601c5af9c79ed9c9d1f65ea9e4b22e5bb9e2eb471c5476171017823299a33e99780327e2cd4cc99de099be2fb26baee50c4df4529ea8eace4bcf818bf0e4e55eb73becc2a17457756208c6da6c901f9dc4d4bcce94c57c11542d516bbea793ee4e61e5815584db71c6835d2316f643313cb000d720c3bbde55b1f7591af11dd2442d8b6f075d89b3175dc42522be396f1d712e7bce22f2004db405b466af909fe2fa695a96e9c86aa3b709f47a9bf861a6c6e520f3a008cd926240f4a0612a9859693c17ac379cf6717962d8692b93213727a4ea1e478007c5aa5c03fec8600a5549a360f5f8d9b40d0342382914174862e6aef0a186053b6756499390686844e7d37e07e20b0435b9d4de840b30741df93799bdc16ab90155c7628100594ded617a1fab819019a12632ab708e0ca9c644be8a282a101e84b61b74105a6875c517c799ddc5530b1d0fb3397979dba3c19fa890df5c643cc464dfdd82411feaca732ebb439c2f5a3fb5600d002aaeba20307d4bb71572e7bfb06cf0be892f04d008f50160051fbfe3cc8b9b8cac17839c674391253b42bf0a177f62ae4bbf055c66ff1b875855c3329017b651822593525b86a83eec0f1f59655673e3ddef511423a0fed0b656240d8e70dbe8abce88e0b7180775847ebaa1455b8e778275287ae64336f696621f5e237f6fe69506bc420df300557bfeebfef7d08fcf83a4acf0d2ca2c4c4fa2f16dad5e991ec25c3a30375edf374211fc8bdc69abc44e213529cad43e64054e55eb37bb2cc596f713fa81b8e8251b9d27a403924d26ae237cf2a2e9052ac84031140ef1290a7b35766560bfbedff3e82216ef3cc9ca620d4cae76b4f8151284e9f32442d75bc9021e04d26a4511ded5d33bd9435622341e714d84ec0cf46dfc16bbd788df5245b2f29e07d49b18898f9c66a284efec47f0158586b843653f8f3a59687d225eb02b3bc1a284d556d9602fb0e3b90392d215f3758bee0e415e8fc964c84ae1778d1331671f1bdd51caad1a63ec4cfcc98b2a8072f8ed6dbca5fd49e60dd8554d7af3506dde48a1be6211755ca9b6e91245940a14c817201092d35a0f41bb575c655eecf2583b7a5b847cce5de0ac1d93665b1816f3f1d507c9862c19ca20683907f8c26db838ab9251c5cb08c9bc31251bcb24ff3d7a9a7801e968f1d10afe7eb9cd1aa96922c0b96ee0c372f5f932fed20c7659aed2eee29f034c3805eb63a5b1e80267e7d9f1c684efcb54385bb1c4a13818896c5b868d6de8058cd7257b6cbc59379b541696d1bfa7bdd52824feed274af52078293e401d72e6d4ea22de651d154e5a00c6570e1a0741627da4c4887694e280107265745084f92a6066109a6d2e72fd721f0ae392c5e35eb29d0c5045d21e8839e837759c4fa3fbefe6d8c92bd6e3944c1281336163d4c72eb297b3f1b02d4af215bcdf3cb21cc4bed6e8176c18048332560c2043afed7b12d23a9c838948d00dbdb705c613d85e95156287ee7281866f7084b982073c67a5bb1a4bbd687eeb7db89170d98630c911299422a1378e1a59f159b7336d38124ed11d1121761c7f624e7e9d513435fb58b067968d72202ab33277a196f6182996a883e4ecac81b70c928ac1d63be91794b89a0b516a3d4eb44c5912a16656b4d45746bff8db1f25634e432c6e04b56a6cc970a35cb17569624c3c4763ec0398b0e8109d6b2ed58fdd8c24a60857cba4d4bb3258023853dd573887de3f37c7aab3330f4f0d810399610cabcfcb88d058138450dbd27c47693570a632a9a2cee5b205ac5d4f8c7e2fc4c5330227a00095c22cea655a218d6eb0b383bfeb786c67174c9cad9a87020d82df08ffc1cf2405675f86ead708dcd287375b51d19c18eff3a28ea31b8a87bfcd7c9d3053f42cf576f1e071f299b831a6c2952546ecf66540a9846fb36f968e4c78ec142e08e58723e1ce0d13d768ca4d970abed115ffc577c26bd98e7ceb1a12ceabe6317af7596b333094189a2da0b3e9d1d535cfac369364e01a62c7874e078e12c4f7c0d21a5a8c6241dc9f6f02608b1ce25c52643d9513e4a5aab8b73afc5cb54fbe595eea59f32c7dc436a980c66ca8f66b60a4526f4b36926bd910e38b14a096ae65f8acba8d926638085a71b3d1b822aa0e7a7f4068bf510c3c98f3f9f6403a90f0278649d5ff9d0a75b1c839a9d6d478a5404da8cc5db58618534810f3e4d0ece2166f396b44ac8de5df587aeea6a60cb3e02451f382c3b57114ffcb420b1b94766b8d0e4ba29309adf2adbd2155ed29687116982b03763ca2ff0a9facb229704a2b45b35d62453b9c7a9efb1b08559632e1bd94748b0371c2c6364ab6c36083c48f192470843d938103f78c7b69be353aff3163d2988fefeee50055aab892d4cb776a6a33cbbf14f09031e22843d590b790b624f18aa9989ffc91b66954394240018f4e2300f624a34229ff14fb8ada001b76fe9037c0abbb7f498e2beca89873b9a73b539d0921ae64780dcaafa8157f5613b7baf2fafa90e938a9211540421e0a60a78cfa0b31774ad43c2daff847cb27201d626abd867bda92a0091939501bd137130f134fe169b46f4e29d9c32caae16566c3f0ff27f65c7c793aeb402397069a90f8495d52274a2a37029b04d17fa11a55d28d7071ac85d5a2fedda1a86e6eda7e6e38a340d73bf297ef4955348b5e65094d6b3cb386a0f183777018e689542b7bbddfae941cf0f306a302873c8713626410ca20d267dfc7a04ed5d6b948323e85f922da73bec137ea14f74c941aa2831d92f5261fd436c70ad0ebe8dd24936e123fa383736f60b295c76f9da683aebab0a9f3759eb546516aa9663f19ec3db7deb8a3145b4665994191d20f4afa7bb0b6b50ae20a9327305c7078d887f9210e7cfe0d9fda46011f0c9de56ba403cbdfbb8a7fabab7ac5a3a0b6d52239665fb86f1d587ded76be39e941e5c8f38a3f6db9cf33fac37a8550908765277c49ca7cc753ad27e66c9422783633ea2c313086f82112e9600b97899eea99a4d131e64add47b9156658b5e84a39b717dec24d892951b9bfe9ba66804f3542060fe749faf926b579ab650b7489d7bee5661c738a3c312d0d0d59f2449559765109b7d33b8838f86db88e116dcbf3f1bf31994e6a28f7f36d5ee989060a32c058fb7040c07603d6305e6bf2042f83a49e7463be3c0090ed4a23687c425295667972f8d3c97954d66826c9bfd627229872234ba3741b3a881318f8b839a371c6171ac5f9388adfb7b1ead205ed3f567d1bfe9c55625b19dd3dc69db7730a59bd156d664703decb2d29a4b2dde15ffbe42812a99f93b7fef16846e4c3b31542a4045fb14f622fe2550078c6f3176b1005a9d9a5f38c58dfc30d58b0d37aeff8633ed9a5078ef0b034700b2a095944f53bb569e8ed09763716a5dfac1e931362fe5e107fcf09272b0cf661633aff398781c847d3ed3f15d9e21e3251dcdba8bc7790f98775f68d392ddd18196902deac3a97e78d3588dc2159e2f63bb4d61f989f808a076fa0058002301db323f003b5b8e85c16805f147d3e20c0b450c4534a96357af800dd5602d03de261574661dab470ece7af5037c1ddbe723920ac0b31551fbb4f5e7ba8ec7dffde7351b750bb495bcdd4424ea1630d306e74a18cc4acff82c04c8e20576766c8a24d6a4518f33d3477fe5132d70cb6939d14819a562403a9055ba66d2ca86bdfdd52a7b8779bc8965c6518a7ab9ca2892032846e890450bf11b089cb6d4695676e528670f058f6d43b4dfde5c9181bc8a04515a308e8a8c28dbe5d0844d2f8352f1bf4adcb024ce9431dae7fb4743c22d42853f415b3bf73aec163799aa4520a22834cc2a829d65016a936de1c13084a645bb625aac79cb5789f4f0b3394f5a3c973f7a56f0e95ecf1a1d99d13455c2d91be532259153eaa52540b6a5eff2d2e6f6216b67fc9ecdf35763a15bdf57973031220edd5a7f9e71b7b7e8c49a6d5b7acb5766117e99d62d8e27863987fc4a6557aa4dc318e4013353f9ab1b168fa6fb96e9c6682253907ba767980ad0efa75ae7457517d3beffe496976d6a98f6798c84b0dd9f0bfb0abf185a811c360d132d1803f1a11cecbd1429b25713be66395b4f8dc8f9afdf95307ff85382df4b108740f4cc0893c27fde91b1b7559e352dabe870cd17799cdcc53a936784e2f654f84c097c3e5a4d6df7210a7b81268868100d03b95202eeaf6754ba4dda3aa179ca72211bb92f97534b2d687fca770384042925b27682d05108114c5ca9534bcc85a61a722b0e66d31ea87419e55709d54d1fbf0e3b38e3155ace909af64c7cb413fb3d9554c62188cc29f65a5699dbfec5c94ef2fdf10e8778589ac34f75bcba89e58bd29b9499f90acb6f05022ee9057eb43d49c91867abdcd24c27ddd4eb8cadc1973d3fe6f8ae0dc5a46263f653a2d848e130ba7872bc5db601b83a00f076b4cf0aa4e28462858c29d90d2d7e22d7de41108bdf37f16cbecdab647e724aff79cd77391ff2e73776ca26ec2b81bd743fcc0688db7235aa1c98f97a107936dca664693b64e3ef74ecbe346860a6cef33eda2abd4e534bf9dfaf60beb7ffd5926114b6a69f5669df7d71d3164f292a67710e680c77838692052afa6869d45deaf72e66089c990eef05ee28441c71e251712f792fe189a2acfeb979cd2556c6ab0870094f486be1577e6b46fa1e70177f754daa953d8ad899a99e9a23bcc9d567232867d348a230aa366f062aae8cb3847e8eef1221c4408a1abd1926ebe576557f104e22f3a58e5d0e9f424d99630feca88b2df93efc90ba9a746cc2ba2009af8075ad4c15b44f6a126d67ecb953798060c3f5b4e9598619dd6154576e6e76321c6111484cc9c09fdbf8e5a5d9a54b09d36c1fdbe3ce034d16b8e8a9b64faa33d321323db61f7e4dd0dc4aba27ebfb8da60c8ab789cf9e21dcd7fe841ef07c4c334397d6782475475e8488da84c05958a354ef6d384b317cc999aaec0bc5367faadc049a85c3e44a56d1e3f2ee9353c3dbd09b2f242b448bf9fc196ec3cd03afa2eef554fd520693fe777d22c94e8989323eb303c2da720205bca0412016654c94bc0678a6a6f10363945d1604af61149ae5690b0697b3ce73485d0486d8c54741955694bca8b7479566e112530cb3468d16d532eb05367ade167810b59163136ffea4ccdb33aeefca2da877661a4b46a10ba1da4eb325682d3acc026eb33c883de3cd4bc8b791da5378eda95e8315ff5ed047ee07ec5c69296909bb4829c0d09adf93395c0e4948051e186dcfd14f5392cf151489ca323c0d885b19eb3d14611112f629bdfe09d27aa17dda50916bfb968df9051de5303ef5f809df9b15e2d2c6023a9b8e722e5ea708be5648c5754d27f47e402a597af1a857c203fc1910af5fef63aadded1ebd08e4557d3ac6174936d8e275c94e24184c95994867db831228351fb6074d1618ce04de2bf3324c5f8dcc55504c4c6e6fff7bd03276c749ff4ec06510103f69643e5b2f96d8203f5afaf194c13a175b5f9b0a8b1d53c8288db6e735e5ec4bb5674002adeaeafff5db48054444ff2b16ebae9b9ec7d12b572df9bf21f562a70ec39036c39eb387a7b5f97e9c159e59e785fe46e97ec28b02b73eab644662dd962933286b6731fa0bb354e72d3c1f1814125a14c4f28a430c3f48721f570dd1219ae37c51b6958e821f1ed8dfb38e80a447ef05ef448d43beaef805bfb6f2a69804f3dbac25353d6feb6d36e024057470322cd44d74d7352e8d07c4c95b8058dc62f84b6aab9506e48f9db73c5093740137f04ecc5562e6b179ed686eeca17637f3165ae8bdc9b37f31f8576cb6e6cae31cc446eb4000111450e3e2e5a8a9e643ebdff077a8987265f3639bd22fd754b30aafcadfdb8cd2b76be615e5db9845c9ec620199eaa554c97f645c22cc290e04f6ab194c313859aa04c9557c74eca1b4b260502eafa14fda2a31d616a945d9e0b6fff42f621cb505ecb73af88c22d3c3e2123c6b6e86e5b0b4d80bbd283bacb5d4d6c4f9b86d0b1e62de345a977d9393c1f445384f28e8b6f6998db004f48932f85469434c8987d7423d021eb22b17794f9264bbb896227fd4a7df90638c6ab2209a84fac40e3901a3578bd615965ab7353326ddf729ac04f710468bcadd4a219175eb379c595e58d2d8008ba18efcf068f07813e5b53e4254c56a06a4bf9eb82504ed2ce553b58dc62f7d50a6000f0907d910832241428a7797913fb0cee7b949c07b16c274df2001fcc56dbb7bf8a3721b19f8b150c531b72664763d1fbe524659f32989bc37531a8bff829de78f47513e488929540503dac8b98d9d6924f3cb9a9a274e13e3f5c2b0d5c30899bb3ad5d7c6ffe668f9bcbeffab96f1e9db8e83c4e0c0d397404687fd779d64fc94efd7d237c67cbd2b0f5ea5b9efb5c0e9f2d8cbf66337290f101c4eac690f4e19f97d09528070cfe28afa1cbd170ef9f72b6aa5cdafd1ebac01111359179cfb8a45671da048b47d353e6c7af2b65f95fdc5ca5dd6455a1ea6668630a1616a8b8a385ab971471c73a482606974d5f7084dda0fa31bcf12196c129a49e69316f610a8d4eaaff8385b18d04c36e21cc750033f8ceb07f0f6013392f97f767db1fc57eeb170606de114fe5bade51f89756f98266d16b71074a093f2b4e5f3c01a1b1543fcbddda0cf059487d0c94946e707d82de199a3b321a8398d1acb1d19b881936b0fc0fb9a73344936d146b7ece5229a625b6fd23cd3a3c9fc8ec4fb9d0626541d7e1d43049dad33c08095f6bbe3a92a2dd1822d36f0b6db3a39c0b9fd8568d26489dc84c3c684a74660f49d1b7138d3acd5ff26016ae88dde1a0ff6be4f9049a0f082ab261c29b59154ab9f4352fe2512eb84d77bc5d581e44f8ab382a01e2ce0dc8a1d3f0b9e1401024c75e806ae848869cfffbe30509b986e5393dbf84dc1800d09e02f228f7a7dc80c248dd24c11220e3e8e9092115eed1861a7069f25bed7badcf4a70bf8afb19f45ccd644638b77d9b543a371aed1a0171d8112e18026af1d31c8ddf9bfb5319c04f365d9471f69208c1a990de5cc54aea7041e1845d6e01a2cc168b85dd15dbdf8eb2c498c59fe5690e7d7d7805e572cdf39b9ce39f40803b3403d65171c537ed4bf4e6c2ec791209cd99fb0f6e24036baf0006bb3364e1d80d362a4f8b8ee32618cadaed283d925ae45d55900b7f6357c296ca256b6ce76811b90a26ae5ceb6363089f5725ab68e9fae289d2f30b8d02a023cde9a78e9adb25f073bbe98d4e35e75830c8c8fdeb745072aa4c416c3d1ac9606b3eac7cef9f7bc03bd009393aa5c933c785c31fdd63255d899841e177562af32b359e5c84c668004c2e40f00d201b2fbd150e7fb4a184484ad3a026fe8eb1eaaf561efc20cce246ecd5d1d61034b6b342a84e29966d916f5b7ba7ac5a89436117f14bd67772a1bc15cda3c3743ef08e38b81b24dfd305a6fb4c053e0a4178799ca1068c4033e241a84bf3a689a9367da15e90bef4a20641140766233a6a66e8ed3366e3d77feed1a1433562d1556e7db655fdbc389e086816c1fdeea8034609845cb1a43f85e6b8eca67f550f68695b0a8e4c345559e684d5a9d853c36cb68b3c3588c2851456925a3e4ca3e28151e8ac8fd80fb7a6a27e789f551f4d6ca00073ba27b1919fba7d7d065ebd2b1ce4f84f158304f12dd85257025e0c42d62a314816cbab725db74aa18c9cfc34ab019e49c55afb4cada02e4e917b511ab952f89bf390dd8f1cc3354e9b04d9695831a9a0f5ac8c78bf26d6835b46691bf7fdfff66518bbc29d6b1761ae93fe99ed2a939cf3296aa0cf5570a3afac077d6dc0865249702d8dc0f89bb2b28d837161d44f70912c97d8879a7f758349afa781ec5f5b9824b014a8d19a283a3ecc5ad3c2f014e6cb0c55e6026503b3a03c1adf07896d23d88bf085a90805feca8d92a0d74169aa0d057b766f9bc8fcfdd1ebafe11cd38eb2875b683e0c35c68b6009fecae90b31f0eccf621f9d93318d33d7538c810a4197c290e9dba97622b3e26778a79f1ae6289e9ddbc16d54348bad02de68663a8a18ec0e7d8b0eb47472ba4e35b40ae119da4360c35afa63708b1cc3e5c622acd29c08b9baca62682548d009cf1d7eb7ed707d29781090326e4e1b789787365a9c3241ddd0ce74db9e841c66c309def4aa98c8f30ca2652ff769975809dd1a0ec3f83d333d582749fe2dae22cafe7a1ae25a8d3f6c4895601e98e59a43abab70cc9c15805a68494338a37ee1a2913a634d77699e65358dab8cc3527a80643788c980c2ee4e3141dbbbcf975a68c01d898c385f50594b20fb0672b717f543a6cf5f1082d3a814192847bf6b9124a546ae12f43e24a35423ff7df843ceee82560567a4827d4896bf8dd20ed85d9f51be579074a2223588a97adda78d1d7e4ccf2735fcdc6453983376f5210821a2a64436f43cab5d2ab6637635820b1aab7da548f61942b8299508a1c175a78cda561592ff6072a1d5239d8014b2c23d8e25840b296afbe2efef2493c6f5362690b3151dc1ab5076e160da3c6dd4e0ea73a4d1c6d53e5cf32f9f6c4cc7dbf607a4881afa0238b82291efa991ba353686c910cad8d237b9893087febc670a9e83920fe80570de9623c93c7a4168c9f48d7d54699af50de5109667c7590cd052cb319ed3fe29c47064b11997a7cdd795fda39c6d6e975e64e3af3d0cdb6c87b59b1c92aea9408ac93598f0c7170309de92413bd8334ff6973f170f075cb88d836f7ef66cd892b6733ed07a4fa7ad08e8342ab2bee7b5e3da7179c8c03cf82b8a739d9a108a637e57b9963899f090f212acae4d34ed1995eee0cf38b2db7ef60feebdb30ad5dd9be782ee68dbc5e909375627727e98446ec6dc4406e3dfbeb4d2580a96bed2cee9174bc49712dcea664f53fd6983cd5af243ea6a0459a71a8366551bc4ebefa423cb20adf8900f0c49a1a170ac15f297ebb1858b270620f78124ff3012f15096fa77a5140782132bfce0c7be53a0fb28085124e938705dc1963c8b00fb503e671229aeb11d00ba7d72a46636aa33f69684ab00aab9cd35d9969b961e2899c8baeca4795e8f84f062e9d84a5904362770b4f990f307dac7f25189f015aafd2d44e63560b1e0d6148259291f5d160dfb4c6ae9b281fc0fe904bf45831dd3d59493030961b0057c1ccd48ce6458dc496939a6d99d698dde12c9ab6cad0fdaa74a71596eed961bf90b021725cc66af3656554384b38a5e5bb6ef1f69ddf655b46e570f6883d78c03aef3f0c58c5e42c8d0c437a8c5174e7ad9b9397f3baa09f42459713efc13f36c666f0bf8bb0e5c94d96f69736a9ed2443e2d29a9ce111b9d1e707f7dd999518820bb3c85847ab8b5f1639b2ccd14dd77cd6136c2d0a4e0302373f784643600f1ac3165852475ed7c7d12245a16d75742a02fd14e66bf296c07b8e7b6ee5befc8791edde54c7f994e5e039a566e5c6278ca994b36a40c71d1b9c84da3b427a559618769e6468ce9ac1ce9823bd7012786b9d626c8931c44de6976c3538cdd3dbb1a9081df8f43c44f191b4598485e79e7a13677b299bd97ea5b25e9a142e7e8d26f272402b9275917312dd878caaf22e41852c3e968be49b6b6b0f7fc1b2bb1494973aa36cea041ef3fd41f57df23558b1d90d4270c78815fd5d419aa8b5c358381d64b5b1cada71ba30e28101c79e7f2170f47a6082c27b214be4135c419012f352a481e2aa47dc382ae51c77348c106299dc2139a25ab2a5fb455413dbe94e1587626f5aceaf534d0bbbb232ca444b1318ebb13c0069f95060c27334fc530e7074467cd2d6c88152f42886edc4f4e20cfdd584a820dc47d9faacd0419dcd68c18707466fb1d2258731c35fbf26de1303ffe5fcd6d83b0c9de5f57ee243ce5cc9e8425b7833ca2a61993573a183060423a6785cd06859157cdabd5e4f35907a0a9cfd6f2dad27c8abb3cf3128a048dca7c25a9884ef1bd8619200f4fd18cbb854457f6ac06ec32bdc1b74f56ee8f5a80ce6860773df70397ae009d8744a421f3515ddacd056313b7141cee4b5617a77bf3e1a9f383b938c5c41d5e13ce3e21800856ba0cf9ffdc0b47ac6527ce56ead7f63cf2ba9cfd03945e4a441b930a20d0ad337c7ebce591065a5a70a65e3b78c97f540c014506c7cb8d962ae8bcc4a0eddae8252f8f63d786767f12d2eb074fd4bd3b2852e85debdabdac04f4be5379904f5981a50e0aa0f57211b1cfb18220c722c6a1081641d6fb7a6a8524beec22edc244a7e169e6aa5264cded513185fa29123dbc9361cb5f3905d749d62d3bf4dc44e921b0f01b6db18ce297ce43c91a2b9013ca850168782609b7dd36b598a0a728ae45fc512c8521f7b7eb27f06dc916b76320fd6cada5a2037b4c01b3fd5e583ed57bd47849e4abc31fda892a6d13552ac9e611e8f2454f889b8907bd0f443fc2927c18ef474fce78f861772d965bc88bea17fb72191bdaaedef0c2a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
