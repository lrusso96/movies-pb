<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0b5b4d7a2703affa8c35642ff64de5594acec61256d0c20bf3d8653d54baee9ac061c8a4709c9fa3572bb2f3bd782f923685c37d9958f4cc8c4f6abffe01b2967c4d9d83810e2b53d5962260b7f99fa42d14ce02198b1aa324616e21305bce98e8a8ab0f942e81d1a83ba7d9c7ab227acdbd0c79b3c224a02be82db79d0ad481e51bd9b735c7b1e71a5d54c76a72af2b03ae308cf4ae505286a218a5fa28904d6e04d7520dd1a02b901668c1e4667bae08f64ccaa4688befc52312906e73d87d32547cf008c3995dcad328f3703058d241ed276b9ea946acc89abafb9e4e98ae0246faf1d6d4cf0381741c326bfebe692ed24c937e655f7c71176d355c5fe64ceacfb26efd79713a3519399cd7d973aba6c8e1bd29eee275ea170fd2c5a84535616efc52e48b3b239a122bc31114580be44c35a55a13823329a6647f0a8c3029b8bc37a4ea3740dae0dc7b08cd3ff0703921e20844319f83dec0f22e83ce265b4798db2f1fe1591b2939cd4a14a75e8fb43bdf150a2983ec022a360303852923e521cfdfc22de3f6c36507dfb26e805104290f819d01e54b952018b461d2f721db006c83dd5bebfe370dcb162d3c71efbe6d29f3513fe040f117ed1311130dc0db6b9fb2004e0bc2ff230103820c8237a447ed4c3a8c274b4c21f5bd2f37a075b13614ffe8b1b5a1ecf015b1825a2da086b0888e191644de84fbd9dfd5e970d6876c1001473910c406b4425a81b26c27d9444c1d03fdf9231cb625565655ffe62611cf9b5917b2aa6e75e91db9cb935b89b9c47301b4fa13fd2545253c842264e0cafe1d14b140755c494bc6e4d16f78606f20aa128dcdfc9aca028c9b435d720c1c7caa1f791c5478581e58fa2ec93aeda7269849a86d0d7e6527702489b276620a6d1de16411c7e982be1f4c5b1baf04b60edad61b61b7334d8550c9f1a9956895325490c5e7142eb2129f3b594716b3dadd7324fffceeb8cf49833a53fca95a24b15c70ee76ec6c949b6596d2bc7a89c762988a0cb6d80aea81942c915a500aceb5a7a5e2b4a509a11b2042cebdb74c4153d75c3d29ad856b98ed7e951280a1e37c8e0fa82009d86096d664bec6b9983b9168ef2a7b839a1d2b33ae666b6d1276672e9c880708e387b11fb7ffac0589e7365cdb1a9530adb750f4b393363be2ec18e9bb1f1a6da1a7d482fd4911ee5a3673d6fff1c8360579e64ca0af92fca1ae1ee0faa8fe8e21af21021571fea0c3ef4486f2ecb04e5fc9e26195957d34e2691d49688309b4fb4fcfe7606c55c2f53b24f98130897517de76130455ff20ac57917b1fa74b9305cd307ecb40c545a3bc9d057bf4b954ede1a5ca6baa8df9fcb461d77013c3633f1947445fcc61b530b1d3aec23b718f27065cf20616c06e12cb48e0bb6a86624b8747a71f3b57393f9828f4477a69b941f43095030b66170c05a5ef89a8fe1fc1a47edbfc03c043232de750ae1821c904413095d22a24c38a6919611755350a018001ce068930be34909ab8c31ac33dbb07a8ea838ad9b209f0c7f36f569c60c5f7a704352aa2bacbe595e54aea759294727acde572d0316915800c79b39bd6e000b388289194edfcdb5bbe1fc477747a5e65edbcc1bba915c6b0553e6e5d8b0ca2983f8e55c6bbc1aa03c4f4b6ec26d5700317feeb48c50dca23603aa15294468f9649e1ec09419a9b42b9042d073837d77cc1eb845fe5e446e52e7d770690c001b1365454b88a73375542e3c61a20f1f6e218a054ad2b5962bd8fd3094bfd7e91e8df74d6efe92ef59542435d2a8019d7d8441b51ee0885d6929a0e5d91caa0b6719cdd2cb4b7a856f4d71967be93e64bd65d704c7d9f1be83f1048e545ab010593a01e75cf7a615a9da4457878da15bc305b784be1146bc297f70ced3c0e6d51cf1e6fecac57c55f8be27621081dafb6e754e8c6029c224bbaf0fa8694e1e05c8cecb5ec707303b24424a1b92f51201a118af9b3c750d20b906b5a388fd6899fd246f47c457cab5a3fc5881feb705942860cd12f30a2fa23f23cd9ceaa16c913a2000eb8c877eec26ced34bc9eac52d2f494c175749759ab02a029f022c6b5b90c231cf368a0acc335633f652687c0f114a9d299cefb3a263d412033c300e25f527eb8fc798226569c34216505c89905426c386d3e96ceffaeb3a533fcf36c6c9d8d3e3dd6bda1733bca98e45de377ee3df4842f73c8f2630325fc7e578b856389e96af6a8b93c2b69bcd895d3a36b6a3fcd608c72aebc81bbd27a1ed943b8332a68790cbf3068ad86d77aa34b9f81873a82f4370d37a998247388fd19c2e3ed46bcda1fafde0fed216d70da97ba810ac951ea44ec9f4595098f92050174265cc485089f3e2186ae7cda29025a362d10e3417cc1d12a22ae8c32aa6aa14c73c0b38b7764b70dac3d4dec7cc31bb9dfdad2ec4b48742ebfd9df302f0e5223fd51367a4f4507097431fad7a9dacf94618e7da634032d3d48c9f2be76b487e191b7f44e57b7968cfb61265f9991149dd6bb53d40ed1e801043a73860dedddb948d338239d9597c6eda28a6d9c75df71c3dbf6db37db2f9c4083113fa1cfafbbd84f73a1dfcfe3137b24d7d3313bd128e4d1fe57ab1355917d32ec7a80e8b2f625280859ef4b62c76bd73f1b765e07f39365cd340e851aa17b9528e9eb669c3bfd028de666772d3fa271cf9093184129339358e6bb3fdd56cda1ae40d4acc752808703a5e1dbf3c08751daf0c8c225b7270a1282ac4f0805d1b0778e49c87ff58519dc85785eeaf25aa1c4a3c4943797430678f830d204496396ccfc746de021ce41a975f69b7515448b064cfaffd3ad4afe3d8fcad40b36eb52aa8bc98d7ac461aa7b357bd7c3d5f5e9166c878dbd00a8b08fd24547b4719b2df038d4fb1c61e9958ec7ecf8985658e44e3b98d813de3685ec96fedde44a47022e92de357d0b77e0a8152b4f3370a0f1c0b654754c2ef1fba04f7fecd059179b3b017189f140570d712fe10cd7af1639d5077f6dc0f7b96f7d9089fac0f505ba43cd004eb9ec17e1d4827f0c3aefa5aecf3ee79356dfd48b8fab4f15bf0bc8c02a429f34f24182f7adad2c813246bddc4d22617da0999feb7445f92dc659f5dcb453f02c79f2205abb0a112374faba821c4f0e69930b65ecfd800acc283ec5d5397b65bd2e8b5cae49f9a69f08094f08b5405eaf104e8477f1f316939ef9a8a77ec48ced64fee25a29c67e731cc1854d2398aaece381c7cd76b0d69e01604832bab8f8ecb6a47a3438cb33d5d3c5be8d0f13231cd8d79a24caae1e68f61167a45efa2aa8bc28f5768f8b9c0e1622607a625055babab243c640817d948ff01767dd4d02e08739fd774162b7d0957f8df2a1a4dde658c34b69c55f0f4ac1e55df7307469df08416d3af5c362760b082ad6e59ff11719f6b88de94d2cfc636fb08a31b6c98a522bdd7c0c624e0c5990aeeaca8b9462123cb145d9a1b2e917fde831f3812e4b775948e207a22b80d5e060b89bbf6dc62447e362efe64fa6ec5681e6d2f5545cd6d02bc1c0a5aa586292883b82c56ac8ba24d2a7f3f09b1f078bcf9e20572da5db8442f03fd9108cea7b941e1c4da8b84636eb22d455dc647086070a455d262605ebb3064187fbf3c51b5db4902998f6f679aafda8667010d96e1a90c55ad37dd4f4d210dc4fa378b11cc2aced74d4e855c7f89f4f42cf126760eb4a4a14fc15d25012e094aecd56a3dd142443818512a9d827adbbb60649a6055351af2a1ce516d1fc985c80678c891616aea2af4d656d437eb3772db6119f07389358874f0e87a007a7eb165644c6a4f2eddba13d42894fbbb6d6d5ed693c1d92971b19e3cb6e21f9c3a11872892ae7650ebd1ff9c41fe904331ce815625a5f96b303b015b7e2fe69b68710d036ed47b77e71e69b0e59ae6b973cc70d51776437d8b8e9b8453db0d7438e204510f2605cdbe4ed69ffb9128d8988f008cd16228083f2dd2ec5ce0282df8bd00d033730721f0dfda46e8f88bf32de4910084c76fc48e05be02ebd1b3ece48452126e47673f331b49209ca9303141bd34b50b809d1c594ed9c1373e7d388f67807ab79c7fc4237d127a376cb8da963d642280c4b5491fbc3b8bc4a63523656cbbb5e28ed695f8106ebb24a5f7cff33827e39691ef6797d3b9171f6620970262ef4e016cea4dab72414fccf9742150c22c15f36ba4c6872e3e9124131cf2b2f1b5fee387cb756acd082abfe1d8a5f20a3c6383e7872593481592a5248d26fbc91943bded1e14a3669b856238e9259edbe749692a62041d5a9769817c4a01f0af79325a5bbc137217cf485946315b4d86dc35351448845ef393b172c6b8cc1830775d60ba5d73a1778a1e9fdf441f6f66d82501dd2170cef065cc10af025e75c7f663b7f324279823512cd40f59dfe2bd4b482fa290974b62a6c3dec508026d1a080bbf2fc6885fc78eed41f79de52d58b2b44546e1dc3e5f750070192dd534e9911cb5ff0e54bb17fe62da63db865f55f739f33bbba774308db3571d6fe1ab2c4035b0aca83fb183e3d1eadf554ed76f42d7e1e8dd0a930727de8ac6c06b8ee38d5036e5a9a4b82e14553820d321a50611b4b1826e1718b57ea88baee1a7eedd9e3904403b0921c933b2325bd766c1a93b452492b0601c4dc64f6b1cb69ec6531b269243055e4b0eb5ac109d62baaa6dbcec3dff920e200f28415a3b7be3a24710ab87766885d8dd6c416dbf212c1c3aae63de88511da35cec8587682e2b43b514ee4d189d754e4ebadf06cbbb41d48b944cbaf266e8a27a2cdf7b28c3a107c94187f0db3b9c97f14d2a9e7968d981dc86d54894284bc92ac9a172d42a2af75bb2d5b6bd099196a14f708fbd9b9d4fda69e76cb1df49a1f10b2abd4034de7473a6cb8958cf8990dbe6d270c1024b0eeacd98bfcd2ba133e7775ef8568755c59eeaa72a4a17926652f891d2f33e47859bfcd444869a8cc1c4ee4e00c41fa6527f16de77969bf0dea5c3f42750ee038260d7db7d311ad768c2230a4a9af624c93ed03229c669ea68376dfa200e18e94a2c24251ceca3e55ec4ffb7e9c1211a556f2ab6fa0bd217ce1b673093aef0c8ecae6658ec14798084a66b8fd4036aa51665a03dff6d348ae07d682aea5d909d6754d8dddbc85802b0c17d6d82c843d2af25f69bf4dc597556d32ed84a68cc3c9a0b5304b9cedbb67be7c018c577b40955b858b10a1ba0e14b1c0386b2a730ac4d1dc10b559517957838661a8472389b97d9d7cd55debea796050e75140ee348a9a4ec78ce26166e4de82cc0cd1f3eb1aa602bd01e0f82a476257e522008a305d4aedc0efaf517f05bffa70378fb8f157c59db3ce955c7242e9fbbc3a439741d2239f226a8713d6734940bb07c8e56eb6a724b4b51cb67a6aa1561d7b3ab988705f6d4bc19e4c30d67295da03a39f28a9abe5a3fe0ae9eeca0d25e6111fd5a476de0f3f4cc2d6ff6c42230c5f1a1f9c9ad3e04fcd27fc8957885ea3946acca0e29dfaa4708f4641792f2fa1c45aaaad5dddf86b91531ec440bc9e465faf07b74f390eea2b8bce0c4041ccbd5bd30b0d06533f301c6cb4e4625fefadb6169a0057cda7d4d7a57ecbe29654a2f1c47ea47dc127df720d271de1948a052e10c42823ad2559e4eafda1018f6628277d4689c4ef7ea6347663ca98af8d2d4c08a6511b05727d97de5b9e6f40dfa5803cdbbfdf39e74c930da0338ec2dd2f84b9e43872f06bbad9c2f433ef920fc43b3034b1de456e82f958f5e200f8a25a0d03a9b0d54ae33b33d2763fb9800b62518460176aae83e0c4c60cd236bd2667b57addc7dcc46e9f951f00480e6267c594b0026c5798863fe5adc09e5d4d92c10886a96d437f0078080f65fe80e7e5275e25029ed38a8b08a7c63819e0d9efea56a6b1be64cf797d63f982237900ad84ac1d7571dfca18d0141709a9f1ad4b2479380e0c6c437e160f925cc04178c3a3882c83160418d6c60cd73b84278ae483abfbe824e7c7248ac7a7268bdaf7ca7645165599fc481bbc9ff398394abae610ab1dc8baaa5a9c0becd9d8f45fdd8f108e8c1d9c08d36ed86665df1ea704fe0f008f5315c2d1f8f82d13ddeb16ec74d1cafad6bd029fab4fa617b32758c5c62fd1f539fc8b8fde1ca99eeff05cab7ab329bf03cfd809273352c581ea8229c4ce84eb3ea757ed9ebeec7246e08f94984f5ddd0e6939057dfdba1e1a45026e0458c4c340ef29074f388b380d686bf5c13da0a5701d9030e3f72b78a72a6f52bc8aa4c9452d5296e043119cccf7a2d76acb76a6cce7e9dbeaf0ec50947e41fe2a7f54856d3f1f35c7a1ceb1200a3849cc1e0c7c41a33b44c3b3b4807ffe4c8c2255f68198d72bfb18b144a8c51571ac6a7ea0c7e26bf4e7db269b0a08d1fd4808dc2adc525814ac55819a84cf0a9e60a0e95dcd40266e06dec5fe4071e64f2eeacfdd45572f1e376cb5a9b86b797d2c96887d324436e20f6286c0dde3deeb295809bdaf80572fdfd874b442c433f50bf5af1af5b92c3e1b05edc31c8563d1ef832fcd995d49026a1bfcf515284c9613c225405ce9a22cf0e633a67be74101dbdf313170af61e47c18305128a6012808f13d71a666ed59eeb6eabaecbe3a2696a436945633cd8faf59eb9cb38fe27526c18e7b7811662d0c8b7fa3c8499c89482d7c921823ef86a276bf289910009ea8d0a7cb46081b304622d00cd3e9b35f06bfd97f0cc90a88ee6e811d0d3274819ca9d401618ec6d3ac93b9ba08d9952d8b338f43473f76e03d9fa206f0358c33010d6b1553deabf6a5acab11061acdd1df029c3e57ecb520df6cba13bdc73428213966300c104a4c68f6633b46b8b3fb10382d3a16b3afd9d992d7d4ba91da61213757cf180a938bd1ed59efc5a31e7d476e52d973f304a7c7c185ff38fd2ed67ff34d3b81435b59412e04355fbb09b2474d9f5608f8ae8fe88676567f55c541769aaa1ea74529be91844eb9ba6923b7bc87e9a2cb16f5c633da9e8df07182e3418e570075a068d6708452b382f34c2fc093bc08de8e67f1c84be4dc0748aa7b55314b73d5633415336fdb307622979f44f2b2c9be6f5fdeb15b378ac765a1146abe596fe4945844d1df5ac64cfa239706942a42d9a0e1557df56777eae7e0815c7aaeb23197abb268903adfd3a93a01f68c45d7e0b991b5bf317164c8de1531a5c4448dcb39d6dcb43d90dc3fdbc4326ff97e8ec243238d99226e8b1dc8c429c735e9456c2b8141c22fbfad7bac807c472d765cac1cd3cb8c7962648e8b045c6124f748ca2bcad490995b0db18275ce6a291eea800975b0c8ed6754f8e84f00e5e8e3c6b437f1c18289d0c55749b27c28727e5042fcf43f6408fd552c3cbd54e5e6d096c89c02d8c6362f03adf9151e30a7fe75c1b6ee5c66a1c5a2f6600e28b8d143b024b60d85cee59a273c5ca2176abe137d772e9c2d1472747e5347d36a2d1aedb4e81c0396303e62f421e30f4a30836666e493ff8d0cd60ce3da908acded8ed012028347bc5bca3a99ab46be9e0f9913c2b32d68f0d5811d89056de4cc841ebfa8bd64637d30238d298ea76dab0c75aedb99fbd9529c343ca135fc3b7062d37bb5185e939c79d12f41bbaad06520ee827f319172cf9c4372940522089efe78af959abc6e2289089d94b81e7772db4ba0d4a9936a32e9139500b4a22b1fd0fe33fdb49c7eb242a8cf82c1a59e627fe2c19c9bf465f33535e10f9e3841c34fab82c28b814d2d905b03bf4adf2568fc3a515788c08b07b41e047973f7f46b23b30a8d4241d10616f5b302544c0e1428ca75aea458215c32bde5e0e51829f4ab0e176c48db4fcc3024cd928718aa7f77d16a2ae2246992a9c5dd8a1c92c11b6465fd3617a9f9d3f21e1dfd9e56c60492959534d69579865069f2212e64959ee74b9c48843d827a81bb716d0445ae8bccae873ba80a6f7dde6e5fdc5ba3dac71ba5c2fb138bdc39ce4f75beab5e5ed449dbd286578df3d251ffb0c30670cb5b461bc116fd5ed1dad9ee46473830a9563222cf79ba602650c16888b1328df6fb854f7f00d5c7fa5ea81b614b7e38a167291fb340def0b0d9a8ea5ab162874268db142f0e595afb44bb6f949af207a4d04c8bae1c2bf15cb3507cd8df85fbc0cfb2183d29ab2ee3a29e4392d3faeb9cf0cda4235fd90033b17e5eb7bffa3ac178f2d99d25d275e7e0e460181853f7cd05be43d7edcd3e44b10f1d448487541ff23aaa6d1294aacc67c11cab5cfdf632095622337ff0f44a74c2a7e12e0da444beb45b3473abefafc45b8ab5febb79a5db06c2d7b03ca76849a20a36c0cbcd2c43acfae919526ce8c2be21fe45d2ddc6a90e606a3845cb6f4250e9baaf5c334ea463a261ec6055874ee528446e5424c587a26551f8323cf93d467561f0f2a0a7a2bd62cce9a728ff78c91c1849b74174e46372e0d39871e56951cff4f045ef93eb7bbf93bb29ce20660a5fca2201570ad5aece7f22b274a970dc96d42376863bd3399a0c18895794be12a5841580864a31632e6bd9f0b9dc31284ba377cc5c8ff4f67b696ea6ee88c3311cfbed960df867f0f39d4e330528aed966fb5f6e730e9f6b32bbafc1b499eb15e0852da826e2e14814c6b282cb43f2d4b5eb5f828cf67a2e845600e49aa2b87052b3480fe49eebcccbccaeb00903568d53e10b70eaaa4cfca4a1066a3984960022f76f4f246c992260002c98df451ce8607088944367e16099191f5a365386f44db8ad3637a29dcb3a05bd1eeb5b599779f2c02554dcf96e73cc6e81b249f2eb334c4f1f1aff0ff3609972f355f9ea8a6de14437b1dfa9348e7dacc8848984e2604ed30cf410a900d45e042ca58bb8a0f8216d5f58bc26d0e8ae9edc9b6f6740225d05a0ffb4797bf24616211e55b811146565a45f4cbf38f57a3f1be6c71c8fa6f37daddcf9e0e34c2f78c1c1d968d23f18ebc4621eaadf681b2d2fef8c6792e9fcb0fa1d8865359fd1ffd3571b37894d19213d5bbc05a425cc0467cb444f0b70fedcec0b7fdaab210ea4e251fe1776a01f4e1a0831000eaade33d007f21550956884fb3d28404ff25816f9bd75747a27c703f5074e5bd5262a0026a339588c7c43c831d20607e5765a8bb9aa97e4ba02b02101ee7d09562887ad3adea00fd8edfcd546844150040364309f035d248d569378b5c5e191350db5f39247e06f1082835ff66518334673d93f0728746a02f62bb05a8d04184472bf4b2f1d172ad3cd5ccdacce6a06b191a2d679b96e5dd6046545981b1c9df1e7059f34e6c762d0a1729156fb76df59ce88ff54a6c1c9752a3d6d7887b7dd6f6f7159dfca82c2943b0231a7c2ad543e4913be3a4a918b0f9f7d7cb768ed9f5c1cd1b54ff4fd06e423f8659f2a43ff986140a50648ecd2472f36443a4be1d4103415fc4f21678e361c36346ba72888f2fcc31f41dd0264926683015673d837cd3a4b0429d44e2556119ee897fa91ebdbc5119954a3bd12ca15cbb60dd35c0eeb2e1bfb1ef86928fbb7e2acf7ae22f4708cc434ec00742906cb98429a8953d413698cfe83b8dfaaa087cf339ca1b63cfc85deac1537b6d83bd96ff8dbf505e7205cf26c9332e39580cf93a12a868707705d7f7d737064219673f655bc1a022443f0cde8d3423905495677b6766935a3a84736c8f8cf7553c13faefa420cbe84c329382b443ebcffe302a43e9a1033c812184a92e94ad28ca879870629b68591103e9357dd5e7ccf6fd821d87d6037c958e7f0a66f831e2108f15d4426b1204f9297bd92c3e8ee8a524c587ec0fc513dbc7fcdd1d541f11483b70d0f06938c530526001c82585836aa886b4348307409baac5b424b353f4f0b8c79a8eb6d918b9e8a0ed47e65971a671904030c248b1d9d288d56ef7bc532d92aef37dc14410411017030dbc7fd7b0d3ee94180db0d84ae63f28b682b12011ac89deecd2a3123d28d89a191d06b1d8148189283edc60a1fe33b4122c96ad5c0cff05c895bb1e008f605716c0900a0113b614e859ade5a5b68691eb61487ed103b491e3be7138b6835df6c3de7f9a102661da228f62cec799fd55fa8db64c294c0b96a82cd45c8bcd0a0fe1a384c7c35aed9e26bb6001ca786fbdfeb03d5fc3f7e904a64f76d74f4fe7c87dc822284ff00147fc5e6653c65152c79d890e0d63e77bcb5020d75d3d48d74fbcd074a7fd86d5962eb262e1ca92afa81f2640a3f0642b0aac11ab8634d398164dbc71f600f6b25c135c17ff8e16812cc3cb1712b42d446451422625f219f182970e2710b04d004b8c8bf3148ae121900faf11136c7eac185a91ee7469ccf3d0508b22b4e1dfcc987bf1eb8774b6fcbf8e6f0b77183a014e506dd81076f7112d649d485b5b44a7acd0dd1a7a87d24ecda517b20cdda898105d9539e2fcb1539a77175fdd9d29cb730b9b4ff2b5c53804fae1570ccd034d03cd3497a13219a6af87c37e5f1f51705415ee059fbcea5ce6971841c7027d3a74b4ff94f2d7901be0e50e068dc1af8601e5cb85d69c75818a13bb165309847fba8a58fa87bd30a295c202834111d54b3372ccdc60cc5dbceb32cf921538d3f6c1e9ffbd374be044bb7323b2b1eb2840f574b923d49655e457c38ac0ad4b9654cd5e4e25c243e560ca0155f86d575ba3c6e0b4dfa94db3fa9162e0a4693929b7776edd8f7dc9c55f43c38f0381d82ff053a4595941f202bc4bd807b2c6e65015c15612a7d0e865e3e856ee5104b06d3a7c7b1e640a366ad4c6c74be11029d9a15107cba27a3f998ce1d28450074002a64d0e83c6360304e24d01fc31d0598009886757aac6d353a9d95114dbef2da24150bd3b74ee8adbb6daabef36056cbfa11b0538b030bd4d7eee67daea6d0ceb4b29fb62bbf873563ce2fd95334ad31e46b1eb2b7a0f8efbeb25c763004ed668bf6c12603d60bb4949a21b1101c6639e562b457435476f1069596f304df15a1095230a701dfb1f10a9c1750cabf75b36cb0145bd6c79c72281407cbb6f47ebf8bc7fb0d447caed6f0d6bc5bfba1672b215bb74df440f55ddba7c325f5a534ef70ab5d05ff39972ef22fe2da3aae6768250db2d0471662af746708c563f3ca445aaaba70bde8795748f9255bbe70ee3a766153bb6e32dff17d4534e3d51e289622da1e546d6f0ddc2da5508f1a410ba811a24082017f7dcaf42d27d63122c4f166921af88adbac1ef2cf80c0363636cb18f75a8db2fd1b8ddf53fd790fce27594448259abef4cd18ac4a42ddb6bef4de26745ffe888c293a063e44a10920aa612ff888c83c2918a826a5cc2bbf70eb61a4600083abd194767d77d8339c308950a25b39ac2427060bc7965e7cc6b2c2594c2fc3d817a2f3f373d432166c0ac2775a7ed2b0edc590fddf2ccce88ccb7312eb64d957f0e0c11fb4d2aef14c45f2e4c10bd0fbf1eebe798675d6c028b761e4344bdb215dfba8c694b85cf3c1f1dfbfe03ccf6adcb4568092c20ffcef4d3aee767cf19c4c48d951bf95723d108cea33c15e10cb45fde74ecd423481f7f881e25aad05d35d06d807301c63628924049a4e5ded23eaa27a20a568477e339b1f5ef437811fe4b98683a50a3a3bd8ac1ee962344dee013627debb05daf94b3a989cc6ec9d776362bf2625ba8dce2bc44223d170c790672f91bd7cc3aef9e088df0614b0bab2c085194c2ffa909e3b046748979eac5d526d4ed1482a1cac961660a3c1eec0f62d4f73e70636699ccb37f7f17c829a967a41b66bea52b07c06ad34b27d535d09431bb8447fb8dbb3cf414f93f602342e941f673b3b2683d4edb3fdac39971de7c64b080c288bda04c94b7eed305ef3db1be8d1785ac2da7073a7f408631256c889344fb18df77e04ce81c38d6be8c8fc1830ac87a68b753709bf3f16d64651bcd6c4acb99f03dc0dd5e9ff409e5244fa73e6cc301defa9648408115fa6fb93717cd1fcf5b8c57ca7b45e6215f5eeb32ee5f855555c21d6d304aa6893a2e3e61c2a104c76b4f72e960e454ec18bebc2f6893fe565c028714a42c1faeebf38049e2842b1817196f9e65d274f6f0f29d9e701891768cc4cf569b412e1d8f248446b4a16c32e8d98ad59316a98b39c7a0138d96c0296fa6782dc7c597704b84999766e07cda0b67e63ace878f0f2381852f5d8f4d17251236ad386dcd2d2febedd144ac68c0815ca6487135fb2c99badd020ef6d581b66bcf44968c853768b21bbca08a670e927b6fbb54c2b665ad85fc5f0361d4e21a32d7638817a559b2ecc828f35f6fa591a6d61b5e63bf8500e29f8c962c6f8189075b078d0d4aa357575c8645d712c22fd9ae432ea4dcaedc988b020565599413e855c337e467120861bf4147c5df3f634625e2a0c8fc6809c4bb0ead5070ecf84275f38bddaf9d537231e8f91b3deaae3600f5962ab97c7c0468ca002958971767e592a399752ebd78592e1756ab91f1caeb9c41f23d6367ab0a7d095be39548c79402702bfa507d3c86f3e922fdc561559f9f210833fd75001d67b583f9d8c38b2680dc4dd9707c74406a955dba4f9183d6bd49b079b08e249306614df49132fb03256638663793b89186203ddbba4673ef209b536378629125b0c20e3b956ae0990131eca9cfd660fde5b887e33db60a8b4f7e9143aa4112bec0df80bd498860ef70bcfd0c14426dd809ff3fe98953d1bda1b79bb5e19c9cf4a8dbdff130918e6a5194b234965d7927b63aa0c867b6c5488e709479ca5f23e7603d5850a600707764b0155aa915408c3e8dc3f984d60dd005a6678969bcecc8fdc0d76b59dc7cc3f4697e1622fdd01943fc5a2200ebbc795c90424ff8a4804a3f600a1f7a93e52d57d2ede6733ffa1883365bc9c256ee384e5609a29ad0adbe6021c60beb93623e53e08f419900d3b2baf05f61352dccff0d3d5ef246775ad6b5f10350a6fb18953f28891e8dfa84eaf083cf98d9fa8d707c36ff22f1a232830b08bffe15fe904157e2432993dd6dd28ce427991ae454782f99147162d46fa589ca045ebdb646363aecf0c7c75ddb09a062cf7d6f0113841b18efaa0de4f0bdadf0297452d434bd7e6abd399766226cf94ec98c114bc26998977c701c3913606f97cfb268389daffd8e50e58f9f2ce4ab39f9192f867408eba1346586ac2bdcc79e75db9c682cd884b826976a55c05c19465bc6e6bc65713b063b01aa167a72221a5a9805338993f28a3a2fb7de8d8092103c0925ee9ea04f3a854627524a2c94200","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
