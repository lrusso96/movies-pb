<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"435c7734fd0214e22c1d256d5f1c1c15b00d7268f6f86d3b992e6a86855992c16b1ab3829b9abeb9df5fd1a95e4654a61234cd544f2fc8af1005a99db5940e6f5bc355a9cd565bcdca2aa1d3ba612e2184580d7ee2bf05f7ab62b4f7b58a74ee23305bb5a9abcf4303b19b88dd33bbccfbf06661a38ba8e90ce4b29bededbe478bb30ca76ad42c151e55ea3b90149a63406754c6f67a4fbf77cbfface2ef2a52596d6512ff38bedfe5f75a7f5690d45da39d8823f1ec323206f329f337d1255ae135eb09a43a45e838783137628a3f57472894e11a2193b099a3a390f818cbb666ca38b90b479b7910f9dfab7ffbe5f823d8240ccfc54b21e0f5a8b9dbfc72206a97d4891dca70e217277a6c186fa42fb2457ccc663b3997d2752709c3bbd94ab578ef1b1a4486fe5f74a08e7b6fe0d65e560075a964784f270b485b7c827c68ea7eb59995bf4fb0e32f6d3c64a699f77870127b0a258cc935f71849ab8399eef65fa66fe9776e969fe3dc935f50c5d7a5675079ff54e458e6c5bb8f9167f28f0eb2b4bced10958cd9072109a230da8ffe5f58d836e0af9e38037d64d0ab88c1425a2b9109e21aba20764e180788d26e382375e5e11c538dd47313e28b2ebdc1738c8e962145dbfef2fe9dafa201a15154b440a49b8ffc8d63df2ef48d6c1dd447e288c2da31559068956e8a720f41b570abd48c48e68ab10314114aaabaca38dba4ecdf5b5bbda538a30710207ccb170081430c766990db6c0aa86de8e71c83f83da5bfd438394611fbd4c46920a88034f29a632ee4c900b3584b8a585260659b694abdb3648ae0f8ead517f15f7bb045b37c7c494c04d178de900c135c21a374a6229cf0d84ba56657b982ef4a0c01ec089e0fcff9c3be54f54bfb7316f804e50a467b1ed736c5be24a984fb9a59ebb4b802d07bef6296ae99e5bd2ecaba340b69b4ac84921c142f26751b34f3427b158bbe80fa42f11e5fdd80b5b281db8373c1f0eceff587d6d37037b6ee62135e555f01ddeb5bcc96bfd6c7b3c5f82eb66cc42e8911ac7cdcd9ab3dbcf27fb82ef83434a73b130cfa567a649ffda124e1aeec89bcffa2d476bc716236453bc3fae4c3db71981c4d8b4e618ce299d12353377ff15c7c63cc288940a453e465366e19ee2735af17d3e677c5a1e8d4db4d243eea8e133017b00d572dd41223f2d61b37aed20dbb60ef6551fa2514e36e42a037bc5bb76099a5353b7ee8f3119913ee626b2e38eb7439ad4f0cf7a51fbc9cc18f5c75f503c272f679340e97201b905c3276d8ba78c28f58c5b3428586d68f7b51e8bd16c2fd2a34ec9a3d38a81c8b17522ab7a4eb203b7a9c6c1b1aeea9f64697e7fa4c2438439e976468f0cea2e9f4e317c7869ddeabe6a20632f71aba5ad17616cc3251598a448faee790b2c3346838bc29c67fb6e02f0d28d51d7816e1c6c5ea45fddd143a1018a8e6f3064af16cb2c76d87315cfdfc9a2ef23760c07e41ecd3b542490743e5f9de644b8f9921742294df32d446cbf40e1aa40893b76605742985a6b3dd8b9a6560a5e8cb99a4fa028781e195a26d8e94b61bfb3e35834bdcb2f950f3f1d1ee7e780b7f14160681db956c75a85f6c15a2629fe7dcececfad249a918e786a7404419c1f99ab55707e7e61d4411c6dea273e0a84de2154ca1c8d0f40eb5cb3c1138ec8a8f76a64ebda12b2f6633173fd1ceb9531df5924bca0293dd0ac44298b281bdc9fe93013e47d2f7373602634a57d413590fff665796ed0d9f999ba37e48c4ef16396ee9cf69d52cd122244a8b01d493b41cabfdcd490eed3550f75db432f32119d8e52402f820fc9ae7172afb27e41903621bfb5c3649abfa2ebae2dc1bb5a90b860cc1c2acce4b6f365ee1fefe0875dbc96aea17d80b5c977805cb0a2c9983f0d425748796baf4839e8477bcfd071aec9151851c917f67ce11380b1104a8bc19e30edadc628eca767002554c71a0668648837727cd03382d50c55084cb772fd2806663b93ed97770b29d46c6b1fb1958477ec4924d710daa68774d543b505fa70d613408c523cb7e4231bcf6d2a5001ab0d3a25935586df27813699e7162440a4f38518e04f83dd9f33d9fdd52411455b744b340b669f941d25528435b7a33fcfe6af15d6ad63297987e1779a741fe2570a4331b24c1e395e88364c9df9b009d6f40477edc865daf0d6a9fc6b0101adda43d5d1099ca0b73b14060725d66b2caaaadab1ccd422c3ab36e9cb97619a0019f01a995afd251388688da730d5cc765fb96fabc6ff126ad67ad364583b0b0f8c5d18262cebfcd269bb5a8f4bcfd10cb64f83bcb5c360e65ae414f7b55f903ae72d7823624000cb4648e40f64a5cef1a8caf5ec1d21e0e5660262ae9cae47bcbe89e3a0b048817448347fa6ea9961901343c1dd5ee1f9a01189e68f4866054182fc0dc0f8f5c72d35262f85a16712cf09dc53f52892e2bdb20d2238e3adf13df316451cbf4a917901c22b256e9091308f85ad477bb1ab46eee25d39094fae8ff3e0619f34f9019a58ef1a56b39d09ac92a6e19f2e61c55cc98c804c581614c8f2386c44cf87657364827bf919974dfbed7bce98af8e13b201bff1a5b073ec5f19749f292c1fcc529eb3f1ff2814fab21f32a895ef58b515d13f1d07d4e77e968d9ca505a88de192fba85b64df484a9769599cdaac9f5f7ac5b62fce117f919488da1f4a7387a6c9606fcd86c02ae1d20e083b1868c9fa875b559b2ee9d64b6184eda047744f17039804bf5771c97a05c5b1278cb024f7c51a3941be34cf290de69b24c205a7cdea70dc3312def7e03f315c3283c0512b8504a2eb5a1c7aafc158eeaeb12082bcbae238fd407bb08493e93ffa0f403094223845272f7ed95762bf9d00d2f38449ba2dd2869b815671aac4e19fef7a8475a9c7c82d302fa5ed149829ef755fc279db2f485cb2d11f6f8b9734fcdca8f5311c97862e66b3a488808a41c5b0852a33035eafd7e947e674025e04875bf611eb1eb2ac99bc5f8089e19a491104bfdcc00c82d4c1ff69091346d6fab8f4cf27fb8e36c0b8a2b3db24bb6af4f5db585847d3d0cf68c02b32c02a13ad367ce159dc63d0c9e1d9b103544d4b90eaec30ddd82ac4fdbb27df90fbc50692f74ee39320a14b2892eab1e2e8a927c1591194dd7a0c545883cdd92cbd5b1bb74d87c4c1ac393298bb3917847a495596ebbae96d5e4eb870a8bfd55da0070a964ccbf36f0451e3ade895686616b9c84121fae045a6e9fadf96934ebec887df4cfdc055fcbc5920ad6bb85fbe896df0147e229af683749c86ec705ef1299bebef302b5be6ddb53ead335df0e9191e0eaf61942b1162aa9d3c834c60d48bb4478abcb1102a492fc67b5a36d7a02a203afa6b813965cd35ba3da38b7437e22f4a00a38e2565373ee6db74774212911889508c1d8b1b1f44de2100b88bab001db9a35c316cb6fb251030fd1de178e32f82764741fbea7396ab9b36504043d880e753aebb91add29e41711a197371322aadf40cb3acb9021aa583a360da6c3e9860afed35ab1bdf365c9593a9e9c01234f12e4944eae853c387d7b55dd672ab6f8eedd930c63699c8fcc65d20cd2805ee911ac4e0025751290ff45393745dfe987dc232c96989178280bb804a409a965b5e75d4bd7e3d0bbe5f57fcb148b6964ccb25696bdd8e0419e5e0e305484ad8d3993763b3e31cadf10474cd886d797cb93d66490a84cc9af0e601964f8d3a221407c6470f8d2c2af6ff0db851ad4781b3b377b46180849e3cc4dd1a13625cd667027b979e4adfcb52916ff53863c7c091427378ad7f279f40de0e405d1030d1548490b7e26c5bc12b0cab0932c8375221161ccaf6c0b0b107f8f4e082b1868aba6f8349579a2f4a383bfbc7dfdc295cdba330642c6b56e42af3d23ac874494e654f7d43be4ad3a1e29ccd9757c9433e02b6851f6b49cc747c1fbbdc725390c512d142356facf35b5e6c1c33444a6b2526f203b3ab94e789eb7145964ed2bac7cfef54487cd8acd3c022fe826a851bcabb0712fcbdbc7e28163161e729aee50d5ab94a4755a67bcf23f7b44000ccd2374c1805141569bcf441aaf3e3fa6b27153c0b680785048232e9f039611293b85d91abd28d6c9ca32a7316751aea2965f2a51f49ec50f1091ad0facd785471839091d8f320c75a17700853a0c2eeae500c25613f16bf5e93e7795d9597b2733bd605a26ce71a457a318e4ca26b3dfa41594ef45009fce1d485870a4a9547960808ae8d0ca3c61ccd3da909293bf08f10384ff26ae751d5762be49e80ed11abc47162fbf6d55aa137218d5bd010d9145294e41c44459df2024d8df2a993035faa23c2ed2323f5618c96e505e8f7688b957508179904cdb20aadb8eb5d79709f8bfdfe8b5f688dd5b4928a53750ec87283d786011929d55ae54fb9777d558182231963177e9d075f16f41488c47cb7d2df60ded3ff2fc405a9487ced6d0566e44264f5491107259cda6781818c3816751bad1f50c09a5ae64c5a15c046f1a62309609ff96a6b8f23fc97112bf724284bbf5f56051440ee71ce66c8102cfc7182e168db76665d8842bda4b287a0b6a6d24b6e1d4fb735d14ad57f6a02614f164989bdd9eb905529c88ce6a8902960141439e7d87bfc666fab494fece89ba1a4b649b1bab5eaa154c1b7a1a168114f354b06547bfd8c4d76c701214e9a2a80f5543bf1037f61b1833db248bcd21b1f1abd3cc43ec81572f4c3189975b3c27ed3c7a3f06a66dd7b17a98a478a86187533a402a6844db280f534f9c87a1045e1ab81b570218e95eda5e7bd5f86a2edd4a9bf202bdaa3af638339f20e6d8aaaf34a7362843ff2d1df4e31280bb3e0a0acaf11e783a889a4b4b9e39cce0b8556765e0f4bf46666646ad649d1b8722bb5835dced3bba5dd4d4127ecaf4e2c528bd9c948d275ea7aa780840aeb80e0c70e78ab81f36a27a88f0ea15d7bde395b29d3d1a20b2ef97667a3d003f99045862a2e2fe56dc5727fde864bdb19b8e70310029d2fef1763ab3c13bd854a7afbb60bceab78708a05cfa87bf6e1918da485d92a91f60f3f566c000a4ca0614d648e9f1408b57a96688e8e91ca66f03370d6fc3c4f1ba754df4d33f714a933ef73de2a2959827f9641e60d1a892eb27a119dc4f1929f6110f081ce5e0ef7d5484adedf2f38aa825d9074ddbd0badcfb025c067235afa993d49f9ee0a40248177b7ae0720295af5b2b481027a4b940d0ad27995f75c8ac8f60b7872082a4d60ae45c0ad169be2e046f13132c00ee289dad42cbe3216f1cfc6c220f09f3aa9994a9c3f2451c57a53d08b6daeb96bcf2c83ac1ff6f440c39002d4fa8a0a049ba0249689c0b07656332260dfab4eaa45268ec78e6b2f81f2575b08e8c0b25a0a5bcc23c0fb660757190a1c398948b69fff6ce8930cd6d42a553adffa4cffa04b07b50cdcf805c0093662957f93686d87b9431ccfdc5fddde99e0d27f76f11af2c03542e2006a76013dfde99de4c5b714377ef38efcaeffdca4602dae01e42f92ff8cc21ee59aad37aa8d0865eaaeedf049060357e18e5b336c4f6d33c7facf017ef99c51b1062fec609addd14f82c925a5a717ef9fd75a064ade3c48f0e8104649ff9990838aff7be78537cbcf7ab8a334b1992ba4b17427d3c35a8a2bb9991e7abd8474af83395fb82c614d740ac3ea19206a2d5e9cc2733c65a53259283b1a21451143ada06c546c359fde8bbad17733875b12dd30a6eeefef149aa105c398b1c4f1223ff2e8f8016367064ce3f6f67f18a666a06c3a2485349a22f5f72a3c7f24ba215fd3581dda16b1139cb01553004c2a83c6e3666c6e67a295f22a55ef00e8678b9ca4c949d61bdae3433e5f2f5ab2f3cd847a57027a8d883c58e4647fae50b6061758bdbdab3df3f6245688a42045bc50ac4bb64f4fc0efd7b99711686a33aef526341656bc5fb04c00084d20712b866cd302d67bc088234674cf58c0487a75e057cd29665b863ae105c03ea025b21c3b6723b423720ee96cc11a460cdcd294e84e7ac17ce0d4194f2c259eea5d5a26b60ed80f2b7ff41218d3a945c05ee4ddc2b2980a95434709ade41799b391dcaa349d0acd20548e27d5cb8b2ec206ce48e52288f734f9f6b0ee3d0f29782904cccd6ef12a90b954f06548c8eb475c488495d39432aabe045660cd97e6f36f05f1170f2cb26ec49d0b6f066b63d7ac486b9d6c79fbce1ee2db3cfbf396ed55f5aa1b5bf78d82dca90dc557cddb6178c680ee912f851f6ccdc718435c2ed011d1d7a5b6a03b6b12e829afd422f6dada66a25bb683782640dbfd74f48d9e618f602b96a7ffef626caa469f43fdb61e7f1767d2b5a20714f132f2dc268cf76d504afb51f32a9182f8a6f6eb3089497e99602fdb2f620bd5a61a689c385f8db66f10f5a161e5865dde2e7228c281cd7bd2d4519415d1495865c9973415c1ff36364f49ac285ddad7adbe0341df965f013029ea5e463b1bab08242f5f93b1d5357313bfccaf12e85621903cdc3b5135878641ea7ccc05a8b15c090cb34a1d1ee0bd7721259de3746cc2efe6549d84af6fcbbc90bdac26b2d7aff33147e59fb0d04231b35acab9de5007793958c16beeaa8cd6a3b714300ca8a5254df9e91fd854cb3a08492571e196aaffe95838df466464d8adac250ce71d3c1778d89b89b48481d3979a30961454336460f547efb1ce174b059ec88ddceaf5f06f0904edd9efe416c9cfd4bc56fd5b9c62eb75ee28570a6d4c879f2c332b66e33eae6caf0118189c129c38d659e6732a3a87a5ff2715baea3fdf6c25a58c3dd3e4095b65ad12217531e83ceb7b096c73c508e4bddb408a89f1f173844e145439852716fee9ffb14b37d572db9cf46fb9673d79264e2234b58af28205f61da727d0477614f23f5c61ed992671f5f7fc1d429ebe16c6a01fad2d532264f1b7f4e4a75bfbe78912d4e6dd6cbb08bf92beee7219b3e826c072d74d9daa824b6c89f26cd155c854520fbf1c4b72984f6f5315f7254752f045589307fb6508575689d02d1f798a627908127d7a3118cc6cfefd1e3252dfafaad43cdf9e91ebc00472829e1cdc7aa695b138165c936cd2ee5bc11407d58eceb8a9e8b9dc818251037fe645a247a25479254ba2d414b36669feafb49144668e9dddd22f51d4f32ffae40eb94e58da1e95dc24895f2dc05c45a6a003f1eaa79e7d8a6a3d1647dcd20db935b2d8b9eaa02f51c9553ed49bdeb9e04030af6d9da6a60eb32fa127df5e53c176a245fca9636c1bc25f295838b48bdbc388e5fd52eb002cbd89cc9c274a1bf6051f67264bc9663a026e0609c23d3fa4fe2292e7ea0c86aadcac4f2190967ca45ad2467b4e92297af9d364941dfe17a4ed34154a8f501c7f8140f20d13ab2fcfbfd6198739f810f5fe9bb78495ea2119461df51a917783aa64188d5654b165efc5e14223331746121a3904125d914dd711afdde1bfee5ed250e7e74158f5aef30f2c8671ae51a23052b05a078fc2d518bc9e0ea56b5b5541fdc06d709777e9cfa308a109506bd68d9a37104d98f9360c3050d245fd07e05d099229cc6ff6290c015129c626aff6d0711a7d60a668fe23dc6088a702e042ed5e162dc50c1206a1ba4862bb3a15edd3e34699ad6da960949bd6cd70c38d0f2de833758e6f9d4e25c77b4e9c852fddd50a592b75340419dfe5ecc3855ec1d154a8771a53a1af1276ee27d026e21fe831a770ab39edc15a006b2b6820b1f118436deb3e50184c6d2b88462208056b6ef49aac8680018f3ddf3a1a803199dd274997f7280cecf22a84cceb129cb534cf9211aa8768da0f06611cba2a97489b7afb619f4209dee1b6c3265ce5cd2018c21870d9883a1dd8aabc42f853aa9bd1e5dd70dcfa09009757b1d62faa1278a9cdc0b55cefd73543b361a4a3e8127fb0cfa2505a34bac666bfe0704bb15555d09b6782aae570c0acb80f410e7216de039177bab84cc94d4cc06e8edb3e100399c01eff3fe4cd331a186eb9f1610574b1b84d009ab11769e47e9c2360f635641530ac8e8ad7a1aca17805c9aa5d7c9ffd5c834a6f7d899a6ff5a07aeeabce8728da754586baf9828e73366f177cb4907096a009b4386c5ef9cf816853b50e5039f0e7cd60dd4c3a117ca7295d6238a3339325a38577a0419210f274d7a01b532f1ae194b38b84587941a94ed9ab1bfa7962f86033a314be69be5e3830aa330281fc549bf9061db819f263cc11a8f03537e3cef473284a550e83d13477efbae6f20270d38270e0416e11b63d6d7ba2b87f0d8c5b7e2dcef0aeda501f287ee9aae182b02299c642201ccc5209b862e52f46a63bf3361fb7cd6e167eb4aeab73dc4f5f37ebcba0872763e9cfd9d0fb40f6eaf723e0c8fb180515f11ea06bf6505217605a4d3b03586fe125b08db2092988d254f055286de97745a95b95dcada371f2e74204a24917323b2d43cde84ef3078a640d45a558c77fee00b2bb7858b285f56bb956722675f55c4cdb24273c4256f8b0ae2ddf9bfce1c23c29ca345e1f2f8fe3effa7149533a4a597b74ac0dbc18b1777d711fc8f76fee8afad299590d4a6c4582f5c1a33d2844943c1c1b0244f3f21dfd1d959e016d28ff73c1f73e9c1429531ff8a6cf8166313773e6327aea8ea4a298ed447239307569220cac9dbf7e8d99185a4a195b369b10b1605ecccdf24a6f9bf3c0724675cc16ec2c23700cd4680d0be58ce6bbdc82a83d1588f0adcc79e4e94542d8071f8605bf440db597b78309d19540a7919d675ba997c3810ea3cd381ac9724efe9a6f60f700029079a9cfde7949e52b81c3481fbe033cd731c2c302e98d78147b0ffcb5914923c1d99262dbd30166fd280b4ef18eafb5cc7f71ec7a84d5e423fa4f4dd25c227eeca6512379c9e232d014e9143fdcd5c81d14b421927a7d3b0b886a02ac8135d6c99e6016a8e3cb6be7031c071287c3d50edc1bd14bb85bf21a82febce54781245516ec8ae039b55f91758489f33b0d0473a7a8bd5c7aefce268ad40fabf170a7ac6a6300c1f73b53ecb3134cc6720fabb54fea33cef872bccd14101bf659f0f6be9643160d92844e326aed31d41e10332c38509a164b8b0223ad390cc67a6f4863f8a0305422f855723cb7ed16e7287a5deab72c506d8b12ff50944f91282b40e195243a6463db2ed6ad2a5828cf275a816aacb956d55f2288f3a8c9444989d618bc7543686330e7f7072f86d3e0b72a5dcc61b925377c7603abe432a19e8add9de9b6b9d56075832df6b90e5808131fd1b59480e5318fcc9cbeb5ab65939bc185aea14a35a233f982544eb792ca0916d46c184499210789cae5fc0ec6e1cffd958a1b4df9beb9fa761feb2ebf034cb0812cb8c549d67c89affb10faa12fa4256e3fcddb3f5b0fdcc25dc695caede4a99e0471bec324e3e270a44c33b9898873129e6bc9862b32c23e3c46e4e15b252b9563325dddca975833fa094e76bdb63d5f74e47ea0d80ab9df5fe77df3f03f22366080d7bd6ba402ec62f0b47e328161353cb9943ec991ef7304b0f7ae41c6a1564d53ac21fd29ca901d2d99ca64e374faa94c247e3f7690324d564226922dabfd6b89d2cfbfb17319ee7ddeacc357d7af2f692016159362065091ae94c8ebf2275d66ea46b3d581f863cb4e19a01b2a6142e8b9fe1260c9d0c111a5f0a4479bac868dd15a577089891078fc1cc52689f87a2e3f3acbbb7907ff5b7977ea56424844791d7300fa7d4dc54f59c9a6b1ef7d30fc2caa856f44ef2d761d773a96a30b556f1c670392f429d130532457e61d9330b2d6a9f9e0b9675be8bf6ccf6053a55acec09c5ff94c4536a2bd238d230ebfcff08a4909331173b599a320013ce474de64a37df7a514ee06035529a94849ea0414f1482e70e9df655b9849da9e4da3cb324a469f8f9b6d73debd270a37ff27cd2ec3c66754b37e1655a261046719666d126b20a74156c9701c3431edf9670a1b5db1a2326722f120868f33313bf88d64a210050487f8b0dcad8aa731e44eeaf3898bd08b073d370a9e07bba4cd7306b01c622c79bbbceaa4b9ae5c93c208a3ae2e5341573da9f5b831dea5320e069390f78ee3bd794ae2cda9dac8784f3ace2b8147064ef8ff253afa530cb6e3ea3a4deb5264a45f816ecc508b6afbaea7528052b9c3aedb4e460e7acc8a073443a34cbdf7d2a9ca44b44ff71d224ef7b1dbcead9d7559b8d357f49a0adfd5c7194b15f575b5eb2d0a33c2ada8cfe7985629ba8a1276136949419b1381d46c78d2d6e4818853a4d80fac82ba80f6594cd56f703366e5d7f8f84e46839a0e90c54f6adc5fdc3aba5efad837f9ee1d7b682c659ccc922ef8e8ff8279ccba084ab71f0d2b6a17851468d77ee08ebb4e2b5467597d1de437de592e9abd644dd3141337ce7f42bd6463a9da494a0da65f23635455cfceb8014bbbdc9800e404f2092d8d82f2cd1eeed84220540a0ef34f7175a922f72224ec634845bf18f1c47a66b59bae5da854bee55fd482cde213b904702dddee8fd4c48f2f25c47c01e3a04e746df163628b3ad126d0e3e43bcba5f1463611badd44c4aa6811ebb923f1224c5d2e4c70d632c7e10f9353812fefd4e98ac3ec2e4dfe0f9dc395b00cf96a0a2eb54de6b1ff87ddabd8f86dea784a54963db65b6d13e647bff86176809c2478f2914e0bbd2cce001344a44e0e809b9956213281ca7554c2b0bee5c7e7e1ad82a4dbbe3c54e13d04367f49d7d5a8c0da0125f9bc23fd54e4e3b79c63bf23cc86a1cd1025c36e2bfdaf1ea2fea1ae949c4eb112e4092af626a92d0f2307d42d83ba88cfdd218bd5fb99e4d84b92f259db1649728f74d2c2450c7748e557ad47edab9cfb3afeb98b92f727fa62e9ddc658a7918a7c7f55f0b0ccc424c2c3dcd0ac1c62b4e1cdd6e1238fe5627fbe80f19d2a0f9fc498fb36bd6ddcdfbef9305b3c4211abd1bf891435c3d44a6f258d808001c815282d2c4c1b48a1492cb8183c92af8e304fea87a6b54bb27d2980d232ad842ae5af3e13f1623f05b5111004644e7c2a1d99f83cf8592f1e105ba3a6eae5194f4bbfa6c38128e1489c1ed6f5d0d7ce351401a030fcfbc4a23c8ec7fa1880af9c671a3631105177f7ce2ab3f3242f6633e9184413fa200c6c08febdb39f62808170dd8e7efb1edb5bd2ac6780290233152a6b14f6fd7e49439c87cbd553d335ded5a52e05c07021973d14df19eebb6a9db8248f15fde3a8c8449d6bf911d5ca69ddcc3ec9c7500ca5010ab08b9b69679e14e3aae7bc5cd7ec3cfb6ad18df96f594499332f579fea0e51cb3de4b9f26203f8fe91aba8096a82c89a39f67a2e7958335ef62549d3fea594a130ccc7a34749e60e43d2f18fcec21c5b9d9315d3667018767dcda13cce47100cc859e8e48af3b1d71cc6550219d2c05f8aea9a1f82255b7e26b919a9958b90dec7c4624ae4f7dc3c9c03d3fb95cd786cac18705ecd70f50a5f52a46fd5c35dba93999d16f35e94cf1459784090845c367f1a0c18d68b661c48ea628a3774a42d63933344121799eee7a878076bcb4b671c9a10a61c17f43a5f6f4653417a88e1802c405902c8255fa6fde4741e0f3c4a2fc0114de126591a0ab7bfd74a16837744857e9765acf883b3afd63a68038bd9e46bb404ace4b044089a6088717cf44d8c760b9fa53e96328436c4c708beaa1987619070ca0005e65848cfad0734b4a9ab0a8ef18b2c9ebc821a58fe7957af13e21b911105bfb66d091ff7b7a8e9d7062477c37db0f35f2cd5ca081aafa05b693f51eb5726e2021790f9874baa203aa2d85c1642d77221361b532f8512449ab77382e1418286000c4ebd80bb2811649c4a91b976c0f162cb0a2386054afed667ff94b1b4f5da1f7014abd7f50026a34b8e3d2abf57cf46418af9a051a0ed7349d39025dd327aed5b68e32d2d032c81234eb3a56e9750f9d903c535c3a4df52f77dc2eb722d36f832d61fd3eedf475cc19d4ad0551b336b7eb60d508bd5ad1aaf1d5d36c97e77bfc5fd940c69cde12a58111435e55ddf42135b9a814dd01b681868e633b38f56cd4a5cb0922e65949129c0b5a63238010b705b0ca7f9004cb9cf41014135d1e0e75df8cbaa8d211842dcb40ba549c0475fbd4d6f4b95092294f7878cb5ae01b91b814e184d14247807e019dc178d1711496209f19970c25ca9ffc864605ebf4bfc35db05e496abcfb93d180d4f93c5283d4a7cade0cdc5b9ed803b1795d0b990c80b94b8e8268d609e41af4a34e325ea1f43767f17f125e2fcbf8328f6dad0edacea9298dbb76eef82f282aca6628f194e346d3137bc2e965724e7b7991635489bcf406b4e5ba86a70f5a9cc660341fdb128092419f831a9415ca26807837a2007c2a7c279984dfcf347c3ad3050c86cf4f7e456afe23634a7d8c50eecc9670c8ea1a30841b2eff783201673c959a237affbe40706b122e2e1cc34b097cbc8a99ff48c9a43d2993bb38150c63333d604ffdeb207a0d77aaeb7875570ea3b7b7f7be3553f63f0d80b03de2f27b31054993f16600f9510774efae8c8818262da346b10cd8cb259b58c7261370f5ceebbb893d9bae7fcedc2708da9a43637ffba4c9b581c60d11a401e04565d018f008e8619af91703fb219c282d626c513d3b5053da84a642dc57f7542fcb9b1f263ec08859021f496592e7b0336c385e2bb07c35a7b82fa8716ab6778dbc1162f7bdcddb7af56961f04d95d84a00248d1b46bd5ada295cdeb5f854d2dc03a08eb4e91f94e2fcd91b73aa614e97cc806383ed7d64da9bc937b9fe63c31c1b1b00d7184d2f851427f0457a22e75e5ac26a6b54f8bd975f2d196cf8958d4781b5feb4d64494dcaa4c7c4e6552fb000425330c38ecc6589ddc7ad6d8c310bb6279d4b54fbf88864e8faaf530","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
