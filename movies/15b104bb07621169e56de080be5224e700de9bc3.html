<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a49ce9ac95d91512130412290ad67926301891f8c71b374a8291b1d97a2e7d7d75917ff3bfce05dbc0b701b42a5b51c3ebef855d2a38941c226bb853082d017bf69499762818ee30fc5c9fdc9b669aa769aa6042975704c1338cbfd46985dd5301cd14f569a3010fe9e027e60cf2a0709a7b027f1e9a90c68d50674ce1c28d6b13b50cc8c58f7f5332eee21033e22caed3ca3489b929288c7e1c6318de9e7a8708b986dcbac6d5c4aeb101064bd5e7836ef3da03fefbafcb6e07e8561184f235b70de1ef6e8d99f7e5b6b0873055817607628764ae8d38543772bcdbfb75a53aa66c312cc4f2e9ae4e9366f2f5854f9a5a0d1c17a573320dc85de33a9620704dfd79e70207ccc48ea42c873a01d363d5e9504eb4313b688d3d436ef5a7a05aa833c3f0579f58abd035508423ab7442ccc1f089cc20531fcac7a80b1ff8c7cb81ddc837e7f110856e1c7d69dfc0f2036e4759389f7d819bb005fc98239e2c62088e9d2ac68c792d5319ae57b7229f838627d7fbde93befe95b05cdb2125acd7be348a9615bee2eeafce64679b55f9bc0470f975f39cd3a252282f7581f8e014b1961867430bc47f168e95e01b46a4bdf440bc94146634653efadb3df7b2d0f410e8ec871d013057839cd06879cbdb59f71bf0587b8a8dd1cc7029879001f50ce02a96c57893214bafd36b4363365b2cd847cce3a1a371c1d9f61db38b1613a6d7ac5eb6ecfc036ca500d222600f09e951e56b5912283bf9b435bc14c755ab59f6b597bea917f5db1d1b759a3b5f7305a9e34a49b37f2768a8b97cc7f9c749b8209507dc46e808ddd270167f38eef1dbc9e4fa6128f81868b8341a8118baf8df2ea02262eb637c0e5540df7e4cfedc8b7675a33f135aabb6dcced2b2a02d25859eb9e5fa1a92a3cacf388e1aead5de6f84c2ddd78b47befa53424287ae0334783e506808900f61b8f962593be739f1751bece42a0326e9c26824180aa7cee345cf1706c382c680e323a05ad944d0f8334860762c508d5d2a51a44f4d70a775212d20025f0f5a31cdc11a5f1a50c78dd82e58489d59b04e890b02e8f478327e2f23a3f8499b0df78d5361e8cbdf5b08344c35a2270e1125a072bd9bcff4b3ae5597fc732544e9694f476ba889b9bc34d5c0a4f7e2788a55c2ba30285573f85eb8ca0e25a3f622a7c6c2794f665caef9e63eb1435d865ce307ab1425da68488979d4bc4e8028d2ea60cd2abb2148618f707eb4bb8cbdf6c43b1068b4dcc1d6469a954903d69266c9c304f6f21fa26a4c880cd85be9919e032a77aec9c994e97eb04582cb7e89f5397bd0375c3560deca32e16ab574fc4b38ac7eb7ad4a7b6ac49916d8a6f5c043878578576694452bae257ee28a857718050de9381024cab52fa4023fbd61f663da65bcad38d98f6df7612a2f5189cab5801da96db24df145faf70655c8de3bcef908009770e364a513893a541623350a3ff0a62430643a535bcfc43df40d533eadaa3227951f2e87ad4ad311eccb2669ed21cc6d96c1a3d768a79f51ae55dd300d267379cbad3b67c32b5117dd779d086fc33a7323a485b38573883a660ce71ee920929ac134cafa5e87fb37dec1d67f044c16ffeb0d158cd5b4adb099b2b065428f87ee2c808b41c751facce1c37d66130a9543726225ceb407dd85c4918cf15df0e0d923254ef11e32d0287bb42c26782ab53215abdc25171e1cccc8daba1dfdd617d1e92d8d96fd6cd3a57c51cc4a7a91291fcc2760fbf38ec1d61e1254e6dde7ae589a0ae7bc7c237d44b42037ff814a19da15f74fe87f27036b380c6f65916636f75a0d0f2847cc2f6e2f93b62582d981a851be7b4ed81015207b205315cde59a43929e10e0bbe85fedebd8cc7b76353ab14b1ffe946201b6c9429843836396e18ce9d571246f88d274ccbd60bda896e2bba113ee523710f9b57eb5bc2b8e60a4f8607fbd7443709467b364475f95477576dffccd6d3d484ddc5fa9dd4587a857f01119befab6218a417b757665de5af2ffaf0af06d114c51b4b0a06734cec79ba26df626461b37da6ea7240cd3334fe18569e425127cf3ced09ec9e5a6d9c9994f1fbc7927cbda59879f57329212bf43ba105667107c49b0f841bc9a5d05f5b8815fe82eeb44658afe70ec68003b26967bf45392a5f1d0bedd51ccc40a6900cec2869bf99ce23791ff2f8954024560f049a5d7121b9d50654918934884f0cf1013ebc13848ff700f99b9bbb070ee66470a7ba2a2891fb9564eaa97e0ebee39bcac82a241455656f6ce3036805c988bf4f4ce2e3e0ccb30316e02361e0b3f2f562dac5f4917d603e9e103a7da59639793de29e87fd815e29344e3347eecd4d4a44f2884c7c17f0c21c6b95daea06256d00ce632d9db6aad0e01bac698d789ad9893391ba3b7c3e3f4dac2173c07178b122565d159713a043f08652172097734ea72e1da0471152f6a394879482c21063ebb475258d885375edd48abe18d8c92e45aedc503fd51be689f73c810115d179de000370a4c4ff0ec0986dc575a142f3415fc875cae3e6fda60878424d90156dcffc4538a0958e95347f61ac2a8f3ca060dfe105c2d50b10eb9838a8b8c0f7d70d7718683ff3bcfa9ae478bf7b1e7db574181639455bafc4f460c04ce529989ab9eecd03789d5a1644063c8b1e6adb0b5cf7441f78d24bd8a36d2112b8a229ef7e5a27a1ac3fc82ca103437b3058458625034ed4f19fdd02a0b50293c50d8c1d4f16e65627fd4df85e0bda20320b95be7d4b3504dce56f65d492dcd3246710c6fb57b92f1b932f861e8e3cc988d4077d889ebd2bc598061233ae1956aa9a26ef5bfab193509575744c52b12e781ef53c1800eab3802cdfe84419946c6cf12e5922c19db826d670632b41c7fbaf723aaf94fe55e90f27e7293bd501b444ade531c03932e7c80d4cbc6740f366c7564ab78b6d85afcb59e53293e337e661355c970c9f6c44bab1c823f56bb1ec8aba46e1399c339c44698eaf61fb6876dc1ed408f65705406bb1ccdec0e44bbea9461648aafe626d3ecff9832e08231f350b04e3b9de62ec6b38f0c38c9abfdde2c583d234238a45348e828e58e1be462e212ae3f6d6c1d6930b692257d49be71566b536ee5d6e3c1e1a0f00a154f5794e667b23b1fa153b90f33dfb4dcdf2853fac453b224f0a3400186b45368390cfad72bc3f93932bed47e34ece12dda70670b866786ea1f50b7ff3a1c1cbaec0a50d36e479660babba31034cf3bb7a67f6a7ad64e4d7c7b3635e173fc92e1c39901c6d9e2e364067e3edeb6a3258cbd8e727f07edcad04d53d66401aadfddd05a2f1bd6a8611ae10830a4f221e8caaab55236079b98ea1f9942e6e924efa0a710c3d679b65dc7737d9f8e224e88b42124cd7ccf4fe5e24bf87a07b9106ea2b9a2151c31a733b4eb44dbc21c9de73cc3f16ac37015aec8854fe98a0a65fa9bc366910adaffa17f35f6430c15278244fe43ed7c6b078c3edb45daff5db3f7a181efca2ad868fdc959ad938335609e8aaf4e49c47830e921a95c9003e39465835eefa5771c4cc28b990aff165bd8e0bc7cb9da959b0df246dc69c49822701f0a62908461d50d7e16d586583241cfd96da633c2b3935202cc9bd20503b69a29404f1615f78b59aeb88dbd958ef0a62ee5e03069efc004f20fbad996d1a9be1ec7f0d8a10a0240322f36615c442f1b3f496403722a320435d1b9a22771d1a879f2758c87067b6cbb56e8eeb7d44c228b385ce05261535538ee7baaa84e45d7479419b42cc146557e747280afeaa982b0d6304383347f750813c2fafa91aef0e58708a3fb41a29d5ec72883d132424a5d3eb4fca0bd3df62a32f9e4d2ac5d1f4564f0bf797606c6954b604553333180f1b898273d6645c1b6070c51f7bea402e85155dc66cfebf05e33eb01a25ebf4bc5ebd02f1fc633d89b3eed40083dff7f1e62894ca1d7d248c6b74b354d6ebb5088d7bde7561a9738d2c630e39d632731415c69d04d01aa8cddda34b2495b2cb465d2327357ff0db62e818857e92abcd10b6a781d14636fe88e8206acc2086c12094e38b3e2bd630a8dc7e12f5b0e17c6d874dd78a3130e0185b6d87aca2516fa7f6ed78073d45f889606f415d0cf2ee018218a4289ee3161b8da5747c52f114796c5743345c248c1ac8eada278991657053aaa3b88045dc412d9410c2760c8d18012b1266514421173198dcc9985fec2c09a5992b54387e99cd5c5bc57714ea11a98bb5f644130d7e36b69939df5f3b2f0c92414f3670adb19ae12022c481dd9bb404f4d8c24b87e9808ccb4a180cc51cdb61c6f642fd3cf5b2ff4ec8ae0e092f84887dc3b105a7878302143e1fe25865a85ef5ef19f0baec6d9a0be2be4b5292d7864b5fa4c95e6123266d4b7f65769c7233ce97caaa9e8a7ce53c436afc90ed29b5e661853c8f541dd0d79b66f662cbd2cc27365ab0a9411773914e282060398d17b47f6214391a522ac5ac7d9a6c7bbe06efcca24a89647838ae17d9c8752f6726b6c51f588545208ad03ed4a452aa7353a86fd74a41894b2332d508e674c19ac151b06e88b12e4d544470960c695c33508e7ca54dadc361b5e5c6e088621de4affed6aead618e9c12c2cb112c4f376f50fba57b2aa3fd8f8b88de8db97aa2f348a9027a55083f268fa05a40552901188e87b1430e55eea2ec163b6c3269d206ecb4963e9281dc20c44beb484fce9cf6d2adafe1dc9645be1b9eea21d8ad8b957eb41c40db5a780e0748f10d73a0f49ba69f5ea4ee7b58b64ddd05c71f94719a9220f0fd89ebb03d24773c1a6695e15ee8d8742f0d1be70ca5be02b2e8cbd1077103999da763c0d8c2072ba76a2acc40ff517c8592ab1c3b8a94106ef293dc1ec71e3c523e34af21d8e976a55b6d002de83926ea7620241f920c08f226b40e8d13c4be91e4c0a4cffe1f15fe3747ff085b2b6d7ea1a81db8b7db8905bc4066661955a0e56230610b1ccef8df0bc7add5e452e03b5d3f7fda836afb3719a50f0a12034d6534e43c3136a5159a72beb0d7459b93c401f1c68d0763f282949cfe83035d2538aed4cc36fd4857f62559fd99ce977137aeac76e0177577de4bf0185691a5b01650192e197d00fccfa4ba1f8cae8188bab27d9bfcf80af27ab7a7d9640b7b2cc0d1f53d35e3dc191659558e314a5f2de3f61fee24c96ee326f4d41075b2a8c37a072ba0334b912f804e3e5c34e7d1bfbb9c4a829282c33b1b34ce8d05d3f3e869106b4633584e02392955844ad10025433e8b9e67cd016a6b2ae30ddff5a2e8a6a9da41aed3344357909e2e316b9aa35224eab1ce40ecf887d7840292f6dcdba5886d749f1ec4bc2a5da32c94d8a3795b3c9f90db2dbb12690827242724f2a938d0cf6fda5f1f76049b8e633bf7d685354356dacacc2d4cdf89a2df499cd45ff504a093694d90b680b4ec2ddf5fd7ec83236e0879e1577f1f62012a2b56d6c9e7c61e4370281050a913d86eae2b1134101c71e0988e7474c2efc39a10736f45f0ec29d65e0d297669cd89b9127c30dbd8ce2be0a8fbc5b8e4274d92324adce17676c96a543d7a383c07582208446f83fbd54bcc42d578c2c9586c2094bcb6c5ec049a19afecddf5348aac23e3ed3ebc1b8f7caa23c3bc3572b24951484ce6686023b08df4e8496a0ce1c4cd62710dbad313eb1a27332e681b4ff3399a77414c38d9d4eeb87f16656f6506f4bb04b98ef9a44d856fe6224e7b00bb15e301e1f9abbfb09d91a42b861bc26edb463e9c4f89648619665875c402c557264d80452da47c28a7db7f3fb1c2cd6e3dc49f0500ce00684f4c6b99efe799bd3b3d318a5dd948757a26c8b08f29f661e9135f105ae6b953f76367d00280c489520569b8fbb657b5c93d629a77e527afb0457ad91d3d0cfe353df28c91b6f32ec52c45e96d703e4f685e2ee233a87873c5bc1116b08832888f5b8d6994ba0db6a358f7554224e1e549f47d9ad7511ba9c46331081bb0bd10a3fa5a125b6a7f7372f43c143e022fd355eadad7da17327aa46255d5818dc553e293512d43b3ed19b9c1860b504b8208e865ccdbc60e53183eb3b1d4753e998d7826243966f0d8c88f95bb7ac74f440061b28b4993a93d1f62c92b1638737962d17fe0414f1a61ae37b7cc3c41e9316c58d09da2cb945c061ad04f922c55bfcdb8a17ef5076752869cde696b898e670f10972afa87697ce370e0cbb104e2a51d807a3518e17b09171281cc9d01a8fea3e379a7c7b92c8102ad82f315236ac8770703606aef94abad32e42a622a325588ba38dd2b00317e13485864edf06cc0f89d2e310468367638b05b9e840cb9106102d47b05319d7de2aac7c60358766748cfd7446ba21d53ba1cc36bbf11c243afee3ee263ceb6e80eb4692f62609c858c31f5deb2838697e35a55c390a7c113c346a511fbfb3c5f27f4bbae8594196beb5e239ed9c11ec23ff6c96f08084939377112c0194fa9c929b3dc603386ee49a8e16984de5cbebc592eb2824847794d996050162ade982263b4cf06e1d684e92e7dfbfa71229b6d2ddbbcc387453bb44a503f22158b678e5d3f10f6f5f2b557d6cbf1d12133268e154a208b5b856aa0e0de1d44bda563ea227bf7aeb096680ec9769bcddbff387700cb7a6c3876dc8b5cd4d3ade236683811541d5d4ba64e81e4751ad0e4752e91b12dc5f060edf17d41b49db317fce530d643289a477a698467909ca2b764767e0a932adfc7fe20d0c9ce93e12c25dfba752dab748315c90820141e6b929e55af3bf73870ab330a187d78b826593eb95aebe5363b00ff1e98d6058f63fe4926c56f78f5f1ae86102d09519fb9de50c7835cb7a6cdb4ff5fe51c2f8a5ab20b8df9ee33343666171beb3935fdbd3bb7d7cdddd0e2436207e005ac2fa64c74935922d21ef59c649d6f5d111c7402f8fd62b933145874422d3d4055dcbe11697e6dee0de95e8108f5daea6ec6d7e883eee136f2b3c5e1cf7811eed9952b6a5fa803ef21b272f2381ccaf6a5b3c251fc91b776cb46cf2546d950a93050d22dae8f64bf42afe5f8d3c0892f471992226599a2b38b69922b8775f1bccee8cf99963a1a0cae9bff50e190a40950bf2e656a0d469b98a99e133e1b68548c9854b39fd3522c56417bcd2711db6387f52dd93df8ab7ac6cf772625b0e14cc40bf8c114cc7ca3b43cf3ad2645b12a2c10e4de9426cb996b8c026c8af8a593029ee106fa9c2f1d2cff743a4e7ff2afe3d50ea6de6f990ff298f52a043a3b7a8d1eb1609f6cea0bd49855d24fdef70c0b72fca347eca5b83bf4553fa468a16745109fd1a796f286963c7eed66a2d0703270430439bb5f114190a07dec2cd46197f45f1f884c6c57a02b70e09033a6fcd5a80bbb20c2fed7f94fe1db25af0c52c09febc83dc3fb77669d75a1d69c42984f6b6838d8878d3a247458dd5e79cb5e190fe4b0aa87eb80bdcf2d59080546ee0f525e411e4d3595d9ca7d29b6af1d80327ed8c3462f444d790590e455c2843f335160003081cea861bb6ccd607072108a4ffdb0ab107a88bfc87572b7a701697672170b0c359b29b64617d763cbc7412f7017351f078acb7aa34a729c09ecb5072f25853f92d9f86d05e039e7e7831af89ba3146212c22f54ec862b33e7084efbe4a7da931d600a9812c58af3e9c0e120f3fdeb6c30f44b7566335fc825006fe301f29af03eca9611446917cb5c11b44b3671975fffe57f25304c3167b2603ca419fd624796997b77ef82130ce183548e01f11f08fc22c82d7431820041a33793affa27022a57a2abb5c1b0b9173315dfc10a040049e7fd26afad1a0285b637233ddcf55fa44e7c7072f37d14657a6cdf1d4b56ed1784ce95c20adbf77f7c551ce3461fd685fa1ced7a54fa42bc9d95151cf22cd50364382fc04dd8be36df5feae5c60bab2e17751b448641d122f1f01f1814074dda69d5447ed915d86ddea5acdf80b41cd20debccbf0434147fb0cd64f6b30f77dae6950a2fcbca338bf60b814a77bbe57ed72fa80ddd23b833f710f5113354c41fe951e142a03dcab9174f96ac65c26440cff66cc549e912c36473944abc21d4ff3cc237fdb6e5d5a889cc62548328055a4b7526932880b8c0d60efd0d67e04309b4add0103c540abed9e4b07cfde34b366c053c479850906368780b8642dc27d69867645283296d5f56e8f89451f8593574e7ba34e24ae4f5cbb2e933e2cff25d35d1c32ef7af4f02e66ecb07f8d892b099cebcbeccf0a463cbfd397974bf062a75623f35547dc6cd5b6ec15eb6da24082597769adb4a1b84815033af40d0eecbc8bffd6935e9dac116adece12c9f81c7d5a9fbe51913320de88aa4405e80212f9e91d80f668b3c375062423d7b6b622e9255d595732d02b89bcd685cfcb374c4291212743651df4a68bef7192e6e0f3d1a94c13a55ebf9a3578f80656d244303520539661811cf619494db77eada2cf15c4cca00748fd1c85e936f3d8f03dfb60fe620393e326ac3b8fa21626075cea0b60a18980128788ce001cb55338ef3427b31ca2aa2c556c2adf9feebb7fb005348b59f5dc4b561bf49aa149342ee4a9b96b2c98374b296de67cbaff1b9044e3ee3a5188baa8a0c119523478b108f88da2a73fee65d0b4b465f4639f072f206dd69653aaa63718a881b4ee8d9a45609fcbce0f363f09c0359cdef3a4ad4bfb1408d1fcaee9589e5d63a8c53ac70216245c6f6e17fcb9581fec4d13703b78fef29c44aad214c501eeed57265f5bf0fddd26caf897c2ecfa1020483d0dc06e6f24887b998c627ed021d238dcb9d788de7aa5867dbd73e3af5ea88503b38bf8b4315039989f887f86a247215d1769df31b5599ea80092b3114672f239be479732a9dc59543f851941d9abd3ad9c53586f5c2ba38ebf7551f5bcf8c8a306cd67611106f31ec37f1db7692117950f8e8cac345c88f1bc53c4250a8f4bccc92f949e549d1cb10794fcd4da88e12d5385f99a9f0839f20cd32a315b71b9c15d47ddc5cf017533e2011ba762f524d3400be7b0754148979b005350b97d64cbb97e8a604de9443a052d6ddbf8ebee3f418c102b9101aeba51fbff6661af075d5689802d4d42093ead70f7e44689ad5c78a061de4391d31daa8a9786dc42cf85dcf8afd9a94f3c7204c959137da2324b89607cb8daa1a2702b5f953238b551ff7f92f76d12f7fa79733e38a39605229c19899b935d986b1efc57e7e2ae85bb12b9c6f4f1c807f8f6bf034e6c4a6c6b2f571bc2fae5232d8d5d383ead940621831567090fda447c0989188733bb97ea7ea033a56de17180ed89b898880a0387ca5f46bc1582b03a2e626c4ae51db2b82d787a06a759163590788207d4ce255a77e91cd747028eccbeb02e81d9be867e51d92107c4dfc242a92784e7351ca6672e20e7cab6dfbd1ad21cf98c49608aa725ecd7181a0dd7408feea36091b5f94d7034ef47929c24d3d74b499dcbf60b626616e891f281b7714e49af855b9128bf1fb998342cd795d1a3cc24b83f4f86dfc25cbe730e53ff513bb5c3c3b941fd90b422012390e816108dab7e8f35e2b1885cb985a01362bf0529d5edcd03a4be7e1f675c12e16586c77ec7abca969c11ffaf2c5b2479915d384d666b75800435df877a64d785702fcc6b74af6d8c7306ce6e2dd9218d6407777a0b0001346f4019b71b75503d3fa79c7d10e454e5838d1c1efd13f7675af1b83ffc4f7ecab0e80c873e2f6808cc52abb98104f4659d982c9d312ab6d7fb6699cf5430451f6fc536b29e9c4128b8ad555fdeadfc2fb92e78d135b2d024b0d0e12a4aaeb66e33969412e4067fd8abc4bcbf71a964bdb4c59cd5db9fdea94d9595fc8311220d356c12747ef973bc2840818843f7f3671bc67aab08b4ab235269ba4d5dff654bd69f0a7cd33c096950b43040dd1bdc2387992be850f5e9864e48c654ae1fdfaa2b6b157531fb51cd13cb68a4b702e9fe9ae98149915b03b897b6c382efac5d9585644cc3ec640b1784dc55a1de9ad9e926c8b31601b38546eb5093a6a1fe2b7d08f188704ec4ee634bc260d27f1671121a1213917427acd5d57bce8a4aaf289da4993907e26e533f4641a21e043d036a44af6ed4d62420cc7fea43b86e309c4512203d96af09179dc96bcaaa69d08fd0aab44209c6222bfc6c39e886b7ea83bb1371a19368753dd4fe016fee859efe3a1f005b100a1bff63b4f40627d20f2b8689c55b3c12999948e057fa59b4bd709825da9a3658e45ea9aeaec1a46abe0d89d7eba42c5b848d4d413eb49d8b3940b6ea2f9359c74164ef679afd2209b8bb42e4bd8c5c9622dc0664a91c3564fa958cb0cdc65f361c69160a7e12c454ca25863c4e67bff3fa9c7dfe3f585ab98bcbd30348ebc4f63577c4077c2a064976967c4cee26ac2993ee001369bd81e249b1ee4a8f6787b50e590b13050c1b47951944f1c54947d96ab4c15085e58814e53060cea2b9838cee962e8e867288e0db4d5182fc5fbff892da22ac27a96a6e8502fff3b2d010eb60d8d450395bd92f68f0fdcd012718b77086a5127afe10d61d5c7d71fdef3c8265c9831974b6d1a2301e155f6cadd01506364cde27d23502ca1857cfb22af1f877d48a5a9e675a7d7600e05da46ac96cea1839dd5fc27b8fc5079e065832d72b4897896eb97765cc8d8ed6f82ab9d9af0e36bc0a2282e8e8a884f6fe7f4b3fd77d11e476b59e049ff72fccdcb99f61dd2f23a2b65a053abc0f4bbf7a4f4f0952c9fddc8356d431888bf7d0bfabb9af1a1705eb5d90709c6905bc215f48c0703192015c7ed110b1b9f4fa3d34cbbb42e1bcc5675162a30b59e52e26215bb4ae8c49e3162b6089883d5d22e25ce679b51a8ff4eff084365f3afc9bc5e105dba17cb0a93bf727717e8f4e5c89bd760b9d598fffcc30ed08872a087cfc92a0827dac8b064e6d29f80c851af4dd0d4fcedf4fa4d1bf294fe9dec268f4766c9b57c573a999c58b1c67577f0f2fe2a59029bc55c42265d634f565a6530b8156f731448156a7d8532a580b42cd668a0a75116dabd16788de4b70e97d22a7558463b36a8e9ea3918098dce46962f1622a6cf3aa7ea4495b17c0a097b51a48b37213bf051b0935771465131dece296b2d60cd69aeaaa8bc7c939215323ba125b9975265297c8faea6e1867c5e47595e4c726939392bd455e4ade63606e02c45f655d00586ef496731d46bcd13d861b3e70d66f45e91f2f76635f47bc852f7981e8f0e1a2860a706fa1b9741cc3f02144c6696d8f1d189f312c801417e7a95032ad759d8f2920bf37c171a5775e2a7772dba6af9717b0d1a7d88a85e8d6bef4e53c2228381066f2f66ce0e16f8729878d4691ad461215cdb9e62bcc243ca0f4b38a8596a50ce5feb14c23193d9bc36c34af3756a33483bc47ffe4561f8602287db8735046bd4f084ffcbead15f701642e75e4a3023d7dd07e5b10ac40c1c151ca1a5a259c93efb183e33c403cb08e8ba7002fa812fc4ad24c363befc291c050529851924247180353be9f8b57c326e97977452609ad640b8371850c3c06dfa67f60441e7904348fe981932809a0b99801f08b0afd62f2e92b0e7e0cd0d471cee721a85dbe633630d2e35bb76ec436e4c018a4254208a317c69cc15043688600f22394460e38d86045c40a475c31bd252c8ef58a63fd6c1d322d0526d7d95b68c5258ee67984d9ef307d50664b2e40274cafdd48c278be1b2331112d78da5d4836b74bf1a5e42d92a53bfd72e72cc95849686906235b2709b528b8b1aded23335181280368e7cc99dd9e0fed9be5c9ab78a7948b5f0be8cd95ffdd87903f2532ecc4459519b8a7cc95110714b395bc5159ff47091fc3fade1558010e7a4241ba1cb7c56fb5cf00d39a10bc42ca9177e121e495387db0ef1c9098bf48d6d362581f86f0d9b68c62111a44094f12cb505c26c159ba4524a64bf3f7ffad39786c3487a059bce619e35812a11d6c27dbbe98a4db30b6f00d9cff6c7d13bec9683f105d5bb6c32b714403e0d9584ab9e338df93150b082da452b5cedeb5b39c7a663bea19b001673e1cf317ee63240b5c11c861de8aba6c3b0b15de44ad63d8442c90004f2c7e7f93fcaddd0707c973d4c53e5bdf7ba49e75c6eb978bccac31e6cce290c902c4570260493ee6d855b92c35fa8c5f7328c3c8a3f4a98499eecbbaed2e057424d6bbaa3cfd061ad132fdcac76a9f6d7abb13b4df2d0e2d49f79aed68bf55e3108d4aececec08252ea87e74d93caf8bfece31b5aef4e1921464402d6290a14f7736ac0729913da0b4d52022c8da5266dff6f05b57a2cd824c7a04609730557c484c847606d6ee6ce18994d3fe90af62cc1c2b8b907c45d1d0349a33c321d009be5275d489e2c132b320ebf4c56bc6bbc0d8034079c4e787b7b519cd3af88cbe47000f89c97e3edc991fdbe269f350d32c4452a062a71e198555bdc9e502585ded1021dce7113d99123fb7f4d49cba1ab8daa0ffd2306c7e6efcd7f178de6c761a3ff7792a2ae229e97faa8aa85a25e532408259f84d5d36ba59bfa9cf02b620d4acd458652325105893dac4754a1559f6f864f6fff405e54a77304cf2539a872549625a329cfd50ed3ccaef5af6db9985f1d2a730435e5d4b5ab5bba7e77a7d85e0c681dbbe795711dcdbe1ad35b957ec04bbd43f88a6a8aac11ddd695b331a562067db47e1609f42577aa4c9511ef875e4ca364a439c4b5452019e897ce015e69323820f3c613309bbad156902273746ebc1c66b9b9617e5e0f11b5b7ce5dec500bd6313905561e8dbf2358bce716afc4cd351c05cc62c5e51c9754837c57cdc3a4cc9a2c00349b786dfee70cbbee93b422334ef4c80f13e69ffefd6b378b6e99233fde9c88c6df125e64f810bfc1a3b6c63ba7cb8fe86620aaaade823c4de319d71fe1fea46df01afbd1877652bd74807a80d9ec778daa5c45ff2cdde9d432d68d6514c3c46baf0e1909ea8ba275d8f98038756ce524546bfd90941707e8abc4e6ccc89ea41d98e1d215c81c175fa231736490d3dda585703065a01c66121bfa4d07fece0c6e7234ef57f698763d981979920ed2cfc6f14b8a00dd803b659025e21d5632aa64ac924048c05c6842f2ae7e399429398b3972f39731d2ab5043616dfdcdcafafb7b941ea31f837a44555bd481d127c87ccce464f629a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
