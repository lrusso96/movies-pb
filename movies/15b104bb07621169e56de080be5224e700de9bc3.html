<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d92713bf7dfd9bb91fb786d56e616b19154752c28373c4eab5619ca56079c3f707f7dede1addff0fb040622e4c734917620550511f67bd0e22b176acbd09a869ec3ae7e0494a9296e71c9fb1cba842888c4bf26234b84737c7d3befb7e563fe4066f10c46d212285cf579979c142453e555948f00fdb9194f29254b40545218d9ea0ac13aa56c022c7693e6bd67c25ad98c05909df593edd2cf615501b46aa93119de2a4d4eae46c8498e235d4f6d7c90222b2c71235b72721de49cbabdeba2dc97edb6dc039de60be3de8e6c7b1ec3a5d00cf55faf1659fa1141c7a2aec9c3696181ef193268911a73ef816a186702466fb7531d540fb9ee87c06fea22b32c56f70b7288cc226f47a18383644c3468ed69973678fcc2aee5813e9dba8b0917dfb905b19784b787e1c328e95015741a4ae347ff621a2081289015a77553c13bb0d298fa5d38b4eb2150b4a28553f88339bf7bc184ee05fe23395eeecfeaef189ca93623bb9055fa1f25ab2f84857f7852830b0d62751b7354d64ceb6eaa43d4c324b7fdb03dbd7fabdd5da2196989378320cc232b0d4d32cde5335e3949669002903465da81c9f5a47521eb85c2125d285c343ef193b70ec3e14ac878e119ca050fe615ed45f3b3aaab6fb3e52175d928e3530339e7298e1d400cfcf10dd41ef90332717d4a23cc7dc444e30829f299c6149e53bda7029f2d34bbb023b95342cf526ff12394e322289b87cfe8fb809e8c20a1657d9210f88317ae8f153d099634bed947502141e7806e59eaa14970698f75425fd1c605db7328a8d94b9614cd934b9dd37e99b14b1c4b4ecfbd303c729c9546cefa176565835914e09aa9f27e0cad444443609e8aae024e810ed2f12660e0e16369483f63fa679b523bcdfada602d02a5da7cca100cae0e01a2dde59df13c764b89b306a2e5ecf8b0ef349791d64e6685ccd98d8f9131c1cccdf13970c979944d0a0592f94f2969cbc438e41a0a8e501f832749a25a8d577a0b2da9d8a8a0a989ae48520db690188f99f1482322985ebe4c40d46cf0c16f8dd8c79a1e26a129784f3e1ff0cb8105b88b200f80a8c0d1136685e4f42c8dd4d896a9938c42be487cc9ad60c1836669d5e9a8ccf4fdc2ca804a8d2c9a69f371579a209c6c9a5c965a9be169d79b591d6de720f1cc4869dd130814c69efd59109d208595af7ff19b995c0aa3c3656b9935327e696a31083f7b3b6ddbea5258c9cfc6b8cd0c884f41fcda6635223956d9be22b9913920fa6dc524784e6d7597fe1ac721c9c9bf1c7642aff888cb0e8f20ee5eb01c4b3bf0356d0ee9accea64ea0156c7093551be9053b4c09999c343a2db03e5074e18b2e17612c9d6602792b28653dbdb68bdf9a59dd092d960db376d7fca5173343858761561e7a95af8310d80f13c837410fd6ebfe357212c08b13e10589c080c7bb358096d0eed35fb8ad285f3d4fe775b7e56041ab93bb2414975638826bcbbd1102f23542d8fba50a5acc8e321e04b02fe152131640bb60159e279e1325cfe638764f0ae08d8f29bc94885f0973073b8c10526931dbf64f5ebe8cc0a41fb181d7d48a7458e2acd35fe678a9359e1b00980f4e9ecf67c451e687bade85b8a041aa998a188376a6d4921c42b8fd5f24c376658f73ad70285dce8b121fb120558b4517140307f4d4dce346a6f7e4f2c51dd267d439cfbb2abbb0364af60a0490fd785e6eae3930c94c871e728443aac803a6f70ac3fb0d613cbf22f139dd6d816d326b60840685d5139b74cc53f7fd1efd886bc31cbe28735243c7fd721248f8b7a24e36749b4b8fa6dd3cbb0561d3738dfa1523a905cdd53608d2bc1b6ee5b99b7448816dfc238199b52c316a33b1bad213ac8d2d5784d0099a2864ea0658f7fceb5bf28ec820b8cc2a674c219e3c55a78d32e306d3d88064274fc47a273f0c4f35ff848eec72180d4eb3e6bb818960a6187d236cbf4c77000a774f15e0f5fe4d51767dadb47e7a3c99e261923b71c700ac8fbd404a10a163cc8e0e299eada3dde673bf87f3cff0c58aee8abdea3ad4a333237e341a70798c19ea1c9df9335fc2570f236f71b335fe9522102fe0388f4ff44fcee585c4eab9f67e598611c5203dea0bbee4d176464dd06aa081d559d6f18978a87d53b41458e3e71443fb70ce9faef5f65a4fd3c7c575de70e66d09737f5b3fb23c811f39e67a4a6336191e726af004b47f5526abf6016564b3b441688ddc22fa42ba49d5ee7a74dfca47e729d0db899c7c3a887d936753a9ceaa083606d89d384b213fc1513596ae5f0a31d994f2a8fbabc7d97209003c39fb8d3460740778a9333a2a6b749681e7540a0298411d2bc83e334bfc9fc30b66559c87374129fbcff192b005a05a4deb54344f88d2efa3f02731bbf2c25586e5f226e0ffc22f6f2ce51f4d31a3186c2b640070c37cae944b5088afc8ac0be365f680294dd5ec5905627a02681b4022065693edf483fa253e45024d5ece7a81783f127164199cf1dbc0a123fdf3d956e19980db131190b390783a3503ce8bbdd627f30337c4e76443fdaa748067ed965118ea99a832e045346d220878f18ca7c8bafa9f4b236d934eae63e6004a1921932891dfc187660ef98dabd8cb0bd7f60f55c984bcfd958c2456d763d214681c9cf128c49ac72b1941a75d478170e266f5c2b1ddeeb3d739071f105ed8380690ae1dff1c590b5176f858b632a77e34a4a0f14d8577f62a0c8f3c54b86effb67cb5e8bf361519b8adaf7c42822692e204768bb569b7c981fc952dab9be843a8aa0ab1aa3282d6547e57daa2ef7c19ac67433252f93ad5d674a3651c2f7e43fa107556bfa3606eacc2bd8ddb6ce15932bc073c26c6c455e48f39ca848fcc530eb24ee060f587fde1b28bf90fcac245c335337303e9ec3858912b65c80e0b954999e6d6d8f73b68f35a24a9727f6e0ee8d75a566eabff43baa2a61ca46972d073d312e07e67c45d1c2acb0ca7f5702b5da973651e84ad5c9b8e58d63556a3ab0e13d656f5425676ca38c9504eb7d2e36496f707da2b8c5fac4804134c11c62da74ff6c75afc637d861dca5e0683258c4b0b511f151f6413cbaa48b77331f72a440073ed50f1e6f795b22879b33b901dbed7b7fb17ea9aef0beca01d91af0906dad5391757edac9f46f477198ec72af0e29e4ef0d6193a59cc2593bf9dcd22369b4c8dcc511b498a6886829c6464bcb67e00fecef1efe70814dee4463162fbb09e794bc276ba0b1d5f0f45a1a87c9ab4271f9fff3e9ead806306171e7d9d86179aa6bac058b42974a7bf61b3c5d645884739dde707bd00784364c63c9f17e075c9cc58789185075e35f6f9be6673047a4b1ff86770e572d4a025babdf112791330f75e0e35e494303df3dbeaad4c1064f839f596e4615d5930752d7745daf7e176240903d58500f86f4f494fc715d6cce2112244eaccf8dfdba7a7fefbf39623801e9c953a753641eae83e935cad5c4af1d57eb80a8c1f0d56bc5014e6ebea9f690a0dc3b7a27ea0f4fa6c08fb7b0d3b3418efe8a15577a7cb296374633922606a550fa6c61ac93bcc77972c546252d91b429a3b15baf2bdc18a7ef95e682b1ed7244fd1359633a2cdc065c5adc08bc7fac7443de73c041210efa68c4f47daadd511c6c11e126c04d53dae14b00e852a546b5e2564c47af584833b7a19756cf5eea24fe59e25c4fbdc83b12ed495c1786c44940ce5b233b272ca3bdf47cd8895adafc7109f17ae85da79fcf538d866f19742fe84b0d00b21feac6d09ff39e7d8855ec4c286bce7255474ae911212999b7c4f5c7e456985cdbf6534ad9bdc37938199853a6aed2d8fc38a8055a9585a793bc4150314ed320f01c9ddf57c7656c86b89eb6eb61264a6f747bc503a77baccae01e2f9e52e5c72485b19998043992d42c0f187af96a18fcdf87b25027526ac99c6ec9dbe991fb7289fc8586aea81564a32e0262ea9a5e3a4ffb29d80170d2dac552b206afdcbd56e2ee7255fa5ad9c5f9304302b575c1d30003f868e886c6a2f2b5aff1349be679900ce696711988beae2eb110afb43fb3928fcfaeeb6bf09a91e25c6d2480257b7bb16791cc8510a31117aa42e434daa23669bcb90b362c368e6d9a0c84e61d2aea5e64dda474ea48eedea08145d2f803cd1dfe7c7a4e0f2b827345aa40a86191bb65e623b52026cd661c64f79e01a999de4911b918d502b3c3cf66b03288da9917205e9e6be7e3be5d5fda4b946bd4305f32371e84482751b3fcb7b9a422451e3090f49900ec5a53e01ea1aae8f64ff4e4bbf127365bfca8ea8404605c63cb3aaf0f64d90d4fb8167444a31bb33c09f8a109ee5c17a3bd9cb650b8bf09d61ceb215ba10c19832eed6c4d574807ba96785994f6cb552fa5b1718dbde7a4af7dfc7db7b86e38a42aa578d390b325cb01889e22f960926d61977285e4017d11ec4653952d9b38b4c103c2c946e3535544ec99c7a250979964d521a463f7f00220cbeb4ca6c3c8b36243aa82e54e268eb4513a28cf0cce63a36b1f747616c2d74320c35d5458a1d38b511bf070eb586b587548d91e2bf14bf31814c0909c42cfb6a8b178502c9a735dd09bf5928f7de9808293addb1dd3a31baef247eef166f52528bbdbf5ed9156f28e45582d9f570d8832a6327c2e959b00440f1be6c07dc68fd1dc03de37b4c8b90c333a89c528086daf27ab66552718252d38695a1601bd8a107d11c6232ae28b26a7f5384729e28a7d91ff2feb5e1f2028ad26f593abe450b692bd60463534f229ba457055ed10f9f454fd818a94b46dce54bfaf117e21b52f6719a84bbedc614032a8e8d9db4b0a4aba11e364b5eb0d9925eebf09143c816c11b1521f6643fc84199ecee9a5c9d5eb277d2a7b8bdefdcb47431910dc8daa22f375de5fbe904f1ff01745c16a20fa6adff7e9cd63fe76f7b49394882540c274f7e5fa815ba5d149068b38fc9167d00470228d9729c01eeb19c3a9c549c63ce6ad84a9e97bbe61f989e803ae2f4243f70262282897b5fbba072eeb017bfb7969092b19e0249153d669ff33c65c4cdcd9f8d30dd4437d9a6233b35c32a6e1fbd4bd6ff56ba601988b98360905ba295fff9a52c246553de785528757e8a3a0fa412ae10ae32cd3b40d058252a5f43111718dacf61acd334216376b09fb1b1854f2afeb89420b26c15101f84a70c425eaa17f6f1d64d5e73fb3a19d714f57337b1ac816b7c3c18cdd68a584c881b4c5c22d3a35a13bf73b627e6f01c50174a34824786dd7e8739956f6a0ec44cec130bb303c7c34c3ea76c6b6011c7b43a0155a42aecf47a0bdab16a2a52e79ad70fc56755eca79b92a591e2d166d06b786e459d4821ade59f1734c162eae1e165d5d0657dbd9035e3551932fa397c2d1d45654e0eda73904e353d5b903c236bf9ea614a5027df525bccbed3b3f59fe17a81d1f3f0a7210eef8580a5c097b210db2ae7d4e73da008b539d7624285fdaa94b036bc9fa255cb2bde71cbbf077220f0ca39b1ba4823067128e1cf71e6497091bf41c52737389ab6a62ace54fb3f810ca0152892314818c6d50341d3a141ef29444064535f32e83f2e7214c3f7de606650464126f2e0b90df0322e2dc5902d8b73fce8216c038c43c0da77ccf0f081041f5ee324bc7a27f76bbfaf147a068753cc6cc106b4962aebda20b7e5c3883e41371a175be45a4ca10a20c2d67c430eecdb295fe94d146ae5da580da8fc6427ab6611d57d4fcf88713d279262ea1cc81f12fce7c0762f06a02e3a2b18738976ed80b8e0b914b07d107557304cac8a67bdf40e6bc1c0b157bd338d7d3925097278a69e5d4f92cab465c8ba84ef09a1c58947d365395f16153d22b93f322b4628883e342acc755f4b487e9c2ae2e0e3d61913fd7b90fdc5418cbea4b7d67eae75aca936f3169a0714aa2ced19ad73e6529386a14929b0c399eeb70385c708743c3552c740157415d96610e4943bc9424ae1cea793e78188362ef0e401669185ea78a6e445ec32e5e02ea60cdf5e885d00e6a455f0a9a6d9cd1c774c6701b18b9b7638f17944144aa8880e8eaaeb80a1973ee7a5c92c507e595dc68fe46c5d8b7acb13aba9f0577c81294a4249b3327e4a20effa4a144a21e391e2d0c322b753690cf49a5753d57677edb9eee0a311578563c801ab10553a49f957f7e12a984536136d76af744cc2ea370335132ba491ba5a85480e838f444fd1a1eaa1c208868ae082e8a47db869688e16d125a55649c713061e408954ca627c1df2d05a69bfe95567115b7c4e9154b8de2162be8483ab8cfc8cde43c9cb27b20e7582a403a8bb210b092fdf665c9153c4b1814982a9b90229eeeaf264fdc5a4abe507b73a4168a51acc211c3dd5ce713df3b1c09010495a539ade23021a50776d502f942266c30ce2f2a4198d319b3483885b7961fac991d20e3e42797b30eca670f7615d67dce8ed05de094a935aeacd652ac39355561ee25a7b6a94295440c95632b401efd3971dd81ba08049c8e931be1e5547a20068e03c800c20a1fe8bac480e6557d0d40beb43787a4b86157f7bcd8063da3f3c1b28f3abb0f043809784fa3e21930cc79be3fe7804f5560ebe440f8b428f08c32039592215d25685388a0fa9e3af3da750ed64b928a1b2b74f6b0916dae9e38dcafc38e144a94871d2efd1ba1920a9cb5dd7ab69733d95d8fe5665eaad4e112ccbfc8570f01db38e9ed7e6b9cd97c97e0affcd04b194a2d0c8b26c79dab4c5a63fcc13d5591a2c63d30573e4ebf71454b6ac0f89ba470a2261bfd9d030bc1c507b0bcaa3aaf19b84a8a0f3728ad322335a5bae3ea6b42d3e22e72b20186d76bf935d34523aeaa0873ce988308973cd41a5a277145b02c38f000233e8ce698e0d8f303b697c420a9750f201615867a759c7d74eba66ca9925395779b2261304775f9d1b1f4cdc14a16fc1cdf8a891d76a9a3ab018899c4d44eafc2e25d13122d7b52a867c28a3aa31e892aeb32e184e6a6d385b833f26c255f619557fb0a00d880aaeff1f1e225a30500a226530c30a74b0a9bc1b2bec09bcdbcb2312ef463fd37e0dbdbc3c3b38a06e26b913becd47146a909ea8b45909fd18061b451dd3a42ebe8f5701ee38ca0fe83e53462f7fb22d69a664bba6651ff222c154487499edf6d5cedbc9e47a41ea5b9ab182c9f7fe886e67e9eef4f8ccfb6b1cd61be99baf52a0bfd23ecbcc048503b48d6f2f485e9e7a164751608f088931d074a5a31590adc3a1201e71011272836c205e1aa57e67c2266350b168b3b071ca77dba3d7776b06f17ab030540823fb7d7905323e8c5a775aebc6d34774df3db31637fce31545e5be4c0888bcd2c7a3f9e503a4845295e136f40a9137fdf04f10833d0194c8bb5afd54fd6bed8ff00e44b858522bb8f706a4f4a664d087ddc0d86158590604532e0c540b663867f2f1a5182ec232202b0c81a4a819a3ca4ab76e11a55c41a46a7ff7e043f42e911c41dc891e05120a880b5d298acbf75cd22b9d380a57c101f65a383251a2f8b852cd0e3d322b6c710e7350c440e127224502ecd4e0782aacb447bfd6e873f1018fc721b3ccd644d96745289333e64492ae718c2095fe7043153dff58c3e39b8d22f6eff15f20453300214eb0fd0a05e166227e70a4f65800d5b15ede7098d556477d35f869ca6d7a0a46b27e2777387e193da39108c9c6eef556e2dea1fbe183726f54c9578cb18b30d70799361a162eef4e342eb0adb710f62f9a9d86b9a8a0a8d22342efd5ccd2123327fc446f7642fcf4731bad6de8318a383d4cfb247d1fa53dbb354891d02bfeef9695399dd1438431d410096f0ec84c870ed3c99f3948c819bf844714377998bc5378d231b9c6dd553583459c5570747ac2f36f2c005f23b04c6465d43d9e58264dbfde29d6ec2942d4bdabc5408e93a7e44cbaf3990f48b3a3b86081e862754bf6ee5aa1b862b6ee1a18634eeee93e9d9a8a534c04cefffd0a19b581d562478cadcc7cef7c492e40a518ed96d7d1f252b53d51ce54b749811019ae2fa8c713b16dd805bbdc41fff45057cba2a654c771b08884a20c44886593d7dd9d4236b1399347a992feff2ff0a0823595b6ab960a0783a3d3cead1d6d4e4ca157ae522a17080e17068de65d30590291d808b4b614a7b9425bcad83b41565757f88dd7f874dca6eea44405c3f6700a20c69df3ab12f420200b5ed68dfd6cfd333b7275a8b8151d93393d43701566fd243d19a1e11fddf9b7e963b54a7e44a345f1de35d66a63a455738ed46c7b124a3668738bfda0c70826d6b7d0867c65091cf302abf66de6a2b2fa7df299a74b60486aeb2e7e82f7a05b51b53d17fe125952b84f76421b58ab412e18be02ccce6a3750ee85148f15f076ab4e69622755743c77e577e623cd304f00a1e119dd1a74603918aa3f20d28167a44488f4bab7a72f1126f5ed5236ca20646583b0ddaf52557a5709e77c7130a5e520b9f4d377b79fbc6b36d641ad55b289664ee43952b20632b993446627d4e3498d96b1f02025c38d1862b42b6663a7407277090e336ed19a26111dff482b5fa26aa9dac388a962216d1062ae8a01d2fb8934b90e746e05fbfceceebbea29720447d6705cb25a2c43e65c989aebbd97406acf299d058ea2958539c0cc8786fe2435827394e1391d87836566a819a8974556d9603aebbd794182afff1a1ad8a64baf9f5c6f91cfc706b6cbf6437d28e125af896f3d647dbdda33b057d906144464c4735a865578a18874d0ca292fb206ffe5531255a91e2e4140a0303fc7cb9c73f154ffb54f3237bb76e6aacfce53eb72f908ea0d0aad5a199aede594f69d053903e957e122496e997881b014ab8c0a08310f8811fff9aeba2a8d2d4d16f43b9eb02aab8df6cf9cb5b4b0e7afc1781fa9549119851a1a63c5119ba3721c70cd3d6a4e333a28a1e4176ca8a4017c5f32471e13efa36b013daff1d693eacabd4fe32381a7af7a901795c8e262d64c4815ba0715ad1c515389c4201f3ae39b4f6ed10ae5fd2b15f243a1b6cec244f6d63d735088863ea310a3505d09e9723ea2318d88aa49c611f95c1e04d7998e4cc63c9c9a6975aeaf9585fd4bcef5abd389e73af796203d6efc81e613a96466cd0bf3f2292c2b2c77119ee2eadcdfaf965c17e360fdf12fd7b52160b41e741dd703bfb7e461e49fa4709280a31f6c1bd7edbbc656cbd8401e955de95c3fc0b35b3592a94a0e5b7e5e65f0064922bb3321d81c5f019a16da7801d03cf0b18739e43e142dd9cfc81a16c44c5db289f11a54494feb6dbee612408e988c5a96f554eeeed717f50af6ca2701169f42242717533d8b2528058205ea9ccb9203c427f9157feb8f575f642d9afd9835c02083e03f44dd4196ca8e5255f83b2692c488da1d7631c6716cd3e6ab697f98bef5bde63a4f1d121c6aa40610b886555c128720dcac6fa879ba8d3dda6594f03568c0157c8aecfaa316a4a9fb1c93fe2a4589c14fcb0c0e21eb1e0a81202408c6a72609c267904581054f8744ea156ac6dcea2e15580b15bd6eb33c8637c14c4d645e2ef19b6fdcf470c0e7c020463548c8b8bf70240affde389ee2a95d902fac5c38c1ce3e4f8a851bcc5902164b2a3737a8b2512f6ebf0dbddf4439ca4d45dca366e083b3093f53be2b9f00cfbce01df97dcf3cc37028402ca779254da3ff1bd968efbccd0bc99e96c6b2e5a79c314a3f3d94a8a5257993960522dc9f97ee974767f21c53a5acf966394df72b6829c62c93dd0ede644efb15e295a657961c4d00aca4bc8e7331e11cf2d1c3bd8f373dffc61aaad9c7706069f642741548e7d0c38833714881d6728fb80b016aa792725a49c750c5792d58f33411e67aa9fc128ab3f7c96ff68b27fb9347e8e723a3cb020f8b476d7b7f881a900be52df7e088a96d365b67e6a4ccc5bcd79b4e48bafab6f88de215a2a581e31f34d1075e41c570630d83a683b185547c3968adc2f5ceff44f901354d1e68f3257d06bdbdb8bccb398c25410bb3ded876bf35b46a10856e6e09acfa227a31e9822aa30a59a8e38d2443a356e971221fde288da4ea7438fd986385ca3b180d7e996e9bbe459de8a4826ea93f17db01ba417ae838effc45c237e31f5b23dccdd9b03cdb7860236bfbc2004906caa000965ebc588ce75d5e420a7808b31453ecce640be92bcfbf45a3002e2fbfaf7b9fe1a67943b065eddbb991348914eb9f2ad85bcd65ed228a037a8a780a4d7293022b367bb0adfd228aa9a28842b3b991c669d8e365ad4a0275ebf7cca99309bf774788672af4b148b211217d4b97f1697906977fc5e2e517e64a1ed55dd6ba928080b53014418e6c25f38810106d9c2b5536991234a7fd71ba9583933046ed73b24658c59c80abcc251758a7a595c4017573956626eb9540773fafa7103c544361c8690cfcf307c43521aaa88d0b77557c65a09566870350bacc6f38fc241e8c34fc28a0d64a4678f95bee48c495c2a57a2ccc521e03e48707d4edf60f1be56cc55fd0176777c6f5f67b03b809235defa4034bc6c6e58ad81c80f72e9ea96ccf5be013b6b3c42999ba8d1637457b110b0ce0a54c1176caacfc41eab032bf8cf5e1367436818bdcb882aac912dd4d35928ca2d9b6465dc40d02af7fcae28b9d961491d39e61b16e4c35f591140f4b86af05821a3e92932563e25edc23df5137befaafd1c99f5d5d01fbdef52f3d20f9cbaf1b44c943a52cb57a37c92331fec351bdd1f38b2f5a1c126262d5fd725b1c317ae44ddf3ef0e5ab9356e1ca52221613c1543714825d2d7701970dab4410cde7e548ec77688884632b8a9a8aca04037d759971586d656f193d035ab2d68e303a0d4feb4cf019b4675700c6870a46e50c4ca899330f409f9131841b95c79778272a4af9c2d5c46e9b0b07d8b1928d583aa147117f6db3d435d76170644b2de311549a04500ff3d2cefa43a7b4e248ee57568b095287185ab32321ce3d7cb74b49465a2299e4347b0ba89ed35883161fed2a56596ab13c33b681a5692af6b936db1676a53d1fe03e1126637aa6f530251919ea9c786b4328132468ac18ab7c5487a4e89742c79ab87aa810f8a2730b86b8f952f86b73dc61c6018d0cd56ff9c42c6d84770e9172600b2d797c40cdb57f201a4ab6f1a3745a149dab1ae9f17b3b66c3fcba18357bb972a14c3d0557f827eb63c369b1bffc9d0e3dfdd2e12464990ff9102a1a6fd865d016dfb0c15374480507af7dc612274f1cdb322f0a58fba90a65ed6574d5b9f97055f6626c3579e7e9464954a2ddce4911b04ae51fad7aa663c39d63b3a307e42645b39fc67698ee843d7e4cbddbe675fcd5d909738d9dda99bc1cc9d224ccc1f8f78af835bd117a597b3132cb6686619d9602c878d03bd763a8fdbe5d8f66b62d1fbb2e12a1f7d33417fa4395d14939fc7928aebdbede0e5453558680d894ecdec9fb989706f03c42f5daedd95c600b4c8946b263ee0b447b126c2de6cbf9d64b13052006f57a4f18ab2af8a8c5ddf4851b444ea0594c85cbc933cf1c77102dd98109f55b9ab14d106000c3624df8826faeb5892038eadba525a8f4aa12c411373b2e90ac3291770093c903ba16224b82cc6fb06fabc24b84b8c20503f4edbb73f7b351ede20cf541a48d16f882b4740331714dc0756f038341ce34b3708b04f1cc86ccec165f160cf0f75dc7d3962dfeaa4df9a789c818e6c0a41a5e42a89032fdf745f51c658a9ae85e1e23d40f243f31d3c571fbfd7a56ae1685066f9cd190e5115d56df38c8f5e55b4bf624720df59a980be5079886c6630901c16d434fc7ed07f55edf61d9b7b12f5876e28c1ea902083429c8347b3342a4f5139471ad84a0d256616c8b75e7d8430393136674b13453464a4d66bbc0040d091df6010f46e588045c7ca785a9c9a2eb70eed906fca894433e8a206b5633d37d5910c545425dcdb656e14f7720e7ad6530211fc87abeea28d435331071c8bb3053cf1fc167263b9f7418c6081db44caa41bf9d02fa130233198020f422111c351bb2ce6287b10f6a1bc769d44b96b90992fb4223e9d7f748e0845d0ba6c7f90c795f950a30cd9ba2bafc397580a010c9b2d3102d75d374b06b4c8154ea8e74677f35019159c6e834ba75bd736cd0b196af14491ade6dabb61fcf7eb8cfc10dd90817bac0bf28c92627ef6c52b4a2daba8de4735f731c1a2b3f847f8ca82fb9c76cfb0e39ddf1c96c4488f8ca48465ac042e89913d1c1a4f31970264831de38293662aa672dd600dc0b57f48754f62d5a9dd5f8cba3274aa79e03d54ce5555f066caf72809029fa420a1b5550ae0f271c907589c8fbf5509e3c78fde76f6885362b0686a1704ed4244a494f6877f80266befb4e41a5c91591a08a329256e51d51ffb6a8c389ca9ab5a744df46cec1cef511d034d2abb202b4a6c26317093f92f2056d8dd49f5591ecb9a8d18ed30e48e47b68c84e9da2590c195a7d6a35b0eeaa88b7452e726020b9bc25a07e1bf1ef4a88df482fcb8abd895f830e4de5b54637a5292710552a428fed66211477c19caf0cf1f1fed7b10a8bf90e5a99c41d13030f3959cfe0592d5b58457b6af1de5a3b070f1e5b84eef7643f6c84e2a9414d6e5d5f12ff4a88e6eb7acd4336028224d5c98ff5784cc795c4f9cfcc0e533e31e8cd0fc5f59faa057008a0ca1d62dad32fb8ac92829124073963d3cda06f445fac93792e20ccd1570c71942c9777bece74965989a426eb80d2064e9510078511b51d131abe8a6562b6db6bf96237f3af01a29bb4b65ec26f74d2392fb529f4000b63ac08194f1d8aed6575a0e50791898520be319afa6c9b395d0e057ec72b47a6df3ec97b285a3dd4a326e621f55ddf8c3deb1958661c20283f8a6824d63f28eec903501c96abcf7c4d6f3e467d24287f62658bff323b18d70d8f21365615cd9b4abf7f632191b4aa3faf48fb240d71354b48390eb4015f008e03646f047fad639a90fb9e43357773c85c0ca792e852ddc3cf3bda792b93866db09aeb582ec3711384351e07d2c75dde8a9f0dadaa9e8856524f005f9c6d0831af009dab918a67fd2aa4f359842a3c274ccbd2f19bb27b03778cec58022b6c8915852b316f08cf0ac887db605b3b042c7b79fbd080e371ea9be2e930bed0260259e40c7202dac0595277adac96f325bad0461417c2efee427bd5ff74d56dd44f726970d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
