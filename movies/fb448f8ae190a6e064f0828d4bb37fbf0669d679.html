<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"83254daada3983fac75e2804d1f027dcd1e725e44515ce3cd154c32dedc75c6816c1b9bf6407de26318487d48952ee4a349c42c70a180f2fb4d1b8c2c249bea7981075fa8ab42743dd5d0f5df730be1447c389bceee15d2380f7015cc05eb87b26448d51a93d3fa9df1405bfddd8e8c5a33f63f82151edf0929134c4de43a13d2155766033cb1ab8e724465e83cab3c950b138b018c09f3f74d980cc4cf7dced93c85753d4f5dd61371073e267b86c9266779097f5e5891dfe4fade98d4911d9abdee203fc57d794313277847d362655d0ef730ddd2af813b394c2d366e8db0969f86e9da4618af656cffd49042179ed974f9289df51b61db4cb11471df7b709d9689968a2881d456a9e85ded791d01988ca3cab4906d3db43c01be19ad31754b9408d180a6dfbeb6aeb2805af53f61dfeeb91f5b204adbeec1135b61528f6e108245a4c5f1dec2a6a391721ac1870a147218380fde38f2666c87e238fc1e1cc7122fffeefb1c060007a1b72e318f07ac06cfbc2e5cb55ca9d217bbd965bb1b7bdfde130851b5c92a10aefb1ada841924215873639ed55a4af29624b5426adccaba3e53ef4832a1185fb3ab205f805103e0e9ecf8529fed1e948a71df6293419cf19d557c953ed454b826086b47fb051383977b2bcb78af463b587a87da5ed83ee8c36f5b4ddb1d17760e1cbab33b3ebe32bb9b929ef9ab71e729e3eaa8544e5b0f2cfe145ae9ab28fe5dcba2852b1102bef3cd5a40b302d5703c37f2034f013e2c800caac7a4eadbdd7a841757556ccdda61afc82210cdca41e52b52bf151dece14a0b95f3b9ac4f6e818f09090c3d49de29181bf886cb92ce366dea8e882c232e27beadbffda09dba056bcd50675378309a2593437bbab13c82033262536222d9aa1ba87c06b26a3e50ef4b54fcddd0bd7dac1e8230aeb5f82f0d7166c1f41851621dced728b0da01176ebd4570e8b2015caf535279d9acae55ac6e033b317cecbffdd0b4f0c13fc3add1f1eed170a3d08f73edfebfc7c9620b252de06052be5d0e0e50249a43f62310409c86540420416927ac452bd710ef520abbdec28759c43f82e4274600a3f2e7efe1c62d6c48d8edaa6136334b1622581e445cd1ebe58b035906721bd34dda13e2c58a1375e9c76f472b26b3e696bf965eb60990b3d962417b8f8da97bdb66ad9c4f2e642adf84c9f5f3961cbf15da2a1efa5d86f966ab7583cd943bed93c9bad0ccbb1bcf080f245835583c6b24e0e7a342c896bece3941604d8de5e003456159be9432bfb2b030827a395eb4a2f2bd192e08d5bd34bebe8e6f60c3a25e8412b855b47108c33328bf483a615249d9c3be141f71fafd62354828e185fc4d4632e9334299a685c46007a1afc6ff0eae27cc54b20216ef940e2066f3f7718a5f168063da175cccd5f5d02ff4f69d190b9531832bfb1e608aa46f6c9812959285039a469f3f2aa32df958186d6ba01570a19f164b7f85390575e57604850a10950db6bc827531165c5e333c16d25d53067ff35d771a407723473c5cb3cacaf8981801fb5d2494a2f1ce7f6f3c4044b348cc7cdf41ac670d51ca69d7a57d8839c206fd0e2771135cb3b4edcdb1df10915d05218b3c761fec8f5c2f4294cf101eec438b3d761021180fa6ecc2c891d8107f3c7b0419534874eb996e019f7490a57e8385d25332f3444dc76c46cdd8fce5c72e90ac9eb8deebd9a28a3fdc00b032370959f8ffb7e13bab4bfb4a2845c7c3be0979456bb79aa41262d306bb8c180facd73d4ac0210de696f60f1c59215c65419faa46d67affeb952e2bc7892349dd3bbf79930316cfb25d8761f428f591782e8af86a8ef9fc684530101ecc2e860da4e4903de9d4ee695a062772480a9d4e17e1e9e4a9b0f641d92b2048402e16c803ab348168bde65644a9fae9ef54ec9c67e50e9de172a655af05cd21626b299fec4578582326912f2b6bedd2e4c34271b3b61dd1594e5b59337860c2f32a4c792a889a901b46c23f2783c4c7ad228d8023b2f253a7f45ed985f3f0e7d338268c6d9622e66f8d62d5ee26e4afb1acd4e6c3aa0f4dd92fa6abf47cdf8f3f05da2769754cb9b6a312ff9608846c9fb7ed4152492883eca7feb3fd15ba883d759ef3cccd6bb7a2e73a7ae20f392d0dd8968d5e4f2103468d0249d0fd249b75b959d4986b83843a5236e4308e7710c0af9d67eaa28e922d159a813c15dd960e52c0b80958efb95b2049a67ece70c5ed279493f8819bccaca17e010281077a19e6a8fb27851d77326acec5089f39a4761148adff61d108e37dab18dc5ec7e884083a3e0a14455deb156d12505f20b12396c455540bd543e20c4812b248b9e08cf9bce3afe18b7e9505c28adb81057dd8a5510d07226a8d6bb2687b0e8e1a08d61890e656dc70570306b6bfa4b39597af8a1926ab90a1335a51ebcbdf9f475c8e7485c0190e4cd5fa533319dcc57e995d94faa5761ac60df5d761579931d4701b5f62a8889f4722d065e61a2393c6410b57fc2c33304e229c73f9c4b50d94d94cf94929b2fb75e220876363d68595b6fee11bb5c831cc66bcf85df0c349044b1bd1f94cb348f8c620b2ce9c951ac252359f4daf34582b67961d97cf8f06df20186993d330d9bb0d02642823aba29a231da32b599a32009d2d9a0dea33a7c62f7b29bd1e9bb7f57df7277f772a433323112f9f569215b8134092d11b443221ca7aecacdfc2b4a6967c74ee86f480864287a4952858d79c8e801070d9dcd42a05597a056a7615d84b63a75af78db46d93313fa625a0b82501bbce3586cadbde61842691fa09452b1755ae8add5953b175e0cdb7f470186ae0bdfad75c4e555e7128e55185180f084451ff05b8e51363154059f8aaa86033ce0ec22e536631ca35d149ee5ed0d7230eab77d96b7eb83f3e307b4ff8df4554ef239084f1fabb996b8e209ce2267b026cecfd9039a3b880f1e74895019e359e5692af2cc2b422604021a38925c9e249852b37698c31fde55a7fd37b376bac123b61bcff996be67d6581a5ebacf39f81ae68e00f0379a10b622517c20bd63ae97aa1b4aa8e75678f437c9adf28d13efcdd37b222c62a36ca86db4874114b0478c6b60db395628df3afdd04ae307df8ef35422907f7f4385f14d95393dc7304abfaa218f523ed8b3349197a9b5a26b95b0c6b211c240e253357549ecdf71eea3c6d0793fa7ad81d324a3a2a73a0cacfab4027b9b0a7999c963e28347a9d847222273dc182eb6b72b65d6e547f6bbfe2420a8b7026093a4c5b100115cea1693887b8c992586687f1ef88b2d934f24e237e7717166b865dfeccbf94a172d212887d5716dd58992f9a70145acd2eca5088375f4f341dd6586176722687afebc076438928b8876e44467ac61cc9927f3c55ad6b0ef990fd787539932b5c184debf16d1b3109b5965a92a4ab407a792b4137789334057562a5085c29d2f0cc6c8201176348de65ae909495ea074c7ba7ba9cd6b0e37e4d44acfa0553289e6ce483217e786efa3f5bfc2fe1a2b930513be7f9c0afa78a2aa90406f80a2d3f6301730b33496f3c21da4c66253b7df060b2934481922076497a43253eaacf2f1763d180be6431ad7f2870bef3521b71297bc07707fd2db93f4cc849fdc409cffab2c9a1891dccb6f0e68c388021eb8ab31c1a14871b5d1a841633d20ddf36906f61adaaf2dd857187b863def88df1af215144b48062ec2cd0c1444e02d77ad46ee6a0fab811f81e22a479aeab81c40a787048c07bdad9e2e4f1015e71622a3e4772c8a36d1956cb2a605029eb5ef73bc54d2526d89502e0c4fcec36eedcc5a5ce00f7bdd6fed5ce2ed161bdd1236e46dbf91ef5fd9443672d21a16af0899219fd345ec3d7090357dd206a03464627b04efbdee27932929b8136e540be97aafa9537213c18e7b714fb582c86d1d9e793a2815106997261c74b8764a154809615ee7f1154f9a878a76c3b4e45809517b444fe652e79a6c133b909272b011d62adfb4bf17e41604aa50469785023dc0825cc3b4565a6dba38503a273536cf4f9c444b16f9e7eb340a396bb1f86986889a1d23bc63bb32941794646ef64cc8bf5b4968f36fe03a7bad98668718ded8dbdbc90d6b82a0d9c4766c7cf451da8912980e979746a237358b5843a1ac4c8a6c0582c3494f8f8119efca088204430ef0462fa2e51bec6bb56dd319d200706127bfe2a65c7741822d1825ed0bc9aee6afa9064c4921c855596ebb647773d68ef86b751414c7de68cf3fbb04a9f279b80bc2955e8d270e1519d3a87f13996a3012b2154cec44e0a667c142ca12f5fe312465568b791491be79e089a0247d9ae71417a5fbbe76bafc5e646dcf910274f54b46bb862445f41abce9d771ab2a779b2dc2dec58696759bc1bef0cf2ccfd3c4ca8e188991c5c694fdcd1bc7ad485eac1701eb1ad4c6f86db962866d3a0e4e6d2eb02eb50c41b1fcf0c807fb5122d4de1b8324699f0536090cfa110bdfaf40d3ed3c516aebb3b8ac757be36a97d3dd9be59dbce2d7baf4519ef549d0986fdb27d381fd7473e8d15a4f156c3f1633d806129c9cc54bee46cabda57a2aa54717fe51c32d2d4d7e2102c8c64e9a169a58af8d29560c95b6443029e20e754e1eda123225cf8bca492839a01e17c63ad8042c8dc8a9d6d2c3d99ffe8ab75669657705c8a3800bfa1aa36c2f081834c5757e0b94e4c82de3157bbc9dae2a347152047df69c51707ba1f8748f3f3c6c2cb9f284dbe904cb1d890c508164229eca8417cfae61a2c23906a7cb4f42b4ad118ce3a81e794fcae8d76cbe693b0c44a1688d60ad6cd3a9d5693b951625abccae402fcc743b98a30e52ea30e48a7a3edb79b43ad028fe24df6d5aa66a66d3e3b24bca549a42f4eda0e2b1ad5b9cc5ed2c03ce2170ee3284dfe5e0db668a8e5729af76c3fc5cc5173632b186e27fddd30d1070a210203bbd4963772877918ba1de24cbd993f101f440f931b9a71d1939abc552ed9ff8c53aa3294436452e2786452c7422b73f1ab8a8198a15bc81c5251ac7a9ea871c1883f4b62aae917b7ba4c67da691389b879e71478cdfe76d0f4848146b620fc0dd74b0e5259855b8a611530cdc62e4b2d5b147fc50d785ad1b6cd866d41dc0df68c67d503e8792807b612ccc1e8087eb79b39ab2d7e44005a2570d518642ffd57c0c0e3373a5888f17abcb74f0761def4ac6a2dc629d7053386dfa891578f7253622629020f2b17dc8e46406696cd5d4d24ab0722affedee6a4486ce60dee6076463530cf700645b6b86070137adc23f946cf107cc8c6b1f3636a224b7a50e02d57668af37d95a326e0a64e5d616050b51fad20c0a1b522491037ee3e18b33818516b57c2308811e7b7c1053c3f8b87acb7ade70be1fbeed137c3472537c0549b7a54ce9286fab542be96c044ab38f2b9c30e1bc4c8ab34ed8123845d81167ef63b6a9b5b7b5f543af606793d50a8e37a9145f3c9ea254ae99a7321c543fc172355396e3c5bb8adf464cf1330a07583a16afa9448cef925adc05b2e7cc3ae950a8ffa54b0e0ab932fbd72498e9ad725ced711b4b1335836bbab82c40bf31b01a51352a879d248058a2f4b4436acf80e43dfea5e6fbd197d616a1dc228d9515796f74b29e7c9e6faa044f99ffab7e1eb5752b6217b4fcebaad95de315f0741aa61ef020cf34a6dc4f13639216c0d9890c0bcc34e2a40e873eaa685f1632c57e87ada56f48651f6fa8db0ae585eb566c2c441a0b0abc4720d66504806593bec60d064d5fefcc751ef1ddb1dae50a84b69298a6a45fb4ec7b137cfd7fed12cef6b2c0fc852a8d92ccf455803edcc98626ed68449a0456b32d1fb96d483e908dc8b7c4e8d462266ca3309c638824aee614753ef36de6fde49138181e0e2682e3d3cf34f34288044af6a1438d79a10a9e00e75386aed45f08cbfa8418ca33f84daffe505a5e69b45a0220e102089bda9ccfcb033bdf15727abb633303a44eab78cbaf1ac6f5c961224190b386d46aa2b688ad3dcd58b73b90698963bd5f1555b598acc073b0f5078b0a16448ae985247c6045455e3f5d3042442ab263a3b5d2291e05aba8e4bb3871094e8ddef4d85970acfc6a24f2ff7424a09a9cd87e5f8073677c22361363b10cc24c793350dfe79f3075781f13cebadeca8a91435863a3e8bac8e9558c4f42dd53664b5fbc2189c7a2d7195bb9363d9509c00a744715684860eb7fef200ce515ca9b12eab5e72f1df837645756b23200776a0db73fbbee1100a0792eb95d8ae8451d9ce232125b329a7bd6fd8d560a030d052b401c7aad050953557395860dd8f1e2df4a40677913a766fc70b90bbc3bb504c55883bb457ed67af9ca2c1bba7dc774e9ee2c6e6ed1e4e28fd63c42c8c64994b5807a4abb9ba3779eafb24ac9f675a8b964f1e6a2d20f3923c9d8b40fe5d0b19a1baac8a6c9d37b8f0168e3e87e36f6904876d0d20a236cc44beaed1bf7de32938d297fe8a0808186a57b391fcfc031a119c34c73de3b4022388afc24cc9003b15dfadb1fd0173c3a1c047b20649651d28a3757f34b89f5db7107985d08517667b0272eca0cc230756259b65a808c47248b6a6cc919ce8e13f7c990aa53b306b666a48d8bd93fb0d83c3bfb8958fbb70f800c06f6855399b14e48bc92c37a4e2a2eff138503d6794378a37bc3ea447b9bdd66ed18630d6c2119f32ef01c082d9f95b26304845040baf67504ef4e31b94a5a79cccc20693cdcbe786a25e461e129a1da2a9d36a56b2209ab4019c6449fb0295bcef2d8590c0f687cc2cc60edb87a953c266eb82ab974db41cab3270dfaf4b66899da87e06303601fadb0691eb6fe3442dcecadb3b6e2392893df816a2aee73f62ffc10cee2cc18fc2ac5f320444d9945ca072afacdab5863d35789920b7e13e778f2f127c98d6141df92b45f0e48af6ccedffde35f30a657b70030d25acffa3b5a5e347d4aeb71d1c05e9c495b1164d80bc7f6f1de0c269a11cf18e58fe9e82ff68c8881d9b5eb20e05b66b1e984354f8763175182e293741cbf660ec47cfc208114ee319c13f9d6226da9ade730a67aa885677d3d32ca56d215b7a5825c73d733cc71b67cdf38048daab3b153ea52c04d61854ca18511a4e0526918625c0cf00038ac9d2c07e10b7e34ab3324fba25c2285ef27b90ad45400c9e5e1cfd9f8e1d2d63ec15d846558903bc9996fa63bcd6dab70bce1cf7776daa2cc7cdf262584ba4fc3c57af0da9e5a99f6139120fe6bdab4ed2a954f2d92af2256a4347a4b6a491266825c71b296933492f1bbc598897aead82f64ffe821d943d29c0bfc57eca02da7163bc6fede7a36617d22493148d8981071a43cb2a6e6bf22ca62018807cb59e4ef0ab8df6030d92b5ac25e7353870e5288a46fb4861bbb563faa71a342d97453665697bb370541efa4dddf051a12430183a3cde4652b47351cba50bd26feee7d64b6a24f31d954f0c5cfb8018ca278fb8c6183ec456dbbc05dd091e280ac07b7ba8d838acef27ccb714740cf795c41b4589469799d1d8f3863934650fdf2ac5ad221e4f505b0eca1f3bc3b31184a57066c755cfc06f1df098273d6f873831380294131ac16d62b021e5ba4c1b45b1fd033332e6ec69790cf9ada3a11aeba0a3dc328c61daa018a5ed2d214a4f21ca8753f3970229bdcdfc3386833533a582ac46dc0cf59789c024b2748bee693ae730e71fea4e74b3c7e047273f0fec742cbb43415a0f5ccbc5f02953f85b3a817bb4f704b5924e042b4b67305948db11b2fdf309daae5074e6464fce032a8b52494ab163f564fc2c491af0a9a71233140aff5f00d43b27fe73efdb61e7ac7e1ffae7e3f714bc2c0d94ef9f973710173ea09477a1ade339ef23808bac7e0c4b4bfbafa7dfd2cd796dd3fbaf32a9cc337e153730e4255e9c7c800252e35950376e3d0eb7d6ce9f617f4f5b781e514afb97bcc95e846c31200efc15ec5f97ea7c653864de9bf231edc12c7491cc3be469e2133c684815bada9ae4649373311addca0a6a6fd7076eefa49a97f3782e5dbc2033dd206f6a3d66d041a3c82de1ef72cf8857d92f69b83eb69ecd83aebd30ba8e5f3d3708b9b4e8c1f31ff9ee63408b1d2b21bcef7722edf28b050b68f4e9cbac3e42ecc15ae5ccbb333fb12d5f535068d338d3e9fc2fd27ffe7074642ac7fb13d6cc73bf453ce3950a7ee4fd943a10bb74d9469f9133e14b734a58b5482903225816b9d9b6486dd01d110216d357369ea85ba6090eb2cb3596ccec90d2c4e4e3c222c4dec5df802b4dfbbcb2461b90d18460af7cfc345c7ec066d84d128ba6d97b7cb4d9d83c639a52ec9cb1a12c1351be1ac4d05981a5cb2e2920d29d6d8ee0c36782372bde71f9db628bebecb519cbdafc275661130d6676ae4d76d93be267fa4b50596cdc7a54583406ceaa400e1c266a9289676b7aad4fbfda88b232b5258c9825c4b34594dad1bd990a90f3fc8cdcf93f00b3872f5ecf6df346f4bd93016f6fedbd8ac381c830a183fe714906f3f3b9f2d207cf481cad0017a46ccee7140dd34a11fc68a180fb541f64ebdf4a81b4f06541098c0a6ecd79c98442bb26e9c162419dd32110cd000ef240b847f36632013dfa95dd17df829b1083ef9f6a655913d9300f312630c50be29c8f2c623c5b618226032a65bbd1a5951d9ae5a19c40d331b9d08805fbb560208d80d4b3834e202ddd634da3428acf888502dbe94ef1736edc9677346456ea97c922faf78cd8fd4b7cfd70d2724acf896aa9e5afb82e3abb11fa160c67bce6784df660682fc03f5d33fbade9929e6092632ab4f6d9da21a98fdbbedc322c8f81500ab6b0555193129532815a8fcb8ffaa242bf76845c6967d590dc4ba55db111459fe2c858a416d6e7caca64097e9910240b7e47ea93cea2e027a4e7bcab876f0f654165bc12670a2d50813dbdc29629f3b0dc92c055a94194c95cfd8761942d73a01648386474be7c7bddb5207ecf2d6a509f148065684851234a4c006f72b785063394d7643af0cc95ca983f7289f39d6933236401475b9d68b30d7eba0a3eaf3b6ca178da97d943735702728330190dbd6947eb654b7c3227cfbc4a0b9a875b6f5da7c2042d865817d7640fa4504e099a517dfbff790d39f7bf82434c6e3aa590dd43804ca3c6d6fa22aae973315715a8bf2bef37daa79ad889842120400e5e04b3572e4806e14954b424b68b3129bcc52b22c8ac2760efed2342fa416f042f8dc8deff6e5ca25b802d5fe2cb8266708e2cd9386272258bb4a54ba4eac7e9cae8bda2341ab3c3b352d3f30daf5a49072f8b2236a2f20cb9b8a4d9c6a03e416c0c48e5f5cebe937e5798d216ac4624b903f9788841c57d3621debaa83a314b6629038da05bb34bc574ef23f9ad24a74bc21fb4207199b6bd2923c2c113270eba8f299795021eb839ad7974a0167cc1622b291e6979acdd2614662f750dcb02c22a350821addf8c11556065dbb7cb478f09de2bd0986ed036c135ae8544108473184f15ae8340392863b0968736033fde6aac9fdc051aaf716dc6a80895979808f9cceed372ae85e4e2803f9e5bf45bee60cad90d4dbba922e989fc4213107a07c4d1b88c5d1bee367d4fadaefae090a477215026801142bc6c0df22399d47b2c384db2338c6e411592a57c63b4de820d47b1163076bd2ca1cc8bc4583dbaf10068824d4857d1c37351d8343b9b391df0fff083fc7304bb34a76105318f64d2e71fe54bf10043da5dcb4ad4333fd7c564cce203126200de812f709eb00fe3601e68d6e6f2e18725f950d8183573c03a1ec4212ec7d268603223085de1c263c3a08030d365a93897417c55f429f26a9eb9d9d293f678ec6406a6201a6c622cc7f1f511a6a2c947150193297a0397eabc86e27d86a4fbb20be99200d5d02f1785a946d96641976bccccb6eb0ae495e3cc3511263f4422876f1b8b1f319992f4a937d751aa8bb50ae887bc6422a713a1b0bb3247cc880aacb60bc3a96ab2800acacff3d8a4a89c7f8e6c4e6e7acfc74fc2b8080963ab71769dc7664f8a269696a09498b92fc258de1c7519fb8f678fa9f943b3f4576766f52c046b277527d3ec0a68262c3ee172c880dcc5f8a6bc046c2473a299b3a08946b9fd42ae89ea81de8af62e15a71f32b4644f48068e439e71a4b485582f4ebe1078c38db9ff2782a6694e440054fc7470299332a42db6ad0cb137bdf9fdcf4dafa5c1822740e23269a77ffc86bac6861ac95e53598d45223b4a384c8d354985f4fac5406eba3f5fcbcd7995754961a1a6339441f967217e4ec2d037b4388dd3b1cf677803c4ed34a168d583a959e99fa662570f0de6ff16b0710e081f056f750ce42444c973cd76006ed9ed05ff7d298eebe757ef9e3d5eaf8751f4f4cb694abb4628eb17b758f5ded37728ca6c466388ac915f1b3d97ec68f8f6c5adcf58021d4f9a9e8e96a0f01ade8111a8e5a819a170525d927d028bfca6f6e25e8168665dcb3c172f4bfc4c32bb884b512719608d76f05ce3ef8b98ea2ad01ed53efaafcfab872336c7b0db5b0416c480324667c3886e358c2466353c10c20fa6bb8700d1371fd47ee925eb9199d8ade3f32a95dc040303a155da5afbe61cd63d56fdf45017d29a52676b1a83ebd465f3761aa6b436db2b4ac227c63e67edcd49b362e647fa44f5eff33d544e22ad3443ee6a05b59211bb57c30900c25b105a3bc38246b6291845192855ccbf1c245cccd4adb9b8bc16a3a5345f9fb460c4f2fff99e8bb556b6b7d6ca2c1c684921fdb631953f6ec8992313dac5f7a311dde3db66c5b9aaed273bc1363a80faedcc171ef968394fe165cd57b11d9c883b614eadc4e584408fc92089820199789aa8e9cd0dc31c5b99b732357779056097f7193d9998b665beafc0f68a54509b7854b43b9b4132ebe2db06d7700ebb7f4f696516e500a38bb88a37d2db9b142aca669c6c9d44500fd6917dfb9cffd9f1537c1e4e5b1a1ea9347d88913bc962bbb2df1e22fc53af50fd9ca456ab18b5c7aa4331b8e760a1fc0ef6899382d77e24d24f8a3fb6e1056a06f62db53ceca21701ed723ea79841c6004d109f33199f794cb3b59d78dc42a1fda02724132294dba8697639570c4dea20a45623ca323c22943d70eb7cdc3416c7a0fc7f19bdf3840df971d74a5575fa3992235d564e2da33b6f93ad2bae3dd05e87afea1ad397f19e4e48d35f3c466444a388c661b543be6ad23201668733d854d09e7c5824b6166f5d46b44b7915b87ee320d401572c74ba189a151465412d7abc6d4982091192e4d717d32efc84767ccfb715e291408b81fa9646af8aa30be1d8b0748d02625a10c54d873076cb2ed272f065bf5f74907dd01e2f65ae84354075ed70570386f76f521291aa07d771508d2e145a3cbb78e9f6571d67f0137ac21eb58ce1aacfde516c4ec5dd9339b1cf612e6182a3041227c4e93051987e5a985e0d3e9a97f75d7648be0ae2c74add77196c1493552495c6bf97fddb5773cc303e5daf76380045cf169acfdf261e25121b734440e554c0851e1dc2d83e9dbc281644f8c31dd89f8a21fa6ce6c3c47de0e1c05b5417428bf908c7c5813ad09628c6097b6a607d2ed3ac2f16dbb489631e18a7bd3094b03b0d7062923d2615dd94aa216a994dab98f9ad804f1a786e8c5d0a6c6f7cdd6eff760b7a403abcd37fa4cb1a5daac7c531f23fd3efc7ff566d7647157344c7ed9801234159e33e6e9b7a9fe28820ca0259403674c191ec394c394aa3c97e5f34627f017fd95e4de733f8528aea0577e41b9fd64ffcf1db74902b13c7b5946a48ed4b44747e699936decca39dad302b3dea60617b0d30cf22b6b1d230a4a11e493ae44bdcbc6644138e32ae2a296dfa035d6663b366df399768ff19500641bcd26d987766b9b134fda959661576306c47ba64d84f524f0be416860376e47b398b18b1fb161514ab3a1b67dd525912dc551cf60f168fb98cac36aa372a2ae48303c0b2f84a11f3e5031d36659197f1eb2542283f79f17ae44b34468e638353cf34c0c1812085b8f3f688628207c8a336c4e60f017031bb66a9cfd70af2b98a484d8c0e729882493b8d8424d1cf7da40d3d3ae4f38a70cb7d40ecc70e6e956d8613618e067447a6a526a112b612b6b320514c561a6d724f5d397fb20e10eecf9465e6f93e323a36a73acbac144f2baae1d3efa3b107f2571dd88495fd832ccb93fa507ef949e9fbdc1db7783345aeab3ca8fcd2554121a3961e3bf5170a62b53e30aa228d03d685b2ae820e3cbdca19bfe270f9547e379f26a1c25090bdfbf40c3cebd3747d5569aaf421128015ab65972ad2e4fd1a00999c6457c29b050fea276f951bae704b10cb6f5e781d15a5eb6680b30f598ed3da5b115ff1391e742160a22d83c13886a8d2928544f5c3674da0a2a3fdcf3b4a30c2ec5ecba6afc32fead2dab664d546642d02f50cc3ac9c644a0a7eafc80339f1c928ef2c5bae5363dd854ccde5e2bb42115499556c864c5514affdf0def348018d38d00f11bb191e087b3365b71c05b785b9d43012cc40bcca5d0cc432ee62a5645d3cb061f0442cd309b4a0148b246b1c41d9828b9e3596f655094271b34796fb1339f457933862baf4431a0f5ee5438224c10b1bdb76361a19d231b5d20738371723c7c17747da477968b29e93c7dca47a35c3a1a5a89ce80a20a5310455d12357b4c8c3bbf98aa4683ceb2b78b4caa00102566226be0bbf2d9be3b1efab0b1e4f06574488a2cc80c5ebf5b1f6ceaa701f817b5dea86bd2986998641adacb32eb414d3a9a06164a2c5b70f308520aed276adf8e8ca6ac377fada49f39935936a4566846a5d924588a9e3bbc8ca1ee197c3820f501ab723347de44c0a19ddc9f16ffc538c0db763f4b84d00636f7ab7f63e6cab0b7044cde0d62892214f8a8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
