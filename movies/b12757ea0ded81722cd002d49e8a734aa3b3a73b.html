<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4c832ee911eb61dec597f1e1e921b31c6650162ec94ec1730377a437cf9188a1f0b8b1ac4b3c3a8e9aef772aa8ee579e41c812087c128bce02a6c04890a04a3cdff4cd361afc7449e6ee6cbb48ba23d5a9a23f56a7a980f46fc5158708243b697dca70809e0b36d2925f8ea8d83533ff317747cae4ebc4318533fdea7e0fc83b764b098e3745a2ff1e6667eb145eee309ae16d580a6e1b4724ca2fe1ec91a38d4a07306e4dccce282576f3410c1ff2cc644f2aa8e794ad7384525b9fef34a7390ff093737f0bbead1fa394b462ca2e5f888b17ed5ead548ef090199b740dcbef05cb6cc5f68f09de349f8e7b059f36979fae8ba7f336e46bf9a5d2e67c6ffde87a47991272fe3f0d9c1f72d329f7c881ead309130221ee03a810cfd63b204f45c77f9edff3531d82c7630a3ccd023cd50e6a8311fadb08e7079c225ffa791fb137366423476e9068cfc15a6938c06d5a61c70fa4f596a26bf88fcaa09a0d142cec294d7ac6dac35fdd698efdbac1e0f78f9d5e7155bc36a1b380bb134866191eb84c5c3f5b8ad2fbe4845d04a8e53e553992d42c40b16ef785a32af52f84765a036e0beb99757952a24566d5710cbebbca1f1b0e42cfaf14ee7048910138fdafc8f5363bae3881c4133484a80911232339c4c635803fe6413b3be8ece81547664f4b9ecc5d9bad38cf984a456a6fe7b0d8f807b272ca44ffa72a6845282b715fca56c1925792508d48e345e4fec393562556b10895621e94a6e2f800d727cca1beaebbba97dd3aea54f23da975da0c716d954e5cdfc8fbe835ab00d1986b574484e7be0b61b971327683bdaebef63a78afa5cbd8500ad9ac789ff14a9cc1610f9151e2e496a0aac8ebe49b4d4ac605c5b1471116485f36d1782c21e52c47232e580a1cfde2a2eef97624421b5bb6309a35dfa40a2dd3d4336609237954f6e7e3fb86725f7294150334d6ab70b043942b11445a27ace4ab463d6a883aba32e60f6d7ca4b73632c2124479faed0f29a8c0d758a2364cd1d2e6014476b5f0f24bfee4afd482659376bd926badcc394b8df01765ea7c824266aca5b83ffecc3b65de8eb74fe6009f92849205625216b75f9cf9bcad848dcaa765473a4bf6d24c594582ad75a4aa6373deed0f7487e5f300be95e3fde6bf40dd2e255d36b88a285b010e795666d810e740d03427f7d646bff4c7edcbfc09aa2aa0599d93616c0c2ddd8150435a255c3056a310001dfa56166380a0443728f209a7a47411e61a7bcb4eff6332ea73a8d144cb09fdafaab4637e3e77ba099a434d6d4163ace28d92ac98748cef085c7f7566a0819965ff883c39f0d334ecae4d1e01093c182f9f793b25cce221361ba63c2c6edbded0cc42390e06cdf7fc1c6636ce6eb5628eb3d881438d31a0cbe5a16075ef2e0222ca6736ba1111145c545e2a087edff0785d8dfd56b1bf61d1df7a0804c19f67772a1c50049f95cbec51d403c8fd1e8f61b93480053ce21d1a42a801fa869327b36ee00a947be77cf57bf42317a1cf1c5d586e95f42da83b0ed98b110a4321a1e0be8648bd3f1b1b250d66097d882a3194994503f408cb9859580467b3f7fff894dc8fdf90f7378b8b294d79b5231a9192a7a8f4e9477787f4b194dcb07baafe4c345016ea81639779409babcf8292d134c26d94de21697c482ab74d887868cc87854c8245fd162673ac26c845a16b84d8e5091e71c2d907d479e1cc912097fbf7041f722a098484409c1ba52b6d23120a484e3a9aff3a6e1486eb008d3c321ba2c2fc020a6e0db904d2e07cffd29fea0d40d93d0fae4eed95f393f4ed27ea9e623814f578355216832d5370d77178e834b5e484a6803f28a440e4ce9bcc74fcd0ba554ec968dd149f54604bdf37ffc8223e9f4c209408b009bd689127682ea20959390282044d1c64f617599dd7400f98ff629094d879dd9b7938e30092a6c1547a0570a489d6ae4ea520be0004c5688581ecc037fa784d6fb749eeaa35242648f84c2d7766457209d1a77127410bcfe69c1d6debe429652dd54f969bae0f53508168e6fedcb18170637b92c2e94f55be7a63bc4287c732e30ed4afac4a606a71610ee1752c2e767f25759735e17da2aa8c3502aea1ccc15ffb8c6b0e37067ca0a6e7cf8ff8349f2b5a0063ed39d15c81cb064e754aba7c673cfb9309638d3864f2aa14339e6b7ee79db467ebc4142ee39ccffa6c3911055bff5c276691844658e4f0cdf28ab0f1e7ad4eee0f12532fa55ae5677d296192bd8acc65ec11a6927a7c31ac6e5149027dd1f234a7689d68e2a3d633b002965e1fdee51fa95513d1ab3cc02e4db79149666c69de8b161360da945b8c03fcd8a94e7d4569662256126f814827b008b682026a75a3388e8ca76cb1dfaf4939bb8f9d816cafa3f12ce0cc27a2ed1c201a6aaf767eb924ed58fe21e6dd6052b36e8c329765a317e2cd148ea7dbd459c72186fbcb40b5dcfeeb737822d2e754a8cf9fdca3caf745c846a1b382175f773393464546d3809c195a07304ae4c72134f38dd4f8cd35ace29895462d5b25cca86e28f90545459bf656da0f5e71eeb508c0ab164b5aa91d9b1d08a2094eb9fdf1d93991b5e3b3b01ea1382353bc1a6c62aa8c898ff527edcad2c79ca42c3edf8775f915e2d513b15416d2f65be80db0c1a2481d7e852365af2ba7124237600d3c888b3604f9e88050a55a58bdff61c44d044df28938248667a9ec517d93f26d2a407b5ae56cf11c82b13afea6357b88ed6313eb439a531b0fdcc2bd9110fe69d07013a611d0e35cf94ac6481a4127f8416b36007934f38ae4ec9dab94554ae0f4ad40d3e82e03e82bf526f70b294d6a307c4ef8ebdb2dccdee7fd1b2840cd2f6aebc3ac15084c7bb92e459fd4cb9869a7e517cc625addfa36e9510e57acb2be46c57eb5726a163e83cfe210298303602e892d29985d54a33b408944011bee45177a3f70e9faa3d84f07e103c3c748d27145b7464f260f8c7ed185831f229613479fc2e39130031720001579d3f75615b1b84d69d89d879c98ba33881d14d3fd6605582a2bb018d2671ab34df78f28cb7bede6e2d4d6fef42a89072869c0a44605cf9a6def35da464a454ea8247bf9639aa2101a04281056c7dad13dbb47b644321b9ae8cc80e91b6a4c9049fef352a3ef295d718f30691ede27b11f60c9ebc771e74c72a8925600cddd8e234c28b5e1fe70afa70e5cec307fa05b4f3a625c6d1a6fc5fe18c919f37220b39bc04398ae08f6d83e6db6f7197c328504d574d8a8a44afc33a3909ac6b962780fac202a59a03bef978ea388ebd14dd430c9f12438378bbc851c6b5bcd0a3e84cef8edff061064c28de0a075051644a9920b5ed2d2d796f5be3a1da687fd58337ba5f813daf2cf9cd0b6f7cfeca108d16c14e7cefa96e9ffa166d480af1e3562e668974172f7dd9ba90cd317a630d399d45e056a9b2baf536bd0b0560cbef103dc397ff80b37a8fab91d687cecc396082a35207d357e94a853c5c1003c8e8fda3b8ea08149bef06bcf8f4c5569bb799e382ebcc95ddfe2b12b8f8f43209108d80e75566f72251f11ed2fc2deb6ddd72e98c4853d58a3d2414f7387166ffdf8be45b4c834e5a34a88139fa800725d19c5e9321353e3b24c910b11b7ef638a580e411d9f86d024734c7d3049bffa3b819fe8bef9fafbafc7ead21e49f7a7d8d142f538e4953944bd22148fda988db70717b975882ebfdf329b8be68c8a0b98b07c6783085b9c28b7726b8670726d21ca214b58b3cf94313b69501ac0955b7ce923b8809fb6c543c67e73c8f68440e862f647d34efbbebd32043f55bfbc19d74875f6d1069355762dc00be5be918f5a5cd26e5527b841cf67bd051e83b378bf436b799cdc37d935ef750937f4d85c5fb0ae0a378581cd6c8fffe38e1552674ad6af47c0a8644ccc238b0c914c2768224eeb95c083e3841d43c8fc7566e40b63d00297c3628a842934f6a257a930921d0ea5a21e6b6135e70131a4b01bc24333cce16828de862681238c5021f39c68de9484ab087435a8f3b049913960b27f69ffc2a0b24a6ea4cd7ac3c37f02cc17a64bca7a19bb36c2f788e3fb7cf3fff44663a3d9fcf96adb44ac217b575aaa7f458773c3bac87f2dd92735ebbebc78b0d86f5a7003cb99258c08e6757fe83ef3828f80b6c958eee47c7bbc0bbf98ca51cab302ac82b1d2aa3309249085ac5cbba063d179a97110aba94410c258370d1a254a5ef9508ed85006db89fc9c85458e8c0d12d0d445c794c479eb42b0b7a3bccb8e843f4c9ffcbefee90653b8fca2b89d277c61b4eebe180d5d71260b50765099991e4fbcfbb8c6177526f114682460d5f2dde92ffbd42de9a3fb25bdfe3767e0909849528cfa82bfbf4365f4faad19f3ac8d2a5e17467248df0f044213f9b5ca2be0310105738463610fa7f950c4e1fb425cc847876025148f38463a02ee6c77248c0ae0e814ae546950c02aa43ff61f26945e009ecf9929f81189f35c1a18ade23f8e068724d199a3ab035a44ee776410c435872522a08fb54824f0c555b4bd4faeba4ef89a84910c396a6e4fee9ef706b4be3a4a5d0fcf5f4a018e7409e152b762e7e18395000c37c6e7cc21ed99d4fb4f770c6eca7594c91bc1b5b1cf4dd9b7cc68af7e935e4228c39cbb00796b1277b467a237ea66bede531b5b336a0d5b35abe22521599568e835f116b4b2d98765e0f1e2b068ac9c84132a18a3996d6bcfef510da2f7dcc34d0bf00fd4e987ec11636bc5b3fafc65c0743f190eb96fb7c57de29ff706fc7a189506790ab0cea4b48cbe303eb2087e372738c8df5ba14444fe1aa08a99b10bb48cee326cc66ff235cbaf1a33fad7c88d9d8b9defb8894b8505ebc85a643214001d309935ded9585d34eacc05666848695731af1a82a809f215085022a2a23c592a5c4839e79979f9ef99a462663a45c0252588c24cbf218b411030b571ac6c46f7980a9349242aaf683d2c55e7972fd193568dccef187f9db0ced5bd3f923ce4cd1ded2c27049080cf860ebd3d74fee14feacad5cd05c79986e224bea7db773f4e946cf730452a1ab00041739afa86c38a23ac0d3c2032c8d5d1579b2e2e97d3bfa5833398c48bd9e5dc774620344d856f56a3444127b672afd99a4d5a0130f946a06293e653bdbc5e1f5cda0faca1c0150bf28cc4838fdb0a827d86d3eb09750ba190a6dca1db0efcba5e153d257426035d3df98a71249b316177ddbbb82e2c42b0e58008f2d813acbd465f229fdc4e1d88ce61044144589981a972ecb746e8be74388f76b60997a915450a3371237ec320d92904403b3dbb4ba85f5b49666f6b07f5261d91fbf6ff438a216ce295e1326b89c71f8665444ef7eca47e2251a96a837c5aec4a10da76716fbccc1e9a6500d291f1c04c6a8a33dad2e538fad61fda254896a82075a380f423ecfe75c9a6aed61b159c78aaf7c20a2118af903c5bf77629d840e7eb674c3efd442dc18fb858306364e376739c81deafd31180a952b2eedc7ed5505fe85cfa1326cc9519709ce53e77223698c00613bc682435b4fb8aae04db59597dc39052b2bf4dca01f7bee02021a400ffab9428c947595745eac272910ab7db4fd9350051e89746402850ad8552b76837b5aa107712c83f907860531774fda124f19a436be02162786be77eec6c5b863ca8f1dcf9bebd80880e1473ce1be2cb2464209d5e477b82c007ac1fa4aa992342997040a6e4bca6a3a53ee861f60ac9f15ba97aade94bdd94591d7bb4d7350fbaf237b9d04c4e970c442c8b71cfda1218fd711fc9697c37d8dc6d5af3da11b2d699884709cfbd6578310f2ac83ed97b93fd7978c1a072d745d48f0e40fda3990ff1ecb026b42b42316e78e1d53246e502e32aa253d423170b2ea2faa44cdaab1d1830cc2a1706c088584f2426458f675e33ba527153c2af051a3a443ee94c2ff498c414c8857ea95acc3a59cf9b02902385f0c17bc8ad541406f510aac75f5766a8d76ac3b07fae3df4aeb6573f8c943b9ef1178043fb6407fa80700b51e30d1ea010aa7f086e1cbbefe81d82b4704e63094d463ed104768aa07d0553cf9d2a18063179a3b9398bd05ee3ec802e3ad7d8038a5cb659daaf88a011099e981024b09a5dd7fa07070c97e0521008a9da3054bb173a91feeffa821288468c739ca5fb47bc696bece34e5ac12fdbb8bd4501247b54d87e9fb76a927b77981ab377f4a76f6d54149bd02ab997208c5331b052d39bb2f9cbb611f36308b30196e511461917c2e1890b4e1a59c911d3f977e56c15c88b708f955e2a56b0fe833f8eea151dfc51726d0f2f2ec5f71b029aedc42e71a1babeb2b7dc63fc7ccffd2b42b0bfa222495b44f52f03b5393c99ba0f756da2c9a2a2c1341620cd8b89d0f5b246424a2f8a03b5f1d601592d50007f9e767040aecd142b6bfd29d876cec3112310639b11723a67f394cdb48b55158780276fe502a09f0e6b9c164a64a7645779ac16af12f023fda17118541df727019d289af96aa5c73848681b25dbf8b9116b9fca645e29db9544086e59acd3de62e595072913976caaa1c61c1c29ad7e77715493d007605f4a65185e329fff7cbf71cbd4890b763fb9c9a15879bdeeea2c33ea6cdff1c580e16f25fbf63f61480fc906f843f581642451041c720c67abd54a6f2da63ede7683802baba8b5924c3b1849150739a20437235d0eec2fa73f770a03bfa8ad6f0323cf674865d61b786ce12d4eff81afd29b1ed60b8aaab5a8ff043bc22539117b07a07089dc59da885d81276068a1cee47667403c63e4555b5792833c6486eb78fbd9ffc2354a177f5d4b86cddb01918fed90fe1dac2f34a3cda6445f0e1e60a060e35b6b461329fe32cf8ff85dff6d8ffd740a1e60cf7d1f0ae1558b4aa50f67c893730f9ba80ea23fd88ae372394773ab6a64345d0607d5ac369e9467bb82b70ea1fca06e8cb3c4bfa1491d215d39d8a44db680bbd75f5a2626474bc9931cc103bbbe14ea0c4c3781a3648173773b0f9d6b22b9a3be8e4682e82a734e8da25b5436d377391a175cd1993c08472d790c640696a4f67b4c6c4ab13cc0725266ef74fd85c8a98b19cb95ccddc187f4adb1c60067cf3c33c7760818d6cf322c93d31c7c158211a90a043b9b68a47e43e79a2c2405d27de5e7a40a8bc4dd6d4d673c8aa259b73dc9a8228e7cb183eef97b734756a2747fed76c90fd4293b39837f81a27020d18e9278247ed8c6b8591a8fd82742a313c60c819010bb1ccf2090c1fc4f1c659d3c5043cc1ca735eac6cb85dc1ee96379c483ebf83137f814f66407af867e7990a099f60ffba16f08d3ee3d2ba217a9263edbe91acd04e7b87f733ac9936198d666dd2defba399c3aab07cd0884b3c1597bd97bfe528a02692777e701f40d5e274fe87b9d73591b928f006726b101b466b65be87ede91d861f2ee38a20dd981ec16b3285cc217264fdb8df6ff46b5037b63ba663fb3094ab08344f9b12171b1c0394fff0ddd72fbb89a7a810a21b2da744db577ad3c61da2176e126a387eaf57373b4ebc4b47a0bd93558a7d5a5351af9915298aaab0062e37a1931da084b0802ee8b20d40673d3c1b9d8d7bdb23c6519f81cf0fcecdc0a34c0f7d5d8fde70ea06da2ff57b1ddafc8d4f3999ef8ae529905713c899a03c3bd5ebde4e8f99e2b773d7b6844c9512dba566362ef6272066aa0319eb1eceb409c36b41b70c48224a0cda66dbdbf58c5a28c2332d46703c0305c52d3d2ea15c3448797676e4c2cae1d4bfc95576cc6b3740449b6a59a043b3d5792cc950ead48a88ba3a8196cd1c7c0806412ae0114f42bf68cc4a0a867c9010aa38a20127df7a9a3e75deb4de46fd78582df6a196916474a00cdae5e042bfc1e038011dbdc213c8625890df5f274cc699e9a9af7e8dd0fd3cad0493f625982560e4b7a4d7851e899bab10a68868c3abbb65c01ea82a72dfa07e92395248bcd9fbb322909face0290207bcdcd5408662c92f6e097f8f45bf23d9675bdc7d14abd6e6ddbc148b070ba5a297af4c9a25178808519a4a55271d6102ca7d420393beda1afbbd26d7acab8529c0318a7ed9abee1c72ae8a790096cd013ce733a4694ac3cacd3d16df2de12c3c84ba4f4c378e175f37f05650a8885e994aaebab86507a8b7415a2f18ee1b34a4b00c7e738bdfde268259520b350489341655eb523f86d6856fd5148755ad959ac41d303a542962dee8043898a54e70680523fd181356eb3f44173062bcf12fb5fa8e7bcbc9fe3b8ed7878636b8f69388922c38152a2451c01437aba37c88b1bc2ce289b683e1475282c6cbf63ea28970331138232ee92872f4ff24065565e6b57e456619654af9323a76dd2abc48785af5294bf08fd1a3a5922884c032783d225c61b9335cbc5c927a93c038bb885421c78f327f11a2a14b9338bf77c9414666b5920f5b7fa1745336c67dc8afe011c7aa0d401fc632f7ab1ed34595ae9fd2d8075c591045923c213ac4a789e750953a512518ac157696290103753993a3fa4a8259ac202f4e21d6d9ed0b206a52d9b59892cfabea2b12ea7c10d9ce8f8f4dc5c1ce9974d97d1334845981366723711911098a06891c87bd855dd3baef790965f07d5af7bf6e7477b62ebf288e3d62a1b1912ad6807b98d41be4f0d2e6364c5d75a66c5cdd2bc004751adb6472e637d48afef879184ffe26a9fe650138362575d588453ad4376b636d10a26d9ec67caf848e8d9476154a30ff426ef328f403f72b34ad9a47eab8ba46ca7982837e8745943ca1aa3c94a1eddb87eb8c662ecd02f68f6fe35a13769ca0bf7ee79f50dd28488258900d2e465c8e633dd3eee0790040b2c3914747d2e038d5cfe456274fab73d81f0e21c9ac0901684a060ff00c59a4fdbabb9fa94665d6079b1de8116add5e4f03f6192820809cce7b63b4a76b725eba1025447c1433c876108394ab0d432695c37d40788522d283b23bebdb5d5048e525d9b1863a2f4a31997231bec3715f57ba1ef9f2dea68b7ab89f65be4413f086478a12b2de87a4a6ef0b4d451d9c7006d8bac5c491c6037bf16a2c3b3d3e5cf8d727ad72c9f5c3d0cd66bf97549136bc4e1f366fe4b4f7a7326abbce954ce0b51bded22e458b8da4c807693f643fca6298c4f8811d1c14e9e07d052482d27eb0e5445095e04835d928f12c1b6ae5fe82a7c95bee35ecf4f559749a914ec3fce25d05754556ae301c6b43dd96ab3c5bad6a6ec0b0054a767670d5a15104633acae223740f413f509f0023f897327c8356f726452aaa304046feff52e7c2d25adc9a87d6b8819104b35e131a34523a4ba5bedc629fb1d2d59538a0111e9b92dd78f8f1da1be03c7e2ec7549c465048a0ec69d5342fa9b29a84e8eb27e3050bd12e9e01d9f433560bfa317cd041c350882508b5e227549d443530f7a10d8559c6548e23257260fd01b3ef12ffd8778fcc619e68d728fd903492af21d10b6bbc0992514f700484cdc384fadafa2fa71f9a6342932999d6dd95da47e75d7de2712eed08564e501ec3737cb491853679066b384d088d3bd5d8f6cf7d0d84aeb9a3b1b37b921b3a24e55cf933f526fa15a24a67f376b6c2ba97248fb268ee62277576086076e10284a0ba6b58a11dc84b5f2463c391a0173e01bf303784dbdd560dfd2f3d7ab73a5657c5b6b297b6bb77348253db8dd44fbf199b0e7b9e30a8c904753576a13aea0a60a56262b4726c539f63e2b3bd7118e026dc87211bb8f725f71e5f604f6bc5eeca8cff49cc34fcb1867e26cc5fd3dc4095f2a4c78b0e6c75532446504d35bd2155ab091349bdcea4f0fb8533d74cf1da851629170ee1325bb35d32f89e9256ec0f2f3738c82ffbb580c07e6ad4436da7e8f20ade9c188767b92a24ca2090a385f1b4c8c9575931115abdbb6cf32964b833be288c8bee8a955c3859064b76fb6f2d6477cb3727facd891c6615978a00ac2c6da91f0ca98fbaf1006339c12dec80a33a78dd59aa33e7ac3e147376a882dc967a6075938fd53d1e49434acfc126a1f097aa7ecab4946e054adca154ec069f2a0c4291a665fb9bbfd7b58ff2d5d80544e0dc539f9c02ce8f5ee3249a452ee77f1d2feb9f1c1d90d01113fd3214d17f1c3f326f4e10bb58160daf61375d07b38918c45c620fe38f77af91f522346eb3e7c6529bfed9ded31697f81b13a6874d875ada50e2ed6619072c167b612559838c96c3659aa98317b3e6f141bb4f04555375d57501f663c3d420fd949e0b3dabb9707005faa8037331dc00cce97bfdc296a96b7a754bc056ce055cb1b5b5be1d9ed39464c9ff0e6d771d1e90a8bd2a86eb274984ce24ce6778605bfb99e086294f8f2e6fba4e6e0a7a79237afe435ed9c2962ef428d3b4dff70118212554ebbe36736dac8be548d3abd5b72d4b1b70b6ae6d56596615951176e0db2679da938c7e56b5808a7c4b2c317a3555995e0b46e0b1e1ed4e75b6b9424b226eb3693e4631f1d9dd34728f2d36ecbf740008b13b651d665462b14dedd15be601b98037cf07f1606e6379c767599193ff8ae7fed0703798ac4017d0c8e7f68dcf42c0467f3ec08e7a247349a1ab69a0071e0581127add964688d7976e0397fce34d4047ddc6d3c20991ef09dd780a7615c50432236ffc655dd68602692e5f571f6788a0ac4994c3bbbaefde3169e9355dceff14bcb3aac8974ff0f80b5b332b28b653ecd0034f2658993d4ad5a2f04f9a69f3a04f2dafb5520c2efeb281d0ac6a9ef60507cf7ea9d01b806d69563a205463c8d2113af7ceeef39be38fc00e830d949f6e8ac03c72f935aa1c0ce79f5cee0f111437eb1332df4d99805eb4835837f14a485eab4972703a27c3af0107174062230ac906716b2335831939d374119b94450d32291616e40493010e97fb9a3d0c45064d47e6fdab27fc7fc421b82fab95cc4859ad3a5c05588a6d39a8bdd175336dcf874eb3f37fcdb12e877ac622d46a07f9c7c4223378f2ad8dce3a92d4e6ce3d6e36f838dde1067f58e7f3cc193836932dcc18a2931cc8fa11d5b48e59dc4ae5b9fd1f4fd299ce581883f71384e8f348903fbdaa173333d1cc01a47244f0b7c0f8577dadcba7068fa2dedc24e4622a23d78f435b546761febc1f7dfcdd75a5f7e8538accc5fdd3283a0f7db2b1c7d9c0dfee3f724380aac69464a65def101954a539ccc8ccc775eb037dd3c9ffbc56703a3a5911e6d3423070ce641c218e3a88cc491cd175b02ad073eaeab9967727210d1a6bfa736b73f724cf4b328df0bd47631efd4a06abc92a7a37432c95288704154113ae2453724caada248873d0647dcd28d3d1acf1a2eb3f42d3557d57850baf752fd240dda6137824a2ea9b428bb0bc61ec251ae0cc974ed8639b95d71ae976ba9cf63612a106695a710dcba32a4651071eda1d05c23327365f1fe207a9c6a9dac1547f27891568a52f15c5b27bf2e08fb72b5901b5668e5f1acb3fb5776697ca2d685e18305cf7a35bc3ef75ebe68a9371a288fea59092c933cd6cc0f21d231684c5e83e99a540615e31cc8e5d9b3d4bb4a7ac9069ef06767ec7b0a6df4ca7576e897629dbfd1c8e5eb62e4dde983361b5a1b958363b03261b64cd8b99e55d2bb1ee5bbc11411c7c688109dc48b02b9604000e1c66ccbe6a07f01cc03bbe91ed0b913e0ba0c64902735998f63c1c726c5f79e1fdb2509ffed4368bf1b8858ad86a4d379ed7e4af49765807c1cb125a297e2af64a2ea15c3025842d81a37541a72209a1eec7fa742c24deddfed258cd8404a6427367c6b054e0f34fafccc0926e4b11c66dd4cbd0cf51ef4d6f8c2f494f6fd1208ff754d58803556d4d8b062784dd8b1ab8faf3f7fafc972d7b15363b59bcde0721cb7308f4ce2cf2b719b670cfad75261bbcfbed70b4a53f11ea86ef4c1e3a5af3c8e55dbb4cac2c9456194d2c7b4fca39fa44e9abe8efd99e6a729427db720a74d5fdfa989d417c0bdd59b657e7cc320115b8d3c72c389e4cf276651dcbcf8e6de8035f3221400412eaf1313eb70c14f4da937523035df7b4cfa281735393bc26a55698363514adc19a31ffe5b5691b2bfba3edb32c018ed854f163840bde367de399fb639ba03cb6a9fae49bf22d2b3caa14092f2a7444aebd4eaec7239577fbaf2f19f3373a4122d393bf9e2e8ebf2a7d5c751c791897533dfa354d638382d5d05a8770ce5eb0eb692b3b6dad9740c8c4cffcc322b24d80fb670856ec1ef3c0557cc82d70b6b4967564166932ca9aab9f067a2f072fdb813645d517b85119d868b0743f5579c934661e60e1f80b021791a497fcee04874b821ea87e721d31833f2e5cc35148744cf94f67ce4c9224d3ea41feaf6382171380f88bdbac0472a90074501e3975af7dcd41eee7d61bff95ca2b37c8efaff3749a3051a6a18247189a16278d144b3421231f7b8f09d40318f5f4b928a3d94e57af44c144f82b68f5e5bb618ac4bfbf03b7c9ab15a8928f8b5765eb7cb543b383fe06ad6b442d7671a5c03b1afc23f70216ebc8a954fb1c532025e6940a4f56968dd0791dd32bd63b7f4e31be5796c1a6ca334127f03806f39cd35b5940b66ed50cf5f377c585015d4cec2c33ea23081127561aadb331a9fb65e0e89f39ec0f2b7d9ce01797edb1ddd83e4717d8fa5c790d51613b4445cb23b9f746443cbcd0df0e2b9682fe4577cab28b3e9c93485f2a76e33f11e81b4de7fd5807664de45278e233abc00ae2ed6166ddb05d0cf43de7a971ff2fb712383ca06d84bf61991b49e6d7b6a9577e3bd004c6933a85bfa88a5691bdfa8f5283240a9104f4c1a5f268b586efc055e072ed4786fd3dc4935445370ab31cab4985f46c317f9cd22eb8c9b9322c56afa26d3fa4bbd0b83bb861c4f2bb3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
