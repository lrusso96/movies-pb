<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"391b1832605a66bea6dae7d01baec2d492cafc9c83e45735d5ed0ea311351ac9e191cddd3542e95e106e3754b4bc0fa7e52a8859cfff4146fe4b2e085f0bed53b5123437aa2f184a690765a936c0e531c5ee4417e98e1c73a9c93ad788894493ef15c706cfc512a7375312adfcc4655641c37af66a9c40c25bf5c622b038dbc3d27cab65f7a5bb42863a410724ff6f5721a111c960960d1a3ee3d4b5635b642d43713e8b642998fc91563c27a9c266adb0293936daacf71f4ac883c505bc4560d03da414b29ebade12e7ea239812f1e6ae262c642150308312ea317c88d22a5d9d24132bdb02505e7810070e479d66dad4dde974515fadc48758b65279223fc64e98dde80136f16f6bedf352f291a0ee03c4c0d10bf2b079510e9692afa9040e10c527491af2d0561863145a17f1737fc229da58bac2d86723d445daa8a5ed72f9c83c6c6a78fc5485e460b1ef7787ab4cc64eda8d9fc75239c33966e1dfdec7e521f0bacb9772ede004713bf2c5c910bedefb43a1dccbe0bca4b85bcb6efceec75a28cb8606462093b2f740c4dcaef42bc7a0d3aa4885278ac8ca8c37be804838816990c7d14cb6ab38f350aff03df1249b3128a19802f41200156a860ac0024e5aa4a2b76aa263ca5a83fe00348a7d957c26d8c2aba9ac4deb01e265db55ecc751b0fe244597050ff82d38dc59ffcdbc5206325c76d1e2eed103aa6e6df2335577ef0c06a5ace21c176132a68624f8a004884a137bca76f6ed3d853fc7312f9749a2a56a16ef21b90988c92def1734ece7216f4aee69a3bb05121874833d35bc4684e457f0e8f9a119c47d5acdfe33e4611504d60f48f0c5c5c5566214bb061bf428ce0b926e04e98f6fec4b482fafbb29cc4d32c2ca48b920cba3905be1605028b695d5b731844a89aa370a755d8fd30f39a824299cd70f761a44f0565a3b73f38d4b897138b2d783947688f093ca7689d644e0e629913f527e88d3faf9861cf5eca536acd2bc6c3468841540ce8c336896cc2103b54a8b0a77647af583a248ef85e68f1f63d81330a8ea5576abc8a55d8ef9fc301509d452207bab5ac8f6999ebbeee7e0230ae6b21d34d6bf209d746617728549a2fefd3075ee9375d25dd3701bcc51f173fd4318502e6478d30bf644963fb972a58fe918373ef59e700942f5e79238763ebcd080e822b85acfaf89ae3ae9f82f01dd2e8eaf892d77dea188b919763c5d43b5ea95fe8e8a702bc6d4ae1e7469fc2a9391c299050c3640cf439e1ea040edc18d90ba236334f100c4f35430d3f500b83b9c72c96f509e7959d49a7d49465890a21e6d33eaab7a3ed96f5513901e0a79181cf7017901d42416cd98319791721fb66f194762cb0a0c884dc8bbda5c0e2cdbc8d58aaca03077428041c39629303c85407626c43485028ce155a56946dc0bf05b34100f75a21c0858681eb3bd77471ff8d5575a3819d571eb3611250071b1183a3eb8cbac6505b0796b32458b4c9a322d099c8e2132a698cb912453957ad3d4e3abd27d3ff94e61e40c7c7298c851411980addeb82ba4556a71feaa948fb7f79fdf1ad384296959e4140db5109d773618e90067848b5d59a3cd5cce1cda3dd09edfb1e0684498ab1e2e9d78b11c909cef5ef1b95c72dc4c11f6edf2df363d38eb86bc9ff6892495f2df181c8141fd481d15e7ebfbf03d39b1cc8957554dde3e13c39064043f4139170e42308decd2dae58536b5131668088a02d7cb474969ee4da8c40ce104b916d5862e85cf29e23744b3bb034d9b3c0e04baa5346787cd76536c3a52ff58cf4ebf880f1f983f13ecc256b3c14729bc95a557c667aebbcf2d03d3baced29494ece301b26cfa8f4769d73ccc3a258a75a358b80611e1bd2152991a366504d9af0acdaa4b4142eb59caec725dc0149472a9aa641f4ac2fdfa7354bcef0594ad8ccfdf27f6f43f94d0837d69496a8b5d409bba34736caf23d536e9d5c929aaf00217fd1fdfc15b3c5604a83cb31eda41314fb6e03d048b5d4f031cbec79fb0a321e46c1ec60a5219530f35a597eb4648732eea581833d55f58d1ab28e1d62d43b25039e416ff6bb09d6c82085e9098aef3df9b0d1334e46ee430ba84c9ddec9fb6a12d38efac214ee97b0646d386fd5de18e434b16fc390c063d5cf790237f7740f3004bc4250bfdb7a57b7881f90c1a236ea2cf03da54dbd1e1423715e920280c5126cb5086575c4ed7593f41d0620648b5df46aa4c73f176870d4a2cd3f6504ddd43c7ff51a30beee76e0bfce04aae17129d49789f8b558162d8a23ef7cef2476dd70feb104e93eee044cfcba647124a7cc106e9306a7992d7496973a390e5c3dbf606eae5ea16ef293fec19c454fac52300b186c7d563c29c884b4ab1c8232e0f4b7adff57a543e0fbb0772e11189db85194f3c8397d3a6562223e1e2e40fd7f10720a7d73264e64c971e051c5e7b66fb671884867c35ecb2cdb36a191abbaf6b18d70b7438213d2b16a826c0eacd67c453c4d2e68dccac0a116599ec2b0f9c10a89568aa89d604f22d6a8fc7cdd90a93097442cf3bd8cba07298c4aa8284779cffeebf48fd15e13464e33b9ea28619b90ec621fa3ccb5991bc91f299e371d748d178dea1044aede5cd22c3654ce5ff947e9ff2652c2078d499a819e1506ba13288b82c94e4fe42ac1eef23e96b04006077280accd9373f3a252ef40ae5a21e03b5ff6ada0cd22fb6fe9f4f9694b9f919e9e9c68b75e744e1f37d4a9ee89343628d06895a6c76745455af829fece73e9eb393e5900ae6b809188a355050489d5f208e5cd735bea5e6cbe4cba45f4ed7c02f14facf9fa043b566b26065a64f76c28a2da22e43757898a5a02325a654ce3bc9261b9ce548bfecf046cf8732d71d1612dc9dc2d4be1a6d2f2ada76605871ec3bbb6bffca76147ba2cb3b6179dfdf9b203034a86c3585886a190cac5bf0d7b64c47962ab3083949bcb59465dee192b097dd88c20fba7210c86c7b714b44d03c37570d612117ade29f915b2f1dbe727ac3a84ab1752a67160020aec763093ecbc07d9f1e3a2cf1567b6105bd342197682bd65b734cdc119781cc3b80bf8f91233b87da4c14282d482e53798e8bdb048407e31fc19429e1bd287f5b7217903aba77dded0cba5b78861a4c7dfb0641cdbc72afd2ae973c8177c626b74ba72c60c4365764417784d0565f47a816c62016b86be171fe05a9482156723791f92d635c92d48dc7ad91d2a32ae53462f1131686fb02122f8538d605f357f09a2bd91a1c9f1b7e46cb79f8ce90ef84accde068f5902a29b5981ee8c4c5b3e1c37df54176d2ae5da669bd78af2b266c85e5c7d16f49ee152f98371387ccea3cb12461509d1e3d6338a50bda00be9e654cfdb1457d002d904deb54f11f3b7043fdd42e15bd239cb56f4ef6e4907e849f803ecfc2aca52c4a1b2deede26e98a00a5ddd5b7b69a49c4ce03e021d7f803bab24edf169db50df28ae7b51dca1f7035966d304848619b190b66bed4dd03b5e052c27df48d0d1b40ec301a42c1c9c083f9a999b165bfa51177c92f81f85cf80766b31da51b89c3a472bfec640027dd1b2d5e330a928ab0b6794b7726981447352c5256a758cb0181268508cd573096d4dd3b4f7fe00320cf835db342d5941b397f817e6ff2791287622d64ff97420aa067b38254ac5925e8a5dc5be76c541d62d48ba68360f64a8daa1e51451d2dffa7bda0982da1800d33733a2a2f3d5b018f2a92fdc3c8b8accef311ffce2c46fed1e1e7e27be623a0fcd8a02cf699b24be511aaba63770174f3d8c3795744859ded0475b7a9a2d212cb448afb9c6461e83507dc181f0272117b03bc0b40dc43bbce699210ada28bf94a84595fcd4dcd00d60f6e1e40da91f659a58de3a909c0ff9b2688d86e0c42770b0d34a41dbbf86b78d2ce6a69e56c63aec538e6ca3eff21cf6eb7389afeefd4aecc0aaab3ea7a2cd4096b64063fcf2bf9422268a729f843bcf18a02e0823c83a8fd76f7b3911573aac56e1c754a1087f359226d4016804a88b3d6dd7a14329032a1ded69d031b60ab08511374f6718ef0b83459f598287b4938351e7fd104a9205f5991556964ee841c779606ccd23ed2d1680107a183a09bd642f98bcbf68764d195ba922a2773585055d551565f1aac54d6982203611e64bd9678e356fe18551f52e97e4c6d814a5df7f209f407f8f3ff057850b0c8980a52824c64478664ccc7670ff52013f27e401f7c5a357f77ae0b39f7caf0d6ccbe96435e8df82abab5d39e5e0c4eac654985022b32937dd8b3cb385c891a4f1c472292c129562a75f563941c2b2b4e936df392316d76ca53016f6a9faa7a39401406f4b013ade101d5c4416e7ab931a5662319014332ea92e4698e81d1094339fed48d76b27956cf311c23ff349c866fb8505560f627477872c7a59874e878afeed1bc5a77217b18a9b94251937f90c23e81ed04e5960155a9976377437f15d456e0eeca394d6d2ee58827858c762b75519d7f7085830948c2022d465363f51ca4690ad3356ab957c6a25e7cee2bfef84328731c4c25f731fb7488af10db41df4832b35ac746e4bed9ca56c2ba9fb1700e6da350930ba3fc6490f765abdf0e4ceba9d8fa51ce82ef05108f365cdf274a37b73692daa164b14146cca824f0d4198a746345e56ebc91614a2e3dea3ddd647933d13f849d5a22c8ce5cdd1e043ed8be232caee03b488ae773a4214c36dec0ac59ab723f938570560cd3fd1af01a3eac7f505422f4d7eafa8317c059187d7b59c635c9f59276a76f3a0795c2534e3e9205e992db6259906c65bc4af65bce463f6f9b6cd26f19ea42e4667485d52b393b21f9ece090bfb379bb4fd759fc6e99a05121cdd86172efa61ca79a552b22212c111e4610433cffd993e8bdf0ad2d1b0b401f1e031d2837dfd7979126ff463a42b16a2ba372e10307e9fde336505524b774c3f09e8193076876c4c189cae843f26ea37de4e9373bb187827e2b9d98d995bb63bd5fbdca820a047377f7c221a06778052d0dbaf735698317d6c16983a60e238a1e90b0bf1bb5acdf1d30b510f3a6794b10a2eb55eda76b11b9828bdd446e2d27073e4d80e749f98c90013fce5d0600dcc417723fd7ff7a856c952b4a5f0cb547dbdcc39892042ec38db7351d7323140e65eab062ffc51a54088090d6776672a85da7d3be3bd9f3d320982e73f814ff07b6773b2fe0fe79e89fc173c31f90ff6a8ba8b8d4ef283d9b5b651fe3cfb7f0f75b64273ca7f93a1f23e8187752dabe393f43c757856d86cb4ec09c7a242b4e61a9c4c25f7e15ed293861796944818d9ee17adf6b2c443fc743d96e67c3472766f4d7dc5ee1cdb10808e6dfd5c96df6bfdf916bb937826b9f4b1979d5bd45b781fe6387ae9696fbe0ee57e761112f2fe39b03fd8d8bbe21265560192290dd2cbe10656b142aef2bfefc79e951737cb6acc37adfdf66b19934b52c782cccbe8b1ff29675093bc729b93aaf824892dbce186b51a648ef7a6bf3f0240ba515c796466e5b80d74e8e42b8eea0aa7bb63a35e3ef41d40761842f82cf0c8b5ac12a5ac2c476b7209edbc0aa503c0e31b713686adf4f07746e57b9cfe459a0e0f5cbc2439ff41b61b6223adc7ccbdc3619cdf890558b7ff54e4c6adf2c3530dd14e4f6d223ec0886e438fcea7a293b4f67ee685bf98b582b213d6aa7f32e826f96b156059e9031f1c29a1a94c72b22f203d95ac56e976b59a7ce3f9e125618c63a867de549831d69a723bfa9bb0f4f279020ea7c6d74e1f6cd692c0ffe8cf1ac538f81992340625843a2d9a66753df272cac2766a00eb6ab45a52c45c12430c4c72fe82793d4c41124fffe7f36e53956bedd424a624b3c20f9fa73fc82b7178e2989f0bb8bf0b75295f88e909fa96d0129fc8ca291753a49f447709cfd8dc3a7b144993d66633a67cd5edb59db24ffe1570559f16571c548c1d3e35e3bfe886da26fe8a9073879d0e917d706299bc926f172ac7d5d9f4b566b471a0f9b37d6a8f8ffe11b7e408051191fee0688808630647669b378fff1a09138eff27eccededd44e3e96863a97dad7fd94adb262fd2695c8c94c08da63aded40c9ad72553a21a593a975dcfdf378ce116a8aa9970427f87eec3f18547711997dd67181d8091bdee3eb7758ce8601e5aea2093d1708cb3598ecd15dfa11f75fba7592eec20adcc000f5897d2e87e070f0817db4a4581098da475f5c116f836cd08d930286a1c769e3bc72baad4cd950bb646ed52c4fbae7e410c2e88e2660ed64a82bae12b57d643e151e434010b0093cb7c5bebc759f0208ead231f4fedf21b7534dbc55a0dec49e581525fa02ddc4951b35103a37a1eb3fb1b03ff3100d22754557b9f77af311f74821173e2b90c449302ca264ff4cc23c131710ac1e13027c6d55f953d466389f426bffd3ae906c37d5949f277a8349bf6ec10da5018a823ba2b5b8493c6b580236513ecf4838bd9da851c8aab0ceadbfe6f1c58977bdaeb4d6b255f3a550554870348b31cabed8e91e86f3444b4769f45c1c63f6a1e11bb2ec7963be03433c66e15a6516f1168e7a052deae214235ac26eb7e6dd026471c16ab7b7a6efba07bb2c64e915081ebeb7cbd8b441435abd58d910051d5a78cce83baae629d8c0faa635d41abd2a092f057985a4478b723ce4708b69a8f70301f792be15f13dbb3742af7f9e76f4245bf0e4296ded40495a9a9c4166e70561f3be0d9d9d976b08d8b0a76abd24a3e6d56ad1b5722f48dcd0944fa58d6de643f2e6324b5e816cd781391fbfe7766e4f22ca240321abf4d3339a9ec13f4cf2393fdb8251ab5e1554116ab58ba45f4a328c2f5733f2ea1e751f1c3f2c148730e475e8b68053ee936a92f22c9b5abf67de54ce993054dfc8b270699fbcaf8cd2e599333e3575593a12726f413876bad3559b0fd848513797f9a253ef074f374373f5ac2391c21ae27859c69f8d4323981baf7c28fcf3e4232d02e9c36d11df8fabc952baccde4177147a0d8656a348e9c10208210b28ae15e2c9ee1ce0b64aa21aa7d924bda0325395c91ee91c4865ffaba6b53df5a17aadcf97bbe008301c10a5df45a96f853b04054cb730a4fbbc51f6274bf55e70ed193b9700b2ea612cca1c8579e757bb9f9d04adc8680f2833257ff95a2efc10a8cd76c78728e0bc8811792377d2484a30ea19d62678ce33fe7f9aee4249f8bf28945906e634c424791519f06eacb5d8c7546d5bc21ceaaea04568508baff46cdc4660b20fa5ff738b2337d13560d2326bfaead2251ab368869d7d8c5e7a8530f98067291bf68ae26e48860fef47af76e001b0f9692866865f06575fb31e1aaff77d8f64c8fd0a664203c93e683c895d2f33cf5bfa4001ac6180c4c6f726581180a00ecd66a6b96bdbdcd13fa5bcf49e3d6fa6d777af2e0a504592106caaecccbf8027a4ece82cf36c369f92320c24e21573e80efd15f48cc00c3b264e199a215266fed76020cad424c2c8407d48f98905a5ccf5f95b0fc74c4eca1cce0fbfb7113391783459664d6b866b3dad398379824a472702a4e22ad69fdccc2e21b02ce86511d51da6a870110a2a66940781347784670c1c6b9b506f58453a9c79950778b6eaf9d9933615b3df3743d07f9e46397338762b938fa414f98a4f6734165dd0d7e4ae6f6b6e6ed86f9c9744cd5fb0d729a5665e105c0565518b4be5223c623eeb8545dd59c5bd18c13e0de20a2e175a33d8218c03b367f00815323bb61ba6c8189606af1f21d4321a8d419b15b32bc1867f8b8ff806e9c031e9b7f776de7cf0be94cbb2cb0a8472e324bbdc36affcee7c1d8d5d8aac0bbcf6db25a4ae08aef6ee1a44f1cc744289dc03e95a74758895e4e4358b869a0018ee7ecdf2e197ced58407907d8b748fc05c48fc9653a3979c062d5d005edd9341729f400f340823b7879a8ab32d9e0cfdd746e327a11a8e78d28bce49908146f153459cbed5ddda43281177463659fcae10ce14e313eddd37302af9d27134d6dd120984dc564c5f17b72f47b26d46e955a16d7d38d7b109db403841d3be166b6b2d640a8671843849909239dec977423aaed0c3ba99cd540283d17b0efc5497a4ac9b6d990030e3b9d3bb4ad5236f85e33a57f04d256a0d8284f0ecadf04164af3597c32a580abe63286ebff2b29e23f04f64192bc78fdcce52ba4061343f8c6ec459b9656dba7741b77d66d9ddabf0e3ba4e9339a882dd00b2642b784ae4d136f799aea8532c923fdbfd43460458838b44bd3a9c72f4df92005abc9774b723f91b4a941d61fc54c6ab3ca953c8e680010786592515ca641c0a9dec9babb99e58e96b9b74a2a9fca715336bf3185c6c47adef0e7517cbb1f97bc0a4aae7063ec8c9fe18c3ef875c6ce61d9b03d187f1c7332439d8225d501e4387553c40fe89a05af835eba26720de31a1387c0cf4a58d67d5f421bc3f9ab71baee7e0d79137b56b5f38a4630c318cc234cfb04e272a1022a7bb325e97e314a6dc0f4849034e49afdd2e4c0dc37b0cbeba25f0f1c762c3597ac127f6059bfe506d81609cc00ab21efdc25f0c7561e81b4672900ac4d26e826daf669529cbf2e4aa839220a1827165b8c953e74b4635e527d0daeafba63c99962f81eb6feaa5f691be122ad59a838384b0b1120e5d53b17c323be4e4e3409f954244cc6ca080fe6708b64bc2a5a6e1a2091a1fb5484d17309227ebbc95e7c228b14082848d2c6b7f864dd74da66df1fcc1bd18dce4344b92407a56f510ddc33155a76f6659603d4c21474df1a1133e019db35498ae1576c21ed15bb05f94001d1b081b7994c73b54a3b8ecfd20384d72afe16dde4b3154ad4a475a45833efad97f2a9d77782c39553f20e4a142124f6c5d719e17e59a42c76b9968ab97e04869044a5acf06420ea0b0073c87a0e55147e81b091c202e8d81fb941d213fe2c19897de7fdf9801fcf03a964d39a63a9aafa1509ac6fc41423e5a54e3f95398a260011560bcba8fbe0a775519cdcb9de41d3dc3fbeda80bb2860fe7ae6acd94bea74dfec886ac2bc6e459b81bd403dd030a65bf8ea7691aa3a020db44d44f3b9617579bb1975cf890bafa54f6bf55fe6d95a8b51c0e39994b67bed479d1da9f618c7dd7acc20c6227f4e129176501897633dbd4732ec1ce02570699aaa78b6b170ccd568f1adf1b280ff733b00ee0d03e4d284ae0ffb81a9c9060878f514660587a96b40e75e112e2c785c403d806cad279eab2b6a458e465363e5ae62b4995e7dac488c6c70140b52b6412726b3a5d53072b33dc4030c7754c7622a3caef84fe263266b0c13c5b3c2e529644d7646e808f196a43e93c2a6313ff26846e38d2c637c43dc8cbf06032795a9644049ec9ae77df157636c6809c39026992be8fcab4a0406a5b3d0e49f7025f6067fe6c9fd2c130f366bbed369dea03caea9a23a171fe929cd65f24f936374dd72e14f28102cb9037b4989501d6ec0640a3c51f7c577d1a14b32e7e731593058f038b339c29c7f09e5ad820d158a359cc360baaf02437232fab42b5e749d07e07577f2f987cc1a2fa8771c76ce6bef3de946431ccd42bb5824d53a46db233f42a24f771605f29f1c3c2cf1ce17856a6417ab9136a3179abcf9d6cbf1d67192de87c900f3f61ec191087e0a61925d1d643cc41c41813b9546f5c842e7dd004b690a1f9792d11124cb6755fcbfd06cfa189c78c7282f9cc6dc2397c983f06d8f9b44b5d76026f369f44e1a2958df0d7c1adc83af386df4bbb41eb56fd903d77076edd97d98825645e9b1a0abf896c44648c071f8ea16ab8f44b9f3a8ac448b03b4fc747f0cd1b3f95b6abf300b25772ccf11e60d0547e1b9eed760107dcff87339440b27f72daebb187764e42c9abd3b61ef06863c491c5a80b478a69edd6620287b99f7b67ce0a699ce355b82eca165b0d899d85fdf56b0e5c94394af0d78f5da76aabfd308cb5dc4e59bc36009652214ab9d1898962f8a8f9a80f6375312244b4603bef898ddaf9a48272ad41f69245bf596c7622605b8a5bde1d4ea366bb119a952fe1537790e3b479a1c266e6bddf635f044cc8b6a2ff8bbf61932cb972ef3abedeafa65effb0351b55fcd727932bd4af235c4e1f9e7894ff0cc8bb4161fdd071e67ca186d7affb2784fc0169345be4a20ca6846882091ac6465ef884f6c3801f6a07be25e0f6d8451d0c7a5979537cb65699f7a1c221d9a9d8913e8293e5c3c3955fa79660dc2470d5757f45f8dc584bc522423027786a4115fc299b9b8a7aacd6428db456e824ec2714804f8f8be3370aa567195c4250c9b33185c1dfc01c010c3ca67320dc49a04de27fdd45924daf63bc8687d8441168bc49c744f90c7601694a7af5d1123c0e962528da2799a18c3c73c33439516305f57bb49ca2c69ebf71d473b83d96cba4289e90349942e17896011807bdede133478a8524e1f7528d7a4f63cedf1bddd13af933cb230eb7bef9faec34661c7e8aed49ddba16868a8a21a8e7f5e295aa30e8543dd982f52c08a66cff1580c178dadfc4788d664de0f284655a2aba2ead4f8cc5fe954d1b730e558b9c867be822f92dc121a86a4e06edf7efc12f00e8feffe9a289d0c966ae860bc057137a30a2cb11177e9ac9f79ad3149e87dce2036577944898ee0c28ec703f17980a553045ddb560621700ab927766b2570e1c3364f7249406a83a2f6879c809c1de9a54a20beaaad8b56eca0922fd9aaf0805dbd8140d307116dbcc4da18fcce90bd5ceaa8448c97466cdc5710abb4c09a089e12bcfadfa392abb0407aace57cc7b57d186c2f34e32869f0b10c063860f1589faec1983df6b7bf5d7c689644a16542512f0e2f259be200bd321f90269089f092a601749b8de945d5146923900bcabd008698961c94f7decbe1508253458fb0cc8f3c5615e0a3ab4393d929bb9abd5a5b023f8d774c12f160e68783d30a00e23db75b12f68cc35de1184203ad056ccafa7fb725052b0269e10ad213fac9bb4d66d18b3859329674190cd1c98680aa84d68f11f91559e323ef1c967d480f7752d9b275dacee3c8615b87d4d1bdbd0848d49b7cb652f12b32218972ce0246cb79ed4c8ec90eeb8e84fe0d1562f791759e800dbd6d19993e281aa4b0e2769d9b824af99801a089ba657689e25c5e83563dff01ef2fbaf9e6a6710ade63374aaa9b20ce708991be4d15d57eaa502ba63bbb80e7580efe7b96cd3ccc0aa4f60913829aba3839ee6ececaf513011f1a1f2334e372715da783a378b283f9aee1466c55d76ceff980d8c2d4ca8d3401ab915ce2307bd8497a4588b4468751ab63268a17fead81de21b1773e92a9ce37c50ec7eff13dc3f57896f0067ab989bcaa814b70142083af46876ffebc45596802c282f2f8a2488d099d3d32551d5bd532fdef27809a14c14544dd85983b0f99aa2aba97ba5d5efc5bf442acaf12e98fe9c1f85c797ff099605287a18aeb7fd17778a50d0194e37669e604102bf5f0d855cefd8ad31071a6162862cbfddc310fa65a3064eae136b6ef50344c80736dbc3e8b4298cae58bb2b2147e5cd2ea8cc784c20bbe2e00c36e2360f811f842d4c3ea498a26221b541531929a6d087f0cb4841af4353cd0562fae95a21ea69c53bdd90f24c5789017b5456a747f59a553dab8596264c86de5dc5d87126e6d40f19f0cb569b6a1abc502232aa5e372c6cb5ed0a4335b9e3a598accbaeab7036862c4d6aa42e7d83b5ffb346ae5fbf0515ab808405e7153906f814e160c39afd8e24a401850e594034c1060c89230d27a63d6695d5378306c954783136db1fff14273ad56a7e5fb109cb8fd1bb2f2704cbd63af017e0bc388a685650e9e20fd2edc551a165ee5b4daf13f28daf34c14c327e1f395d04b6d69edc9e3ef790dec2f89f0d22e5c1179a23168bd275da20c6492263b17a4e12fa6819d103a12d40bc5d299131a7309f104318d7a73fcc87a0d48cfd2dd061c72fe0a2d1612cda2e03cf690949589a30d1597af693cb381359d12163d739e2bb407fb9759b92a20905b6a2986fe43b73b4bebba0389b84da053a97938a6e571ff1028fb389e67d085b86e80f5dba7a752fff3089322e60e79c854f1d2e0126d0f710afb1e43db4cf6fe99fadd539d5cad2d8a9cbd4561e55da0042aeb57b3fa2510a0a7462911404fa7e22d23ae95b07ffe61aa076c53a83cd77bd430e8e677f0d437f067d65815b9f03718700832039a358b04b1a94cdc543a145f533b55c5261cb0437d106e4161a60b131ce4697eecc87cd313f4a6056bd5b09fa43c1d0c0a4b62a4afda20181b6dbdb63661bf1768555408379f09013a3e0fcab48522780a2af7917eece7477e325105f6e3f7f94daac7c38b9f61a3ad78f484f99cbd79a7eedcf8af64c105abb4725a8d0a761afef4152b2d1122cb2c8377c7bea926e11ff601606d27b836c7541fdee1bafadf3aed7e60bb5c84d0c4e4ee9cf4181ec0e8ecec1eeca5235fb100ef079c1a3fffdf677191be1f5a649f5ae5797a9100d8332f638a97397d7e3722a1b1cbabea711abbe97e0a8a1d9e6d3a4cfbcee2d64d99f777423035b4322cf5b8059569d1f8e6bc9329d011a9f4a70b04a379aa7140f6731f19afaf562786793982acc1e470bf302e5082de8f62544496202e24849a5959e2118b50e0d082bf2117e4d96c23be098a44ad0d1d1401d28e6dc1c151f4c3574eb72f15ed1297bc95cacc06927f803ea11a229b460702c8072adfceeac9dfff9fd617983007dc45ca7bbc1a06a17527d0864bbdb835b0e69296edb468540867ab904f6f49715364a867b899f988f5df79956fa8d054848c06d9045f8a4a7410e1b54e5e70d3e69333fddfd6607e0cf337209787550b51c33f112feb3169e8854b4cfcbdaea4bdb22e06dd996a87172662087a0b624bf769d04a34c3117","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
