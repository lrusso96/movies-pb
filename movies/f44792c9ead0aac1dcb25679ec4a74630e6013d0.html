<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5862e955a4d70214b39cc3a9faeef4a8cc46c4066d48a277b9686e642b5885b0f2028198013b75b6ecf94a2478cbf4fabef522a0c6b2835232f2874ae8d83a769a5fea66a3dbbfa8673184ea1e85923a9fba0ca20a2465cb3a2378053cab61314be807263e066f9daaede452f15005e37db13c54afcaeb7f43bb7ec8bc14f21c0ad707ca685957eb5c8a9aba1e614bab1e6764cc1846133934ca59a51f8bc2e71035e25ec122eead8b91ebc9766ece2b04fddcac1f17b50b4ded95d44ece4ee1b4f00b5fccfcb457e4e17245a3c2996b0af99b5fe1b678cfdc39c6e77efd899b3e1ff4ad29aa701d92c78bc64749d7c8ba018486bb5171e2213e1a9e3907bc3c415ecbf9f7b85a76c45bceef42319d098f01b0ae1305c66c8c3653a5c7cfc252ae37aca887687af53b358d35ca49780f9069ea634435a11cd7e33b982ca28b42a5f2c4d16ebb5dd2e7182657deb43fa11bc4e3daf7f236ca3b4cdbd361e4b76c3d3450679a3a466988ba34cedad16f887f1363d9800139d102529538d5bc719bb6a50eb7ba50c4787e50757ea201acac5f425cee5de665c3133b553f5bf0d34a99ca83cbbdc6b38157b3eddb122bd439367bd3948419bbe64ae6f0176b512efa0c6527dbe5c3a7d8114b02a7f163b707bd6edee72ea964a23a01b46cda78a318f1c4d96435be278082b50cbf937a882e9fa29472d18fb8dd26d9f873a1f0f7802c34456c1adfdfb6e28c1ef8a5a9283c0c140047ce34db8b0f9a28db1373a8ff5d59a2522ed24677a1d21273c24bc208bdd32a3209fb6f4fce46f85dcd2c75e99d46728d8bd2c5a6b5ed9d7f6ca6295a33b007266b1ee2c3bad20fb07aec0579ebf5ba77e8f10eda104be72bb8f44c577b5ba2cdeb8610832ee1feeeb3ccc64e297f1c61b0c98f8f590790967f16cb1e2f5bb62a65496683c77bc77c8202a88dbe81276c852cdc9d1419816899472faa0ea6202259985795a4a3f808496139595dc96a6368b2c252a597cae8d8a6fe771e5f2362c9524585f0f6e0f7afcf4aba0a9fef3d773e99c03e994124451b3f200d148adaa35d04d5b375a3f39c73a7ba93476a975e38684c315f9a3f59b979628f8e20874c4c0165f0cb31306c23ef68cac5c13263befc4638c6f3c28f5222b560151153b42d169b506cab53f56a675f8657228d115f26851ace1f4e166d6cca9c2d8723c698c00e3c4c10f5cd7257d9b39276af3728cfc3bb673ea6600aaef878d07c080c13be9caa782ae155a19b17cab38b1e1cb0f184572e1eaa51a97c522aef095ec239204fdba89559066b628a1b72e518310f84ea89a69ad0aa975ce94ee51e7a957b18b22a872defde0014ccc775708d9b1bdd25d43ff8052f7c13fec7b9bfdda1bdebcf29030c354d5e53540e26b36fa43cdf68ebe620e0de428b6051dae79d3162d084c5853fb9858110e027ed17dc61eddb5757b0f4f875e5ab0dfc4de62510431812826d756d28b184315061dc3da1bdbbb331016e1f0a27e0538e2a73c7035d3bfd0496286515f179f189b4f4a69f7e315a35d3b5fa0e2ee615b5c7e9565a2637afd93621a5a0e52a7d5908608c55a6fe4b72df55a3d55459c942d02bc3285a2d70a165c3bb470437f284356c05d0f774b083128c85319b2f1b874b220887e15c69fc5b14404e64c2e7f04e1318626b6cdb2d75ed70e782538e3c77ec690bf37f66d6abd75a0c580c9f953a9a3029bf06a5db036d74539e3d62cc1e62567b90ba7bd2d10fc2b7c8f2a37643f84f3e76aaf56ccb2bcf069c4bf3e3232c3e1d9071d617c48390a10f99ade86e7fef0a32d8286d6cae38d20522f07f36adccd1e88639428930e5cb6982d8c8a59465363f3f2efa2d21e140e2d4b4302fd02cb42b44280d899600fad98d717e56e1d5440b221b31e2bed472510c3bef52adf0279dcd5b4876baf373c62e568f1574135635a5412177135e95404b0e2a680889558863c40ea55238763644a89926cf027b2dad200ff7fb21583b60a860279e81baa855600993f80222f951cfaaa4163ec0a1d5a701178309810677296d7340e585b9eb4b701d94d8f329c4f59e39c1d2669eed8798d2704a9869a5e7d57d2ce483585e751a524a2e4a86cbb33f4c89bae8cf9154d80914bfaa837bea7e6b5ca7c0cfadfafa80432c3545b9ee3b0e0f6b5525eac90a7785bb557e58ea4ccccb4725018238d7ea4a5fc09a144bf2ba332dcb99303e114b6205e5f7a896a27b327e9f6ca5cad2b424d9703913ec2bd3c29b006abeb0b1fa6c33cb7c5f49fb967a131e3f5b1ffa5b0715693fa5f754f218bbc34f262779caeabe2255b31f79a89f4490045a0dff4294a9b6facf57db8df6671832356c8d5bad0916518ba0d111ae2a73254a09eb485d4d42e947aeeaa9c665e17e56516bbe294b274cfe5c1f077c42f0b308ed6431470cf0fcb61b6398969ec6215a2e2b79ee373e1e362fd553666b31f7595ac7d33cdd1dc06b38d1c6bc8d40f13150cc242a511343bd5efa0f5664ed089e5e4b453f2071ae3511a6e75811e4cd4d9b520d5ae8ab676e3cc4d547eb87359df8bf8b3396c7d72c14179ce9d0aa332980dcac58b66ed8e1191158056fe4cc97abf41f4a3e1536dec807b20baf59da51a94db483f811d5dc55b63877e10ba0a4581f9fc833a2d4294942b2a58f6342f9442b79f044d69def25fcf2297b98e01a56018c230d79e470d9690b0865d388272ccc600d2dbeb2c9ab69d2f4657a365a9a59f5269e3fa1c03187c435190afd4d43e6fae8351d0e4db0eea66027999529354e9056556395ee8748db3c9cd6e2510d4351f85ff46dd48401278df569620a12d1ae5be744d7c60c938fcaf860d5531ce600be05a164c1eec720d6b17130fc1a207fe6d61dd7a036f24443f1334da9a082278c9b18980cb36f5241e44c9ab84a32239caad5684411163ef0326ec1e587cb6fdef7005f970bc07c39ca272de68c8f865ffc8335fd8a4f3463899833b9522c81cd5bbac60e037df7e9b56d0b2f6508043d4ccd211d7d6b929766b166137971266460593b4a29572b1c4f4a3dd059fd4f8ff059094035ad872fa876c374b19b680a9c2be3ccedcf13e0c2f69c685d53f3402e20206b99cff38ce97a5c9666cb68411f2f6b30a2d01d5d861066d5f922309080c04298c79f9a0133f64d83213731c0a1cc2d1da042e1a31a0c929dede7212d52cd88d717480f607c9daf50fc8d2086887849e0c6f01a4bb4ff1b634213d0564583e678bb12e8ac92d106b81e8b5c21a1d559d0d57c271522eae47e40e4f22c3d27eb2d2b7f5711b0cd6db6eb254720c234bd6bec1fa2603870ef16d4d6cb5ba6cd0e9f50c7cdb6f121fb244adbd6d1a1b37209072886188d223b66dda5c514224f957a1be0b7d5b527f2399e23e64339e92d36419715cc9eca5df7533ee038e03972275cf2e51dd975893c47fc0d5f5f29e17f337fc63645578c663f8024b1a68a862f3c77aff191cfa3fe46dd37be065396bf396128493354321b6cb52dfa705b473cb1d7a59564b02c4299db7a6a0df95ce59a94c23a154c230ff4c1142f90bfdeb92a4de2c9de6c87f93fa64fd53f6e3bca15210f19d8f73c5afd27c92dcbd50933110e7a8fdaf8564821de65a4a49972c0a43f544bbe99d009f47bd1c760452ab28536dd661538c1091aa650ab59e185fd478a6f77b70bad0d3ea1467be4f3db6f868eba739eb66299ac764e2364c0a984559be5acc7a1d5b6f462a3b6699fff89708bc0250f99560cc306e11389f2d407c58eb1393503d7ac6022ed134b7e9b8a65b7451fdfd4bbc0fff6e46dcdf652433e32a945a94868bff0ec6a2dc49deccdc43fafb60fe875ed6893bea6ba681782d5831aaf6712f10a342496fcbc8d1e1e560cee439db311f4dca5860a44a899ef3703e27b08df4b9031c7d8cba1e9a9245772af449e04de2f37e8ed1281e228205654c6e9bc4bcfac69602eafd0713ad964a905ce5eea9f0769b9ef3c4ed053a5f602198e0556e7e8668271d4a9c10ea512389780748500474527b1a1df3b1278f8b67c93703c29811d4dc3ee29b15765163a383cb9107ffcec966bd64c5e9fa776a2039f1a64ae5b240734a63f78a152a1ea482ea907bd33898930a29594ff919d22075275aff6805ef084159ef11e6adf0aa1a2c1f3d6a5537de8106a6f205c58e3bdc19208c3a7b3abbcea16b48e850838452179083d4d2da26bef13ceacac209dbdea85c7d48b697d448d7571c6279e4c2a33dd21a19b2e97844da9f9ae0965bd9d976d2708a60d5a1f7b78c81fe5a54a3bb698d8b5d37b48e4d7fab2813fd03ed4b488b09e8d8d61cb2f9c8ea83fda06a3a73406f8d096e3a3928f6fe6a3f5d14c0583efae81109a8047f5bfa72580bbb9f2e4b78e546cc17a7e4f4a44c6a9fb5674d85390434962b9332dc5d305652277fd3d02008a00486f02ebb5bfcb655ad63271400fd2c38c5a0031f1de3951912f5be635aac9a1efb28fb2f62e5daadb2dd61908073502f8e056dc130f66781c36ad32c67b98ace71e56b5ff841f37ca2a9184d7130c2258837ca0ef9d9dd3c649c65af6a523cf3ea28f47575074ba6ca680ee1f5f09fc98b20b22a54260a365dd23bd181f3c83423797cf7430e9a7376b7a5f26afca3a1714ccf3afd2e4f294af28f59f09418b9bbaed2b117d82e3605819440f5aa87343348d713d53a2d81a0e195febc852f1b91da87451df12dfd3296414aba05a6f3d2fee94efd3eeaceac3d06b609a1e17db02a80bcb821d2efe5700dc3c0564cf712a8c3bb4d513fa12e6ca484256828b16e4d010cfce75c7c2749ecb8dffda5ce004016211515ed490a8118d48a758dd8399b0747b5b4c4711c7a981583564eda0fd1cf09071f280d81e02002d02118b8413837cdd3d77b8aa958b31b78f6ad09bd402ccd545f7630a4af23c406de463faab60b843e34d94df095910ad2599d656a3891ee797dcfa68e4c80012b0de8d2820d40a9c3d888ba079d2d68946ed7032b7d6ba606c0ee5f93a5ef686440ceb66355c6d7f67dfea7c00fbf7af5de9a2241b9c9eacefeab1e490c6119e4e9225c8c47c644bb016a43bba5f977f175908980fe429301a55e0cba77c2045da0c8dbfe04e5386c156e3e7b68fec0c07d6cc4a5565f6cc024376ec522a72ed70aed47e1aa35895a707460a82c1d85df777745502f9adc8bd84fc2233d529448ea625d7063dd01d91249798c3212635d5e01ce9e39995343567955b72b42b9c327f2bc0da3d0271a88f07a760f434c153a98f569a3bb575df51ddada363c73dfa6f78068af630c5cf297baa4079f2d28f3e7e36fd36aed4829ef6ef4e767b7374ef49ace47337d8b4c4bddbfa36e60a4131807ce59a2a8b29ee9b7bfc150b5f8e99b189f41eef3cb3f792b91cc60e4f01ce391f5b6b1f6a73d387f0fe62d808d164a190cea2d54dcfbaf74cfb2698d2be69c0f17aaf888ee34e98daf0a824a49aa620a1a886234bd6cca212dbe04ef036a3b2210a62ef440b868ec0b2142cf06f6ecf858e8a31984c27e923f12835846a70731de46e526bb75f9da40da6402164fd9929b635bc944799cff9c77ec4ce16dd2670ebd4679d3d144b3c31f4804316fab5dcc711c82047e11fddf431ae0836ec167baefe4217cedb7beefecf2ec19e651e94b0c300c8f9889cd1b8003eadff7ac72f18ceb7eccaa293a974496ed229ce6e79f4b9a05bcaac98dcde04e7031e1454936548444727bcb87f9bbad4aec3acea8237e7ca6225d1983501103554c422b93500b43f5b307255712fb5c4cc69a75d2108084e42f549e53c66655a65801de77935087ce989da2d57317c84fa0fdca07a1c9a68a0daca24a6b71414581bfb6420836f90d962bd332f125c6d2b2f950447a1f854088802517dafd6a9bebc7b23879bb19b811a858e853e0cb08bdf3699f646435762d5ccd7df6bbc1f8626c6627d27a5f6904919f9d3c734295054ce9d3a9d6de33f167f078b46d581124fd69120d274eb78f38ffcebca73bedc490a7e1848fba9341caa38442b53210f151049110b8045c126f3d56d730fa06c921f2c94718fa6cfda7e58807554aeba6f6ce615411d426b67cc0b031e596ee19ea65847285b3a8309cfc8264bb737d7076310de7c3452e519b6ee5f46285486b2823d3c7414d628525f1df2cad1b6d332b3d278fa34c7211ff87b7bc3f7679a73c6829687c9b6db6a2f4384488136b6c18d0e3a13935b1a8023beefc44b76263fb43526db2dfca272753b81dcca29e9a1dc9e45604307d2177c4648653bb63ceeca05ac8d1a73c46aa1c6f570211c163024a1526fa81cc79a92b35e0d121fa02339111476dd23ce61398f0fabc16afe5793882efec46b48d650295f53adc059bde0ab11993c946f58e347414671b16af742283ef4cebc108c61b064103a4ccc2a7e3cbfef1076c51193224a05c1a6e9497dfec7776bb5c6ec6318c42d2fef0a05ee835cccbfffc3c9756c960757c600bfde2a92be7f46927b7a49db20cce78d2e8336f5b279da18f4d83e3a1705faad4fd154e6fa93df1c32f0db7f3969eede1f9d13a26c7fa7bdfba6fae4fb6899d7d8d36bb2e55e7eab9d700d169a9f064a44013c0d692d1e70acbe039866e9f3fdfa2d6f2565a49e501cc7eb02edf40218a52e58b9365dbfb5ffd0a95290a60fe4d0730e438ba437032fff67ddb36b00da439e938d89cd71a8ec1e4da5817b4e5b78946abefadb450fabbfc2e6ceb6e83c08e8e3c57948962ec4c51fbbb1bbf6485d5ccb99b6c3616158a8676e49808a6009f9ff94c815d9871d477d86a2a3edfa4d1ce68792ca2f08af3904a5c29fb9997f32441b7e10617ef5c3ea6f27f06c303852ed7ab6205746dd95551f9494993b2e07118b138741161146d197f79e31e96479e8337d0a50028bc75b414c1f30bb8bb9cd4d21cf97982ad7b32a7a3fb845e47a41f9347d200cef7ca64af2208961e48c6d3edf0395e1dc41a44b759356a74e541414644a182bef4722d1ba13c02e0a755848b86f07d68c5b3c90a8afceb794ba72507de93123f04acc925c686385ebd69658f314b4b7fcd8dbf6badadc920063b7381ac1a9536b43197dc450dc67d48205ed8ef803430a07158fc0852ce2cf10f1eb106d24fb5f296bdf00ee0828f2c2bdfedfd15476581240c4c3681b0c439b3d604fdbbed45a59b655654ac5d51794aaefa486558f302ed7e51fdad6d9d0c1a9e4e50ba096dac0c34ffc8a686b253446a21f765205e08b9b5b576228c9ae26a815c03bf53d825bfb96f0f1b0b7a52818e5c8dfc671ef817a9a0c3ec034c917855fcd3e31a4b70bc0346265b404d50d14d9c1d3b57ef37316aed5ca16261aa8bf376a3cbc62be3dfd21515fbe6d21a93dbc435bd3b351177f76c568fc257ad6f6c3294b7312b979de5461269cdc856953ddfcc66cf092032e2c6ca6c960a13da4ff4dc100137d70a3ec49c440505ec25352c445b4e1dfa5d20a092b73c06b96fb78f251894286c873caf8884649de4ad68fc54605594f26bc6fbfafd44be1d9714b60ea6f6bdfdfb963ca896fabb2c11fbbefa1ef50c2df0462a44667398487c089aebedbe24b6a1054feaaceb19c5bfa203123c8b301aef1b5d1b17d344d6eafbf166992ac48891ed4c4037a39aa7d44cebcea98871d530487a0275a300fffc607d60c2d65a9758d9bd81ffc99f3f9c194fe28fa3b50d13d59287d7dedffe5d46187d9631a751fdf0e5c6e46c2844dfb2b8611bb3df9c0028ff115bcf374caeb757774b6d3e50e0226eee3b8e396fa0f17bcd8b4ac295c724a87d097c589bd7b1b8c410c333c6098abfc5df0e10adace0db511e710392723cd0fa78570c6eedba6a42ee164dbe6ff8a1f7663c54b228ed2af1c3a17ae4d49f08e3831eeac8af2b6e9584d7522cd7d57341048fbd24b0597e9a7ec1cd92699063524879d6ecc0e342dbebc60ce1116fd174fc65f5213e739bf02b21672defd8173da7cdd8111215d80fc8ef61c46ee840ccf037ad45beb4b46cf28080e9c70c95233b338ff5f07d21a2f96086efa6b42ac6ed23fe4ef74be82aec3baf965e27ab84b95cd3861ea894c90dd79720ff497f96046da370e3e6eaf77ac01b9549116a9a88239e1e385cae6e544b1e2bcb4fdd7457b330dca251c69b506e3f85bd694d10099fdf20d0f791b6b5f879aeeea8d2b165155975e4c95516d5e739ac86fe120ba38ac3b87df6876658bffbf47826e795932cb61efe191383601141db446725559441b6c90f2636cd0207ebc589c359155a98becf9b022d8a60f57b95a293c22532d73777fd95aee0c9d0dd1a763f9c3db2ecddc8730a112446a9ff35206d1279d0bba75334b79a475b8283ccbfddd354f548cc9f3fd14864cd1cbefefd0ea996d0303495cbc388bafb2eb91d0b9487bf7d8b91bce1b007de630dff6705bdd738aefb3fedac3474e64d273c38b619539c1858b2f8454f54bf63847e76e6b65a8546176d32c79f998e9f9af8ef2fa7947d10da528e443a5d94b5da2e5e730bf519cc36815b3402676933b3d7ecf6188db458629d268ff1a3ac38f6ff35e8b39d3fee9f30a1313da9b416853921d199976ed89cf9dab0c69d643afab7268e5b15859bb01d55ff710a4d9e01be3433f12b5b16c46cd90579e7ede7f831b736c45d4452626618a12eda5047940965bf370b75a5d171d18f6851a5a44f0fa96efe426dbcbe960c7e4113cd1924efab3104c85104d985307b846aed2cfdc0c48d4bbc6633b88b15949cb5c1306e86c3d32662287d751eab67743de3a9674af71de2c82868e9369fd0a4f7b6494dcb26a201883568d3b0a3a659f7f7027fb741e9493cba64d3e7666e78a4404d045441cbce5506276c6f645ffe6b3c75977716d01aa48fcc8dd4456f17fa69651d2cc17ad9c36cf636d42fbbd3975b96180157b7bd19e52884e71b81fb4f514dfcabffa753a319aad658aad6b596e8d5fb31d38a13e7588769735bca64f03807681c8f901089f3a1e3f9d4c6524e8102023c5e2220ebb23d4ca36fc31fb633930208742d72f78575f5c8a7150d857561e094603bb02041f7863969507c650b419f421618b5f510432df0e88539a039c79b936b08902b9fa18aff786d1ca5995cdf0ef431e0f9de06b784471b43a26dcdfd3c28c94cde24ec159e093f5084770fc9d6002741173e9e9fd37c7a46e672ddb8aa5f7b7abda1c67151d2ff7400c70ea6d80fc507fe1c36a87d499eedf03aa4b8bee5082f1d1de8a32c17e31eae02b0e807ee41fbc8e58f22372dd0a1b983afcac5c946228287b7e2177099b15e74b850eda0d82542df1229178521c156782b8897aea5a5d708cdd60582feef44afba2e3e07a05a5f76d59dba2f17778b207bfe02ca468ac6062c7fb2004feb290d51c983ebb8f46e743fee83fceec0aca5ae4ac69d3171e970a9e90335e10de1640287d303c0abcd7b88da2afe631a6c06cee706c1090c2693b7fb0b237eaaa4a5e58ab814387f7629a646ec0f659f5b9275c5df514fbe640c17dd49c3d59b4d108b3484ee2a93a354d623b9d868083b4cfe6aa2076cef4b8062a4c318d294c8804c2ce74eb9a66156233b2b4f507f29e72ba788e90e9203812575c501dca53855a745766767ced044555c05163e19b1d357b9f3c0e632009ff9a1c66d0d615601fa04161a737e7aae049e76868c492ada6386489e4678f7f4cfbf4c8f24a73e0c06d8ec25879daa02b8a9de1402bb6a4d812b9fe67b9d6b8dcfabba7ab9a4122c9f3c20fa074616f25c2ec33915d46ddaa66a9bc3298064c3af22664e58f3a0b0806610a4eed82a9fae5a0c8a61f46e8755ba260b05e8c2cedb30ca1404083de5147f38c0ba5215a5d8a272a992b05472b3b0e53ef9ffbc03d21dba5d42fc3893096755a96d36cef9711086466b15c1563858c8f36bc91c07ddf950f3c3161d09222f6e95f01f49708fa4dbbcc45b77c7228101896285ece8a92fced2d09bafd4dbedc33904af291adc43a531a2bdb8ad69df199de24231e518b5bfbb9d61c55306187cf87ea2f66ceeb9b4764508e5cc888df6309bf08a1ff8b4d1246a942c2ab05b38f766e52ed5cccba46da56ad1aefbf1342ba5a2564921461aaeb577084e91e323e110c21aaa669e9582ef185dbf329a592906a77fa1f36b8ffda69056cbd7b07a471f58de681d54e7ca4d5415b19a706f7438f04ace06f78f922f479ba8fc7889aefbc0c1ab4a3a447605fae66605b8e2c2a8438155161a867ff6344cf6a65909a671cc9af6c9b48d6e1a0e1ac1979d13f5f0c0c7113bd5d43456bb3a811009e4ca563bc3d46351ba11bc36fa893d910cb558d75fb72e6ae5011632fef00a8a8e7719fba684fca1600ec815b9c58c1333dbdb77406a304f5574ae55970c3f9441861dfd51d49fc78a5214f2ced3d21e812437f3f3dafe0a4d21c7a1cf06c8ddd2a62acbcc887badf2250ec26436cf4d00be64d1f33bb7a7dd8e8a8173bfbf64226c09ba50be2ee4ef8072244f5304a4c99c86595b94d50aa2682f17814f0130a50b54c81a5e6c502579a051a7fa3e5d743357089ba149dcbc522b80d3c3b767caeed9fff0a7a5ff881584fc128e95222c82ad9feffb505a53931f6977e2dfadddbcaa0cbb459f4e3565b1ebdacc921928d9e20eefed577cf86f2227aa520c7186053761c7114c828ef3a8912b6a83237ee3b64606c83cb5e6708f6475728fb564e1982425cd2db7233aa6b69000f327d2d3b3970e5debef0e5c73f8e60c874867343c6a335067b3b651fbd792984ed9d45e077ae0626eb23bfab02e4ebeaeccb78f984ec9b21cd0c4f51990cbffda819988d86a2790bc4dcf6a7021fd8d9e2022e2fd9426b9bea93308a57658386ef2f7584c2588959a44165a451e1196f583d7273af5f489efdf34901fa5179179e13c605cc8cda0275823e9ccb774e960a088179878c5669bc79649f881c5f629bd1d6ff045a629f0a7827e8e8b1725d1b7b23306808cb13df3a3c65c63acda504b3aca0121aa2de9c2a5ae99e04975aca936c5a5c16ed6ddbd3aafe796508b5a41104e353bbf800c652f1f09a9a5804a48f8796de297af14f86db713b52dfb59b59c8b3756310c535a94f58ba8bec54aa46aa66ee6951e3ee097e570ffc5407bacb99dcb4ac9d46db7a584329cf8b62c37a85884212ce96304c29003716ac5d376f13dbd60c553ddbc6937fec03132b25cfe5063960899ce4e78f5335a977ac1af90d9b956ceeac0a1f55724606347d635a99bd52476df9c8c963d97c583ffea08e12dac81da2e3c0870c1ff1def87142452ff2d5ed05f52764d32724640e82f5cffecbb2a202222e416f403389e53ce086f942a5391aefd242914364232def37eb9abfc1d3804b6be9e81313c2f9a35046048dea9207dc60e30ad3337606ac858540c55ca7909b26a99cfdfc2574145f61a01b34bb7d554e391266a9e658f1e8e0053c34244d1fddda9e8a9b8517687c08516583553d5c32c9d7e074981314fd72264af7d9fb316ab7a974474f87db8ea33e3e77c03330c4263acc9a22f651c3c984ae34d49432f3e0a044864dc942db9f7de5db8aba5929dae382a58c809b5b2ea5f5734322df16c08c25e459e5aaa9fc53995657fc37690713addd2dc96be4e1abe37e7020c3e56c040bf205c5116f6e67ba05641956ba5dba100aebaf92c71dff706c7a159afcfda7bf0d3676da030fa4ccbb45449267aad02aa9064b9a90de8d50df8e3a8e1fef94a6a970c560000ca556a0a08c7b77f3372de11044e5791dcf3302f2eb54048518627a02e4dbedb32626868b7146f49625a72f1261f06c7decaffec2e570b59d317631f91791d7c1c89525d4b9ae005fe049668c6b8e3a327e28741a38e2b1f170136bfab6dcfd822e8ff4ddb5ccb793f50bf004deadb25887d3662f60b569924b9bfb42413ce72131f4b2d1833e18d3b8a7e6ca7f7c26e1f8672f1449b81ad3b7bd5e622c9a9e8b2944ec8ef4f54820ef736c8d71f4b931e7dbe0f5b755064bb4f1821430b1bbbacf01085c6c2b0b31053ef37d565c303669b72e13e5ffab84e6b00f529ede26df6c5ae74ca8c9dc2b5feaae78b023d712d7f35c52c32ec23443124442f7cd3d2cf6634ce94e1166dadb53904de5e18d679ac77e4585618aa5c6fea0f328a1ab3225d7387dc871962e6080edd790f7d601afa2c1bb6e578f55afc1f1cba856052075556bbc81aff0af33df10ec98273e5caf257ea7b7eecb25d87c9c87e5e6c373ccde5344997cbb92e4955d04780cb47d4b1fdbd2e41dedff197976cf0f7bf85a4f225914cf9fea95044aeb1a123caf0f7616db15d833bb99874cfb38296748583915af1b7938272981e77efc6399921856bbec8d7da0bd41549abb5052459f47585b6815e893a8f64eeb947f3a835af4c58f0ffe04774505c3af6053eddd91a939329ec31684e90761032d59452ca2eee2aa0c55c8a916fa02b5f7aac9afb612bc70b74311693fffed24ac96b9465d477176e5aba81bf7ba1a1f1648a438d94a2da01aece889a861d411622467ea67edccab3ad2e7019882d3845451d4550c8b2d4ccc6eeb778bff1244a7170c29b04f8df7199b7b974dff598af29c9a970a7a6ba6d841bd1879f6c3bab6ba79cd74f14c74e5279ac6c8daf055713b4e48ac2057da47513f46756f6bd74b7e41ba550b51c39a3946d3359892721b40a496d4a713b7ac1bf34ceca0eb083a62397a0d6f2d39fdc7752a2d1572c6fd2a1a1701287f7be4ed531b69ae21786abc572bc2a93be846cb0e0b4d92cee13f73aed648dd4ee447ba7d8c837c713694993f7fe545c25e3fe6a69b4a422f7f10da59c96955a4a9d4beaef9910f40c262bf6c0f221b9c7f73c741a64525e52adc64fa56efad70d607f53ed3833c9ab45e7e3dc101ad74cafbefe3d9a465af93bb108fb13bfe9b00d2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
