<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6a1fa837b95482cf0cea66263a7a3b272dd26c468108e3d6212e84ad4fc34580c27cc81a02fe5e4bcbe3c0a7f25dcc216bc8f3669d20360b31d2693047089320d278481f9244555d179ee07c00c751bcb1c2968e31809eb2b269c6e026fc2f4f663fa51a5e30361e5f2e6f5aab1b46c35ad2028e13be6ade706ee81de2604e492521f4c3aaed26fcdc27fbfb3ffe6e2b8688762176e0d36c60f39facb90b2ae27990f6b62afc0a56cad3dc0e3180ab3d456cad88e825264aa2688f89b7cc8fe99c5d985c0c1889a4f1f8c481bef60cc889c82c626d225fbb59b73ba936f3ddf571ed6c3455dfb13bef2808f1f2886f02d46f92c3a78aaac988516d12cf61c977a505bab538c1bb7e70b332c72dc3a5fe3907e38a196a287d2abbbea5816b300ea7045837bc1a6b0a541f0003a2b7309665653d180587cf700a66940b34ae1e1235598b7179a328440c9317eca4a3b709a8084c986cddc34fea6d23ed66462afcbf460341a5dabf221913331f5d9e52f5498edf27d1eeefe0bfacd58687b536221ec604cf01c146ed0fb039e4f959405a3daae9760b1a1a2b20e85f31644e4c6516c65bab4b48cf59de696e3d3aca75076b296189dfda7f7665a4809b711646cc75e750dc2d283154b3356460ac7dc5abc2fd4e8c652ab09974ceb348bbc4090cc421315c8529053e1d5c5a83efe59be5ece5edd67f11209fb17cbab459fc29173be9e63d2c9272eacb71384c710b60de730fef71b8cdb11f849dc6832674c2793d83c27c800f34670f82984945e90898b02d99b74bd1a65df99f2c05e3c729c9d0632a412cfd9115cf90adc3dc8aafd4d7944690f14c010e1e29f4d5775f99aa9266e7d0ce395e9dc3c466a781a585ffe8039af42f93a236f48ddbb8a06f956d22693b90cc2d7846a0eafc116a395817263f91d43bc8fc9c7064b04f07c3b5d6919caafe1681d5a39a87728aefcf702c4019b5e704c777feeaa1a4cb5502d26237c0d55ffe28fce4569258ef6c881a66bbc3d1d190788f66991452a5790e26fca33b9e4c83c20661b64028f50d85c01b715670becc69d1fbf3d1d541c4764a099eaf591c11004ad3e2b636794241cd17e840013b54a44e72a647529e28aa6cd7088c29bf854831cb2cb9c27fe21e55971e1182d5694cc73628c3532c9c6204b377f4aee7e6aa6b405a5eb9f52ac1499f80f602d97cab5a4ad5408fffb01cfe4ea5714274dfddc389ed0632b0e223cad434d3fcd3dbfbcb6f6290c4716e7bd9a92e88af210657a2aa7e4bb2ba00e5d15b7757fea94b2d74c2e24d4d09a76f66baeb9b2b3086d416f44100945c50ec9eff366e4f816e1e2dff858f0ea14379eb940f6ff129ee048a220e1a658a2156e6d392f9254c096c36175aa85ef4661ea71bc442a66cf0a5310e0c02d01fc13f794b7505942ab7bd06e30af3627b8d713dd5bafce825fa2248e7c0bfb006e8848a02cfd9db346946d447c95a2ffe5fb50fd89e017f137bd2f8776224d7268b9d9d23957d6cd507805e8cc464e0c11097dbab0bb125564b48891d2b654df0f673a357bca457d9f312c9cf4172e414e2c5e073708082bbffba82077c93fa0bb914c24806ed9638d8203a8d5c0486bae3c9ef902b0a13bbefc5c104b8dd4790ed830998eaf6276d273877494b222df16c2691276fcc172d5680661a4541ce75335ff5af8908ae3a099895efb2203208f80c53240203034bc6f90d7dc669bc18a26e1129c10f7377bab85f28c710c54bf8dba8be590b891d40fa859151cbaba949e9d1af6c2613254bcf63f63dc4f7708774d80801e973b84eeee87d0587c02b8f48e7581e07bdd5e50f6959e7b3bd7318d79106681759eb411e7d4bd19f5a8c525c534b77818ba2c24ac3e93b48415475539e6cc7d153a5ccd2359e8e56f3782f5a25a373aede13d4a287b7e6ed699fe182825a0842472728b4310f543bd7f7636716acf953b29891ccb209a8df0aed321f3b4213fcdde59a751c0e33ba5fafc4c9a3384c65f18056784e7b0c2d4f8d0691a87a6eb413b5e7a19389ab2c6ded1d04123deddb01b6735d14d299585b9b331c798dfe91d93ded100a22ccbea517d6b6bd155e755dd321ace4e97503aa11eae40e0e7e766a777811d3ceed33edb3e1142b66d6387d3a9bf29e07229da96b2437d1e13eeb6fd9f788f2ef4e4e0d21e93e8b005af8b06c775f297626f9fb33746c3387ee4f612cc42938a61c82f277890dc05aef62503716011792f34a4dd0ff224c7ed60393583de5515dd96bf1d38ae68a9cba678708936ed973b7da7f815e8446e6e9259627acfa6f8e3ef1a15a2a6fcbeb65bc0c398cad78d1c4e3b6c846f245028a1311e77db294c4220afa5fca8a2fd41f60e12897dc54cd2c824562d8a6eaab7ed46763eac80ec684fc36b2293a3278344acbb2f43dd42b32892171f42c03e03408fcce2ba72054b5390069e9f6cdc9dbe2b26100ec885e9bf3493bb7528252bfe7bc7647178f952523cf22cbe11266effd792a5d1e89a2dd21d95547b3a3f7cad5cce1480142271078a7aaecf1aa09cedb7816bd785f76f29e7955ca8f638107548131c5d90ce7f3087d118771d06cb52aabc0ff554f275944183a7ac193c3bb3ba5d0441a090f25c5141de56fe0eb5045553fa95acff2fa0947c2ed383743fb94f7e0b0e550472275c191a4270a95234bf041464e606c491fcd03b4bddc28a4ee82e758ba0bab7d16804b96679e9ff41eb289904748f0d59ae7cbd0a0b8be26a2220f7da887a6ddb5f91612e172ac98f374c37ba6f0a7be6dc251c20c64604c1d511b0c78cc4a1ba6edbe677c870d01434b5289e7e917a2c47c631bb8df09a6b8b90b1abd7502af6130be670350da9ab8b0d4ea629bb9dc9796cf4b38273d671d2b9397cfac7b358473f10a4cef0db02b00c4f91cd7e66f7be1971684e55e698fd870192962b9d967d2d3003631fac878e7933e7e2379eb72ffaed8d126f22c8446bd61267134d0802511b3442ff105633a365577c2502b77bf4d403cec2753fc114f920848eb0503fa21136f1131a1da7548be6887d384a564066511a92d381ca87f7c0e5473ff5151f24cf4da55ba0958234b2d359ec1352e9a7c11f6fda73ad7edf953a94901f93ebe30df4bff81b238d8aa5eec07cd69ae46a393c4bcfbc8e44171247f2583b06edfeca9551faf8b83df3cfae31bf4b367b7efcd958753716198f377a099637a542f73c240d109a7ff32bc4f09dbdc905ff3c483d3e61fbd032e71f6a48d3b841ad5b59520e300d8d2bc46758855ad16455d83b87219cdcf7fa7ba90361d9f48b7d441c077e014f5a3428ce9d17efb9a53cfa3ebbe68d93b8d0f85218e8dd30aeb355a0a04b34359031e7fc5d3253d9bf480286129f635c68d8f374c05cc3719d6505ad1897069636e15a4e0ae039f95f988c3ec86c834277035f06d45f5e53918d85f503a8fb07f0744e0a9a234b23fbaf8f4d8ce81b708506b47ac0a091d3f5f9587d49a436a8e8f57fd1900230feaf20a2e6c231b422fc6995bbad249d1e322640ae9467e1fd8e3913935dc9b275238b13c96c4ec2e0f237295ce49dae4fc5f6b9ceec39b9750bb6f10a1d133b53a7e698a20ea321732cae61181f0a3c55db7bce3849982c2f06409d5504a8756e9dc8490598dea5198aaa78fe4c85cf2b7427fa932ea84c74fa45048777330bd7290f63335d65fda34b095da8c9124b1581efd3376cfcc7d655d96f9f109c09695321474fd60a4fb56e5111cd12070254e9e44d3351ffd07665b99ce176966fa472d5629b25d31a78c37952b968b7cc8b2c6ad33fb81e49fa4c341056a00870ee903f5673f81e2ae850ed862b237c2cedf02d34492bb3f847abddba83208acaa0794ce383ee16faa220c37c7c3c34f0dcdae29da0fa8cd92c8269cbfe95957229e7af55f011bbd4516841838bc2030d21390860613e799390263467e973c18d00394aca4c89adfc91d872d21892e1e13429d4af6e01c516b696a89f701ba1926ccdf87ad4a2a1ba43aff029ccf753a29e72a92324457e642fd61b0059b0c853f3ad253520d29f38a2ac72889cd6783b8e5ff94dbf1839321614ea4ff40b728f41053250859ba5ce00b06acd946755748ae1e85cdd80283d9cdd66ee98ed5d0d7994704a9b744ce20479d8c7773257a44b369d298c954ff5e68f71d07d2aaf9d85adaddb987e28134c527ff7687ac6afb61e60338471811f8d1cf380f0d3180b05510e09097b3b66ef030a95b152218396e0775ec36bb87a98319944ea8af6a0e9f551dedcc678932f15ad24f973efd3cbcbb33bbadc7d1ca9dad2f01f65f46fd9b1b7d0199b09357f19be8811023fa53a0f63184d23e1ff7080f31acd39c75f4b4c4035dbdf03413e5648bbb9c76ca09aa41f1ae0f6a9673b4cac925befa5f0b292d20e3e6bdc7e53e9926893c83d929abb826051338cafc094b462863404daf67f723ddf5afba5c5ea0d94e52d603084fafd53c040332554849e1e5e569aebf1870b605823002d2dec4ddcfc22748f4f13a7951b71fc8e76474cd86fe51a46f533dd7eb219ddadd2abd840eacd47a304aeb1b2af920fecb5a28a9aa36a58572e9b1658f76a2153aa5025e628b54a6b6b9bf2d6dd7f1d7fd4328ee1956403eb73e3b850e41921c970fecb500e129d5c14b32fd9fad5448f4ff763c857e7369286a43f4e2b03fb04453b768384b25ca094547bf6327e974c0aac3d8338f887389ce3f794f87878936dae5ba34dc81674b46a389627e8af33c194713d08972141b3288515f7b08825a7b978b5362601b365fd0613b8bbfc5bc598e4418f59f8a85c6ef6447e03fcf141bc307c73973186350bfe463f0f645842962921064682eeb443901bfd745edcabc97aa92c9dfb274a16cb72cfeafda0d1d58f25ca7dcea5a05e5bb4175babea2669e67f9989499549a0bd5e7f13b3439579f6e9880edefd691217c025d622c2b783249789549e8e438dff37e2c9c32a1305cfb23b2bda0eda21de5fd5be546daf4f530a51f087ff14ee25d1dbd4997d1ae87e5a969711cfaec9a7604b3456633c6d7ba3dfe8a5afba85e404c11b5b489c2cad3e3c6bea4575be308d0072f9eb2a9fe8ac48ad7f6e18352600db0aefafd134d137a5bd995f9d54d511f6b094fa1704ffb747e5876312e77c89d8d7b3f1e90a6fc5d9067957ef882d07192a745895009ba9f41d7ccad0bef9319e48ea632ea324b6bc6ccad889af20e8f497989bbfa28e74334504e91f0259018b573162641d5e1b99001affa73f82c7996ebb44a52eb6374d6d4d229af071ee83875de9ca49925190059f4543e79ae4cb1b78cc96b8c11544668b632858efd1c6741ec50e40588b91ce32988750fc4509e307c90a16fea8dccd8cf653cf15d3d7e2c7bd3cb1e12b411cdf6b14a5da438238b8a2c33f739aa679a78a83f895adef3b28a6e0a2f4687f4dc9879e643dfd22b16af62fde87e7871e2fe98e338cafef7d7a9b0490d644e75dc6a7ed3a752f0d3f48aabc8d38d87ebb80f87c5ac67155345b7ee2fb1f4f515ac34ee7067372254932a4386cd05a2bd1c9ff15fe6753fbd89ae981f9cf7f179bed689bc4e58964caf685eb700632b509c5cc06b7b6e22c6d5e32a94ac17e098525eeaae0a2b9358cf5d2b00e367ef24cb8d550fab75ce577535e25bf849831f94982b1d2c0d26ff5899a0b76d26fe903d4a1a79ecbf033bae094224d469fdef5449cef917ca262271b5b0fa525a7853cdf7d60d3e307c7ca529b4e83985b2846d0b59eaf32d02d2a43eacc65b106d9bea24175fa02f17cc5cb5c24faaa7004f94456a5268ef8c7a2d78b074b2d168dcb7110baa94be1164793ab78f71996facdfad358c836ab732be6b7e850e089dad66e9faae7c12fe586a078349968d64b9858dc2bf29e263495ae07ed2e04d1cf60601d6c9fa52ae1e68414520558b2b739cff0755574de3462f7733c3ed306e0123a787e62ebc0b125b2ea29f99ee5bb3ebc17a28e20fd6f0b86f3647b6091577609614dd9933c619bfd8620ac863d997b9d6cbddd0ba0a82cb64d553d00648e1cc7dd952f36aa3afc7dfcb852c195aeb7e81b83cbca4cf0387d37e336dae69599e14ca88124c9d065e21ca3934867f14ddd8dc952ba2a831793eeadfdd4206ae0211317c6bc42e22696ee3a7bc8f8d5957fa51dcaaabac30f03ac40923caf9d5564ded94ae57894d26d8bb4c97697aa1ad0c3da084fbffbe991ad0fa4f00fda81880437da07309f89de146b33cfd2d49805568d1358792faf55d8d342635d904b9d9bf8cc0029f7e96e30633a2d997c170cd6d03668f34c7a8abe2cf8f24f503862234e167f4ea69dc0283138847c1764732a47b44df2f18ec937b76b9cb74ed6503179bd0ffaab05fe40342558b00d2cbcfe8a3937d676752ec61b8ac6dcf5341cf43b9725337c5589ce11c330b43446c6dfffbe7ace82207f1dc9bd09a8e799aabf8d9c2b2cb11fa2473af01b3568db618500ce1211945219305e9585a9a91af8ad5cf9bbb3af0f9701033b7d9a2ef0c9588f38321d41492a385dee10da99c2b930d3d2630e1bc5048fe88cab6c4bc5faecaf1228341911a1dd122f5695e03d875131c36ef9f246e3b44698ec9d585c17c0aeaceb94ae5cd5ef46a7fea431a20caa0834c956dd7b762f6f548c88b909f5e5f3bbf6d4c63f359fba09adf2d3f2f80f668b4cf476a20b8e8b85e5e20bebcc8065852a1a6b8cac0986b4932ad3695ee345b79e47eaef9bdaacb5832d494693a506e48837349ac02322771c55b5459046c1e33d6e047f53d40927e5d63be4ba740ba6bd4fbbcda9ee1e7eafd8901cc03b6ea053914d49245e72b9d1e5d76fbe874e6b7d00becca90bf034f01eab0fa6da53a565df05204a6b3fdfce3e1246c5c445144aa034b04c99256820977017583299f4bc611229df60a234bf57ea33b943f939e49c0df2f106ce3c6dab2121476c9601e3db596548ecf3ed03281bf74794806ce91577896e69906e83ac6219fc01b1ae5e9deecf633349e3f932ba5755e58fe3c9309ac20c71ebec4641164ee6d42d4a1551133bb61c93515584d80e2ccbe19dbf0fa90d7ea3a40645e58def1c292054942582cd2f59c2deb8a9d065329c2885722c6b6de5b393e45ff77600da3fab221ee41a111373b528470b1291340353569c9ae7a67c4060da58354918a5eb78c852048962aee8987c3ac53f15bdc252bd5a946180b61c82ac6b0ca430be7016c12a0899bcfca745c512e8a609cd3ae49a745b418be7e16778da452302c44bae6dbf9de9b443cc427efc1fa1693c76b337359879a03dc65792487fbabb4a7d81f44feaaa15891b154d2dee79b6d6d250b7764933ae9525bc8f6d480cffd9b693f8e4170bbcccffa0c227f8388b83b1c70175205346bd6a5c748f67ba99bbea9f24fd8a1530975c1f3a6266044028e6ef6520127170dbd23273cdd43623ae5f6e3a8cd02ff5628609be5350564183027b480e47567766d4238cfe6fe8ac7fba5160f5fa4cac760e4dd663fb2a6e360ed17f7ba8f4b836ed32a9cb14f3afd57838fbd7741f7ebcfd307a679570a3771d65ce8801e8a1857c1e28550377bdfd8c7d5e1e947d3a7b5eec7a25857fec133f73bb137948f1e4367a0708fc874e102994afac18390776c241a096ba4005e79bf6866028224458d08d0afc09343d31035d18bf48bb0f7b47c137cee8a78da15e18f6a78adfbd0246bf5b4ae7fc57bcb23df1418015b71ebbbb48d98dcce74a2af91f305d980f2889826a9f0ac677bb2a27d3ba3d6f8ea24a535ad368689c846fe6a7536170fc0ab58ffcd5760627027b63d959de32194b089c4f4d21c2db239c66a6f9f69f6f6306a457bc051a4f909c97c8e256b8794d79bd9d7a2a7fbd1c57eab10a893e09d6334b2b93eaec00409ba31c2b97541bf65fe6896e7fe2bb45873c78a84c10909dd833a91b0f2ffd190522589df19874644fe93f79bd48f99755ee2778a31455fa4139a9ac5d12bab3dd67165cf4c162d912e80d292ddaf744029c8fbe843a922a384a0d0b81fd096a5909942a712624be84a2f4b25ab47863bdaf76d9ed988ff43306b171d33148571c70a42dc9d10386fd35576b0e9a88eda7dbec8240772d581046e07e586478fb7371ef429b09ba4f3890ad22c1f954fe554f9c86b4ea4d7c71855ea520c7acf3d0bf8cf2931a44e594eecba5d192702450e654e639220e62915fd95e9f53c07e83590ea2f43e5367c62059e7516865f8d3264e95e1dc9a955863094fd4349b7e09962819bb42daad92940ecc62c28735ac31712548d1dae2766f0f9bb65c9b8aa43907d0a8cd6af622c9d244530fef257bef5f1570aee81666a4f41ed6da09c46948c117ae4abfdb68aa15224ba3938198f70a99918295bff1cd1e76de69009844d32648362fb0177c8a307b5d605ed0f189e9ff605c3d15b1b2b0a2b0255342d018e998ffc41147db7664f90881349a1ee8c8c4414cc1c9c2dc03c20405e8eebb4fe01940a985aaa73ee81146cf6d55734d51078aa66a5e5f24af0dea6bb973056b902eae3d762f9f989833ac439f05da18ef12f3cc709dbd97726832732f12cf1227f836c6584cef5b60c0ccbfea79d2b18543bc027a12bc14624d88a97b4f5e2866d6ae4e239b621858d0e126330f39f3f72c3bdbb1e54db46ef3bfeece9e2907b97f5101be9759258efc78231d09cdfaaa50fb43c31066f32d88c20e34add240dc90e22ad6cb067012af21052bee9ce46374a8919ff14182320525bf98aa74defae1217ed311ca7344c3e4b720d27b117c84fe961f3bb5c6dce14f0f9c6648fb6c6dcc6487a7fb4d912a49215413f528774e63eafade8caac9f3dd04a43ffa7cccdce823301a5d6fc9005864360654a373cc9bb4d14615957d84490e122f942605d425d6baf95b2e33985476fe890f54836715231fc8a8f75b10eb1de65b40b637a123799bca9c668ba28700c4d5be6f3e0fec60c92e6ae5a5482ab37c3264e37f63f5b35ff1357c996097354b8d846a99bfbe1afcafdd894aff18538d49515cafcbe7b8dbab55aac460cea74d5f3952c751edfa14011dea9f635a5d4d2a5de553391afcce6c4fe0007ff72c2fc481e04478a9d0e7855e960bf05a6d071022e428c4a5c6ed1ef5f06b1ca7ff3a18de920afd9daffaa9fc8fb61d2231cd4f3d674a16518f816eefb3c7754843d619f8551036cbcefeb6f02df496001bcb043b64c1125c36b24a4fec96d7c7645d4763455c05253ebb98b8033d8a158cda21c0d49ffc32a2c17f611cbdd49de748a58cf865efc26425472d8427c5df6654789143d263f5e152933e5b1cb34ce3911936c594e8dff2f5119c6a22a1932e68dea1d8b3d17600a47926982d1b2fc61d63b1da4e13ffc6f0520684d620e4870266799f98523ff8438bebdb8bb38e6304d74f727e7faa152b7652ce67a423f968169f748bf057962ee036e79502395674df47c2ae4e06e7eed5d242a7d162c33f9e92a939dea7708a6120a45d31c7c9396735c2c691a8e6c00a4fe6bb5e48796e6c50443308c422c2c89f09da6f040961d3540a8cb46fe1ad13a2c44a7f0bc7ad1757ba853bbe8387ce41de0032f6865a7ab3a9b6fa66a2039299991c80e565a0ddf03b7081289c99f09f35d6828544b5e9f8e78b83facbf11f834486dce3931ed22d0e45a7d6fe34b9de9126d22db126d338996332be7c44f025a40c017b65a4b9067befb79d6c0893ed40ad8c4afc0dfc244ed291aa6fdfef04df7bc62f798a8cdb95a5c4f52111201e36a05e140021803e7dcba3979ff4aa521d4be04f825dfbf84ae2664ed945e21d172a1ef62caa1c800048c90ecd9b3e4c0546b6794c0ab4ea442ac171cfa32ecdc1637e8828d645db8e1f4899a21347c7a785a3dfbcbe33f904b6fc21ec8b7148197771e3d2e1d7f97dce5fcf95d4aaae5a3d62bab9d808b9efb42333b8fdd6e3b7ac442f373b14b0992f89183613239a5225684cc73f91e0dd35ff4999d7cbf460cda3a0a217cfa6743741877b44688da84073a3b55af5e751e3d0728769cc60e44eb4c88ffd150093936fd316c398708c382f3fec5fd5d9de2af7d106fb458d40ab6e7dd4d44cd0536d958a0369c8574bd0f3044872e66a4b8879b4522862a57ec3ff7f8e535abeb7ba880efee5bec7d05743a07d43a076f3e550bbe240c686f50107aef1c3c9bc6415d4f539a037077ab332f4b2dd10320cb34d71af22787334501dc299339a57bd84b3586724e50ddcf091e0f067725c1b29b246e3c7b951b27fc56d67cab58d7bbafcbad18baa3521da0d8239b9329ab3482d13ff90e57c641a15ce4aae5f6e80959b1d5374b0970d8b156f0387c8770f76d8a94e1a80f2b999525a24b55fc8bdf76fc58b9b10d009d93a6b30a79a375c87ea47a7d1da520047c42f9d9c9ae315ed6aeb9f3a70d3073c79dbd1953079ec8754f098533e44faf29a0fce9b2e42a4e7084b739dc03102a7468aea86a7e85d91a01d074699507b0d8801a9ae4409757ba183e86305b2d6243fc7e91c26704705ab497c8ac7bd879da192c29dd4aa35cebf61a07b9d3ea01434127572ac5c73dcaf087dc65672dc83db6c89ea68cf4a5c8ab6caac6019bb6920b7ef54152992a45004a66cddafadc31c0abb20f0791dd22d495661702926b8b0560211c39de0b2219fc34d10a6518a4740f9c1f64bef6cf6b83ee1f14c4c686eb961a8a127c99d71286c4af257194c44a78fa21c0817f1b417d0e9d6be051a7146a6541dd2f2c7834daf1b61f226f9325d0f81e90d05d837524a32a4625bc5cd05ffed9c9ac7e8d91205793ea33f2405760a24e7dd847f24509e21637378223d3c14a0467fe22f59fc06b0d2dea50909da2bab28b1d85ff194e2a3351f380c989ff5889278bc59d0e27fdcae95cb9d6c1b7778d22f484c01b86ca92a2871889144af0aceb46e4454b977215739b7ca965a9e350b9ed5a37da2a2bf5b3929463c06f4b66ab089a18c9028d069ab6088e4a636f47a3f34eee9088d95d6824f4fc90ed68bcb89b1747122c21a4c3ce33687b938b24b408d8223cbe520e1ba33d26504cb283e767f238d9ff9ba773b4e4576efe91962c43bf597aabff71482b4c37f82f4e452dae3058f06af014adc5aae32c01b19de6c884bbee82f1d41573bbb287445bfafbfe47f4e3e5c15966856379b84a1131b0a89c533c00a9cfb800935afab303ef4d22f9002977ad9fac576cdcc905e6d33848b57b4ab01076bf9232c80c410bdb76760b56b9f35fd6cafb8ca64294c2fb1c0b18a42738823d99f3330d937180efc892d912150a30cfcf0dcf495a0a8b3ccd53b68fb92ae90d745ce062a1c17d2044d31ef0ffb75ba40ab7d027c92f427d51dc071e76a9ebc6680183ca8d6df34fb7732d142fea1bc30ce6b3b4c8fc8b3cfa6f910c5680d20d0b031cc22bdcc7fab2b5396058107f7cae7e4b4847d5376073d91efac33e148cb86b6f8bc61bc2589d6e227c23e2266b650d4487364be8c8c8d7d4e4ae82ffcd6e6edfbb8983b592f7b1dbf3d3725bfcd8ab1778eb63cf630e1b23ba8928e67d36853b51d1dd5337cf5f93f60f33b0adc6274250d98608baf7eb29543444370ed447f6cf87fee3c145cd1b48e86d42345f51aa08d360e0ea0e19144c2ec56030f3059fa1ce91d5791a849978e77ac63bd6ae17cf6e55dfb48480e5cd05b93cd4b9fb521b038c28d57abca21ff41ea6613f328d62c0cb61e65810729228363ce9d183c83e15fe6dbe3612eeda5ed0245c90144ffc7dabaf0dc386e02851570a8fa139be504f23794b672b863bf408994d93c25f0f5a8f51bcea23a9a50f92d8fd2075b33f0c5cd4fa39f7f47038293010fd4b79fbb95abf3e7cbbed390983ff60ebd0c2d7ee7d0ea1e15ac01eeb43efaecba9108313699687f61b43533ae466037e16f0f8eeed61b7ccf3ca5095b55c4e8fad70c89e91f2a6ed459c8f11a5a12fe7765578d07f908a3f86e7bf01c24ba76bd7e38e4085d8f99001963c5700bf7ad631757649df4997f0eecb3a7933bb953a8f9f5481873da142acf1884aadec5b38f1a182b09c37e90b0bbf4471a9f2e87c4aa0e7c18eb86129c55d9e7724b31a5922dcbdb469fbc6ab7261086a11047466f9cdb32c863955678e852b5c7f9fd8b5d834f404d7aeb1bbe2e9e135d249e3ac53644ca1fcf4bb679b0ecb89756b93fd67b3aecc201c0c9b8af5716432af215e15fb4e8a4678ac714a7f928fa4eddc24dd7950cc6be61c369f1ccdc70d798afc9c24124dcad9e10ce7f8f69feb861030adba5a8ab04e38c8d55137da8bd5ac3cc73c6457e671dbff2ca1e115c451a4f245f478056ea9f87fa0ac895802cad2014633684e4725d65bfe3ff332206efa3e6db4b83b0b7194d197b583d8705ad196ee14d7ad5d83f0da121dcfefaf20ab9585ceb37c1301de7b86868870a07165cd8c71a334d270298912284544d0ca9ac6d0c72a7436ad5007401f8dc47352c0bd78efe958298b4e435010833d7a3f5a73b70a16b06ce1858e571bb87c810db0cd0c5e92724c7e8fb1565d179899b2fdd2245cd646e51e5161f3488722a17e7b6c2549d682c742979ade6c3564824599a455e079269064332be275f51a46b8813aeadf44aff3f5f429e3b1bc29cda9284b24aebf3c8a250108714bf7a8b0d494c989f7a61c1d70bf53ed95a3c6b35a4da352c614a2ff3f5bb7dca854d1b828cd9c873f40c47021dc4d3955ea52ccb0de01259e5abe2178f0f11a0ad59810a7d168da109853c258785fd5e597819506b5fe361626140b23c32567184f1acb8de2b87469a05f786169d3f8d1ae44c87d393b6dd21ebfcdd51055d99456134a6caa6234a23cef74264b287d90e00624ad523c264500b940c9fda91dc020a31e71904cce0b37515a7fefe7b4611864698d97e10ed36ab9b3d2fd94460be1e878abd85ba5eb6c029fe955b95fc63ed07bb7843792c688c4a6d532a4e9e18fd70903a64d14b39cac2b68f5e3df9bbb7bd11ba702930a59df44486d41f9f52198591764582b6cc99537e76f808dc0e0cc0b43da3ac6d6edad3ed089e8bfb30ab49ffc4d6ef15098f7ff5f1b35942286bf110b3a6f49897ea27d4cd1e9cf444739fcc19b8ae96c9b10e15ae41960e4dcadb73bf70946faa79bfb94998eeb803b392e8044c6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
