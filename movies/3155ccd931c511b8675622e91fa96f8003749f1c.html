<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ac212c186c04950ed1df240a4d23a5f6ebb5ec7a1d5a92c8f1df601c33ef14e99b2b94b482631b293b6c41f9ab018b754ec38b5a3c1e043ecf65ac3b9195ed45fb447bc01f1a66c3cec4ac17d2dcafe70146ca8874ffd96059995b489a67146e75422868862571be888eda8eeacb43c60edcad140f88422b6d8a9889dcab7acc1c08649b61f80599290ac4944d8d9d9481435e932265710d7b0e61e6f341c4fbc6cc910952d9de89b1e5300ca8d34dc080a1c1cb58bfe7c54530036f1f866e232602101269b5a5d4eda615f5f9958fbc7f207f2c0c44438d42f65118f9a359422279d5e2f698ef88d02a06070c686e232b2b1ef736f58eb32638b6600608821db6ed45298e68f154d830003e2bc0d6cbdd31c8cfcae0ddbcc4099151dc15ae3f99d8776624a4fde7e651ecafdccf4b99b5f94870c6a024423730bebb379ce0c8c4924e6a1a6e0584ea7fb73a2809cb1a217d4c8c7a5340b6550061bfee42f1f16a18c1da8ac6c2e2736b826dc5ba8e6a579788b506d213c00c17e2da56a498233c0d34c64285534676190e75a13e71fb866cfe2ab6f3a1d655488ec1e7a98da8180d769e97da10fda714ecf368f58d9aa61e888c5ac409851215d61b6875f2ee7c6ec0bb640ca08bd6332d993c7783de6ab3c0eee1471274111146ab76d8c675035c2cc8d78807f0eff9f92d5f74d179ec2fe7154ad2c27bca2b4ed9fae6eaf72c9194d18991565a5e20fe05210fb68b685501c4f13102df7b093b53dc6a0ad6e7fcaf9ed1a7f1387ecd9e90f8982f450f1732a013314790dd91693adc7a97167630ab654b6159c29ce07f086aa83af139f99920b5a5dc4ca4b2f23998ef160e8fa8c9af809c04f13ebeff37414fcc54202d9e4b4b6a2e4b4432f22c8cf2466245bef3b97b4cecfbeb3d0d1e171d47941edfd13b58d1ba2aa9e8f7fd58793f4dd9e6847c0a0d948787a87e9956f6b9d7e3e98e318aa3261be58366adc2f8c3aa6aaa3fdce91ea21d0a68c435b2f13b815ffaee9a82243452c25b6574975f53fa4aaafdcf957b35920bed8aba47b397d05ae973f2c1ac370de37840ff8a8cf5adae13ccfa856aaadcff1a2da6e4a3d15012d4e3b52f53c09653a5181b9122574cf31ef3f1793f4af5db0a749ac0771f84ec4adad50cd0c54154581f013cb1ebd4565c0f818abedf33eddd9d394a9adb09863b8a8e41f699e9c06a53a7b46a2ff1309cf35f9cee85fdcbdcb0a5fd065175045811845a63790f1282485b7d3dcf33796041defefa7a3accd456d678b133ec10fd242bdbfadcdbb41cdf457fb25ff7857043c92135694513ed832c9ab569a39c9a52ad03f2ac437951f04dd59f7a629ef9056d7b87fe946e49135977d1189715097c0ab37ab72659af474022a2362221672b1a8475667d502dd5f7401c6186c438eb4e1580df459240bc5b36e595b1ca0efc9c3dcdce63e3036b12dcc0592c62b5694af7a3499ce7d75db788a2d24d19aa18fcd70816af0f2dc29b8893f44a99d8e400d36a8aff8360b79e130047d53a11e35fbe4ad478b4c79cf9129ccc24d3c133e1f6407db920cf42d407096583cdea6bb5376bbd7abd09ba6c98842c573affab42891e226ba891d4d30a5db56cbf2cd9bc76f9fd24eaf04d1a28716e956e082c27bcd06b0bf6d6351b679bbed2a139ee4cc256f01e9729b4a3511d0f36360fa012f0c1348db59080d72104dcf9b8d1e713815b3e3a1e94f9c786454e39612f5cfb9d6c793c8972de71ff9973762a36dbf365a6c1cc40238d8f5d71329ff7727c56d3dffe200576530debf07849e03593d27dc0686c74d74c895fa0f2299fadc32d2ff2ddcd4f7deb5c22f920c531810dfce88c7b1ca3e2dee1933c6735e8c4feeaec1b03bf8d5fbe381922b3f3bad3722cb2612bc9a3d867d512d3ef67b696912f4a1d73e8d28592eda0fa988c4819168cf31f400480a45ff4c349aba5ae7f5243493921c95bda01caceb2ab0b2147b31a95b6e83e874a4f374dc80dee65d579e4ccc1ec358a31e2d91b58ff96ac12c72bb5ceb285b98f6c8bdd7c748d3559b157620aad28666e58b6c1e6f7be338b0b7eb7680c6f93bc86b0cb6103fc555fd68e6b1dd9bafcf603bac158aab185eb62ae13e115b64e25839d88a55c6d0e846b36b1c123a65f626dabbefaa2241761bd5a2af336185bf5ca44e183f7f4f91e0badd3226707ad9343c724bff3a008fbf999349ec1aa2f45c505f8af0fcdc71e38986593239b531c6392db213afe6c03746ecd737434a9d436e3f956263b1c34477beb42fbff736aa1b9da9c61fe7f0fabe4d496ae6e9bc163b1882a83220734297390793eab66401c0c7ea5382592c9d1a259c677afa47e191554e7f41ce63660cbef57594e74dff82ebbab6bae2366421515dc67834655ce5c9491422bf6df60f265dcc5a536a08f9cf6368c4c1e77da7bfa72fe6269623f1470479dd9cfd0142a5c67484015c0e8a3519d8fe38fd36bcd825fa5296de2ef3ad8a9d89cc144b47206472546a157d1c34277ca4652f259160f264fd89d89c4cf37b2a40da3dfb2d8f1231babb47222438f95f36d315dea4d40da44d295c04d7d696b583c8fbd54ec29b51b63c1be7622d34f6e6df9ca8a54f42a0b562546de876b2998c28bc61fc1f8eb36097ad5aa3474d92b5b12d8b24f4317c2fbf3ed1130e2b7f7f0af15a35eeb692951476b0f898f01de53fd3ab981caa5d065b9ba306028dd75acf3f5a1f5aad01854c17af581987fac94fd25f866a99be9b90695b5cbd4916b7a30b508c1a51441e55bf9b0b0ead63c062ddb7f91afbedb8cf11933876ab36ed45b63c03749c5cc63fd13a127b4d06f88cbc126a1928aeb6d0a6b2e2b7286f0547576b38b8c88069e32d765a312f861823b9aa433dfd6a22687f3784d0153fb854855f30e2b94302d3a74bbe58bd6ed9572bd6405ba5f2d10c8560a65c9943040f871e51e252c51043e546b2a3dc9c150ac856731812d55ea0fb94a802fbdc14d93bd757fb5ed4f3e5a2591c450914474d9bac623d162c2fb88467b8d4202feff13d191a7faa58cf15e5f26d57cf5f72576257b785e6758b3fd079c1753f0fd732891396c2849d5ccaee587b77b336ab691cd5de90c629c7bde7a63e1d2a6fb934ccaac4a9e1e04dca48f1dc16766b40851bc60a9f8bcc74d2bdd9f1ae3e1e41b45c870669550bc85b7936f5e0b19cf8275366d4b9ee3a4b9ef5530347c8955bb6bc8cf27c32e01642058d80c78f3758b89373e70b16b59bbe9a7ebdb9f96b1409446f9cd64df854f40e75a93de8a727df6fbe490b7f2f8c5c71e18b147b6b67d3664ca61de0278dae8275a7f5165e2dd666e9f9f08e9c88841a8c56ffc3a07c7d4a8ad30d5338dbf4dc43c94212d60e9e0cb6d80028f1c17b0d7c41406b0f53212256fadeec5119c7be03b19e0d2d111218143afdd54652f1b6b4b3d3bbb34a8648a569fcf0e54174df9a45d8200f50f90a087e68771a95e961201d6d65c81e8935d8dc4178dd8678b279ac0d60e9737a3cfcba8c44812a553dee49d489a9d41f9a0242ed3061a1ede7e559e27f22c1cab11cd7d6696e24ea869c2845488946c76f5fcd81b45e9d8ebdcea5a4578185aaa6f82354e60599f46e12f65af9ab852c6ea297cc445fe5d3f9538549b7d576eeb08753e5ca8bc24aacc9a8138455b297abed700e5aef0af84ff93ea492916a101a18346e46ff3a97caffa05038a197656118206cf5e28300eeafafa40be492e58ccf48c3fe4082f40857654fbcb9ddde76e0ee3c9d724f82c6122a7e16547c0cbce7d3d3e7d25b956c4e0f8ce130b306eeefc9d64b790470e3a8d99e97d19fc41692136e885c5c104455b4bb1a8e8a96ee25ce302b159b978a0337a75e62a848abee17d82ca9d5d150ce8d401f8dba91325878d0b615a49ed3f169dc2d100afe01ffad66db9075b38e587c1ba009ada5a65ef4026d7abf3b057610d3ffa87a490a37c22e4d24dbfb628bb1badb95dbd61a9fd6be8f1491d1b4f89f49a699bee46cd28af769683b9755630a9957dea27e0ef9d475eb5630bfc6d86447c35610226ec5862e91a63e6330a20af0617ea28a23e311e83ab09a5b98330df4198b33f5a94cac7fd0994a757c62eea494571e3296463b810ecfe8d46361c15c68233a5312ce0adb0ae0158308fe47ff8c3829a99ca3f8f96c4a70de4ad2cf5b7f8ee9675490bc1f556cca04f27d1c2cbe2f6991a5b92a1990889b56d519285dedc4b83c7080d484bb507a4d0642cdda2ff9cb33bc62f74bcf29ae9011e7f657f946c9b0093b54f12a3e3260a37c887fd1f00a0598b0cea3bca63ffb3233d514adbfe6b6afd78c5e4ac52a744a5f6fccc16d6d9235ba2221c876d9992ac3cf7413b525054aa8f43609caa8d01cf312e7d674d606ffab1e19daa292f042c1b9cccd76bcd795c9a9c312c5e3bf18371c1d56ae8e3fbafa59cc0c5a4b30873bda61c2957fa3960714854006d01f3f6b6210928402423a906f1ec8110e7e8cf88c38570b2630b61316b8a1ebb4c59aee9bb0a0df46af2847558fd20ee5768edcff96aacca296de61164321268007ef8830416b4fecab290a31b1c284c416f8e203531d37fa656d40521dc93e5bb9a7d7de30d4d6d093bfebc0761b068a3477dd4a4e6f1ac827a64765811996a24cefeb17522ef0ee085bf307258b369b067de58996b06141e3ce9ab2bc3eb3a2976a970f3da4be5b9c9cad78f34c3c84349faec4b68d8866dbce27b23a6873da11eb4db0bce747d5cd024f88c80cb30eb11e60a128fa1e2c3da14a99d5d85617af4ce8246d9341ed016d6701429131f6ddc1e18f2c36b21ad62532824cf60b9c1f4d85618d7df304eba7e79f76e14dc08a4ef4e74ef730b4f121d3534bcd3b26e8d00fabec1ffc06a164d61e0ac8971eb00eb456554b295a7f3a109162c0a675284da04670d679329cff038f5011d064e6c7ebbc3e739543a3a07b0ac21f03fe846d65b5a38248873cb8df155aabe22ebe7cdf44d8ad75efdc0eb5e426f2275ee1d520d021cb1f87a72ebde02fb9365d200704c75e17bb46475b5e502e04fe9e3557ce95109df06de44317c9534653d294354f245d596e3d0363c085ab419c5b4e88b6b9dd83afc9f7a0ce68a225f78148c500e56d05daa4ba1f41ba7529e4a8491ca8cc6d19ef05c43cb2f10b25c04ef4001bdba2e51a9f9c56d9fdc69452e798aadb151846316321898f53ea9b11dfb83320289e740ef6c7e5e02556d5b015ca9e1635972503d9371799d2d756ceea391f9925707f6ff3aeecaeb351d0055535f15b7b2b6877facefc3726adbdc17ccff78fdba4934a83496df96c78152ccff8b7554d3cfcd413a1376f23e2873fc7e4d56c4a46e097db766709318c4d3014e52cdac70c39c2fa90f7076e8457a11a82fd6d2cdd669267e9daaf9496b6002bd4bf6c4b613f0fc5f3b75762bc83aac02ab2e0ce9558dc2b71ae699ad7beb8c99f5f879519894ca3882b12a114ac33726d8e9caa7757aff87a6514c35c19faa8c29eb965fdfa2cb59ec48508fca1932839dcae96021512469f379b007daab03cb5a089782b76dc4f91b7ac5ac073e133e4efaee21c3af9eb9c8ea43f66ea0835cdc09dfb00053085e015802d597b5c300f4de8edaeb98d340ddc3e1420d1e89cc3b77ed59621795f1aa3878426802e53ba9f2be1434981b9a96f3c2d3426bc61754f149c6cc242080fcadf051e6e1564f9bc9d348084b070ba79c4267515497a77937b47a4bebb60c68a1795ffeb12b2b860f84c512f3a87e17f43a2529a37b8c7f466bd5f2e424ad74ea38a90c5c081fbd9ffceb6d262224d0db91d26ce05648f73bedff33823e36daeb63f1de21afbeed2ccc667d9cd8f034695eb38074f222430560d91bd438a05644854cdfadb62a467ebd8d1585b2d3a74c44663564feb16ab72c96b2a0dcb994ba0d1a90f3c9ef231d1e1f0ff33e13ae7528ec306fbe98f49b0662c0a90f36ec8a4ec193184ec1f10f925c1e8b19a77b0eac8768c6f1a1f3cce01fc8fba8dd9e34a545567ae4b36640b8be128151e858a3f1678dba4702d77f811279bb971fc602486cc0a44c6d4c74de4d5ac63c24049c564d73a43799e5dc38b9943b5c844bb34d4a37d18325c2ddde61cfb8704b109720349cf10cfc2bde3c339ac932d1ca4f077dd4b064794e90c797dbfc0de568cc094ffb79f0dd8dd3b6ee32fb18ec61f793f1b8cd07159666856e8d09439f1fecd695b787f51b2ed5b0459494d702dc98d7e9d3461a7c8e6dea3c93c6733fe60bdb2a0291b43d0bbffc592820d0b9791b71662920c6c7530a8886f50ddf47ddefe2692172e8c2d2095b21dc5708df73b51c09d0fde194948183d9ec058666608bc0b92039d5fc6a21bd43e215c561898fb7123ea57270b448192b94f15cfddb2b33985a9f57d067c1944d3e19d9c261fc82b3f4806af0be53c88cf37a7f6ec27830acc3fd85a00de467e3c8df5affb74e69fafbdea0cd7c52916d9a3bd72bcb1c194c1c2b3c75d0fc86731c8fe8f00ffdfd2ffef6ea68027afea406578413249e8c0378ef5ddae086e0290881aa2dff20ac4dc4dc7f9386d67b392870b3e925265bc09a3434611b09eb5236566c39e32b8b8cbf821fafa0b17b9861c079e5ac1e0c6f24312360bd2840209cbc005c89796381bfb086cd1a3022fde6508ccbad6c4baab34c2a5ed9a7c82290567c6af4a75959ef063377e02fa0345dfe4c2ab970b6dd3216836dc1c923fa33f338211f41e4b24afce2dfc4a8aafb85110d8f263b51954cc2999fcd670bdc7a11dd2b6ec1968dab620756931284d1f65f0d6c58f626f8c83a41d041927763f919b3a00528147d5d3a2587db051c323b799ffed4052c23a9aa77db9cf3f62f50fc67c6f2af7274c3b2365ab7e0343c36beff7f04a76eb29e2cbd1570b77c49429b978dcf4802069e4aa98f37ade447a044cfa4fb0957696bcc47dee73831ca852e1981229cfaebf392be82ff471a61992cc56d11b35e22c30c5e75c8d1ef68ab3ec760d5ff37acd60a4761de2c60345ee52fe33c0e907ca6e005a6edee6a9d7c3edf946bf02fb936bb2523465f4095d5783e41c6956e41d21d765ccde639476567b16543a0e34fa9c22549cfef64c32696b10e3093070183bfc2ea3c19e6f0b493b0a5f27d722d3fe51a06f52254236ad65b6b72c48b444069cc7ee5e61650422cfe3a610bde0641ed0db314e6d8b7351d0a16fad987c80ab5ba4f6e3edfc952cd0c5bbf7e28d7e9a9f4e5b58bd2599a8ea09f7372516f4229d540af57a2e33ba96e94463d30ba7f6749c462c9a79a51c79735a43ca0e363c1ae41bce109fd107c6f42589bf3e25249c9a39a0de86bb8e2f959e45b5edc79e4fb82c15c5e06d9fdd7b10546fb4e3fac59bea2ad8bbb333c82cd510e0b410d49d426a55e0071c789f22a1aa63bc0c7f56e003867411d5c86e6ff86a3c14a5b64879ca77de07f2accf54a6ba171ef9faecf00dd1118387ca6f14ba360aeb680b91de2c149894dfd4b7a56ed442c8467e0eae8deefb9496e5e999b7b8895cb0d873938c14adb211e742b9cb7d24a7f397d9f6f5f5c0fd81f5562d6e2ef79a768fd3cbc9195322bdb0f909bcc4b230e102b4dd5298bbcc8d5f324a8818acdf324d7bbe3204221e6e45b2d0005d48503ac97b761da85fac3286e6a9e0d0aa60277d6dcaa184b1601cc4a6611fe6d01d0412b224619ef4df6ae2938a5ef8ee395e961bb655cd50bc8a9f8ae7baaebbb9b6cea5759706226c58527c5cc26b4bf8d35449af4f8b68fbcfd68e990fd2c312592f478df7256c40961195f652ed95f6e47d789a8ca81f02c3e0e089bb07809835c3d8e041c85cc6a8ac41ccf46dcf082b7e1416098f6d9092c2e89be820e3687e509929bdba3ca45f8d8763374daafc95c1875faad51e5b2f072476902e3d02668de87b649f44f35ac22cde0c1c4c6342c3a09a380e474c048da285bcaaeab17fc85121cd4c95718af3a496c990ceb119524da2c782c677f5fad47c1ee2c5fcd70bff141c616b942090ee80bd55354fb0f51bb73e4c0c4b81e38ee7a6d6d57a956822049d8e5a6915713631912edea9abf9a5b1a32f12d47572335715adcdd7a629776321954562721352b44138e7846ffe9b8f0ee665af2942203dda2cb3d534a5cf250bebb01f440eb499c60385ccb97899c7652d82a936e35397050d271657342b43089fca24acab408b4fdee93c734c2a97b50b74ef4020ee2862246f48c647b53b58fe26705682fa930969ad0cc8a868a9df0d99e66d24b0f02cb9f5aa89b0825fb8a86ea55177550f1c6f10eb0fce13ab8813b2b20b0e68b8612bce098fd8a9c5f946b726b1fd6784f8a4d8a6acc7d52bd41a3de12e6db04ee482b2ac5df40898c83467b8efa32af053b6bb3285205d8d49a77d490de13592dea026e8304b9b61186aa9fad2bd109f05102eb7f43bbebadaf5fac6d18d8ece4069bc907dc710f1916c1aaf585a3e8761634612cb09cef7b35a2bd4e59dc33f5c6af8cb779a76cffd0f848c991a1ea916c7f14b7e9f5323b35d114b095c2920d34769f670d74442c8fde2615d1de10c031d707960ec16d8fc3a6a5b2a16515d464685714b7cd146a6dffc05323a883e64460a5a53a4f9f6723556352e63e81036c8727be0edd555289c846b66e2272b4248256e95acaaa4f6122efac82135134f80c1c812f9b0af4205a77b50dea16861d22bcae1a23f17e37467714630de44327f09ba8e3a4331553a553ffdd243e90aee76962b16295f1b98ba1e325d868dd7851b3172cfbea19ea68e67ee4a37bb95ca3d5226914e452aa6f72951fcf5b9b901a4faaea0417567a7600ddc02c0a7b6c92ba2f62a555e6419c3150f717b1b84e47ffea423ef095fc1685939c6821402c9de13a8e406a9edea7175b1fae87e27330b642efb1e8a9e79c89caebfc442206bfe549224a2bb640d2d3c384d767e3344ee89ad347af1d2d1690afba64b3aebf1a5c9f9025ee3ffdd3f9fce5f56d58ba22ae036f494944f4ceec62deccfba8d6ed016192ff83332dd61b34e5adfeeeec06dfbfb3d3fab801ed010d6b9b014ac7fc639f38c950403fb5a1ebb3ead19251fd1958937b8c8ab07f1d5125220a8a868e12233b10ca8b4ff22eee0a6f72ca12c48f28d22d8647b2b3b20f33df42206285259a82456e3ada39b69da2b450f0c2ea7d0434117a728f3a4764b4b0900b7ca2f800a7d7569bf15bdb1448dab0645dae6ea47ff81ba2fecb2db14d056899d6b629cebbd769626b464622197c8f578dcb956524476be731a31db690773f3f1f2af7b4ec784e0e8bc4b9ec09fbb6cbbbe34eed86a4dc2eea14bf96d3bd8dc35b76b68924851a77593cb78eee052eb00c5c6728a1572eb515f33a729fd749aea4560d14edc3aff0a85e74b3545ac8ef47f43b6e27b543da7f49a746dfee2b7acd9e9a8873f79294452fec40b3224494aba878df6379fc2e63864fa94204fda2d5114d6a1bb3b6e7eea56ea00a11a4dcf127453845cf0ccf8fcaf87a8e328d01f3a57668b58c1eb6d6e8a508525ab289d55008981b082f2e552785df6f48116d8028d178e8f251591cabdd0ce08adf7299c62829867cedc6dbe950f47a92753f5c0053f8f97d5e31faf5758ae9ae271ddffd2ff44511c7c8d2b1774a060c8200833a9f73a1ca4c5246aaadbb452c46df4acaa6ce720cecc742ea7d56716f99af34375dd01074e1e4a07ec53e63b2a030a3ed69052db040b9c72216292fd78f1a272211fe64ba15b36278dce1379b0dcac3ac580f4f78b4581fd07cad1fce51167e232bcb1986cc59508a881ba8fd160e4bbcda981d2ce00ffc5e2e76082196689fcc625ae954c17e7c8c3527a6b386d3ed27e056b99804395d46e2f63ea647de42b702d5acecc417bf94fb2adde4c24b024a50ce4a9a5f0a380495d6ab9f7214da028151f721d72e5e959acb7665936176a6f4c7b106ccfbdd654c6dd41271dee68cdd74d53387344bfef3edda77eeb9d5400380fd8cc1214efb65891342d741a9ce24ebd8c77d7a38fb7c2154b6bdb70e82f05a5cfd7d850c56ef89372d6554c821aab2bacd7bd5f3be964b26f01dbfc1c0ceb6dc52ab1604062c67c6232fe83caba33df04f30ef7cc1d47a01ba7389f862443bb79a470a9767f2679d95355f169789ee060f79689b5d28c56a2f3a9fa554cfcc3e78d0269425e983152e1cf5c96e5aab0dc97ee7b5c62c57b720657f1bf4587013de20e834d74df3b73d071a4c02a6aa082418da0c79df8004859733532fb29758526a28f12e18dde1c8960853317baf713ece201798f6eefc5e004107c037d146363ee107c5d99d8be691a4d4dd476a3454a28d643807dfbb7e5fb8a2533281a25d72b64b193d2143aa82a6df178952e1d32ba84326768d0976218d884e5132b80562e5aa7a5ea543f16c01f40f2f71b923ff2f781a23c968c582d4b35a0a3a3f78343b59cf7f2ea1e733754f88f243a6c91d2ec8ae98c1198333026a47f5b8c5ea04fe1f08a0b0caa4cbe0d44ea9e6a2e4032b37c8e156d7c4e6abe00ca7a57b51bd6492d214fcb1abc7395d572df8e655bd33bdf5bd8443c1c90335e024873137ff81ab07d7878f956d87e5aa4162ea4ca6722addf42b557a9801efb6c2b9053a9418554bc15c093b0fca789dcede243d25178bb0e20b6c1354facb860ffe2deb1f0f381033f90808cb0c408b7d795e0cd63f326ca864c1a32f89f17abcbe6125aefe76c3850ec7332022925042bda7185b267bebc36e588e1dbfa070d8b39fc280e588428acd39e1604674812d5ed928e8884aacdc198371c9a7b3eb2a324679dfe4824b64098086dc7cacf3242df4e73bd5ee9638e18a9b613d940f254f0e0660180dca3dc36d9c1c9f323fe93dfabc87124fdd4ce6ee9a7e2c88faa47d1c34b1528da5d1c9ae435fb07197197cce891d7cfe300dccc36c8339d4696d418bd3fb28b0383e0b3e7d309c3ce54f0f9feb7728c25529f8e2b5c56aeaed13476b1911ba6f404ef907fc1fb6f51dcf810db16699ef4a1d3d7808991ef9e2bb666bab458995398c475bc378204ded1612a783d0f9fd55af06c7f38ed34236ec7f75e10678728b3f93b845d17cfce45557491c1bd7d1368f481a2f42c3a354d59c823f9b4dacf8dce5ddec793dbcb2ae413dbafaf390cd75efee6d975e28c817e0cc95b2fe4410073c0285762ca12f0104134214c4261bf7cd017cd2ff8e67e3e557c849424790b866ff002c778f7a1fd2d8c8f224f3c75dd03cec32c4df4ebdbd39720d58819c611ba30d53e63849f15618fea4d725903cacbdacc4b6a2d1a72019f5e2d9989206290905ab93e4a5e300db6e96a9920459bc00c744abff5a3d202878b8978de685ac65f8df22014a51ad76c921afbc73533e2cd8dbd0feb52fad32675fcb5d2ffc0863b6819d0d1d6d0f47dd80904cd71d31e5a56345f44a51bde7f6396d998a908f740b68d732fe637f0229c472191f99967ca6cd5265d1d3e8424b62780f797b0b185673b2514590d295ca4d7cf3b2837c83f7ad1ce1164e7d9feb1e1212df99e1c6d849ad641387333e23b42edd96599303235fd4ddc617ff300bef9b1b15faa112a2f0c7c3ba99a5a1aa19428b43a10c2df92819e4b8909d03e9712c5b1dcf72650858369994cf4264ec7142ac96b83a0eaf8b62ae3869ee784de8915be4eadbb42160cde1def17db22d8142e83db30e8397e2d51f3111237d0ca7db00b6431d50557034aba5d3f8f428bf7286791afac34754f2635570051e86dc5a4581b7e1bb44cc9b009b888e63fc2b4de0818fbf333bdfeeef4282dbb5d20e8cc83d715db38eac2f0810d4c4d718ade45200e008926c77c79229d7a396d3287759dadbc0fdbb62cfad3c6280d1e1b37e66131970ae4576e860a4ac5f5a9f20de5f5b3aaced3cf24345b22dabeb9b71e6330e163999b0894655744a71830355c6095ec399f6c5e9f9a72b9e6c408b630ad9b9654981f5127c3d6552c7fd02ee30e264675c03361bf7c81d54657f6afdbb13bbb228481a1d815b4a97cb042ce1731f40f486613ec54bb426e12f1a2b01236029bd3f07565ce34655986427b415c63136156fe681f95cf00e20f27f7316b3c69fa1361cd300e1fd744f6b71b19200120b1d22dcf7a0bbc440ee76eaa37b685175f1aa004c3f3f2c498657dac796b7219519c22186b1ab65301658b71baef9fc44e8cdb075fbc075ef9978dae5ce141b997dba0fe8369e454be9d210a39eab3be742520ce50dde13503e9573674c98df1f9e5063b75b13195a63a041530304dad7e54e24ddd6ee1063562505816b88647e37ebd2313871dca2cfd66b80b321b4d2841c7a86ccbaf98ef73cf274a31e4e063cbf12907077bb902e6666cc4163ca13d2f0a4705c9f8f4ea646f62447d546cbcc98322eaa9ffcba3dc97edbc54889925d1c7b8c439d6b8a784edc4cbf6cdeb5d6f900a63233e51ac239610dbf05b6def76bf4d1c7880ea0ccfe48a098a28738f707c16de954f82d9ecb8877b85ef9cf1afa6fbcf258c470b42fe26195c29fc39e0602a0f2dfc5ac217c6d42713bc1a6e1e540fee729496e47d75a9510e7dc4c05a54ac80b66445c8b95a0aacbaffa46afa4125ced9587a75f00d6af9d07a983a6b772747b56fe56b0f7bcdf51179694262e5e5c3bfaeee36d4e29e4329f584af028c6a1b197994b3deb58ab73be34f3e4378f109940827ad16dba58be4d8d766101fc4250536bdc746bab32b9bd0842ec301b52a3e43fb1209e2d0ebb9eaa4a0e9f3386f7258de5ca132cbbb8c58664e3c62f4bd96a783489c42a479633209737461a8524449f0609b4e573ccd34a45ab4d36be9a50613713ffffbb0e79dc63bd54d989b49e2c8afbc58c894d2152dee71d2d1091dd641f9d6da0906c5260ef314f2cfd2ba0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
