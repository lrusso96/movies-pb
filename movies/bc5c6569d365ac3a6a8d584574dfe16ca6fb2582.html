<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ba00329452f3ea737ee20868f13082d54ce87857ccf782d91874c832b08fb43f0be20f9cecea800beab236c112ffd22597d0ec2bcba400ad036bb9de74ac9768c49fd73bbe6a6a6a20915cb16e177c0432b72ec7de0ed71aa0681b18a405e709c7c91102670b643a92290b7033c17c43fb98eb88c2ba279957af33ca01dc0f6afdf6f8880a10f7a90cde89901eea3a210a8e082deb080742b793cd9042ffc10921baedd90fd69b76e8d40afa465b2ab3187434365633985fe982e8581817b00696b7e5871d8c1b55c0bcafddd8f8ab877aa20eeb0d3b1ca5810a233cf084d07a1ef15ed8d9f0cda4694dc232fb81cdd5fe9da3dac8240e1fb32cf1cdff05784c151ca472354653a199a7689f56a3d7b5e8a260e7a374dc88821b01491ebfa4044a32e9e960e66affa3708b05dfce069c4a644567f47557f26aaee50672b1380eed12e8084c7afd8e0468216917711a81475ad667b6e1898060874c64b92b43ac8b0a507a1da1374ca101e673f894a3d71518591a3e7990df2762c44971c37523eee97a9a0c1358f107c55f5f7c41a8f2a49168cff8bd2a71b64b219eb2cc0ae591e6d7c33e23f8ccefcc1cab2fd4510f77c139c913069161335d51458c82e8cdad4d52056814a79446ade1109aa9351bfe227b87e0f31c042baf126a73254b7d8db40ec453a697fb0cec7b3db3b739d652a84129307383dcc1929b2713adfcd652c9a1b7199a463f93e8180f26fe0962141e41bb29f4bff995dbd3f5d10f1a61c801db1ce4c2bf30153e48168497896635c12f89236aa13eae1e2ae77671607aa71f92a503da4733885429ca1fec970a8a4e0fd2ecb3ecb610aec40e14cbfdf6d3ad9710595df61c2f48d090fd4085d50110627f309b356c9757f5ccf93fcee0759911b3973ee0f28b8d2a492d5c264c8a2604f33dc3579a1eb7f4eeafddc831e6defdd8d2737fc73ac1b8d65cad9041c71deb5357359a050ca865362fe4651c4f6edf7cb510d4065a4c049edb53e76887f98366746743505bf174b03fdbeb89391aa41347fa01bcc4e85600648ea318306c1ac7ffdae0792e70fc5ab02aa9b4dc4c34f047a1eeb3d39f7b0f5c29c90f8d0dd1bd696277021114deefc50b077a2d52dd02557ea3e8bc5e2d190b5946d6c14d4d784279ce8439e455de8de596dba26f404f3184b627a47cd8b0a6c91887f6fd9ee7f28721fd55c715f0ad3869cecafdfb50ac1130e88c0551eae908f3f0cbf791449cc71cecf75bec812001b04bb3f415beafcb638bbe8b74c63c272d5a027b86b89d53fca04a44cde238ea422e1193f0c9f7ad3df6e7027156d338493e2b641c11d5c0d76a1df54d46c1eab250d77958d190dea136d88f28e86c2fc7dfabc16fdcc4563ec98f69dfc91ffd11bb3663a9364b8a691f0db9a5b9d00cb9479d9233de5eb8df0530ab1d62e45304c23c6fb66ef03f341d40036d94eb6d85b10e021c4ee7f8aaa04f096f98c412c98244c9105ff1420f710ad051f8cebd363f72ca3a39daa64a312c0250294edf258f3450dd08f11acf970c4e6fc56f5206568025bed52991be3662ea21de0a4e8b3984e5eeff660d3504a9273752271e1f3f583e70f873a029ff18e4409e7d1fdb4721e003c0da62c33879c8c19ff2d757ab15ad023b213f873d48f855c0a2d209d887a7d495c80bac262c7bf0b2f6f6a1489703c57a2cce2008dde4260adfd16f2678bc575e9379e87774441a7061caafca464f2b985dd39547b1a1d349a95e45d9601a19d42a79b532e2ba5fc5431317765f60eba4baeb1f0a2481b1cce3763d760e53e6d58c88d79420c8cc36fc853235a63bd0b81ad405d75194ca811812a2c6d62914b9c04a4ff395b64b040dd558527c512cf3bccae60028dae9171788a787a6b98c32cc98be11dddbf61b0f382442b62c60ffe6b87a1fc2f50819f255fab01778092c1fe8aab1617aad420fa3f647dddd4074a9487fcd1b62cad59d4e41bcb167e023a9c5f2f77b7e247d3623ac5bad47508df1fb420f2256a3db5db4ca4dced3c6c4577e73e1668cc6c0d3dc9b5cc4415fc11c1c707d7c7146ceaf7eb92ca5cda583fb4c0fee9b3a2d4371a312741680434a6b104126b1a1b6414260299498953d34afa01047e8fcc8bb7f3b699d2a99f2ffa403ff72713e2519eb06619515a36a3d1575c0bf4d55c24ae3f1b8eb1741603d53a411370c98cb49e7ec8b7ede96790979cd847e17ae18c0bba64ac19d67b11400c0c362dffb47564107f3fd2375b22a77ab4f3f825c2644be9d81ee7c4f1b4f4262b7670658040491eada31ea8ae476c06dc69d6bb50003e4ed9839ded75e156dd7b4841f3cb92f7522f5f5cd26cf6c9cb41358ccfae3c1af8318430df8d2eb5b9e42bf2c6ac514cbafb06b3d02297a9fc89b571e098bdde7d8a9ebda819daea3c8c1aa8204a4e0aa1491c78d628c059511f9a8956b46ec25467860886dcbb4676ebd2d44339dcb38b059109580c170e17ca1fc9205d71a9afc4d62d4d6629e753e2f455d1654f788f96fbf3416601895fd9deb0bb4c3bc89f7c110828609e446d2d53e49791bd05ed5573a27317928521b134118db3abe4c34c72836a579ac24246a01a07e4dd910030f47c2a63f89733ddfb9cc16caeeef0bc401a7f4ab400509c1088f26e3b972a0622413d7610db4c29219567a1680f8577acaf18f8512c8f06f46b7c13b5b4f6738fd00b5cc41fef185c723bac30a4cf0c414ec9c3e458533ed4a1f9f62b9ca161ecc348e90353a97b1f6eee7debcb2e8d561e18d5b215f0d8aedd8d0effdb4e8830d8a9a82fe572e7e0c5c5338ffbafe777603e7ed687ed562c2debfa3fcb6ed67d1cca0b063384e3ec125dbfa0b338eca5e274d1b9741f313dc928b6017e9b4f2bbcef57a5a1a480f2b2dc37406f1a1bda747534765c13d2e55b51c91abad8f1ca39dfde7b7bcc631a144714e83752e081973be0278f77fc16f2e5404cd63ea9b335ee1b0fdca3cd0eb0148e4602e7e12eb07a53bbb03312b45a77a7c741d1e89ef3e4205541599ecaa982367c5d6c2cc770bee59d4a7849ee209920e22c48739941b20de20b02cd2dfb00244f58b6c87616e4318ae3beaaab400ad9dfae66ae946c66ba7e654df8c8a07f598943e591bfa8518c4df3f8af6b964f2d632a90f260ed26ccd0536469e98affd8935cc6b8fe9334d763d9137ef9c609688f7eb99ef23bd54dce3e72fc84c694ff866888d8ed6c59c1aa4990acd3df87470aaed3274a7882817e7b57548d34942b0b0a60d74c072c78dd8c4cf16291fab521cb19cc0c781107fa90d115b541ee064663225fd123c37b5aa868f0785b69d1dc2b095239449c60a678360ebd2107cd620acd69153653a2092e6ecf89398acdd25515177427304d4548bb977945803918b9aae12b63e9dee4716def208455fd7c09bfd9e89a3d4c49b4a4a15e828cdcbf7115550506063ebac3bd3a26ff4e3f2288712f2e6fa7da2d2c81519e791637c961e73be1a0ceecdaf27743bd661aa77d6d32d2590e600711c5dba4105525ff4a41a4856fee663047f3a90c5b4d91e1978bbeea4659db53222bb5c4dd6789c84233f8db9fdbde8676bb0adc11a8e3546fa6a6bc6915764fb912f7d4e54af2b15e3bd83af3963b37dce501dbe3f8c834b5590e24b2ad5226496d4c09322e042b46f3747935ba04502b14be6fb157b7674f23b4d3105063a94c3ca209054ab24260578999dd2361fd0aea85639c218c4aa5847dd7cd5774102a5741545cf05c38af3b3298d796c5e328c8c0c2acae9b8db813654acf390f5fe97d3392c510a5407510fd19a55962add47fd5e972494bc8bbc30111a70fb41d77e36d420fab601eb322e9bb8f7bbc04a92516696dfb0a81e3ae275ddee15200e9b4837f524f4576771d10bf0dcc3dde68efb76930fbb513a51e2b9b8b03efa61103566227644221227e950cd90ce5d6790166c1bc3f617caecde8595bacef8e9788079f475de39c88a220ad4a15e81c1b34fb11497121bf3634f3ae00d41d287f9f4a6004729e89417b251f844ea3498c8ffad56f070ddfc98d98fa27b6fd92db77b87f73212e32fd5a0c4b5a54936771101ef130a5adafd081357f9eacb12271b3b42dc54fe8b8c9eb5c6a381805ad8141d735006fc252cc3c6ccbf15d9e1d0a6a1af53e19c18a22c0b97c141f47793c4da91f8cb467594b6925f9527f159ff20e6ca98eacb36e1d9f2a18fe7630910dd5bfef6fe6669eb2ea291b3593da6680ca27c44f35ceb975c1fa5c07e2f5401a33e51466994052c1f5358ede2042d40c622bf31e0b27df4ed62724198e5aa2b09eb477139bf2d6aadc2ac9af3f1f9227454ae39668e4aeed32883be24538cd0a013a729a70323a4304b2a952b31d96711979a9c85a06adab7090051edf4c6f59f352dc147fbd5646e9f2c55693c52ffb1cc0cd03fa85e703158f4547666860397d868f87545676d78c928948a371df6a5af55c5d8307301c6c667bc7554689ca7978a14b5082add8fcd71f0e7a644edbc1e03ceae3a2fe8dcf4c68eb089a13497c9804c0dc32e2c76f95f83bda4156ff904e8afa3e6001e61230647afb07f43f7e7e10c2e303f7d3498e9160ace932682003718ad057d11b4c20bb0f281d82dab354729a5eb9b27d83d17725a8d55ac23099fe300138b4a597d333e98919f3245e8ca1a104fd06c446975a2ca90bff9df81b5408251cb1365fadb6d773b8c61d68dac8c2b48f361ae161660723d8654777c0af6acf5d86a8b0ff716e755e295c0a8774712358b3fc9871a0143d11aadc53d353c4821200632d1e5c4e8edf7716e531099f906af7249f2ff140df22ce72010be0ecd25e28d561d5df96036d55c31d640efa41a1fadf6c94df1e9adc9e5e309853f774fbf01fb1b3846103b341969ec319bf2039ca03bb3f405c5098ee458542b8e76ff67d8fd37a4ffa7d069883cb66c88209e648254145ec33a56376b270eb3d0d178aaf384831d5e3af7f097c2e1518c20bc480c95928f007ebee596b5fbd40decb72e3f26679b61041d5961d8ca8db6fa0dd91b8d9a1164407d1dcf8bfcc8a38b202a6d65c827776f01714971f50491213cccad3395e096d87a28a13522685bf2a67be3d978d82cac1d1e69d09732d007d5e8759fc0b2ba7d15f633e79156289fc15e3ce21e4f1896980cf37d3b388567deea3ad299d90eb091bf54f4c865e1268563d552dd5d40394b216abdf7bc19b3a309d8bc212a07f5d1fef3c5254affcc5923cdd8bfc1d152d2e254a138a8a271c078f8851f036d19655e9f54275e5c957010e2717c06d08250f392f2cb7e47c0f056a2821d54a625622c477d01e38a1d718898801f2c9e30602266cf9cb859b336fee6d21a3185b142caac977560bbaadcfc578300e4508d2e7788d155bc3fdcc95ac6f5f5dbd88eee999387fcc3d9251c7e89ed4484ae0a9479004718fe8e88a8afc77fa59eeccd55386d93817f610d3bb3144e3637b5db3c9751adc98fbbb17a57a61ae799a15016dfda6aa3bbdab23cd5782f6281cb05e941403ff38d9cf961920f0812eda59200307d06195477b12b9c0a392224ae30db0e346792bf22ea7fb9e9c0b03cb12fe45adf6ef771a03865173b18b19e634925edb0cee0b4b0bf84cb5a6c8564fa7852cc87767e2255a2483ca76a1d99c612c2e1d541968f8c0284f3c2373c330f84bfeefed6f4b58f33f77c72b2cf2b65b7a7a13eee7ece0acdfafcaa87e0a32bd59f23aebbb2f2e2590a6627f8c524ccbfc21bdf971018b6dcb7bed94a09bb0069d1841f9643f3567ad7d57debcb95cc59780976a3e01affd447c6a385ce1738e78cf9a72659ade673f1693df52d60cd90a60c7d2c407a6d21f7f615445233dde19d55463268cc7f9d7aa916fa95de7eb6ff73281d62b31cb7d74f7f083fb17894f62aa8daaf39e4beb56cd3bb77a022adda4e84aceee5c25047507ed4450476d9df055729a8914dc9efab0753541e7d5dd6e3a56e8fccda84a6a139e9bb34c4c0b7b6cea3af8134582c9e9f577b3aa997912e83c7930249903bc7e0487e1990a06abc14210335a44b20b6eb26c5e91ecd9e482b41abfbcf3fb5049b8de29fc06ea8d521e48a33662e1e22b4767764cab96be1bacbd1fab3a255d42eb75d6ac61e306c9c1962eb2733e9cdc17bc6192721452bb754ddf61c8fefbf595ea79b552c68cec425a65f1589f319601126e494a4b050aeaa1b2fdedc803bbf09cdb3f305ff0df012fa88ea64df113818e308124701849f5f26d97d81cffbe673d307bda8eadf0fa90e4514edf7b1213807da9f8b64493d16c1e2a0540a88ce96b57928fbc1b3157cacf64b13f92f1c447f7dd5591c81e0eab99242daf24227ae924f25c59b40a78db79e8193690f8b1244cc29d995a1e04831cbbe5d895da384595f6c4a07380c5d01edffd29ae08ddf5aea7ee16ea51c21f04accf7824deb17b9823c2ba4dded09a28af1695f81152006565b1a19e264bfba2f1626c06088204791d636fda7fe6e16d17f2255eaa7b50171bc37793b8efeb0c6dc427c9b3aeb0f2599e846e7cf9844207d95359bcc4baf0563ac932f96d90bda7fc805550c7577f0b7ce569eeb6fe7cf69923fedc575f7a1a9c1c674d2a70087c680faf75005370bc2a199dd571e90eb0908f222b7f5d179792a27d6cc2e75701aa85d0522e07e36dae619339a1acc3e9597f5ae6776840ac73cf7e25a04bd6aa0655cb42abf75fce53d96897d43fb4ffed147ba230680de9cc05ea5811a88e003e3a85256a8d746b67f6990dff00d9f557b5845fc2f87ed1db1b3b5c72c427e5e8838a34e3915891ed1e9b281e96466d79e41fb97afba4db77ac491ffb2475bdc61cad95cb517b99846ec1d9ea0367501a8337b1156cdbb965fa333c65e3f946f37da818edca553a770167683a58126b3c4d0e5a6e29195a8f5936811c7d3e69ebb97be7e46631080b780e7cd532ba3bb261bab0243910c4f078e80691b28f0feea2b5ff775b7fd76b9cf77b9cee7cdeb50aa47ac397c52b9f997b90179d4ff1efd9704f1b46d719cf733ce8615927135c94584bcd204e84249bd1bec7aebc824f63fabc9e20cc38e63808d4118abc53d5c4066e7a74ffc090e7ef83e319982dda17e01db85cf5769562ebb46727fdb7a931962a83baebe760d1fd05dff4a82138010eb8c7a99382914b93611238d6e92bcbb766d58245b20bfd095437278bb7021495ad5748f754d5faf61adf2eb1d051f5cff4cf97f488859e4461ba08be58ed7408c7f46a2619627758c9ba5937c443f8a09909740eeb2b6eee228ee55a33b7e133d1f5db216675057b029efa5a05c7324ab3ebbf5195d1482bb467ce52d7a6b953a3ca9c8e3373a999b4f6d79b80eab55ff4c0651ec9b8799ba74560df697765dc9adde576587ac26d5fe423baff4371f7eaecb64580aae2407e03eb212a8750162be477b2e61c904cc7a6730b5acb40cb783ee2748ad6b837432f743d5c9901f893bd72a77384c11d0317155470e9998590e99d2809f48ef66c1aad0876085bd96bfd3ee391645abf35e2898adfb76156ecd93e10ddb52e8a9428965b944b745159023061699fd3e6850c0d317f2495adec5292f74bdad996fbc92bca4a3c1e00557d12befa6ce5294eeab12ab98293f4f2ff5e5700a5263504f4a1a38e1a12f4d955a8507e867fae69a69a5a8cfa9f3790f416a117fe90d91da80ff9721bef7b84cd8bfd64a49224f6c9e777749b80f96e1f12def78b25fbd528c1e8b41479d4717fd803d3a13813b83e092af954fb4be84c8da067f5d16d5006ff65873fc8ab838aedd77752cd39223b40daf9736d0299a2cc641bf85885b06fafc6457fd9e20e3f4b40059e3b55acb7960bcbe3eee4f2ca2a8b5f0fe635c431813f8a5841fd6854819f64abac8216618c36a467895cf73b2b61570a99c6cfa96064a1cb27b2bc30c3337f7ad87c93d0896a83422fbe73d3e0ca5982022c800d379583af254bf2b6bfe2197a2e0b972a48d00fdac1224576aabf4fd675ac2b79a1c49ff7a58252e0289f94096436da0a403e6f7aaaa0a0f56aa9f78ad76f47d2f52225de3a5cec835416be0efcb5ad6d648cf7d934942f1325eb3148620a7e730c4636ee889834c65aa751d63ab1b43b90d67a2e9b357ae2a71303e0a816f82220556c353aac427045190fc67eed4e4b6de8987391d131013a0657f3a5c8084c651e43a1947fe146f3b04b4bae4d916ba836512a197996ef32bba58f238391d76837e0cdae744f44719024af63594479fefeae1d4562576c0f5652c416f6220a175e8263dc20ae9b888590d1dfbf7ac965347e1ba8f45ab45db2c929b1e74fc8cc591dfc42377f2f9b1a334fe15bf9bdb3544dbb9d916456d4d5029dd1813f18ebb390dfd0e51f1f7f6ffdbfea80b5c615ac3c0eec813ac4ff0bc3851af1e3c27a41965a103012c1a0535fba316bacf26805a64ece6e50d63fc90ae839ac25a6ade5b07b0b4695026fd8a7d22d6164cbc14adadb7288c04d63f1ccaf8b3f2502e21c1e99a1f6af21aa0d87fccadfe64823c624a443b90ceb000fa63f45038db15d44f8a1547bbf649449afd944f8cc2ed75fe809816de79ed6a95c602d1456e61b69b6d676afc1d9fc3f314238a84bbfe885692ab8a04c525b4d9f8c0dfd1dee5e7529ba1feabb0fe691f64b52792a80bf29543e39f551f35c3f27057bb4a5eb5ac12b34af461c69aa242b5345ec125e0bc960a7e18f1c3f6850111b72d05e61f446968212fd215f53f3286422dd0655881b0965c793c78305c43588585fbd90f2023b062a2ac9998f731cea9438fb7636fb99220fb8d831dd92d837147678c40bf1c147322080e6ee0f61756fc558b1e235ee331cd83bf8de3fc8c0386c24f657034de53d824d0d57f4f650a5cea2ab5479c2880b43c9586a0c982fe0703096ad8bb216174e8d1fe9264b89f3fb471872cbff12818931cfe8cb357ad5c911af99588fcd9091d367954e9f2ff8cba5dd17f341e1d60c2a55224839266c7811249ede5cb6c88b2716c444fc876c10e13e9864b204d88814e77b45f0e5e6b9114af329c6eef3c6c7388ceb0833b5e17ef226efbd68d4255c1f1a7cb12125c6d73ef393f807eb4179d5066a9f5437a8b2d7dccf812b8cd3eb5704c2d392883c1ae5fdc0c26fb167098ee18060e3a3d5d52ff0689b659020d383a9e709d4cf47551a2d7e353d68fd93fe22c7c1f84e735d54c8beedff6d4cd6aff1c637774beb140e5956cb1d6df6dcc5b04d7578b163650cefac1045c443b2d71953bf44d752189b7d815efb2b4c28fc70bcb5373463ce137570fd51a6899533e6264c59e22aacb39c30b56da804b5c3138a75cb9ce6cc1345d7eb7e25e4601dae0c4c8624b3e2fa7ad9ec5bbdd4391c636d85cb2d4da2b5a920dcc3b3c15851a17ccd74ce38f28c885cc6693ab1c48856e07fef583a9b9d8a5bbe065e44802735708098a7a264a5d7087c39a1675d43881aa656c8d2187c5be0b939e55e1a5cae6acbc859840c08a6e03a28d51574617e76d241282d87b376d1d15a0a350940d7beff5118d4735cd0bdabdf34254bd3b0cd613ea2af25764bea5e1bc272dea315f1594271dcd9bd39d20b962158ad06d17827ade17ecf520ec1bc457be20a31b32d418ca75e9874dbacedfe5665e98ed089467b0070e07dbe87d5883f4ba6cdf1d45420722d8db1e14cb14321944f4f702c41fd808c1fa1b78e71b855014e931ce30f98b0dc028c4afabd26c59005dd9d49bb729476fc8048a61e98e1a4f6ab303a059516e6a05eef3a6628454be49a3fbc2c3c67299fc91376a55689d0d56d8b1be270aaf3c2233ec140622f2f4fe92d4de7831c42b9852d1aa9948fa9e583f5bc4d1f6a5f407d6c2280b1a0d484a3e8b259160f2252b13d2339991a87682694b3caa35ce75d1aaa79d1581acaaf120f6bbc445b96d1363c75db0aefbab3afd480c2005b09ac42c38155079ad71b186b6b7f1eb96c73c08c71db74d9c08a69c685d90c6f49cb3e3451425846c9622fe7416795361877f5219425d3c78b4cd1b712f12cfa2b2233b12e13cc21e7c816c53ec9f24bd131109196127a82d4b4268ceed3c828c64eab087d51af7cd3a3ee2719e7904108111144bbcb1a93f8e2a9e3c75b571ac6e9f2cfe52dc326afd879958f10a779b7d168bbafacbf8be3274f305e0809dcf5307fa63fac18d7df044a34d571f71669b61db0b0839438b5665c8a984db191f3a9f97b97e172ef68e9e12211ef66124db45b7d7d3fde51b5f3d03adb9570b757d5bbb440244c9657def69aff9e452a27a3274f6f60efa0ad092d244f708d52c62e82f910255964d2ee39fcb8cf67e85e6e336ca29c8c23d1cf4e0747013e4cc5cf796d1367605e34d5b414647c79179da4449d65f55bb7f9fa401cb4586884e3acad7577e937a36b8796303bb4a4e54883b43a0320299af2588af9ab165b5e4121b23257f9aedb8fdfec595ec22fa023afd56b6539d28d325c8ebdc5ccbce780597061aea3001775bf76cf53cc3efec4e5d79f75fe2901c9ae5951ef5bd8d57cc38ba61ae1adb47c10d6a40754a9b53c34da07f5290763d89d922c8c489cf5094dbd16e12188c211732aa8e11e4a2d5a8401fab19f853d5937e0f170b2f7ec92949adda69078837b4cfb1b86a6f46e0a6f0cf35dd7107bc7c50102af4643563a17c84e01e0a680af12ba5f194f69237b14d18a19a887ecd7e849e7a4e6a09bc00f2b22af46927c28e8505a637fa43c1b0c460c8f318cee33637590557aff37d764525e0446b87ea869b9764030a58932e387d049d885678a520f4d4ade1f0082ac540fecbaeda028247d328008e094e2c0d2367d109613974130efeb3e08c42201377b6e8f5e67ecb556e14dbdb128366fb0fb99ca441a918aac4d0e221b35372461c9005a4702fcbb3ec46ff46c106262d922f538b9014b4b6e2be48df84e80f76e85ee9bd7b368fbf4d5b8311a41157a130feffaac490f910f23798399ae00b1e990a0d6d7357c3ead8e26437a065adb64cf81157fce937013b7be3f5bd5b201058d6864e57c0c5fa117d7fff9a83f7febb42e60769e057cc8d34d57b9d2c5f828724069d8e7a85a3240e7371590570e4658251a583ef63142769b066c2cb2110c75680af27e43d173acfbc09afbdcc8b73f79857449374bd2405057cd1b19f7c649ea2d45d245e5717e85ffa221780adc200657b1fff7d76f686aa40dc808d21d054433fa281e52878978a3ba7d6219c724f647c9b4326d36a43d6c562549496edc8b18823e0017c8c074e43ec6f74f8be089493e5f2d185c6c58e77d5b0f66359b23cc608e3fd87a83818db836e97f91a8c8f7ed17845abadf64b1ff7ee788177d23387852f376b373ce023d2e81e26e6b260fbc0f37dc671e0cc3e1a4b15d1d0ecf1dcc1e4952a0378c2e4fcee7fcad43b8398d93c9ece40d5dfa7b6353dbb762bc10ed53d4e9c4321405dc87ee793a2af9484113284df9e47b53405a319a11d52abd897c8c06575bb5d2f7bf0836c20317d3f107ed4d1a1d566518cc3a6799c195450764e436ed926be7b8f2fcc8082e86e04f22e1e8802b61ea9c5b77a3bc751f612e5ed64b9fee41c987e960ba027475e738cd92664fa81318825df3e6cb190643126198b97ff178c83c88d496c7aca3310dc803748f52b686fe91b39ceb33742a5f51a1292347b28cdcb24474fe37b3f5db49d334c533ece2299b7415fb3887b49ba830c1c231ec7fcf338b0a211c31318bdd30f2d9d6431acc10ecf8b0a6872244321a2fda4e5a7da99c7bea5362952e43d205befa94e2e97926340a7c4359dba9d262b80c0f928cc0e2dcc875343247bc03990ca37058d1504dc391e3eff922d5fecb1570585d35c81e40397104b652b9d5c4c497b20c854531f28ce866648fe26bdc860b1c1b5d45d1c65fb2604eb944623ce275ca4118b302646695644a4c3ddfb22d43635c00c2a2dd767ddd861cf0a34ce02c38923f1178fb1bc02803d1a206050fbe9d69e8a9ba5025d9cb841c46f2f80a6abf3a124f1f394afc1996605126f3b057d2dae1dccb3e9d9e110a5e342ba57d6923c5ec9403bd4ad918acdc32fe38b98891936392f642d9847ee121bc57faf40965790d240692816986d1afbfe9ecd44d2b47a275de84ff0a1719b3284555e374773110809834946007b19a0c0ee455631a791fd519873f4949e7bd4c8518bca3a524de4b39bc3e5eb52f3fb8eae983ba137ef2968f0688400675901a73dd0fa4a52daae4248f8a1e1048e89aaea9e66e1605994aaa79e9c6202d30e6a46222c3a49348375ec76bd16f717dec915e55b08dec3ad51e1a5b0e61ecb47060376adb9284a6d3d1a1699353474c0f89f8bd4c97588fb1222bd3762c041f0f1741cee1eaa72e0f75af553ccb66220acec94b5453415503b46a34c481b908a6af662aaac0a6695ee2c99aa9389c6dbe9836200627a57a2a7aafd41bfb6a96ccaac2fc23fb88ec6605db3342ec3b68281e73ca0e94b639374108278bf126e90f4b1bdc3e34c06292aad012902f2eb934487172e9f025694a6452a75a684001d4ff55967c7fdec9b5c9ceb0f804f6f3b8622def5662330372f382d52513b8c6476ee3731c4d7803515b90e05049be6b4a89983f0843e1af7b981d8308ee3ad9f8b8a33a4e918c365f2c246556d30cfbc490bca0b382777cc01d6bbbfd46c6d3928bc9c083668d5b4c4672d99f7cd5f114a86e2833b072078e769523681a167f5c96eabe4e9e89d0f27124d5fd05f9da7126c67d95b61768e305ab0f2e958c54ac59ea7c690e70dadc9a9a4407f8caa92adcb567e7d108c00c432df1ccf095b86c2b94c525020949a89c86c9df44ee10d62385700b60078999ea3c58be6ee05852582c7615388662f5c18a21a2adc6e27ee38d1e54cb0cceb5faef75ab5854a622885745d8b2bc7665d78d1c29dfd959fc4335c98f7799a362b4d78744d40398960dd8707f94dddd36b5d0899d02772179b2056638a0d07620520fd36459ae6e88048271123c51f6afc33e985909503d6a752f08a434bb96940365dc8f1a513acd3f6a936eac07b169b14809f6c62d31531e95ccadcae46c4c75d7ef50f580a0bf68a54982c0a202183a0e88019cfd6e2c6a8d6538069c17b9c89daf2ae527d139bf83a4da3d268198f8d93d0f0192d876a3ba990d6933ebfffd893e0257117fd1b4a684cf4e768aeed50e9dd502e6c85cb4949601c5c36ad4e06af2b17ee5536bf64b65095ad2523cd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
