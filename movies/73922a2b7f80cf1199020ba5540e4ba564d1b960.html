<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"994c3203153580e0a1e1938e713e0647320e67feac1b16c219c99f339d17d1fcffbe2dbd92b5d0fce777f14eee3e0e6950a794a62c169025277fd1a3064282b122e74d5348f500640fd135cacdbd0de2734e3da115045027e1053ae374c38bda9613b7a120ee9340ee1a60481ebf3854b86860681a8bb014b7364adc1359fb65e478953a2dbf21c26f952b456adf3137db84772337521ba4b3d4f54dc265b02904a64655ee2288286f34ae0c209d653adb5408469660d1a7163fc190912a2001cc63495a8c27b96449a469b8dce78f883f06cde45e3a07bf08607c528ae9843136067206d6c7a883ffa9cb5337ed49854f51e0869941b5934ac0344a63f75602ae5675632f6f30b8ce8eb05371cac0f66222d2d5a75f9db7b07530ce3c57bffdf12b59676b8f71ff6c5da2762b511a9347af344831a3833ff3cdedb0f84a06306b12dd5c3c2ce0ddc80a1252e7dda8c94dc3fa852bf64a9f44b006bc506e888d8588ee395a6f3daacb3a8d3e82d276aebc141900c69c7cd5b0b18271f7d3c0cb1f4b63fa656b4e87fb8a5c08acc6262776af5ab006115a3ba66fb53595513a3bf14153db26e5e0329628e23365641db69a8cd7f313627ad564f1ef198cff837db310298f16aca7f008b58a2d375f67670cdca64cc5f7c256e6b03e1fcbceeb5fd32f401c8cfe548d81b8db32891e021bd8abdad1decc7f5fba0e86a12542821cf0cd813a38dbc1e3e0bce5fb13cfc6ec3f5dacd7370463d4f10559642354ecd408fadc80a958081827c8584b9409cf91589d7f245af5a032f1739a5935ed8bc6b064d84969c43e293df9bf8a99833577f966e6898d7bce12377f52018c435e19b376381285749072840fefcec48bf1ff9fbf2f4e9f6a9162d3da23e16aadcf94e963f3fbbc3ce083af2bfe068abad5e348fc56ee9ff71a9add326b5c3f9ee90d37b39537e9463a088f733c3b4f59ca404f5673eec9ad30e8a84fd21d48279da6eef288114907decfaeef30d3580d8bb3f9f65c8e89ad7fee4c8c4fa0cc75b17160c721b1e6e15f84cbb5d344c770999983f44fc06ccbdf307b9082ef4ad2bfdefd11f2210e5139175dc5342e7c64b63bdda3be6c4556a5a2696cd540e641afc05365bce1ac6a77567599ece1677a59e5996be8d57f20fa05605ad05087a981c610846c7dad3d36d1daffaac7d801e9b2f01b4a0b87070fdba901b4bd5975394e514d1c3c4f3cc3823743f67041877003aede4750fcdc50da95e2ec018c3e78dead99acc5d236ef9c928df62487ed3f330aee5fd521045adaccf9aab833ec367e6a16783a70e17d29bf80dd05458ea1009e4b74860228ed5b2cd1155523f3805db19c4b066e3655683970adcaa317306b9a80a8f6b28d8c24d46d846ce4a760bf1e88ba6f9755731d538fcd1b153c56c92a10ba968ca69ed68e262019613b9f23aeafd1cff4fcdb8936491c8c39c60320482dda4066a5365c0a984da9cace29636b60f02ca7a2d3dd6de46728210a2fca0bcd505ea68719db0c3fe284f5facb674a94257c11f038b9ab6ffa3518c1c28918dfe8cde2d03654c2666c89330d9f6d2eee2a9cc2ae79ed02e4a70287e0129885ff2730f01118c83f7729415c25b1fc08a91b3ac34388af267a0845921f5e829f345c6fcc88cb8fb83627d07c911ce19d19166ce0fb659ad8a55465c8f52f3a548aa6cbbce5afd2f949b88a74814b72dae625a058efa361119312131d9e8851631eebd1b927488a15caa3673776fc9eee1955c6f02a8be4a33922355ca43424c623ae4cd209d680ba59e4c80d685cbcd9c388efbaf9e94e42d3f6872cd6f935847b39d97a7d7a435ad6b98f4e0490bed9df2c70388c110e94b01ad41c81f23f68d466374309bdc44dcd6603923a24848728f85eabe0d097468b788f35ea7a651d278ea3d166337cfc2a683826272529e173c76a3fa7ec4a28763f47873c7c9d824f8a731a8fa89c20807e1f08b677866a6aefa7e8697d550aa71dcea027610cb95d10cc7dd3b7f3d7be60fcf895c6e767b91addfe4c0b551753470b3ff75a0e1b43359cbb692bd094cda7f02992fa547dbece438de4eecf0cbaae152066f49d36477d4fe1564ff322944708dacc57c856e5ba5f8ff1ebfd3787362ea4a95df59bcc88e832ab6ed9886545b0bf6c47a25182741b23959188631e295946d07464b140a1a6bd5b7f90ddebd54378a2c2522b2711073603b04e8cfeabe15c9135f17beb1be60669f28afea03266360b621c34b13cad71d6cfee2b7535a03918e44d6e4b566886cd6415073c9a9957de4a79bce6cb0c1be4a4a184b979c278f875d2e3a39d2951779e610474fbbb504fd312a12d2d88195aa8bc792c9924c1f2220b47588a9f4dc2873a0f470def3cbc3f919835e06eb60b75dc6978013c4f88357590b79a1597cc0233a7f82594eb8142ffed7f4155fd7394313452cb91c24f9aa58585fa42d0b38e57a4edf1f11a24c0135487125816bcf18ab1856ffabc1cc7465b8bce0ea51fc51bb64308149acdc775ebbe10c116f73562fd88a4a43e1a8a715a44ffada0aa705a42de5de2aa01f2c77c2954a536875e293aa4c1c9e482248e121e591273330ce8474884e117ccbe157afdb3469818b7309516cc56e81c09d34c2a3c8760e8a0e6795348983731060baae4f0d47b6b4e696259a76620e0ef9c7cd0ba6b372e13657d3e91c9e3e7bf1faced0b991fff7e661bbb51cdf6ef21ed17b15ebdd9dd436b9bd3ae723c5290154ac803028a983845135a0a06a00a14acba4d5997e48209be64c034e875ca0cb51e64eb333e73a823ed957cbf4bcc716fd2eec158c12461865321ef873f7173d907ce378df5036fea949917aedd37013af16254e12f5b41db1ecff17939547f447ca8545f7cfd6446fb643e8e2404a4ac1aeb092f3179cc196445439fde9415f91395f815baa1a5000553421c0648bf9eda08e50978a01e7e39af87a06c1fc772df8d25cfc9db3777bfe88a6b5034b15874d4e3ac59b9c2c6d8f58b4691b916e2257458900779daf593790fab4e0218dc1e0eda8699fe4ccfb8248dac895191031514de04f2efbf3f6af843ff20a8652c109067ed04ab22271754bd586ff2268ece4717afa493a6d03b1bd26aef772836f807919239ddb242a1a2a8db1bb7998f9b23dbbfd576b860d91cf57002acc36f8ad31369e0f25b1367b2a31e0f2216e0bd3e4b964065b921fd39c452236c87ac8711eb5004835b141d424a385fadc7e8f32767d11a41686df4b5618c1b16afa62477415f3fb632b204054d1f6fa7730ca4634467d9ed721111b637fe332c5fade716f0181c2d00a5112fa622f187d38235e1b5edced8ad5d92bdfa8938732f4ac93fe53460c30c52b76d01a86add2c533fa23c4c3418abd307e99d781a3a6e3b12e6c2f7fa9ae843409749c7978502f6403cbcc98af456ab831a197f9fd9713ea422977146e7bfef012856f52311f1c4d6df3f39213374176863df385f6fc73ed90d48753994f292f020a66d74930d0eda0884e198d6d0a8e6f3e4145ed9bba69a1f874fddb355e18b1cea60614005fa7137ac574290220e2f3ed570821f0fa70f6a30001c34011cefe252aaf2aa743dc140f94ea514198e0f23e809579dafe53aaee1b4054515e5f5be78c199b04722b6f234afb9cd55c66fec9375263210037c6d9dc81bbc5a9788d8818a965505b713ebcafb3940b25a6fe72be1c5989465316f22746644c048f80345f386987fe2b752fbf2d4fe52f3e47bdcb9fa2210455a949cd5a9f05df0218c5b160309cecdffac7c2d57d0c0fa860bdb85832a5f1b8ea59eb2755296ed819ad0d936464a1d84d9f6145bbe5fe5bc9772e0ac6543b939674a4e9ce87884059d73628775fbef6fc11e8372ef4df9c0945d89d42ca577f573e0002a0d27708f522618637def16e73bc663552c6f56453824088d6a1eb4ad48bd25662cc1e4b3710a2bbe7063ec850e51a868f57b02f8917ab1db0a50203488a50b4ececa34960108ea8dcee02bc11cdec7894f2ccf31498f7783844a7d81cf97d62d1af3dea33146ee71c7a6f728dfbd62ffb4d90f3c4391f3c04fec1c33c29f1cdf8b8ecd55bd0406e12465b940e56e8d11ec0c631bc5ca8b36e410ad054d417fd3c309fc8ae8c2ce035188fbeedecf82986c28e668641d09a5963f18d038128a1858eb17e39392b2955743d5d21c04dc55729fc364bf2dda93c86a1f761f4d57fd8971d3112077cdd818c2ef8e7b790312f709cddb197b0fec6980c9828b8968914a386d2ff0ea978748719b547682e0487a085a8ef6556446f4d903fea1dd971641c8e9b43187a9a84c36562e2db80e6c2d780928daae592921a3b435f7a628d5fb15c9fa35e704a59c559606bfbcd1653b0b305ac95c39c247f9ae27813c1bde4da4a615bae570d5bb0601f42c1f88caecd89bc2c2af700ab5f181698023dbb273e3021280880dcbd5c0ae286e990bce258bbe28b06c02f491cfb458d95088f405657daaaaca31de76ae27bda03f80e749a7abf200fabe972dc463bf5642a47437692e6e9d223d7eabd5d955a74c42dab9dc65725b4c33973ef0069800551a278d9d93991ec8e93cb7b4c5bd13634df355a018fcc9e5be36992b71e76f37857d11be25110c8ab688da5450678a96ad2af3be09e814e539c1e4a142b7bb3457a8cbdcba6ffbf7806d2ccf6236d01c2d340e6b343757f89ef9cacbf60779a3849c34490f00db48d53d56738cac42b228288f996aad94fefef44a779f0b30b7900a180df2e9696daafef414cff191b2627bdad2201ce479ce856ebbc01c7a7cab78d99ec05f5007a9e3ced83727c714d2c8e8fb41db670a9fa131046e5cc081d1cdd1fc68103d2719052911ccb76d0345025c154633151720a6fed38a697b249ac8cd237080e07a11541ea9adf65333699d09c82cc1f3da86e3af69ef783a3e7a2da4ed3f7d1fb239dc6270db9ef7d4ba156019b48d07407bbf06cdf1ba938dc74e6b4b3b691557cffd590a4c38a1a1f97e4ff583a91933670f32536133f5574d0f992e6779a683d70019fce168b074cff4ca240cf915bd3e709001e0f7c584b206fa4d90aba550660590a6f82cb6bdd422cac9ab5b796f6f25db35e44b6572101bceb001cb9668c989f1a87f19a13e5c1a181fec4ffcbf978f042467b7c7ffaa4ac9486beb60319613ccb8e610e02839839c61ef3d5be270137aff93e02e99a55fa8364b63f520ce7334f6398735a7a68cd9a1d06d788f36c523f05625814ba1a39302c9441a15bde4b67a4d86e09615de772b29c765cd120b374b147b3f2e8eedc4f7be88a9cb863617e494f0cfcba0be7658be32619be8ca95224f17b897ad2cbee09b1ffa39e0a1641cb904219b1f7735e53dd6b63cd41b44e8032b5cce7699f2d4777a5f39537a1cb944d1b60e821c32bc0f6f993f0281e3d33d6b664b5964a5d340943406b59ef0543ed7398972bff6d235530e813c312926578c659eabecfa0837aa0c4bdf8e494ba2633e4ffac092ffb6c580fcab974d7e43b598eac4eeab4a8bfbc80b3b4f81dce784613783366905dcf6b5bbd934b24bf8ee70bc312fe9d210a58b8b3b4ab72df7de31f1395a4f0b453891263d4d78f8a94412743bc6f5cdec9c1be2dcc681bbe04c2f9aa58eb398601dac0cd782b239f75abf018a607a0645432b1f1ea60765925a840d77e265cc0c7d748b3a0e96bdfb092af2458d52e6f77db7de7d3efa4f8f048a1850e9946fa303e3acfd902a7dd1ecb223491499dc09a07e3af2815e3ba87472bb17605f25908ef2e19c6e7d178ff1b4201efa1e36eea53dda0bab17566c21f67449eb091cba5138f54799ebf1e6f7e8ec2df823e0211c4b7854dffdde51bd889a9fc0d4fd4cd0089fbf0b4a6f566d6c859af82a5dd4a387ecf1b8208a55fd5bac8a8ad735968f7ed2832f34b2dbc700d1d3da88bbe4e12df1041deff9187ca5753b3e601e28db491bb871ad1e5d7be1a893f467a6cc1425ae25aa0cec827e9c374762de95da0744afd5346007a5dfcbae6eaf64a13cbabbeea6e54ba52b92f6e527958613fb0aa71d8c4e60bcb5342d334abf9645e6240a15912f00cd5cf40aa322d313180d957c4652a2fea57abe523b4f04c5e7e973e438f52adc4554f80f93aa70d8a626c20a9cebc572cfcdb6f2761cc1f6724075732c94f7347e219afd25eac3040e545b53ce6346eeba220c9af3d991c3a2357a4eb85cc3bafa7853ed7d032430e965b4c2ae52bb2cad907ae7f61ce531540e91ad809c1e109ff6262634540251369ab2b34239af5d92c6bfbcf7caa458b9057ad1d9f11508f9a72b310bccf4a5447b24b57227ce8b1bcc21d4bddc89757b01e497e3f3efb2a038694a87a32c24049266edc98c07bcd88de9518c5d3dfba60a3f51e6be57068c512e68ad92a11dc88e82f29d1bd98c63c2368fd6debce1075a896711958980cd815edfa20dea2ab884a93a2d68ee0c83191e873daa1390246fbde79c63b6474dadf4943ebb5474c1a28f7090b94d6d97f5860ad6da823c625a82538e0ec9cec6aa39ebcafc48682f22f03f0ba9abdc7a23f8c8de072a4ff6c88f92b0c9020593ab30b93be98b37a10a821373d19d80f12a811d2dd55354c4eae864876082c9050d77bdddc8b44c1f9f0268ef6b916d9035f64f24af886a67d2d1e20d8fedfaab41c36af4a26f44f2536ebbbffdbad097d04b02c9f324325e915010b23f26daf2c6c187ed452dd00174b515f25aba4829c01655031df6ebcf4c2234c1dd3380e1410784fa529c550bff2082b3572bbe908f997e321f5421dc63874dd83c2ff80531f6c8ec9d14c6023c17fc4a25cc8e305befac169ccc911cea5d2ae1bb3e1ac1ff2adc2b8181ab3fdf6e0563eb1191b5ca6138e1f84693fb2b214ddaa0a9557609017aacd821c3a72a90d8fb9089317dfdd3199feea0617d4c1a222e161122e7010b4d99850cb4e35c23f0af09e089f97b59a3c1baad6c3d6a57a08d7554d70cdb28563e458266211bd1c6a09f659e51a4e7abd409ff95c4e06c47dfb04301a359a5f6dc22a34e820dec1d516625faef4002fcc87c14da93b1533a10d93d0002040c04fcc920fcf925581346b4bf34278d64466e97f8e5b9c8b34d4ad25585fdc1128b5e973cc25c4e08102103afd71e3aa11419b86359530cd049479fa0892fb44421e35c551dc389dc7c7844edbda3cdcd764655e31bf728cc1eea93818b65e64d64c28f97c066b635d8ee911a568c434d14a7cea8e6edb71fe36d6606d75bba671433403e9149dbc0c33213ab2877e19762778bb8d779fdb958e506491b81509c54e5432eec7c95a91a3900209598b80173f58c0bfc390647d2b1cc8843923488e4cb2f8c7edd2160da82e5a6cba9dc1f6ce9046a2f31b257bf815eeccd0155906a36e1293b62857bafc3ef142c7a590671bb3900085af29dd91cac65e020c31b0132eb8002a6cdb0c603e1d06f6c8409815462b192cdb6c9dd696ad527a8b7afcd086f63e0682c5ca1590ea44157fad80825ca180b0455469ae6a21693133d7ceae0c379a0360e3df505bcc24c22a41aee296d21d17407bf68d05e7159b9f7adf3a638c7a15d5026b1b1d807bfa76c505fdda8d5f849fdd71a7bed3d82c8e3b0b50a0ddeac0a1be6768f2c07ee49f05269e801878d30ea03971341f5a2fc189d36f5b183a2c78e4c5bc9ccafe0fab657479d1a67be685ad0321c64d1673ddde68f4eec1ab62e16e7f0d7ad0805f4cd07d1580a07f108dde6766a35c9125498b9a62fa5fbfbca913c70abcdcdc76cea9d5c5eabbf7f97b9632c59495ad40e8b71aa22f9d487cae0dec8c3eb6bc3275d4ce1206cbada8a146b8b1fd1e75eafcc0d654549367cd029e8b065eb76cca43084c49fed00d4e50006426d73d31888a917c59fd510e88e203f2aaee6040a738a7fef3bbcd364938b3418758cd9c6cde3da50f469932599e37ae8a78cd4216f03250cdbbecb7e290fb71986069af2318e531633115c6cf3dc172ce698e9ec1ca96f1efc88a9547299e3dd969e37b10cca6db67f9fc6fe0ea82a088d795d34ae1cfdc4e5ec37cb9726d51782ec250781230b0963699b6e2c5449fa596efc71fff6eba96f901dd8353ea31666f38438af132e504758a8a388ca56cab020d94ae1a067dc6c63f02ad1f868a2ecfc01bc6171f5ba2311a2f4c18629374131b05eaaf8207e413e60053c728d0a7c63d09b130bbd94625289ab17d28408a0af9301dfb724a66bccbfa41c3eb04d458289bfa8b0a92f8d2f2ae8784bcc2964a9d7767ac5b6f845cf24120d391070b91a905584624bd797d5b5d98c6a2597cf4f9cc53c3eda806d5810e584005e1f91cb1fbf50b8caabb46cf0b7767b1974c3ad0a195fecd8d9f0c2067f89b3af0100c1519acbdf61db668356d7dfd4c6937aafdeebf1e51d4414e1ec29107dc65bc3ef60e9b30c13d61b92ca447c318c8bbce6eb6815161941144d37039c408ff1c6136c57d9c9a729ec8c837f31afb55509cacab6cfc9627299f480fda435e0ee901dcf788fe69aa5c64c3a6dfd2ee40b30c69b4aff2f6e4d8c890b0c33e64d0e983103ad19535dcd005197bc5120ea16f6e32bbe0845d4268e67fc2322213e1dac1e4b68324eef35948f259d605f638b4322ebf4af2d757c4554b7990446930883255d46d9bfbf0a55cd7227c7077f4a13d5f2ba67deb0382ea8de13a4c8683960adf21c3f2e4c0ad7e894c4c2d4270b2b3ccb5462002add4c0db37e8e5189931831c6e9bc81449167b2759fb0d719d34bfb473c4569ba922025cd41b038f51b1bfe3f0ec65b1c092f2fbb2b5786631ccb9bd5d3b2f050109b6987d0428af78da0c810a6d6e5b385926f00b34f804819634d8d38da9f71736af43b7c4a38ad8d3c31677c2443488ed04d2d0e27516e94886d4b7089265477423ddfdf2f24a218ccf59a6c567a8a2842841b5b63f7c2fc834cf134f335d64eef7a92054328e6d08cb87ae01f938e0bfa71174619c472584fc3997eee5af8f4216e9e0ba3c5bd92b3e4d3cb1a5d0501dfbe6f22b3cfdf909470d94486de15ba0378c540ad044e9578583b4f11428b4d5d78b622214384e7eacb0f5f0b57c3f46d85f5037b4ef80e20f3c41df52f59beb00922a4b33970ef215f1a17675ced6d74832e9eefcadf5a33e8a96f6d07c1023f42035d4c52e314bce89270fdaf42b0c8bf80cc251d3d183deb6405cf9749881ad0f23e57eb602a195897fbbfeb52f451cf39eec35b588c88c5e43e93ac9428545571be1275c0f53d141ea09b9549e485991f3eda77bd329d3e8be36f68f509ff041cba3ece24dd9274d1150ad3c934e74f2a3c8e8dfa8064a230b5c6edc029ee1fc3e65f377b85148bc5dc9c5265c5a020874fd69c8c2dd76c5ce360d664d9583efd22838de4f3953afd92e0d8f65e906adc09606b791ae252630890b893f147b9783c468d42b643a5ec58c84b1c4d85bd583dc550bc7194d60acc128b9b51ccaf796fe349d7cd9d397c2819804032b5bb6eee62605e6a23f58597af25ab68a219c715d90c97bcda256364e55689b88964f91cec4c8a610dd59bfeb4783f953fd70fda0b9908514d7b499daf4284a93c82ee0a0f171568c0701908dcae8f0f7953612a84dec99f115752de7f9ae9974d51fa4127ff19970b308f5a9cda98731a6d325a2727c6cc2037e4819f72ce9b99da35686c3adeaaf3ddd267cfc46ed00bc462f0c761a565c8ad3fb1e9fa7e7cc4d59aaad72fb83e838cffeb7a0b29d0f9a6e6a4007814761ee2978ef4ee4f5cc2177146246f8730c45f117edd8e307963c916e5f0535a90714526b8facb3bdcff0b90b494bc8ecfd681a97da131eb4a62142db32170007d0fee6c078f5884112066db64910c233aae3936a00ff2e22c10bc389ca8fb37f46f514aab5b3ba5b7e1be638542a213933cd20e2e875963a8f0976aa6b1e95961b7b6d2e91916f3c62eae89f7fc64de802b6d8348eb927dffc84e58ad984efa5b1ca66d4fce4d887982045f45b5218caa1fac0c1009a446b7ad1e76e2f35177d11bf375b6692413752445fc91550b6c035514e9ec1f09cfcde9c54314e4826a442a1cedb4c55ad95dcdb10e770df5774ee3381bc9bdfc2c508425140d9ccacdae42ec1f5bcedf73ee05f2493a58dc89a91a9eb38184ecb437d7d6d2494d5bfd6ce456a5a834ddf29a98b4c4780d67a87ea745f0cb7785910ef2d38e45e59337e03352c0f7880493fed3a857f11aa41dd76d24b5d9202307ac182cb656bfde5eb8307b80642f40654dd0eec34cb2d4ebee0c7ee7fc6f4ad9682963939a7e1e8b05c2478547f52a063e482eabf9c7e85b4b64d4f97051d4119b9cdc3849c0e804d31b9b0473bb43a31471892734ee37764bbd04adde6a4db4636993fdace0b59c84f6620819f579eabe7f6ddc780a870af9eb504bfaa62ba9882a86351a3f808373329f26e4b10cf7c520cbdfa15f8b213ead91448b70fcc4891be550e7209051b0e79a3131ca80d059e86ff1b1f772a74473c6b3f75865ff3fe66d235e49c1a1ef108eedfe33819e876fc46e1d63dd5616cfbee2db8bb5320377f82943beaec19c9cf65f98aac7b1d4646733174e82dc8a838aef9002f6ffd1237dd1e5afa5e44db8466919b9a39a3401ad4a109640c0c08f7c73062f5c60ba700f495c91e0e08bc71bb70c4120f4bdf94f0a09f057b04fdcc31c8800b7e65760d6fecf834adab9484e724f5e01906eb0216d3b408296880c4525a5474e45128b489fc2ad65b70b7c19c49374b4244ee280b31cd5be12b93e3ae6b1b99e068ca038cf5a5d39462409b4f7df5cdce827dbafad1a17bdba76896a011daf1c773d78c1783536621647cb59d6e0a6d4c6d28325b96549fe489f8af67e2da265e588e2391b3b0c71bc703dba6ac1c602801387a2d4f29a52bc617d63ac5998435403432c357209bc584fd129ac1342c988cb6fedaf3df28356c19f449e002deff3dea16141049ae3fa81fe8ec1c372dc82836db60795fed4bdb811c06502387781fd572c81ad87b4aefd68e80350f353d44b9b6d231e3bef9879153ab5c80fdeee019c7e6d0a0ea33b351c0c959638da5f3b696acd10dea4642babfef929c91db2ca025b4caa8d868d07fab3d45dc50ce456e89c3e1c7dddb85865991adb97ce7ba2a4dbcaf8ba5514ffbcbf8f05691feb8b962c88cc8ff87f3b55e3adb751a99e5cda09b184624f8e90815fd2c17de21e6d89be267e33de3a120dbc1080906ef30286fe7847db25939a0a68ab23a0e88fdacf81aa2c55a25af26bbbda06dd76ab9565574fe6107543c5277e7096d010b575285265d337b7f7b844c4f9cb2d604474b2a8e9e0bf724fa07f285471fcb5d0d8a6e21c80eebff2e3dbc6134482ad54b0cf1d9dc2ff3a600c020932467497539bbb17648204cb6ae7ffb281a56522bd592097699235ad209bfc87b85eb8efada4eab7c1266b7d5bd4de22f5cfc6cf84d962e5a117df60df1461c98a4306e82a92db04be49e094aa889e183f90346125cc15e8fa27623e41f2fa91d58d8649a68ee9c5ec9ca36087e663b4022228f76667f96851c8e75cf3cba6783f81ad78a804e2b1e5a9349e0b50fbe790b8d2607cbb58d67b0ebc3fe80cf63fad1cbe7c6778d33b0bbd2d4fa1b57a10201f3d97d84c8058f418835db3ee7827c51d5e6505d4e986ab8f4d0ea19cc1d7c1366d954dca283e7e01e11955e80053bddd21d2c220c01e0d089bafb5f32447f6b3b8ff89ed1ad59e20ee8ab7da24992964cccd9ca553e42dbd108efd25470b3909b347b8875ce18dfadcf71e6a9d391f5e5f85550fe3c63ed7780cde8ba49d2d33d16c6b150af206dc2f55c649eff0a202aa1110c1df577eea9e3767843dfb4a5e732693c4c0736e82eb29d36502b99fd5bdb455194b6590d497da2b2725848af1204111c9592b2aa1dbede9e1558f8cab123b0530d4132cc257312cc4ae0bf4a499902148eefa528a10a265214ab46ff7a145b6d9dbf9b6f2495b2a1631347a0afa6f4a0a5dd7d7f253f11597ef2b50cd77116863a406b76d27c0d01eb7e2fcb429c7e1746e89b00f86170c2ff0e51e45d5ac8d5ea59723d0f6c61f9b04ca173c58f580d04e70c12b7e16ba00f0b5636235a5d63c39ba35715cd11a363681b0ebd5e1da294ccf65bc64d81627db222d32209ddc9971d71a70f2169acc92253528cc43840bd5b9b399f3fc44dc214129964323811bf115cf40cd92946ec45ab0e81c8c3e0092bf5255e7e57b2cfbacf26af8730d8f5320d10155a908b71bbb25f4b400fc264a1b02f52de1ce9781db4ae65af5ceb0559ecd61bd7a6e72fe46ab8b4d9475ae5347a69a9e43343507f83c49a5866aa2249dda5cf40206fc3f80f91e0fc370f2d83662254c6fa5e33924d725dfdb51c01eaf8d90060313818a078444a1f14fe50e24de708945091671e3b497a6847d56a7a63fb36002b05599f94243508a4be03f78d45d7e0fcb59688a94ed94663a323ed730a8b0ac7694409dbffd3ed94731e220b974a89dcfab487cb978cd1e23abab68fe73105d6017912b88a734b85f18afb6fef95bb5a77e4c96057e45997d2733b449b4efb161f28208181fd8292819877ad00a849ee9d27f2c1e0bc88bbfd32c53afc3dbacbfd29e701ee4b85e8748f3300ab2e6b9a2a18ae06f96b7f232f099e8d8b62c4190954ebd78113a67a557d4b4bd8c0e3aa146bc8bd3772c9caba7481b8d995d0ef31818b65d544c7356f11ea27c491092ee0f0e8790943a498cc0f3cdc77fb297e35be5eae1c68b421cee465565b0266b9b75fc55dab16a3d034f85ff10c7798b00a6bfd92da99c37466609d6bcf23abc2a1e3a2777f077bd05140d3838a86fc3c8115ce1180dbc20","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
