<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"833352fce01f04f35d5aae9c9dc7fb99fe6f78a8c786cb35711e4401a7a73c9091fafd654bac6fb00275b7c1eea43bceca55bc787fb5fc326d9ec9d37de650e9c917b84e389d8c8560b00a43173bcb006796f579427f5704263f0650a274d3dcf895376e451bf123cebc65e61ea5a23dfd2997dd011c708a5d6214d7250dc84c5d221619da022c0abfaeda5267d43d679033dd6ea33d60e1bfe8d519c889f69acdd6464fd98b4c03a33e8c71ee26218313102f5535274e1b29723f6e1c7fd4d9511385a2c7fb00e0dde41a16b9a95890e3918c23b0f08aff84ffd0c4e04df369a55c9bbaea0e2383032d0661c07faad744a3ee8b1ce475a25e3b07a6b81f50f3645f52e0b40a886c3859bf2a2893656125e46accc4a40d6b81c7dc506067ea1125a08c83e20753b0183cdec2c021d34da2806d4d4f3ef4519ff4a90e35dace79548b763b0d8dbd5e313567ae50e6159149404d73f828ca7cb19c9fe1e3f8c02a838e4a5c270e075569634b2fb42f21ea9ace6154f11941a86afed36497b537311f2e251e790a96ae795a4a6a98d379c37c993d4bb8d210bfbfa9d3c4e9979b80701bd7ac3793cf5cb7bb61d5975dd6b660f56cb12c400e42aee7cce15b22ac02f520e05282278bc016552e22291bb7b8159719783982f02d9ad8022a6da9c636ba45800ede396adc0ca64a7c9b5f89475b3473496a96f2d89a2da92e32dc1b283e66d8d6995a450aea5dfe7c8f9cb7fa480618d53b48e161cc3396dfdc7dbf1774cefc00b3e3e556ecfc9793ad01e7a6a79c8bfdd0155db520e6686b2bce77b1cf45b41ccb6966009c548f99b8e3d65617dab61bd8e6bd6efe35fdf5be9e2b604f1be62f70e9d89b5718681e54533e48b05499cd742d22991aae1bcd925383d5dc6902be27aedd249830390d81184c3d1c14f4297525c55da314520e0aa0da19116fbddbf9acdd8362a3a83c405378fed90bcb7ae4561ef109d7fb8a3f1bedbafe4a0587218ba0c2b51b0b77c9781946b43c03d12cceb8afade99d4fab266e97c81865524c5a6bf8e63ce6c68fe8bf67d94210c632b4b7e7650f7e4f459682ea68da1df0cf162fb8fac9ef83f13c4be601d49590ce690b9fe2430090b5fd1a16d5b1ca164bf6b4129a7ce0fb24ff97d6239dca59192ccad0696a75bb9e18bef7f82b7f59a42aefa40f14a22860208b3def60b6914ea7eb9008729f90d13679a0669402fe16cfc94bdd89f89dcbba1d22d431f38f0358dd2d708058281cfdd426ae45aa8f5ae63cfa28a567ccf5175361e0f48f82632bed33c71b5ec3e352e878a0cc72ed51f065c98326b46f89a3914a2559f5cb96908b7bdb541dcdf08fff9a6acea72d3f7c4ff1246ed0fa677d10566fa30ed51946da037aa77fc5ec814630d4e96cd264f31301860d7e6d06121f7cb5dfa4ea57e4cfbf142c009a307ab224ea946413898c2b6f4c0e73aa47b6cf1d797b283cfb260cd11d6889d45ad53a0894b1561d53556970951f8bb0dc15f0ef834af890d2d718463ffb3a23f0059424ee9890789c65bfe210e4689cd8e4d9926d05cc798ed0d6a4a689151b4b8c83c79705fcecea044e87e8ca687a69a359fa531ad0834c5cd8322757f24a8629b5a37078a651e1e6ca03d82d799c3d01169c19a0e379c402966328c06f505ecccfb21042b506755e8c34d80af5f24947b43de3b23ebfeb451db061d7cd167fa86eaf833b12306a6fb42ea1c75e0c577764240f83861446dfd6064ac87acd27586d829c98a4dbfe953a9510e682e7414a0fbf72262c93fbe15287c0e43224f407723eb70601c57095543decbbdbc06e198239fa0676cb4fc84910fbba9054e44b1352c45cec1c18895090657a539452c014db67c0cafa5d341bf8852622e5c148f76d00997e82e532891ae123f65e605c10140381b71127a567dffcc5bcc8e7f22bec764f22bcad8fa217346617c774e84491a0da162ac56f6e4c17f538057bf0f9970a94b929405802781e6d99d953f948ef55f5db65a0f5d647d341b00c40656eae79e187d07372c715b312df97a993b898813c64634b95b8f8b116fe2b7c0d6846c5b6d32ce87330907e7483b1013f888e0d80ba614dedaa308bf4b099a1fadfbd3214f40623fd1480b6d6e9f3a7b2897ef4451d6ec6bff8cb593535bffd8427443b58a7df6eac282e115f3c459d1cda62098ed4ca5d456b35ebde8c1d3938379b1b1ad18a834d6347262e1809a97a6df30294be163efc7a7901515092066a0568c76858e19d57ddaec50ce3fd8cddc9f612bc2c3c1429e4224760f47889e42744910c3da45d874a5e740e3f8e10ef4b97878615e89d1d9538d4c00336bc2eda3dc9b70199e5020e3d8e7f905a8d76f3d1bee94ddbe15aa1aabaf5dc9f436e91d52c70daa982bda90773ddb55baefbbd4b944c5032aa77e0475e2345ed20234dfcd03529651ed4acc2a6cd60ad16c03fa25441e99ca78afacb9df2da8d4ddc18c77286824b2fc0812a77f33593dc359f45e2813d706fc77042188f4fead58d0b08da4b56e855233cedf229c3d9df9384b4b32133c2a8434f38d4ae7acf9278b8534102a8abea9621f9de4efc3248f8e123b4f2a4aacf7f4b019b5c3052d0a467aff80478b402d6a37e9a31c59b042a6d5f10ba32b7ac6f15381c794ac06ac4b61416a247a1f948d019b840c99e15618f4f30d2c02f7ebc2d05cb0635d778ac3af98a97e3330c13547d98f2ab824252efe690391973a7f4830ee007a2a7a589c3b9014a5eef6b1f1f9f331070bda2d461287a5c1cf2ba74de885016d0543c9058759942165354edbdc5dc2b646d6a25ef6854c402f6d1234cdedefa3b01f8b6798d359cce7722c91a37d8155e6fa9456af1c067d004474600f928aa6b62f7bb2dd7499a9ae2336e596aa239242205e9e930abf3baa9c2e7931d290ccce76b78a4f646b8f825a9fff7d3a7ff0ec177b7bc7c4b7c8d45f303fe2f6b793fc31e55b253c24ddf3f274999953af30972935d734737b1c7a411d584d0e198663a1cff60f1d9237134f42202879e65d415badf504e7a17d602e6d68d2daedf74ef2b712fa8a6a02e8e721bbfa1741e2f49d49c7031e1ce20fb840540bf550ae2c4a8d3f711687f1e4982c70b3aaeaa3d7ef439792f408e1199e7a9933e2eac471c3e4bc6586c3473a39f41a27275f349158d5e90df96883afd5ae7336e18c8f2f71c92e30b21c385e92e05225cc2e7281045a83f92ac2f9305611cfa9b32a11565996cc3a0dbb6ec334551ee864bf33b06fe21738949bba3317ecd6eff0c669c89063ba2dc4ddf8d2f27539984bda39e68ce9bb45d01180ccab08329ab7d14a48318c4a61d581ea444055890de64b013d9e47cca03fb5be415a4ef55cd34be47d0fa49fc6ce04dde419272ede42d323cbe8eda56ff9feffe12c8abb6cec3e5decf57a1c6c1c106c5f40ef041b49fc503cb5402418737d4da3852fd8d8a5170f7af666ce3eb44d96916ef18f4b948c317918df693ed569ad4eb1c72dd2871ce41b5ec23240983b486495a3d03a9b749fdb974252f4b48f5efda6096a903a9b634b9e38c83d2dcdcccb573e0a96f94abd77a91bc4f7c2979a6564d9407fef186e24b24e9d251dde38d522a682c4184bfef8923d1998e4ee8e8777177f0024f49915133c075a67f8b1334b16c50f4f460e674e26e7d5baf3ec9ca02053f57c0b1c31f8061da8d80032c1ae93759b861916a9367549b3c4488125a5d1c328f9ed79e829569483f37c6058b141c264ae8e24cebfb1b981f1486a6dce1b630ca4d6a03f4e6d32846045ea5ee0aead3b173000446be46abe553cc4958de9852d3e5bb877037a2dce7787c6ae22f4c7016eead6d2252c4f984c5c0890e1d26332bf1ce0c5bd90297180e6b3c8ae733f8fda6cdc9288a930234cb2437576127ffa0856bd6e44ad8513ee060e1b09e0852260286e5ae8ad08b2f6fa6e2979356fa637c13f2c16bd0887a579dddcf91e8c1becce439d3cee53478a4f570b58625f24ab370c92488db9a0c71715f4ba6228334b9d640352d8866e3c79e1c6e29e7cf86b7f8fefc850fc47fe47241485a697f5cd3a96c1d98e5b2333bd91992fc791ae3145715b75355e7eafa4f3d1fa186e854b52c1b03763875bb682be40a5ca8e9a35867108ded4c0e532d47e16c8f668b5dbcefc2a4cfeb59082062f81b17cf00c9f2dd14024da4359b0bdac39de93b8b2cbced7e67dc95b56e9b4edf05ef984042be24e36e0c623e5267390fc95e47bf7d0e569f6f018b528438b2e826350fe68bed32df8b2d857b81e74ec93c92eabdfb9f69b52d6857b0b3a1207d50bb0b480b64e7b1b474e7e21bcfe271f4b2628e91a081f700ac7f88cdfc1af76c3070fc42026824e8cc69cc24716e326cb899ff12e13618a6e2762a4dacd5747d5b0aed4b2c0120efa8f3b18953c666339dbebdc1dd1141273c14e2e51bb35f7821341a9246473de60c3d90e423a4d038741e63c81fb83764d7794e8defe4e660f4cae2ecd05b29d8d1b44e0570307e8fd528ca0f946885406e52d01822c906c8596456e8ede6137512d0e3a70d0d866f14ab1a89adfdafe7e904e9ba3b560b9f9322355ca710bc2c59795ff544b4540fce9b480abeef15b6a21b5ba798dd7c55754141fcc593772667d0db0ec2fb4008cf4b67795277aaf658270305af11cc8d25a4dc5e57db049b3202335c586172b56f37ea1ad2ce91a1dee086af558fa62c904f444d75de1c7ccd135b7d333085f83a2a0b44de853d4db370c8c1e897b002969b653fd73fd39c95a239faef1b6246e5d6f1249601d92b0d353d63bfd7d19ca8c11898bd49dfd3a3f9094206abd358d95059e9e9533e07f4a13fbc9ef5758d782dbd915908bb271bbe3bbbce58f2a5af20ea8e28c8b0aa10598c39d23d1ead6c670f2c187231d1e93fe0ea2484d437b60505ec415102035b7a6ec4cf82276fe17a0f5766d51d2ca2227690f08915367f9fb84e8fd9a705753f1d49c32dad41e7060369f7c66a25760df782561207122515a5f33c4f690dee2ac45ff76909db0cafa49a801d0abc891be55e0786aec15abf1cdd3d727b49fe7c3727afd54d498ecfbc3a99bf07ab40542d221c20a4fb04100cc8cf6af943417f2793d1278eae774b96d4046308e6742aed674f35fe70a18ae67d85f70c11744b1b142de6a66ea9c590405dd8b3a09f081ef6114fcb62403c3bdb74575791af3b266590e5716e9c3259906e604dcccb1531c7b22e09eed8aee332eca127a16b335b283fe4f78b3405cfdbd3df96db3e2c3472ad3c44c230f35a412b770ee77a06a9ba01f57f29eb33be446ed4bd211dac2a4802a3ecf17b3de21f2a50bbb317826d20c85bfd8d4c1560108d80634e3edede9e8bfd53b6c1c39a39fff42019448ee077ad6b0c8fa65941e1407f46d6462c683c8a1296795acc81113e71d668ae0f324f6330656cacb41066c96c16dba081efee3d9f81a24d9469857d1a1e81cb939709c4ddfb4ca75db0c55d0e8aadd9c7a267b30cc4224a605965ea266dd80e216efe3218ea8a0a32e182048440220a30577f2a183cf17f118b1068b06d7c4051d31a9fb26ab87af4c0113d7082b85c29c676eef37a833196231d4ca72211e4c75560947ad074bec051e4441b86e1c935fcec2057a95e18833d1e78a4cf72ac3dd060e245aba3971758eb94b1cc26d85c5e21564c8df62a26e4fef439f96be64cd46cb1b983659e627c1db651be63b645f4a3ba5f79381d786f777f26e461b4f541d57ce69e4cebb7f3a62ebacc3b53c1634017257cf7331bba43ed15d4a224215f3b04fff09b90678c5c14240102495c7dc127438b8955f91dfc2dd7199cd9681adee93b1a958289b0deb85379e252ba4ddb48f65ababd02ef28bbd14989850b8cfc518e22aad78e2afcd2b63c2f2dd40388c0c2d36253e5194e2963fa6ce49d20efff04778919bdd6e1b77852844fe0244f400a4d5d5d7c5c146391ee9f68e592e4d84f083d2d6627a5097e64733fa8fa1c49ba4ceff01d1f23767f518aec43f6fafa4aa07a33cffe184d951156f3490bfad1d5e96eecfaf25756621c7c65bc1a3b72a1ddcaf204f768e01c25732d7e3ee924e08d0467f5c32a30d66467bc46186ccc72e5ea6de50a0e9a2b45678d99636c41ccdb4986d02a5e12696917d4451fb54546d105b0cdf4e837bfd0af380f44b432424bde53a0fc490203fd842e050fd29c02f0f9cd3aec5f7d26a6fb0d119e90f83cd40665e27eed2b1fa49421f7c8c744128f2c65f587ad40a2b3b67cb920d4c8322ff2f6990601b7e59942c6e1eec5f6160e3b24ef64aff1484e67c26af39bc70cd115d15a197d4569d48dd70c4aa525396d8cae0982d387155fc02cf00d040a3fd25905af462d7b26eaee7a064b3e8e5bf77266201a1e839108441074970026f24c65babd522c688bd6b504d4b7ae87367322daec7bf11acff7a61011ea15b5805101c1955738e0ad23b6e48c66f567fe447ef155d234f68e2d0e0669af55c083d27b45d4da1dbcccc512d8eb0bc5b0cf63479f158a68f7d84fde350336d2c73e72809fffccabf5b39f4dacf1539eada2036726664537d550355940b62f4c0c83f0bcd065f7d40927234f75e3ceb2456e45a4256038fa3f2b25654a43ee4efaa12c6c9b5dfc0eb5d89382b24cfb2fcce408447489b9e23d2b547c9f82abc7ec97985c72937f097834b36d29544f4d625a2490e38f16e42d2909a0e40f791979399fa66a8a1fd37d217c8e25c807664cc09a390a3d18ec3196ef4df3c64b23c34ae42281bba8c7621eea2d520e14e8a83fa2508062b01c60045681341054fb4a463b606f95a735e121442add7012cce1e618845e071b4904f09ebb5e7c34e5c9065f3d375e120b8e46e1b08f0a85ee6b57b1383098c72c891bc1391d248eea865c92c8882401b9e3e4933df7fa8a3d992de0be10dbaffcf80eae65cf77152d7fe9844de20ffc1d63b4860630978418180ad6d53f20723a0cbb1385a33827ed1b0cf481b5d265a637d598d976dfc31152d16f43bdce487c72afdd89be52dcff9d46c6998d66920337ef40e0c243b3f36b9c14fe7bea31ea53f69fe611e7ed8358553951f36b7259beeda9d9eb9cf466bf5e6a8261f98ead53fb201b127d0fd5a7bcf9c974612ef0f7ebf7fc620d763627bbaf43addecf2012bed54e99e849407198dba219617e2002426630f6d486aa61bf8b54a87e7715918943685d3617a52141dddb5031901434830c3a9d5cf1e92989a311a003debb538887469550bb189a1014355c75779b1a8577bb30debe962d3f49d51b29bda9875e48aec0ceb8dec277f7f03c2af5854b6732b0d11c240c6669caab3796c7c656a9bd1a564d1a48256439719533264b45c52cbb907316e17f1df36072aacf5d9de5bd9cd61e0c37a768eea0e1db896727ee231ee4357bba47708c1c6a3bc5d97731e326aa330c504147f233fee0a591666d587bedfd4a84a42f620016c378423100605d14908f590f77f09c01a7b91a90e0a8351b4d294a7e6cbace0281f063462b326465fe6d804c9890644dade4556a91005fc1aacea71d149a9bc434bd94eb64e6482030257e491287d9d9d277bf1122de8798512d7f2ee298dab76a370b92d068df765eade1b91f19d293ff7f8e9d49cfe633843b3be33150f2fe10fd26d4c46be2ee372349f670f67881cd896d4518cae2f63dd5c6e91ca41e9e3a361415a53587a758b4436bbe4e9365e429ef8181ce0dbe2d31765bf5fe7055f710dca4b0ba919762ab0370ac655296c2a1e1285e120d29ee45cac42fa8a5c56a47dc686e60806d3e038dc09803d4f12edbbf30a7a7f5b5c4bbf1a144f105f97062add5d335965cfeb92e764d22eef2f24592866138f1da1fc84bca9354ed159ba4bab9ac4809729f1f7c37d0f4a2c660be8fdeafbfdb9917930851a58d34fd298863cf7a1bf89063594d4cb03755eca0ec4d496e91fe6f87803c12d9c1ea79b5a1000b251c8a2a4e2df82a08ba1bc9221ce3396a18ac9a34a96db5bc8bfd28b24a52839072b2ddb5ec6625367b923d57db10563d4b2903d8c547f013c87e5e45d5cd3d32551f96a9ffba140d7ad2e2e0d3c26e4df8c543748c663d63b40c865172ec95cb77c371a04b9f3f8cd0934729745cfe362e58b74d46b20835f5b932bab08fe76403d0ea35ba1d592c2604a321412b750b192ac1a0e95b63b126f8e7fa628afa2430f11ce6742b8e0ca58c3e4b77efa9c339f2d1400eae78b0c2e687a930c52a0384adb6d211244b9e9616c69bb28b8c9fa479d735504fbc37991770a787738e3f551302ba8670554216d9e6a7d5fdde7936300b2fbbfd5bf777fecdc7ddc38491ddf2f7589d4c507c0089283b7ab0175f7d4009bd99173f4631599d2b7e266846886187d414ab929be3a74b813b71eabb16dee13cb5d1fb39a2bfe65b28c8b22983271f1645bc29b65bf381b96f32b69c4fefb29412cc53c7be63e8e67f061538cce669c8c24965f8d6828bb0626ad486b3f305db6f5ce3afc49cd1248151aacabeeb0cdf638a499a8ab26b0c938496815b1283566a2c8b18c4f098996685f394449864fc657eb2f67c95c892730c9d7dcd3ffc0b8a99c5005c18170567e98e0b14ade9ad20b657195ee3b63926f592455b3065a61a35fff3b516a21a38dbc4f71953600f3b47281726f5320d908954063135a93fbeafbfa1918564bbe0cb2c3956629c76a3e849f0318d05388fd00ac4ba0edfe1c0ac294234367cb64b78f71050da7a58408f3d1a1dffac28589d3dc497044ec08b952d0a1e492d78e03597e3fac3ad896bcc9a0369d943e6235ec3740427c199444c457e09395f5d0ef8f1da48b040e3db19f497b9b8b04c6dc569c23079eb44e4d6a1db9e1289c6d5964ee828cff2da2f3c8bafb84c4c34cd2cd4f74a7e6cd6219b0e9479852f64b7e65db2a43df55892bcce6a0ffa6390911ed158ea7cb2f6f50436c6934f3c3432fbe399ba2371a308f63628cc6412fa35e8b7df5036d7655cdc6cdf0fd25bfc7d9508581774d9c6124e9a0aaaa88232bd4c3488df0876b1e35c0398537b0dd5a1192c6952cb2466475b01d0a0d96880193a123c7920b370536f1c940d2fe99a6d0bc170142045f69ea5e9781bd0aabb6b16c7e654b5e333752128d12b9a864916e0ac9ff47d565023371d13e7027572bc4e30bacfe04ce091454667630cadba4bfe127db378e75ef317093b00b3b95378fba1f57926e7a26f5a7908bea73b246cc340dceebd7796e5063c04fbbc2f64fc1cc3ba53f89c89f91644b157a47110227da63ae70adca0db3f65caa15835eb7017f8b7222069cc4dcf5bd3c57d4bb92f69dbb89f25492797a5b2d5f59d88cca65dce546a98a6a3fdd04d43dfc187fac28b10a143ac3f06211eb6612f61eb34ac7aba3ceeedfde1871b6093e6d541c83be2f0bf28eda84a3604f00c06883e7033354f62cd4cee68f1fe851f41e59fd94f2f8cfb025940bb74d905115c9a266aa7db8866affb9d5c309289bd13a06a32960c02f06407c5be9b34500adb8e1b1c44ea2705e484d6354ba404d327c816be3572235a017416f78bfae61db9464c3958cdaef9089ef621a7edc077b1584f155c1867f7c82bf6074dba20fcd70010050ddfe8b3b87ce196acaf5884b50107e64ac970a308173bc2424ef29024185bca5d7fdd4a23a67cebf65ac346c7f32efec62d96395361863b5e736a73c335fb483f940bb2c0c088daa22b7caaf84c788cf5bf5a34a7a69a690adba42d4f34fb5ce9727f021b8412f09bd56d9deedc7bd02e6668e1812396c11eda7ebc82e2b388014e34ede80045eb5291ef15aaa7af5b0852a4f2594eb6fb933c3504d5fe399001a3192b17f581c80eede3841d5fcd42ede1964d7b41a3fec28b89c567631b4419ba57765497101eb8801e4c7950f08ef5b14a0efa4cc813b60a292f5d39c322ae2645977095464ec18274e8fe23eec78b27fbf50d548252223b1903978baaf3b9926a320c8044c8cc29f632a9969362343edd4c0ef16e337ae41f655ca9c22b7029938d06b66cbbc7a7608fe5522de8c6f2f77c4e0017d2c5b873256961ca9e0a5915838b150e49173027c24d87fb81ee7844688a439e776ea83e7b7a1c3c77eddce770c250e3e16bb18b76425be00f8ee04ea10a71bcee79cb9a3376c2c9ce557a37dd774c2630514d33d6e89a5a2bd355e805856a8aa627da127c26b37b77f415c935ebbec0fedc563351bf974374867c196a9a4980c8df2ca64d5b8bdde7d648b6088099d874488498bf4520bf08c8c516aa4b6f01a3d21aff3515b11246a16664ff720872abc085619c4e3072cfe090a5725b0f287e006384dc89148c01f594fd87df465bb27cff98576d96b74b58c64938d4a592b1c6a97c3453c88c90eed7f60d52a4c01575b6530d72b000d5619a86cfd7d4f968ba64561dd2b9601229880a0140aca071e60e3846f403cba9445f67d51bb40170d8fe39155e55824d1f7dba70e0bff214bc6ef99bbea6ab99aeeefd8045a77c2595f63c6480615b1433ac179ea975f5daa16657c5a5ce7c77cdc4d5d0438966b5d052786e3b96adc3036c86ec52d29f3395da22dd954e924904cc2e8d8e682efea476b36053ccdea00da16a8162b2bc545096c0e73822340deee0662b7b2694148cb90a7342b1015047467e3d15e2cea875205a14ff198210fa66adbf9be9a0250d4546541dded06f61ee23b8292c08d7efd38a27f7b1847f85b4ca08848848b430cf72daa78fe2045ed26f183fbbff0b4ca9a1e43e270728b0b3edfe8634ef2baff7d327cec066a989acecc6b843924ca4171725340feba19dde2ea462afd9881e7ed2e2836676ecea67f7b0daf2dd7f2febf7b83cd799352980e0cc30711d6fb5444ce5523130331eea5693d02ac5118bb470a81142fb9d457364bbbc02a56ff8614b7a1b309f6153d95929ad7f82e4ae43543cf1754c3d303c11382332988ad525cd66ccec5478778b72d660bf09aa289f02d89de05dc6a54c78e92a1fffe675742b4de62b0c149613f32a743e2585e99f248d5c6013117071fae5d53f3ea802d53b12eb539ba1293f23bb31d4c77cd0f01825436e6c209df5cf1a074f252e51695cbb2f2a9a88cf05f93531da3858bbee00a2527e50cddbf7c34bb9f11e6090b8c3e795a57c94394c9b2dcda5f415b9c174ebfdbeadc3c3bb95d195360db84882acc7ea7fa7a2d722db252ac706279c46d36c79f2dce496c38ae0cd2218f8c614ee45901309d2ea18fe8618928e4bf7ddac05d8376608df75db80f1b8e9ab26a257b7c7bdbb2fa64a9888daa26273cf876d90962976fd953b6397e002332f69661ce45f9e399995b87ccd6c9d399f91e4d9299ae5209ba1db1b61cedc7323cf4e6799b5fadaf59e722a68e4bd792053a890086887dcb207fcd92cc9426fe9e387a3b9f4e1b70682bede06080eea861152dc7b6cdbcfe8c007f0abc9dc29d51ce7fb1310c8b22cd4a226b0131e6a3dd199633537551e5fdb16a6bbb06a1ccba70318c093e7256b0974e3f41532cb7a360d2744496797792a05401ff5a6c7a13c03a4d82887b717dcf2ed66b8d62c04941af4ab4e9a24fef410409dcc5a175e3d06bff5cfc51e093c36ebc87168d10bb277a591597dbdf6397ee32def259d2470ce55edc169ce881cca27f26e8fdac1c31cbd6571ac1b169e485ac53e8c2845121175c61f7da0b151b47f2bf11b963525ce94a9a07a84f2a2de24c3774d462dc48204eef81c5079138247d60f57cf5f0a3eebd770b3955cd52bbbc3dfdcb6f5f4b73a0dfdca3a441c0977d795019fd25a0515f2962111df7d43f91eed4278950d3bc28131b8f95b563cb93a3c05ecb366000c9a8bd90c11ac135895283eb4cb1c2024ab1589fcd5773b2810ee045a7cd1e2c9141fed15fabb66cd8bccc997ecaf4f3c8e22e89a679db397964f52561082fbb0fedb9282565bcca811a45430cfd6f98d9f516304676d86bfc8103a837e916d2cd9f28f9961da097fe07b0508ca130702c8d5d19903c95c0df424bea7e72d08094fc71babfdd778745342eda37059460926db58139b74cf1a45d1ca9eb8fb35cddcba4a383a6504adbee67c5f82389ffc6c3d90e9785ff220b66563be714f11be315d1d2951c0c4c8274649da7f254049ce648eec2cc7a8387da38fc46edc22e7694fb241791f73c7c546f6f38bfd7188ac0ea15c3f32ab32a075ecc681016b1c41dd8788b77b27627a21842b201b77ed273cc7094daafc9112dc60f8376749835616c115f55148d7adebec65ba89c1ce416b2f7aca31c4a1c12f31c7845393dfe4262772450ce8f807a1ea34947409a71d5062c25f08c411bf6fc7e0e2c3bf33365b6240ca57174e371e2f3437a62ff1a180495befe3994c71fd120b14470493f09a7dd60407b3158cbadb6f4b52dcbf589f86f9eb8210526dd83c2bf49548bc4a8aebf70f8112054ec435ff3d89562c6b053c69bb92a471b41c3a8ca0fc38634303525b558c3467453e4f3fb9093635817f00dd3d2a416fc7dbe0e8c36ef3db04f50ffae13b4882e223a5c73f2d811e3975c79fa2d13e5135800cf8765601eee6c6cb7e4e65bb6b5a2f6676d525b89d5a8f032035a339be9aac0ba05e5074fa558c0b57f883faa18e8329e03e5b14c1900632a8b296d078d4b27c9746b326fdec4e8a986b6f58310045c69dc5b41432d1bea9df4b20f0cab43cffb00bf7008b7d93cb84bcfab3b385e93b6e2f482cae933efe49c2c2bbc623f161768314c1a7cd3e80b1e1328224d3c09d5cdbbdd401c32b7ea102b759f9e891a814bf008e6e1381a15e824fff10bb9878907f764f5ba625bf5e6f7eaedda4cb56c3262a85ec5b11686c0b15d23bd486b48249f99c209c1fd59269f61d57ef8e48538b7206ac2913e4f89aa1815af5013c414383c3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
