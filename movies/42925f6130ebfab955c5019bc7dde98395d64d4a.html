<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"df351996805ec5bf3f8577a6392975624c2a3d055b4878f81162a8694c3bdc4e088cb3a0afb310fd3399b8f8b6036fd556ca75876a7151165dc99dd4b8b8a88e37e941c2b2ecda14443202ef3d0b997ce4fd6a64501926a54c508a7c47f151e2dbba97a4095c08a10a00489090b87d74703978cfd9a85bb32db252a8a728b46968229b213089de902110aa0d64a0d13f1fd583a425afca9d795e021a07f51b7bfd93a0349bd047b91180bec94dbb0c61168adeb0f5751d3bbc1c89073b42599c2d46c1dc6aa42d2ef9b00161ba7ec4cd7607b228ff9fe7c8c10b475f179bead7436d481a304964f347c8bc1bb7581aeae79d12ab93140307dc88a5f9be7f14e96d8447ff35fcca4dd2ed00a1f8c0ad3d17592f3442d243329dbfd2b323802abfb1c11726d4a372e340674cede8ebcd4a0455fa597087c82b6831534b73524c7163e8e1d97e4cffc41dbcecb6fcddc3400f07f7ea582cb09ab1cba7cb1c0153a694cf96539779da18236fc307b0ba8b1e6f8bd0bbcb12a4359f823714bdeaee1d97ca3ac28907ab40116efb2cd235618dac7c0d0f11a87f7bede69b75a2a10bee94bf9677d3683aa62f6e636523389117a7951ea0664423349f6ebeb7dcbbf2d05bdc113e877b299dba1abba31bc244c104baf6e32f7a74e391f6d8503bcb8f3e23fcc333922ed6b2dc7b5eea8301f0d251c07069dbb334b7816338972b49a256633d8c7ec685665b8b979294b5b07983bfdfb4f7bbf17416222e660ebcfcb3253d259dc77acc84459b346da026f5c2c7bfdc8d4a9cba038b1fc29a799d8aee4e829eafa8678b4d9f4c508218a18b6742ab33436b59d8d85bfd273e6d0a84b556f507c9af483382ae4b98614f1795b8e6a73bb2c1757a8ec7ef7732c8848ceab23e7e3e79d2c592a86bfe46551a84c8913110ae3b7ac155866e4d8521ad89de4ce5becc8f4909d36728a79c5ca707156e19110a665964b254c7f32751ad7408aee08ccd44fabaa1b39648578385c37ed4b3d6a4ff6d55276887c69f8d69eaa126e0cd3624da3986f5539acf31f180c627b3e8b680a677c67072edb8661d7f4fdcb987b8f50593e8ff18ada9fe4365fe0a644bc43138e28e7c4592f063ef1da1e924b7ad86a4a01a0390c7ace2f64a7c63dffdfea282c4c8e9005e6fa64cec7abf79f0649dd14d870230b48f569f5c8b1aa949d8b4994ca369c4252afdaa0c54b1bf8354902acd85ce314ae856e44a15009d96ba96669ae73d79a28cfea84139e5db44d5f2ad414e52366ef983d865b58b175c94818a5c32aa5d6d1dc1e5946428377747c3fc991de231849bd0ce11086a58ef68d1590bb1f5343454c7defe9ec10d521f78a84a47e0ece0bb0e828884f8179a0c341895cbf8e3a8939a680832b9f5d041485c38a058baa9a5bf6416bd3af8fd2220a620ab318af013b5d83f050e48db61fed1f253c04c28c0a894ca82d0ca1e02356ad433776581bac11020591c99aa9b1a98825e1aa11e3cefa286a58a00cd5296a29fdc847aa7240e88705bb1455b8d7e1b6984a35ee2186e80956ffa13e573b5cd670854ddb964e19c41010994ebce3cf6556667ec7f4a77af6cc72d60a65674ad22b4768a30630ab037d59748a11e3d9fbedccc64eedb05ffe292b419562b8da52ddca761cd3801873c4e0311d03dd4cc08ecc82cf891102c32dc4ade349e86ea97620eac1b958b4ec617325a5c0ee52ec9f704705f52be392037aef2fab65765a5a3107d0da83a65dca0995c36740852efa95b7b32dc67dc4b67c04c1c436a4dad29d5c1c8f1036942f87ea9b5b514cb0aa9b5bfca24607146b831fd17458ada08f57484ec13fb3dfd2fb318c26855b6b249b63a03d0048a25b80017f4af2901840fe202a8d92dbbffeff5147707bd0550e3497afc74a60db21ffb6b977f9555783a758d6ac9b4a86f33a8a3e96108f7527172418c98780ea4bcc9960cb31821287b08a62e44793012a56ead83daba2d02513dc0452f2e6cdeccee07969548ec1afc9465abc052378293529cdcd739a7ba93f5aa223b846870cd9a7555a3978fa58ab98152630730bc54cc35937e553a9eb159f6de428329684049364a78dc50a48cb7e8f4bd6905997b0073dd571a0696c07bd0265d925d565171f8954f429fb616ffd372d6d21d9e5025771a7f3718c1c4011958f7c463eef915b59679b5255243238dbbcc51097ac55d5550d944cb5cf5911f68ef6f415fcfcfd0f2da191eea5f18e5b461c264cae6e106884398c9d45a370113f6e421610f7c047441c8a08900e759c545862885b3d4ce2c3d71115f255af1986016f898648c11ff0b601b887eb330f64512560e6c09925b362cceb035c8230cfc51f541acd89a87e2acd03d94402866b54b823e12a6c5b9e7f87934776d93f33332d999426cea0800d0f9453a5a177fef676f1173ddf0ddf9b1d142e266493a2a0b0778897a5e721e74a28c04fd6695a4b5892863762871af1c5d7d4d80ed42ea6469fc45040b03c3c0a9706f1b9baa57420e57282af9c3396057b5c2d1c88a586ffe1dcf80a21861e5ad47673a54174968f6cbb06839221db18e78672c1b2907636a423f2777fd108fb9082b1df64479c2785113fcae97f759973468aa7d4f7ea275cd0821c1575ef768dc3a8ee50d1a2c1f3ae1d90fec01fde33ee8d2fafa6651620d5fa3659ac6306f3f2e2d5a93544b9c105621ee36a285e0ea4c9e206d84d6803e6b922b722f9abca0c627e1eb39c69b0c312f5040fb3191920d77db65563d7a75ea06fb4f345e113839f34cfc7bafe98f1bdcc1cd958e54f489808e1282cc865cdec8133cc1f1e68e7b64955a1cb0f4cf6efd67a9b0cf8215145398ba677c8fad109030ea50469491b8bf36f29e6e0fd7f55941874dcbca6233644fc1914ca54409e13f9548600b4ad4f66d413cec6bdacbe65a0faed9458cad5d6a1ca70120ae953b4307a38dcbd58c27d1f1ce870792e886ed09e954cb81b20a215085085ec6a8e2e02ab747a283f7bb0627d9c48e9cfc2868c012dfbbe5bffc8844240f805d4a5c2c628bce375a207c0394b32495adf1ff330c1c6fb02068457aacb2164480990e4bbd5de0441bae7a12d702180cac91446c55230e766db6d4637e3110b5ac8f1d0cd7f37175d58482c46ee4cfbdd2cd34c5c24448025df497274f824979d4c54058382d21ef6409632de2678ec75b709aacdaa4254d3d082b7070cfdf5135644ade729e40f24dfccff9283d1688a5bf702259191ecf0a3432a2a27d3ecf62be3067c8aeaca61b103e37497cbb978794173bd6fa885923968f26b77799493c9c2eedb90908cdb78d1d673c2376f98ea5227c4d18055f7e814f91081b3d1ba1ea6d64f89d6a0ca7a467a66c9720b131a9881cccd430f0128336187f2454107f75927f239a7eba6a2d2c1f94c2a4cadd2d8c7c6162393d09f097b1fe4d48a2b3b7562109caafd52ec2241ee33d8ba49840625bb736359121b622f9e29bfe518c45945be5b2ba40cf70ecf4a1a3b2e5371ace70df6ed9bf746d741947609c761f1ee628381193f4555bf08a64545b24fb101ff45c839306e7219bd40d56fbcfffd6b459661755f2f94d8fd4d238a2caf816c75011039d94c1a1e9f96fb8d8dbd9e21f6e1032763879901a415fb6731fd8816fabebf7643c127b6116c242d988791d3a9ada678fd490b9e68ce9597e02811f1cb04f6ae3a0eeaa7188c0d7483eb1a7ad8e6af5c47ad0a9cfc79eafedaad2563d3db0728e3ac7b14baaffb0adb10f09d179960efbb18f734a3a08539cf7cc7b408216baf1605e0bb4df0baa39cd4b0e31c141e20398c26a52721c9d45315b0f3c8bac7b28cca21b1c55ebd5dc51b30237adbc4585841eb982fa43b0f965c6dc30e2059144951be885f06404b8e73e50c0c4fd961e4da862a92783f4b3ae58dab7587cb00e553a6690b28d8ecd20d47c1a7697f279242a45044d55dffe54526e841f5532d774c7bb0caf8db14a1470bd54750d6b8c3b72faded7240eab82fb8ff2237c898a0db1a72bf33ffd116cf6384b05595f2e4cf71456958ac29db1a187191a99ef594b88ff884a8014183ae4685ef3db20454a260562f445818519f8d45420472f9fc1cd8f190f871265cfff76db025365d24cb4e17612764ac991197c47f09af40fc9a63f677592980bbd8d59ecd1fbc60d0953fc39bca509748191033968f81000be7a1bd9ac73e941272f7ff05c4f755e56019f561263612168b2dfdc1432d5564adf7612f2abce7f1d96abc9fc5b6b6dc5b58332f687209fefbb199ef07cb6b5e2a0b019fe707913f7408d6e14eb85fa0a6f78c9a2cb0ae5891521b660b372c467a48cf1f6233683d523e2b5d9bffaf4a0055b3aedacd97ce0e16732796336e1c390ee4e13e513a54311b58114781355e786837f435b861c2985c44b4b11d1c502f4c4bc1ce4839da2a11ba6014905d9e0e0c60c14215ee495932c0060e1e475df83b29b188ef8778b5c226bf6fcf5acdf71d6185647625edaad4befa4a8960bec7a336543298af43aa39fda909a3d1c4cfc2a4667d97e01529513f490747db5df6557ce8ecdc1699d8951293252f59f6e425d1078f5d1a734f3c04ff9212eae5b7d0bc5e858a6f108c3e0324fd5e5064ba0b7e61807f6902c6a6abf0f7c5672c6d48a032a3d1058b6a1238ae3f09e1ac673e6b6c6fe9a054821cd21a190d5931b7cdaaf78c58a661c45cd1859916c32119ce135061e419e2f63219bef62a903f39f1fc49e57f09bc204271888d6d30ecdcae98965a5838dfd3830f1df735b3eeb5568d4f42509c067cb62362ca7e45d9e8644a6163b4594092484e6086ae895edf1fa909925518f2bc9866a806d11e14715331ce622739ba5b51d2e58dfc027b3fd0341dec20f00b33d44b748f569d0f1cbef7db059a99086eefb74ad52336b8c237af1ba3208406bb50620e8ff9e30156a8e4c04385155be0924b189c50fdd7b97545200887defa3474614394d2c5289ea68483972767491701c647d81137c4cf2480123d9ca4ca19e1749646fe7c20e2c7c2c185f0387437258434bc58e79ef571022f37117f2b6ece1bfb2f610bb1449e412ce47daefd323a2b4228df4e86e3a16e5cc16088114f3d1c66de5f442e5577f4ab2e8c66f73be0b7e643661d43760f0a5c74ec72a046c20ff53e1492a585c410c0f1e3344b938a2af97357827def89b9ae98abfe67fdf6f763a47801cf4b8086010c04c0825193684a942cb7779ff57eef94c7fea87b6f10c158952aab09b83b4582d81d5a2d4cf9d363882d62fd659b2e99aed91516ebca07d4a8a9b8f760ba7638c5abd105e8b7a0626c824f65f6ce5ebffdb06c0def9e785713aa4f6a05220af9520e35be1c6851f4df29a3e619649f767b521b6b928d9d1902168ca22d505554223262a20d3815da219bb6f36abe10a562e96055aba1d88f69f8d64c91e3381faabe31499f973303f584c9f4fcfb788259f0a97ce0aed8ca993b1863899459c14e9df89f2d5a8becb080f33920ca54d11faf05f512c0b1b0ecea014930cb75ca2fafa43a0908b68dcde61796f9c2ed5a6fbefd4554d17b1fc95f60dc9fa7d3fd3f8201b5e34b8c822ae49eab541ffcf884ba65a7a9b902f1dadfb395d4dcf2caa31dfbda33264936c1877a6b4247237c9db22de674a3def7d3f41f6656d32086c4523e8db76771252b53932aeca910dcae8d8d74524929be848f6b7b458b77235cce0e388ecd64c1cf619b66f5e6f94b60385006a93fcdeeebe6a0d2d200f3ff3e046c85565b86cb87bdc497f68be49d47b06df92635b745948418001f68685c2be4bc9c06258c36152992f6ff5817be909a7006bdb3179cfd685502dc6afcc5ed48723a1eca8313fb20ebee929d8242f40a49fa52d776a25804b7da13cb401c42f925d2d408855e51aa060040550d6879e4ab5d2198a0195bb8d48edefddda4768ce92f178f6c7fe09a524d8c9624b4efa8cc68366314f1fccd0e6e8d0445d6f993907ec3cf55724a4f1bb582d3d6215df596dbe48ff56f6f47ef5ffabcbcb1e7cd48603cd742c3ed1484a93437d6b71cbe697b759057feee73cd5b456512232c2186952f8893e8805a1085d714a8d64738e836f3b604ea8f8443db5179116d6cdfe6ebb730855292a2ee7c2d497b3224a403a0b87532610c09aae9a7122b1636b744d59522b834fcbfd5af37cfa02f8b881465aaa288ff92fdb4dc400586863cf161e95d912c98d12d77cdee851e2efe19e760d50b7486eaf2ae9d4146c2645f037280fd6e0fece6c56ea016e693b25e7b12e8ef8b44a78d682693ff27ed0a2d1a09fd972ec8805bd6b4b85e6fbaeabcd0ffa02f1641e1de1b53b2bb1b626f762c725649ea70377c091b967d77c6cc1dcfc42af5e25e26cb22885906a0206c86d48b2138e125b089a6c7bd6c8af8c05da3e1b0e3317b52edf4ee54ee46d02ef04fa5c19e0716af27da55bc98acd33870869eb6100176896248da6fb8a4c21a0b119970a28879e326490cfa91d99fa385ae74c94c6b359e005de5c0f7a57985d36560d318e424dbcadb3cf9098bf049170b196b9bbab364031a1aaf4268343351ca4ed5498ded27b776fa5815bb9bb17619227099b0db97d3b58b9c810ee1e4906ce17d55b43afaca34f626e026d54eab47563a387b9e1d856c02e54825d0a3b13317228d7ebe8fdae26df3f69f1f26db96f7ab50fea47a76c0dab08ee67af69bc0ebe2db4fbbc2e11ee08b6a7ddf752a331e53b2b2ec986f92e946247aa7033d46efc913fb4c5a02d5c5abbb136d7d00035b2fb22772d25afe64525b8ab9c563584d7fe9a8e7f050672e638d19e3cd06004fb7a9cf36ae268efbd5327347a7318f4c15770d5106582c884d17c175ee233ee3f0a67408a564aeb632c7877bafbecd9b455e1e67925f5d33019ff668310641d2a44134e8fc69cfcd20e61af376035ae96f9ac6f944b00d13a69d2d63e29c920e631bdbc703d7ed2041085d3c8036a6671cac4c1132b58ccc25903ea65ed390a79eae2f83bee9f8ae29f7e62ab3993aa1d582564a79e3960a83aa78ce6bf5914f636d9386922d24d2feb29cfde21fb57665141748e9f9045548b9e797a5ae5bcee0e3f5e18fd22ade8587c54e7295c29c5b7d4c51ac0f16d47c2f8acaff328640ff978d5fdff674da0cea3942695be3236ead6ce60fb1c08b683dd571779a5c0c793795e80ae69855e55d16cf3f2c78dea06b88289d8953381984aa313ebd0e5d29e78f199fcb8294e1ccc035782a456409d488cac4f72ba6952499a3dd5358e43b6e9ee516481c2af62abb978beafdaa602d8bb2a44617eb1ecc0c84a874685cb7d80b555bc6c505259f54831f4ae9650708ebed35a8bf9534ccf3107bd3a8969d568c7c7c494049499e2dbb293c7fc21e23cf9537984224321ac09db173186a28aa7897ad57870798ccd841d95850359dd904c7e4d63dfb16f520116db10240420ef730388d420b4c961a08e1e6b0afe0ec4e3e8aa35ef9544eba841906fd4c9cba39ce9baedf89d8f073b61774f41b8ce7b79ff890140679675ae46601192390a161d9f32e4415929fee54d91ccc37bbe2aa36b808ad84915749dbc5899b92ad6dc53384c5170427632e900d0be0e9ec2630568056683c4bc7e9b3b34d180d3b0e0fe859bbde46fbe4926b180bef636011606ffdbb7fb8ed4e7d0a88faab23506969e40007cc5180a1a736404ebca9e3b435106dce073666e9e40847cc06cc129fdae438c46c037731d0aed657fee226eb09e836d7c9f7478f496b80839705e0afd6aceb2a66067793c5ea123987c0bc437980752cb2b7f03153a85977b537c7f736c42673068b50791c9b032826937140cca1ff0060a355cc20c72087492866fa2d10443693b33bf3e71a07de08d6b160b3ffc7217355f6fa4fc27e6c61d0def939acacae6ccd5a40bad87c6e2bf3dbb743eff9b904dd5c320a20afc7c90cddd7f1ba4330796088257f00b5837239a71c0cf95231243c05725169f998fb1e17cfaf43dd0c74c40784a923471ce9c2b23e74461b9a24f8734bc3e14c15fe6aff2c703dd32f96a7bb825e24adf62583754f6fe8fb42f6c91b91b70109e03e1b10d6e1419a9bb727f208af82971980f6a31354cdac5b8db7d3df1fb242aa91cb6f76507e2b994045c06d38a9bafc5e35f504d8ecad4109f74a6d74c04bba55c4999f429ef620d2e8a1683beeff411747cb3e189a90ea10415c1047f3ceb5183a70b21a1f769d802cedac0bc888ac10b87f4fe276229213c69ff98c6bb5343d27eea6cb49c60d59eddbcb9a0657a13fffc2547c74fd3761afeb3a986f714603935da66737e2673ceedc50b569c6b7bbe34cae81788df72384b652d073cd21165a057605526b288675b8d6a83994a3b3b8104b216cce15de91d1e45f038625f7a5fe95368516c38198dad2609b48d9f874f435d5ad1455ab50935f1d12c6aeea94a5902611cdaefc7859b4ba94f1045d6bd93b94366d0531107e7fa0c9cc49c4152a471f70558d857423d5ec229c4f4c5f7dc86b7764fa7633409ef52ea109a96e58c90e52710ed71e9e3418146591bcec2fcbce681d3d4b91a1feb4e8293349c3974a74de2b34cf744bb7341d98e1b4f553546b9e7a2e60c9b11da800f170e7789e46adfb1b9987dfdd6149bf72cd3de18d80dc8c6a8776b32cee3799b677b17abf9669de6bcde9959023d297346ddf185358c483d0c49f4625d417162580986482fbb42da967dec19c25db0686c40984f951a728fae4eea376e6f7198fcd09bd19a3c324e578b72bb1cfe542f9485a7adee4473d4384af87f93ed36b8bd3a40dc56c7941327eb135fcc11f8d0b4f021aea8a4863f02e6c0104fe10c4177a1239fb5636557cc774427b9f345d896e4e78bfcc8fab1ef01f34a01a733d2e3e2a38f39e4fd87d75ef87379e8b662298126b87393a2db682e3ca7c62358c5f63192d25073fb749bb2c0f2243ce2bd00a24d195120672cdfa77918f50ce9051f2e87bcef941bbaff243fd38d5d85808489072e37206ec0d261c10e30d5c11eccb37858131c2c539c6afa20a5d3c9f5820c356e465655b49378efa5a1e6101bfdbd934625ab07c40920a5b15f41affe31b254eee3128ef9f59c86fcbb516a97de12b22c0f05a75b75076e68fbd87445b54fef1bc54dcf41ddb115233186ab492afc222892f9054b3d2181f3677119cc68b5f92e0dab124a300d5dadf25b43c5732026ea2769fc2bd80e74e34d2eb0ac088ffeb25fcaefc4d392851ef1c4d2e65990209811639044bbce58b53fa7eff89936e46e0b2db2ed6763e89ad1910f99669d2cf6fa6463f90f45f4d3df8cac1b21729d303d9bdcfca46441003b8bed1c1a5ec1ac15cc863750b4c776653633e4e43a2ed63ab0111686772f391a359e57f01204be616fed2ec8042fb64ccd0535ab4324714147e5f80437bf945e3a3714aa67de137fdf05db00b95e9a54943c9f457624136103ebbbd4dc68ef4148c40aa855ac9cae58de9e7d2d0029dce896d04593d9c4a1ceab2e88781b65a2e7419e5e897f6f6f695e140012b74c86cc245997ad368cb2d265245956a1910518e6021b5ead244d49e42210cf9f00e0e3c74edd45924a1f36e00c1b59da5ddf5e29ad3a6639e2697fda7ea37b7a4402f1fc83a583c97cf85924afab17fdc6dc3e2f83da0b7dff37e3653d91cfe56df5de3fd456652ef757f3fd06548a2593e2af5bb3ed71ae65814be3056b5c1d1ce139ac4e8ce7cfe8847296e3a45093f0061cdf7e8848cf4a0a2cf1a9188e6e48da2b8fd7682d4d5414fa31bf7fa6a02ff772b3868d2ac0fb86e3a76304a6b642f3b0a07b4fc77aaf2c051eefa1ef844bb31ec0ca174998494e63d4c3d805e533bef83123d4bb13d8335b644f2be62bb2681dd99a951a8f3506dd1304cb9cdc828728679d8320e10b5053013c5c10fc7822cc7b69b4f3b635e5be13bf4e554b40b4bf3ac3af448454f95aae909a757559441c10e5cb396fa93b95ac435ac626e90ad6de688caa830765eac972b60d57fec5f863f522b1ddb853783b916237a0bab7240286a89872e8b60bf9d56fd774f6f3a2b7fb247e6b3176bdaf54db613cc568827145a8df8b30d5b839acd8cef3fe72a2ed23e24444da1db3f35ffae51aaca82ad097b3876ef2f82af80f68af8d2517c2096bb3573274bd82a476326a598e7cb0426b8d337bafbb9b284a93036bc4c3aebed3e944d58094067ad2616f40eb5ca768062f73fd8457b024fc07c8c6722e78bd45e9a40d23ebe14af4ca7350a503389888e07d8f84e6824845d3c02857420c93989a998301a3cc2cc9db850cf11f7f50f8da56bda4878bfbf00e450b39e9dc7dbe68f73ab0a70824f099393843a1da91c0dfeb63180b5967d4ca3a67f70abc668ee70a55c72823ad106f24920684a5540535b5eeeec1daeec8ec6c61c488ed48c5b861cc952b954a39208121848f28f0e0a19657160a027a1a183dbd0ba2162cbda030f5d2d52f3758c2c4c8957155fd20876da2585d44cd698a9baac2b970826b2a6067b406eac608f2418017205215c4eb629051fc489e4cd3ee24c64c01b18e7c482545f83c0955cd87d4f10918c4f1e47130616889b222d4629cf2436e95683de3316a30c9893b5a7aa8018c04525010ccd43341f98361cbed61af038acd0d3fecfcd1414bc7e5beb2c94850809b7ba1de9861adc9937d3ebaab0e3f53b3b3b846a5a8d072b8efb2fde32e64cb109e167df399c23e7b03906f873041444e258d7087a527af210552093153429a00cf8166e242a70fab712916ac64ad41e7b6a052eb14bd269f49522e0301a336993cce0ba6a82c4f92b83d83067ce78352159bd8a672b445529d6373e205356975655bafa6666c7daedb2b214aa462e8d568093a9d7516d04ba6ecf0bd9c48a967e99ef6e2db26291ac6c3b12ef717d197e01a936839983a897d27af558c6684712c393e70dd507e8d6d699df80393d22450b904d50ed9860daed60389e2d4f6e282d07c8da1d4ce0ee42ac2a86a6dfec2310364c12a7a5a5e67b77c4318d25afbe7a466719bac261b7de4bee73c1d84d6d787bb26b51dda93c9107b9bc1dfa96827510714f3993598da0c6f91c8153c235a465c0a5773d2423d6337c0764ff466947468ad061c39553f3b12117a884588b3f330625017d76ef3703f34a495ef14b12e0f1df84ad04a83bf83359c8745136eac503e55b2788d203af4e5b2938a554da601c126a22fe11d3c827f1e7725292e43ab5832063692726ba45b7dea5c5b10d17e152df4f0497d8c4b5c19681631e30840c6f08d85ca2af0b4e6134eaeecdb6b296f9b02f654002563dc588089899e09486200e7044fe3a134d54a4ee0908735ecbb7e7a26c34ac8c7862e3eaaeaaae05a243b30254cc135771fa4a45a4bc846b42f9af886c78ab3cec682e28e1521208a64fa0dcaa33e2f76fa315bf7446525c682af32542a82f20893b928896407ae3b91023f58dbb251126855f2b4ccf57cb25794dc294040f34e02234f14d0fb5113cec8c56b2bfae583883ec8c216fd3b162781e72882b11dc140323767459f1eacfb7107ebf0e50e7a282876271f260e25ea055bc2aa8b976790e09fe366d6b722d077d781a29fdf1b6caab58766213cba031408341189ccf8c6699942a5315b891fbe38df540184099e696b520c798ac2f6a6ea457a17c753ef5dadbf11ccee9ab667a9bcd0f5d5d0b0d0351aacbee83eede06a48fd3e9c33ef95adae982a3ce14fe179f70d0bbe074fe6d101e975550113ed089803d47ca7ed0e11a6d312ed13a6ab9defe266826a19fc2ec2ed6c7f949c7ca5ad55f414daf06cef24aaf67107d8ae022142abd8e0daaa20602232e3737b27b9d46d49d53917b783d70add51caeba0e4890cee51da964a957b1c41aeab9d38e66f787d47823d4b73359903569d89f48af18247aeca8fb499fce8e285c94fd38925e694b10904a3b0fde37ba373f6b7627cf5d8cc6518a271d368e4f75b634ef62c5cb587030de83a7117a9d16ce539a5dd3cb38336f22a110d1b710ec55f57261f9ea706707f3e096398876e5b91549ee5d4cfea090cf67f38fb53a1641a01912590aee5022ffabd0c1fb381ab43f602bc70d2a067d9b6a2817966486ed9851c0a4b87da768e3d38fbc5cb608e75280a5771e60048574a898d9bf1f669efb93fb95f78181687edf01bee2e32929674f052e8d1a29ad0334434b7043cc9df514725ac9e88963bf522048d67442eab16e6e40b1ad915f556d7ebb8108b4009689d357fd8bac480c8eb9e249d2c2e676fe71ef6c3df53ebd4af45d8b7b7a1dc648e9ec4a328b0a06206b8bd7ab06cf3ef96fd01a6e7872c30d8cd30dd3b419ffafc09e21777c4a2c00885ebda4a3c1a1c4e716199d7c7f0f24fd7c703ce2052edecc10812d8413f8407b18d091dab978d109cb9d65582b690871f0a5892041cb44c1eac64228581919a318b6b80568c691a843161fe77134398041ad4fde2ab9576f61a87ef4f54f2edeeb12a3c307de10a2701cf526afac413143d86c5fe8708690ed2091582475f0851d6819f330c42ad7ea74f1f8f90181f92622eb3512ab33e6c84f798647ca6cc8da8b70a62cb34c67d30e3d7e5368de3e5b70e3e64c889000cf8efae87f145d85f4fa4f060093ecaa6304efcbe0bc06dd44d517727572fc84c44d89c4e2f9cb2e6af242d306d5cae4ff2ab6dd4b4b247a66a3d3769fe92966e8bc2cd2c6ef3583537d5046e2c3728d58145c78966e5638b88b161a57180e9412247f0311fe8fd81e371f22390531e83c73c33d20a56479a0dcbb260761b7e168defe1d1efab01762d8fac0fb6375b471972f8cf8f2b661a5ace729ecdc4ccf252033b141b2cd2e1011662d1b43d06277f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
