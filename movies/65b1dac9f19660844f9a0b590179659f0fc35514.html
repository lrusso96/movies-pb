<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"379b6f222e923bc2103000eac36526bc165ba1424ae63126c7b6d22ed226571412b5ba7e0f384e74fc9bc4c0310bfca14d3e390142262f3d053586590c583a11f08afe95d7c544d32da21a1ff3163789b67ab972a760a302ebc3cbeae02dd70841d38f5830d02f56c4782d2b27452e926b92ade5940f4cf5d9948fc28aa1a86b683bd88cbd8929787b7ffd80fac2e91141273f7ecd1e5fb631a31ed6fb9cf79973c3a1b77c5f04e596dbfca04dd987da4b553063b3340d967811f0845d268e2d20e9c2785776490a98028372fc4f4b8041b439838ebd1956303a17d00eea44bd86e78cbb58b881c842d1c7a2a5cbb2f5e12842228f7ccb35a96fa1ef7db4613ef4f3e1bd460158805ed720c6e4b6bf9557c850113eb16763bcd43ef208fa613cdc68b0ab2e6a8b801df450ea28f5f21018808f2d688aa0b43fd4fa0c822a39bb97057eb4f2d0b8e403a1c78fa7cefea8663ab3c9fbe7e2ecbb4a5a9df31414d3c4828653903cb2c9ccddd0a893d6ceb12add64c58520edbf798e9b06b2800cb09b0c3a8b0c654837b9b2220aec4afe87419060d9c9e9f95b4fe732c5bc8b9fd728451a8fd838e7467d483ab94a28e70524b77a91e062570d764a4f27569be8a41c1ca126311ea3b1b4d5e2036c70b3cf3e3253a7164910be4e6411c6e3cae135ea1cd6c420e618b792e7f33b43d346d7230aa2cae85e7f7610202ad26bc7f4ddc56f4345688dab7775b8039810ef8aaef7437e966d355579c0d8ce622e1638493b945a175681b60081f729cae9a77f873bc2fe1160d527bcd2a838c991c98321e163ce9abfca0648154bb25f34eff204fe5adbbab9ae5938cce6124053a4f12d5e46644c407c9947db1b1ef26245d50c4972322f56a6fd2dc7935bc4287399be378883168c862584a8cf55de5f410f407c94ad3919892044803f30597e0ff9336a8604c80c5aa618f6af364883af329e9615882064bd464fe188abe9c08bb465cfa05596293b338c5315d744c4397a338e2b528a215d8c2cbebacc3468d09fb9cd709cb5f3878ee324923eeee45b348ae4504b0025b432f9572d3abab1498cfde2e0aba5262bcffa57b97e3a1d17aeb5039bb9257a581ecadae0e47b0b7f2882ab81eb2747c11fd84aba9be84bfe3ff53e58df3efa562537a4a6040d394e75aee44bce72c67e2b4e86d43ce458e5ee2702ee334e398ec57d11e6bfe49a681e61b8c334bfe64da04a9c2ef871be3f178221cc8750a9235dfc3bc5a3728a25b2e3e8ee4c8f807b040266d88ef2accdd562d3fd41e960192c237f6aeee3a693d9f2ba49d0c4e1d2312188161acabda0c7bb6b6b894d18d7b1a5f65f7527b4cb1ef74c48b3171df7cafa5c9822a2aaca65d4bf55c815e525efbfe91e1a53b37ee6bc97a23e9336302f71fa4ef1e285bd63d2e83c72e5b6cb0478de0d549d628dcae9c7169e0de14d0507c2752935639d7672eddfa9d7bf5c220555affd402bd84f8f518f4e1badf39b8f018d06795bb27635f533f9310dc76e8f2d1d77b52f4bdc57ef6adf60e9854d2e9eed73d803dd60e364d828889a4a933034c54bde6b13944e275a3cfacd6648b2fbd2e71c1bd19a8924f0c25cc58fd09b96fc7df6556f082ec0eabbd579e1e988655595e7778de0e470b961d287500073d573055bf414bee43cb29a60bd302c17acbf77a9bda5664c42a28475ca42abf6edc58fcd5abbc2314ee6fa9a058c583415974697071f3ffc5fc4606067cc4c0fa17ce24d2e80f42b717fa495a55c8af7644e4fcaf1538dc64130f101417f21b592e290a5d4bdd00a6dca5c1268b2a082a6dc80cd07930568d1f6ee0f19206f640ea3a35b511daa7164159b08d88dc84cb2b5e62ecdf6cb4d6e14120788e685d3636faf504893b05818767f0557750904d6d2b1ac55167534eb39d00b0b0a7de3692922f7bfd8c85297dfcce41b6bdca62c1d5b2d71acc979849203dd5bee6422f40e188dca87af2d0f055cbc10d1fef6721d1f29362b38852f9dc9b88040b03a4d2548471b6480a139cf2ecb8a7ff5002efe039802b9c497d9eac3ab8d676abd392bb4404683945b691f5207d073193cc906b8a4fa636a9b500e86183bae86cf2253d7097e92ebb501fecd03dc5ab696160dd31b93676ca359c3c8197d7914dcb6ab569734c3287d0f1ec4fcd605d6e191807deaf9cf734cfd81972450739c7a4bf9f90bf58d1da668ceff581defd352ae8d08316a83b82e5553d06e3d9b809de0aee230dd68dadce93d6176132b10a6d1a0b10bcc2a48f0348ccb3fb193bc784d7a7ccbcecdd2de9fc88d34e223351c012a73868e40f7b82472c1312e40b25b60e9828e139c6655d7418b7bebd111db3b5a77a9971168259b8930d605ca1309b7f037afb15f9151f6d68f13fc82a1065ec530aaa04e7eacf0cedc6f7f76643ab8430384a9eded852d503ea2f86786b6ae86001d638f75c3c60f2b516e020bcad9c7ad5d44fe45d50fb3c1a7027621731e7d8ecf64ebc5204d6bbdea341a040ab34c3544955233a6709379286257a8157288245f9f699a4151243bf092c3c5ec0b3f4696323f305f943a5811e3f149b9c8abd8e846b428af3a1702094588aa60ceb00c503982bf4e0e5ef2c4cf59b6ffd8b2c4478eec23f32d4c8c951b7d65e05a0f62357d6c23dad6696aed5f01d864813c5ce49d356394be750c5e1037b0c58cc41c33007486401c93b5b7f34827e9f9db9a5e3ace530034c95a5332d0e063e404d13a49e3c43516471303d6f080f0c5a3ba61dc751eb208b8372d355751bcb35f0bb96f97e34623a270f491e4fbf9d7056c3101ec49ae275d1f35c96b8078726504c66daa82bdf666d03afd58ded7fb8a33261dd6540bec3541869668dacb9e9d2c0b127b229d4db304bd9c5ce70d878d77c40bd5aece5f511f84fee1cc5b7c9c34511d8a92d08f5c7626d09dac55ae79557739308518afc4a1c02b12d79fb12970beb8f6b0631ea3a83b293259fc81f06eea42a540ad421df51c2c002423267e9f0b8d64ab520649c445c2b5b55f65a54db3fd964bb842dc4f728387e31b4f40a9a7b0f5b685cdcc3b85cd0a4885663f7787a1bc1a10138c4118b9cfe57d001c6563c0bd3b40d0ca82f145f55155cd896a547930a4fe34f6227bc77c2f1ea9afd97456212c913c4631ac038933885e0638be3c8c455b8dc423db4162a34a031cbd9cc21c757e37bb1e933e3fa908fc7b273a440c8df347d129c0354389df304adab5192f6cd05f8170c00a7c16b2b3b024a44905aac3beda7f81ef2bfeba248b40251834ee32646bb25627b875a2afdba3d5ec3ebf5ada95833b19500b2fcdd2b0760d30b8c7b284ec2bc7c59052c175a5634ab525e54ac56898aec323c5788707f62da778fc5896ffdea047319750ef12af6e4f90909c9a599de429185bc3891050441e95852012b51561f5d5d18e9444a87b046a05ab62b078f5d56bb2d410d1383bf1b569082234a4d38b3e1f9d07145d6fe2f0205658807b2184f3746d70f8231b259ec7463b2b2e8c8e93781e446a91a46512beabfa1482de4f27cee1a52c35a71661913fd6ed30e75489088c172489b68f9d86432778a20519065669121d7aa1f1ab379053a0e34092befab0990ea2c20a21e13f2aa3f98ed7c17d77f11762f089a89d754decc41a7231dc7e91112c64e08c0d75213505c61f5ef9668da853ec9152bfa234a8b1d926d7563ae5af00593eb2c54fd6d36192ba51d58b458bfbb1b0fd95cbfdb6142f87cd40f8ca8f8f5643da270a2f5f23ea2685bb405ab29fe1dbf47d6b904639b1ded3e525887c1b13f599fa3855bd4d03ec27e2221af741595dc4934cefb457fe985e961a2226e5c2d82e64464fde71119955a8b792531b2f7844dd54bbd69775ccfb474b75f6d73730eefa4f89667885c25828d2b84ac498e12e91db8fc2ececc7b6b197394cf14be46941cb02ee6040bc65b3b658ec0360106e509ee33a1a2da1c35652b31c4021baac4a4903cc6c74df49003a7e1ac5e880de6c2898460d55e9d39c590ae1ef28e4b5e751e1a075a23cfc65419dfd512e8c26b0c1731728f0c6c3bb186da5686be0be571c6079514189e6f4ae956ea384399605526dc4aa74999f77f9e52d5d087a6c038d1781337857fecd3d7c04d87469aa721f19b6d49167d196d6f7345baea641fe4c19c7b112ece058471916307eafbc59c742237420551e0bcf4b4f2482a2da9504ce43c02620bb095cc8bd8c60d4d9178cb446012f6d9e68120bc9ccfb410556a7c676f95bade8627f83f79dedca319c43cc68cbc5b69c993a01a0f2dfef07824673698eb55179b71e3991e2822f4616a061f922460ef6e800fe075ebde208c612d2611a22c9e657aec0f36a9fb0b0ecf5797720bd5c7fe1337752da0e877960bec893927e04621bca50cf09c58d3398de4945d3bc277fef39cb7b2b157aecd33c7c2c1bba7146a634b6272f0d7cf1a6c308eef947e9657214ed471cc484293d29a30c836cb89564404f8650527c0ee59a2185153cb23f397d9116ec01af68f648fb6338ac59c3d7ef38e5b7d305d445c0596742bf0e0c3bc91b282006386bf260f83e44ae8c3e4016e05a8c64a3560bc58f7a17c8272190ba6398405584e31196e644d1a657a5d97876f3219e115dbbad7002cc3367afc7bec84f4fa5b1f8f460c9a9ccbdf69732bd67fd0dd023a7d122f5964f30771e11fb9c99b68a85344d8263036ed6f76b706af0ce6249413721741c5543466e42d5a06abf5aa1bdb3b08095918ed8a8688824b52367e95b35528d19b829b4e2b071fde4756990491bfecb9937282d88d57a17c82d6d3a4c18ad35a42447c02b79792d1bf4d7faafb9eba8135a1b48e171f16fd84fba166efa753c4eabb87c943cb0a2b5a027b5df96ecaac7d0660de9a540247ef00cdb64158216af62f14c054f721071be918c25f75048be967e4fd69af408b3f7cb3d77ed5c63943bceccf930eac74dcb7b15938fd131f761a53397644d558bc8014f9de88304683b0b2ea92af2cafaaa2058d7f617a2adf0febd349568c115a4c2c348534ebeeabfddce2eb0de6d2a8ff27137cd54224abb6b619eaef84be5df1c8b894cab20da1fdf1eac28dac0b5153567f7e62825fc6eaf7333e8c178f6156697a133eae104ccf0f480498fa9bf51b9be31a7addfb0229060a50c5b7f38df2df1e61d5d980110265990d86f8350b5d67df67c3fc47e64803c8ae70d2b604b61997eb88d42bc28dc9cfd90f8903fb51dc4affbc2a2d269205a55046c2e5c69e159f603843e26d647b12a25e155c069268da7da513ac78336fe5930cc0d28667df4dd501729225f5660555b8481aa917eae28cacbe4c667ec2cf01dc76262a41c8bb349a8c6633d331dea748f3a83c785c34f4055672e195116b8311aeb6872b2c85defc8b6a3f49cdeb109336757713086e8199660225a1ed0fe8c2d63b19cf360ebd1eafd8244316ce3c3e4450c0944bdf1d4e2511abe288661a34c4a5e8daf8d39eb7cceb7044d2d4b5513aa471b118449a2f69c4bb523501deff219593bb887612fab8d464aab4017624c193ae3208524b350b4c2925b98461428c0103843b4f1cdfb9f22bee6d257f5496558061b735678bdc561960a6e85ef71a130ed1511e87051d12796998b271b32bb3125537400d4c59930d3972e78bad19a0feae8f1db376dbf9f52a27397836c01ed61e9d54e19e0a7953b265bf4216586b029c15fd6cc32ccb3d41135ebc715b92713988439c8db245a8a49856f29d49e2007a8cb7646540c2bda76a0ccb242f4701b239e36c42a0e9c853132681451ee1736795d5ac18d8adc2d18e48857985f84558a44716fcb455d04cb4da9320572c3e2b74618cf04ac585754f579bb88ca2ff0ee77ca2660921a8abd09676aef955acd856fa934478a8d16787c22c4da68942342edf8e88411a59a68e2f9bc841c92350c8f5f7a311ccb494a32a4e8f06bf0e4e6895efee3c59dd85354b9611e54fb22da8f24ced07f088d6cb7ac29a948d0f56f55c93d1bc28a5dcf16e6a8fcf50ecc583ec03f796b123dcf7a72c5865ef67fab9454498e242bcb13d8d6ab2bed847a35b17eb4c3baf1af7e2de46821060b8baae081bf4c668a482cd9accd40a090a18e42069fe77bb33135802adfaf60ff03fa6563f690aeb1826b99ed79fc805c3f70c293d61374fbe848e54f1fdde3891dc4c1db96e597bb98526fb0b455f78019887b40eca69a27a3b3c6d806e737924af6184580c034f1161571d8d4046f1df266bfb37d701ded10e46b6b6dbcf9ff8906b8dfa7c9a621b70293fcc2da5f5766674bcbccf2da4783d9766344216bcfd6c880badd9834a85e64107941a7a215554e8c600bc900d79687762ee1d3bc9cfe9805acbadf2ffa64b2990a897edb50f2d9622f82b52a56fa77af6c31941543a1a7c1630f86a71f09ab3cfd9dd59baa6fda31ed8964572f7103281ccbc2b14803f887122e11425e1c5417d2b0b048681ca87dbc6d435b82d2696e4d33604568afffad16a2f47a7ce57ba618b00642f60ab63589a00b6e49bb2e589f40746c03a0b1c8b7017a39132521c6ccf3fac916863078a932a8f5c35610ad8a939dfa961f8c6c1aa13af52cd03512a94fd42cc47e576ee66c7adef01634bc3a0073d2543df437ffa4ea2bfe86d00c97bb204f2a4cfcd630f2bb39128d7693e9a3d9a522e1c522acb947a78d2c829ce300c6bf8a74f7db67f66a5aceda7486136db5044d65ed2b10fb84c07777b91932a96782b69280069ae545162b95b48aad8a91a8c847ed007a9e3a5f9ab496e62e0f95e7d59f2e7a79b556715942d1430294eb5db9b8f31af0c5da828e2b48e2958822ed0b131222a89ebc547b0cb6618f91e559b0203d899155068382e936c242a7f89db964f0b29857663adfa388bb780f8423235c9a0d6a5ce6c042c32f0858da61796126329d3ae0e722d3a56ac8728b7c2be484499f82766e71aa55bb8b39d1dee07efe52989221a536ce0b8184946d0b38ee50f59ca4e5fb7fb20ce31592cba29b4f8fd789de3178526f7e1f6e5e4dfe9b375ff201a556466a3ddda30b4fbf7ad436c2fa91e3a10ea8818f9292add387914c31d52b629171fb368f9a49d4785d7f77d410a27b7e81adc936bcb861e978fd81b5120fe5df11d4835f75a633cd067644162ee5b43098d081f0cbead2d831a090f81d25cbab1f44b92b54c001a00df369d377c92c7f6b81499457082efb2c356f21d96a5c67da443912484eda5b32d0c6be6710f26076e51bb124e924ba3d17f7476686fd180ee5b3c6bab2ca8667317b4f68f028f0d3105586937eada985eff2995ffcc65d78622df4029ebb7925cd490e32cd39e26e874a0a52e9e3fe9a750b48090ba96cdf07ae87da97a75e29dc422c4899627fbf257177dc06fb9441daa4bcf86acd9c84ad4db088d235934412bdd8ba30cd9d54c1a72590e6f4e5eee2c8f8f2cf9452d8fdd543be5bcc08a7f69b641a1c256bddc147c74578a76534808f90519998c1c4e838519d35bcbe5e5dc6144fe65f9470e33134a6b05debb525b113baa8149ca58fd38658b42e1153cfa6852155f608b02338fc0d6f642c7207fc01e26a0bed53c38d5cc25af7172c1e5d498272194a13af338edcf138c83766f5644eabd393f94fe684d6bc3d585b3c7670053a3104dc14db779bbc038542468e1a1a06db24e49a84769ce36f617e5f42702c16bcdd4a34f092126570c8a4e267ac96d6ae76af1fdfbc47059763eb51a2e914f5a8ce2f434e6b9e3bc464fb0227b4f94af96b0709a2b0c51aa082bc5a69fffcbaf1eb4ff55774f8a43b9a30bec12aac50803dd09cd69f069ec7ea66b915fa2b527639eba5762f93c66447b32497f55e83a2c259fa06debb265d0b40d6c4737c7c37d32c8d34695b1ea7d2dbd5cb228075236b35651d98dc04af46ddba199a5990fd3d70dad260e29b315e5fac772b7eed41a157014a029c87673caabeb0bf16d2e670d65122be6f167dfebfcacc3e9209a8b6accc220b6d65198795a2ba5c1049cc45c0a23272f2cc2f2c754d0f010b393feeade076d58b92c38de7dd41cc70d29d83a17b02ce6c83038478822002b304eaade15ff3d0ce9f75d81c946eac3086fde10119653d7b90c40b0490e7d853576a58ea79284b4a951498827fca265937511a588a43130f5dfe2a330b41cafa6f9aac7bae953af6c91320145a3b022441dd719ed5a3b733b619a1e458f95823e0e0c8eb33a7a2d0d25e4805f9ce0fa9b9e75794111b580cb9cb6cb5c4e9aa624d0b2cb4fa9770db61ceac8415a391f40431bb437a304424108d03a5cbd36089e0cde0da11eaef4b40ccf881ddb266505fdedc0724ef48e50003a3216957caea4ca4dd6287bf1d52ef7468afafa3aaf81f32ed7774e146032e7588418b6e9ef19b98013c9c18c501e7d5d60925c798f31da9e462366b447f5580aa6a73c7b8f6d9854840a741665cb039381b057988632c4c46bc4e012977cfed88dfd99f5c13ccdd18003735aff95642fc93f074c6ec669f762681f8a63b111f82ad01bba45c1d12897ccbb2090c55672581ac3b80b3ba7a88b02694e95507cb4cda8d60f9e30aa8bd2e93fd86521f834fc98691c3e9c74d689d738a7966c16c7f5b9f7be13cfe04bd82b2f9d22f123d5cac97190618ebd17b3eea7f7676417b9ca79225f9c7e961e73dac96e934f8b093e7e46333e534e136c1b68ac4f80ff090b644fdffefa939266b728999a29e597b4465eaa92dcb2baf928594245a2491e5ba68db9fd38abf71ce9b03d29b405bac03e64955680f6e1640d312fe0bfbb6a56e8f4879845878cbd44a85b319a323d7e6e3828132c92a76fa8feddf6797508ef3e5c888eb463f828c5c8b848ddcbe973ba872c2374e16b9eb0f5ae21082d3531ec76537fd48821f27d37880dcc40ea355ccd5e1c16c387716a542aba6dbab3a188823708e253d8f288baf0665c3e0262396c2aa61813d33782d5c257bcc17113350fd9553d9631236d6f36a0b747685c9a6fc74ace94d1b70d6b869dcb9c34a0e01df130163ebc045154e96d625052d4cba6d8cf9761f8d24de42bbdd5a579abb3f20fabb33523802addd397654e6b195f7dbff46ff0aa23c0c3a9ad0e52b782a44012fcb9791e4f44412de2c0d48947b2437afd70c7785f990f8bb00ee543588efc365ecb55302450f39600d38773652a58434893182bd3611b9597dcaa1cf1160a63b7ef33e420597ef43b9dd6889ce196225c8dfba75139dda75482915d821369e7a3163f9eca8b5b940d0dd52a367e207a9454e7ea409931cc614e996669f4b6e956c58b34006b3e695625cdbbdb97267e063b0ddf45ee4c24e454d7f693bb5b78dbb908ecf3c62ab5ec2c2cbee79e20a0d01cf41cfbd1cbefddb8048ff31ba1e6d0d673350f51de6785123548b8c39270fe1d4cda94da99eb04845ca0f4c9d87d7d610c6a8cbdf6f081cdc85f1f0a00b7cfcd71f933f32ed5ab501ba242ece1609ab19ffd49bb036477329e107ea7092aeb78369f574fcb15003609dfbbf40878260c21aa1ff0fd9d1ff44bf6a688c14abe0ca98b7e1e8b7d71dd5a8f0676b85707f90ad3814a0dcc97225682369b6261179ce3b7d20cb27ada052fdc6f3f0473960d9dfec91b1396187ed10ab86977b33a8fb549f8e7a634c8d6ba191625935f2c4eb7d5bdaaa3a056abae5286cd3df21d928230806b522519f8a605a955518e53920923c9e403883991299afc72c4c361791e8381ddc4f5abe6bf96284712f773a12c77d50da44d65f16af7d276753210ecb0151ceffa37bd9078659c5dbed8dc70de198d99b8fdd15d440736e9502a9b801346b8845e58497305543eb615134a1bdb416402f8ea577096be58b37dade3c436a49c49027e1ae13bd6ee2e0a1d30ab651547d5cf4a9762d466ad8a057468a31e6dd598f77ed37e527a32cda22c4e432d51a9815925135ef3c99d3201076aff3886231bb9989109745b54d054f2cd5cd6fed0ccdc205b75e99a0ddc4d017efaf650a23c59ca712a25830134ae0c294bc9004b0888ee51b85847e7aa8808a5573f4e3c7757c4782d39257c4c9f1e0d3ffdd744a002cea7a06220ac3350c769a5f574df04618fa5f2fc0bf80b26101627f4673acfa9eb7957ab719faf107d83baf1778d91573f467d76198cdc189028bdbc04a5f9ee1ae6dc52aee67dcdc46babcb0f8ce3a78738e920bbb4e3461beeb7b092fd92a0125f17460c25212473e50049f3059c045d4818723d111d9222c5f5a14f5576ded2f2f76ef16ab35bdeb01c621bb89e5e3f5da50d11c878d3c44a61f3774b857961304335ae60b7b2d3b90162c32ef4ec3da5780e7d0690aa5d0f919e1fdebe6bb70686eeea2fcfc5ef5e69b54ae5bb11a7e2d19427c9fe7b68379c5ffe8972b84d0743d6eb7c29f043f191f6f33c687b798c02b4ef9bf64e678127d15f744ffa3dc423b57d8e4cb6f2e1982520fccda657359ca7dc84d10450185c9ab45bfb30621f791a7f3892d92b7bbdf38159d705c2106cfe8224115732a83479b9f98cd4b9fba60f5d6c0b28a20b364c1455c41cd22e217f3049979f490501a22f81ac6a73ce7e16fa0dbce476394f662a87dea6ced1c351df4da3327cee0cde13c7090ddbc28fc773210cd2cc5bb74d953410623235d345dd1982d09b7b9d7f3029ac36abdd584b778d0aa9c9ed87cf18735da479c186e0db9984c3e1847f57da884de9cbf003caa367a04ce6bbe949ace1a13715deca437e689268f870bf69c1a6f3494998fe1dfae2e771a27a94a21e9a9618ee0d78711c745b91d0e1d2c7074758159917525e9ae59634af4e4372a090ffc75baa053bbec4bff5ab7c382a7df1048b037e4eccce9c0b3029fd3538feac2fc4082f01103e47fb47325cfb5fd9dd30f6cbdcfd2a628ef4295d0c0c0c5d03e0f8c98162f614683e8d49a06e919fbf51d4ef75c3ed422cc52c759bfe1e4812642c424f02bef6abda932658b303446b44629682474b3116a7fe008566a43dc1b55f92922c4607cd9732b91fba8635cefa8a2a2b3127691bc51b4660a051a10283cef5c26bf3ab7717848893a05162dec2c8defbfeef94bc0e12fc4788d7ff0d9f16f44a1565cb141d85d88821d0bd91754b4be719ac3d9368f698a28b6568fdef9d0a7eb78bfffda2990c9fc8d64bae3d63abfe75570e7662e0e06d6e3a0f31e81038973bceaac314551389f737edd2a9c6876100c7aafbf51e62aca89866728ec22da9fb105ed11d3ef80908dea1a85828567990c2e7d2b1b1954b9669e6956db459432cd2f763f4db44aabe5f925546f25c31956dc89fbffa8b1192a34acdb323528105a2943dd548c73251a832e0ec96cc6f2cea622007e3f0c799858caa3d5caedb9dc32e675d80b116cb7f9a869bc6d3ad2a93a42b9902c1f9c7a2dcff6991bd7a4d551f981a2a71e8137866af3de049b14884bde495a84f6a291755e23bf8f8f60c74301978d36578ca0cb5633d236551e7f78040bdaa1ee59d9f17db3f1082920475b96685c3ad51a063c27188f64db8526f789965eef5f8ab0eb0920f8cedb1be56c896806f3bb9baebd35f6fc9131121715416d0ed7531eaed6ec65f1622719c6961c860f543bf36042fa5146875f063b1a8d7a8ecfa26829f35212fb2515f41dcdf0338666caba828714b022eede3a58fc782bcc46eb99fc0269c688c7963b2f6f755fb441c558327a41a681b83de2d58ca3dace1583f5ce8888f32d32243cbac91dbbac65f367e74756c25d6ecb6a427c539cc2d1c96c1270f979de774ea68406a0921c34989b9da2c9a109ec0a42a5b265de9ef5ae03563e065d165e288af61d1d9b86820ddd7a698799d8e32bd3df60ee8b9b75779a0139c8b8fb3894d16800c457f2946d43a3f6950bd90c9c199cf55b51987a1915f92aa5296f0a65b3c5b9b8c004c46d5b896b24899ba3bbf9a5b59d64fcf04dea65ab2ab6f3d5ed2ae1fd0b92f8025195eac419b0b29e1cc6d06590eb45ad9c53f3649666a93a2c42a72d984a803923a211ef75343642bc27fd0e76622bef092f073b6bf26917750013959f177dbe461b13c1a849d8d7c75c4964f5fcb33a02474e3944623c374f0b5ac308d86f2ec2482d8b172614733ba938c5cb28c4a4362ed53a5c5d3413a29de89c86ec812c6c9c8aec9ce912ea590e91727d6115a74445559ad506204780f50038eedcde946bff71d621968d009f830a0299f77d92cb3f6938265dea8c86c5d7c7bf9437e0c491348579a8760d1a2b5803b50701eb2fc9433435086a860e754c597739785d7c54e8440cc794c99b08912f70f2a56630e2739853d672687576ba19f44fafa13cd7cd588ce0dd07bbde033b2c69a67ca3c55977172237cda512aef55411b4e7ab10ac220a8ab36dc2ccbec43f63e8b7491041b3cbf6189cca0ebbc59b65191057336f89f30a912b7413e41071b23e4fce1d752793c562958dd003e586d53eab42a064a7f428630af909c222ba6774d2e433fa293ca48f0aa185dfbe25f9e12b60a1a1bd34f6f1164e6076483c9e48eeebf1f8c2fbf51e94acc4658d93997b294ed80015f37fb1b8f815df66ce4cfe7fc60bc9efc70c02fdd9cf32694fab28c3c2bae2c80ad552822589ec567883cfcaa304ad917bea673a5ce7489f75002c3014e5dc445827731df2fadbed8b4681d821aa4d8dc41234e8c32a8b3b49f288cfd10fc18fe3e47512cf5d3044e066ca5b6bcecbe30774deb843faa81993b8f4837947271123c863e55074a2d0395685edfae465e3196e8d2bc3962cc0d38f9e62baab391f155975f2e74adc24b654bae344c00d0a658b6bb02382103525fe45ae160999f1f7cf082445443fa3aab5780de27ba0af1586cb2bf98f98a0c7a22cdbd333eb666a3e535eb1a70fccd1a20a53d7af512134308fa1cef5346cb1e9f90482cffd3a05eabb72ca97191b46043305493f837eed692af873d85c24fa4bd4ffb9f79d3451e8d7e6dc93d9ddda9b997c5a7f0ab6a77248126c8fcb0b030c68964b2326d6c513fde9deafbb9d65a45e640c7814dec622c56a0d1e120e0ecb0bea9afdf2d175692b9c3961dd2a1557ccd173d9d5a7f3bbefbe908d57c49dc4b2f9f5decd3b28364d4173f7adb7b359ec62d34cb4307294831b4abebbfaa0ef8e5fbf3f5efa50cca4a7128418970d963aa227ebb8447dd0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
