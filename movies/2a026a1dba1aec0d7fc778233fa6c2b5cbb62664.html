<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e6a2cb2450f730055ffbd95f676377c2c6e5b3fd0552dfb61bcecaf256833f48f8af2becf410ace9220a236d176ab89fb2877b7b3e4046214fef73f407fa6beaf10ecb7ad2e05e91a27ad48e56b4fbfc3172951462a72f52aed936633e365fb9d06485a27c80ffcf63099c1350c8ce1ff7aa63defc08260073c21b32338bee00bad8f0a766f6acf30e4c5ce57ea54d3613b6c822eb98d3e4757e63b69f5fea0e93f8275a8faa2573d1af967b7937ebd0326ef77e73483c14fb3604268aea924de8f478067e767d1622055c4b0a3a10ee4ac155882bd82f5d3dc29f9b545dd49c3024085335c73bfc6738a9b42865a530efd7875e09ca8694662c55c0ddf8dfb088e3d66bf1d85855ec12fa2d43115c224f594b2b4fa7e0676ca6b1d44dc2db91a6dd996194a1928cf48eaef337a753a1cb3b03e4756fbf68a2e99e8b3ce1abeff8272a68294329751fe69fabb9386d060d37d4b30fd3acc3fd45c970d6c7c8e49d4e046b9e6ea44ed7e4a5ed65ec32440cf9c17fcef89eaf81df65240465272299c3489564d8cca94c6008e5035a0b48ba78d8a1445de653779914ffe9cda2da8b5ae654ee18764e583ba0b543dcb2e5e24b119494cece030ae8e88ee998d55f948e0acb81c38c276064bda5aa6cf98fe24bcb435ab13c38e32d1226621fc2b5c8c1ada5a4da320656aa6d49b8a18571d16abd591db93a42a2caf6ab6592d31177e0ba2e66b56ca67b1bff5dec4f0f860e61963f92c64aa556cf6d75303d8ecba840ba1a9ebc9a261bb155e94633df5863768f7f108e3843101529499789f0f12111983118df0b8d13b45ed0b8a9433b2119535ce562c4009c550fe65ba3ccb51c3ff987d8db16101d74c873bf2c5ad8eedaea96d83390dd5cfc51c672b2ad5c16116ad2650edc15de709eeaa32470e03336dddbf17007cd4b0a67f295c1f274dc8259f1a69b9cba5ca7129b25267f88985c5f5e6fad47a7fc5aa887e747356a07f53e0d3086886c66929d2141d82c2252451238a83c19e0ab9f71e8d66e0368e0421d2a488f2d6604bea50bc168ecda9b95ce7a4a51b380045afc44e5354e021420a58d238b5fc5bceec397e297a02ae44298b95a4a7a7f78404eaff9248bef3fe956e821812d06ca55c5bd97a0ce220f4665245f6fd3a5af394f1716df186eb03e6e2ab53368b9b221d95efde8c81741f681fa696528d97f791782caa0ad33310a0cfc156ad17f4d04c2a8c6cbc5042cbc0ba4747e6cb5788eafc5f12aa99f4d482c7d6ca00ca9e7c9634393d5f7078a3d9c8a223ff5d6938798b89a7a168dc368c63e60aefe8510118dcc3bbba920f2f8a44ab224b86d4f473d50a5a363e610b3f47e14e31c996b57c5c4e3b2e1320249873a8fbf8e34718826d107b1c0d3f611f22a6531058472b8505ffeeb39bb603b52b3de50ba7e1548ce8f0541979696e0cf6a209e8e50bc4a5a6127299711f24dea3692f2769333c6ee5d88f96b4719ab9ae896b92465dc32f6a0dd11e85c65845d5ed9385bdc11a46f3d0568e1079b7eac2c3bba4c448691000cc369e1f7529863dd3a8aba6fbc5eb5f904eb7789f7b3b415221e897e1874209f721c8e8a0b018fcd2ad651ead720fb87e0810a602932c140100e98d20770646e50450cf206dd39061d5cf8edceeaebc16876689c1817e76af1e28bc1019c997e67b0b09ae17b9821fb64d7ff6b59e2d9c61442410acfa5a50a9eb0dfa73e3112babfcc1c252c6e2dbce4b657809ff13cb2dad9df802ef80b54fceba0c3a166281db2245d15a76a7cddd4cace673ed099cddce6351a1f128a382c5ede524de28acb37b747e963d28569afb3623461fede95fef945ec7f7bbebd1dddbae443fa3fa000e4d3af7434b526a24def20c5d4ac94894f62fb4ee08d66b86f50a13eeba57c6d11e67d8d19dfd587d9d5d6901074b4877ba5c91c23c4159c7bb95b76a6c06de72d76ab75ec09488210831142fe045c18cf69caa4c6bb49c81daeb993440845c7c63107d847670f41ffa9e1bd6ed70b5b16f5f65f4cfcbb1663783fa4f7ea855b10db6ef85b73dce914be44b75f833b54a1fed5c04cb01027d1283dbd5097d9c57b9a19e9cce6d384be7c8678eadbbb62e776c69f328bcd18cc251b6ff898938e5f25214ca59699d8e720bc45f951013cf3411bec5512b175ef2cacd0b80851b27c161e800d1495d43a6d08e95fbfe2a3b4e853ced5c6541e14dede1047d0be0586ee4a683741bb916d47d56a97c0e750fab680555709c1d583cda82fdcc0b01de14f96651c8887c9f07991de10d285d8341b606ddbb454c8ff16a8461841d9311f9754963f1cd3b9904b7850fdb8a8e0afc24a18c2f689bc815728cedb502d8c4ef8b79bf49984a3adc5dbc1f41046331622bc60bb71f33c1a48dec0b5c72d5c5d0e57f50ee22638d143a3893f48b57a8cd65d3b8af4a70bc67f2eb70d3c39590780dc47cf3938d54eabf127929f9f9066dde2cd3a2af7a9cf751153a5f56b2dff5e2cdbbedc60da81d4a04b9466d277b3f0da9431632812db2115c92a4ef7b184b6e4626a934c1ecbf144e185f89e46a1d8619e3a24344ad6af41f3409a755a1d6a872b0d8bfb79edfdb13e7f9569f9101c1779fdb83710172047ba062b3f865a37ff854ce82a72236e18eca5467d06afae8056aadb96bdc8d25376626583703e7343add5d8dc3a7a136f01434799e623637cd4db0d8804f6c63e2171473c2e29997ffa2002241db997b83d99ccf70d39b0f9bc78e2c328cb36928e63b017db82e07ca6c7530af3c883a33b8e7ae8d53f36e81fa9f2028e9c6e8157e70fbcd2cbca720710fe4cc285cfef998522bebcefca69d3f10387387899757136dab597f89a20d32d677046ca95d1813e7066ee05e60fe30a0ac4f42f0a1b11059bac686dd3153e092ad8f68c95ad8d35e28f85c6145db70a023d3733f5c97922a51e062c117cfab9a209223abc6038fbed31263e34435e67fb6942a0c6a8f0c836a529ac0467871123f7b29968cbace1fb7f15da7625383531c3cd47ee32a55a5e5f952c52a73779423710cdb7077e4c121f5ba904dc59492011ae7ab0a977d1df14bd636471f6f7f1a304b7106c977c179b908f87a128b543db8cb4f691d8980c7f2ecb746e83dbf26e2c0c63f9f76e2b1fa6f1c349b72cc57f00315510ec38511b81d4b17c171467b58e6177976989c20ef467007e3daaf5929c0c744db63e74c951b7fbc12118733fd959c91a1ebd316193515ec779b8770d78c401fead0259dc84f22ae73ed0fa1a894d162993526a9894190c15ab38013df6bd3af23c8f94d9eb468a3241cf2d40c694c0f96b2637e2cf3079a5c25ba1e1765354e39d81882880a5772e7f7a1e52b155c39e97bd18aac18503158edc3dfa3774bc84e48dd311a158ce05044632f0c0c3d5219055effcbcd65303f69527a624156b39d7dd8f6294c44bbbf4ed8c353bcd7d58428c0bd7c1bebe4e315814b63befbc820ab76e6e0260d86799e718930679d17e8d9502f9be738bf956b092c62fbb220fb052f130b8b828bf0d34514ce25f9d6da8d2ccb8198d38114934c21b1da3f8b5127426420f1be73e403d6323144b2ecccd8939001ec6f8351ca2baaf5536df68b9937ed0e9e6d162a9b475f0d4ea4307c5d765aa6ccdcaf8e3850b5d47546e1fa2251900d88168cd5d2a9a614ffd9b26ddc780907eae423d2baf56b5a6441ab2dfc9cd5eb053511171154803007e6345de3ed28b6d7cb2b12167c194bc0cd9b9731d0f346e3801bd2f3408f7a4ad96b5cbebeed51dbe185f74fb1e341be308be7f9fab1aded2c85ff469b4a6cd5dd653b09f07c1a203eb0709f32ca03da31454e273bbfac91fc7c531c252bc7ccc77d64245e8ff8131f65ec0def9ef20278bc50dbcae8621d23d64c6f6257aeead4f04d52f24876e0fe1835b6e60fcde7c8aaa19b7a09f715d36afb201c1ce6b8757eba4c80e1997b595994a59ef4741039aadc84718574ea1d44a4bcd9699f38012e261078705211e29690c86f67d414a16a135f9dc1f28ea3b7534659158fc8f74ec506762a39ad1a868307ac62dff11f191e1124dc5e66c285c7ed60265f9ee740631efb165ba62eab7179aef7192e55c7720aca75b8178f639e2153fdf86d8fba3aeb6b5221b8514f66b4d80b22d543e746e35d2a7d7b8bb1f82aeeb96041f7a34a54427c7d9a39a16a0a910fdf2a5f4f18e0a6f21c5e839e4ac19a15acd7ba6ce6e74d9c69f76ffe16ce7d2690339d1d2685dfd84e52f168dae40705c76774789092705315537a668cba4027c9e4cc5df5d7626adfda20fe8b0fbfbac5dd8b1545626cbd9109f9d97b3bc197e7e3a46694a1482ed50937c72c4999e8779645e7cba2ae726faec03c2c5e06db3129ca679ed513e0bff1bb5cfea770d61c52530944f2cb19b0c16c9185a823a639147f16de588903dd4b60f61d5f646fbba5b807739d40841f802e694d111d0a5e59f9689ce844532d0099e962e3195d4626e2ff504ce75ee820a62088d7e53e20c4f83f6c626245b7ba717067b2fc6bb5fe095884528e738688859a9cb2f7039aac53efb73cb997212797e0d5c744edaa74c6ac9eb0ba8bd676d6d05f521e6415b99fc10ad49a66fad920df4d8b905dbcc856b85c82e92a3e239c4fa3b2ed5d9b02aec7f1fe3fd7eebdb78e4cd1ac66548e750d3821e3fa823cfa191828eae1d37933cb6d9a705716badb9501d0868320aa84def129e18a911f1da62cdaa3026102d4624558b6316e492dc068e61c40c81b4e043ae8ed2877c15df01c3657bdd3fd188d06f565836d624dce8fac047a8083e34dba12e2b53508b6191837a2e241aad0af3ed2fa07385f25406f03d4c8eb14c728e6da536fce2f38ca721dac1a80664360fbeb9041fe91e3dc4e422de40184d3ed4101e372b33aa96fa06c79102c9fa42f00db7eb7e12cd7bcade74d9b207363c8baecdc7efe686edb66b54b2be509b6266f4b495eed249d7d421376ebe4ddd9173d8ea92208ea39bcab2b51f5dad9c9348fd0490b6bfd40c216d98be1f2eaaf4211dc2da1c3026f5c74f75000227f2d8052c2373019c879906df9b244275f5ca18a7107b2565f2d68b469bdc41ec15b1d3bc552798552851d84b24b6caab9e97d2101b07469bfb139dbf1a4d300a44a061a8ab6e023ab5058cf75124a1efe5a1124563d5676780dff52984880e217db42c7f59294f12ab925d690dfa7abd34b069bf350dfa9ce92b3adc20e5ffd94d191cced5f93c2031578b02f6be1d508a557cad5779052e5f4fda1d7a47ff0e98e4e1bf51709a9f44c97cef856a4a35ad30e35457a79fbcaa5d4768b7be62ed3cf26f5ae103089b28b333f31f4a5490d656cb00babb57a8ffacd254d0163602514b22c5653665d2748e6ad97ce1bc2000ab3dda0a032edf816e5942d066389a9121b47bc2d2f5445015a4316007e91532e3fd233210a3b12713b4ddb7c9d331ad2439dff6602ae93fecc4ab7d7cef2c51af565707ec834b2729f3b16227b5acd51acecbd7683e682afe31ac5328c2f78077efda2df0ef13041429964f19482f0b82d3c1affb5dffabaa62294e45ae7ed352dbb35776af4898b5efc1c27eaad67110d60d4daf61c5effbc28a2c4b8149a6a6bc3d0e134ed96c59f8d16084a1021ba5d76724ca024329dc7a01c85257e57dd0d8c7c5351cf0a30746c1c2749382756ab82bf312ee85130861a3671448ca45eb13df3340317c219d4b5aec71dce5d33ed7fcd7bb44f0ccc3fef4f440f0d9921a21efb5ae65e56d7a2d75eba028b00d92b05151d9477aa419cb38eddcd878712620329021495b9d3c2ec3af73aeac2075de5e58acd8a7dbb9b4fa19667daf30439a4019ec7b236e63f69cbf7c63ba98b77b2f41bcb29a3502f83226340de878680487dd5b6730351cb08c30e3bf8401c6ebf73c00d6b2c1c9ed2e310833d14c97d6d0f7df0f3809f67a3f2ab3dca1e1b2f91a74b02a4a00a443ff088330e1b27ecb16816eda343f6f1e15a1fa3829f74000c5ffb573e5832b81fb61d9228157d0ff3e4c32b86dec921999ab44c6b813e87201361befb21ff2c3e1667aa3d60bc257ebabab38bf5b6e477a69989d85efa04243ec365fb159a09adc95034100d37bea8c91ac1e22cce74612cebae724ea93cdf6be9514d144495b287700a606fb4750de9f1f1dd64d46a35e0bd9e2c37f536be6ed5d9034006cbdec14fcc1b8f462265a12ac89626ffc1ca5c5b11a50cd96c0778bb86d25c3621415d8b788cbacdeb668e74ccf154aede419563bda1aee44bf6778f1b2e5e1121999ee98c1f88974694d44251018eb9725b5bc22176dda70c414a08dee940f8d988b3ff4fdff641be56ce0a51dc6d8d02430f2f8784412ff8e04497d22b300b996c41e1ad58dd2960a964cc69e359e66d957405cc01185e4ee8f723a3e4cd7decc8209631e2871d180a77e2f028ddcc5dd7e76da05ccb52c1fe02b0bf8064e1e07044ffe1131ba147a9ba9fcdf62901fad9b2a5d8f3d21afe41f0fc3b8501b429a1bf6d02b12458d93df8b77ba6132a794a6bd25b29df4bbdfb390637c062a83e77ef449a1ac0a86ea844b99de2c49effc3d2c4e4889702d573285c4e632b476bbc4c74c247c0668ad533690402c77cd3942eead3818994b97bdd684f431dcaec44be26c92661883db2bf9e4db226be70db490334ba96807b679150543f9007d588053a0e0ce9dd94e57ac5a08b6ea05b0535f8f79ce8e17e91afa28def4aec9eda75af86f50378c2f05ffa03380da42dd5bda651be5f13751f0313ba2dd514aa4bd977bf3b4023e1d1b3bd2fd1a1f6ab0ccb4daa76edac7f6401c3cbcc0c6c2a6a7b0ac7105f7d59e5c25f0e7c88a4bbb58c1a9439b7b20416b88c53c555f162f043f1b1a2663653b7b2084d06de31a08c9ee1d5ed10d2b30cc4af0a08ee9cd102b2c89a64d33bbdbde8ececa61553c97d7ac3cdc5c81d0a548fd0aec61eccad7c57bddb805fd581ad72573a501596740caa9dc02b08ef096d89bc668a9a234b50c4ae70a04f921ce0233c63b5a158d87a8ccd898c4fe69d95e44f8b10c167e9d89c640c8e5193ab2c22c78732b779e765d7246113dc2f84e35d5b8634011176cf27f018202dceeb23009e6885eec20440e99a9454eb687e3aeb3462410b86ffe5acedcef4903a6c0beb9d120806879316d0339e66376dedd837ebd67c14683ea4523ff318417117792730e1d8af4f822cee6f5b71cab8b835b062fc3b77c619e34c830476b8570458c74313639587387e473e9523c5035e544e57b42b3a25fe88bd3626ba77a1580444212305819da2106e46b4ff6058f65946677b03f4a3f874a16c1e77bc440dae4a93f227f8acba9567df7c13c5945ecb6231776d313bf365faf886bdf492fa5090479dd56c0d79368d62237c7b0c9307c99b01d5dc99f0078208ace1bfda15e7f1c3c0a2851c1638bc363610639551d9100708324afe53eda982cc29029f01889f8d3b7438fcb2774f4d94765b934197ca1e74d4b86f0efdd91143eccec92158098036abbbd2662dcccc1f3bf53fde2f087c4c5e96858bcab28b5f175f5b87bece8bdbb45241fa31ff9ec33d8a45459b44f18a95e31bd1515eb8701161ea48d487292b2c774a04193d91d26f00d29b8fc8c6ee57f522b0798e65fd5817ba885e050a02339fa099a2f1c3fad222e52a67a23f518140bebacccef498a38ca3026f55b1d309da64d27b00cde1c4bc39954558c6b28c8261b9e73fe33a2ea2090716cb4cc80783cfd4becd5003626915ebe1d9b20cc85320417c152e09f496d52b6b065a981236dffc8d5cbbe1cd78e33cf9fcd35b1ffefcc8a728d790ce432e1698c54f00da0d9adaf5e4c76e5fd44d95cf512644ab44e052a3fffc91b80c93785e9f6a4b9621ae492a02d66a64ce0718c332b03523ed79bf20dc39f23ab586696a225cc33e06d42b13cd5202a81fc48862152cd27b46806e94b9881603456e27d39cd50fe892b88b54d6a1348fff0486e70af2c97e8425f1cb65abaf73a567dd5b32d4e99767d8e0b1eb569f12f0e47835b814eab0671fa015f24b9180200a3f3971095cc25e6327ecce20909b95b2df52dd84f2c9ba9e0d5dc48e82bb2a6b8106c1d4c25c603ac003528bbdc664f533057f586e65ec33343d0daad05c4d265fff189ab6147a8480b217868d68d18dde4f901f5726c99d750d4a33bafabbf3fd7f1649694cd77b5787f1a1c12d7c78b0a573a260983cdc4b8ff6de5d38eb29fef513ce50342020e74fd23628378af713f2579fa27f13c1d92e19082764b1be1744a305096d094012c679bbc43c5b6164fe32fd5a16e1982176fe944b1f965c537fe7d1ac5623047556328140b3f9f47a10287d0312ec9c5636e8e1c0fa6dc4fe5165df91005d16edfcc8f9c84c5d97b37265bd02c7e2f9245987e9a4d059f339db84ca3246183c5930d01ed41b3d10091ddec13926a8ac8e313b247479a6ec68f17bd571427a1e6174e3be91c79e8e9aaf32bddab5640d96669582f7884b36b500e38c2ae99bd2b709e54bf8e92df32dff7492ec8593e99ab65ee463653ed8cf960e90d4ec066bc73bb858c3db3291743760d533e91088da8c48a32faae7131de9d798499fa33ec3725c624662722bc8ae00ed567aaea715dce61796760b7249ea7d546d4aadae761dfb93e3546f36bd82699bd8df14bcc11250d383f485ef8b74778994e5e52b1c7af43406b7193112b8f49e5220509bed1a466dc83ef868b8c572b373bfe60890b2866cf1ea35bccb6cd58cab7c899be34d30903592f67e6737653f6c0cf060609e0576815ceaf204ea80b7e03f3f49d3970c00fabb8ab5880206b3a9443a8dcf0087e1b512101f1f73f9a81cab8dbef35183be5c5b702a1f510719b8ba8557148f7050c3b3ce23856778c8b6da196434f8572c56bf46ccc177b3f26556e28c17d98fa39dcd0b577ca6c8f49af503f28203685b1a10b90059b33a9e776dc3ff7bb0cb459df81a4a7037ea979fe898463748d0521c5b71c3a6fa83663d9d84443f8734bfd97d15f0f5118243d147014e9c89a793fd67747dc11e08cf6050dafa4bc663cdac203498cef939f579588bb8ec22dcc0b6b48e1482ff3e192720383cb1058984b653d0277041104f203675306ec282972db3550e6bb59164726bb81cfd19d5bc69f746f50b33b98526c9b3dc1398bad092d3752a75c8da4240917067096e4b46e40e945d0c77e506a6e8469f16ba51364dcf1c2ffa3c51f76f936c20899d760fc00ad8cfcd551d96ddfb9e7b57a8fc058fd1b79db4ca8d2f888a2d05f4d47f197bc41ea1434fe831be8dfa1a343a984ecb5fbdf787f66b88eb038e10f0dea3a959e9ac56d73d8bd2b8ba74692194332b93a4a4b18bc55133b454d179b44392d571690c6b31b825c95b14c915ba66c77600a5750e606ee1c698d15b6369ff13d9bbbce1aaddfdcc1c8d1942c90824b19f4af5a2987d124e932310aef2f5322aeddabff74bcdfa28aec75801621ae31a8d3d11ac918bfb0b3de918dc7563d7d45e08cc7b72bbeb8df82735ebe2ed4d7c929e520c1292288494461130bf88057f6a9e8b8c5554be4030d5245f2a0897573ab256ab352ad992f77590a542496a3fbe28bb50c294a6b884a41f729bd4e7c1f654726fe565e5a2fdb505265cb413a5dc78875693d88a339991e18b6370750fc38b077bc00922b1eced5d009d75b3e90cf37815dcc50c4b800292b6a954649d395d2810f7c54b1cbddbe8da503bb53dd191a9b978de434e3cc2866466e96e9f3c84b3b9922ff8393e11318da7cba34c1a3223ac0e600e943bbdee2f234652fab3fd34632802701e69fc4709eff100ab2f4908e74e10c5eca70bff021f3d987ff72d23a5827337f5976614276e749eb5c0b54b7f6ea3003c72bc94f2b4edaf9f8cacf9b0c4e7355f9e8d84d8b3f8ebb603c6268fc5ceeab0fab0c93bab3005c22421259686f8b54efb387f044d2baa1fd232c9a5e4b2a9dd23900b381a2d9c672406f802598df0fefcf8501e3f0471ee96b958cfd9034a1f4d13b4940393135bd0cf8d7860bf9b4fd3fd720f020565849d8d586d3dddaf3aa8b4ec3498457719d1b6cbd21334d9ef31c88a16533c20b5e60a94bf25e3d0132ee856993cd3613d6835368d6c067d137fdb7b7ebfe4d297f2f612889ae79d415ada493967fcbc5b6f75dd00fa68d904c1f012165f1af1afb630fc16e1f4af6c8fe035edc2fc2ac9e0cc964e5264717ba47654ffed6ce627b1097a5fcf2da3376d845fd57a57b1743e2a97e37e67538a82e89cdffb5a1da8dd107c2fa76e19af0b079b5f95d56ce699b58ca7c7c433f03c4f6662de48116796a3dd74c6841a580478335bfca9395a4f2bf2d463bb60ed8349de3ccdc12018bdfe67f8185405d68f8063f9f27289073a681ed02bd003aa684b89fe2214a1da84f95eef931d951bb952e49857f75d2345cc9b10191f6d15eda28d9f385a16a41f0bdb022767f0faf0e2fec9f0f34246f26fa3027e6b9ab9b1cbadb7c25470e209b70ec4cb8378fe5c08efd770bf4236e6fe6273de5e9c03b5c6c3b4dbe8214d5906fd0f687d7531ca34045a5d573eb7bbcdd6ae223c7af601efe15c163bfe68d8f3f281a40993c201ef60d78a440a0b063809cd5481e33e8687b6f26cc3c6eba046d56b1bee23f5d455d2300d6f54e7ec33b30013af48a62ea99c6e378c850d0d89d49b805cd5af3adf6e4b3b118bfd1b2d2da8158da5d1b9009664a39c7ca88cc87fa6bdef931f4cc5c98fe33a84fb0ef240444aff2e71f05a98013599ddf2b7da86eea4e7655b64283913e591e1cb6d4b1e673c47b0024c79c533e0cc14f2be95d78c13af97ab6a6be67a5566cbf1e7d8639573a4362d8bf4ade72f708b25bd23e9781d1235d64f70e7b3fb72dbe33e5cf8e340c479a56d06e19a1b592333b262d71b6344f7a3c05cd4c67e8bb3489de8d89a98c45714e56fa3e5261eccc9f43ce3f0890e88e2b53ac08f532b1f7f4d67564769f08d00c6e67a702bceb9a82282d04dca26289c8b3a34404d790ab71d312e70cf2fdbbfb651ef413936b6c267e9785c4a01834cf167bf67e71cf1d8c86c508a1103e565e0b5d51557f62f400367c848be189405f02920ff259d313139b409f71914f72841b845a296933f286c1f6f95605c66312a72db11d22a957bb8ae8f6121d8d40b09876cc0b505e4932f3dc72fc1c5e8beb839c7599bf9336773c274ab44c7d357e6d09af84a797c64bab09e1a1d2bd4de86043a62d7949abb6df81606624eefaaf1fbfedb0132b821c42c5e761b14bd372f8307dcdc06f9638ac4b2b7fc734ac745f2cf90d88162a3ccb22c106426b859caaafa8e88e7223b106b4c10cd911f92112106bef49fda107a9a8ce3bd1a24b0ae2ff151c2129f63fbd9f71b818029df055f3ff775a5d7ec11440e1bbd155ee6a7966f117b5f3e082034e5b1343bb02ab6fc3409a3a7df7930d5072db81aad158aaef8619770fce85f5e4497b4f9322222676eb00cbb2215d84f63fdeea5cc3392882421de9fee3ccc6dd5a581e1eecb4107e37048eee23c6d526fcb801a214151206601b5040e2d343e5aba1531857d80c748e80866d195ad3614db53895700bc6669511066946f177309569627de0f4eb8ddd3ca6ad190a0aefc855d5792c002f3645f7b4913bd7550f242be8d367560db26fff417e8d321784deb3ce735b955ee6694fac54d98163dedec96ce82ae508eaeb04af665af5befce5ef476e91c5ccf41ff68e6c3b87202d083122f643b4892b815dea03989f0943f1bcd61ac87b6ae08a6fc5edef87bee486f5170c0a7e9977c55febdf7f096625bb75d48fbc6c257e770dee2c5ee68a94e760100b306f256b548ef0a463122c58beb04044fad69600f333910252385974a236e53a4c7ac98d880b5546cddc54c013f0456da25fb84eea2be92430197e95996257ec7e6cc38fecd593e3e8814db5150606d5c829ac279808536752ed2fc1365e45c09f78a858ba7e22864829f2e13037bb17c5b1a50025b2c1c1b26e4e1a38dd3b6eb829d5f8dead9d3642e9037ee8fd5f2e0ff536d6b8b77d9fa48ff7c1ea728297124c569dcff6f6754139a112ee6defd4b30fc75f426c1326c1e11a4986816bde4a4b118ddc0a0d5d45df886e30e7c3367cf344440be5b303c1ca8d742195c9439f4508b70dc481cabcdbbc16714615a873e13445e921d8bc4422ca0d1dc87c4c6b8654f0888501ab0e8c0296f7463a00f4bb5f1e221c5311935ebc37fd70cca120feeee76c9447de788fcc7b0434491bc6c092c783f2c1fe58f08fd1e9accd988c4edd2b2eae8f24016d0b63b433c405d3162374fbdb7fdbaf3551e169c978e53116e4f9c63236f5a2970f0c2ac2fb2858db86ece9167306d4582d2f02425bc236780f3365da87fdd56afb62d8d17715b73bd3d0ea09c0c90b6bc4453b032b92fec6656b8c1d815a6a7316679bd877ad696c0bdecbe9321012bf043d2e232074cd2e9eddd2bc0ded7d0cab859f8173dccf821bf046b4b58c91efcc809c0207a1f3331654e6ed2ec918c8d5982b2c40b2f71b5a286c16de7f100053d96db5e41df6c53971fce3f6aa6d7fa4437bf97f8487076863d3ed0b690915dd2931d90428401e3b8a55ef83dcad2eee102ce1dfbcf5739999b25f286dc8d298f5a3a52b753f0f21da3d3e01d125cc485155fccca37c12aec13462fcb92c33764f6776594b73981679a60f90df402255209e9823a8800a74764b09d50d247ccfd8df0edd3834f6dc88548d1fea265007badb7d06fc975904074a2ce24868c4ac008465bac7e99a5dd3bb5d1b862f85638ce25f60018b82b6f0a670d3e67f91a223f0089b9ea7cf523fb1f11e494de88d12a9c5a7dd7b90543661c5f14dc996520ef287a48b932944491fb8cb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
