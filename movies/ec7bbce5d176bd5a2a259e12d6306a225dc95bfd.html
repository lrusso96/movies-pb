<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"49672a0e17d993d54a01ded34437153af20f3e4f3b033058e505c9ac34f1b341afbddd590693ee24d3884406143d80f60c0604c2e481de14d3646ed997d931e2028650ecc633f965deee08e0059e22a80932062a04c1fd4c0fd9c8f395329120d07ff6a1c43698af614bd9334d83adabd422d6deff29ae18b95e3915e2227ca0c1c62e388901aedb94e2f93fce929bc7c277d0d3dff89005081b121fc46cfe139ad1b241dc3b7fcbcbbc97cdc052fad9d2933378614bd7f52771e2c1b50c66fa603a13271432f6c713e63ce8cc820712f3d16b0f4112d7ae08bd889d754eb75e2cb5f924c1681311822713c0e9101a49e30ac2745f1da964da1d3b2237582901a86e3db42a061be5ae70ebf0424afa046d4e333fed4eaf7ee13f1f3a7d3bf4ea89ff6476bb11eaf9ff5d1e6716724cdf117197f0ce6b0101bb718addb30daa3ebb12e85025b3c69196e1fbb43d83ead6ce96c2d5df4f86e3db1fbfb84f888bc5a2fde0f6f2e44e1eb398fedad171facc524239ef7d82aec960fad01dc99e283a0e4b6d0e69107a6a0451aa7db25230bcdc7cf291092d9916b0bd236bfa77b834704511c1e83f7155fa5f6f449d627b641c55c38f6771fcfda06e19262b026059463314bd0d3c1be2e47ca383c47a60f0feb621e70d973c64d6da189c86deef7aadabcd14bc6ee12c8ede1aa23def90fe80c05b378a9672192efe7aa43ed89c020ada111a1153d2d917ebae43805919bf317fef72eb448a25bdf3e68dd59fe38c5c1d1d01c23508fe5b51dc6ac6428b638f7cd79a20b10a92ceb08cef841d59b6eb681c48f11ce8b6daf5903b55e408cbca39bcb71f1fc14b07c347ddc8772df0c5f4d9a12f2d2a2f9847ac3250c4f6273ec31904dfd61cfe3a1cbc265e2f1fe23c1091a22140976e3c0c59cc74cf454d152680a1b1f5e83ec4a14312607a23f76c70d842d0fba19517eec2c3819307bb7d7c75da149f14af3d915a756e69005586cdcedd7c124cf26061a73b5b7956c60eb10e77ad481f4f845a04a60c52f5f9bab54b238fe09ae1de2e35b6dff0fd8966782dfe2ae922bfa73a3b1f6342339bacc93ae1a85c4d17ccb01de8cc352a0867b131d84d4e7928d191054f8ce7e9357927a2b7532b8c34c8e2b2fc7dd8b26efeb70f6598055bba3dad4d52c9338db4d2042ca0299093e671bc14a8bb52fd06e33337cfbd886a811533542d3191dc9976a09fbb14dfb76387a19d8e5913d052e6fdfa1acb1b056b7f4dea899d80e96ebb532fa1bdc00a7422450b78628ff1e57a647cc9b4c82e441e226ae4a509791d57862eb976127dfc40f1f698eb609a9fed2a456db3ef329423de7ee82f91709b0eab3c882d17cf0ddb1bfb3a86d1aed586d5345f7b3d8ce25352ff679613b6422fc7a71a3d8c376921a0c3df2953b4872ecfce9292b8e4b85d388f8ca17b9acbb6b68146afe0ca83fe7580cd283ccd3d5190114af975cbdd7d6a83db934fa5b2d13bccb16e9fce6fa744790a06d7b209c9d632027af85a37e84471ab661731d3fa8c15fd8feb59712cd98c6ccf5f1a183f75ded056d39f53e7e165bc0169eaa42622448b00a95915b698bda02c7eaef748e613d1ddda4004b2a0d0e206f77770b9925fa36793c36253703204b1e3f3da10282d13585e2f899f28e7224df0982bdf9b189be54d316488142851def7356b0e602bec69f841a710436b10426087e12f3b6c887e090806ea76d38c19925f09cc6f80f7cfbc9b1cb115697bb80f3795253f6e6c8d8c3b599add72f07c1c165dfec5bd65179676e240f68b8b23ab63d545ea11517e3fc27a92804e11e9a2b2cb3eee544ccbdec13aa9701499f34cd138e1be0dd5aa1cb01e1779fd7695c9c6095a15036381802fe046de3eac81832ae6ca73caf5f969fcfe4b0c8061a0f30f3436ce56691f09b5cde2bd372a8740af208536c85bf0974e8df8cda2e8deeb4078315cc6ebfd15f11fab888b64e7243433bbcd982e82799bd55c1ecdc0976b4b607f0f03d55f92509b8fb5111e9ef980bea8deccedb9ea9376c92d5a0ad519ea1ead0105dd511cd1b615de4c11d5d142d213a01cd4a35ad374b1f7387a9726c0ef2f62c6a7b8a10d8a47d6c7870b28727c7037b21ab906bfe358725c7fbd3328e700b0875048af60998e8e47ad2732e51f337b8b52e07986d07c3b25922b8ddefc6f3d852ac1d749ccc6347c0579f03afb534cc62577828563eacbc44ff375ede1ea2c9ca36faa6cd306923ccda74d790792caa525d485e530b16af06c5d02ca6f711eca47070f2bd30048c9b5aff066513d22ffb458fc32b4e0bd71f5de0e79699c1822640a87e1230591faf6ff49fa94914180ec394e65b2a45bceb9418990feed87306ff7894f4373faabc487fc0648b83c0329a76bdc09a295833786f5dfe63b8346478ca944efa45e77ff06d954ee9eae7acaa20ae35f50f43cdac5618fff8da894b4f26f43fead8e8355da5ab5d01c4835d1d58a1547017faae2076eb990effd340e7e2e0281a67dd1d8d0f81a81211f20991300ae6811847e55b37844b0d398b7ef753027d737634bdecad67a826f0dfda16f017e9af5ecaba10c8488f7f82af01452d06fb2be262e58786fb276dfaa99ecdf52c0b11d10183ab45df8520332186c5257d9f09f55fe3be927c63019532a3f7bfecc88bd1f27764368de1f6c6f73c391a6352fa5947054ca7c9561d77a0cf8dd4cd551bd9d174cb5d381715aedebd09cdd189aadcdce8a5f84f94901f1a0ae4abd40d156ef49a12da92c545ed00d2854061eae6dd515fb00b7c3acf16df412a73e7d614e73afb02b9baef5f3056e2f87d8dd83d0f39810915040244d8f2ba94a7e0027ecdce52616163d979226386ae739c06a071b9b9ebe060ba585367d38a33393153116ef4b20684e07a21531de335b5888c7b912b1781f1735190b45d34bf93058d23b6c547779ddf5df2bf85ee888cfd087bcbfe87ef25bca6e0c1de61a8a27fc638913300deeda7e926afc1a55984ac17207dea976105abc8eacc84e74d2a5145883f85363eb1c22feda151d64b987a7e447d5c31d9d5e3863469a07f996bd643d4007522bd249cd0fb2f60576e39ea36c2af066175970827e2d105924ac93aea305035a4b26294492dd960c89a793b025ab0f3474dd5e112bb8b44d0ee150b803d2551b05cfcf99735c3c9723a3827d6af36c0a81be846bde1f4e11ad100ad75c105d7ce9abf223aed7b7f29a09838493fd84fef2bb02104f03aa93587b6c53bb325f00381347a76c666b99e45caf0fde6aff834d576f2559504b3ba165f6d9c50a204f6424fd2c2f0fa5551d74de2f35d64a00f479f5da6b8e9dbbfafdee66a9bbafaab06e63fe491be5e884a5d86767c334ddd0b17d8c7cf85749386d13febf241e9bcdb6f460eab1fb97d7f30cba89a43ce301a6c2c2e4914740082a4e73824bef7a922117014d709922e4e19a05f7b4d247fa62986b9dec36093dc111542451c5aa903f1856afcc292e65eb38f335c9fd44d184cac42dd6123cac349600293246be02527501306970c0216328423e9913e23e39a005aab27f2672171970c490cb8441cf9953f38a64ee8cc1b81c571a3a3d20086400e1ecea45b1c802019001ad42a34e9d56ff23ed6c304eda3a9d23962d9f9ba6046a4678951f88fd4ef8fb82e799f684a9b0833abd67ed34dd4a37aeda01a10b83f98981b7db91cc9923d25dc4f3e5a1ae6101908c3a9c700562696a09db7f95c12ae305677c8d75c92aa34fd81c0aea32289ed4d70254e138710d2bd77a5b925d1151304a247e252c801c513d86991b52a74948aa8ac0843cc85ee7010aef85a0f426e16bb95cfb4af026503f5c94b61aa9aeee70a503ca01401f4013e518d94e7adf86b481160e8afc4334d3f7140e677ad9b47c58a7094fc145016945dd737c30057bed9696f98682b54de10fe1b80a445f255bc4b688a389a2df28932f208eddec75657542bc5d40fe8216f64424e03a8da1cc4077f4c2c9218b411808382f54131d64d4795bdc639f1e1b53763844151ccea420d22071d004e1946dc257fb6ba3c5014597bd9cbfbf77c3230c2204202854d896b78423a15ab6936141b5abd90a1830d3908f3c1010ec9540bbdb615c65865d415d84466c569dd41266fca7ffba32a3fb3fec810064ce765e0051d778a4e788c519a830512fb7b3e9f7c692f717af236e950e07455c52376a2e62be35f3b2bc0a591a7a97a10dd48cb2959a1f580a8efb3ea9fc8deba522169f7f4f52625da2a574b6c1e5cfc7f02283accd18f1a6748501557362c47d8e46df9e71e55881b86fad17d5de07bf5a5ded97b38b95780dae355ddc546c45e7605f3414eb59b00551d0c232e1f7c4116a5cc163d490dec265426ea85b94b94c90e5243b4252f5d52366be5046843cc86bed2055519cf1895a0c2fabdf02bbe53de76436a4a3bb532b300385bcc9d15251717c2f9d25a8c6312cb2ff3f03da8039ef6524d52aafa12da8815d87f820e004f6c110a35139b8facb9d8d42a24007b812613f5f8d016f19879a5e8a45ddda60b7588c0df523054d4221684101d15426cd0c81f0effae5663075629a62551dc95935d8b43ba07371707f4cbe54664895d2885b67c3b0ea33763cc2c60b311939daf1a05f8927a3b9adecd7c44e9b1eb2697594f22f58c395a9aa1b9ce89202f4b88a77e47aaf1d7328f48d53ebd5e67443a776f21d147b2ea05d600818a016500dfb0679d68d0dda3b52eb9afcb0b8f38473947ebf17f293672dd753a7c92efcb78fbda254c277870845750b3c70e3c002b4a436575c3dc599ced918e863cdc3419c17768a9eddae974e62e7e59f16b3bf04b5573680677657bf5afb3a40d5c2b52bad6eb52300ebfb319473e5941d861b0f7a150c09cb6a30700190c8ff912fc2966424ba00cff90558e30b01c772a792b042641b4c75afe71573892a18e0f39264f81a18513759e4f8ce960ce4d39dc9a3cea855d23d372290c8bbe757951f12088a1055cc22c87a85a9a3685edc94461ef50d9fd236dca04dbb09adb6dc07fa811efa2a92a1e9adec516f01cc51aeb2d1a14f1baaf37fbd80eb6ce5bdabefb15c44fc47b6e4e3eb80240fc6e4cbdc4adcc2406e9ffc9cb79fb8f34252e9ee03920494feca5549c61c4f2a3f2b7cd6fb7f4cf5d8f569e6c290b22d2bf89076aa3ca89054f6f7a2a59c147dd00f1d7e92e2e5370b09f57c44cbb0d3855e06c124ffc9caab54df88cec252d1a31114cb9cf08157321a18a77c89223d71e130ec06487fd8cdfa808045666e0a0b207af070fe7e4816381d39ec0e12dfc8e4e99c982a4ee25eccd8e0484ddbc101bf55542ed2b021e4ce2cdb7d84e2f8a6c7762832cc830766bc2a23ce610666550f12fd0c3009078fc0035c1ef7d68c647681df9de3de98b0864819ce2d4cf6f51547778141341ff0f2eb20599d05879c98ff357fcef25de1de401707ff9c52e8047b47acc017d47612b1fe5a0308b6f81ccbf3ac48c9b64fdf40503d1cdba529ee36c80025b446e4b82cb78e31cf86f21b7272f42519f3309bf8269f56fb5618711bd3a56628078cfca480575b170cde661ef7f69f496d328da88938ce48e49a167c5334e7cda9a07cccea346cb2136063065574d7c93730c7ea22d4700374f6d315e1137f359ac261cc9e5fefaf73d32a2b496457eb5f90fcc03099674c986f12fc793d28ca68150b16145c8a6a727ed54737bd3c752b767e424bfd1f488b537f249edb99e25dbf1afd73fb5ea1e0a76bf953922179715c013d51f32cbc9c0d82d84abbccd010b1636f82658eee6cefc39a5a8175543933669eff3166707834bee4df80bd9aac6c92ad56735ca1ddb7c7c3cf8f44be8db42f502c66eb4ac4fa0d6cd17db72e07f71e7db854c07e3fcbe3b0062bcd725a90b36c4edcdf2e8b19bb0cbf371cf7c6e0d48191f05f3baf4b6600ac0eca9b533bfa7bd62c6ad63219a24a915f7dcbf109ff4570a19998a57e3d7a3d87868eb38fab27dd9af470e57ef92c20b119be6cdd505be63201ff09006865f6858072c873fe5fccbc72372419ebff79b2b7a4ed481d577296c4e525061da4f59f271ab00c28ef2f34d0cfd305f91576f6668f097048a182a2edad1ca2a1edca943aa4499e844ceae696eb2e221adc07514673f050456715200a744d4b67279ef7f104129260487107bf222af75379577bbf39ecb3fe2b2261ba0391dd9135f152ca8d68f7f653c24cce025d2d96dda9db468844752e0d523721585257fe6ffc9738d8ab53a31843fbcf1288600071cdee83de71a68df4bde4daddf0bb9c959a8260f322f466750f9f4cf5742cfc6fac854533e80a3a4eac12bca80543418e5b2a1ff5596acbf755be837d17aaa5cb5580e51fe2b8a9cfac932b5a1745b45d94141795f7dccdc3ad258219d29e87d24455542403d386d925a233068c7234a4f7901875a3ca0ea4f45acd3f5acbdf2e774a1473cffcfb2794cef0059faf8c76f88f319382f1b8d20b6b43b7fdc15bc4ae1b4c891c44dbd80d3af6398aafddd02a1ebab927206dd78649125e8b349f42b120e3611e393ff2a3b4e12a9c7e8479ba6e410d0bb38edc1c640d45d4cd56e75f9d453d455e3241edae1901fc81249763b13c428215e507b1d7ee60e55d85ea7886f4675234f6f8b09ea596400606eb62339bb8ea1ddf9e6781762450f9c2e83a084ef32e8a67dcaad29d412d87b4139ffcabf56d6dc980df4f449813d204f52a4dc30e36ecb653aebe63fb75a239ab66d19a41c1bfcf5424a627acab10d93857608c123a9296787744628c54f6fe6919fc825110ee5901ce0dbbef00b7871d3248387c9008c4712532524a8aa9383e02d8e288110caa63aa91b3952080737f28fc9bc28631fd03997b84a66b0dd9a6183f434c4f2d9afcba124fbc7ab3f49eb57f58490301661aa7902952ff511fb2d064b7a3faf742e4a311b3461863760cf178e8b9bb5146106ed0dea39f7ea12f4898444ddc54af29d4d93b7c1dae1e78ba029d27c3763763223d40320e3ba63694667aff9f93bb0ff007597876f8278c6499a32524e39fa558f862599e27376615972f98ab5beced495b41d6396151e606cbe3a18b8c7e6c383ad488cbc669dda9ae7dc07047fa4945f8f5e6131634bcf8b6641a534906863e2f095ec4d9be164dd312c2ac1ad918f62253e12782c175c5a0c234f55fc1f96bcb7c7d7ab8df9ea7f9d470b801198442865e6a327f3fef4a857e3ad9981d59c80a8d85708427f6a685ffa3ebc3b1cd60aa4b6c8eb629f52a81ac9b4242dba070abdc2fff40a60f41716956dacc2f628e8e0475d13d506adc84986abbf57e7c5245cf895b95257a7d54b66ad090879855166407f89c124c77a380f48753831f1c4295fce29d77a54641025076e5be47cccfe9bc531204c6df8a46e7bc16920a4dd5b381682406dd7088117bf117ee1df4a228778bebb2ecd5ebc334d8615bb392a7d29d48006b0030f6dff71dfb88fce7a3b0c14d648922388e72d8e4b659d63ed4bca601f2a62e7f8cf7e67bf3a90688a0baac057d21e1e8d8c5bba79b6fb753dba9cd3cbb547e2ee193e9b9cbacc4a4ec789c915ff5f352b5c285a5f2adffe3cd067006d6b5317d62aa55e647832c4d09bf7b5778fa44fcc41827d4ba2f26231f3da8d8c91299bffd68c027d63a5943caaf5c746ada6254a45888509571ba9318d99892b1be996215a4667201b60128080bc24dca15908755a65e2ac19accd4ef5e769c7eb46499f7f3696742e42a89676d945158cfb70450a8eaede97ac60ffd6bcc6507bda6c340f5d3e3743282885cfc1d7916ad076e12ceea22ed18f65c1525dc290591f661db7106cd8880b6e117afa207c963ed830914bab6f78764fdc3ca2229d1065b5a1e955f9972976b4063920f06d1d10832d653696151a168ebdf32032df49018785ba827f3ed4c2e79632375792771362f740951a19bf253aca6ee87508dd84540b6027ad7d6f2b4be38919d06213ba970d728965bc7ae6273876903ff48b6fabc7237654554d52a36ac3a947fdf3b0ec81fae551a64b331c6a13e2278c9d63d7b1d20c8375b3e88a2dd3a0ddd0363215c75bd1872bfc727294a7c5d4fd6426b017130e5b4d15dc12c2c979bbbe654bdfb10f4b9cfab2c608b82271d588bc476d7603e19f77a01373efc71306147f4df6d4570ca2fe86bdf0e6013021caf002fb2ee088fbeddf601dd0fc6a8e50b749097752b9410cbb267973cb30050f35a4335d2ba90e2fb5f2374a309ccd51b2d6f683aaf5c8d0e4ef618af3a19093ec3167c34ecda7ee8ec08d320d323ffb113f858d161c5ec9e81e238e3378882ce089fdb4b06d978d7558aa51e73a2de72c79e4d41a4cb6dda47b3d79fc1e286262742bc27132d6a446b82598ac504f0ee3d9cc931fe886e884aff01b837d5d701c6aba0b74e7d08cd76528a1cbc1d36cad9aacce6e44e6bc36e171e0db93cd598a7f0e5842f447d203663f48f87761c17b1e2976376b69391f037efc0dc580be8b2157e4623b30555d6e4740da715d6405fb3529e9a3244434f196fbbf47a1b77d9ae2e8e56a65b7ac0902ca1431d00f646d6685d2fac26695820a53502c3e94b8956681c727d6fd801caca0e0bdc05b6fbe17f4432024d145d37af4c9040de631dc9a56c0c62e3c114eeb39076348200a56261425fb4d41aac39e034bfec0d562be90860f134a6544e7772f53dc7307341bfccfe689876ffb15a3e38732fb95682d443a2bf3e9b6999fe9ed5076de750501f0a6c840df6bf25c5ccc862658f1b584bce905d40edacd5bd1fc8b111aed9a7012d68d5da93369a2501341ac38c768ec731b0a475c46373df3e007fc8085cf73b1c68ad339c2130f334f34f16e6e93a0353a734aa8ec883154ac59780eb533b7fb54da0e5ee92930d321eea0d6c415decfb55b4ac80fb564975356b4e6f33b45a44e0127a0e164304d534febb555935ba6f7f5557b23eff291945a4164bc492d73df5b5c27658c3436aa0ed34058ff25fea80d0da66435f29c80acfead36cccc86e68807fe26b35ec90acdcabbbf8fb5d3fff24cd9df92de3b1d7547991430dc2e0e8748c5fd24c1e5313503b09a1a3c6fbe2ab9c8415a55b75a0f50b4620eabad3e295a84752a64821e41e7ccee8237fb5a51b004111d36471e235a672ef9c6d35a50b8badce7de755b7bfa784072fbb679862d92e65180acc385a4cea800602a83d2a04bd0eccbdf54ddfd6117a23faa0429a6d7b4e057e33e3f6c85701f576d27c8570042d456539e1c3581e7da1b5c10df70ce9bb529ad37c372883b72805757647fd381eab7dd74c852a4d229c56069fe413037cd038798e6d0bd3633165e3404f0baa9c7120758e0aa8a8aa839d758bd4f0a50fa696bd9d1d5a3f0038b17f38093e0657d5ab6c81d1129ccfab4b1553e879c3bc933e35f8c372f2350a3ebb498a380f2409ed7121ede21e635e789d99e4da4631a770bb9303cc26d28f2ab1ef451aeeb88d7b130a9d05c81bf498045c9b5e8ce1823751d72034a96c6859187fe8f3e06211f548ce9f2934712df049c78d43735536041fb4aec30b2df37b3d8257b6c272d5c5b4722c0e70eb2d41c1d8aa71a5f7181f50f8e661999a01b916e4c065b33003d31eb153f6ccdc0653631e1942162a8fa1925153609d2051cca901db93a63b7a2b1912cd1031fa83311a69232158552effcd65166c5c9e29ff73a403639a6b1c64cba8bd1cba8898b1ed456cf78e1d02ee4e92c4fdb4c61ecb8f78e7c334324893e514fd424ce558f57811fd1aa66a425217bd9a99933bc166fc559bb0b35a23bf398835a4898de4256019692603b2eab6d77ed3c86450522d28b2dfea022bdd21edad6c2f5138a0301b006d278c7144f0ad28351979f928bee4e16a8ae2aaf081a545aa0ef254b02a531af98901d1fb8333f1cb53b6f4495180dfbee66b76bbf6ddf70293bb6a6aac2a49329034d0220b8ec15a5310b2d58b0cea378c3a85ae00edc677e7d47e1ee185330834bef7238d5819dd06b702530190a9ae3346569a32a8f2173679939902b360f3ed502500496a0fca03ce07c67e2ac69bfa31a18282ab78be4890f0cca157314670faf36079d64c182193262cf2fe01359ca0117806832587fc18abd23d8e44417628053e9f1eb646ad7cf8f28b8fba862e535c67648afc00a17b6dea7f039fda38837124b5bd92779b86705b614a11c1dc0e9d12c3eb15ae7a6e98d180229499e7fb9c7e89938cde53190c14c1dc06c17557a61e92659db38b4c169f904d66841ceff25a2db7b8e4538230f2eab9b43e587313cd73d7264e674a6a70528b79e1f00ebbec6745a70d266f52b967e1346804562a65ccbbad250d735bf02350d247b176b43c0027a1982113ce01da7b9fd550ab727e2c64f2e3ae97fc2b7462456ef6fec4984c03cf087cf8ddfa74bc612e6e760f29e28ad4f2d3a3d8538427bf0ec32b7fefc15a8f19dd7158b0cadce8234c370be74cadf0d722a331f864a038ce65fda2b33d0236c79376177c04d06bff1a26d8f5e5dd6e2e9be08e361f3dba8446f85503ddc11f6567b905ebf7342bccad7e3842cea595739a671cbd3a52bbd61341e96e83de587ae05c6002ad8312c5c4bb21e8b728f8d761d6d713786d29bcac562a7b33d826d2ec91be70dccc95e3819fd8933b226ba610d36bedfd7842bd05c94750ab7b4152262752756ebe171709080aeae53ab989244a999bae8101025931bf4453f90d6abad19d1e3e0ca1a106a3c1c5dd2513b17eccae7d58ce88afc30b723bf20cfd602db91487e3d970778684fa6d120e5d34e6ced9d05d9b373caf4152dcecd9a1283eafb8eeb2ad6fa7b6b710e57be06395bdb2cf632873e5f16432850086037ab3326fab261ed7b5d6f648a351936618eb361277a79c1b08a39d29542132df997ae83c16f44a48ecad9c7bd80df19b4e64248c4d481b7639d0580abefe2a74b877a6d6a5250289fcd96289caa1ff74b93a174b9d44ae79eb194b0526875e503e1d946a184071cf5b0e0d1970c0997919dca886102c036ede846beff443e0185569adbe7d58298742eddba2bc1095ce8e7d051dfc9acda0ea3d208072ff0b58d6be8dc3da7d3e69ff803a7c63896168d9ad45ce508ef86dca4d2b9074658c199ccf765752c37d03ddd8d7e03a63ffc10e87049814ccd3f0c7fce699716242110c961834b61c4a5e7a4e86e82fd5086fc6643693d83c713799a4b033f18c9f7d3e2c0dfd6fe4216de2cbbb59bd6ed22d5479ed5b4500821e7b7c09e275b19528e18c8db5c767d319d9589318570205a51cbd7c21d2c3ef719bc14f2126a64b631e938e3ba598b0456d0b69c434c09919e02e9c81dc31600902ab3cbe60cd3de6bac2fde3e7a422c7c65ed0bd641508fc11a5d765fb978177d631596031042b7f9f9dca4db91cad0479153ed12e240032ebbae864064822c2ea8866a71c5ef636cca2ba5135e9b5d4e2ca75d214e1bbec1f7323aa359717526737e7e71b070bfe766dfc05f93bda7ebe7b634e316b44479c7bd9950013d1686a0e338fc2db06a9d5df6bd8590e29e882f46f5f991a38992ae9a116a76f7247b5b3bc0e6ba3c3132932e4226574da38a73de9106c976103c0674c996cc09621f4874cd18e9730226632babb7f54fdf60288e6fee73a66fd3cd08ecdbe1f3016077cc00c2537dabfca96f35c7413eb6dba77134a98bc3f14caefc4a4bbb7015455dda304b36e7d0d551021fd520326df19e4e3b010f8b375b8572e79cc648e406b40c3db8d1fa9f80790ebb4238a8419f8805861f0d06a2fe7794b5f2c9625fabb30b29564dbe9fd82ebe4c6b223f03abb15482960ee16900158d4f035388df71bf724270cbed5dae11e89866b37ab1b3d5ae92e39f53f5dfdbb0b8db6a3fbe50c1e2d1d08ee308d0c3b5e532b5a771bdd468d261828c349f0e9eacac312c3faf10a7e9d97ddc7d407bbf780fb06c639df5a70fba4a62deec9017c1383ffa5c015c94996717e5afe8b50357bc7ad7ed5ce358b7060168b88d9a47734c246ab38b7829005f52d5839c59ca9b63059f023e6b073bc6390281de0088ad1ec26bf0a9bd90e609b01f303e6ba40628af1f83c6383c06c402c869a79b5e5c9b92da0848a8ab8132a4273a9385aad5ef03babb0d6f1834ece26e6dfefc2d87152f2bb8bdaaec613432c0e2881d0497bb2c64787069f493632dd43a4a8712120764c16552fe1f7c0918d826770aab37078b3df26b317410294bd3498654e5385597e310a0a678caa158796b9678ecd75ecb43b0e0cd3451acdf87ef9677d3c53187de7fef606e88955becf9a2abf97085865a02f061bab83b12a97b3ab1af98adf19d7e2eddb035e97bc2d6ecc123307f37bbf484993007ec683cf9fc158644e1d6a204d64ccde279f6a571ca812e8fc9d6c372f88a19c90b61f07c5d83a979cc339b90dc81cea1f5d22a6394deed328f065d67cb8454f26d01f11287fa7004cbc9e971d15b1f0a7a4d37aa64f4c884852e9071358080afa5cb04fb09b0c2ad71a184f239e12b81eeec02c8a51416322990599162b01ee4da7cb38372eee75dc0c21d1a7bf170680587937df5850e0fbbb6d7ab1ea42282f270da560352c161fa0241a09483351e0de80f4558f80d15b67acd1b9d30932ab8789e1cbb58e0906adb3a91a13330260a1fbf56b05544ddce9e8fb8cfeb916d3aeb719444afb8da081a71a6b9b5d22ba9cd185e38204529f8a969dbf236263ba61a675f379503766139698c69bd7cb9031ea0120f27d6ea81313db3c0720835000e6c2bf856819664f5cf0eb881b10b66526d9dcdbcd42d08ac3d48dcbec4b8748dd86af66338df39001cc65ec59c174cbf6afe6937e9cec7178524413a3798cc081917391f9b61f505c59c5c35cae9a1204a38b423f63e606b3f64dc33954","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
