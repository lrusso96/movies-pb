<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8a1098ac4733e2c2ed2718511a1c1cddcf323fc5c48032f991f990e24789d38af24c2ba9cb34a0a3bc730571f7a87c1f7376244b009c35d67c4969c533af7319741ea566e4a712e2f0f495f5c271604186f934c14ecd0f03ef9601680ce7884d70aff3307e8b44580815ae90353fe0e16d4eaab363aa345b2b776c25e08f87d97d28b5cd636717fdedb121a507f9dfa4e3fd47e1821aada8a7cd03ad342fe3e36a0856c6b6d0cb612888bed06412cbf6f22cdb73e0d0e3566f11a27db8e155c3ba9cdc436e1b3ec5623f9870cf1cbb150660f15c18124d91d16a8ec87e2f224fe53c3d3e046f8c679c98b2ce62816fcb10b1576ad5530d1d7c124f3b55977a506e27e743a168ccb6900450623ffe1a716d21c5ec47682f1a2e1ab0dd2c8740cea9dff006025afaca94e1aa980d8f79de36fbb38e1b1176eff5c3d54805ae7e6af7d8cdeb99d299891cbfba8991db83db053847c1cf29d29aec57dcb5b716632da81aba251aeb0a2b5f692add2a285edef3e56fc45c16e0a7bdea4f90e71262a404a36f3b244ff03c8e2659e1d8754deed09c7fbee0d8c7cdd0dc2ad4af619577cb34483c32bd2a24541201fe4a25dc54fbbd88836e24c146eafac5b93a65d3a10e8f2b55a7c5f4f0c8c6cd8f67b3c85c4c1a4ea706e140482e341ae6b391e5c614b1e128a766e912031ed3d233d8928b291152052a5c39ac6e2f886736818bdb531341c76e0e707d02c094b794127388dc7e68ace7debbb9178338e07f760d5f227f593723b85ed10568d150bcf45c2408e0a8d750176263fe10583c71db02f86e93f781215f901965ae3e0d74040f9e1290caa5cef020a7e6b06065ed3b5ccdef0edae94cfd9613749d5622d5491ae3ebf6fdf014d0bbb51df7abb23f7bfdf570782c46e33741cba3403a5d98eea7259ecc46178a54fee6379e8ac36b19c4e001f25e0744f828b9eb294a636ff61dbd973a430017c85f750d03f500ac493c39d93175707bcddc42705e15a117ca69fbcd47380852c566b7a165a428db1b4b53847cc6331ed87b4a013a5ffd53bf1c6246d346c994bc4184c69618f9b75fcca98c52c87e36885bdc33e220775fbe6346aa16d6cd355f411833a08d17e3215d899252e779a09f7fbce3c0eedd09050b91fd51904f25da5e4a5b0f13fc5158e37fcbcc5cc61bd5a88d7b623839f216a5e7a11582e6195f3c17d14a51c5fb27f4c0f3a01d58701c0f536324eecce9fa53ab418bfa185294001075edfd33f1241866cf88e4f3dae2d4ed7b56c4e777bc3b4fe6793a321cecb66537f587c81373060292495a956665b3b80fb3f2fe06e8cf7b2dac8419cdce632488571c77fc8db681533a16f8165dbbdcba647f657dcb373006895bb48274a56f726fc99fa0153917409e16869a30fd97e1d1c2177ccf4bc1e6831f85118978c06c45974e82db1eec08a4b6eebb8b32c016290f93272fdf385f18d30d5a0ed74467214f6847f8108fecc1e0fe1ef91d05fdd8a6709e3f8181e9ff1c94b54e8429e4e272ae29f0b641f9c29f5dd7ea6e18009192a17b13692aabeda18c7c9691408a93685d3d73062a3b0a3e18a89e887e7dec183f0abfd2c961ec35dc0754164c4f5d1092418a0750401bef9daab1d34cfe830640cf103c8cdbab3f8f5efeafbeb17544765ebc90589e074b453db47e817d4479ae244de25e4d9cfda9a877f8d58cc110ca11a9b8fbd9a980b25588435a2877c1a6d4032947f6b003ebc417ab50b1c1331d040018e7924b7e5926da8f4253c74aaa43da539abe086c970ae7768947275e57b961443c1d3c9d8c9cb6b5a962c67acca151163ddc397226f8eaaffc309fe1bd38a22fc8d566e6a55ee193aa5373e477e65c6c66dbe02b228411441028b932d4317707e9fb5085e0ad69a3014820cfaeccbb1740d863efa5de7e1cad285b9da3df4912cca9a9d9f2d3fd10b9133c322d03a71f8bd7cd2d60e731b90b23b8886bb091653771f574cb9a3c130ae0980973b668ef916bed59fc2ff75ca201071c0ef3dc9daae69045630220072e5da8c81c1f645150b4543896a631cf7a8bd1aa80974311bba210df4cafc39d925d47db882bf25559be050d02c39f90fea78c6ef27e7d94687b92b447450df3bf71177163a9bd017eb7ac7dbfc017ef5e99354ed5564fc317f8b1154ec57e3160f51d945e888845f3825fab785a330ff9be23b93087725a79f93174aa9787aa962c3f5e9bc825ac11adf8128ef9acb8909bac051a83d7fec70b89ef500c3efe54e658bbe1d4f27a5dc60ed9f5c210bbce4a073f495cda9cc5a797f2d3e3b6b91e4fd874a4632a37589b297d2e6f844907df2870654559ed2f0fbb9cb55a939c7da903315ea9781ed65006ce0adf7b309d8f6aa4c9ea877c8a107a15b79b8a63115b0f238407a4dafdcbb821549bb13671812ad45bc94ea153a0c63de22ff1423ae177f47067ec0bf975ba494abca36eb652fdf28102a2486fccfc60b7c44405253afaeb3acfb47d3bb9d093d089e6662eafd85247e28c1546ca53a14efb0bb125c8f212b67d6ff945fe35f1fe08b6a5c913e752ab6cb9bae088f1daa70c7042852321baabfa8562981cf3258bed498769f0d3700b140b14183c2cf754d49934b16da6732dc407dec16fef353f4cc15c4530c031a946abb0517da30e7110a46d4ada24b8e3dcabd60dd70617de4ce559d811f336106a89041174b3f26bcb9f9b5f326009e50ae7702c2947eade5cfed9b0558a8de5250bbdff6b00ade862bfe9e1fc83995aaf7df412c22c067dea80d333045061f7530d5076a472f5cc3ba4ae003d6c4a48f700f63ae319dc195615082160efb18923eee37fe44a6a30a078c068a5bd81d47b0fbd1950886d4808bfb143a6c08f6838fff9f3c502a284b0fbb5d6707b4a6885996f52f004f6a68a52b344928e22b17db4c99b79528cb7eab41ea89c4569908422eb8beff871c002462d9833060e770b501f14efe9a0b958d5389b2b70127590904ee86f947caec248ea7888f7dc7ce001c04ded90aa21c911444762ec7dba98e6e243929fe2268e4ad3cbbb93e0f168b1352ae81a6184fe5a981d7f0ef2a996cb8bd529e0110804d7ec9139df983d51e210fd68fd825f633381629075cdb5a28cdfb0642f33d5dea7d467127eef5d205865dd99277b25a21d4ee3276c30201b6f4daf684ae00c5e1ea3a13e44a68eeba2b806f36fba61e15652a1957f0c389b004afe4cc55fd7bdd5f12a263fc6b2e32f76b12184ec6a9580466fdb965e077a617ae2a0647317c8f0f03a403f86f95219930cc37ab5269419b8acccc00cbe3aeafbde934ee6a107016a6d9534ef21ace3a00e43fcde8363d7a37f62fd766f4c5135845e47c34f205f94008327c3694d7e96f4edd7f01d8b772da540353c466d06db31645ccdd8d07c86039d93de522608ba89599b1616ec89ea9ed06443ff85ccdcc75721b15f9ca0634b397acb0fe4c3429d9ea56b8c47d9066b4f26dd54295e6fab63f60ff070c37365ff8e57154ade51c5f71ae822b59357448084aace8e89c6377830070e104eb4e8c4c2b31af9300f744608027d528570ab57b47258fef2adb609be5c170bd7a6ae04268c3ea73f834601301eaed7f5d81b1a8086c6275f4060b474ac7b7bd2911303c6a571041e3b4544758d67246e0672198f48d775f922818e4b7451866c6645adc5492092cf6f8effba2ce43ea6e14e0a74e5d12427f5194f6cba5a9d306082215977463b222b30a18225464c2fa16bdfb6caeee5b3d2c0b200984ba3b15d52f71fd71f44c3f5dc8e2b0ee6553ba01577d431c75c80d3fe122cc88607f3a914e6436c0c7d2170268af64856e2c76628bb5e4c31cdacec54d9ac001d9eff85b282aed49cdc21b41d5c376499f5a5d392410008fefe04815ed2bd6f4a048d0aa111fcabd511a85ee59bef0e3b9e2ff78b2baab0af2c228b9228fde51afbb351d17c42c0e79d2e2a1ee76f403d97889f63a1a3786cc6a046021cb06015aa61b706376bda41b4ad4a52aea9f2d8c62fd3cd787b467f2194118cc68edafaafdccdd632e232b1687218f49bb59f785618fadf60d1944b8b675de6ef770660ddb69f1a1c6da354d6e5ae83b2192efdb795c757303ddb8bdb1f0a51cfa78f7b258085cc1e9cccab2347011ee671539584a6fa94ab6443c510ca17fd856b0b486027c215b43806dbd2ae24d9e2320e5c05454555196045791ab96980ec10444465a3489de6b1adfe1f2bf7783b2aad9b28cbe6e757d4e8332d05cb17248cd68b19498df3a19bd7a6a78c8f70f2153ab0f46887ab8a5bc48bbf8eba31ca886e691c84eff1e410fb4c1252f498d49a1ad83b27d8a136c76116568367ab2e9081cd3168f2a8cddc935be723e1eec4e18d26106da211d5ca615ce2eb352d1192d8e338283b22b9099e2d03cfe513e7eb0699238c927be0a074cbe0ccebc0ae87a92ef1f7d4445a4bea54b098dc618f611bb6093ac925bd90f616fd61d3ee8e1c9d1cc7e3800498984ab1ddcba9654a48ed116ba44d7719bc37b235a471ede649dc7781f3885b183f71957d195a7854be7eeac94d788e341b3a63da5bfb0ddd7c56f55371a12e339b50a02299244608a11c82c0115fbc2bc9b61e71db09ce5165e500b77fe2395d8538112d862b07222fce530bf40298312bd6b48eeca18c1c24a8babea72a9271f5efd053b953df149ade28fc95932723e33812bd41cc38cd10066e26b66935cad69ea4d3c9a46be170ee70fd9aa5418f4911c76f337913b6118284f8f7a7d2e3e41bb73b60b449511a9df54d0e7cd9c5b6ec5cb126d4c00743f4f5a7e7f639bff727c0d12d84d17c7dd0901b08eb33f3934f21f5f59ab941fa6fe457ddc666e29acddb2c69ea0348dc163b26aa3eefda53295c715f51ba20c5bf554166003a167b631fc8bce46d1a5fe290bc6bbe745a0e8c224872072325e1fb21efcd11403855ee7d1db9602ad55e66a6fac63ddd650937cdb3ce8f1a1a16b9ed97421199f7365b0a1cf0ab53a8912fcc39dc46bbae6d130b3b0d1d2c017b0ce04be2ffb1aeda4f87cd8e4652031982a06b1751dc5a4e82d263ad91785db45ae7a03f624a4955b2df5749a1ab31e06e22604718306580ae862b0fd5b5e40f12a817a983e0fefe0a9c9071111771c8bfc8ccf772bf013452268676ea8266cf6b53203c5da38bac0d4cf7a10293f6f2c4cd4b0c50fb24c4eabfba1313cb6388c7739716781a98430e86f03840b582feecb3467f5f513f3436324eca7ad41dcd387875c541465b40cc00d9b1e77a24f2568203be264531ab21ab23e49c8b7678994d57a26131df822d98e1983a8a6beebee166f59d650069b019d71644040deb750bb21b62a4cca4c8c1e8b20e87954613d2244bff16f1c4867e09e0c9b54e7111c1c899ae9484a690d8ddc66af6dc15437b5a44f83b537fda83c7f8805ca030cfeafbfa0f4b4574786e50ce812d88fa9518380bfed899b69dc1ad5c1abea6fc15733a6205e9fc3289176933a804cfd4b913888a237984730c86a0b84fe8db22062a5de7dd90b4243f67ffd9d7e6881fb641bfe010d2f3888458367beb4522df220d11008eb7359ae96a4070c1bf4aa3c19282f2ef09ef72b6a6caaccd516fcdc663325ead0e2fe0cd30d0908253fae5c49d110b84c62c749fb18989beb4f4a1369aaed955346ffa3566f90c78866911ff05fcae03a3ce4196cbe8396ed15d72f6bbdd7a984a059904714f1c992352312a4f321b17225844e88a0679819749964e82a72df29b37bd94a6ce24e4c4e8048a1681cbd675d44aa6ec06caedd50a41e22e84e1d0fd0423de95c0a84d2892f6689fc669918f394b3c1cd75bf2519031b59e118cf0c74e714998cd7ae6be7d8e9e81074ba7ad95caec0c5447dc4e3247a31f8e5e37fc4ec13f9b68b72467b8ae1fa3f0a18d1495d5415a00b56e24c22d5e987b4530e87c1669e4a2030eea1be44a560f3fe7f52cc4cb188bfb87dce5006d433d88aa6513053cee83cdc279817b44c5c98ce5e3071ef32ecefddf4e0506eed4d82284f90a6995e2a751dcfd9a66b0cd9cfa8bd737747bc9be5b66d8419919b30224fc75160f5e4445cfd36b7bcc8cdc29355def9a6631a39a2bdd91b666764f6375f02d4fa0b295dfbbdd1221e20ab28f0798da9478c2a560ef1edab432a089b5815d705bc982f626c9b03c1963cb078c92255cf8a37c4c67be80b728cab81f9f2d86bb1e0f82387119429dcb82ef3553ca8da3f8eed333c64484898a7cd1dfb4caa4d84240a8ebb71d97a3d1e7ac37244119f6e109754341a91fa18cd682e71eb3e63446bab00c98ebf2334ced1fba6df3ed615722611d0f827fa38d39ae130a559d8d8a703705af515049487ad5b59bf4d04cff780d3574c92312536a7e6ffdefcfb31797e32457144e1dc42214760d1c4442fe1c4214821f844e2101c545f0aceecb57febd96b3ce651ebe3de0b36547793e7563fd39f059b262d4b4ffcb7294729a890e9cffef3cb2df755746e25adc32e399974880412960290e8c93ff04a75613af0332c75e760d4a887e05c72100572bf28a2a81600c848804fe520c0f60c17d03401ba835b3c2e8c801aecd1eb42bdd6794b705ec11bfc60ec91ed31bacea0ffc1bf902b1cff213c86319dda5a1c0495d5a690a9f0c6a18d5e830bcfbb3f9056e1d04b37a934ff6894dfe7c4b109bc91061754c5e90259938ef4ed4e9dcb27b66de5979d5e7730d0709d66a1c13b79e9ac14cb11f9b507b51328593d5f131cc0fda8c1dd87050decf98ab0433044d05b2657c65aaae5e0d8d36c3822a6f4b368ec46ad905780b08a3ebea1b27ffd2b34cc29eb19fa1abf6570d35f200b9001672b7f266dc9c5cfec6607a0ab42b9b254b78a10261edba05e3554910c6e0d336962abf5355ee347f278eceb472d0c4fd55a9008f72fc6068e4f8ff88b75d7a4f41044d4bd9039689e910f7961008ecdff9c2c884404157d73504bb5ddd1e47fc1e7930794ba2947e022e0dc31647abc80049404e1a90f04cffabc20b4f657ac924bd21d78d4653867dbfabf7c706d595dc081ae6f3efec2af2119ec4f3e0ece1cbaf3471fa09c404636428b6e4d32f62e2d3671b455669726871251afee776bbc807d6fc39515797570c9fa2ab619be197fa00c5d7c095a5128c692b905773a039fd5d4452cfdb05230931b5f26f8988db0e7c5aefdf20f73db48a619b7af696b2d06cf128dcab8640c89cc7ca8f1f77efdffd47f1a44de9ad98536ac412deafd019c35bc703fc70f1f9ed6931f253d5718f074675360bab2473dce6d6e2d62877fe2209cb2c3b36fab139d1d6b5ca05796bc5f2f9c83559b2cabd278d605473a6c7611410a0698af102c9c155bf189d41f97c9d51750f5d238ecba835ea43a30a9d3dddca3c7e31912157786a5c3ef48fe220990013b5308c1683333663db3b295ac4922e4521b4104a973a91a91dda2c6a4d0522134cf3ce0156f6e9bb10d7adf9d99732158b1584f590356593e12a24f34b90f1b1535b7778e535a19aa3a21f3a65bd4aa789b9f5cca6d1321797ed9b4b5e7c718fcd47e011773063fbe96ccce5bc8af93871b24229c51ca2f5df5a65ac2dc3e6242fa77aab114603434a9de12741314b1bedf45bdeb3d40c5f2f80b0451aceb1a3ab37b56d22b53f48491dbc4e8324898a28d1dd56dd44f48e8d1b619acb422415a9d5d8798eb8c2964789855dd0e49a4312faf9c129c1d1815b349723ec0c8b3c8cbe100f045113c27a39ed9bcbbb2cf9cc443cbf426d4a065897ce40180ecce32aff8a2113374ae9317eef4f018465618d257214cd13b664717eed75826373bf6bd057482fd3ac5d600aef09f2fc900cd340d60d07cf417ae7bbec7b51d042ce2dacc8fc4162036f574ac78c76bb7a4e37f81fb02fb1ef639ccfdae019b7d74b22b2d0490b447f00641184a660a82a8009644fe367280c5bba6cc5b9c79967de06cb69c3861603f11505addd755500b5c3d4fee09e134516a62b9a71bece815c0e0137d0fa5f07c1ae856605936aa3adb14934f194c03b1c9e86e946ebaed4bf2c2095f113f3f82f59e423fccdc36b8214b0916326c9a8ef1d8d7c02dc33ba5c226983f0a761efa232f6829fd282282ae7c43813fa729344ce4f8b7acd68c0a437a5c3616233c06904b64fe1c06f3e523d4dc4bb809772ca576efaf9a839745ac2ceffb6435531e258af019937cd3494c894d7078c2c9c9f009224d78a7a565971427b2322a33b3254d3a015e7d61cdabb0570f93d209d75b71d21b36fa2bd5e0af3d70c406db4625f0f0c3f3fd87d9b7a518172d9744f8774d153be45754c05d03547294c18ae9666af48db6703b3eae38976fdec290f618d57d3dfcc4d26555a5f2a4e93d1c037f5d4c9ad1a1f465c371645e10fe906a3fe73ffbb5f6e6642df1043c7d00c7622602ea4680b5498c4299c9701fb2f07124a1ee467c049d12e0c014fa55a2117752cf304bba267b5b6cf052a39542d788c1533e41ed27e8261a185d097baed8fb0f926e8ea94a8a4c25e53dffcaef5b2c0a12ab2e64bad92d0282f0a4def5915660c3c8f134d6681a3eb58090858c5f7cb210193d36767154747822276c9f66e5cef2d28865e1cc4aa9177c0b54eb8c8f8d2f27ef4b628719186071b11a2495aeb515ca26ce66ca78dba526446c5b84d27a64a54dad2c0df0bdf9e08f3f8e9193356d82ab5f489152ee369d7f961cba872e8a34fc61051157570bcd2f56bde1769b5eaa7b1d89eb7c27dd1a7f2ec86c3b9a07ebfcdd1e8f93cab9e75bb4c38da7bdf8d5435febbddf3312937a884ca6e75cefd02caf06d905988d4ab1152e91337350a5df6288d76aeb61f7fd7d2ed065cf6077c4f8d1d6b8f1a37c6fecf14421ca714b5a1e51cd05e846f25b1a1e061419ec6cb9e59fae40a76bb0c50a79907dd7d79d9dfd3f3be4c88cb99251b789620114f87dcf6a1c91cb214689e6dd76e08ffe75f5598fa08a38ff3e7db1593b0d20ebd249d62a44a6da8b1fdd843da4a0ccdb32cc5269fa6a27bfdd01723a03d7f3418135337764f1121efc71cc6f0c07bdb620009a138ef3d850f54f7bd671e2048898473d158af3e923726131b0a090180bcdd8358234c7abac811e5afe778e9a74c81daab1b6a5c1659d66a38b2ed852774f7a5af37dcbf9147bbbb79f2803e06457d4282317a29c63b029a5a5819882ec422f20a4caaefe2cee6590ea4dbf949f01addd4ba76275dcc3dad192a3bfeaa14fca4e0ffdc1f567d82f313523c9262754e2cfff1bfff868289d7885c8fd05705ac4c18ef7b6c01d184add50f55b3b118553f85884481ccbaedd131c7151748279b15849b711a64a841a5082eddc701dce9ce229070d2d4d49036154c9b5b24ad715d0edfb580425bf1945c33954e13ffde87f3d8b3e930fab1c2c7f6804388843a1d8bed51e4cf1e056c66f5d8fe6b0d2451f6a5e56666c7d2c046f4e5a4cdc7a96bfe722e6e356604fe69f5c88b0896143ce9440f868b4bb5b2117c9a1802ea7b458e6430277fbd9a91d6857c3def4438d8864140e1532d84d2ebbaecb4b9bd5df22ee560e7d617dd890817cd2d75344713e865bd631c2db746b6b34a5848e332af4c48d47f49637591a0032f919ec6c5192fe10964e28a5d38bcd0d96d054d868e219590e3c6b187cf302a87e3d2e0adc449dc12d863b2774687d91dcffe413f1ffd70b0de4b2db6b1d13e296a45942a44b19cf13569b458604e5e4e8b1325bbf85847654d7a46852c54519bc41535b9f7340a4ff8c1e34edc01d096eea129fa5a9d7a8fdadfd4d2eed92213771f0b2a8dd275a4b2969a8f29410d80821a2e23b41b34c1e62c46e90213c48c07920be07f3cbddba252c58783de410d038e5333c693de6e44928745c8759ba2dc97cbebd520dfed75cac7721d8aa1b6a82d87b1a9cf166bc8c11b7b686cb82d86c58213425e436fde3edeb77dc85465a16888f8cd95a82792f2d022f594c8dfe621280929f778a962c2c2ffb401fc05fbbc07e4238e1abd112e7d54d79119f7a2c4b0281a8576de0c5a5da466c8cd5e0bae9a619a63022232247b108819616dccd42d0c73205ba5ed714e856a1a7153a81909a4ba2de98d3774f08d41bd18d7f508814d220bf6e6f5b2126905668ccb744fcac229dfd87f2e3f7019fd3662ee3eccf71c8b31df1d0680d53c2c87a814e33d04cb99233012de0ee20b8fa7b7461e3370e44fa927e8509175ce1e96cc31d013fbcfc37b5a3cf03186c2bc56dacbf0767c1beb626d8e2e04066255aae4449f9b413799efb1c1f758ace6e543d172a850b24cc4949586f2e6615d37a9f72c601a5eb5dcbd6ea22a1edf9a8f51abb222d5f84382692be000e3bdc430a30a7b0d0c1ae1cbba0ac0cb6f2e22d84090d95d181a0db22be9d0124bc70cbc7d133e6832df92a4c201e136ebb01905af877fe27f322dc43ddbe2e913a48fe559d336920b1deeb6cd02792061c83afeeda1f769d737ce392027011007edf65f1b09c4af9c655a22ab8e3e7cbedd0ae911870285989a279ae715cd1b4b57d4ffe3d53b976b00bf49a0d189c28966d46219b6b3fa28991d1f767a4f13da200c153edf07b6bddcdc382c8e424482318adc6b6563cfaf6669d5719b0954b1e0499dadaa7f88f8e1f183c5d20959dd7729405c43ac261e15cc937c96d1029e8628cabaf8cbe4d173cacbb2d77dd517026070aa792c33e12b683d305896f0db16d6b432e6c09cc32e1fccba5800d6a404820adf17855d33225b1ffa861a51d8cb63193b824f5c002ab93811043397703bacad4430550f62504ecd5858d03314583804ef994d687278e833c71c112c45ad6115721f3b0fa403ff61b93578d6964be2d4ce86cdfa1e2d1538c325b06bba610c2e5f883be6ef0015cc50da1eba78bfa2af868ae5dea02ca9b07ce4f976bff4a80ea5a2965cc131ce47305859a842070bbf9aa42b44537de122c9d28b86f03e7bbf2e8376fc6a3db5d64e2d6f8d91fa4940286f4381ce5c9ae63bebef3414abefdaf9bf5c7cb1c6052884514ce5044db56af3c8ec78706a370e0f92051c1b37ecd01cd805f614b35f184bea9df23612653ad96af912a6de73ced509b21bbd10087ece1fb5af22ea292e5006a1c915d60e7946b7644d61bdf5909bdce2f88d39f04444018decf835eaba83a6845610cb46efae63a7f5c90a9ada8eecbbca53c86de9e90171bbfe51b75b1621b3477ebe4ac588e532e4b5508c2ed15079830abf78ef87df7ca8c9f8d98566d1933b04a1c59c9bc7b7e69a49b8094470e9d278ea9b73ef9fb60ce382718cba07cc44f1ca93b22baf4f87d00d02e3d5f679eba965352343f63a0179a97a135dfbf93e77e94c470f6f0361d9ad86bfa7f7f35e9cf0740f23545c82d1ee76ef968528f9a7476b5850b6e5fc0dc955ed7b2ff32dc282c7cc20d11cc527da0b177eca9a46b6738048a49a3ed7153c7f93e0d3e24e1c8509f4e1e94ce5001733d64c8a46931b3e8bdcf54499ee6a5b6165c48076625d227679446a75fc7363f2f6a14e72365c834f1fef79495f9e603b29823d80476fe912319454cfdcfe485b22ccd8460347879e17e95cd2e534461171d83df8b9a51622d4c7d142ba73c312be4137e37fbc0d0e4a3916b2e03bdbeb6b95d6a54add60620f2326e9de24f2e4bf8845751ac703ce4249eff2405121fe95d5f4a98aefe31885701fa45cc4b88966344f2a77408b44649ad6544ac4ba42cdc6fe71f1edd1a22cc1bc9764e5c5d942fc09bbcce233471468939ac10a4a035e30bf6b2005f3f30f5b4c9e26998511bbade32aed515ed39d02a6c9af528a1a0419b2da64e0bee379fc17331c4d5cf3bee235f5571d0d5740de038b2652117282b9fe1aaa407d3d2179eb1d8577e5b056212cd0262332744283ad3b457098060b5882a6f5bc27cbfd633f2cd40bf210165cee87a36a9e1f0c61665e5759fd40a62cc98ed2cffc1060a59835d5e4b1e8786f539cb60076e806bf0e105abbb5effb5ac9991fae3199ad3a832df639dc13f28ce71432a8431b055deb3f22251f1178f32a1e559edec37eac7b46f58d48b21351feb9290192e6a3a039a41c1dd079f7394e58f22d95b76ac411935916cc487bcb6a88ac9eda78a4a01764cedc26f31f7280ad8b21c9b12ec7574acc792ca17961e5e924e114f473025cff39d3396ca7a2369aa9fc6f88ade15710c6e0a28325b651c280f68003eb56305952e53a867ad6d4e4d1d29ca0be069cee53d3b5113e5915f9156382eeb2c8465c7785bf36687ae6faae0c0f447a1d0e0d6f8258c4b3b69e04815d0c481d7b23304272f53f246318d21c7938663ba7cb0eddfbf241b3161bb9f06dd31eb9ac7e3c19f65d7afa41604ac61a62687a86fb0bccf3db36f736d9b127dcf06d069e470f7174dce5fffdf2fd8da790b24d550f684a78fd0e2907233f12cc3fff6fceb3fd8d8673e08bc86b3eb808093dd52153617d3af2684ff6cd8996ced7b32fa02f07d81a55e4c83a9dbca4caa4bd7bfceddf437d16cb6e0886be38c0349352aa6c3b16cd2d47b9911ba8e31992a2be0e5b8bff11f2add59e1028debea9032524cad889531d34657ba75e4c7a3ca54ab4bf46ac72d79a82cde2d7885577bab05fbde2feef6e7a10db92e32b1479aaf07917586b7cb58307775bc8ffbe5941b23b35c4541a4f802beba23d031ed3aa73efe7ab373fea1a8c64160aaa2947eabb722478284ff2292f61902f07e26d710a2655baf6ab67e575bc6556414da306171d37e98ac9c6626728390c43e51fe3f38d18353eaa6151958fe430d830d57776ed72067c534a509d5fe9831055402a259a4200efe0aa7932c32f445b9331d7e11b7aaddab0cedcd013ad32576cc75d711ef0ce05d826f377bec484607d10d49ff1750b7919c3db2b6a36ca693f5be82bb4139930d300e07c8def1ca2ddf5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
