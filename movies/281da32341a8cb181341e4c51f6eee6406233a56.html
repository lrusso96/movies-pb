<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6f1f31afa58b37c9a17c1e7ba4e1a9a103e0db01a36497e07cbfd2a8beef9695ec19e9ee9082c3532b1aa2f445bf0df14d9c82c84be3447deb7275d9ac209cfd5e68be90033acc023b464249d192f4d70e4ed778e0cfe8ccce05298dbedcf263084825bcdabf0af285fd10ae26c8ac55d6747bed07f1aa9011215a250ed9fdf10dfe2782e9609451c84822fb1fadb7b185a0916f1570804ad395683f8dfcb8ea2af05d07e0159ba6faae4666627c671e8c86d693d663486d8281655ba0d598a67204a41e358d9f1d88082472d3b55df21cb582c424942c3370bb46ab752a5df4a9c08310f9d37ada7c6c943ab35dd2768f848adc15ca51d38c10a4576d863a6c1b5ad0eb529d6f87e47ceabd72adaa4e12d23fb65c5458cb711e12fe27b8e6b9d785fd1fd6d393e93907d1267db04693841041dc11b390f1b96e6bed4cb1924dbca4cbe361cf9f036feefa79871e7105f6c266d19d3dbe2beec8de8c1e3b94b91cbb2820ca5c51d5c4e1ca852b0bd849b42c92f6223aad34d86bdeb22fbb15612adbfc2cd1f56a36a94b157bb6499bd61732511bcf6bff235731d75372a88a58e799692ad4c07eaee9e7c94bbc354508d3adbbb1883dd0c2469085c727d0403c2bef83376a3e5d626a8bb1a19b194dbc747ec352e27a7ccea10e97f11aeeac0b344bae0850af1b7638a807e5806cde6461726723327431e1eb1235059fa5363e9a1acd0907445c4d8bb0d185d01bb24eff0941389c5950cc732ee79472979d960ca02f9ee31ca4e82d81ac4901d98eecd1e12e7b74187024a930bedcbbdcdd7e5172032841b4aa7b66f13396e1cbfd07cdb290041be97e2e13f6bd4229c76b47918ffaf387a6428f4cb65fc0ef3d1d66076fb1291abf309e8feaa426331d532d0f5934225febe0ffe3527faa14ebb3598e40805fa3e89bc446aa64d66b060610a924122bdea1f52a18ccbbe0d69722d68da6a8fbd5a5513a1f25c59ff77dd0f4233376eedc28e5e67d05612f06fab5e7c6bb547bd92ec19c6562b75730b633796d429f98cfa79b8f887eb542c4cfb66a8e8d6868887ef30cd60e85a8a94f9c6d8ad5e018aa42d3e44cde3a1dc4e02044ec16b266e7b4468baf03204188e4de1c66256fbb1d8715c963124f81253910251e6422a9c74f232dda3e5c25e88445c70f460e18d73ee2e13cdde161a490dde69372b712957259df4513684fa13d85b6385871d4555f44d232eb5242399cc047ddf82fbcfa4bdd871489ec20d5ac1d7549fe4ff5f77f5199fad1258235dec6094bf108f4d9fd9a30b1858c0ab3186d9fba9395f10bbf184af0a677da56eec785b59ba6e74ee6d8460f0be1d7d6f638b266abd1f08df4d31d2b1044616014d7829c96ecd94cd529eab3f876216d98a9a37a0c1020259a6047c67e1a2d474a0f3ab53e442795146e18d15dc7233446c0f3bb98fa684fd4fee2d14bfafaf4382da5b22d4f4cd41c223625d1ac94ef9c6095d1c1ace9352336cad6257e09fe9dedd2e84738fc8cfb3533c22cc8f32573b900c4ab6ab75df73757e0f6085042f06803c6fbbef494ea756fd19d4a9535a78ebd2cb965216b453133551917b3effa71fab9645834a1a9873900b53eb89815ca6a1f2333ed3a22353be1771d3402e2a4e592669bcfab23a340acab564462ffbe3952be3e5daf4431722c6bab2889f17f2e16acb48d3cc2873109c66769c6c1a14d236872abaffc92a950fc12bb21e8dad11371170393c6876ece615d245d0687eafc976a38af39ced8dbf15fccdc946fe205aaef9dba0f978c622a06c0fc4ac2040997746eca014cb7cdebe1b005103a7658b34839d38c90c7dd9a11f31118aaedea2899b8dba6c57b06e73cdbc9afaafb02d9c6b463e290950b274e1638facde32ddf323beafcce5dc9370dff4bb5e67c3f7249953d5adb057e4f8ddf134cc86f98c925ec1b08691a125133bb10af08c9e39f734cec92afd89496f7d94ea19545a72371124cad4d00bdcfab940d6bb8890935284ca3994aefee57388b6d8d305cd83cc9f378639a5f914b6ee4e0133fabbf0ae2ca908ca8082ac51a5b1e1dbfce3bf6e03d1bd21849907bd412cf35c670c5d7cc159964eeb8a47ecc9f2908a47c8be0fe7d7233de0f77b649e4a642ea127acd1b4060017bac5931a140d7505829ee6f3e8ebe582d39809d06c3c1f633e507c88ba3b228c599f66fc65c832599b6791354b8c48348f3d4446e8838b8849d2ba1a7507e855b984433a759d9f72dc6b5dcc970a1f660518412ae194359f2e86bbb5c983bf854178ef768f84e8b925b9a31f9dda038e0bf0074a4ba692c4460713001a67b47cf585e5ec1cc5092b70b9c579a16fb46965bb9feb7e110fde7b6d62500f2b52cd99ffd1431c6595f7e913df2a53ccabdaf161929feddcbcc3dd3b9626f7351558f61318051a89a643e4f79c63cd559ebba8feb97971fb84235cb30310755557b147e1af5bcb8d87beb7d05b94d47cc4d51627cd1101510e2dac5e5412d0ff6ebbc23aa5a23694f23662969e72919eb7c33ac8ea7ab491628ea487e27d8d5e0a5e233d69588f7acf010c98a96b56b3e94b4f6619ce6ae9cb26cbeb4e11d0403f807a31ec18ddf9283be207713e7c5269ff26f18cdd44dee8de66010a52ed0f724ddf287b383be8365e1ca0e7c304668edd5366b67a0ea4e286121a1f984690f06b0d23776c697cbea13ab00dda413b7c1288d5c66c19783b013cf1e6c458388ee0a0436987982415265fdcc9761553cc50db266342b56508969f480a38bf34d716846b3d75e06c176b10094dd9f92f7b3fdd9edb5b00a71d2abd505e38c04776bb8ce7da0942a30c73bb0e2f4bac6c879463660e80a957a202c88f359142296bc1b17b97b37ecf7f590dea5ab12de9dd6eb29f48028feb3b507c6d0cd98b7e98cb07d9afce8e4809c79a945332a2dec082c2a2ef0851a1edc2c16ba9e77b2432ef0e7e4e625d70f38050dceab523f6e115b8a5e359804fba8fd41bb6604cf32acc013fde17d2095fe391418066f3095e2917d62a9b78f95009b6235bdaff769548563ab4ae9e0a5233a61fbf2914ad940419e6aa471ca1e55af106be7fd8e8742cabbf39425d6563be779a9685ab12bc24538473e6d2d214d5ae610b08467e697bd2f33159888e0e8c869cabc92fcea03c9403aa49f4f80c1fe7d00852586a466b1852ff37135dd669a6f89e59edb2341c5f5c20bb5782934c2c0094ac854bec26698b700e2cd4892f871b18e52829ea23d96d5b5849d18200c56388ca9958b3080a871c06b6119c29d3a58a5f6f369e7b8f7b6f6607db56d583dbaf97e16c42f0fd5e11a1525a49e5f018be1b5cab3c8f5702f738d27bd61729e2479326a77515ba54264689bf51017740b6a5d64c78fc22d99975ba6157eca5bce6adb6866f1bc3fbdc7fe6af771b949b3256eb379634b7dbe9614aec5536a89fefb7d5ec9051f07226c6130fa94869cfe0ccdfa1a669780acdceb598f51edf55aea04d123d36bfec4e133c43bdd818382fb22dbc2c271634376148dce2af41c154b376a8bf157d44bcff4e3407b40644b3d9ff779219cc38cfacfe9d7b5f74ca911ec75bb9947d55c388712ae7d6d6081f618089fdd815b8ed5eb21d3767b260c005ea83b5625d6d2e7f5195db17f9a175a08abe86c95abc7386eff8db3507612ac4ff273a605f43d11c041575ca3bae281e94fa1eca414bfec7f93929334380436d8f19f5f00c60c7be27fc1187eb4097d7a9521beb5ae7364866284476ba6288fc337710e561c582f9425acb8111b53ef4d45eb0360b44ced3c0176a4cfae22117005f45990e12c6dbfb84784a3fcfb5fb23ee3abd4e90bfdefa1b766905040219f728280b94b6d0be092327593e3acb47c998acd905aaedc3976eef31c4c4325442cb59ac693f9d37a0c20d1d606a516dd34b34a4c60dac3e42abbb06dab1f4c242cf1117ad2432fe41e911089cc12415eaa6768ad13837a2694e136c7f50a8d16e9f9fcd6b7894d21eeefc6397dda17eac177b372894b2e03ebf145143a64fc487b89f54d7b1fc2ab9caff396c8b7bba209d38bb1885fca99cebc4e40f535bccf3334aca1300d0e2d909e7d568d012dc97118e6bcd070ef2d69342d21c47672c99ada48ec363c1a9315b1a7fd25c8f25f4fb4314ec8cf98384ce053c442d3f511989f8bfc4a06a18775ddd2eb8e49e37e8c4167e52825067bd24b887917a45f2fd9712e1e4ddb8e9ef48706c6c295ce281161dff3ca53454e293eb61ef8ea0749ba9032fa92d4063b67384e284a2e0d9b4867cd4964612325a3fc8892b010a2dc81805f550a04ec7f7e0494206ed35183dff1ba5ab4bc4e781fcf50ef70289fc6ebe9c15f835eaeb9afbf14c769edbd7fe74563ddf29693abc3b7fd96f486a2b7c5b75e3d5b35bdac372af4b67382298f0d1696b58ee0e83cbb6737adc8dee97d01c5d346bde2a459f9cdf6937d8957abcc347a2c731ef3ee62d787bfd5d1951ec88780097dca935e178531954e56c80bd2e3b5691a3fc0f64d8fbf165332898b98603ef64e5852b541a3388a2a7f4d63a32c5643757a057d9610d3cdb5f886d6975009d29db5cf7f7f37e63750c6b3a61f8c880309e1434dfaa14c262969db36c006db2f5f8a72cba08726e7a12fac0ef32e3d4407205a14c4f45be43bbd4f7d80facf04884b038744aba0bb416d0792c8a78a84219fe3815f3d87cc9bd59a4ec6551640ae6964c2067041dd08718916dd6d1a0e93e5c8fba73de6b35cbd1ca573b317031079668d2f747b07eaf64e047af409396f82ac2b0ebf25e2fc4c09302d6bd38da6ac0a15106a9cf6c1f8763391d767e2f1fb224f2fcdb877ab81987e6b8e00057f48abe915078fa4cd816d2cfdafd5bee7315f6a686d6d28943daf483e766293bd5e959ec10b1c6dcca92ba2405a41dcaf9ad9c6c7f1218858461764b765bc9d4782f4662deb6219bac4758438a25aed3b6c92e21dd6ac4b0689bf22d5824980888fe079082bb45ea4df3a717621a00e9edc0a464693fff2e345f7703b7118d6f61413d1b20758aaf122077614ac2b5fc6c1856a4aa50f72bb6e10f45f07d30e45aa4ef6d558f757097a757a551318366e857ae0d7d7792150e589de234526a80d3dd2209da8a468b3174c932db6ef160ccc372cee662b60c21f7c7efcfd25f3b13c46802910d58a5c5d28e5f4b365582f476f8bc276973e447335d250715109ae24965bc9ae0db7763037ebc37957325c4fdb68f9b0f6102fa459da030b18c5d269a857162a8c72d7685d844488a196110cc3eb50b16d3926ad76008bf812314ae4670fc89b0a9011b740563f5265e995661967c55c4237db890f2369506ea4945db833ed9be15c2ea3e7d16dd8bd22c166e4fc03379247e1c8d05bcd173fb96c8a0f56972752760c7c90b1e3de755e96279b8044773186eb37212b1c66e45ab21a155c934afec5082bca17b91b73b463ab70d988d0e93b0f118a2c7c503010f4d09ea64a8d91f792598fccdbc3d7c53ff37815d3e17aa88675fccae7fb02386b77f3c9912996788b40d589bbed8fa6432bc84ddc135620fd373a92c6d07c4cb107615b39d6f2d1976c5f205af7b5550934e7275d313613402cb29852e32b80fd6a9c1aa6232eeb0b135a856860a197f9b7796b17c0434034cc2dc1f9bfd2b2e668c4cb52933038280491b902252cac70d232d4be9c09e229b09f8579bbf6d1ae3de9c11b5adb25eaf834ef57a6c6edcade7ba3064205100f9a61771df260d2225f1c93a4f08e7f800b7e92ac9715b2a29d1f3ca7cff34ace9963afab55c470a06fa607ecf0156176d102e42a1f8872c81945aa2077018aeedf6024e01b4889ef075f472d7dd09141d354f428deb2f3bb2de64ce566884cc4fd6ffc0245e5570e0fd0310c064682d886c2fbe8f18ab882bc51ac12913295b7bf6926546870e429e87d8e5e383b15effd39200e992a8d759a2cb69b9f7526204ddba581b8bc1f4038beae8a93c38b0c7045231912a5a385d6f2719536dd4c3418e48b203b1bcbf51471ddc6a8ecfdcf652dfcf63efafd7bc14bc038f66d1c1dcfc246d4afb00cd13fa7ddf580a63031f1fe82fd59ffff36fd0b9bd67788b0a7029f85d8fcdabea169b9f8518a4a630199270b5d079bb5f0e77ab3dec117eb6325e031d93a57bbd4709122195cc33d0e1f73f35d46bbca79a9f6ff5cf5c1911f19cc1d2c09a7e0dba6ef2bf9f776144663452a4c173c2eb6cc2e06f6711cf35c875b1d028966dc7136d72dd73897936ddeadd4ac7335f2ad5f55565fb839bc09cd34c0f72309e10af85646fe6d94945a6aa1a0ac1ff8e0536b3af923fc553461f16b0ce5bb463e6f46df15db86a0dd825455f6308a111abc589d9426d6363aab941fa89bd95789dffd8761233979d6c75889ef9def972601af683db44d9b055fb74b56ab60ebef571355a434d4196ee26989ed9c342701ab5952562bc06602ed0d2c71749abcb9474ef6e9d260bc1db5c99f8b9704768408ddaa74206aac90303e7facf9d9de53f220f1f7519c5e2be5a9bb93ef9e4842f2fd020a9a4567a5046f30ad9d737438a30b6f4b42a4b0526dce0f4c5515c2c6b88d990f1abe2000fa3de10e60a4806e14b235860e081b5395616851a9c039e75fc671cfd4aca7313ee3124882ed96349f4ccf58bbe79f5dd10bed98eabacf70423b083c5ad37e66d5b4cf3782fbf28461eb47e27a35989f50cd24d67e4e415a95cd88035f9f25c6b0479f9445a135f7af776a52842c750ea7194db091af2f3e79c32fb153362ae8a6cce2c98540c5e62134090164e3f8e295b6246bb27e95d8a03e1d172c8d88f1ef33c73565d2a5abf6fdf6e2f1fab23fe64b43396901264da4ab759ae43b6eb48f3f3bef397497eac987799ccd9028b2fb17f2c94cfb5788dcbefa4df25fa5985d6733141bf3dfb7e1d64bbbfc7cab68b96de5e2aa8af34b8c290916c3968c598c930c745805ad18f4224243d7dc9a146e29cea71490edf991ee1b3c4495bd92991a042ef16c47cd0f89ff216e29fbe15a2af1279f0e121022f4b11192c5102e4431685bf6fcba6605c179492eedd2eb5be9bd5de47f782dc0a23e6ff7e65bd2eec58f59062d9666306f5625701887e06ca334e3f66fd6399122cfd4eaa51a0a7168222332cd07f5801d15797530b128cf0276b0d05a0a791c5518de91a6e15e5bc77de84ec8ef3a01d926386f0b1a398df632e1793ce929efcc2fab83008491862c5ae6d1b326852ba68ffb8bac3f92d39d014379e990836ca38a8ba52a2cdc5b62bc063a35709b295ac0f8981d2fce4c7a9a7dba594ff35387941f5e33d7ccefb5524e90b5864e81a58fe981a43411ea8fb77f456e0a55dba83ce36ffe47ed2b46a810702c57842637422f7efd8809b669e91db48189cfb57552bcefe6d934c88dffc0dfd82177927033598bdd96afaa8ea5c3e2538a24ccdc0f86a355fa93dae75894b68feaf68abad1d5502305755f01954044970b7058ec1bd132a93fd43491f105312c6aa9c61fc8796fe8e4501876ae0efc1478fc340b0a0fb53de5869067176cb0e3bdeecc8e7dc265f12744ccaa55ba041df248f995ad55e4a23afc0d3e8e1682cf2dc614bb5c371f2319075f0e4e3536743e6d2bcdfac7bb39bfccb6c546488a86d074608c96aa973197c893ed85c8f9d4b5018e44f5892e8a04290086edae506b36fe493cdec75baf4d4a07a181687b9d1cc460d073fa17f7b2c6d8ce951bed41c3f2b404cec379d0c8a4e65bcc38e76175047b7552f3692cd2879c0fdb3e92d2dc8f160c724799c87fd3dcb0bfaf9b69ae002f7cbfcc45a876771b81dcd7203fbff7a8253cf1eb617d7ff21263d76a396373e9df796bca3053fb82f583b0a916dfa957b4c7aaa86a6937e6f0341a19511ffb2c8f001be41b8bed8177d0a7913f267b069109a561227e14071f3bac83b64146eedbf79825ca9a2d562e9d97c916b1a6153a2bf228942dbf0ee81600c40098fcc2e63bb937d31708e7bd741ba61fb8756216b28558dbf2a8e4cd947a51c010241111ae76c6bcc293090afd651266aa956e335f0ac7cc9bc419725cbeaacb385481e68c179a93095dce012ae2f508935e9c7869d94d1dd9e6c5418f0f3ebb8434325a8a556ebed3bebafa4fa99caa6aab4d332d4a80abd3435ba04324831e9cfb5302c05b470d6244afcfc753e8604aa8269c4ff9ed6478f1d83838c32210763bd6eee37750220ecf3c02154c0c362c9e75db8adb26d86a9e0706681c351259ace86057374146f7eb92c8355ab42c9122e70a4205eeb8825e9832a6f929836d2198f7cfbf737d4af81cfea63f1a78382a35f11a21d0e29f4dbce07ef339ce91f5c2075362f1fe23e099219ec3db6a501abd43bc3a75f66d154402278077a5f3a6e7d7942a2ff2fb409b3aef5aef66940b355ed7d71bf792629a897a88528da52817b555a262d6f718d269fe4304db0dfbb39c1bc599c32fdbe27e1741446b83687633b6735deb7e90c94e0b9afda3e3644384f39f4f33b2b44e8d2a6cf9260573f930bf78d08f430be6168ef8544c6c6e0b4a341e0575b5d2f6c7712956be7be3273b9ce0bc6057f02987a60f6bb35eb28facbe2000722c53314821b6c3a263f3bed6bc7e36eefca7b46b6387d27c289febb0849cc922f20bf808152b91d0b1aa5d70a012feb547c926c0683b4ad9af3e8e52bc0c5f0651156f5b549302e472be16722e1cbaebd2ee5a6503e7429e1c7cf64faa585985d74e3c72f136aefc2b22f3e96a431da0d6ab400cb97917d41fa49a79264be0bad02837fff077f49e613d09c747e04f1d8028a4af99584b38df015300a9d0ac708da594516bf6bcb16e1a4a9ec60589a343918c3aef0de373c3ad5bd94a90c469057edfd7e0d3c2e76895bfed8a674dd379042ea201389dbd1ce94303ad21c21783137b803478ea829f7f9b6aa42c83348e2c571fbd9beb73ffb9fc8766ad32e52a3d6f11a5cb0f81546dad7fea04f2b60385059031b9d74fed639422f1b0f1d36ed4c4e138ad9242963f743195a2db599777c83e91fcfb18c4bc128d36cd322da5a8d3461f27e51e86789f55acdd225891c3d4c4c547f8ae80471adabc4553b6ac477e2e6203f02c99b8c8e6c2de59e2ba5d5a712e6c50a0e913d871ae95d3bcf4e4dcc72e1575d85dac13d1efa97c5c34ae5ecbf1a9f863848d46e08444ed7c9a5fe0c7148d29eeaf84bdad8dcc8974119530939697acc3cb39f3fd51e4fc82d6d106e7a382d0eaffaf942d0b2cb482eebcc3e1e4502c085740bd25ac58b711d61a44487affc22e9a6153c12e4f41c3b460be10ed189226864b3367311c254ddddc4d6c9b81d61b8ed830c85a6df287cd63cd8bcf7c6be2ed017628d886389a454c1a988b1791c82bd0e2da706080427828e2781e638ff342f3a76d265bc5a6c516e1cfa90c6f62983648e76a00a468f36eefef4456bf4c4625d40043aa47450a2af8e947f215f5b28c9452fceaf2e88487df8f3df40049a226cc36fce6d3678b70bea70c04581056991816b8e3db666d4e86d4ed0ca531c1724b08e0847c78b5441ff5c3a5f0a064bfa5c639e740440c56660cdb5c445211bfd178e08204156f79753f376d344cbdcb339d21c2af14b2a3eea609eaf614e2532b629f9e35231db4f1b5728d867d3b19bc6f19282a96b0f7f5e5c4f94a62d887a776ad947371b85af53488d24d494bed3348b662f2c411043e2ef10b89be3b0d820646dc804da6b81e03bb805c54492c697a2cc8f031196643ed526ea72491192a09b1e9ae3aa238fb92f08638e8fba44b39617832e92895374060b98542502847e4e6f58af81195a311f2eabba0587f0bd5766fc15dac3881463ce7592ba537ed098f986ab8b5774377695b074ccee642b479f0b084e6b0c6be333fb0880f6f28d65bf7605f93c32a9cf27f776fad1c6e6f5a079248f874ccb28da9ff1fe7c4e48ce043069d9337965f95bca764e499ef7e26e4ffa586e89c8470882f992fcc8794a215a79efb5d361f50639ff6086cf1a75ebf0fe1a54ca67d3f2fce7c72029fa1de1f62b0be9196feea512625ab7403f3b6defb000d3371779479c9538bd264e174b3a8d9c255aac96152b8925b94730c0423faa7a8971c01d50a0a962adb86b08216bfd2dc1ef73c8b7f9143439b1776a9c580dc26a79c4f8e200ebf45f7eadc0c678dfa33b6f55c64627dce355b46aea0da6147752ecece082a9e8a519745a1e44b7942dd53d85d7fd0a3162e127218832ae012fbb52a817b16e653fe8b1f1614c72659657437f6d1cdea8cc04faa6c73352d9fb143a535e0e9fd6c1bdd9fb3de1392a772980646635e5dd0ecff17153abcec610d6a5e9c552e3b8ea1dc9f6364f825d74e8895c4f541142353e3fa971c9d60369b7b1adef3c94a2b09255337b01c711cdc2ed22207450c07a054da5b4e8560ad1b63326fc6307b7da2bcfeb12c70cf300a9fe7671ceae55da785866fb3c0eee35c81be91314598f58cb61d784a0979a98f01d9ffb52612015aff9694e7c78854eb89261bb2be03e1dc6ed382b19f268baf4293420c00cb21240df82c64bc0f5121489cee7c80fb7b346a9448516a0eb38dc9b4cca5d214893db427df6aa7a9f6df118a552c429cbe822d31de57f9d0f10fd86c248ceb9045a881ef72e62055a3f08d692fec37f1d90ff36ec54691901c3a39217b15dd668da3b91d1d9623d05a5dd7c238617ba9e3cb52d755adf631637b93f4532116426d78fa8a450b902aefea3934db40bdb02831756e61638bf0102a2884faaf6a0e6a4fc5e93780b7ae9344b927827bff7f45cff5696954b903ffa755d177d608487fad06fcf8784b779fac7cfd62da3ccb338563d4b3a19e49a90b281db0e251073ece96e33579f9496b6c83ba1a996ca83a7e24be50b7f8ea47c01242506ef7669b11f5549cd3162a067622200a6ca910cf0328976f569becfd513373a188d644a21e59648b5930c167f44b2b2d7ed4e33c8141565f9d1bce3a6770ad596bd6024f64f95bbd71a9e354a0f61cd707e85ad95d252d5656d26026617716be47e4a6b61ba93773526aebe6eeccdfb7c8f0e9d9673bcf015c902c12ece28487c77851545de49ffa2755d52ffd1851f0b11c8cb222f5d868d0544f12c03190d18c2bb95111fc517c5c24a20cbd57a6741d54763760b97327f7d6bbcab055eb888ba29dd8fbf1469abbae7effbfcd4c9f3cebdaec754c447dc6ca38e079a0c4ebbc067effdfee1b7ad314660401daf2267449d9600f8be1c729512df5c5828498b859af1a9a6e168e699ce1f7ae36e2ce56a119e914d2e1b0e2925ca3281b0ffa5cfcff7aeee7334fe8f384b054f787ab6693987337c171b95b753184908f71c5dc9f3e3c390b9b66c316faa2a0a91b8ad375a22cf1634392ea7ebb094adcd4ef1519d0e33c73c493a8f2d110d998d861f71bd854073a0f3a0c5fa82fe03ff1e1e979fccaf5734a46fbe44e712e823ed371070d0778e0e8f463e5216a9a981f5e8b648c71bd7821337b647d48b6bb9501bed8ae1c7ae853de38102e6b72623db3014501949ded78a7ead4d91c43d87b820c13f62bff6b321b43e44dd1dbdf77f484a247dd76c28230c065ae8f9eeede8a151da6250cd62972c28a3b3ca70b81f01290ee09607e7a543eee85004eb142d15d0606fee1ed3892e62bef424b9b5984e42c49222fa7acc26090ba12ebbd840b86f783835d6c6c26d8c1bcc93f534adfbe225355003f3c56a5bd8669185a04204c043bc880cabb97a2247f5073c3c077ca68b672978edd07cd85064956f6ead65ccbfec2a9fb7bc5312746d359ff0f3309e569b0ab276bb6ee3d5e2201a8475bdced137690f83e93bbd124ace9fa160dd0ddba1ab2d9c73c1f34ac91a1ac098d838bee18ed7367fc2edea20b12d3a452a6e2eeece29de9c939b588658afded78e10cc4acd1f7c82789d8ca46bc6ca64cfd4be3d2e1b40046810a176c4a14e24b9568c3df71d85d3a0f67b91f81c82ffb4aa2715c6e3a203744b9e8b28104566406ab3d5f3b30cdc4a70125b3d0c05d6f8ad85386e7752bea31c40f5a0639410a8ba36980ec04a61d72323ab280b1227ff649b0383dc8d05a1c256848f7de1a95934534be25df27d1bd69350ba04eb8de6ab94adce2e98c5f5d4b91086e31578937d978d55f342f87f2c8db0b38fbcaedfb0335eb9b08bc199686110cfabb8e192d63b3167e9c5c5ca9a2a0d2bd2509c3e2dc2344bc1fe0be9e9a06e883a0054c268f535d1a77adb1d8437c62a0e68a5481ce01fe331fb6451809662a87dfb74664a432144c6ab7c6a6c823351f1a86aae2c5ed8c28d2ed759f340ed84dbefd89fb4a3db843ee62ae9e4f8538d29a91a8849c9e2ac7e13834fd0ddd4250be82c439f142222a0223e5b9607ca8e1122fc4f8bd697a05bd0040ff9c2d408be848ba47dea7a1c1edd6a4e6b566d0704c92051b763804c9e6631ec1c60842d7a16b388b4a20e9d55096b205cd68ed867c4da1c13f70420f5694350cc703c4fb30883cb59c8c5216c3101c07e4681789186ca3c7948a4c522f45320720106da63638f598a07df8d0703890003af2f92d1ba9e32948a1d09d26d3983fba0096db2b84148e27509a72b75984174c2bd8cf32ac9a853e94bc932872fae13beb4692def84ef9453a747e65b5c8f70fa4c8a936bd1547ddac3000564283b6a4614ae86dce45e21dc89e28ac25ab52f673149e090385a8ef3ff7cb5eda288a920a19f90aa3901c11a0bfa9b8f1f7a007691aea5ef8949812592a27ef4c2966cd097fbd2e6ee09112d44a6d98dacd68767ba2140601a055203a503b8d534f66eac34f3cd4b8f11b2bbff2d394d056230911a9b22ddb255106e65f75e6cbd89b1876dc802c4b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
