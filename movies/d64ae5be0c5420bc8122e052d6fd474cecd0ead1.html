<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"40fa025477342d5127a6161ad0ab644cc627b48be86d95b95039f9db060fcf5c8072c356dab35e034287849d0a27259e42ef33d6794731f025813eb6808bf5bc17d5e2d7f1e493db24835667e8b5b54b650353e34c4f8d70988d04153281921ac922f21fb96cf1ca8446db0a5239b6551ab3ec1a6022db4eae330dad7a964c1a969af8d29f96a2da08c09848cc36a2b697a4b9b4e8653585c60c050b94553a1c7fd9e563cb48f735c7a1053705a38d9b2b8df257d2dc795a6199085d8200d80fefede2263fe6a879e47561924ce46d0967372e2c01e5a3bf035a56d30b358eceb5408b336a7bb64158fc2d70a586fef32db19735af24c38835c53a4c48662c6e1b6556aa371aa5d6620659856813f0d4131236af22c0e51e5c3ec7d5756a35e0f003c674f4345a73f29913851548a08e8eae95a0fcef896798d52e78792082c61529f1ddffea76918c57d96f80088891e6150be4c11edb6b9ab19d13d091344c6efb6e52b07851824cfe9f28438de0c6cb3a4468aa03622cc714592a389acaa94f4495794e98c8c94f333bb2ecdda1fd672abcfde35cade44c5e42df15cbb071c3d909435c2fd015151712d9898f39e09ade13fadedc171d09ab4780987c768129a6295db4f6760e61cf88f9ca5c29bdcfb7b1ac23f92bf852eb9e0ec07efad4634340a1ad6568ae1284aa5e1ed91b8fb1c33a57a265e59ee8ab05157d3761479773cc4957a29103fd630cfc3d62c85e3d75615349faca1b8a59a77d4b747a1d09873380bd14aa9163c4081d62d945eaeb201f69c060924a5ac54fce1b73861a679c13ea3add5cc1ad353354ef640e94ed2e9110e78f2bd6cee869dc560523a2e550fd548b367d30ab8094e16125e2933faf118649d8472b36acaa9e76c134901a35e8ef00fad922b41b12d478925becb6224580ad71eb4c05c737f06d865ea6f809bf6fbd16d5f69fdba422b755c02d0b99b405db1c7245c966af0f343c1d11a177f71931e983b611c42a19dd3906eeec755dcc8678afffeb03ef23469078d6ea3755a358ae818e582500932ec69b7b7a284777af1c8fdfc7076b805626fc4eea93d2c5bfb68dc949ac3d66b0279d2cf51a5e9219caf37b87fec1d88a261ee05524d84db4169ca93e81951779ab62db4d3ccd7c736c0df67cef32db82cd83fc96bd182d86e4863bb3f43ea744f41ab48cf175cc6b1e35274b85c9f661faff995a1c322fb747fbaff5543ca7f247c1d0653a585ed99ea61645bc0b5ae2795ca0e17d207aaaf085758d6f1ba66ce0d2f0e3ec6b01c6b6f309d3b9211a2c5a530d9fe74595855701f46735d2f1c335269ed986ce2bd1a103541b644a96e388c19bc348acc155ed111c80e13d2bb9d9cfb33d84b16b85de04ade4455c7970ebd2477fbcc93de2a6e0d659a85f1ef5ab296827aa68078c95b139ab1440bb2796b1d2f7405cee8bfadc006169d50e5d68b912bc5c264cafb4b8d4376a2be489c2fc4242bb1122b8fa9f36e2ca895b4319b423aecfc67abe5642194e0d42b58efc47ddc3e2e4b967b5485a4137b79825013e946f3a383d19fdfda828b26c0c98fe5e4b4c8a1df04377688bfc7abd7c1c3afa0b87f47b3131198804823e7fba7641f6749ac100c01c3884d20cedc2d3a8fcf2c7b9396bc4c08ae731badfc36ac465dd50d41df860eb49178edec78e167185d0f1768bff3a3de6ec1c2f531c1bc7713b1c476e545e4c0272e7bfe38f0db77b5f6732ebc51c19e164f248136d9570335a1046c628f0bb369b7ea93cf072cdfc83ae1062f5a25014057928a429346ebf4f77e4e735993f5cfe19c4cd9b2edede08f1a822386205043caee344d8185bf951d7f790610fc4436eabe5852e0a45b5104ec2f0acac8d5984415ce84be5a67953a9e33685cef8c39e021d9d3f598b12412e209f5ce4fc5481488e4980086cc19a38e6a835b620408ba1fd69617f2d213585b012626ad3ed2f9160759dbaa0803fae38e0538e48a82bdebd2ee986f2d7c5888c36853be367ca1786435613882edaa77bc9e79e322509ffc6e77d2c3aa93fa28214cdcdc3c5e99830f68f9361c92c62277193ace05962cce9c9814436e793af01d8c5675f5ecfe3f1cda7f37f69867a4477e5312cdd8941617582e4c4e14c7449421d72abadc411ba88750cc65ab9529043b781a387de03dc5f2fe490ed91aa0b955351c181d2c5e46b0bcc40aabea1fad6992da6e9dcbb130a1c07de438a8e1768a1ff74d5a434190dbfed4060262743a1704863e7c93594ebc99cd90b1fd37b1726258c37fc4cbcb8f634339581abef3016584e11d21d26df1aa717def561f66d18f69ed3399cd46384ad32a9da7125844d07adaabc03fb3a8df1661ebf27a70ecd79837616d94f831e1c835e13bf10bcbf563d5ab5b21a037e08044a26e564d2dd4f5b08cb070ba371d8cd792cec26cc3f44c09467aa107a8a96e6b4fb5edc288c52bd89a3f2cde459c0f1aa7df10a89300143b6a8c8ac01ce9521aa4321bf9274f852bcd9dcdbca0ad1ff9d553ef8c8f8fb2710319b0793138d097f698f8e19fe60b32def49f71b4b10c3fa970cd4ddc56dcb99496fd019c33735918a009e8374100d76cea59bfbcf970fec6acd3f09c9bbcdadb734d11be958b8276309dc56138ff222562d2b3967bc912b964c556888366f3586bc02c177de1e21966870ef37030b3893cd1019ad2122183cabad630b50088fd4c33e526e96056068f6fd992b07a6f5f6e091a0b91309f8dd50f130c6161de9227706e900bb2e9d7d704e421fef3358773a2510607bf41677f5d2a0a13e8fa3e664e7ebd075fee0734be5ac1169ed84a97f86ee94f1cd561efd4b3fb1efcb94764bd6d3fd0bf21dd5247df0d333617a52e797e705c5b8ce5092da0c3050158f82a38cc28aab2c8ad65497b414a8e761c47b959ed9f8e2d6bb405595c3c9676ce6af6639c52ba238d0362e1e5373f2829d55bba0ed850813d5775c54c0007220bbfd73537da0cf18a1389b7a1388cc99766eb06cd030364204204af50e930529cecc64882dee23ea8a8118e11bd730927273c8d3185687ecb6b45a5346cceeae71c60f0b2601a08813800f0b7772c42f2f11adb9ebc9e99780a8949f14928cba6562a86d2b871f1943349d261e5ec5e4267794220335a29aab9ef638760b95600970a21ed2530d434df16752e0e2eb57a6b8c42a7e6767d238b8f0ae60be38899d21bf012c474fabeb401aa195f63854dfba9bd48280ddbc9453fe0f1fac884e9746c885debb1ae7a31e00662057dca5f243e49eca590114b71da69690155d2ed306487d1bd9f64fda1db0f93064f05a2f14e63b14905d4e15f5989e8b84dc30404ef97dfd324e70a0a1c2d320a721e4a54296bc2665a19cfcd690ed8916ffb016919e675d87f1219cec3b1ee6e18fcaa490342acd020751f6d3e3f96c6532b11b633ab04005b36a39bbb1e06094fe7a2bf2ba18f1d5e483ad0be8c957262d39a5f777b8609c84a6d3875283b820b4d50e00c232949fdc09f6f9e6e5ce490d5bec29e05c5a9960e775ec4131af145bddf2b9887fab9a6e8fdb7da2a53cf7c1aed835405fd90644234f35ee952cb944bceb3793e30eaca202f3db44f9a15b821c9b905df54c6039fcca8ea76679bdcf00f4db340244d100edcbbd5c8885d6e02799a519e36630d64fe134d42234e72ad5b2a32ad515299204b4b6d9558d5030a1c21c2336ee5713fed5b7125605f54185152cb0ceedc40a2367711555f339e1035b512f2002cd00193bdd6cb06bc734777fdcfa979cfb96d725c8f152238e88c13f93df9ba87816529692a61d815dcdc72abdbb0cbed16243bb720ebcc6fe679bb6af1e1a361eda116f01a44176eb950b9364c11ca10e16cf5952bb1e0fd5c48868bac93de986e89c0a4d50c99ab0e72c3760a5ee9888c6d99c0098e07c0d25b74988e941f74b00c6e53803a71b0f79b967f8a999ac1231486c12e5cc70e555dd90cf9c77c56ac60a31c532945db6e6ac5e307d7f744a2a7fd43b9f15c83189d309c4cf96c1efd5defe2dda332abe54f91826398a835e4b9f03d8c7dd49a28affbf3399a03945dea07ec1ff1d462e6ea703937f4ddb6312858ff83743b9ccba1a4fd25067b24aead7f0a004a5915a9f2975d6377540a09b6eb615ad63588d4627234777a5834734eafdbe333a3773d58a836225c000ed84f13606ab314081f7c544da9f05224c5ef6d7b23e53bd4b7c1e588458c1b303360c2eb5a41553a8bd497a0264afe2054ded8d9b8b0c8d334bc4dfd886a25825566c6b3eeda30505c64c45edbfb66a4b3e5a863b9379a47f99ac6146322ee077eff3b19463a6f3be3250767ce403eac8bc059386c56d945ecd90991269dad2824ab5af56790941a46753ada752e973b321a41e361f42d9420b6cf47b7d786e4fef489ddadbbe9d655f4756153a23656e434c2edd95e9c2bb3a1a63b92df71a0c66aa91210363881471303063e9ca7017d273098dd401a753f8823c5daae70f43fd5e439bcf8debd724d69cf0e209acb7029ca738de4da33044922d869b887c0b92dd96df124c390293b7fceb867a579a13cd15ed3174054332db6724fd1f14b25fd3684d1f8df468b635d17f7d12e5b0dd1d1673690a1e9ffb42d89c1992395a9144951779067a6963bdb9b39692a7d67597bb4376b558bfed21ba48bab309998df3756753a4d777eb6ac520469cf527d9d111a01ff9d980b7a764e6837e942fa7198bc532f32f8316da7fc5560a7b27f531961fd24a203914d1db54b01ef9ca07edafe9f230f6ed2100a94bcf2251921fef2abc3685079b35fe98a8b8761c0b18fbadffbaa2372930556530d4e90f732a876f8e7d03daecc52d217300248174bdf36a4a79d5b5aec2cdc6f94a9c08f1fa59a466ad00963d5e05a3d9e74a728689887786b98bd5157650bdd8913befbcbbd8c96c243e87c6567b27088e1e898ee0297c425162b1cae7e300018a5d16d1239bc0e358c4255883342989d5a436e00126e6c30b0a44efe704c0281216877c08a5383a4656de8260802f69adf4173989863f54ac2c9c3b28acbc334ea7e8650dc75db33911a18b8d14f21b7e4885e01113f640a4fed5f4e7952f6026ee0d91550240f58c0fcfff355fffa043e92a885a634c77f2c1265f6aec57d6078763b0e31ecb76ea9b2f991e9bfc496c5691119102198bce5758e9e12d0d423af7e2cce8ca0735b57a282ed610170b63b4cee3cb8bd32d48f21f5ea26192f43a00736e1ad4b41733a2b2bac98cc756c9c48fcb4cab33766897de80477a71dbda8cf2f44aa8750630101dac33c99af782cd3cb476fee95d0554cc1a668a6c4e31603d10f321bcb042f4a7651e20fcb341f007ecfc61b7183ec2ec1a9e7381f3e5d23cab6d8a82e00a0480574db637632534ec43a23ff93b09d95740c664b5434e802ce2c789c08c10e17ac832396553991fae6bb4dfe3b8bd11253b2972971a075d6c149113b768d798400a715bcd50affcd08de84c1e2d2484f8c452d28609b47d259f8da62cd1323a634d09a70cc7f14764c772023dd900527bfef07e33346916c9da05998b0dd7434c1a26ee032bdbc65d0dbfb928dcc403effbfc5ef60698c4d9efec3ea3f896cff5ba9a8a1161b43f1facbfb9be1b98c72fc4717fd9bb6fd59ab8a5d76bcb746f647df9039b9027add03a40640f89b84a280a6eb4e1f3fbd04db2b6c2159431dd39b216fa080438104211860a597ef1deee0376a4bcc5bd4178f334eb2424c673f38db9b5614a6591ffb70e7c3de557213024a7ca898e8b879db46f9088dbd4d77db395885dd5e5f8af719f9c7d4bd2ca40ead96d00ae28045821abbca2bbe9991a7d3becb18c04cc83d963429c22081148ddadc94f7a79b2d7ddf96d105191134e7c317293c01cb1f35698f8853758bcbc7090f56d516de1bcef26283831ac6fc7bb53be790d8a69d9355145ff993afe86e9868319623cae7f77388bef95eb7ee1705e0b9b995d8ceb2f78ed1428774246f1e5bc40759eaa7bfcceb8c65c850f5ad210bd706e07b819808af7fb93a10dc0c47c2f9e0b27e7b4c3a2596609e2e6cb24063f9539ecc56e18589ad28029687f562c1a8d73b6bc87b357143aaf9a851ff85a636ad08e1e316b19a875224f1fa93e43caf6c41d6191a6ce9f3310cfaf3c7497cbf5ac051d28b04679ff1db6e8af2160a58bad8d589361e474d64c246303cfeb1a0056011aa76ae89dd08a6d2ec43dbd1626498f8d623b8d7f4f8c7cee86286be5ca03fca1fe8d812cf618cb3b265fffe5e88fa5b90b5d1efcc4bfb5c70956ac49ff52d707533a9001a66160944fe7babf9690575afda6fc6b0695baf37d8e615854248b470f586dc73beda5f46a4e40babb2ae19060c52955e4ce7d8aa1f25b1ad8b6693a5495be6c3554691b6e18e101c939936d08dfd0e46a6ea10897ecd97b6cea16c6f8ff5826a9c593d711e410a8382be6fb69e45eabf5f526291d6ec38d7abdd8318e7c71a55c41d7edc2bf0639d42f6f1c1e8b32891f96085451cdcd027a724e92fe3b15f75f000cb6222a4ea6a2406701ca300e41034d2b2114e3c380923affdd2e9030db491f5aa2971c04c4b90bf8866deeba26e3ff9174767e2b55005cc7aefc4752d3f420ea56c07925277a260d642f9f0aa63f9dd35812e2f832aa8dff6001d035a4995d1ddf1d375f6b226dd6adc91335933ec6b33d4965414c12d63351160cf9ff89e9fd758ceb58b013711d8cd33762545c75bc535e2dda0e380faedf875ddc553f5688b3378fa392ba835f535a04d5a8c8e03746641acdb68a2ec7dd480e70eb18c4c8074ca18bd627f8d3390095abe07cdb5220496a6661a2666cb07bf3b0a773580f4f19add9f84739f511223e2e9c75641e5f7f1628cf2c4f3c817501584612d8243823e18a28161cbb7e3be6c2aaf3893441af57ca0f730f878c91ae3d9e6b15f07ee975426a95bb7193427b81016c63a6d6b58931eb110da2d68f6e9a2757fa2857661f58b4c0365b99e21d9d82e6524eac9f0c10084cbb0268358f0673902124694f50bed38fa969db6bdcc77ef6c6fc8975a667ec605be55584a3b05b143117e8e363628719cfeb0cf7afc2f9033acc4cdc9bcb01b6b500113cd7246dc3e8ef105fd79da476e7e7732430458a0ef16c6e2d5b51b77412020eec341049569a6bdf9e82dc07c902e368ca220746c243dacb08a2da3c6b371282c9147805a7dab2e3cd60173d201448e0d0bd5d5c355ba6cb7e39f2bda0af772fc75d9b20797634a50f3ed16c74ed6286623963323f03710b17e11395b0e70123c3e309e8ed6de692aff96648c416c85dc1822807458985f8efd50f0c7f520b5dd3b0567b8f344b044cb1f564caf1e346ef4159ae4d4ed51593d30adecceec3b503a4a347b8184140f2046d80060c8c8071698aac7c59afdfb8487a1b782e41b2df6d79a38e3ae7f326a945486122bfc1546b40ae3d21f6adeea6fddc9ae87798e96b7bac50253d2b3271a5642e989b49d1c72b80167a4c8d15af67f3cc435169fa47d2fffcaccd7f596306434024d163de83de664bfead64bc857b1c8ab6ed4f38edd3ee69748a3a206cdaea0809e4ed8f5f82063d10cf3e2db916a0f8de3d0b0c07ec83587725baa7b210afc75417189c5dfedc767215d21a9a1b084d88860b8d4e0f691b3c03b04ad47203b5816d25a75c3d22c52706ade8fc69e4f9e564d05c3fc592921cf9940ce72526d8a6c32859ebba5cf0117867c01a5c3f383c629c2c2892f8449bc8c5a9211572a3cddeb271921932ecca0b50e0c6af681fe604ac41d924b4c4a0e098d7c8f824f20c9c57dd7288ca1b12d6065b22b34810fd9777dbe1003f78852dc567f5814226d4debbe09dd7893ba0bf077735500521a5d9fe258834e3ac23e8554d3df5fad736e9a01782c8762c75aa048a781eb6d5b87be6454731555a36957ccf58af1626ef3f952d1e78b92c3dbac2f04c47261844e78c31f48dbbc57d82193f4ea2a520266f82cd920e05c1b2032935d58ea4ddc0dd0375af765115e54552a68c14d0c4de3fd284ef2668985eacb630b5cdf5e69bbb70210dc29807908584d8dba91713b1604090e052ff11d0891b827bb64a4d6916687c2ffea29a5272150b27fb2bc852423d11af674001e911fa2fcf2fa2ef8637fde63102e9f9efbf00c8b8d929ee7b54ebb520f28909cca4c1a23885453db93558007ef019fe4147c100ccdb549b33288c2cba20ea1b9afa4426de4c7101c96ee9d2b65e8ad496577b5b82d371814105ba90fdb9ab79a20ab34c5e1e5e43cd45f4e84d8d3b7cb4c88672557eae5a6e13821761564dac1cfec30e9f712aa85ee2acb0bff1e9891981618369ced7ae316d4c78e8a203c59f5430759818d0c6c7df76da76b9ed711c2613f447392d72c6b402b27910b2a3dd11bdf270c6ba18b801bbc587674a1c60b5c65043608dfb81c13f6578555d57829667f4fd386e2879a30627f4d10939da08ce3fa8035da29f3023e6b6ae5a55b79d0b4ec7e85a6d1b4f7de12c355f78fa98121ec0b247fb58770fc70fa406ed56d42febd2e097120051aa91acff19c14b24b3311946056ec2d96d16cd621d04fb3030ba26cc384335906cdb352f93f4940690b741a2ee782fce35d3cb5b4427360c336b7c0e75537e3e78e28ab139f10da0de43a86dcc1bb41276ebc8f6e1bb45b63785ed7ca0f1d89a834bc016798c15e84b644d1f1a5545a0da42e75ae9d90a561c0ec4290e68d0f9ab80964f7b2bc9f063735bfed71946aaf1ffe315fb699c7002b3a80fdcedeff80478bdab861a64b3dfcd8e752d5cf0f19252420065bf11be600d17440be32db84c58173e9f742debab351f947bdf3435e27d8efc2ef9936f933113ce8f94667e0f4ce428f46e280a3830151a634841771bcfc1d6f80a5dc9e978f3e5900b63813a5ef83c654cdc2cf094713c70064af368608a2b970c26080e0600b0e856c17d396e5e351368d0cb1cf730ae892e1d1c79d3bc772e97cfcf8e7d71ad1c08967c7808acc94577af41d8b3d36009cba369b7fe394077e383ec252601ee04765bd7b214122fb9842f4388119d06ee17bcb17c90a2edee59daebdd7ee2919c2cc50ca21f9ea6661e9989dc3664fee51a5d8fd38e3626d63b77f5ec5a571fdd53d4b02b4c39de0b083c6e36c8b48d12eb0e146fbe5255c219c86bbf803ca8d143cce36114f03b500a69191b9b5b39b9f711ac9f41f80dbc11b28da884b9e287ba2d4fbb32e6c990efb306da893349645d5aefbea3ac605543c7cb050c5bfd82a4b6f69a6fb9896a247a8bf19d88707d024c6f08bf23b599f642170ef00960f805997cfdf8a3d863d7a591c4e49abd7f8806e8a7631ada2a567a4bda6048184a603628ef304f9cb6f4d8c75cf0daeac88938e05cec171cb8351ad301bb67d1ee97bb895095aea7eb198e046c7e5b098882831edd512718a533ef265e10603fb788134c56b77ef1b7136feea03076f86620d23981f49b3972e3408f04941d9d876a7e6e35dcd17827a47c65e093c92fbd91969c7bbe2fc605c2fd9f3d861b95115a7ae634b2105f2f5cc8148bd153dc46b59269e6362346715b25436aeea9889959a66c6542a70e5fa9a23cc4328e722b6b101628537b8e2cb0b4a1e04e49c614962343cc0c457571fd00e82dff66e27c0ed869a0b220a04745b904590924c4cfe07cf5673c2f74fed1cff90f47d3b1a7f8ac7ee64a349b17d97c8a8b0fb263c5e56243362d418771c941788ad15b68e76234ca9c980fc688cab5a7a833b838aeb592ba190e9132b6921b8fa95a1980507bbc2cc2e56c5c990d8e1f1e7f9f9e2c70695bfac5b65e071a702cac15e40cbcaf696ec2d3525f4fa13cf2451ce11a0c5ecf3567cde9d2c8e9666869009c17daca0659e2c31e795c72b4f4caa03ad512a4ce851f05a52cc4cf13ee76e284ec581d04df1b6f5afabaecf7dc097aba956f8a1770b0208e4d6bc41d7b943fbaf0903ad86e132d29a76bd9b963ebce0087f1896f8cbf0b0821f9558d23223baf9d3579090e2e87d30873e17ebbd7fc6ac127c12ded356e4ebcdc5b2b0ffc2a007f89926d6cf7348177dd37b8b52283b7d90e59f5910b23d89fc6027c7baac9743e560774506a03ec8967231794ed8ebcc4a949862f96fcd148f4fed6101a22e429a08e29ee1e72157ace04b5e5c2a84d8c938e9d27c5789420ddf030583f6b4af66d0dffc0bdadcc02fea6a270c0af2d3a8cdaa2cbeff102f935aa6b14d57af6fc4ffc1ef7aa88711fce62fbb3c0f1d73d3213bd7367eeb8722a8787f792d09b062c0d1537816849f3ddddb46994457c268bc69e05162e2a5217fc12304ed8cd45a3e47ed21bfd582c97ee64481f4be3cd7e55c0191005e335aa3266ff04989ca5dbcf9128aa746fc37787a2dafd74e9f517d0f8a1f708a27f1eb3dbdd40e56e5c25b70f744f55ae8ec6d8ef0f8e57e828c8d5ed9124cfd76ea8d4820238ee6085ef0fad4b07d3dee925a35e2c230a231ae0e53b3fdcba31814ccfec2a9487827ffe651d3c462cefabcec4a0f37f9717d80f5ed29ffc69682d229732ca2d49bcf55c43d0e30a26adecd6f96513f0f298c6a41d3870373daa19d4312bbf29325b91abf58cfc8ecaa2e63589b59bc343e060b34c877b62eeab9d131f5ffc3e282283643a178793fbf031d9d55464d436d2dbcef21f7b6640ecb30622ce9e95846077107cac13d7cf1ff8ad38875aeb0909d0e6053e1a9aa036b1deac77799eb756b344b773c04ab03f1de41c4de1561b2767c0f750ed379aefa66b3d7e801ebb8495de919c77137e8940a7f1dd0617d22d3d4255156b6724a95353ad02e8f8f6bf3af6dafdc6d39a0d2ba858539fd4c5771861c7ef1d3d9eff37312cdecb4a3689da796cb36b27175d053443f458f2d0b0b34f14838ac6d69b6dfb6b76e5897b8b031ab8038f4a49ddd87bf1cfec73611e51931639c6ff1ddc2538f9af9e109a12e98c1c714562e287b23583ba4c561e1166197e9b189e7a240a0feae0c51399518ef630e0f11a11abd1b90c05db1068be4d3d7eaf349429898f2763e5b6a53b6cc1c458fe8326e7ab7f5f1ba148ebb8e7aac1f8d5cab8c29e2c58d317796a884c7b7266d673c9e69aa5c0722cd1a0694e7465bba72a40e47fb78cad9c251a93751eee657988e5372182e91268f483c6f5dad53e2a38d42ae6f7dadbb68900c687c26e39a23468a5682374bff1ca10031bc001dd70cbad92e2db48794a0a283ed84d89f83de81421eae92c540ba84fe38b3bbe2b424296ddb3a19a87d09226acfdc1cddbb9cc2c7904db07ff37d1d1d4bffdf2f2edfa2d513874db76780fe024d2a6e5e91ee01188ca0800a7d7862ad54e075a722dab13b7a75de1aa502ca34ea40787c49ae1dbc048df1eb7ca8fce0981392b9af8b453adad8a61f857ae6ddcdc23e5ec9f111faa5970d7ebac18857cd37c0a5facfb937663219d7457962da570b526e53f693371301c7cd7c22d2a9184dad977137ce6691127c589f1ea8c9ead8bf444a4493e36fc63bc79ad25442112d492272397d87846738db884d0341dd4988168d42e5f4ea90abfcb530070ddfcd55ce077fa686fb76033f4f8691ab0c52efce33e7713ec7cd6130f8415411c532ab4ed25c81511fc36a7b922e49f53942b719ee7ff6cb8341dad7a4ca9acad2ece99a42044244f95f430c61ec2753f531b821f88c7796d436787eda0f1e6a29168c2b8fa53dde135a01fb6f4bdf84ecd931b2fd2158d005c05b1825f2e919d43f8531491ed7d9a29d73a073e22087f0b2ebe52e7f9d6a47f020e1471db1cc473c22575d7ba3c88d3c27d2338f4b9484c4599e48a8c15491c9e11a76188ca6e9e6cf8c8f33fa6e898a45620e0a3dbfc4e5e0d435df02b0eb30ab2c69fcaded2852ffaf4a3cdb1c2682e7e59f1a363dcc4203b925c787363fe28094a286daa26381fe4954e0d488dd028e495b0f762ecd1c759c9b3116e5efc27b908a4aee1f340e491063d2d672edc4ef69c291bd8c27f7084a90fe4a31c6acb2bb64eb350dedb8f109e8dd2b5b57e14438709c7f63384bc9c90c1b7ae6e23dfd2e5aef13146920587d1456bb1f18e7677650afa70f524f2f29f818dee1e4d117419ec5fb741020d5ccda18c095109852e279e53e64fde01d1333d78feaccd836eb32d74031bd94229ab4b5601c23bb78ec81ac767145b72e30c7d4177e21cc023622895ee7525a2e913bc45dad65ab3a3433ea7a152ea5cbbe468abf88078f72ffae3e0b3a14a3a2030ca945936f4ea405424faa1428e3fc5919ea3624fec354d826e39898248e934d04ccc86f0705fd8b7c6a079daf6e575ac22f4dfa3596a7efa5f9000e383b2ef575243225d0a92b28f2b450704267475ba6d0780f66557d1b9652208411802b9cb7dfbaf2cd8603ccca29cb5a9c24effdfa69daa3f34cf8f008af131ff873b103495f077e71c554a6bd9ff79efd554a8f60518d8aecc8bc6220c38e2c65d0ba1a7a36c1b099f7d88c98c90e2fc06ceb1d370480b398722639c204afdee0581c417dfbb6575d258c65fb38c850d8686f792cdb486de9f9bbfd6dde4e717ce6261528f89a70c7979a43766f2e8dd19411730360f828c0d95e79fcb505ac47072a66e44958d8c24e383b1f8bb1ef361f8bff100b1bcf255ea66fc014e438093565680b5828ad143f176313e22f5c98c8336cd4d6195426eda5614ae834555fa0d58afc853f2c644aca2f41967f948979351f038f0e0df3003269a71b0f18bb2e657d76ffd1fa275920fa86a64e831dc6e55b22daf0bfeb0e78b4be7f48dd7331d955ec4be658d9f4260ec7a376126256395338748d1b27255a59c689ebfbb4eeaeffcbd0f4e4be5863c7176157e4f6710c1993507eb882658648233a6f44a0c21a7b01afbf3af9c09c236db3491615c77720b419df5da3ff3aa7a5b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
