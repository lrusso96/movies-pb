<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ae29aacf5e60041a5f4c0123322e9751972d37ffc3d97bee4c5cb2f1ad2847e945b478dd8dbd88375db4ac61f0c3c1f07e363d14fd5f0a6a5ca58d6d986bf3f3a603bb3c100e9f835c81f241b965cee219602c39e3368098caa03946195b2f0c9149f2f9b966fa4f4f91f90445f8f5edbdb81a50a0bf255d7b5b0320b3f9a780618a5ed59087a7f0da43f850f7b08b5fddc314b913b7ec031728face035975bcf65c1c59ef7ff0aab6cd647c3542c18586393ab3965db4f0e6a7b9504d6929706b4e33ba942dd9e7595b083c896d9b8c0f210bedbe666ba9537b271e8977c34ce0792a4fca6f966917ea0ad61cba91108e0061b7949bdc2cbc26ab60304a38a7844f51a93ba69c4383ee23d5e7be695b8257d96b2b9c1701c0e59f75e053fcd948c05042ccb4cd1d9f79e8931bf9c195de77e1c5e63cf7c8451dac453467b15c53899f5cd918d3376ee63ee04c3c1fe7dfecdc34259003e248a9a4cafad996911ec484ae57742815d86ee53b730f3e76eeea73eb7325de28ee88787ae92504b77c044cd8d9f11ae248c4d12069970defd66d88dc556dc9a66e73b5b3b6a7594ef30fc66d082c225edad5deee494805157cfe853d6dbd9e52c38c75b17a296de4637ba0d387a2b075f44eda1ddef0486069e92a7d796ef30626754a99f249212e67d9f137189677da36db42b25b58f416984f7e135a122f999b65bcf213dea32dc067cdcddd8df35e3beec1fc1ccea28c85ea40f5eeeaaf32b2a01c1b6b55ee4e662d14f819b8d3e4930e9ceea5c204a402eaeb95d2bb4f4938717898dc87eefcc836ed3cc67a499ea966b283ed73f596e4d554407528470b7391a2cc37fec63ffd7f6d63cbd70bc9318a86bd1dc8cc12ad722a6348a414e9635b45e39de3e98a86852000914303f9a3f2f636abe617a553df089271f3592d4e4bc753ad96b19ec86d98b880cfa96b4a7e0c4f41be3191883e41d86e7c8e40d6a189799cd1a2608c9b35cb93a2a12eecb5407d032ab95c0a5def7fc62af5e34f44e505170d7cb2adac8802f904024863cc7849eaa9b1378c16f03009182bb5df8ad53beda7285014c3f8a4398485d9fe9fb99041f973d75b114537a13890628403ed50a9fa27c4e2ad7f0707b0bebc3edf7f335f7e3d7e0221c775763f5b8419158f06f0034cc5819ea5a19f23bf0912a71d82b9dd156eec8e7775d82c1a97cbe452d307576dfbdec9f9ef80aa3803a6d3c03a1d7a181accf63a545b0127b48033f7f2123a53b91a12fd97d771bbf6b09b4f1cb30a3a6eeab4c8fd03c4ae09eb9fd8c1caba4f47d9220f8694a3450a3df2229fb08b0c94d8c49863ad03f1a32e34c086f3be460929de47f03d441a284ad75eb68b3146c156608127375c39876c4460cbd7762f04528794994797963d92489b2ce6555dfaf277a00a19cc2287a7dcbaf4732d5c5206e06cec02099d0c696d9b1ff271a8269457411d6b481c2cc804164b7b9fc0e31c4f1281f7811bd798fd7114ed1607003e1e253bd596094dd0bdbbc0ce44c403517e5a05d265b57ba5c78730abc5105a915f948cb7c4d4b0cbd5fe0ddff27e5d039a3fe6ef256a5eafc72282726de3e5fc81065f5462db2a5666cc35efff1a8c3e29e19c9522c89c72dbc784f913f576f15c81795955b385b48d6a82061c2bb01be6da079ecaf739e5a4caa8bf595dc9bf84439f13b0fbb7e45225971f4cdc55708c29726e630e960441747538ade276470091efe210dab7f5cbc3bb5a5ec0561af17474acc0b6d1ae09b2827f7fb12b128a15b229b376a8ab83f98e77cb5971ab76b4bfdae6a7a753ae48c757a8facee71ba6106474f9463e845bad004304567e5b703eab2110dc55333f553adcb9de8713fe113e117f5bad5ead292b2ce7ed4d62900d8a15db9c888a2e9d948d52c909cc701962b09c68b3fb809d37509fe5efd5b0f158e2cfbd0dd40f9ed76cbaa7c11a0f332796c73f05fa392c5bd4cf5971e9150c157b0d71f5e7cd8e63cc98c327c368e15d2b0674c942212521811754c255e75e4c1d03c27107b50dc0672cc76829cea57efb5c3fdcb72b660acf8d788163c77730939bf3805d095a422564ca177a6bbbf6f31ec3785424f53a99a1af36268f27bcf89f28d2fe9d904c3b16d3d0913594ea8cccab7e68611a6675ea64914d37ecf776b68d181d71cdb1dc983a4023ee26c9990fd893de3a7861e136b15800b59ca0a082aeae6e5745d391774607d0a88b866707ae499e3c90570a4b53f5131bf0c96f197bec26f50595ac68971ae1fd38fbc71868948994f2420632c16ca07a9f4dab2d13257e476c98354f9a775f7bcb7761ea256f3c050e6e13075735041146b9348fcf0772b5d05ec96dc3def21a83e9fcf0bf9c2e8dd6c9753da0dd1f089ffa4b82db60228efe01e8f695cd10d36dcab63d030e655f88aefad902ebea5a3ad47131b7ef162dae02a011c15e1a9d089a1e82e59bdbea37d16188a965aaaccd07e1c33ed27f1188ab797180d11b63fcda63f3dcafccb99bff3b9799a744cd404b25da65bebc5dc9bce969fc5451d56636ec6b1d312a79ba196b3621aa828483973e3a9be8ef140915e37df2dc1c5a0a1323a5fc50b0a76172d34b5af28366fcc72d4018718c404a19a5dec7631a3527824c8377074d2a42f342aa042270ff0b702ebfb52070147ffe09f45d7692acc638e376197f2bdba08e2de02786a4709f935a9381497f35197198173137d346bb5a8abb295890f3e78b2a1906926c468391cedb08a23881a5785fe844f982ea8bf33d5f2873f19e4c4f1205d2c11018a9088cfd9de74149ac6bc777466bd8506970f87c3fe604b5a9d2e5308d703016d20ba9b167a32bfd7811b0530f44656829abc9cd6f2c7242545e4730c864c0ff937b061754e9109bbd4c3e82821fd0785f81b01e4b039608fa3e3b7457ef892facba13fa45f6a273c8ad78853e03b9b99a79fcfc82fcd3fff323cf53639b4565faef38daf9943162c83f6574d44de4ee7aca92f6c0c1b767b27008cb6775eb7cc99e4b535a602f3e31879c82f870d9a701b1e9a103e6c6e8455e53e4961f00483747f57157faae1e8ced262a7dbc8bd024c6da86e7c24c8fc650dff38941d0b57c139f1f1fe5801411a46fa82a26a83d75eda6f857850bfd047e1deedb4db8981e3ab102809c4de7bdd53b39a3977c46f2328105e01c15ecfb50e010c2608f603b6e833dfd2fc3d1fbf2efb9f67a8a72e968535312d753b3992357229ab6ff2cc89187baf2077f2d089ecd258c0ea6830a5f7c5530569b9fdf4fdc4cbde2b184da1deeacefe95efed26ad28093bc9307584143f63ead5259ddf85c0a2c56ed2a8d0353a3573fedc752922e4460977d5b87ba377316fd4ffee7794770c6c484dbdbd33a3aca5588f858e8b68d882c3764319c7ef2cdbee9060c3c971bb3bbb7f89f4331843834f0be0cdebfadbe4b45a24721ee5b0ecde4efca2f7049dffa7673619476eae1fa5a7de397ed8c4aad90610b89f3baba34b66d206f2595e4fedbb4cc46ad17763f302e03aee3631ee9a0c9ab532748e7a1693264fe49705ca6da0bd200a9bbf69e99ab649f264c02640643832d912184dd8c197ed532931de424dbac7fafc840719f5c46eb11efed4ff2bc3386c10097d6e8a80b9898586cdca0b67c3ec198b2264040a2acc9ff33f7a34fbd226dc3f8eeb461f446764c59596f95e19a2e046bdce729887653d341f2975e88e7bc36f766579fdcccbef445d29c390f6d55e0ce187d578bd2a5c38c19b9fbc2601c0c5d5aaf90d1f3c63295efcc2773faf9860082d1cb7d4f59ed0c2197ecc258bacf1cd9bc5fd80639b950989dc19ecb35145076e340a04f3e9d3be4dcd8af2099e8f389cd8e811dc7c1ce602c09aa4d7334c1427ea8e28457e3ea6013ba087ad54d8900e1e8dfde6ea51c580f9aa029cf85da4434a98c0395c1b21b6518a48727d078c86a7f96d7abfbfbcab1bc3a1e213e74943a7d33877bd07fac1be923e9e5d478dd540b60a5995acf753bfb12cc121c070a430c04e98f82abf5a4ad30f1544963fdb2aa6ac85ec73d4f42c8f4734d0934a55574bbe8dada7c9c161c7b75dec61f154325750677265d4f2e539c0d9045494ce085b389b5ccdfd4e72f501095e4a95fb0a601152abdab401c86fb62501b5ce300b42a861995b3b05cd628acbc336eca5d2e9d548501ebd5c304ebdc2c136513f6624b5c32e79f4b986001bb3d53bbab082a3199c22703545cb3766bbc3630ff857d9ea99fe5cb8ecbce46e65116679187e9b0c47203cc2b777ba633b18a1f212db45c441e4907d93f9f21014a0489e44282f6445d1e1d4c2aebe5bf8a30ac80777d7b86a5397a936074b93ce9028f421c5a873d27496a5730966e78e1bc5f8075f4e04124cfe6fda85ece153be455aa0ef4f82d7342089f3583cacfc5075657b278ce1d54e16a8a6e5790e6248746c5895aded23335282b34176a3af4dc1f2a722b534c283e871c625c3ee9048cee06fb0069ca51db9ec16520fbf3fc7b68906c0cc12f60adbf2e74162a52588dd6807d86fb5c4071d4bd46e85c9cfd7b2a97b57c403ad2bb5e80d13edfa284a949af112d2db899522e7ee04e7a0bbefcc4f4eca37f0037a15adfd4ffd3e6248d5f77dd31f2f8e9bfdea1dbae9fdbecf162cc38855305ab4310b9cb764c9e604390853d5965745dd57f27c8a3cd9f91d0c817dbe9a9fadc46000c6612d5f52f0b1bc1c6d5f3d61835385ca8073d9deecde2f39b3049d7a953f104c8a7b9ac7f5e4a822bc14df892c47a1c660fa1b29186f1e1f7599ae470469539b846a253d48afd65f8824a97e25e232a573a174ea3dc3a6b5d468f92d8acbf6d4c19b63aa0f2b4afdcad94ee8a16798bf5785d8d0965f7f68514d5d8422f341d024ce831adaece438be635b27a69218af187a893b9e1e85b9090c4e3c42c8df98ede2b11ab05b8bce8ebafdc628b2dd528c336d1fc98c9a6f2e55accefbe66256390b2c033f1a5133f459eb10688aaa5146d0164c4a2e4fe1ad3c2c56b1a591c3aeb7136874ea424c2d8a185a3b5b6b744d6175433beed777a6a3f77c224fc7378fdb7e2f1942aa76dca9d9e2699c9188a3c97f2821d93f83be3a7e1ba27b0b226b6373f6a5c566be2ceee89a52f962bb94829e283779677a3ed1695784d709c27201a7a9629a453d80a8bf363223fa17a4e2635fa17f3c9daf169e42d178d53f73f463967a7c667aad4ebb7ce11bc8bbfb735ff968a3affcdfbbfb835de44335fcab87bc2d12ce9f03d221d0b5eb61c73243fe5024ef10c482711db23923f62917926d2b16555b02ff26d9f245f265afbfe447513b6407defac4aaff188c3b1f2256b2d05139a61b2b34da28349d54dc3ce03c45740dab7f9ecd985b09d2fd4d07e4d4c10c77499cccaab81a27790e86deab10bf495118c96974ca816ee9f8ba6312dda9cb44b0a331770bc4bf0580b7f4c48b36b896933ea11e6e9a1d0f30d416138214d3902e21cf4a0de3a7b4645ff57dccaa843cdf041701de0e4df5d934e3e2e8c1f2a23e716d35f0058ed644ab060e63665d9af7e21926ec3a81cc585e90f0be75273cf4328880a0e6c209acc669665154e8137b00b0f27008dbefce41ad037e4012427d7d7414eaf102e5942ab108b774c4ab36070ab1232cff06d794c732d6195756331f81a75948532ddff701bb2f4b36637aac819d9d788b29c80cac0c3d1be981175aaf3027b6ebc9e3894a8810865e616dcf0c7a55d913c5d3955541a2ec7dae8bf448afb9b0e3644c3bc5b606effcd270d54d8c3db9f5791159e2625e410606a9535b8aaa8f0589d7af1b5b86d706c186c9854520c2995c8087445f073af611591d88ca429e8bf6394c492589ff3af7593cd49c5e2c5f49c2bc5439361f1c2d54877881eac1f828ebfc623ea510f7ba770f0cc8a3e94f9d6c610494c2ee33959c9a0b3c5a1efa5ca4a4be18c4943561c08cd2af0d704cad37aba3c3ee4b578cf433a5eaf9c4a276678349ec63e39e7866b31d6eb74f8f35d3ad358cd8b4a7f31cd4c4498146f3381a57f53168a6950800d4cc1181f5d955fffc33da29f09255145324f640553230c64928e6e30f5ee1ef2d5b2d634ac3de05f8d8c17a129a6ee23ed02f88ad4c1ebb7c9e1a9e82558f7ce14dbe0005e0be22fb94bcb8c014fae71d2697027cea4b4b2d49c63171033c254af6d284f6b6655a8a6892f42794cfecf1982bbb65a06c29cede0805cb4db24c55712b4e1a5b153edd129fdcd132302d5254c5e3c9189e3568b8852f162f2d14046644f6425c502898751f4f6de80dd06b123eac1ca491dbe147a73a3788dc0b009a3196f07218ce7c0f8c79db4873d0c2a2faa8da20105c64759c9c5d59f43f47839e2eec413498c3bad6806fbcf7f3e1bb9605a072eb0982eb20d9325ab7545b22021c5380995b2b298ecdb29962f842b4c3b777fa120a96b8d6dc6c48deb7b0ed738486044ef67b70ac2d28582b31e8096d6ada3a5678efb3854cc8a553c0d020839da91fca6dd7561f2e1ef1d06392563be465073ada44c74073c8a85a1364b5151ff52527e04bd946e2a3556cc240b81d4a3bff5aa3c6cecebcd2b7b898c1c0df331a0c3d781a215aceef6d4275906cf9132d6206b045f0f5ff893f56813f64755689cc743e95966cf7f2c019713431a2b79e5029ea560625ba8102252a6189a44cc142e0b30be34b7ce5feca3c7c0537812fa0079228c2fc305db5e6f01fe42bb3a3daa82d139350d36686d3fda5c4070bf112f386513b66b4d9021478acb70a1395b7fc916173c9fc089be0969d9f00f4303d27bb675051ee08238f240bf1fd9c9eafde4bb0bec8f5e02c9a38eb1307f1b5657252e13d39097d2da66bd99bc19677f137477936f605bb381cd07a329bb0f9131dae019ba0a6c5a9d162a9d145f0ed174b4b0f9fc06a5fccab71e91494248ed2654aabf4e8677aa4f3693ed5522e62fb56374ba3ce5ab3d4b704e1ed0dc68683c284525e7c7139a63c89713e3bba6999d11f198e7c86b59ab3fcab2bc99c0655cd3a14ee0ef70f5d952a512975f42f0ee62d12dd19d8c5ffcc3cbe2c9c31fe08d4e7e2f2f670f432b3e2ecbd8a142709cfd7f79ea1352e60397bc364267a9a4bdcc84aa6a38f27b06c5656ab33a5cc2b064cb3dca7206597f3e7474363427e4c6aa540fe6a310c9871b356a2d7cf2678335704bc28d249dcacd06dfac4d558056f66933d1db22fa498af07c85faec1dc6096b15b1ccf19d302536387cc2f91c724e4774be8a85c04e21c91b06d2477101441a0888ba8374fe64f2b94c2868b546c7a7b44fdcaf4769158d861a398019c2154837927909f8d30f67e2f3fb0c95cbdb4fa829f10a656c78f71fb075e135c1e9f06d66fbf7b79eb2fd0018d604aa2df3d187891bcc2f7d142d3b283b5075b934cc1a2b5231ace83266ea418516f94862728964ae2eff36fb992091e47e21f29691bcb45425a86410eead45d812b4a8f8933691eb0797d55b41704bb671fdacaf9f735759c8f471ba646595882fa60be6ea57b0eb1ce1692a68d99ae1f40380db24f7bb9ca99bdd9c11c42482637823a3316260f48281ccc304cbd85542ee090a8f682777e5f658942f7a6afde4a8acbf26b53401ba1a161996962400e926e68d38c9445e29b11c66a7b3cc5e25b8fabbd7455a9cd6d5dbbda0d54c7e27c213fd0474ad441747163ec5a4c668c6fea431cbf91e8ffe71195f2e62170c31c8a50684599c380b68594271a2ad5f47169047314837efef21d1db93f6a51c8fc61d423bf8ff88622de3417e42d58ebc51c78fdbf34a6b2e187d9e9bd9bcc36a5d75fe7d86172385ebf3619a8f1ce9cf6ac996df5e2875f0b17ea5a06078426ff24881f971a9fb9e5b835ae2fe620481c034e4155d941820dabe0caaf7afde2531723d2ac4341003487fbfe7ec499e96f01c9c5aa8eb6a7ec3c5aad0d5c4a3363b03775f9459d6e36967ba144bd760e2d479814b94c4dda81bdf955912ec823a6bd42995196f5858fbcc4ddb9b0a2553cfda006136be6fc59c5a7efd4e6917df88006b364db529dd6839ef517a07b6e6af8e4865f48b36c8e4d78c5e7aa8187b1960da403a1d2c64fcd1fe36ae57980e3730e51d7b87b3f4961da1c33541e2cc9558ce021eed5020c717309b2bf38d90eadd0c0070872f193e3a09c6485052d069873adfa419bb2e7ab130254ae8cd2d81e2a3c3c8faf5f9d0566c8123985070ba4be755ec2f8e6504c18966514dcf4e33696e5acfb51bf8aca06d89aa5ab88e8186f5679b9683fbc80a7457e091c024b4787ab000da672b42db1cbdce8303f4dc7fd06a7a618be42f32ce1193c11019ab63802c49dcd328ca3f3c07f906d3b879f7d37f3135a123aba8f8eb4db1bd197d4f57344d52971e6a57bc342c07a8e4433283428173da1a6a64d5c65b700b7d6b33a9042a71087b71c609f194f99d6e8e6789ffaa6a13f78c4c4aecde9d7a32aa2521b0e90b37b0f63dcb4f39f747f4866d295e1b8ffc780c3a55e97d0f1256c8a0547c2e9b3d092ac9287aa7e83f10600ee5a96cff8e8acf97df8abaa0c885def6753e8e59a9f3c11be0cb75dbf4519407b8f2cd9f76c77bde6d8c0a4ef022000233b115d1ab4545ca599122ecb6d1280dfcf1b2740316e153271939695e11218d1cccf4a724496bab43c01d608673e093c0ec80282adbc9984c21db632de35ad019a1f704409f00e2b1668ab6a0057b702c4e5779f699ccb0eeeb132faaa8c92fd08bc509a2acfbddc320d0e21d38ce29dde82b9f8c67182d071027cf3a76f4870b5294c626a20b51aad417d03c02e6959cccea92a677332d301de211e7541e11fcc62c6ef61b17837be53d24b0bb6b37cdd626fc483ba722e001faa39ae572d4681e84fb504b974c8041ee820f4ff33c5dae4695d9e9ace3d2b2e67648e446fbbb5cd2ecf79ee8d2a5f553038f339d5535d85943361ad15fc257065c49566c6f92e2b86e0de09a55a0ffdd629248e842ed86f914180d22bbeb2a2de1b29f7d6bb2336bcf268ac2cac00fb2722c496a15168fa8d7a4eb374dfc094544fc1ebff2d329ecb5aefab6a514268d3dd7d217ebbdef5ce1200cd45e3c38835260143f8844dfb92d7ffe35efcb9e9bd1e78c5dbc3b832630717409727836764499cf32d1e2ce650859a246ff6e0202c83431d84dcef7a8cb9c9e27491d1cbf83c83313afb9fd1b170848b4755a593ee50d2356647b3c699b1ff3a8e26924dc3e5d4e854e7bcb7284e1205e5ed1fc623f97b4619c9db0e407dfa1247c9bfaee1427f6d5d05c88d12e7dc9209097d02747074339cc1f1a516752029599f2f277028783f85f45a1818cf907e91c9ef2b9ff01d1c00df644d5a48ccd1616e342f0579eafefa0a38cc3d1672c047ba2e193a0622f03d429d8d6b7babe4674ad289c33724a16fcdf3768d10143289316c82c9f896b4da6429dae770db158ca53b29710f806ded97bc233214113370a671812751edc90f84857e50871346363029c22d1e2f2a206d24bdb96e2dd07ef017c84e8eadfd95f02fcfff88b9569969c1aeb1a2e988166af1818efd5f2ea705376ecc0a4f3931370c0bcb08bb61e484bf159445da96fe69340f8e2acbae40baddd3eb1e3bea08cff69a35ff39e1fe14fc3690c7e8c8f4ec34335da00a8042c3ae3efe07a7a0a01ca1152f7c61ca2530550530f1b75df8df08290fb2fd83c4fa815fbfedf0f8051579cc7343ffc36c2e558f8e47c69a6d5f1c45bcfb65631e156f0f704f2a91021343517a08c2d109bd687b2a3947f9a84233a6720450ecbe3aa69911c539710b3a15d10e3c74f0d5f65991b5f5f1fc9691575f0203066f4e9c219d845a5e0904624d449e2c934224b117c33a354f350fce760d55e0f7a848d7e01d9ed80222a5e18cdbcab0a35ad594a506c90c4a3368163a7f4e75fa1dc2bb23952bc1b1a0ee85939c972e13dbee2a84206f716326ffc62e6529e3153d09f39b73520d3fce3a54564fac7b7f6ff89ab2ba661451bbd441a4bb4f6bc4984b3e4b18df288e96fb1050bbe1a8dc6f80695b1a58e77fc1253feff759162c4ecb2462d3bd3df760cfd8542ec3d41fd29679415de0cbf7ce81907a473ebc8300fc234b096b1388eb52a56f58523903103c9fd2169f60b0f7589d7e648597bf706c9861ae22153d371b8f7c6d5d1b83242c009de5086287ba2925b44aca525634f00c347d227d63638211fca581cc53af516507512bd86b1228b3810c1bebba343d8ef2f7b8a21a77f3d21580812c7393bbc6ce5ddfc42cd1400ede0314ea0db49c2daf0b27535d46808476a3182b7abb2b76b0cd8ce8ec031370656dc4ea8422821c619b792e5d0d564119ede3777ebcd06e55c1c9a5ea602825c2c9c9f278783416e80bc3ce65e84912ac04078d6ccf2145becde12d749668b3f8e13093e565d46cdc21618d52fcc10758d246f09ca81426c5f04fa420ad274171a59ea6357f6ded2566ee9b2be6595156575932536172ff5273ad5a9cfe079281dc11631f25a872bccb3207008542fbc148c1e077fe4ac6fa42d2f55b8f92a01a433b5ab1291452b9c4c5f99357c9f33e42d390f01f03126bbec929ce4c57f9a5f552eb0141ae06372529789aa9df4a235f03c26f07da6bed7d20123e44d44cba5953b4f374bf756b706bf1a793f2364d7fb7a0f9a26923cac395d12d8681c68a61e7cd65f66a537b23d2f9004da2917e1ba8fa188e45b9600e075e2bc0e8415ce34f338713fea1650b72665d13ff895da261bb37976653b07689305c3140e11942ffe3d5a87e2c305ba436d72c28d6bfe4fba3da48c0be69c26c491f871b1f6599810619a5c359240d6aa0bc3df5985ffb4c34401693f4329fb75d325a8ed4c110dbfe0d5ea0a9ee5dca80519a9eb195329a46ed91da776a987bc48bc4dd2be4b21549623e1f44197f822370942a42c46438628a93f651c3919d1b35bc4fee7213207a053881a9496a9e1916f135e67c79dc0d47a6da9fac6d796338c5549a217e3d46e043d1ea520f85f8c673f0a375c62d87add308c94a249a82455a42570f63f2711d447121ba56e9f8bc6291dfebc3d1c355299c564c3897a42d5f5473ecd3455426afa4c5e37ebf070a18e7c6f7c4e866fc3b0fddbf3a32931ac2ad3c5a0c70695a0ab5ce0bbf206dcabcf6e6b2343d5ab453fd6e8002f109b0a9a4805579c3b26bd0bb2cc87ff7f1e419f1ba0bc0d645be85ae1d40b2aa6d9fa1a67efcf5da1ec16d7e8738aae6ce452b3d32bacdf27e8e1ef7bcbe55c585c404f60dbfe177477a7aa9f2963de99902029672172ec71c2383086e2914badf998e445f39bb28e2021aedf50d9b8dff7fe517af94e468b689d53f99ad21e59e7c4af774ef8d859709910f01af43ebaf7479acee6629f3d200d5b2c65ab0d204f58c21c43c97afe48a718a582b3589b28bbc690c310ee738013b358f7f169016dbd0fe6e8120b17873ea9b1080112f930ad0e3478e08a2e8230418fca22bb1fc487d5b39e904803f2a064dd0f72c1512ed07a2c0b6a275ab6786ac9d31d6e5d25993c0a979273ddd9b27c426cf568d7e9ba3e9419fb1307c87a666e900314419856f426f23aaf64302eb9edb33da58f079b370d33a06a9c501c02897804b86239c7f5a09982c59d3e928293e76043af07a4e14be98204b8414a797be98402daf6d022e4bc4d5452ed5bc50a82be472b874f00dac91129f2a1d7c6e38726bb391dfad05cacbc431c18e3254ab7e4049869d60db9f7fe990fcf88f0c242c25a34d612c0b3d39fc981013330430f377d5f32cf03caacaa495957443d1b161bdf2f584fff20cb77899def39e612a76f2ecd3092a9afed25c570b60458b35c443bd98a6bc6d163df56a8838349fc331e9df416eed08e83fb10176ad6eb64fcb87e8d4eb36852b8278a061906f74bf4af4d8b7f7f70c9bed40522fbdd092e9d3b044a71fbda3aac0bd4c6911a5c301b8bd921117817a1b053bccc078836d13cf4d236dd7524ced140e16cb5fc44172b18bc054d32e654afa1bce15300b113650c5a3aba8659068b1dc167523af5939c8be1240e2ffb8b6783a1a2c2ce37e6835c43f727687967cfc65ce86f688cf42174569633846cf9beefc60be6cf4b8d3f64b77e8bb7af79e7f31fffc7b84f5b04b14032ecb538097844f573f46cba688ce283ccecbf98802997dc308651fe9cbcb24133004adcc468dda514e6a4bb61aab72aa0aef15c26ca76bd009f68b739c64c2cf242daba6c4f2f4bb4e504adff7ae321d074c1524fa6bedb526fb38f555c7be09650183472c8f2b6f293cb8d6ad33f92649e368a4d8a2ed0eed80aa2ad24b0beb3c697cbfddeb215810936136746506b1aa46c0228c62ddc2db3ee93f97f23763b67d883320319d5d9c9870a76b17bc80072b73ff4b5e3b57bd999499db80f557f482512c5e640b72c1b3289971c56768614ca58525655b47c03a940151fa93162f2e76379ecc29c35e49330498bf080bc3f71444ce9777c33cff412941af6b0c820762847f574bee1884c4241e52e4420cf8c06eaf8f2c89e96a652844fb71c9304934cb76f1c490826ae2f3d4a1bae8e37c4246d44b43d0a527c55f761e28db0554d266983a5925b8bd27aaad5aba25dbb513b64ffb7a6d944e7d5328e5cca7481cc65cacad39d5e2748cff9a96f7dc10289d02688808e93f8f2e5d36b25ebf500b4bff865b5ad5c52067c1f6e17d5884a329ec3fa8f42a54ae2d6c6a92a48117df7e46156855663fde531c4a9e077c498ceecc5de90347bc56498828174d3c43c56015eb63517951de29482cf06b1a2b41e0445c1a2373e40a812b70ade8d1d2e2066a59e4cfa7c0cc0342620aa8651f6b04fb500972281fd58e51ad9a95034c56768f70489434b30d149e6ed57f624244d8d581ecf599bc550aa0827ec017dcf614882031c9eaeed7f925ecb69d3f5190e54685b63f4b3cc5b647f891a5c328c13d9d2fa164e5d62a7bb7389bc50a0b80ea5ac0b21db272e7acac5f10eb134fc8109ff08f7394f654256c663f318ca5fc03cf95d5722896c8430d836c18c54da127af1de","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
