<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"77c3d3e8c2430cd6a5df21c47b770efbd22fcbd324a2ba95932de634773e20173b79f0b2fb65423ccad07c538ba2ceed920b2475c6b2187016d93d733789939f6bf66bfe3837b493b68e0f72bb8d8b60b63cd9349c87da1d27d8b0e248c93dfafbac874a605ced2a630f485543fa6ebb29bb5568e2f78b79cd08262b787681ffd19ec35007f820e37c4732b4d0ea56ac296a570e58766997ec45ea07cc5f8b4c77af2f9b04fed1d40e3b5fdb7288b42426d0131d8e72b4b35dbacfe41fd4cda3e9f25e41a86e76660366facda86e0ae83774878feaa8a3c0129affeec147dc9f5c4d2a065a72bc91ee8a3f1d2470d4c3358d900d51782756610f103c79d93b5b6f894308d2cb0d23b2b90248ee81bfe3fe6fe4775b522c75e888dd153be8ff6c04951cb679fb7bc68ab3911184c536bdb5ecf5819a4958705a876c664af162967ac8287f222e1ebb236ac8fadb5cc34dde4dfb5593ab4b17bccf798e27c3540fccd171d130e9c653e0daca751d41d53e10f5bc223e770e6556dbfbf94185b66a17d11a2673d39d7090835da6d43bc6995baee313d4a740349f6ec7b941904d3fbc581beb17244b30871082e68e9bafc7592c263e6e3b9efcf4a882ff6c08afcc0b59de7c0e2b6db91eaa1b7365a594107be885edda6f262e648911ae1aa3fafae54930f9faa927f8c0dfd93d31030f6dba6bf4b4de31ce19e38455f0bc075381b359f334fa1636301063b727936677ce7bc1d04a19de43a31cab0f45b5b19b41d663f558804ff975a0f9edf1a9f1518900e6013774a019114702a4bdd9a6570d8ba5ed7208d2398a757db7ab2528a58bf97f1e0b4e9a12a3251dac5f7fbfb347cb3c417ceba14c8f939fc4211a825b946cafdedc60bcb55f1cf66be97ef39cbf9a18283a0ffe472c267551079258fc412da8e33bb151042a082e6bda2f49ab976717ae428333e3ae9e4cccaa73667a7f101cc991d3354b994dea88d3f9ed26a587a37e4cb0bb13c5fc5e500cc14b8b42a4f3bb9697c99d009862682e5142a66f781df2eb03190021a0edf6830292417f81b4497b5dae0ad568ccc658cb97257e36c0ac30e5e3346889bb4482ee0a3a5993779ab1940afce749b38834bf5c67cba744a29cb18cabada28c6dba228b8c1203c9ea7f0316fb7b547831f9e178600fc77b1b44339ac059b5d9b9bb3fb1f8465a56f81ce809b455c7ab564ecff332bf20b8a2a1b8b31b8fc31645e1235cc2334c78591c650d32ad14250bc1ab498633ecfa3b3244cb2e3a4bfab3ca5a4fe75daa3b51a8b1bbeeb99c950d16f80e999517373dd5a3b28bdb5fd8e9d3aba9776942df50870b06349428a0a0e4a4e0913444aeab576bcb97893c7ff443a20e91cc1072535188433d8553ecd0ad73beb8e92498e75fbe9e833a1e868616ed05581688d3c03d5d1dcdcdfe709ec7bf2ea495e443dd40aa8a39ca432f97881e211a711391d9d6cf2f750001bc232e4c48d8ecbd7e79b5fdc81af4a163dbba3591c7f950c534d53ffae96b02aa410fa341e217473a08dddbe518aed746d9284398047000aef6bdb2707d1ec96df6a6b90194b2fc2f304a8d296e280c0c141579f6bcdcef64dba71a95e2d6d5f2c81d913af8b4b05b426e42fab21d92e9beeca6486744922dd9b2b47bd7cb779e347cf5642396eef6f0394f009462b3ba7e7dc5462a685feb99daa95fd911cbb8e6cb4df8873f7841f873adabb2aae01dc1a320cfb4876e2d1bc97089727b7131b69b80b6a5cad8643353498f50dd1e631c905cf39b76bc2e539c43b4c280ac854f68df136d814114bba422d531ce0c974d9dac9fe48b47ca2bc7360bd9c34160a93921eba25f480a201bb06e3f69843b4ed8413ff653d1f46b5d6f1e92b2223551f453ae75ce7036b898accdc05d0067f652fe02cfa4f0380e76b8cc25970ff1f8c7d144f8fff91185e1ebc184b14f1ce55fd0f10de579b2f14db2a561156b044e0055a22c77ff42a6018cfffbf7cf69882bc98855ac5f7589e424c6b6a705146d8c5edf42a946c0a303b3de780ed52cde39f2c77169f312a551b80680b73089c46ffb160967f13096d1364d81ed6d2f5117b037019dbffaa711e0c9afa05e4f3e76ec5245b13ba6b9e69d27eda7c9edfa9e9e9dc88586967fc2c161cf49c479c554acc180004dcf00a5ac52d62782b3cba39509f71b2d4c364fa78891acab429f08756b3e2fa24a53fef4bb238e6bdbc4652f22b3ce5dfae25373f698c63ac4adcac5a45de3f8e477fa68f4f46ded1525ae6bc8b4a0ee7facb5e2a6f70da9619523103f2536403f5eb3429433479478bc8a85b293676dd2a76efa552a63266befa8616795b0999ae2fe444a1e618873f93292deb8916a6dc305560dc30e108698220bcbec5f768bac0e8ff10ecb6783675f0580ccfb8c5862c63416fc799b88a96203d7d0daa170cc95d1ac4d7f93f68fd7eb6edf9c0b3dd11d485ef74e314e3114cb19ca8f1e01ef6dc8a7f07395260aabd1293b91e06753fd2a7d54b06d8ad5d1e0d9a6f7c7115b36707a6f6817039d394c03deb3d7dd6ace27cacc6265d0274ef61259003b8c417f6f43fed771eb628cc8a76948e0ea42b4f040e57bac2e3cd5f3f4ea53fd06d031e603efaf1962129e7a7018d9f2f56e5a575f8cbe55f28b0d69b704a4be7938742c5d8bbd6569e56319104b75bffe64e36bad8019d11306acfef77944c6808c6eca6d6fe173ca7861a6efa619f14ee96bd803090e6d65ecb67c5f44731307521c7d2207f4cb69cf4ef6fc26626a142e75f3ccba6e9d9ca685740a1ea5c4c9a2dc6d6ecfe084b91b8efd45fa37fc0726cf7e00f9ff0fa014bc29dcf750a69847eae31e4ac712c978952cba9277419e93650bb816db6eabebb7f8fa2cb7c561003e818667caf24769aa1e958be6e61c633d71fe2fcccce45b809bf1d11be22912347328296df58d1801bd1654bb18782a0d59c7b60a484fe6adc2ec2af883b074221d281f6feb2696adfd20a62a1fde07e718126c50afc52aa6b15ec545a24b575600023033669e8cbfeb43e3ca6a9b63e470eac222e78368146a59d3864fd187cab834542711e2e9ed657c6581080438046851973060e9030e0284066bac9c2831fc9ec6b015ff84194e71fbd3e10e235f7916aa96f7858d04f5f4663719ddddda123bc4aefea4ec75a37af2208be034844b7a572eba8894017caba64ed875a3ba0f25fa111d94706bd325e60db463458a7b9ebbf9856b7faeb1b1493072badc10cdf9120c0f10ff125fdb61f5ef101c383705ba31ecb21ab289a27823daba0544ecf02f0dcde97ac4d4657895b4dbe0a5bfa6c16f0951a450dee83be29e83abf92572245f095a22c078ccf3f40f3fb0acf2e965fcd470e5156297ffa49a21dc4a0d69179b98648127faa2d5e7207bde2ee2424d4c3b2f83315575337608546cecd290f59d5ae3b277d545d3d9f6bed0a0a8ba91c0b6be9c9fbdc74722ae09471ff5f0f9e8058148362cf2114c178ae492dac2cb35591888c218df4e49d6b3f65255445b1b6e7e398f30876aac8471fb41a43b278bd291545270454594d1e2431898d8691298e36633a57bad4ab3d26cf4c8b7159d46dcbd22d65914250ae68a75b4c59941c64656757900127d256d50625ae5760c76fecddbcba916b9305f6fee75401383a7f7769536085f22fd89b6a86d6dab3575138c3e77e67b1d672a1134e2c054ca3311066035a25c48cde6d746b8721dfcf568aa6d2b6a179fdd1a4dcfd51a73e14a8826e84b1a608c16330a8c035f8be2fb3329f01a3ec8b9ca3f98bf15df2eb9ba2a43e6dee4ae0c65437ad2991645640c4fa6263dc7f5506052eed4fc441c715642309754483ea0ebf1a188930c26cfb0598fb039ca6ecb22f2063654cacb7814cb60e663089ccd467847b2813a7f490b91a9c3fc58eac512bb6b0c0449932ec5d62e6c1ddd7ed9b92c9c58a32b72392b43e906749fa14b3e60d46c1ede95ba3107466d1099e6152613fa2dd0bf7a920323135c610d23eda23b7509288ba4be830e320ecee8ce06e69c044edb4ea7245566749d7d3f58fdf26c74dc7c6f9ffa0e274645fafd1468471be069cc0dcb6749bf6c77fe94ea6486583d741c35f63fbdc945f424f3e4e4c944da4b57f3b4f3cf534b31d9f3b345f690c5ad7e66698b1daaa8113b7c3628a6fc932b757895969179283c7ad035bf2dff649fea6c09b12e63c55a61293c73656caa2b897fd0f116f3938617026ec1a20816bc40e2931234fc2b2536204f58cc5fceee04ec2eedd9dc614debc6054a9efbe29a8a0e5a260c33766a3a9cebc0d83cb9431f54c7f042e5984067ef9228dbadfb0fc12f0bd3771c2936510c81196f6ba44d1c06e7d4f0563636fec64abcdcc79817a95b400a5d93987424abe5ce9d97ea78691f9bef673eab23a35eb3d550c8e5d9270e5c612c6f42b5f6930372e9050e55a2a26def001036fe73d9fcefd91b9ad65dc810af6219824b8bfb50012831389f4716f8a801011c28b9c54723383ce695dc6af851394721c0464ceaabc7e24e3c6305a88629af5299016be675928853ef73d3bfdc719734de8a64bbf4d064f4a0bdd79b75d492f131de9b7ed0db9d5a163165706eb87180815f8af2b8196d5412489530233db45fd0f3ab4e4eacfa2cce14b10fa19566bd900c40f9445a2e04a23eec776fdd7193f2908c7a8d8297378b3593e104acd0f3eb6ea1cef22b3503b0d3a4e3803c1c88588444dacb0840ed2cd79322835940b86e4dd055fdc1f213edc5d25d79732093e49f06884b5bed1eed96c05fbdb4e2eb9eb6ef961adf0e128610f8dd767b0ec7ef1de9e1551b9213adbd93fcda1ea5428b5f73ea5f7e1e1872851a88dfc9cfd64ff39773ca221fd8225b928569473d5c55bc9da90a01230f417c7b6cfcbed14c3f0633399cb0232dd793dd57d42b49677fd5ab1d0fb7ce0f993a66c9e089e5d76a9ffb8b815816e0cf342ea12b200edf9298bd2414544269ca64f9c56f8bf347adaed1e92053ea57b2b010ac99ee73a15eaf5479b0c8ae9394dd7bb65e6da0f9e3424fd8dcc92f6696dcb65932ec88d226707ee2313a2359385adb1b4ca6bb9d8a50977fc5ec3c9a965cb060ed9cfcc1b05c712ef7f847441da14b16722099dc1d4da6e71df29b48d7d0af6a8a8520ff8b5c94e445ae079c94abe6038f85807484eae66125cb2a1000e1bfe3c5076f958f0196fa98c34688029294dfcc585832d4a2769e0ed741f3faad8165d12d95910561ee35766359291e9112f6d19268103ce54664ec2326216854ccb645dabc95d820debfed834ea51f70ab1faa605d51042dc6400a75c69bbf2d736a2548c556297dccde1bcda6cc99c026ac99effe3702661d1666a51e2b3ab8d872214f31b4a39bbfedabe299eb8a47fbb76af5d53326e304a2e42fc9124c9212b0683d1ecd6d1ece1473c7a2c31ab95c8f055645d85f062abce45f4be0ab63d2a3ca407145d2046d521b704d0504ce70d010e0c5306e52916808c10fd5f43d5c0c5ac1b8e73b7e02fcce0eba9c4e2d851f74603c815759f92959c232c3b852c89aaca97f4982156875bd5cb19f068aecaceaadb311ee3699102eeffb8db8792cfa2888a62fd8c64dbdf4f38db6d9f8d95332bf9fdc47a81a64c08e7fd87bac8001229edbf928af13a7c0633fdf7b021b52166c89fc990e6f86b68ba546a9058eba4309d4dbc0879d34aa2c39049ec65993be5ad3ad318d441c7beb0ef791813acfd7efd838379949aafdea4a0ca32a2daa524d72a0541c975552a58bc5a6f9200b103d3098c62062f82e7e726c50b80f79a173917197e5a9f585a2e72df917ce379e46dc9f6210d7a2c8d9efc62ec250dfb09ebc21d20dd98daa25578da771138f4aebf3d4482f8a3152ee30686d266659f8e632dfafbf74497a95ec726f76a42cc27e9de0fa88cd4e6e91d88d5224f27f415bed5584fdd7ea25f0e1501b971bf16cb9196543878226e9790e0edca92ddd519bd7fedcc3bff31d20957cc17d82aa7ee7408c9f68e78c0aa22a10ade69e02935edcaf810c0083a5a5ceeef2b1a5f98398f159ecfe9c58f38ca10084ad8a5a9aec01944f575c7b64df58bab7b6a250ad815f07543e62599304a0bece31dc70db026125d1dcefc08d94bcdc2d1dd6869abd4ec7872e3fb58647a6583a170f6b2d77cfe56cf40a27e0de1bdd3c6ad51896840db318bb50c4fd1a3357eefaedd9fc591881377215d3cbc8b7aa7c13ec9fb2ebdb152d137464ab05e0cbf31900016e757d08f2828fc31fc4b5cc0dc3967eef6ee922f3e25800960c25e2451ec6b7cd7f94c0037b83f262d3446fab6812ee630c92ff7499193139164bc86b443d0ffdbfa0fd6eede86616354e2a7be2c9f27cf3f84fbb7c0eff5be01af336d527acf929dc9c40565e7296424fe915faa327b308f366503781d635214a24be5c822e4b2265e9ec6926b540cbc3f8514a4ab3f907f2af791d9b9f167f72cba2fa5b19382b952bf663a56f0266c447da27fdb1795313580418be050368010ab3a2a6239e3d9b8f518efde6ea3ce038bb7ec64cc30fa8b666c4616cb7754efdcc9d0f9a1c3a67d5b64d18d2795ee9c2421bc46a53db9e53c2c0669829d20b8d0ee81c1de11758b5f72852b36dee1ab7fd655348baa6877dfd50fb83af29a069fafd200b622e73a1316b7277d3fc280e92956873e9e04028609a1f81cd45135a3ff808ea511dbce03ec543ff489f4c4368d3cfd4b01405df265ad377da2246c8674fa2d1b80cdf7c000703ac0f2c78977a4151ba5135fa2c38b5017fdacfdf9d0c15e44d8ff83a6ec851611cae9b4fcf31c8ccc8e411507d2932debc55854af3e9bce81ae3d8ea2da938fd3b13b28d3ce9ba7db2145766ba2832f767680641eaec5447da42a36a3d83c1ba13970d595c30a8a5625b03891a0bb83d6883984d7c59f7867428fdf4e4a2aed03776b594e58c399e01ca494b3e76bc6bde970626e2a6106400fc546de451564417ab7db7443e07ed76aa6b77df1bdc3a111c06eabe9edb7d6304f52c6a2f3bb14c5189c07b3fbc212cabb1f1a83a32dd3f23c43b00621fa235b430f76f16fae18a95b0bc3872b351782b008783f02d52d6003f3be9dd0eecd2ff928d3f3ea9a458ada8f35e27c85fa341960eb9d5e9bc7e14617758e193483afaf6819a1a4ddda897750d7e294a827e5a4d99a1ba9956a84d837ca826241c9bab1b2b1c9d07dbe3549b526c931a8b719dbd16feed5e84336096224154d254c2f727ae553e6ce1b21a626ff155ee59573f725dbe17d6c4c72d6c29d0f084bcd1a65d1ad049c6f094230564bde313bded36d2a603b86795fa12ed1cfc5619ace084755e4de74b983b467d88178de4c1c0d64e2f6209d23c09266223e03846b1dfe5a738100335be8e68199cfdf4d8e3fc8fc2abaa90dc469f372603948ec71073aac6087bd5213243802acc43ab4db54987cb52406f021ba23efeff837276c659dfe54e7fad470d27fd3a4b11e6cbedaff489a8cdcf426d39b3c779117c0167e2c50e5bd4cf558c82eea19d05f11719782179e30688a89bb1809828c4d1499ed12edb7936d9ddf0d1e1dbea509817e69a982d82565d4e43814309f9368ffb629c4d4d445b75cc2e35826585e7c3e3bb9b80a47b2053596029f333a920e366863a07614216ed0039175e36b8a4d81c071580717c1fdbb5a4471bc921d329e101695cf352151f96af6ad99365a6e51e779360cdf36a384241acfddf3e4a0f85cab05acbf33dfaa13e44c5242213897f7e9562e73a071bb3598e2c03cd612255e7f55d4919423c017bad9b6290d9afeac4087a14070312b65b419e53526f8987e0c7cef4557c0014d6bcd7aeb41e36d31466896a0e83d0b50253caf6ee25b55f14a5731b9060fe2d6f411caf4e68acaf1ff5e2a41d9f064e16e7763ba55e48ae201f8e978398d08c09a859d7094f9168153de6a337e5fec12c3c6c05cbfbd472db4e670d62fe4b003b2d6fa95bf63677a7685419cd6d0a8d96314c4da78003d62cb899bd42c7e592a7d6009f4ba9200dce97498eb6f5d74d7a337aaa2196f3b793c64d7cb495bb5a26ec33b890f44ee7bd40aaf8c7a632be7ffce88a281d10622147019c575302168234f5808ae4ada4dccd76d8b7293595897a8b8fb6a0556fb259d9df831ba5d59577512b35478c1d6b17630342591692bfcf9ad1400a41af1b0c6d5e91f6f172a3ab1fd034505f26ff3a0e90ad9bdbdba30dbb3a0329ecfcde64b8ade3ba5400d31c0ed1bd98041e47d64a2782284b0b1f1b424a9e2b794a543b979fd015b052938c8bac8d47ff71518d19846a12a335e9aa039bb0c26dce76faa8d001c19152f1e2f1243b6ae9ee0c53ba1f057a0f612a71c67efe346409faf87644d03e4905ccabb3d1d717e632a1bdd15c790e2d6dbc7d92cd75bc2acecfaeb24f95e9fc24bc159de046ff509a1c41001c081986215c95ef3ccbe6edf806b0b2eace91cfed52078506a9833edc0f24e2b207957f22fa72e65a2f4728efaeec040275f8a2efce3336fa48d1e9fb4d6ef1e0bb2c9a138bc3fa36a309da1727cd0daaf214e26dca816d82d570553dc86adead228872fa3304b60ddecbe30184a8368921501ff1d07f8ccf2882fbaad180dcdd35e996eee9e240f64b8f5ac693dbecd9d57cf370dad9d7b7f0d441170a1660868687e9112aaef579f1e2c1054ce9716c6288b640fa1f6b51beeb958d08848cd49be48f022f552896e55de6b19aa4af9bce42ebcac59c6ef84cdc346cfd055f18adf2b67d0e8fce6e09c4683629eed7c176e192fb9bf53e148b4e6ea442b4b89516a6d08a6fcf701800b7b6f65e16a327564bfbeabf13974ab8cf49d1b96df412037a386cab2adba3e971ab75e984558f48b6d0ecdf9e6a1c57405fca777c46c41b893fbf102fde5bfa5f36eaa084a4116d2f842a8fbc7f8397617d90ce4ddc7a2c7d472db5a778265271e100e78a6ce3b3ef722d6e68cb8b3099a1ee7b4eeb21056904919964d821dbe354dd0a692808fec320db011acde4fc1e4c2a4b3aca36db5c9dca9956bcfd679eefcd13120746b473506e74a83eb602407b9c1329709a9fd5b604c95358147bb2a669687d65db2fa099ba2426bc901ddd0ebaa78d199b9a6f684fb4de8024a05cb770317156df2dcf31f14e155717c75aac75e73fd12551ac24378e7e976da8921f53dec4c03210fac62a9618706c501612a5676a1e685640469ca3c028dc7b9795cda17237714b2350d24fa29a1584285239fb33d9ec10f4d19a3fa068ee7ae1c7da095cac41afbfebd707b827fc6f7e45e30600177fc5a28bdbfa1c02d25bd236d032c31a7c5fa1324bf33614cec00d9d0f6dff8697465b5acf7e1ab3e43be5e031ece6f435d082fb436e314348884e1058b7dc5a8b85987e40a248fbceeb74cd741e1d9e4478e8db0a8c17496d7aa33f0b176d415c0997fe093f9a8c0ee1c5d433f96784e6b672c28756456bc5f64290eaf9298807630a059a83723fad8db114eafb6743a4655c8888a3c59c9d592f613e0563ce613a18e2074f31b043c56c5ab380c2947799197955840cab5b33eb301d1d36d6a00b88642cf430cc84f918b0c960c584103d2514577939873551bcdafc8b1f579acb1b250141d87d1cba907d48b05221351cb7923bd84820b261ca7ceeea748c8f4474c83c8cf547faeabb2c121a813e3cb5d90e5eb48dc1c2891a3eedc60777eb4eb2a534d5c6764185a0d47fd93d37b3aee5a55a93891e181829207c815f350dc7b858a33f5b3547866696bbca1c2d238925fb8551e3eb1647b8160cfb22e396c624aad84f171880638f6539a8550cccfd82f9266343b6541358c49baba649bd251f2b9d8f78a3bad5a8dc9f9bf2686fc51fe349d70bcff40e84e7b6eb90a64f8a08a29751f4d5330941fb78b8a25b30ba26561e16cb70473e340604104749ae69a39fc610d98d0b9cee32a0fa6cdbf5d98f974c92f863fed177edd5f54581b659785d44f9a29ca57f013b3e44ba2db774dde9455315f1642a98919f42bc1f201addf9ba9ca642e62987a41a992f6f402e6fb701468982e67b9311107a0f2e483a3aa5c9ce2b29ad48e0497d55b953954a86623a7b02ae2f679133793b7f458fc2c4a013354610952ae7dd7ce104541ed9b8d129e2c64cc3d3610b1a32274712b416b9e8323aeafe9c274b9ef3f066bf40e49a7356935eaa917c2c13972bb4e9f851ce80d4ff10c0a327c3691724f100bdb18a80d1c1d410c3bb91b703825b86e7813f9d30fee9e465a584f6cf41f1bc5954ec6a2fb1f2120adf4e26885f0c0af0535bf98dff610dbf681eb2bccb9dde1913008a1127ce9d5eaaf95847ceebae66a7dcef3ef3dd307de47f05640c85cce9f53289a7efcd161b6f74e330bdaea77bab37a2f2cb6e0402fc9b47d3fbc8a2586c23c0e80963aa281acac17d6d48c6c0838fbcf8783a4c4fb0cbe0555f20b2a35af37953001cf4a5d3c52f2a2df8f6141776fa65f93079e92632d35bef5edfa4b3dbdec6d165e933504505a2ad00110288481962263ad1f94c21736628a4544af25efd184ccb4c50f7f7619991b7642313be513a789f887b446a38e381e3b033aa8aba6a3d703c77b6cf21cc3d1df932b58b56471b3f02f311b822fb8d2615897d8c26d82c7b0842bfebf617c8c2cf2f8517d5840e66ee1d35fac2db8f0c203b26b5f223be3f082cd64b4353f28ffd534eac1de681d9a9411105f7a6b3a98e4a8c2862f9407ed3e049cf75bfed92f7c775001f2167597b6d9918c2841a4784931deb30307422f7c66255a1c08d21c1d808532b65fd86f6ec59fc0eefe6f9761334a787f1efcab70e61d33960ff59b9e6010928d5cfbd8c5ffb3cc06f60f0371e6f9ba356a2db9e139f8414e7cc535ec14e0ae32fd1cb57e423f88a9edb76ac9626aacef6b9ae287979bcfc493e9e598d8f6245959ff46e13a0624cac4928e242fd3a0b882160808f89e00d75b63dbe1a4a7ed66b1a91b94440389ed2b0014bb8299aab646e5cc0725f13cdca7092f785691fdaddeb9fb9172c9da3ce34a9db55f640496cadab8fc2281ae90eff1c97104032a89b3fbdcc933c039c51f2752514008d4cc984ee853e34443ca9768052f238b0203c61246c959bf5557c76f0109196e21c7b18b2975cff6c047a447afc7df428670e54fb584ba5109588d81f918355065242828040e82b6620564bfe69f9730fb31939be8b39b02145a7c25cfd3bd8c031963c063d7cbd3dd018807cfea44fc712cf098c4b4eede0aefc8a3ebb4b295e4012b7191e71372e21ab0ef1c874978a686ad1582f2f90a7b93e1909bbf4ab6bdbf8adb06f5500fc8e40ab6a90cab5a0b146cf756012a4a9a36595902d0f804ede4d7fef3cf4c63e85485a1247ea02d8f1e95b0e85725ec6bf369239b45ba59250fc933ec8c09b9a2c3a33ae0de736a76cacd1c6a1f2e9392b8d1154d587d69c616aa85a0d02d890ea5450d24b32e2baa530798e67945326d08aebf8e089d17fbb9e18f4626c09013b0fb33f7bca8187b823b945e493bb12e5f36809f7f7d015eb791c30a2bdc56dc374d2f2e8a980ed85e0a478eedc7968e66c19e27ddb4cac881d825a0b8f151f428a39884959e00ba4ad09f2eee608765eeb2708c10a2aae171096e332642d9195e3a1c83eabe862ac2c1b3844e25e3fc690d2c205d32d0b1ff49addbf928f6e443a295181a700f82251b4dbb5fe6a673708c5403470f18167d00c39e4955aae107b0a56877d6fc2817a6ecd2e166aed40dafebdce85bd8caf2cd83070bddf632f2fe7582f6681087d47d1b78cd8c486c5fab66510f39205331d7ce09be687a12a5780e5cb540cc8cfd540370e70793397a643da3b9374cac27699a0d8979418b5384d5d135744c72b232b63ff56905fa927326e1949b0635e679de978a45f441f155102466c3f9c173d0aa74ef81fed721b98e47b9a3b5c480e43d7758d4b99d976ae6be24f6cd873e9ab462480a5206feaa30834287a0eb65d3054a65f3a9daa74d654494512079956c6d9c9fa3f15c10210d2205dfb6975a2838a6e85350e4b2876215b815072f8dc26685ab3cef7d3e27273e72914e7440f67bb9c9c6f82c3cf3cf0e07c686b82a0fb36a7fc130ac24d1a2072f8c7e616fecc304a2c688ba233eb2145be4af385441df12054696c3112346660f859bbb438b6ddf3798a811fc6e1ad488a7143caaaf033793c90cb9aace8afc306349b1085343eaa02c0a4b73338030feec1addee10ac2c51bce777c8d49cb0122ffb3faf0d1f1e091ff0eaf01838b006d38bc0367a17d4b10069c5065b119b4b85810ed946e19cc7948d09a732fbba656e710b86d54ad0ecc8d134276481c1245e1143a96fd10b5616e8580dd767dc494f2a69d11ea7dc2e20367e9fb6b870b2380709b214c501a0c3ecc6f790c640099cf9a739d5aaf63c1227debb30aef06df5d58405aa49c0e4673953fe865a63414603f0114e0d9b59c4fa7b6893237952ae626844f1df8b06bfbd819a54327ee34cbdea4e8c8e9e6b297d86b60356d5b8e3287f3daa51a928a7a12df79dfdd26e366fea645203ce5160cc400c0dfe89efcd68d38dceaf1f5d5a84db795e95ea4db0ef0eaf6c73a283ac0890bb64271c65904eeea5f668f6b3d30c72e39cd8a349252a0fd316060e5937edd886dcce64b61ab2358fc27a6fe885a0319deedc4d57c111e70382a45c4f2ebf95653c691c90200531e9b2356f5d2e6e83a44ab599ec2315e7d9778d34c16355b8b737d240fd3bd0919eefdf21b59a16fa265a3da5a0aba984b03713fda844b9d734d9e38dd847f16e3a8f6278ca3273ff55a9d42e7503fa14e05349c9894d91b8354efe3c46ca4934efcf81d00b03d2cd58492cae8c91629d1818ab62ed0c01754f35d4fb392f0e66d407692","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
