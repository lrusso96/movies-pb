<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d057e1fa3c64c88865e4948cb475adcf2af49d33c03c4792dc3a058b24850b4e4cd94267a8f2b52d8a443c0ba762ce5281fe34705f3212eca03b6a007ee6ec743a925a6966a5a99f74d6a373418414e2a11e4cecb26530d7a5e2b8920ad99fa173508e10f2d555647b32d930683e957fbf542eac413110183708d1c9612b5d7980f4bd5a0596998c46edc956a97a8c5105160ba17b426e54e0b02bac032188afae4b549e70b4990cb510daecff63f163f7f7adf6a0133d2f85970ce31254f806cb4168fbc56d0875493f85ece756d24dbd739396c7bdf1a0e8604ec70a55981e0f6057654d795a05a555f42dc3626e7d402fc32c7b62ca42f3a07cc7046f79248561cf514c0851246eeb3d9b6d3b2f77310dbec7dd9e05355206cbc53546e290fd3473c2e5206517a297ed6f4349a59a8d89f45583cdd1d4dadc3e4b7090532cc81425355d0eea53a2f4d7688a5d2cb07b41e9530d1db5f22c9d52270b7e1fa02ac49026f9e57089b3d920517aaf986a216f2111eef8cc7ab32e39b70d1f22af6632c1c5e8963d37f519cc1f50d7cc7b85dd1d677615bd2c1508f00036c580784095ffb701ea61181529207f529ef5d0c94fdf7112fc90acabfb63647bdae86643142a0f449af373066715e888d2a3e60c936bc1fbb06873aa701df254d27f856e0dedb5e4639c0fb8bca09078e63f9921c3b3d994a1485ee8bae60073af79a33a47dc1c6d2a38077295a8b6572df19eb1c5a73d971ad7160483f5134f4d3a1283d48a0581cf7cd45986140614803d9fbe7a19c22ee2be99f2fb6445c563465186d786382555ba1d688cccd9039d5364f38c152198b8eff4276683b4443e37084f8c38ba2c7969a1e397200290f329f72780287a0681fc1f67149eb3e7ef0fdd31a32f78687992658cfa7d47529df5b046558dc036560ee1d43ed0e2f336de0918a94540a9288dc1b092e0caa7d46ac96520b45c765b5df0fb1b051f3dccb1a407ac039df4373c1c5421a1ede090b9197353764f0c7c5ee39c5110adb0ca27d241647c74a4fd35ce7b1efa1bfc1eced8686fc5a3cf6d3cdfce9feef08c6e07c11eb0ee6f29f0f68434c1813a59ca300ae6378010de82e94d1eb8f9b0a05413bb6a87ba57540a811a3b188c5271691855c636ce3544e4005ea719b40fa99eac2d4fb98940dfe780f33f64d7dde9ad0566ed665312efb05f9ac4d28c413e2037fcdcc70a6839c171110cabe4dd818dec92c70e76c48dedde18eaea0358943850943cb7dd0f9a21b58635fd9afe4e5d7e27e56a306d96ef9c63802bca6e60bf0ce1d837c6262e75ce98667e8432a13a44cc06e11b6c10ed981d41b96a4d902911c02e789ff9942581c0b9a53e0eddecbbe10bf04c0db988b1b3147598fb37754094251ef82276fa6f0c2c7b930f0c0f4de39eaeae2e5bb60274148b2798902c3804be841d0cc105e8e32512b516614eaa8af7fabd49b2eaebcd858ecbad9377ce7effbb56c68d6bec02e51407640217c1f5ee2dcde7ce76bb2a692fa465ef1534684d239e84b343ba8fb87a9878660bbb74bf4a9b6f5e305eadb5bd5eb35fb9e792d9fd6998bad59314f7924f2d9fa64f559ce0f2bdf25c07ebd04ffc9563cd6e0abb21eb3a7064d5d719f93cf95a54c6c047490254c88b03edfd1fb76b3a0acf1c6a48d6ebca5234c0a22ac79402c78e986b828a54d0e1138c4083309ca927ac75583ab8f9590430dbcacf3aca5e300124fbafaa765515cc458d28373a6ac9ef9a236f91e529d6429ad8a8ba05b8d37ed0365d4d40cf62997d0cbb8708e4f6211369371fea7a69df953d69c922fe19fc7e63436989f6e96af773c20ff7262f031f65c502671313f40df23d053dc913aa832d5d2295d6e53b1214c719760182e0f905c6ceccf2a66eb6eb552a42d6118f7337f32b42ef7f89341b18d314deb9bcbdf8875bdf4224a75e53a04cdfad1350fa5908d9dbbf58c60a4ba54c21949ddebff5cd032be657689d24d5f3d546ac4c028929ad67f1991dc7e359ba0a8e40c075003e9089e8aa70774bf629a9adf9f73a18744b8b6e6256dd4b0fafdeb33a79c2c454d3d85ca880d2714a20b4beab216430d369b5ef1fc78aa24f3cf37dd793c663190d23aa72f72ef0fcece1645f423dd86deea944e7ba2042cfad877d56908ca1c307599a08a26858254a422f41000210338ee71698ed1a61308a1e5305be3f44927b203dd76f90ce238009cbffb19db3c9c73b2c625980458631dc27cd0aeedcbbb0c071fb45010c0648e7f4424472756f34b833d9a0a12bf3534e9bea98d88932904e0349828b82279624fcbccc59160ed76df691f15e2c3c6e1b4e9fa16c1c0cc308cbbb859e2d2ca46986caedffe30ba8ea79528a2f9e09988af043236758a65a9508fb128270ccdfc729d22cea001d5a6d86cb9d9036796884f4088ddb1abbc616fb0880ef221f624948f2e8e2feda33f6405c17ad07205e2dd989426be0e9a110fe093301e0997c7913043235dc096a07980c6797db95b385999480649e3d959146280c9df6cd59b6296d437457b3833b1c5cecd0555fc9682fd35caa591074e66e14a3abea733936e65caebf2b5ac5692f528162626c7c080898aa7eea09967caff740de21418fec2b299d41b9da4a2937bccfafac543f42fdbfda317f7e76838dd7aa3493c86a207a493d10bc6521f58e657192de065ec51f09411f2331c90fb5f22ffceee5d16e1c86d03cc4d17e8c1795e52bbc791b2859f6e10fac6a22131e5183c39b42b2bbbec9b1b2cc2392d409f45eeed401a848c51da25c3892533291dfc8aeeb8ad68c19c189c157a58f4d41926a61cdaaa306ccf9ed17105af5fcd04b7caca5b7e357289ced36e40768d1e91f86294fff35e6665d99c95e8d7acdb6bf2dd1f8b8497566a328d42d2f5c551611c25448fd4d889d0473716e67ac0210f34e88afd939b6980ee4b7d37688ddb452c4877632c7de47ae0eba1d50db017aed9356aa144e6d959130314ad3d1699dc76394418f8dcd3795cf9ab86e08aee10e8666332fdc521105eaa599b7d40fbf0b766b1022d76b58d49471c393eacc085b6ec5ba65c681278b3c5a11ed5516ee17bf20cf4b3cc65218379c638581f31b3fa60da4b28303f924312e10688c9c9da86605cd46f0b3653767523b8f1aa86a382225c223cd460bb4b21a5cbeddbf226e68c2d962e464847ea29e414ef4d176bfee7d557a20a90078aa62bc3b3d4888e1371835e8be123d9aa67e6c978d0a31b36a68a42a8c3d746856cb5a0ced38f21eb8330e3b2de6498daf1aeb9ffe5edb4e60630e2e30e29f41043d20bb4ab1f249306dfa1ad87056676a2cf8b34de8c4678bdc282be7d4bdffa9413f88de16311490f2e7451de5c14bc873f7ae920a8c89eb389b5c8adc9d3543890c495147d164ab62ae765d62c599152f3c6ff339eabdf2e0b59ca95d9562364719929da4202997c6db8c8ea436650486df7358e04fa7d9cadb53bd2ea12184b979712dbe5fe44790aaf571fdcf3dfaf0ec8c6a7381ea696a750526a70838c468fcd1127d1c9f38ba4a2cbbbdb253f52633e37d18a8a33512f6034fd746cf5bd3152e322613a8ec40a027f29d7c95a7451708a2819c11bf06e83c4f53ed247f64ce5f3adf6c21b8f6bdcacc9af2da015f16c7a7c5cd7ddc59a8ee58b00da673e2f5460ffd25816bf830ff212492ae48ffc665c45bc5cf0d97eeea8b3a539d923afcdb346ef65f228f260c6d3fb8b637a75dfc9f891da1d28dc36b1a9e70d496a334cc95c0777864b198b4324d6ed341d91e076d5b71e48b08b8f125ba89da2f6ff5f3593ddb4077e7363f771ef11387261417e1dff69ffb6add97979000cc24ee762bfc281fd6624592af1a80ede0a491b5fe68e58feb957050ee5b0d27aa730abc444631f63dc6d5d0492106395d5761a1f17095407958dc2b1d010f2f52f19758ab9411d643db4867b404db178669e66e2fe52c0ccdca3af983b0e2d869a389e4d936baee4e1c7b19fd175f397aac85bf61253e15b2b67704fe91077f86503ede441ccdf680b265120407119913ed49618ec59ecb09fa45ea6942b293ffc3a7d1acb90c7262a1474b5e927ac0ae36f9641351de9616f1c7ece6a10d353572cf9a9d5f97752e214824664e0b313bd93488e54d6f736f90f8d2dda2310ca3d54df82efdc8b46ed4f42d88c4b1ac2eaab829dc83820ac541b2b16c3d3bbd4d9e35af1bf4b93987ca15c5a2988354c30c1d7f41e0591350ce59c10cd2ea931402c313c159f6786511c4714102aea0cfee07f2f0e285301288b848f3de46ddccf8c1d60f15ddb39236a9490d499b0aef81ec30706e85d236272603966359cefe8869cdeb43ec90c817cfb81a690dfcd00a177f00f1cdb90021dc860094ad4c27613a775ab1c1128fa0ce0f79e411cb356159e748e8ce039c9899547a91e1add51652d2e6e1b68ea4f3e73fd4c1c1ec7e68c05c719f749f30e189e3209734d161d542874dccc215da8e82281b0b3fc95fcc7325e2df11aea48f91c4ba180d822a80737211b19cd428f558151cc8bfecfae04c2f88824a61e021f0e18bf149ea5413b69dfe8219e4d1dab8cf7ca582db4a47f7ad4c04a01bd3f31deae8d40c89e9d729c3a0236cdc71c4ebfb6d4df784c48078ba1d85b7626dce17041a1a69859210dca446b842c760e44e54cd5c63eb4324d91ec63837f06045926d7709da5e0ba832d3c9c3b0ea9ba65bf5c380f6c2b4eaf2b7742208aaf5974d39a302f8a3094e3939f2b2218a09258b7af043feee7dd42654b28b1d8fd6906247c6a1b04d73f00712a396b07816c3cac1ab6f4c9e3315f7afa77e599e4688093bccc46270189c9563aded045aa2a43393ddbebd4cfc4f3f36925c8119bb73f6d5ad87e2e47b8866faf56c0ce2ba7ebe198c4b3a3cb39412acdaf76b8d4d0ed8be5424ec1b52545e2576118d8d7edcecba95b2aa6ce284b7eb61d03abc2b6e5c75b4c73455cb74fc65ee0a198142d790dec7bee12c5cdc5c305015a98b70bbcbc4f379545e3a53875d85d7f11f714b854bcd290565a45688ac8aad84abb46a2129b7556b45793516fcf579dcd39e7ebd59b3b35bf6f24d4a6d37f104b00b715eddf05278c7721f14f7267f454196175755bbbbe50158398f98029759a79050271a7242820e5efdb33466f5e56a6d550246e5cd3af358904ef736b5f3573ed4f8ba01fb94c0344763d16ff20a840ac79a003ceea5ee42676750cc75626bad0452ded31ff2aaec11abb5f2c370498a8477aafbc0d57c53c14d0dbf402161e916a6d815bec11d857895035b439a77cde4612a738344bc4e0c18e0cc517dbaa9f3df082086af3b12588e13924038b6004b5640d8d8c76f3838023692431079a0fb6fe1b7262275e6f2561eeb52786c92dd4069d90c610aa45b7602d86aa6c02f360d247e6b65b0872b8a7636d7d843137f858e37488bd69eae5fc303fb0e22853969fc93c91a87038e80481071e190dca7aa667baa20375b309b3c90a4878e1cb35a7df24a384a3ecf42cb80af6c0d7abceee760c70dfe6fee1a471c95b38c04944e32674abcc55f1afcd50a86d284d9f10bc0b390c786fcc1a9debe6f03a0a3b6c07c1e02dde6a36cf051125f83aa814b5f22c075f92e17bb36f8b6179e87443b25b209fc08aef59a14705badaa049b6c133de6ab7717691682a86cd23d7131767079a13117e0c23e19838ef879aabe3ecc6dcf27317c7b766c56613f529224dd98437579996e090d0d280e471c2759af0661f22314ff8729b565c6d2242a3ad36cda1dd7e1fcf79933d9d18a224a0e91c13144f4c3aefb3e2624fb02dbbd7224351a1ab2b43f012f3ebbac4c0f0c97d927f61b08697178540ca1600aba4cdba043a74f7394086966e7fca81858582a383b590e84015c5489ccca144c16337f5ef7b0c17e89c33ca4808c8c7785ac807c1a62ef05a94a90d1fb40c4ce2ed031daa0560a72cb3354c13f9d56babb2ef038ab637b71e8e53795597c53c331bce3fd20b9c84accebe0e3628ae818bf74fef37a268c79bd6b61ca02116932b51852ef2d106b1bc313277240ab07956688817168ee61f57dd6a329843a608290efb2b141d01f57162a01dc0e460e303921fc964426df1087032fb90491aa9d8ce83edeeefe44847f47d3db21bc617049000309d0d89b720be2cd1201aeb70e97424fce52054cc634a9a3a4eebe5e02681b81d89d0a9a7c2e94dea4e1dc96f383e43776aaeefc6197d180f3cee6b2f8a288ff980b016f9144dd38f456ad74ce348db7e1d12059dad75ba0769dc5a4b8c0cb27b096afa2f7dd8313640ff4201aaf3f8fac6914bfc342e0a0d87357fa799e0e10defb91759769e42f623e1c87cda353836da2951b0117557351c8a80d27a0ba3d5a8f495036c849d39b0c010779fd76da49f2247b16f07efcb238aa7f48dca73eacac3248ebe0acf10b9fbafc9415ce6a8c991166df0a74c034feb7defceba4dbef8d21575b23172b9258b89469418c43b38ee37e0a3c3cb4dcb6467178c010a85d00705d205969b04ecd57e42e9f9b35d1393d2e69bf33f5c57e9c0ac24ff3a847aaa980da5d13fb4bc0200c50b15bf771817e85186b281ae22c6f095b03e078d829b812c361a552bc541b6e35157919c2d7e11ff13a4aa6a1aa627c8cfe81de2c4954829603847ab1233cdbdf4c1682220efcc82ba099b546b72732624f867db5b1559042a1cfcf086dd4fc468d03745b2bbdc40975e7a561c70bba96d4a304906ca592ec1637d594d5f4a1956c900b8eab97b1fb14e4629fc739c4549cfaf53feca34076689df1f7b2ac9af83462120fbeaade465afccd66218e1021ed90d201c1936414516ef6a328a44203840feff5bb1373a2544380ce37a7a56def4985645394c6de2cd8e46182ba0c0d1c194ed401397f61e4c916673e3102212fbd01f01d9fed29040a9c6312cfea01d54e18a96aea1f303d7199ab297da2a9538a4d2c054d923e9dee349468763b745f7baaca10573753cad852202fddf6d19fba3a4d0c26e2e0ba61865d9cd830aa3f2db2f52d07c02bba87d2ce76eae2795a631730676f6bc52a735abef11ae991c9bc162de9ef4e878501d96daa028dd4dea9e2b6e5cd1458e7c9da8c51142c32e927f4cf13f0c0fe64d9780e62aea5447194f51a09b7b167ec423e3b246edf463908dcb771942941e671775e4b3b8af5e0e5f8d2052cca00a360d591da580cbbe7ef040896751210d9c8d3a3991b3b961baf0d84520cf7e21033dae72dc2f9a02e2162fd98398fa7cfa149ed73cd954bb4edf24996674b90ecfc8bd558d8a591e90a00989ae3dfa80a9b5dd4c19c2305be97d6974600512671bb00e9a7dcc9e4ed12b3776fd5c0b01786adf6cbc30d6c3bf49f63bed3285c7ae195a75764b0fa8c31062d9c30a77c4dc5d2694ce4b2108c23cd3736ca31cba8b87c3127376841c4563262b3312486c9dafc245ceab9d36f228f348fcfeea3c6c4d8379248f0e18f14ac9db10c374960af19106c9d06611daa21fc428520dd1f019f97fa643fa4dde26fb8970a928e48137f7f7b8abdca6aee4c960aa00a33469aa6990bf361a315b1fa3e540aa0c170c690d3ea37175ea01ca845402dd322146d0ec3023d1d680f4c04ce7552e7045a9587ec8fd020ac5dc049ab6bafc980758d5530f53c4678fa4b18508678d8261d49b7cce30f659dcc5f071314654fe5017006d1ef86229d5a59e4d7e2c5fd8b3462b6a0061231f5742c52a0c34a5d0245127a2a409f0028562e227fee929641c8e0b088db67747fe2fe2adbc3764263e85fbd58dfb16280791c2989e3d81b8554161dce724e09741d415cefcc48721d126e2c1d4f962f4ffda969cfe99125b19c371823399088623d81cb98d40cd9bb3ad6ab7f6db5f54330585375546c7e10b2a36aae06e3b2924955c2cb14a2550010edffae38c6efe612e479322fae32a2e15017910b28aeadbcafc3a565d1775c655d384edf14c615e4f17f5f7044ae79d31c4b8dbc9bcf8dbdc1d1a4fe81d7c242862ee44a04d6ee34a300e7ccd19ee15b9bc0c186112e07575557c83343f1baf3b3ac4b21a50353db7fdd953b523025ace1cbdb1e23efbf0840ad765e5341c26b4534893738f3ada45497c24e6936bdefb7caac23c2412d774970e32171425414acdaa424087337402c8f6236b27ed9a7c76bdc4c56f4369093ab73b32872355602bc7bbaaf988250ddace6dac04a53dd614c3270f599fa6449e2ee6a7ac40ddbeb4dd9b71dda2873e6fba55ca566988298fe7ec86b784ecf9b829209c7c2c688bb6e1808e8093a10e7a477c4e9f6d1c87334d0614616e0ac4cfe466dfc9d8b83b9cdfc93a80a8eba0557bac5f5d6fd7720be3b7d80a6393674bb1a59384e2b6c2b28498ba77f484d952a7c2aea1a741f0c4d4e7ffe11dc0fed72ee943747dc8eb6201dd5ef61cee18d45ff5f98e196498e00381d0b912bdfbf50cecc8f05ecb0050f4877f7f85c6fdbe197dab0ca7839a1d25a38c3143acc3b37c6a2e4908f74ec30f9526fe8fc52c612cc00375e3ef7747fcaec84428ade116b7131989ecb6b19c8fa95732ad208b73c174e94e98259fbb9eecd2be5b974e3a20f33285130f9d52fdc926f6b2e9049a9f3c090d21de1a3bfdb943ba3e896977b10be30a2b5cc4448121aec8dea33ab2148d704628ebdf4126fd5f952adbaf9e60eab4876f3d9e78af35207461c712af31d6b3b92ba3b14465af03db58374916ce94308f72945d81e9f4f9678885faf84fd9f31e101c54145f9e61234800f85713707c593e5f7772a11849b406344265f2aa96aaef1f7ecdb1389f499bd486388d40c30bcd1a341d8f198076be142e69fcf30d84e87656c402acff9cf188728e9733ef73d18cbd752823df5e11cb0c6cdb7d4d242368c3afb97db1d5d25ec5fd19968d60f1891d05bd4176a30d3c20a56c7371baf6c2c00aa524597c0c7215073db32bea63104888bd91a6d3b3a39d80c40ae70c17d2a2c4fa644c379fcf0553bdad04995cc93292c8f96ff23e3c427c2e623ca44cb6dfc184f360b34468dde881ddeb45f6ea41c7de70a935cce727f5cbd2a0ad1150743387ad2459d34abc4c1706dca30012a513912a04a86b4d20b041ed47c401469dafda4522e705eb44074ed574eee190b92b7dedff66ac76861775ad9873f4024230829987f7a0373d1ace568999391ca91b9814a5c61527187c9529e34e5726e1f089d57a25d4025b4dfac5bc7cc96711f8f02b3ecde61b196dc40e97d67aea755184188d8270f753d8ea73f9a7093f4639ab5053df3abaa191824c8d57ba0c80c1d27301a62a873b13f9f47790f0e47bb5ab381ad055faac4dba292f98b3559b381ce2ade10d0a4e47f31d376c86d44699b03213c3faf67c7729f9afce66988f4d8c46dfad0e4e4004fdb502b40d19984a3ced9f27221e7cc06402a019047bde3c76cd788091f667db10a64b810a960afd5112d625aa29bc3458dd4d831e3e6f64baae6b0b821c7be9d911047e21a729a795296042d59237d7e7d8b2864a2e96d4e9ec19d004344ea59b1e4d3a0022c0f68ef6c6ec605dc20edb345a802607b41e6c36f42b604a916f91e4019afd5eb7e7fc61ec719f446faf36b2d91b273f6b2d2b7f8d2e5cc48e1a50af7209784b41aeec50d7c8a1e100fb2ab7bcac5fca171970570843b76a32d79dcc8c36918c5043f46ae9b420cf9b65939dec3721f5af898b039a1966234785b3510a2dbe493199d0c8c44178b37f7f95279a5fd9974ac243e08b17e0d0f8c499a87ad8a2adc73256713d39547f3c22bb23d1797c51b76cec8bf461cfc98d9cdddb43d72dfd2918e281069aad9c026139386d664efba37507dec433f47dcab3ed1181dc08db47c2813c8e6b100f25a970ef53c738eeebf5a715e4079678993cbbfd76ae4c8bfdc098b0a7dede2d6b6112aa96dcfde5e1adc5996b6488db18c67a25deafcea658a03cb6be4e532057454f511dc9e854588737a4e86707fb4b4457fd4888c9dfac2e658039acdadb4d7daebed9b4015d7eebb58ac0d9264bf53b8c526c464719b7f93b330ca991facb7be74152cca8d60b9dd644e492cfb0fc2ba2db99096d206f26f368a24dcbaa1467631a3e29ec4b546bd8c3310ffc74bcff4b25ad46fa30150190979d6ad494ac2bbdffb35746aa0bd56dc3b779f11e9cfe10368db7975f07c22defba401058fd2502572ba35157a7c0f8221d0effecca92ecfb8296f9e12d1155735b506532bac0f2ed27057dfe0415872fe5c2175f453b46e9147b64681dc00583af8f8de748e7071c5a846f3b09574a3dacbd02674af6705dadebe078199c360e9b34b1e416b4a0aff7a8b474751deb738ac3f770c4613be6d9acab59f981396b6c8db4bb5ebe48c4ad9b683b89058722bdea3697026ae4e49cecbede9d8ca6ab46c06a98ea3f63d4a0e7e66529126f1a313dc4082dad0a6ce0e3dc770ef994b0f4538597e80ed90704e0296086f102ca398656f0ca4df5ffd028d49eec679c4f97fef1c957563f139fe142564bb153e6a28719f4d4a75ce57829e32879791a0c5588b7d692861f558010cefb44f3fe845e19bc586c75e1d9af1eefe32e835af3200c3a210dea784f941133f9c9a4d71da69d81dfa209711be3cf588f0e11fab54507af9f56df9513f4f2c8acf9714a7599530b57e1cf0193df6cc8906c1d5cd13871b885f0616cdcb73c2cc4c16bd23c8fc9b679e8bbc4809beace164f6dd5b783d8e974d1e497d81cb91b84d32b82bd61cd997b87da6a386dd72c4d2cde6c8f27229e3d1318aed4864efd66cf27f50aa37a480fb733b48a069e20e7a945e2128c44a85edf7c7cf0acd96902d651182104a492bc5824ac13bac2f63c0cfe3630f9d91d54328969fbf6c1c87a766cecaa480211eca342c91cd3bfdb3aa576d770ce0be05189d4e186aa36a8fa3fe0f186201b457a6f58cdaae861f17c3664ead3b10a0c76f29acd3867177845b16537e59f3c332e102afe0ba5529da613632b3c05f5dd1309c05631fcd21152d9f2e66be6062ddba1c182f4e0429dd456e590896824179bc22b9fdd6729b81ec3bc4d6b433135b0889232613b9f7e08fe45b7517503073b3801a309663edc6bcd63582e97cbe2c46167823d0ad6c578911bd50e48c725d0cf3699f9e450aca7671b8e258afa3aeb4c7fa4cd43f985f84090ad7ffb4ec97da0c3a212fa384b66dd70956c04c97954f20175bd9a54dc754a93a3205aeec314c9536c903af808979bd1fc241fa0c2017bb3f333987d458f0782a41930d540df69bc9c2554c2c641688176fea21aca1daafd23a6dce28b544b029d0ce873090d8a93832f8ae3249b2e43d3bd75200d8f162c43ea078c1e204d6002a176b5f8eb18c0025202f02af2a9497f5cd663a71b8fab544f9920ce5dec24f1349464b464ffd4c35b79027b33e6ce276f767c390664077387e81f3969ce59d3162cc541afd00b8aa7b92555651905b0382a1ad8d9458d1bc2496eb7e3a2942254110075b40360f5a22c2f98490995970e93d57789032a6a680ba0d5ce184c527d22964062d2e759829d81a60eb20b2a4e615e0418faed94a3bdb6a536d457167960da0a8735a0abb5c947e9b8d8fc73f905956321777b9be102ec6a8fba8ddf952df08f359e61eeb40a8ac32182f7eece67a56797cf22687a46d09597421dc489df3226a0baf86244b5570919f08873fa7f0ce21084fa112d5df66e581eecf92cb75e8c565c4f0f1735a79936232829da5436251a9118c664565b0e240b280d9de7361099a8d174cdfb1c33fe451961ec89877e529aaf097497f03d8156f685299662c870987f5893df0f82bc88e4264d02242054c5a3d74a1a2f13883bb30f7cac8019b96a5c0e1b860604244b120d0dc6aa852ff0446c0508722ddf47be8fc778f073b8eb05390f9f9c5baf6f929053501448f4cf28979d58d292b20a0413fe4f4e3111e4d318db0de0ff76d5bdeafdd5a599e97464a2b4f6486438ebccdef926fd8ec6ea7d47f94ca398b202d0aba269eb54d2556c40da458a35b2f7d7e06b6967424c285156967d8b90c1b0ccd367810b7ca8cdd3b227eb9f523368e94ed33db06ea69c3711194f63074cb7fc32b95a217f498b89e3bc7090c3090c3600f8434467d9751ba053e9746632ee02aa56cc115efad9c4083fa161b625c70f62f96fd213e137da260b723252dd7091fc75ae817199c376569b9435c36d3770c9639ed2fda51830274b4d2f2eb7bfb70bc45c4dcc5172bed7747a2ff0f8612ae60caf3b060be88c53bb535890a1b7a2d3b7a33d0f8fb19f7a280e64ba725529ed19cb1aa2db9e82cc0af31a02abd7017f451b3a6248546f908d9f9f0559acbc5f138fe1750ad98b3e529d891c30a53c8d88a4e6626226b3a0cef1dd2519cdefe7184a47ca0cce613feeb7d32cbfd748eb5f8820d627873aaba71e728ef50812d8aaa6e3beeff9b646c448e3ee40f06dcb4ce3c61662e41eda283df2ba2e66d75a5324ff7097381afbf0ac1bd0165a24f545604d75062cc438abd4f5d13cd917e237d51dce219ddc3b5515483ca1d112172e118cc68c542e10a2e9e2bb4cf4013a5f379252977da6135064ae98bc25914df126377b39d76081fa20ca4d8df172ced7eb35b03237e393fb475acc1266d2a23206b1a682220246712a7e67aa3870bb8d4978eb219c2d88e324dd3418e4d8f3cccccc170cd1f71bd582f6b5cc54657f76dd7fc2896a0ec846e9e5647c3a837a499ea108b982d2c24676803bb5b97fbc8e3644019f03d549fd5e860deda5751b0e9742a15ae94ec68e5369e378a0c3437625e0f5be487897d1c8e66a8e721307dac4794350a143ca7c6afd5cc0c36107c479fd91f03ca77a2f6201a0924516f63bd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
