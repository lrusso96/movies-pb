<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cc05324d254d0b166e10114c1a093e9c11b6e68ec7b7c4620260f9ce3902ed234418476504ba7ea77931745941cc735abf382c05f69c97aa09d412ddb2c8afda6c56734ac2427f5453a2c49f7b3a2a39d7f23009103e5e21e414281b3652918eb835ca2ce815b72610b592db4fb34dd56f465933a802b35a7396ac7024907815efd9d9dabd941265563125f35262d192945e4a8673d160d711c8bf397a0338639f9b7cf582bd1014eb754fc74bc903210158fd62fdfcb863e213063db86fb5a40572a105c5a023e89e7c55c155f5e58fca4a73776db801fb5efdd3ca307640ac18c993f78ab37c70e67ecd66b7ab7279ad38e960405a2a04e0bc6e58ba597194d2cd85c7ccbc0202479ba23cbd0b6360829702aa55f170ab7e0bfbe4f73336177bbabbdd91ea65afd82c2d7e6f4ce6241fb07b0fda5e6acb5bf70f25442edc253af9e7486cabb0557b0809d2dc8071ff4824355fcd021aefdff5fc104e03131fdf1596dc239f2729b6e897bb7b449e3beb134d70a36f76d317e381fcfb4e42ea85f26a037219491dac4d2d43fc98fc1755662e87d83958b1290de6a76ab4834461e9fc97da9770f9da7aa8b9b6cef2fa2f7c713c61f88a20a0c25ff2a3a8ee4309a48d27bacb9a9e131b1210b9ab056646a1c96fb194b4978e62f02ced90f83ae92d77d014a85ee9a00894777b70a684743ff90e3409d05ca38805b7b1106a2249b7beb6b09260c15bd1900bded73959f87ad471f7b654d033251019fc3f8460f533323646a324a61b6432d92b48f581637e0b9b018d8dadeee2ddb7f3e7fa9495ef2cf5af3578216d7620e861bb08e0499aae8b2a97c80dc111423b7979411af7bc88d5ae4f884290c16232f973e292e0efc684f5a6bfae3fceda098fc92a16f9b0b2adaba31fcf689920089fa273831cb0a22929e71572d406ebe1bf01dbbb78293e4b80c986da85c644ff565ee802e6e737808ffd19ff986bb3bf4189755e4e287558e2cdcd98b4c027ce04a70b8fa54156b375ceb5fc2c36918b4de7e1c3ef5a150fc754c4ac752ad29dc59949f93dbc93e76c0dee85254c447a4ef79a40f6728b7b95347bdd33923c41708b6b8b6cc3300576f2f3b1e8fa62ba0d1efb40ea742bd739fed21e4bf1ca20f02c57aed1a2021087be506a56249ddeaa9f8b7803e3e185883a2a55100207ad582706f9514d447222abc002b2e1bd7abd2915230de8251681410a025fea2c101d2f7cfca7ff584bc6d0b9770dc46bae4ae79b289de24bf549a1b52823b4daab7f44cef65adb6640fe8d1c889ed5bd022b952c59ac0699f2730937de68b00f47b96e66562b40f2fe7ee8c1f2657284c4588a43185f5262ef55249004988c572ef7cba087e3dee5c4317d245d2cbaff7c546a8cb0002c32e032c82b8b993556232c6edc61bca07c6e3ef647be2bf3116393c1c7afd450d491865341286cff26bb8267304226c4126430ae97773d0ea13f57a4fc075944bf9b8f2d545d98a6b0d448ac8e4d40b8af0b908bda7afcdfc2f2b47cdd82db4711d94c3f62ff29bfddf21a0df74c2bc152e71f78b6d577de0aef1dcfbf2ce37c22abed507e6143a5e9287516710eaf1fdeb7d0ae355eecfce94786707eb4bc5054c412d9d3ac677d91cecabf3d875c120ef7f93b73a65622b5b3708ad4e35037384e84e89bf2251ca4af03794db51a350cff5a6450635777a121a51108b4a92056efaff158f031aa0a10816be799887db1b7e852334283020f19cc06be6fecb64e8991d7a99f86de55f1b48e8b62459f5226ae32b659caf7c67bfbff1b7e24547a365d31e35606bbbe066f4205f6a60e9bc9f731c3eec5f7d9a15d0b13477702053ffd323274d36da4f876893159f524a4e7171092f8da2574dac51f0eca4569ceb61de2f75f28b250a1fe90d849345552dff469214e93bb3c8e2f196c739720287eb2f257489e7d54d8353ba9c968c497ea21b1103f8a3e388d46ddabaf9184331530081c3705bed7c48a588d23fbac15ec29fcc568a5dd85c0752305499d896abf5adfa49880ddde7a5a0e4327f607696b39cad7a4e3900fd4a3ef4f60aca5de5ceadc3ba4020202d1da75a7f78b97f2a5c83021afcd0ee1daf8f8bce558f363b076c97b922e49d048c69e8bc2571c08341d7312dd4bd5efb3fe891f74dd5580f3c35e60d0f2e6e2f46ddc74d471406d7c799aafc290b26322a7c925f29821ee14f8cca3436b0cd8236024b14ae137a27466c9e0ce8851765a061ec684d9ef2b94d21110bd965d05741a9e6299a516616a1a49f22bfd1223c5cfc7e1548f999ab3f8467b230a3c90d5dba1ef9aacfd34cc16bf2bd1676671b7614e82111179c5359c24c342f6526df4bc20a68490f22de837474a0c4ecb8910ca06798d55a12a1587c2897a1f3a5bf4647941dc0a5895ec60d9b986746072a3348559cd10ae971757b1255f6247d495d3ff7bf110ae3e930e9f0d9bf430adc6f38519e6be45561fcb61381011526abecb17c5123712f829111067bb4549a9e40d3ef4939f67807c75c1350dc7f814b5c5567a914935210bb2001d519f071460974d74970c93ef279a53a692373590dabcf45f74bd4a0e123df6e46c05302cf34ea2b0bc00ac316042d85d04cf32c2a15a4693494d4a70b31dfa30cfb14c3defd379b310efdc55448ddef9f8f81a2b2b9e5c6efbf1e573164793d65fa0b537cd14bc236e5c62ff3399d393cc4eb92e1ee618800352798dc1a458495a1c8415065f08ecb2845b66999f9ff04dca341c47a0c3ef64b773e0e2dd60a91e98844c81f2705b88c0d9e3dfbbe7bd3eb7c99e6769b79c33e1cf20f3592c08aee2c200f07c02094d237d11325b533885d6442cdf5721149334b02aa710db53508f03da9ad9c4cfbcb9a704e13abb37317d66f1881ad281ba26de3802920fec9b460eb4f28ed227501eb2628fa4e413ad96261ad7e6b5ff62cb85a29ac1d1356f6a3ef4458a3a9a647b163a7ae0b7f68d63c5aeafaf5755b3c89c8f8f0a1247bf82e6feb8eaaee18dedf2a9d2c958ded9631dd7182eedeaec99325715b0784282dbb1a46cf6020c3d25b9ab5993fe79a1e99672d25f81df9164c3050ad1f495461d62a64235162f47be1edd67ac027f7d9011b6c5afbdd57ea2b7341665a0d5722eb879cec6817c81cf0737ef1ef6acf5f78aab5a6e14de40e9fd3745667b05d5262a258b340dc6329194b1945ad5e2df4d94f8470b37e8f67c4641e932058c8138af5e864f55b4567b034a56e515564ec7cb8546ecb98c18b892d8cf6beec474078bbea03bfefe0ec2cf4a57dfd5609571b6acb19503250ec842ed0d34fc48de7f407f169761ef85bae2724ab576ec8ee51c4bb29d5cb8fa3019179b4bbdb7cd1dcc9e574eb0e5df7efec2e4e67b56fbda6ba582b7b7336f8820671c4b954d54e57e8839c86ba2c984468c0be4ccf0a01a33c701d974928e91029796e3b614b21bf1b90beb3f856917844ce030ad554b4c42a3b370ee481cab8a48e0e957364abd6f23b91ab8ba8cfddb6cc2e43a336580eb8d9372aef92898a266388cd5539fe8d0f78e52294b28da57503910c5a0369695e89af0e199cde4672f6d0fc42aeb15377191f29239fca72a332ed219b0f9fb6c1e5ac9f390553e4abde70ac43a75edcb0d3f876544c2672a302ea3e8e16bf16e77065bd6d55c8a2ca98b09b2daadb1811e5369f72f309d27a0885e615a67fb43464ebff390a9326e2b147293f9afe5a54cd18e0240411601f8f261ce7a3702c96dc78a0affa3f2b881d1b96281250d201e5919d9370628ee250607e93b426d59372e4dd36b4079c1b8942387b408df01c9257857ea5a3701c6e43b199be946c4a3369cf4ca605da28ad4adbcfc86d6fa345ae9dea09e7660f85d4b306f60c809cf3b8a84b941840b2e69b1fca87d454ac48544ea65877e9f70b044e8afa93fa6ff824436ce78ad7a4f22d50e1ec884d330f68be4d5892314f73354ecc606c3f3a0b7304b29cb44f72150b734d2daf12d603cc1bd19ec7856c104e3d1abea7cf8aa2f54f40fab2d9eefa4eb6f6a6b3044f12f90033d12956489807dc86a1b5e0b1516d44d50a21309286bbe632f712966474f23f9df9fe134b315513b190ca7058f5ddc2a0f32d609ef0b23bea266ba56fa91022934e2fffc743a933ff56290f75e61ab8c4b1411ef21e0f6148bbff0ec9381c419004f08ff4190caba3b29df82f27f32e52bd412625a05169e915b20c0230162ef813c1cd56e05d9d2b1eb0d7a22f314e564df462a4c68c9f23059725dd5249620a0b35a68784bf726120303697180d69eb5637aa62adf0ecf619d7ac68b6aeef5ef1761c5101851d01944ad4c6bf28fca7e859a038b8c111e4245161684e8c73b64b71b048964d0e430a5406413f334b03efce0fdd96f27dda45357008884c02e2f6b71afe1b100cd784fd0adf7f299f94ed15b4c4a32295c416160be51a42fff3ad5d10d920cb68daea421b38f7ace9ca04d2c31ef3ca0fce6eed61b0d09aee667cbae2a52b8c62b063d35063df0d5f98aaada80d6d2f2826134235971f328faf28a04345f2c8074283ceacd9cda68cba8e38fe059d0df46f3d8f91b501759021331539274498e2a5126ae72c469bdf53005677852393b87e70342cac452134ee8315d86b3b3c1afc9ff1d6cb7175932c81e6868b2a3aa5b6ebe93920fcd87de4d4a7eda55c5bc28ba5101567c8f5a0c782377e42e918a1907ddb2b5cc4fae4f3e7de670ad26eb9e686eae67398520143dbfa9fe3d039ec7ecbf26994559996fa89575d6720c4c6d3ca15be074e61dd9210dac4b8154aec2c438ce57c6650099b5540bd17dd6e157b18245b7df73105b028daaffc3b7215af257688911cf8301ab0ae0a8e9f9fdff9d716221ee1c1e28ffbee5971695f966a0282d89b4266be0335342f825c35b9ed05e26cdc6efac3b81ee5afc1cd201ff886ce5b52c2fc4cd1a8bade7609929a16aa21d45d8c67b830bdfd1e076ed2652aab99d0cedd2ee45c932657e81eec2f67245d1bea0fad6acf711abb54c8710fec2a54be962cc4b1035eb5ca294ef7873d04366f6a39b6f9f2e056e038ea8b85b34a4c15bfe2df83ccdb6844f7c0be0f9b8f20d1c7f7c54d1a93bf73df05ffdb8cb89e298cf57f93700a5e2528a970aaa34fe7507e93f9c2c01381e5022fb99285e63a70a8a2045aee267dee75a270358a2573e80cf1bb63346e91953958b8b53198a9d1f2de969a17ffd2e39fc729f50587c82c4aa6bfdd25c73891fdc574ad7cf5c3034dec9d94ceadb50b8b27ba5f17b9819c2b218009bfdeea8e21c6818ba115cdbfb9701b6912aa80f64eda67ae7dd6efbe0c02fedba67bbb230ad1be56a0d96f086dc144bd954f2d3432ecc82ec48db66da8affb361154179c0241b1247d4dc2db71ff1441f3050708368b7b3475af56c5cfbafa3abd12afe08f9db10c1e148309c22cca727a125fc42913a79f2fe2e9896a084521b4031afdcee7eaab0737d642e45a0fca2ae37a812d16815933cbfa2ba7bd590dbc0991d6f8a8e1ae9dfc2122f69509b1ad420ca523f38b591a0c323188476dece9aa5c200307c26eb75691a6a86452861eb2b7529ed39937916aca60b5bad5b52a41013991ae23950b63415ec088c23013c0f5374324cd97309c2237ad234aaeed8680c7c964e3b2be675658c494296d5c1612c7d772dad5b5680c9c5d17b845099f99d8406c10ce8649706d2ba1247c6165e62ada9afc79675057d0c250c9aebcb8e3b01298af935aa2ad0fff89f7f2c959e997c7cc9784c97abe742f619aaa1da9d96d5f16cff56f54e98d36359a1aae4f3d5b6fa06625f24241ce531158099e8295e47559a41eafd05f80ab581dd8976b2f021042535a6c88d5c600f2d3248d216f3aa2b844a052121ada08503763a530b2a6253d49c0e317294829f92e66c95f136dee2136f8e15896b9aea522a14660e4a45de4f801223d2f03a767f7e53153c2417266a6d69b171412596caf02214bc26d64269b102231de47b2263c25c09227434ead17eb5c6cbed275f86950ff5ec095867ae8b7a23faf66ea88812cf70cf372b843d995922ece8ac334fe4a350e806dcc726a4a8b9f6ea68a1387ace9ab4a3515a68e7033d861e4f14799b7922a5a95efe7b3f80ce33f0301045422dc624a44968c00fbac893f8edc62205358ebc917e55112ee48950fb6ce1efa1c17f81c398c1fc1488d27d03ddba86e2d19ff9936e8c2791ffb9652c680e40f451662faec3d62801e62793e831a04e33cda747acf5b2a449fa416fc9ce376d335cbfb7f3722e7477e3374362e6527ca34b3d3781be37d3501b7913aaadf32e279825fe988042a588216d4e44860f4e37fdd95eb54bd34b9b159197745976b3dedbfc40af5b94e45fb8cc69cbe508ddeecd78be4180fa53a9a3b9da17ddf53a17e132d44d3b43bbe04b36048419f4cf36d94bb4d3314dd33c8c12ed652efbc6cf313bf940caac51d99efde85c4bd5332c50f9df280f3be7920fb18e72f29100c22559efc6149ec681644b2f61a349131b60fe9029c3b77778d1db2c31fb8da3db16ac8c55297c275f453f0b1b0871ad24bf338cb084cd9e157abe9e78b3166d08391c5a17f20d2473f233d999b249bee020c39967d55885ac152d9257dbcb8dc1639454d0a33ec68d8a68fc601092879c8ebc4912d4147da2cd3b4317feaf268feca71fb20293164c8c250a42bcbbcd6d5a92005db29217193d7c399897798516a39cffc68f2277bfe0a2184ac9903c2670a15add85ad44cff1a9ccebf5d73eaa786e0d0c06ec7f3ad823cedc13f0f9445221e684082300c947e138160d508504c64df1eccdfb3bcde169c9938b91b63600ad563af3b669f08ef0869a13836a4f546436d8cfdab96b791a3d97d4e2dfd76587c503d0e3c02002e3a2a67571b5f575268f36a15f13e7f9ac6ede8c95ee2afa0c1a4ebf6069e66c6eab089417c3f5413bdb22716f79c3fb4dfe456272e6b718f3d34a5604baa2cd9e8723c430f88cf16bf630ff00d4603724325391081de442ae42c86366eec0c46fc7ce6c25019a54ba7a9ebe4db30a753e6bfe9614ed4b307fd5706c271a9b516c64660bdea7f71c10210d58f064bb963414531e7be19f0935414c29c9e9de97915399037210ad62af9d327c68a6f3fca4a330c1abdec7c420a3fb9882ed41881ae58c5ba86a50d88d5ffdf817a0161ac94aaaa22eb4a162287e1a6bc98eb7eaa59efe3dc7771e6b73b11b05ea926128222749dbd0e21471202957c4fc48be097746047afcf7080f9a7c477d0baeb2b562efdc0d96e3f69326ee46711a261a3176d66b1900087bc1b6230b423ae2b0877e0bd3c7fc134e89dd7515d3208ab1c20b549ae0ababb05a65d855c60f8f0b82e5a376d8c23527a8d320afae550eb7cb593e54342e4020486e0b4a6f2e73d1b6799ad1de24c21bdff0bd739e9e25c955d1613b1e4152e9410f966edad72e04c509168842b0da66ab458a517ee6580d149832f233daa6b603ef3eca9bf041a485d42daef2795769733fa4a1407dbef4133ece1184066cf34d61716e79f29e0377b5f6dc31608eb79df5005fd554097a1f41c4e60a8298d373bb772312a46d34febf65f7834146242f8664720c0925ec95b0054067c18bb192448c6cf8a87e3dbf641addddfb14d7b8fc482b7a1dfb62541ed81efbeaebc2dc1e72d27cd017a6e49e32b963c0380a9657b1537ad5e139e1a81a220128c379122f1e1b9bfc67387054cf074a8d7218ffaafdfddb2f894cd8a871c2a0050ecd73a8755046fb9a4c91d9f3e16a3ecd9fdcdf4891d2788bc62196f64ae7c58fe694d9cf82d54ef240ac6209942b155d9ddbd9944ee5e7a1b76c778b4fb8adc3cf474e7d51b756b1be26323cfb2b105c0801b81088a7138cb3ea2be54f717f9c9d62fd9cb31eda9d929a7f26ca533fb0f68785e02595a1a4cd12eb4af83da3e84d502efecbeb9814309691442bbae8136d26458bca05bf93eeeca9dd029a4a3a8c33cf1afc9defd17418f38922d1eec83874da292ecbd1131dedff58594796407857e2c8a32ff62e206c8a5feb05b3cf27b6bf05ecdd819ca91b4221de9a409db8661e56670f29f53651e9db078afcc1a907c672080d13b203a180181deee8e79036e7463a53644feeb207656bf4642d21d8b6ba9c27e7df99904386a2540043233a43cb155cf5a995b7b5e9d080688d5626a0c8f0e0aee022a4e6a071776ab43333c28f7bcb59b1bda37e15b9d0925ba70d1d2fe369eecfeb2a9bf5ae2f7c61817fbb863d217722b1bd907d36543b133aab8aca21113f09f14a3838565aa505616ff0dfbff21cc1c1646362a4f4bde6aeac2b917f8e06c4aeb9e35db6035c7e27a5b859376df00d4a15d315b7d23cb35162946956e1866d6f7af6c3477e5488c82fa8fb8e8bd020200f2a5b282cb77c690695f209ea6d65fd9b721ae67957929f7eb6e27cc021a34e3f98895b0b83ed572a04d399ddffe251331b039563c7d4ec8ef7097ffe44c16076b0858897dcbce7251a23d48b93c4b4f1c25426417e5c0f348a8ecb0a4b12b11f42628d16a16c823f12dea09a220bb0c23f22b16824a6038687612c03a96e6aa2a34b7a628ecf534049b9c7865d42afa6e1f2de366778c51fcef2e4e37029a7c566786074ca428ec900f01fff110546698198ecb6fa28679025125afbddcdd313e4359ade82e531fdbb39b5b10464a5ff3e931ec13b853ae5103400fc5a966ab8f5a6aab82244d263fc008d28b1ae229ce5d29d3cef4289aa9067ccc061b255d7d3be2ed8e293f5418c8aa0f2066892c8de98f854e1b014280180bedce5f59641b23405cf00d77562e14434b694d5954d82c7eba554e0a85336706e056bc1d1d4aab07d23bb673b6a48d2ac46cd8441375d82d8e71e64360376fd01ba25ec93c04647ab45269e8dff601a094adc8b0a9f8397dec2a33ca246152da221efd84c7984a6ec1628b1c4cfd3cea210ed490ed2473c9f8347dbb128d25ee957d3901af64d12bd7813ed0cfd25544f60c8a28bd41574a1309a366b6c72ae9a780473b584c3d85f90ceb98c02c608ce2d0b77d25dd804197638b1e8d3797dc5b3d8279349a51fab7207fd29d52909c3a17745d03f85f155bb7cb5cde327557e76cc20da8a9fce242b4db3dd08831ae698e578ae55b45069f850cd4732482ec97f09fc17548988f09da93cb079c3e61cc1b651999bac2978f4fc5228e4bb7f70917962bc72b6b03aa513767cc3f4245a9aca7649db3fb32a66724285f428a461c5651e7569371058f8ac8ab6960161c575cf77c27177441ad16f0170b0a4e185f00d0174aaf92873b70ed788df016c0be98dec112820dad23ae6c63d478043a3b6459791a96a62b6c5e6c4902e4db97f190734bbb931de8524a6ff7f2cded472c2b30502e21956eeabd8dc49a9d8d3a81d30144f50adeb78088b55e8e6c1b1102d0ed9c2cb465bb05cd6cfc8bff86ad424b80e04681c617c87313837195716d8615a2090c70c92c255aef484e45bd4e213ef479623d3e748cdcbc14a5f1fef8ded71e2da6674da74e02a2bb6b91b541866ac92fc7fc015f6f92271c449f2a84049f7d1eb7827281bb660a0da99dc536fdf9e1d7c507d50a1d06a354f64bebb9770c17954be1170b625902113fd46bdec725466bdec4686bd8fcb710ae6164a90af3e66a3b9d46836bef92dc7bf3e52b229f9587eac3ce13d1e9195ce5f14606fcc22e2b82ca1b26efc10f914f09bc59da6f027c8d822a49f76a6d965bb0a8357a7e5e702feaf4d67b6043da04480aa062857370dd3d56ee207ea095eb6260700a8b96bec27b296931f828d877b9169af7d7a493bb07150b625be5231b955bebdaee70113fe7831cf95aa8a1f8b92b72ed9b23e1739040153af332f433a8e726497e5c57014b74fd23cfe400f630bdba412ce9512bc39700d51686216665db48879baca7c5a23cc059a067847955030816b2c1ac33988034c3593516b80ace15fdd708717e39b4f24fc381f73aaa562e1118ac455e897cb74bc4b7199e929fc8c98094917c24f73c8d11b5565586280ad97c47b5c38ca40e55855d147031691abd116dee38e76e80c6a8e70dde20af0d0b62e268eb9bc8f1bcb0893d06decdcad560c6e127eb42b8582346556826b0f029976ed53973c1b18db03b3ada841a06d4a339ace20ad642f41e7989c7cd906b8255613699ac13e045cd025fb3848abbb839325727b246161bd1f3498906dc1f4a44d8ee49bb68933b20b0409b45b08f6d0c14be24067aaefbc5921c20d76f5ea55932b5d75cdd8504bb6722845370938df5f4868146cb2fb848713960b7e17ae6fd93516c6dc328ba1e50cc94d36be1df06b93255253865c6c43d675f6bb046e4295270ad1094853bd900471a47d25133abc1ac9677b9864d68ef4191cb23f8ba62e995a5b342eb5f92201f69510cd346a8648ea60676ad48deb306afc671f81ef5a48f8f8b06b9bf2f62e2cebd6c6c1c603e90201356528210e29f2e53cc2615fd7f675a7f3c7d96eac9495133f60e34c8ad85b6ca916177b2fb1513880603bf8be620113193e46abb78e803f19bdb0aa18a5e506e8e969e93f26a0e5fcaadb8561e01c5c8f757d43337a21e47bfbefd5f818b50d2b51c4f76155d6df760bc8cd1047b7fd781202528d1dcd7cda5b1ceced731d09876e4f120367a60e53e58da5972891e3fa62875a61447b7bd7c8bfd756893ad203422d85d8738cd989c01dbcf84482179d0c28b27b0eaa3e9448403a254aead942a0124bff34c9afedf4923bc3edbb5ac827dca5d61d2464f5fa2b023c2735e2ac0b992bddeb3e141b4ea3d5a23b631dccfa55e7a36b8c25369baabbf2da50dc0f90d8dc4e34de4ab75cba9f0d2c50e6276d456ed4d8795867124d4df7e77563d642ce8eefb7e218314fb9315ccb5683cddc41dc96fdb15aa6c425863ce79e408c8995a7c4668a32f41310ebfcb3fb06e67d2dbd9d152cefec62708fc0845e83b99186352259d18f7e1c2cd9ab5dce9170e8bccd93986969ffab0ac0ccb239f3f00e7f962c6e6b1c29cb43600e43d0e8a587b40d78070257623025383a10a446d18eef6172cbee2f992c1a9b7a612230264e0cd357ad7d565ce61c0e813775aa9db883907522aa5d45098e8ca912ec99a0ed96e63bb52fa8df2c3fc0264618d70807eecf7da73ba15aaecbfc08a64dbaaa5d1df81bd405b8a7443b852fa9b326c7af9cbc72c685655c74a4fabd8912b845444dacae76ffb4ba6a77eaabc1b8297617ff055ac77c4430235bfa23fe766c5bbdac1637a09b6fdffa3dc74030213c1ef4832dbc0cd9c6ddb73f87fd306e07c244863f7fad6286acb635ed37309b4f3d77e327a41c8eb47647ab8234f5ae673f339d214af21475e81c526298579242b8cf9354af6d5deeff64c3071df321cf4a728f3c43a33b88455d50de234407d455a5573aaab7eefa816d17540837c972515d0cb7c2fcf8ba1e703bbedede4ee86f3940be48f551ed7397aff74b1a7a8597467998d9e3c044b7f0ccc39e41dd1495eee14ca50a4da068549a33ccb38507e66e7e66896625e003159b69d64ec4c1fd1e90f90af3dfdd8d16ca9fa84878aa9f110ae22d553438a9ffd762306447ab629221acd366ef97b55f345d05d8053f80b2f31d52a30446b9a54c9d9b8c25910f3d0fe4c65c71054fcff1f8cb5e9605b2bc15bc6a81712c1d8da9b8151ef0442196e61cc2de29dc3aa827c329949ea79f6682a4b2657877fed8f78101a6f8c8f5baf169c30acd1b3d4b952e209eb8506061c6569001c055f2ddffee78b215dbe2681797cc92108be90aef7f9df29b3e564a02dfd69bf96922985557b47924b90b95db501681b15873a3cbb25e7e67072a25a8991b1c5eac858e652d4dee5997f7f062be0afce85f14f20f63e5777790bbebf5ff29e26bd07c062f36491cdd52e5f4fada0220938f6294232753cdb83c3b240e06243fb0747d5becf0e24c2c7ab3fc339d408268bbdd3681f6ddefa5a060e5851c50e9fe8a0d10a853c3f3ff21551d566a16e1dd5eb3913ed8a62f980797e7197ab425a2764e7868d878b1937629d42c49c7e62f5c9706a9949cdb03694f7eb335ddb5bc9d44f129968e55c4077261bad2d1cd28c7d5752f340d03089d1120eed2ec10ade86c631ef9e350a321b8c10ad51b6a573c08ba23a4da95e17bee1c3e2e7cbb5f10a039d56411754303a762bb17ac0583303b4529bb8412e911e8d2acb29fa7717dbc235bb9fd9a94773e2f03dec6119588f2f3c4eece5de0006130aea9564882cef775fc4b3fea707dc2fee4ff068d7123e6145b68755e46bb5b0b5567a844c52c161a5bf94424de2c4eef2e826dcc1cd885136951874f6b6c5933d0a946af18c3e3d48ca8bb6344a1ca875ba143955e650afe781504e8fd39939afc91b7212e1ecf8f68a4b2b91d6d04a0a1726d3b2af5c0fe729c05863404f2db747b1c0afc0836e1d8b9ffea8f457c16c428ec7a3587b346c65e80225774ffdd0768fd6f238b846f0502a2836a0d1b386ea82a0fd451a1dabc84aea1184a24a549f6eadfa743411541b3ca9ded3040658768e0b3420ef0e018ede9b09501226cabf8b7215d8a3b7db74713074422773b1d77d7cc8a671f741385a6e163c3d0477d91e81cdc67f0e42014e462bed838f5bf26491097acf3400f83fce4938060fb924cb853abc79c187ebc6be24305aeb41ff7f3e9f04020323146405f50f5fb5f326ee46d21401fba5921a5dcf48f89268fd7f53fcc524dc08f6ef2f1906b5922c34f245f1772fc6340efd892847cfea02779756b069e85ed2b2cfa422e34d9a1f28fc322409137436bcc19b83bcb0bdc0a2282572457f059f61a86e2dde53acdafa7bc584d8d125c2ddac81b499c4898f4eb089c9569bbf85904afc4d7982c74d9669b02610ca704","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
