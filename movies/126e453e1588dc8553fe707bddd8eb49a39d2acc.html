<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4664f325b91e631a7935312f934c7c0290ea59dc6469b11ae181f206ce60782b86aa89ff529fbb9198c8415fd9cdd940581bf2bedbb7526205bff7132a257a6e6939b09237c2ff1eafebc0dab72c4cd2585b1a7fcef30774a0b62c271afca50836bdeb76fc4cc7e8680db7639b01d0ee10de3ad2c960fa8b4bc97403e27ea9c94afcfeba6f153fd00dc3a2fde2a04aac0b5ff1694cc704b0dfe90326d2f54dcccb7e946cbb9e2b39cee35f2eb9a7094d3ecf6fb18765019fb71747c27d9ba967dd956c34aaf82b5a695bb28211650985b6b1a9e4ea2b73cf95a21cea2b5bcd48cd2f201b47e1793279837412098ce02a715f7b036e97c998db520d23e394de806d8d90d54bbd0a3a87a675db99ab8a65404c259df439e0718f9480d1d15703ba8761d523f6a209d9f6fcbc1fd5e6b0edaf15bdbbbf6c20efd0b40dccb4f5579c6915513a20b9650e685513cbd099818190250ab53c49cba4fc14ea80bcefb917460c719885c8ca05ee4c5ae615d67ad03469b8e29cb566f01c17b9ed4c9981d92c8f793c2e31387393c5773fb120d94eb7fa18b2a070f612d642f009f56d99f2d2e4b351e5efaacc25e9108c12a6f25ed641d367b6b37c64cdde62353a50dadeaa05fd2a779eaaa6a24b78f7e0f095bea44e0cc44cb39e57265358ac8e4ecaa51d49d927ae673bd9d505417921c38f196331e39808805c94eb6b73bfae76c9b8051f2674383b32c42a01838de942802c289e95cd73eb05c53eff7aa2d4a977919954223dedf218aad7250e77287fe2b535e9ed51aca9b6bf797a350a3af3898499b8e49971708a1b35163d558bed2b454c5efb6bc9dcb7a3150235116e74d742dabbdc1978a299e939aebe83094478eb458c95dc147f6045640cd3768d5c0a858f19754e607de43f49d9274d0f189eb247f62183dc79811f7ac8dd2dbd31cc9876c2673f5b7a3f9dda644e18d78a5bdbd1eeb6317d09fab4343e70f7db139af8a8bc543e7c397942870b74fa906095030daab8db01664fc8d3bf902c804b98b7a3cb90c63af6d3b3eeed2edbd690420663ebbaf12e4661399f79022075831889bd071c3871daaa24fa86631f5aef86e99ad81b9c9c0e2108661ace273d14bc25ac00200569fc5df90036d5140f3acfcb2ecf31abd37b620cb83d057f38ea7ebbb800f77ab1985d239c1ebe34ddffd92c451f43a6461fed2c5463861341473235cc062d5b58fd849ba82754cd548df8d48e98987701c4b66fc2efedef16385b932e5833aeaba9c0f2e1f3bdbd952c29fada681e4e07a432946001d2fefbe0187a9c51012b41c5f93015f3ecb7a650eceff92d628f9f6b04ba7d122802c71f421047246824ae601e4dfdb414a0a11997e860fc871434a75bd8283ca0b650bb8cae1d38c3ec0ddf62af37e8b3bbc967b31383463b3baffeb978265b678093d3076c80a3cc738df10158e4144cd2894afbfd9d171a4325b82c9342d81ab552c997000fed8a7d7060e3b908ea6714b39998970284bd3e3607f98d7c20ce8b40739fa3357d1daed4aef1dc90348a876c2ce5a4ea3c73fb226596096cb96579826abc85178057958adfb706800629d5476695d42058bd381dc8654e2cf5019235d13542d975eefe39f8698133a72fed7ec76579521dbccee59717ff489953e35bdfec32a5df1e64802dc7793970dbdb10f0f4b550767799fcf99fd84112aedd8c3d095cee159d6950302c8a6b8bb27cd07d5e3983830ea44895ea232ad0408efe011bdd19fc5e61cdf4399e0d3021fc6a4dcb8143dd4bfe567e58c257e9d41c845b830c4765aacb90d8c15173601dd1d5b5b1e07e50f2651eb3389dc3ad06fcbd1a992d95e9976a613664d414fd513bb41ea108a08e43308486512d9b676341b25e79a88c90d7a5da371866c0e1ba59f0ff3a82afb701c73f49b91080a33b88da86b142a34e73b7d68f2aad3012ccc898ffb5bfa345a54f79edb50425d8c81c047c0cc53d3f2ddc1332bbb20ddf309fc8df0971bc00b16836e5c7267a8c3e66f9ff9ff8459fb689ea8a95f2b344cd8520036714c38cd3a6548049466c3c570738d71f42a66aeecb487359d77dc4a974dba214506db9ba4bba830dbda22676f035ed4b4ddb0a9a4e27f312b11e19c38d38574ea422dddc581666cac13c36b594a77fd76da4dd4e2f7b83e5a813c9bb6dba2d794e25c47f7531e572e854992cab00d1d62c2c64e448821fbdaa1c7be4be472aa1674c0a71a64c3f7dd1c74e17885e1e49e783b0a9352000a59fc64fd445aaad8205ee53b256bc240c3c85508f19d652303a8f18db1038ae0fc5f3804085ba482f56c4f9ea1af2633610a0fde19b325cf95cbc4a48208406d0342a41b05d668b593c5ea41c63be50e5bab2f3d21cdc9db9698708dcaff23271193f32f3288a2916c29e2624778eab1654e6d291ce8efee4c8aa0e35d431479277fe102448431994eff88bd6af26c182c8ad0f92af9bf6167f5a4206bbab302f2ec2b895a8c9884e0a64bf9e852856453809511fec6e63e8cdf36c7270d5996b1342b6b5cd5bace846292237af457293b39f4db0e66c972b606b93c077999b56f2f20d690eda40e51223e999c7917f9b08d958f77a317d8a43bc91c3010e4caf859d5f0e5b96a3f7e1e198742046cff5a347fd0848afef6158d60b05c2b9f3ee88d5fe9443a53cd639fb8f373b1eef3408bc767cde5c66e46ab3a07d4e118b11cab3086929ffa173004a653369263297b2a01d3ee24f4476f7c8713ca8eaf869362f5ca506596eceb1ab9b498f563fac4225f67788d5ff2d293a77d0c174e6273369a6e7a0dee10e7632d4dd7fecd55c3800983fa59d49a7dda2c68b1fe2b115ba3cecf6714c69b167e9901249244c5782b7e6a46a4ecebaf72c29cbe34f2cf52ecaa28d9e04ce9a77a723281bdb32fac799d9bf73a2751ed7a8bcb0d055a3e7cc43b9f2bc2825203e7a51d89d832f4eb94440568a030499661d1e6ff0711dd8197d101e99737df6de398f0c83f35c8cec7ec195e04c6377ab0d5cb8e57275483e47bca10cdc86a074371dcc49a85d7fce22cf1712322e2acd7a65d5e92071eea1565e1917922e2c1d141c51bd3cd973dd3a60a30194648883d00d0f783e6c91d176042fa29ef7b6cba56e785ed2b4f0cbd85a094dea49c044fde04997463a5429d4191995cd23366021e1bd3ded64f42fdd12936ffcb724781ebd129639e9a96156e76d1f390df40827707c15b7393d7d873cdf122c56d83d198bcfc98ce7e9d339056cab3df55563088e66772aad854bc8692b0657700eec534f30a104aa7f209e6c1164d14ca52c6080baccf71d8406fd873b12d41d34cc83c71a0995ee5f80750dfeb1eac3ea80ef92a463e9638f1d24c9ba784f9f79e3ca620c48a0a35e895f1da9015b822a556266801e83f9f922179a3645fe9d458b446cc1370aee9aba0c0ad34993a1811c18427305ffbaff3433a6d47a2b0c863094b6f73652fc00a20892bd59eade36a795ef8c926c40e3991db0a83ed72843ad15c2dd706406fba160ab23c6c5b6e0ff09e30e3bc05ae533c92d7e84c98b28da345f1ae6d48303fd1665e4507a4667e6c6df948db1c6c73b0cf7af96f3c0ac7ee7240d978a92aa83744f7ce79cad98d78cb98e226f786ee55435d3811e7542df6b9a20ad4b15919846c916ba5ebf64050e3a90376b4f7b92bd66127fa56b05caf467c285643fcee12bf356b9919bf8ade475388a2e6f06ff000c4628cd210355b2478667d46ab77f3e166b1f7723dbe95b7d233fe48f3be2376b64852e6e133acc81b85c391dbda23e2e2b4626f2f7cddb59994d5123858efb482778734fdb8cbb5dd41cb40c9bbd1a423e5ade45bcb395701cf82e80591ce0f2d2cbaa22cc9d92c50c31cf444f7ae62e74a6a390c1b0647f9cc1952bdf5ce4906c57f4ae20ae873af5f3b41b5bd8ce0fa833f0a2d7ef2cb30ff7e08e37309d4fc1e1a03888e2e378d996b67e4f6c2008985142e3b759f8430c93613cd032657280fbb1e9d8d8892c46913a55919fc8121be82f33040614c0a8effe6eb12455f5a75bf0076ed461a419a9cd460a7ca0c29e2ad7ad1001bc9882034bd31d18ee977313af6ffe5b4b95245376a1b5dd32359d41812fd6e12dcce78cae9b4e11249795af28dafb786337d46ca211ab6c58896b3575ad9704cf9b69d0ff753b0bb0082b04e84835371ba6a3c1d367510d557ae2e0dc841863b21603cb63f2ce232e804f6832122d465069b19791f8795fcedd83e7db59ef8a69e197cb2545063ea868403c20be6d0341e6c9684f20a4503679b979f38990fb7f9a4ac2272eda7e833242ff3719dbbc3bec18b90db6afac59df7ecdbc9c6f3b7c5bcc40f52bf8a335eb1ecff1faa90a5e41ad2ea60422ae222e57ed8b34825b13e0d9db459ce82e016479c9a7c6a518ce8c5d2fbf908f79f275a590f20784cc6213e97721cc48f204cca6b78152fc5b2af280591aef93820f5a64d9ca18f4587766cbbf9c8b5a0ad15a81669c83c28e29e4c7c3bf93550caa3107abedc29ae69be707f8c44cc03c580eac07b1bcc2a75911d837d45d03740feed0c3005614c3e605faf7d86318d6f34ff6f77967751660f0d6f0d3c06e033927fe41baf647a87e185f96b48487c9ed962aa35da69f4df069e3685162396de69e952df0c4ea426de0c5a90b5d74cc4f0e597b5036d8771cb3808387b4630de9e6cb118e752eb628204d9b88a0c3477c42b38353fef48ebc831c7b329e48519352b9f0a52ba06d429baab6e9d3abd4f09a8d44070731cb14522fa3af169e720b6a6deb2ebe6f0385d65fc44b723e4a0af2bead21a0a2661699c92d9893efcf07d518cdc07f471ad7d1d9ec823348955a9e296e175475aa6652234afd1afcf114550b5064db771108d8435c675f3787231c852e66ffcbee1256ff6928369aac722fff86b4c9b2f4183e64d84d1872e6884e34d35e79d55548cb5a2dd4d764988beb16af26c5cc6da8163da0ee51f7f395a5ae4369287c7766d172e96b9314ff0690b717c8cdb8f65247e2d2b7213b8b24c4a5f60ed262d7900130d555b063f320e640833d6281a8f89880dea9c90085c223fb9df3e694cffdd7c8099a1268952b0b5721eb3838c37eb41c1e49975a9b7400bd8baaa664fd5f34e339dc4d1ede20f3cb7aee0e5ea56afdedb59a49c7c37e1bea8ab2f8bda21c2e54e1181098be2f74148623763a242a3176efad6ba189b0671cd04b38e49d7bb9681a3e194d0bde533f3c271cffb4401ad4ae5d6054b12367ed9308a8f522e9ea1dd7317ba1603deddbf043ff332c9b8bef651b9b423a0b9d6c251d66ccc6a514706598936a29de59a0ffaa9e1d281ff990b1e300baf794382d82c60e74d6dd4c4feecf7d46a287ead12753cbb87eb4f43ae4c2a361bf2e89b121993999238e5f8571ee52b85cdc2b9e580aa102386e15359dbbc027a852dd4b43bde395dc3f05f0f739586e61c368c1f0db3e0fd163ff3e536ff441f0da659156d0fd179b997263e799203acce522beadc4747599d4d061cc4545a5081c895465c3d98404ac6296feb14cdbd40219734e104d20d84a7b145964c82472beeca23c756252986395490fc6054b5d92d732bff11cfe6143ee2ba12ce0965607d3272d82038da4362d6ae63dc0d214977e7f61e5bf2cad93dacf856c4e659ad4279ed592011ff1ddc9ed2fb6cf2ed28cf8722846cfd98e7aebe1f7267077f23a40c14b8c87aa572699b7e8a527fce27d02afe3795cf972b54b760b2fad7b05dc56fd9bd722232d1ff75bfd7d3f3f530835a38f7e05f174faa154e5894e589ea3157150238d72800dd35a61d9f8ad336cbdd2e4624edb5767fc4e285689f55a992775e6c4663f6e12eaa4067fb962798031aa27adacd8e0d05dbdb6d913d29cb3818c8bcdf9fb97f99510988d7423cb9ca46de275fb13bdbbb071e1430d5d25ffa2defbfb9a904d4d0663ae6daab5072edbe78e2bf41a2cdab0802741fa6ddf0d0afc13fa5ea3d393bbd9ec5076bb7125f1359a93580193433098fc9b76cf9f22562263693dd39e49b437330dee4c681c277ab1e29338e8bbc00d994d12bae43567632704fe64ec8623c289671d4d7aa2624257ce5e751e62d26d1566219899561809986ffc07bbefdb032c39425890ae17196cffad6ec552a786f3fd017ca1a37a757f36147ac54606459b398fb8f4beac96e00e7addc08c5626a372133076e31349c4bd403f3f24c3ffd35d49d707cd846a4801d8081b077b1e57831322dc7915f65247bd6d2f9f2e51225675ea502ce242c0c02c3af8a909e5e340c113a75786dddf6e05fec818dbdac24a52ac58814da187ad046f42770858aa588862667683177cf4d6e791dd3ffc3d98487fe997c54bbc3b4b46e84750caefc146d8801b2d9a7fed0f3f9207b2f7f5e89600e4ecba1a48273ad4f323571fc2b9d158e506bb208469570603309e68d785bd311df6e212d32546fa122443d5796491a6d473d82393cc0d08380062e00aeba073c5a95eb60fe3cd39c701783bef7d3706f965d982d93c58c8dd6f4cdef5d3353c1202154b063ccfd02a045e2dc4be63ac318f45abd16692571fb3d1b0c26d822b6982ea43e13e53211f2e04bb248cf23dd6728e2cb3435ab64f85c310a1383afe5f891d69e54d30d65e6d2b147394bc738e35ffb4d7f7c8974382a27c4d18a1d4731907b6066c77e5c80ef51e15dc8615c983992a28746b3ed6ae25800c25c2156bc2ecbbca2307cb10a75e02bcacbbd64efddd8d236b91084e6b1c389b83ea2caab2803e092423796d7a7bf3da55b78ce90379d8302a1d3b253ba5c505fdc1f7b7043e33e5803f019db5919c3c8c4cdd4147087c25ee2e838c3aee63eb744aa6f8c407e4183ef6ecc1440548abf7306e3564ca1a52c4933b8efbce22bd401559ccc5cbe91646c5dfdd608ee5d01a30c3589b06b1d4f8356eafb016e356d601de5cfd824bb91bf2d41d1f4bbed7ea63fa4c184c637950e92d6e2c832d1bbbf4ffa2c3a97bc884c215a535de40c820a25523285101fa512aa87adca8ea9c50c57669f22a7952b2af8839f9a500694ba3558eb94e2067ce0134eaa674e8393599862c697b6af04d3c55246bc22f1b94436a5d40c0b8a325768cbc7b3445cc439ace04226d7841c1c52a7c6ba8feb4d053d1ae2ef7741c80fb538339ee02613e98dc00db09c3ae2f369ac4a1749a7fbf975f9ee00b4dcf34b462b97fc6dc0433eb49f88baff2a01f22ce195ff6441e8482885f5fb12ee4b438912485f9a5db22197f9a19d5498efaa55d622c689e22c4b8aec5a9b2c45698c5d1cce24c92ba4b68da67512aa12063d9f8a4da6a66c80a0ff193adc521425d8787cb541a5e4733dd44097dec9385d2f772920b3219a0f19bea603e6dd2de3940caff15ea4f8b06b80db77bca8de012df5a69f4d4bac645b591a8491c526d5cf03f13211b77927c7b700403247025ed602b3ee4789bd72edebbf69a532ae2dede20a3eceb61f54695d6b6cfd0db3c25af9a9e164628e8817bd5e569862706ab229be15f38c9558cfc29081776fc97c8b98099930dac78bb9798991673fc1532733f06354197e7d3c6cd735962ed2f1f3182a31d8f4117fb0cd7a2b177c59451c29c4bf6d1cac31800de0c39c78ab60b77a60f3288e0fa6e68b06eb3816b7c2a76fbda4d466b5577894b31d2f4ceb7731414dc20f67990a26743695d9c8cd9a114d61e573bb66e60b74dd750407938e0d141a8c1ca64d71322bb653d7a7a7084a7ecf38f63c3c298fab004b4373cdae4a09453078c4f495af283aa04d63472e89ab2d31d275bae1b5cf9001be44bfa8d591da66241f6d40df3161abbc4985d75fe2ceea5728cd00b10c380299c8a0cf9820153d00a2c92ea11ef4e5947d9ea7c242d1b903219a3483c27500bbeabb5e3c759c64c925f94fea569aef50a8c3ef8b08ae4a07a9ee3cc533e4f622812159811585576b8b899f52c6195147035bc995ec8a318650f8e8ed4ec78990feb2ac631fb1428deb4cacfc801332041bbdd88696926576bc75ecbdaa2b0b57485ecd5bc23000fbbd616809772a37372956781cd23c09cf0d1c972ce706568f56644e22711beb4af21eed63caa88dd2d544d44cbb1a292705441e3cd83f6255bb3b3a8ca9abc8dbb58b7cedf51d57147c058d8ea610fa79b544d03f8e31ba2f25def278cb5eda9c4b25d2da738999bd544c8b1d662de43d5d5063ec39914a321fb4914223402d6f6149cb8e9b5d26febbc700ca4f40f563f8ba30a0320c18c282b0b589379425cf7f3d60a4ec40943e1b2d3af931a34a677d4d871b2d59fd08d5825260dcc2d6cffd146092cae55304b82f26cb6aeacde5c5e7a00fe8b922abe172fbfcc95a6fde4d10930e78d8826e1d8d980a2583592c21f539e81c9e5e8fdc937e54bc1888accdc4dcfd211641f962bba140cf5d0bc17a1e54d37096264f091316975e2491748349451438ae2430a65130f95e67f6c84a53258b32dc2434cce0a240a6b73e620827940bfc4438a360b1617aa97b0a9b6181d279514b5dea48738eb5d68f67d29c14f9944dc48a27f981c4ca9717bebddeffad85d68c94b7ee9b20963cbe70d7d1e85a524ccdf45849a447f8b0e969cd534b1cb524e6bcc490c68c0ce120631856526ebc5e08fd946951b85199570497683a740318f5f5c7b2f97f38672f848d8caf131b57860d93708a108b1fe7a2ed1270fb722d21ada5d9cdc855bca52e26505e5070f3f62992d8a6ee740223960043698ccefae34657ee5cc1ea56de80004aa43ab8a2f7b0f9df9d2408929cbc21ca47b184a0cef19c88d5a42c69c900423a3f6fce715fb61f0cb04e5fce56cffda70dec00042533809eae04d48f8dab4e0bc70ca178b786f081c00933b14dceae67adedb95a1a1b5e8eff0a2fee02a98b9793efa951e541b457c547c54614d4bd951abde8ef1fb52d693a32631f4925d60ade418df0b4a896a3fd2be1a44a26098577d46ec946d38e8b4972462940cc9d651f744172f6580d8da4b33f281f06834ac6bd51d11c011d4b9777a48c3945418a17e7dee0110424428d4573c3f2a997c65d93835d8079d994f60d600fec10edce0240004c1359a09363ff945bb3b44930237546ac7c2d5a09bb8e60078c8bc73a827ed290e725ebf27d17792d39e3bb30a1ddf10adafe45df5dc7dfabfe453d3692ed10ca226be096bd2af56308a44e867e1545eb6941d02538b53beaa88915bd94953e69d2ce27172a706e85dc611a17eadde9bcf94fd2cb25eb6a11669628039b8e24dc1e86d5951503c0f43851b89ef728214dc1e26892de22b430e41015d44f1a178a86e7a6dcd2180762da7529881458e26fbd7817972e2f2a50388a3d7a72bd282d8fab11f727c88d92f815a68c81c882734c88922c2f86405950cea428fb79d2b99a64c654dcc44440bcdb66fb5909bfe2e7768bf7671be340638bea52fad43a9e558132bb7cd01a62b3fb9e2632a1cfbb0dd646a1c7de9c1f993240d45390ad14aaa1990f97eb2774859236502ed1bfe793fd2b6aa1bb2976d84771195679172df174bc205bb94e29d33e5b52a0778a00c8e3d9c24503a3e50621e504999567b39bb14914c6f5bb5a0d35a8ba364776d3e13fd5f601542abfa4dc561856cd0521427e0c1a6688ed80b0fa93b62fcc7dc36b4a2e0bb7adfe1af71f1aca5822b4f0cbc4f0c53c6c444869a1d3d7125172e446decbf5ecb7e9ab0a7d5936066a518a2104f06ac750eca7e7ddc0643a0725bed3a7fd46124503c4abfbf4121b76d5866dffaf402e6af006e33bc623163a39aaa4ae5d26a566231d3c27eff5635dc02d4f8a6050529c1eb17464c9b28ae662911e759ed02b90e47f3440241673ba155d2980c97c81ad8a3b7bd5a729457ca4bad8dd70472a725bddce84d730e5f3e71b78c90a78238c4095d479cd8136b83a57f0de4caf12bc6fc5a5fb42bb9a64089a5220114199b7770e11122be3ecf2f7f0f88c78d25ca9a3328625c00429db61baa7825eabcd9e6eb713aeeb0e3f0fb5928676f90e31a5ea013cacebc93f40d1c0d3101da58657c2852c3dfc794bda12f41924a1797d1d3382747d2fe6c895023ac59d9ea6315bea22584c835a1a140f39d6daa3aad4813abce5ab4b0ea76eee13c869085aeb56207071bc821da81ccdbfa278760dc086b0533d2dd9fcf385e0df6bb35e4c8ddead502293084616be4683233dd02d127487e95e8c50ee00897c3e9b7ff053ee004ae6102d65900db235e8d09232e7b2c7a6c6a8679bc47663f7aa5deddeee91d934f7df4d56164f09d99f44e32ac7a599283962a3945422583991410c8364fa52db3d855fc58eb1c1cd210ad143d9bc722b3167a8231dc38cd7924a55f761b3883b39422e275bfb318f02db1ddf4a643b56d4fc60663fc71931a94253803df66cbf0f59b275220a31479d80b01e7de8ac45f1bb13ec477f37123bdf9cd419795ada2878f3a869708d0e4298da236ca21d59dda5173f8b96031aee04e4700120b5d7b0ecbd2b0b27bdcc8b1c0c67eb34875e0a29b81f06cad961f0028f8f73058f7e998ef7f6e0dd466027ad23c2eb0dd95fbcadcc8d529ef6155e5f1eff34135b0e6e6df6324b3ed5ffea4a1b84b3b494e4e29d6bf3901e81f57b1a854c30a5b66081e0caf2f8ccd117055ada12eb254e25b85a452053695a5bba04a037077d6008ce5d5602ac3fa8d451ffa0ae7b0e695c449d796f255ee17eaa4ed5bf509f01927af7515517e6c73f46eebe5f6e0638e043cab71501a6984ced3e21cb850e377ed8a9efff156a88eab289c73f664d312d7cd87888e7694db8dc3a61dcb6114dc09f2d238e71f1bd787fb903ad4e926ed003c84aae7c8e3adf40650bde0172e5f76d7c1c83eea9e1edc62655134a4b159ea555a7e5cca7c539d378cb684d5365ef27c2a8985c715b80db70af50371d1509744cdde018a6df70cad21dbaabccebca09dc2cf16fc93086ab9e35d30b0a7393c4ce0f730b0df39361a3c411f9312643c4c1deb66e51d1a640bfafd67f0fb39cec8226b80dfb832355b9f8ca1f8f1335cbefcc9769302052b91666b909b2686c7f15e2d662f8bc91e4ee1312a48c6d01e69d34dedc5d0d526d11fbb25903bd12edba6387341973722bbe32e2852a7452a1697f5b42201e3970e7ee398042e5f4742ad46983cff34dcad6857eaf139799d7484c8af4a601aefd767f12a50198052e10647bca8c66a60b80b7ad088063c3ae2779d4b1c64d1435d0374b35d641edee32d46038011767026b9e0bd6f01bc32eb3df980ff246c338ea40188318e318a78f2d1627bf79e89874505f33cc80ad5bc27acfeb0f0e61ee001e52d5f24ab7e3efef409d79c98704d6a5257b4c4702f4536210ae3e9913ede1b2baf405f34884ce98318af4f2eb8b6aab723d393694b3e6c53a6cce2a4814577f82d0e50853064eda17effd31485721022aa42ac64eb8f9e8d325c2f20a4cb8872a38de349d65a1ad5a77b833c0186ad56443374bcd8c0f4bc4b77ed7ceab3b2c5002c54115889c2309057dbbd1cb24bc634fcc0a7278fa658b27967f78b27565cab7322391d8ab26b29c58d3e219b4e1f462b6cbf0f89c55c891e214fba044b088a53f1ceb483e07dcddf1c6b1eb19b523f35748abd346ee9dcdc8cd99c152e7b7d75d270ef086775cea54359e3320ea67501e47f45bda4ce7c7e7c5269bcf7acab6712da38a72fd075b5aa4bf78791af5bb557d9c48e8c13c7f39bd03805f0f7b14170f8f713d562d05fb920382052b28227a9e108a440fb58e8e676a01a138f734311a19b5b1076848661dcd391ac4a42ee3198478446faefe5fdac5f12058eef597cea3532d1d9fb351e6a9b76789c3efde0e2a281445d234dac1c51a4039a917de3aa0c34910d0efccdbd868ee5b66cb7f633a49960e32c2e4b49af86cbb606c887dfce10ca12be2c4ecdc269281f2c199b1a02ecc1fd28b95d70c282f39ee5cad2daa3cb5cb4fb7f3985eb6e052b96520d3fc7d921b7e349d013223aacfc70232e2e8517008c93102708d51c4506bc65eaec2539b46019504b429a20d41900772019b83801979c4b2f1aac6227113ec6fbe68efc5783f8bde3ec6f3daf9800f766227e63665f022df2ba3e4863e5d323328ec3af098ef75c5ab4f80455ea03bf68aa84bc80ee032ed0080f1fbd43139691fbd5a20c7158520c326d09520b9701ea71116f703578f46b96b2d7fe63eadac375864fa3a62f0bae496d84f6b81dbbd71691cd04c945a21ca7b093a5d7d7e6d457ec826499ff7ebb79201b1b0c46f9b0cc42eb6764403bece1442aa14b6ec9b511fc0fd8706a617e6110ddaef673401f0f742b9aa4135830ff4d44764cd50a58f5a003a6b8714427145defe7e392d75ff263fffe97ed15d734bcb636fc2599944ee9d8414438c6a402b5241e49aa69ea4065fb3d620461700e9bf0df0fd4e8c3a0db08ac4033606a97fb53d279db70e2299ca78ccf097513f66864f6b1efd9965d52ff08c4119b10e0b9f9feded5aa5e5af54bddedfef189099c394b162f2bf6299f9c28f648f85e5b0fa4a707a07e0c3386c263f7f4dd3669c6c5b4342c11c19bbf15586443dea2810912b0ba12cdcb3290e25c4c9ff450b7bfe343d53fb1ac45d8c59ffa6b63359852b35ce974c6f72ad79008c9e169e8aa3251db238dbec6830ca154f55700ad57a60797c6f1b3c1fcd1d4446a7060255d7245f04ee45d96d515219fa23e2c345391c713a25b33a1f2cac5abaed84045f815d2d02eece1798c2fc2f708ac5e46c36865d0f0fd5267561761c6d7c60ba69b5d36477e287e500c50dd6a76728005cb9a5060aedb12554866e637a4a731dd3ffe6610aaf2487194cbc3b0c58141a27e67ea0dc3297e34b8d1d668","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
