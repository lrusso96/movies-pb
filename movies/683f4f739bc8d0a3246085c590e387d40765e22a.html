<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c90323deccbc17ad720c724cce98cdf20dac0b9554fa9b33b4d9346331a46da6c001a3aa1dcff997ec72a5ba400d38c95cc2862f5c9301d2d5a0fd6b0c43f160ee88eb5ecfbba0b5ca277da09488d8189983a6faabe249062b7be20047b60b183c3ca4f44a10ea80c0dbe7fa3cf703ab12298918b8c61b48585c2055b6671fc9c15023be92d654c49e7256b0b6b0ebcfbcadc3686f7a3db35c329511452ffa20a5e5388722a94c17061e973c4d24b3f26ef056bb9255670a2f954a09ae9958bdf06e4c794e90368274367e66b149c5e595d1cff15199ab250607063781e150b0455f78d42e806a339ef5097472dd881c5e83c9c611decdfaf474d0a6aef54e4adf291de019250a496744b2ead91f526504e2364123aefe616c446eca1e57d1cb310d22bdb971295ceff80573ec796524b9eb512a8170fb3b630e509b7182b108538d7ece084d960fcf6d0f824cdb85f659c6d620e6169417b692770827cf42f4738ef4cba8964abcdec2f0948afdaa9960f0467729486ce8686a503211a8706d1f13a8a32337a6ce6180f713644b241a3396c795d5a7e8ec93e2ace942cf83937ad18937d210a4fadd0d75746ef541a3497a5dfb3a99068f7a081577d6db8357dfdc9c563d6d59afc33abf247eb1400b9c0ff23a1946d8f7b70b679bdd5fcf117c109792ad946a22bbe390deccde53793f5c1211688415805b16ae7cf44ede01004e407ceeab1ca265c8a843b9052dcb7b47b926cb31f620080dbe0a5b4cb6eee76215b33f1f3934fcbddd1b21fc55dea3e80a869977069ff898e5c9831410a282aa3eb140a2259700454ec39c31216dab64e2f2ea7df0d0c5312d830e7ac47abb39e909c154d48d0a41ed205a699e2e85fb795bb55f0990c138b5fd6185869eecafbbf7f55a165b0845ae3d82fc3c5af982b3a9436164453c2fcb8fab78a735fa1da2af3330ad1da5d30f61e6a64b2b3d03af69af563d2cc66aba38bda882dc674581f2f73a807b6fd6b133a0c891cae6c9db45a7c92260b21ebdb4a360dea05ed689cffb68029b950ea359143724f129cb7f55494c07b90b0e2348731cdf1382671bf7f460557b4d257a712fe0daf7e0a6aff0bf76fbfba2d8bcd2f5cf1741ae29e54b34157f672779accce42884620adb95792ebab2127bd509ba5ff6e54d6d56a12cc0d21e7f9c2655f73f5759f40faa06bbec35749463a88c63bc86a2fb1048767ee4828984786bf9d825c6f251ec66bf951c36a9f66f62ad02e320c995ca4e24f129d086e9a60d9580e4d907a270363a79725934aa65bcbbe36f0c9363d697ca382936834e39180e75ad4fa206ccee71750f51da158fd478572ed167fa3201f3e5558a7c5786390a9f82c48ab429d2844423bcd2a40b01801d2ca3e67b0d08a8f988d0b3ddcbc4596d2ccc01f6339919a37be65b51127db5c44fe6081853c7fdbeca9fd2f363d5a36992291b15ca6e82fc2a3276317cb148f299ef08558094a79c672567493dbbdf147c2a62764e03f7684cadd025563d498bcc5e1b560782ed50c2f4373c418e97b145882eda791bc23a3f9a6a1de36b0711cb1ddde5f77ab2e67669b5faafafed34cebeda3ad16b71e0bf1f6dd03050f214d9baadf19077f3f955685f33a966d617009310f930699fd94bc04ed1a1358ad7e3025267601e136c5d53accd60d6730785469d838627cff9d2334fa6012cde5019e5d56b13eed45cc59889923a93a955e24d8ce7ac6c7f080cb6651ceb987abb6584fe0ccd27f11880d9d1836375661f672d28d0745687e92df476fcc0923142daf6a4c5b366504bd7e719927391fcf1b2442d6211a16fbc46c62352cb4c5c6cae76dc8a0e4097b0fbe17d0157c97b71b3a45c8add23ee0add04fe1798392e5d92a97355c0abd9df5bf334cba4441df0ff3fd9c87856fd14d6ae02a1954b01bcf155efa8a3058cfeb9b93683ec556af0432d49a9bd6ba8ed7ffb7a820112303d78993af892cbcce84d38cd2e80d14cdee1224d5bd3e7b4e4900369a8e8d5a97a39497fc8d974a5a2eafa269505f81e4b6811588c12b4bb71086dd4de8de4e9cf4a32e91e2030a29e1cf6fe28fcde5bc4bec17ad6c032d3ac8bfcf99469c273cc14b2b93797cc8386572b2687848e165649c25ea5f854115a5be0ea45ed4e3e9f1a973e3c104c2b2a0ba344da496c2514667172388d477b43a32ab7a76c795c60d05ad5d064cd4e1223b36699a50ce0aa8c5d528e5b138cd43301a7771da74745db68b60503d5a82467d5307f40a1dd22ab43cd11fe906f86d88b7a894378b6c6483baff4b16e8e34f8c61e16f6272257a8bab589fc7ea56f6ad168748ad840724a1abb36d840a0148246899e49984584a3381dae2516a03f21837b98aa2d6d55578bada1583b851efc4412878a8a5fd6dadb4f15e3e76321af6b91017cc36ef24bbbff3fb6758f303a66158a4e2c649a9d287838c08392043e05754987b21beb7f10d618fb4beac247a6b947a945219c442e70211f0474f5b532d7573b7151319d282e97aa689a9e22819d8a5d46d4d0fac861c1e23e903fc5128265fe73870709f63c7d54d90feb0146f62ff3f767521fcc6e1b6cb8c2f9d121cd16c22249919a92edfd67ade21f9605fa6d55e2c4fd89440ead88ed11fb93af2104cab34cb6cd471d6a3b578e257029cf2395b69297834453c46c99da0bb3e1c8aa7675dcab302cc85802155eeb5cd3339a79528022ae404d50169eaaba2889855c35523a164dda2ecd137ae67d73fe329d193fab8f714886975e104c617ae3fa2a76c637604c68f13cf857771b58b76710e27c6bf26198fe2d6e5fb6deda279e7a2360dae6df253a9d4c81720fae5e2aba42886f9a7d224f6299c5cb5ab62cad761d79fd3fa8e6c2d150417c5c56832def36be55f3ab4e22784fc788729c5e1a3a1bedbda254251004be92084e763d4283f4b3de355912f87dff8db63c5d19dd3a02bc9caf61afe69f0d56efbcae5831fcb4c955aab10d380db08e2bcd5efc2493b701bbc185ade57d0d55ad37be366f10d2cd5550b4835baf22f5f55480dbfc3a7062814b0a70a8bdb3dc66b6517121068c8efe2de5ab293def05ef0960cd4831a81590856c1a604917761e6964190e9ae08eefa812c1d73d7f4a6608d0340181d2f83bb84021225ee2fc4e0bb0a3dc33505f28779ebfe63e4d6110e0ba33e52d4d94f5f1ee57602cebd6992a5a3023eafc89b33e6f4984e7e56de2484726b8e1c7fdc53ae77a218feb3a4fd32b173b0743248b5ab68eb2031a355047652ff7fbd5ef046cfebad42f1b1de462f29635b124c8407572a31c43f10d9fff129a3f1ce5cfff94b8df788e19e5776323e61213762fa28d494c67ffc336279311eae81eb8e8a8090f9f7fb689e7f8a90d4249837501ed5549648751202bbc4f7b110630e4b3f00a2dfe34a55fbd98c8df08be1124bf9dd6874592cc5b794756c9b14f8bc853f2f957682242be06ed0b2baaeea8de396c98814963aaa9f4b81b71a181c607dd7a4ed2348f829d849ec3158151208d567de056bbff46109699e22c7e0856a55ee369b3ba90720bc134c3b67479fd757612bcd81b65fd958be814bcae5165ab5bff70f3887e404f9c401a4581a6ca5afd811bff7d22fc85856f72a2a7ef3dfdbaf2db5eda80dc42ec7dddcb652eb80283dc897270ccea78f335cc4b9b9f9ce5667bbf7a155bfb8573e6f1a3aa13c3190b26453d4f03fb0c99f0b600027e84bda44f5dd76e400c5dcbd521fb11bc850a0d54869ae8740e5a6cab77bbc7b22ab04175fd7efa93c1ce91354ababaf4b04ff04a530251cbb894dfdcbd45fd5e50dc7c61cc16c8542be0f48d6346c1bc5374f4e9bc986970107efb5557358ef53b01e71581c664f75374ec3f98ae24a380b4e00607fec28536fd94ed4a38d8add53c6c156b5e79e3e26defb176aa82791dca75b374502b339614172bef0c1a25852f7a943d442853a59bd1a62a422fe002c71780a3bf4fb340a313b4d158774cf7453889c8d38bba969603698c830ccb2adcd74081fafb86d447ba6fe2c60311eaa4c89268c0401793cdf81d0f9cdc1123910684fa7a4de2dadcbabba6fba57c54598b27a85b2e6f65ef5cd0cd1c1d9eb0403105f3a4fa791028b6b2e93731939886745878a299f687023b2e170a3da16422e1536ed3bee05f498059ab81845e040f1c11e21053ab50e96c7cd2ea5bbe036925ce222ba0237d04b1866243636f2176925769fa46b005ece078c9abd4c2c861d3051a2038311ea4f27129d100a2eb41d66a9b124d701f70c8883f0ffa5b9392cc4d92ab5b4853578d3331de1bd079b1d3d4b4344f84ca50980bf57862ad7eb74c6fe49a7bc6e35c26b543c94a7aa1f6f9e19f81f0f97cdb01ff76e2004fdab58840f84cca61a703770b46da4100ba5b41a325db48c8bbe85f0bfb94283ccead6d76b29addbdc6728da3ba0a7f7b99baaba379a12e1e4863eac89a9ee29be3f8703dc4deaf5214ea7067151d058b23bf01d512b5b42138d204713a9e630ecfaa4c47b992facc17ecfca4530b946c1c607e36ecb47f6ece62adf3605f281c6ad25394ebbef9c3d064614eb6448f65a46b192e076709836aac37a25c4d3dfa01a65f27e66bc6cf64ea7ce086e3479234769c98b2d3da42d5fa704faa034891d5a2a665060a22459491f9793af28ed53bfd4fa63fcede005d256e5640c407293bd0151da8eacd98a76bf46fd00171706520a74c91f62fa8c4b23ca0f70f1e60c8a469b5f2f252df3f1946a7252de5208be5ce0e3af5c6adf3facb9179777d6bc417fd645bc44e1c16c15d37098ff1056696c221b1c8c66662e1f941816fd503e36e02e9cf7d04aa110cc1b77f4be45836fd6d9cf1cf39fd7f46dec426bc674f4b48f0670057429d366d9a5a307e94b9224a3d15ab7dbc23c8dcbb176638acc4b82d10d5042447151ee5388d7204927f17cf86b864890c734425997bbb887692ad9fc465b909a971a1d4d9b5010623decf963c0cad5bf46b346a1d6e139d6f7911aab4ab54414839965073356df3fe7e7d7e03b3b93e3c1ff3c5908c883e79c2ef90c3ca3751171c752bdce80f4adf567ff543b2b7488a0f44d184937214e02a5b5ca7ffb57456ac38610d3337ff56af210a56ba25088c5df1909a37092382b99c6cf1846cb2a0acb27368624183b727861d61b9513a6bc860d7bdf536673cb18cdda7b2535795ecaf6179a48bba7fcd1e4d68a3e107c18f600cbc5ae7985590a33f801b993d863e366e30de18441c9c18f0ecd1a5a3d79d7e4e148abcac3ad3e7df9dc4baef376a435af991ebce9eff8a60c031c78bc5fa71ec2f0622e3824c4d7d0bdea69fc0fbc1777c8a799ee3eea5a17c5b2919ec6c614a86e1449bc64a22154753a5d69abe32bf15d56a71f98955e03f834c71b453d15f7cf4368752a3dd6451cee7343f809dec9869e31b8e150ffb93166541256df66e9d657fbb295c1db114aff45467de5e563f59a6216d5fd666989f34492a3ca52e777c89c5ee4c05117619e6a2f46590466c466b151b2bb93aea369aa6d31d0b7f97cecdfe78129d1231cef5388f991e7eb633b076a1aed15d2b793ceeed2b4251adc417a978df0a6a49fe4ae9cdf86b6503b84b279a74880e069cc075783da2ef20cac20ded65e1ca53ddb9f96613f717c06490674482dd021f14da9673126449db9e64934ce2475e399b0e55662555504c7a46a7eb1df0c842a36163d56bfc586f4aac7eb657189ac63ac2bb1ea452eb9c57d77f3899ba51a746d6cbd5f6e7278f2c62521c9685d18098f0a313b68c3fc0cd2707fdb8655d098ba98f9f1d36f6e17af61f6573fd2abf7486a436eee4d8e24fad2cc65d0db3035c0a50830b02570aa541d08c0ccd21371c32bb3004df1930bd3896a550d65d64107c189afe86e114bc20bd19242716df778f116c04f39a0ba1be61e0a9806a4604aeb03a6bad0526b1099c2b2cab21127012f2c283968c42989e74d2df89f83fec5b804a70bae1d2359584c0d8d1ad65e9d0f026a638dfb8a57b09e50ccc2bf9c59865913541f88b06a63e995fa33b836855124fadcae69e8dc611ae60fd6635f829eb2806373d84f759b6d3f4207b9834b11cf366ed85b67f1abe1ded12432cb739d54259e32b1f5645a35417e734468ce569225fd97fbd5da0a8bf86d5775a193710fa852476653f786afd8b16548302c77ddaf0a38cd37a271da81a38a3fef7fbf79ae70b7169430521356ccef2703d3eca61b8b812780607c36bd14112b1812fe7652b74113436bc66598d63858c73791818e7307e17b03e4d8385c18d064e21e3ab4fdb54b5b5e8eaed110479e8fea6d969c74d0ec2792c329c1ab9d1955e955559fddf754dbdddba7938325b2a427fb2ad01f918636ab4beb7303e30b61e36d4f98d8e9f86b6d7b7808b78140d0bfaf29cb9f1879d193f1da94a74cb0e881005cbe526071143ecbca3059750c1438946adcd3951a37402ee736278092632ee9d9e006a7e16c54941ec127008a9dd72d3b43d5091fe84e750bbe9a68261f1dbc04abe6dd859ea7d4b9de6bdbca5e274bc88410495227ed9cf8ccc2e3f95eed5b5235cab3f97e50cd691ddf16dda29c32823f909a141421cf9e2876e2f32d69b2838c5e438e54e9dd11c5066df292994bf0fd7489ae2065e681cd6d18dde00beba4800103f76365c06b5565d768bdeae72acbe35f148bb3fb5b737fe29d1ab169f0991a7cefe3da185a8f1e77050c73f3272bec80812ec00e62e62d6a73ffb3f7923441097adf82da4ac65a7f8d2547a7769efe0b8d2438ab14b46be6729d1e0c3986f548518b7aba843ebef59fff5c7499aa2a5df30514fb95c690779bfc766661c2eba5698de0e5cd89700db052ac6d007b12f292add46b7166cd36d2f39678902c31421c0a012b36565ad8e4a1453717980872006af68bdac062f08a0b9c5e1941486529c92da72ddbb3ac999911fd7c5f377d33b40144f10362aa01794bdd3cabeff1b43a24f3250b19b6c82b77ecad965ae750e0300c96a265d03b1fb5fe62c6e800fe5df22f10283e648607c60f87752adb0d84d5a1bda09a49735b4f971f5b6b06ec9b782932dd7e1bf1a883b6832dd02f31fd9391a8bcae4dbbfbf27c3eeac39ab62b1628dc00b629dada282b86b21eefd2a853166d930daf2fd8653e909ad05be7658b94806c697514f441c8255bdc2822ee9bbb09393ba0ff5927c72f7db4f7e4a631cc01bb2689508fc5ff927d3c84672709df84ca77df5d09413738056e8f7bec88e304ba2c85f48c9b8c9858537fb8ac05f6a5cad89a03d7d73dca28d4e8a56684b11638b4e3e87c5fa4edb9dc69292f81de6b35d8d9cb259ac3499ba977459ac3d89cc334a37cf828312dae2150f77b58c043e950be2d10e61787d68ec5036893ed9fd337adca97c5cfa28be5c9f418e0a755ba56bf0a74acf1b42c316956f28bc765c884e7d359070cdf19d021f0d22fec1aec84b7f41fd4f894b8e8fd4601eacaa3f8af689a49ce2508787bb0c07e42f7e6621c5d4a7dd81c1a55894a5ba9a2aeb387b90da4ac8a9dc6855e45cf3d23a9f545f5dda8370689d0869267a03bd62dfb6b1bcb30013ccf5ec888eb61add671110a0bec9d2186f9037fc8ae9497fc9f52deb857065797a4ec39760c1769766435a30835c5800bea3dccdaa61d4cf66acf6a9b8535030a4d781d0438a9671ab1f476d6ed23dac963a1e23881a979dbdd64277b51047770e17fec8c97d831f3b867bae997b90ed69c5ff537822185db0ed76894e907abca652c015de38604670caf2689e2eb47dd7a7c6a4760af248d27de10a6e667540714368861817825e7c3940f056ef8f4f50bf51f552c99489e4874640dcf08b8442a32f1933993370ba56f83026164380d89be59111d55d878d38b1ebad531d7aae615c70d000bd990a22fed5f9142b12b1386b640fbccd2f6ee66a37e6da9e0ff9f9942d36d9dad02ef342c958d7dccc3fdd25c6b4e3b1ace306f68b2dfb5d9fc0e1cbc121775c36002f1c6a334e148215b5c0c9726a64ebe5aaa0841037739072a80ced1e540813b3960fcd54a8cbcfbe27246e07f2ca854017fc7925c488073a9a1bd4e039199c90748c9a7b9cacf67942585f0bf7f81dcf33611d1554e67bfa6771c2fe4c31bc24bdf1e3117f5937f67cf6df0e228342d0a1ff3e96cb7cf4aaf0fc1a9d05564cf45d0ef0bc1db80f84e4a6f4df329bfb47c65bf7d6481149d36c2900d6fe41deba2faea0c39b7fd11943974eca8e913741882239411488cfb1c1f9cecda3f6e4f24e521dca04a3516a54c7e04a2a713f0642fa95c7e8e1495e029b42b395612eea3c6ed104bab69647dda82c58165c30d6cddbf0f8fa31243663779479bbcefa5a2f1374df3159844a7fef437e201507e2d8a9b45ddd4868d8ff147b3022f1ac01ba24745038f372e07e586020e7d2a6a21c96823d0f7a0e3149819dd4eac4d62f3744438e31f7324b695863dbf210a230a6d4f426341f5d8f4d0ecce6e9a8373e2ba3b4f7598c5228b1f50a85a1bb5072bdbf061052ce137932c9f05f82f433bedfd992b053340800a0a04e717a4b337a609b2e9e30d24f8b86ab6fc4f52a5fe66ae8897689d1c07b0eb5ed22acc17375f276666cdc82d24a9cb69681613c8804259745f03b2ae617a360ee599ca579ba2cad53130e54502324ea4682f165e5818f06f94e32875d95ba3e857f7118acbe12181d569b1e774251723bd727474927768fe4e51ae838c5d1ea421718c5766de08813a9d7d99cd81aa2ab7333e229df7bd695444f675a9a2e8fe5d027e59ef9d80dcf25407347924ff65762975d89d6ebd77e3702088fe1e348cd872a85294bb6ec632c160e3473567ed6f1f1102f7802b12bce70df5173c1c043232dc9d1efbf68deb6303c2c0caff7a4ded74b8d830bad4d0a582d3515e9b097f097d024ffc711f8f67e70029a6b4fed0f371a236628c3a9e313fff455b3fcbff685357101ec67f5e5f0c38c2795d5805d0ea8753b9531c425c88a79030f41956a582a746429097c269a3c9d34dccae5cd86efcc5946e5d94df02e4a6cb080fa3db2ad5f5fc40ca3dcbd9344a3ec1c77d377a7e1964e3dc2e6630f3cd3b72e92c08b32e551b34eaa91a079ba685e1acdc7bca9ebd4deb95d38e8c781b6bc19c8fa37619e010ea1f38903f8657f8c3d6dd4ae425be18db17c35a8945238f98d7a5842ef5aa3c8751dd9483b15112215192bd0d71f944571a4aed943362ebfc379c1ab5371bcaec6d36fe4f18c1057ef71fd26206433329b19c456c95684809864dee7896558b6627086ab09a82ca52e27114f42c25878580402d0f3b70e9eae1cbaa4fd9bb06def3e9bd899d5db77e6bd3b6145413b53063dfaee3bf49c46072b790ef147c34792364cdbfdd2df0fe7668750374aca875d1933897312641039864cd7d26fd5bcb65c5320f48206825c285b73b2443efc51112285b1cbd18d07bf5492b80f0add2defda11b10cc1e383f84dc6612e5bc4244f0c36ac3ee972febf052ef1d6d102fd79851f0600790b26f37d8951be3c17916a6de6ed6dbfcd8a11628020a542905cdb37ef3c22d11aa529e8c7f6d8a2b8c8782ae443e090bae47dd9e3f60782913e5004f1ac0174219a7f6c294ddef6d45c8a5712238271fb98a2f7a58646d2cce8e10b08adc5aac8a31c51625f492adc7077c99c2e612ac120a7e57a89d1e854e93442d6a3564fc60226c2386c8088778c20790134bb4167c70585e86b4de87ae8a2ce51ac396126f4306d01c91abbb561f9962de1ec6487d6f41b78921f485d4370a2fd6f6e2e36751c44916a52b6e5f0583d7e4cf31cc8106033131fd85540f65b93ff3bd400f9285c7b8f0cadabfba58914e48ca246f22fb7d3407958ab5bab8f4220320996315d917370fe568dfbe800a5700d6b73cbf574de926616a1c03610dd62265616a3e2da310643a83a1867d9f1e0391b6ee912b762ba13cb5d9ffca5be1d45bbdba6624ef3812db862758ffe22757ede0a932866418df47238d17ba6cc63487e6400c1a1c29e3a6896917be7a4c7f9a18ac42632f8fd8ed2456c64e1a7c806f2691d79db8031e37bf038823429f6ba42a806e89029461da79aac28decb1f10492d442191b7b31f3104fb2fb6ef06a905a259dd13d0e00bd85f7a8a7d50ecd118792e50a087c3f4a62999cd6a0f7d6cb6d59adeee05d21276d540f9f25f77cca4bbdcdc422dbfb286d5d1da2db85b06d28f1bc7f058f015ec65b4f34339d8a273f13b897259e4f994902e564726df6bb0e9a0043735b436bc9ba58a42a837f7027fc753b5c6385d5b17a78f8446dfbe29cf3a701103f1d6774c226c489de66e36fc79fc4adf1480459891a0b46d719c52077bcccfd1525c83af1a905a34b3f0c8ba78752ce4677287bd91ecd7e9cd83724c18c122613289c272de3ae348a2e7d11b68c8058544862517b795a8fbb05b301efd82f23bc724205972a27b76888a37cecf65401d20887c6de5452000a77bf9b1fd3026f5d1b0269fdba5126b04a2d77687b282f46df3c0951c89859d44013fc2517d6ed7d7571650bbbe5ffbb79025f9d092ca9e45cde703a6e4aeb1b69f3b379a0df7dc358e8dee76f3ca9a871caa27c45ac6746cfa4dde4ea7bc22db111b4f1515cc08a36dcb0e0787dcecfd4d27de511d76783069548fefc3d282e9e683834c8e2f750bbdb9c0a13f8a36d8a66e18df8cf84031e23e20ffdd6dbcf481480e98a76e13b42505868c8b5e9bb6a46d370543aa8df354cc2c2c03645e323ac69a6658be5d4fcee68c4849a5149c3e08456fcc7c623db33c12d6584d381ab45b17a072e31287386752a98d88243462fefa3d6879e43cc57b5f1e964560b98ffc480e3141420f16f81cb99e23751167b76a925ccf24fccf360e22ce3d8f975ff4c483761c9355295ed97a0a6824c79014f87bb18c6ba7663d9ea4c9459a46462ab6d71f3e3c12e3dad44838a1f06756d49513a20289b66c6ac4c7c8e260cdffd6ae3aac042b0f9cac49f41010838029469441fea958282f77c6b2a495ecec0e3c98b957a17295057ef9ae46edd60e22fa9acfa1fa3345b1f7c7e62eda063df6729968733995d9d5821e9129b1224b61d467a6698c5028d834119623ba7c3374f58aaed32e8c4fb1a0e9f6200ac1adc39701fb9505428244f513f6267b002d7f6dec49bdc07d688d7a74cdd2a6b72613506686d8ddd5b10ea08a8ad7b6528d6e23e96bd1bfbb046a56319d9fdae6071df49aef2ee90a1ef86ecb45b526e0c581c62e8a95a78a0ece3d2deb62655c3cf3bc674a773f5f198365957a0e72ae445a35f31b9debae75005ee73a784cc57c4d6cc3a18f2b64dbb649eb97d1f7d316b9d5705e3632076bbd1f3bcb03eb98bc6b67ec187e9618fabdb3d58a0fdd8c395568b488123d831f408627a186cb6c5ea22f00e328743f0952f28a1c09ec893907429a07072dc604eefc0f2eb1a0b603838d4d3a9f62d4251cfe8201d93a13d7e30191a5a2ca57690c35c523a46da86c8b05ed0b4ec3c488afab9f0da9dad644d9423a5babd1f82871b8e41d8ddad04098d95895e603e5214eb183eac0aa559c06524b4c1005f185bb09a5643c60e56125245ff62c7f0907b7fe6690302f1205526654350aeb239367591557d1bf60436f3f547502d3dddf8332847de76487525a9e5da9b0b78a7e0c419c5f43389a3cd5e897370781c179793f05fa89e30e8940a15ee83c1fb8e58c9d36c1c62ecfd8599e4d1735d9dfde8a19575931d8e1c758132880fba889339e44976451661c7e90b08c36c47323773dc816fdc27738a589efe7a31b43470806dca2cdcf441e37eb7a87daf255c8e4c6edfeb0846846b3d0aa9e54e466ad903d516b2eb0ce844b6fc275b5f81d3cce10a6cbe868c7a0eea1f396656aeb6c88d29e94ac490a58a44a2b3876aa543af0d0e509f9cbf0eea7e5f5c6e10e594680890f494f4c338792798750e602fad859283748a609fbf397ae95272728a09cdcde81436d05725bd0de8557a366b313ec6a6d782bbc396ae2a4ea6166e84caee5683194660b1ff56c48f851eb559f44013333d3614c499aba71dc9f0345e5fca1e1b43562e020c6cc10c9845a3447f56a8b0c6bb553e7c8a9d46af7065feeca15aafaa6d4234793a5d670510f08419722af8fdf936b5685123d22e7154998153aaf753c83eb5c7fa9fa71a6b86033eac26d05d583ef0029832c071e42e475f4fbdec6ec17f0cacbf4301f66716fcb1c46f617500d84b366122bc37493a2b25f2c3a30daa375fd4a2dee6854ef4556efcf1b436ff53668de8811f831825f97c81a499e4177666a83f05864d4b0be2bf609e82938eef663b42ae292c6844185b505c77e7b9891a53168f6be9b725a1e85d9d3bb9d1815e93af1d3d0c2d68b257795dbe8aea1e836e9f7701121611ae2a0ca7a0d873cbe08eb0b7cc3c6b7b3e11567996e98ee7b308176757b7a369c502e2f4e50209b79501fb39a06ecb44fd9469eddc0987673d5f1b1f243f5a028e5cb37071f7ad57ec0becde662f00e0d733a177627a64b903ee08ff20d5f8671e1f97459ba9a4d9e4796df1a3e8d1120faf50b695dbba89543b0b00c3b4399a016b44674e0675a623a5dc5610a0a3ac45467bebe865931a89342b7f44b3ec132acf50b57cbaa120dab0289e624d68ec431dab77f2da2d729dbf11a34ea190e83fac0172028e48d2b388132d432f86b73d0d16188e6752a364f20e71bd8d0046a99c6328bef3689c23e0bb409c7a9751129b904ef29ce16697c41156f1cf3ec8d4a20df49a8bca1ea8c65356bb08424c3d7aced1958fb315e16434104e9d77e247bc5f33dfac91f67f9724d24921b5423a21712e10e276177ba542e088bf0a1e0811a792b271e704fa56c5f15ee4e44a8bf7a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
