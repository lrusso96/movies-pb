<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"03e45b89951e85b8d4914acd09c8a4112c9448a3aea49fd82d8bb65a156be63b4c3542a7b4a6a017ee6b2f6be226b22c91135ed9aca66b564c6370d6818a64446a03105079ba1f7d51e4f2cf195b5910a224f27de3436b50ce30947638a284302c82d69274b61620c4d535b0c9edf05eb75e122f020e36feae411a73651ac382fad74ba185dbf224a35a45bd21fc40a57a4c355652ec72e8fc743ac5c256d9c9f3de519299c337fc22560196a52139205ff628876e55b185c2a65d3cb3f60647e1c57dc6147bd5501ddc2367653a902e1f705c421b22ab83452a8b049575a1143a24d01123e7afe694275153fffb91ec3219f4e10e379865d9579399bd37ee79a12236ba4b0e81641a8d66e571a7b25081c7ac4fc2dff0650f139de37d3e1b48b54778b3bdf1ec26d88a06d2c690c2ae13ceb653c7b9fddee9982cdec427a51393f67eb28ef9fbf01dcacaf7e44a649fc79ccde86034fd1d30642b251efec05f22e93e64282ee44cbb4289d274cb50883d85b19b6a016beedb3b0998fd500e17df11aae55ab63c277cb4ae74bedf9e259b456787591070d49300ff73a45b0f5f3112190d274cdfb7fd19ad9345c65a2806c6ac9421a8ea789520283cc770ed1b9d92697710acbe68ffdf95ba7082c57e88075cd69acfc00fe6dbff8d1ec844b29da646bc0cb1831e0237a313d851b1815fe9ffdd8a6f169bf35a425911c1224277becbf0a4fc16d55c7d99bfb18661b7c69c0aa9c5e2e3c42e1160a4229b4ec84e51d8ad693b005e45cb8e82c3e04e70c69afe813d3dc43f959e257ff6921949f1242253b6b34855af2e6d866cf6cd8c588208493b53b6b4c91e38bd1ce7c09435d90b7d433a27e57ff066096cec8b67529f687f8966b96f5be5bc76f8419c195d0c778f9c3d590da72c1885e91dc5535922aaca215b8b93c718268c175739dfc4059679996a14aa5dd17c28a5dc76dbd9b7b51c5a798354c328792b5c5a00e38547d302182cabcbd37101507e77220dd89a23b55995a4b7ddddf2be785182de849247529f2d6caf19d667708fe05cee9559e896dde135d5fba2c93e023f80762b31ca2cffbf6573cb5e437e63e2f13b7a6dc489a4ac84f08c03b76d766ee98f1d65edc362196244297b3f568a7345a7db04d4bb28108dc55c325e947996a3dffe1cbcd07fc48579637e34c1518bdc599a25ebb0ab275dbc10ffb75ef5eaff5f8cd3edb00bd6e935ff809b0ec70184327648abd52ddf801b863f7e7c438aba9b9e9a8ddeb011903495558dd1db47a84a4cb637aaf2b4297d1a185188c0ad91c95da5c78c3966821013190bc85d701535ea93aca3c576f770035684431d284cb882ee9dd1eefc53dc15456f45b05f0ea01ef18cc1a1ba1ff98df9a5e8971e532254d2974b452f50f2cbc6e4f624f6713420e7f469d26d815ea0a2766e7e844d1553788a4692ce283cd3e6e62eebe2e6293997a3a5efa524c57836727d85dea47e017f385680bb5f99c46172179e1307134c8c2cc6babb625e630360154ce6bfa5e0fe13c9bd8d1d783c2264feae4552413fcd38c642f5b1746b48c1f7a57a8e29bdc990ab57c56da2134622e3475c4db5b0d4fa574d9d89420db477cbd0511dc8f22d5a75bdad0739cbc69ed47a9277eb85ad1d2e4aa502fc8da0ce9e0ccd660f1453a0b4e9d3d408abede5988058383f8b721250b4dce6d3271d31ed8d581913ffdd130f7ab7f2aedfc1e5914e9211e09438c0e3d75a871eee6f499197d79810d3c6cf0ee821ff6915c52e2be4c437ccba6a06a503493e9805ae5f472e4f1a8f5d65369cfe0e03b61c8f258f4cda643bcf55c13f17c04d3f3d824e7f45303a3094080616b54290deb29aa6a9cc8d615f664bbfbd42ce4f7738fc4b595a5da1e1f3514d7b4ebd645b50f30bdc361edd3f566e508691ad8a7e4aadd34cbfa6c507a240f00e327d2323e93facc9cf89e5d8095c1de979f79bc7509aebcbfba74ace0de621e390dae0a9302e8554117d893c5fca61354b7d7244172fc9ab779be10b9ecbe0ed953990169fa47f9d0e2197e6d55495ea346eb654b41984d4e9e674575fc0ac77006f7053b620868ef17dbbfd2f3e04af6641cdfba6298ded2eb843ef5f79461d86bafe349520d80d31b226d8d5a77bae3384c1214c13584d1710e3fcfaf6882edf653e3178ddfce0960565cb5668c180d1957560b1a2ab101e029b13969cfb4c7b830712acec910d2edc85dafeb305b481deea4e48a0e32ae0944f36217b0e57a66fc1f71d967ca59e0d1017f2d7e6943dc2d30aa743eca140fd5bb7f037d7fe612959c59467699a3951094ea5e0bb67c3e54829ed2521042039d9b053b82390b82d20939674897d3cf3a62756e0b67373c8324aa32f8222d00d7ab2c24b1724013e26400fff5397ba74d09764cd5b6d36961ba833e7c580c7d73369ba9d997a24f33999c8c80609ed8f1bed9f15ababbe2818bd44950e9ef9e92950e9411101faf61f4553ab2b35341c140b11702a17e053df5a2c96d50391aab4c190427996ac864bb0bdb2e7e08ea811264a37fff197af556ae7d828c8279ebfa1c343004c9d057f21e0ac61df65fe7df679d8fa30e44d237bdae7087ddfaeb8a79b5c9f21fd262e8d02574c842afa1d343aa147ccdb376ae3e6fea2ea5678aa4c5cfbe6c47422c8757d56c4356e6a425cd171b52249981908fa962700e53d7dd1a40629b53e9c1b3fa2813a3c3813582baaa7df7a00159f66edcfde3c0cf8cf3e7bfebb79a6777eebebd36633be81d683968e0ab32b89fc66f549e0ac6dd7f9a42489e69b6ed8c1dab70a279212850e3482b0d1564ce0c0a7356cf0b6b0d5f1e1ae2f734daacbb91e11b8f6d3fb39524550789f6c793308b9f337f0b52122e2bca3cc5e59891f179f4164cc9594dd093e4008b20dc3a1d039da0b4b2a38d2e7af5c82442c2dc42519750bdd473a3e5fd4894bfe5d24f0710e5c40f53e77b275d07644544b5ee13a89b6e8a6118e2ee88612f2dd9e5dc5c8f8427a88bdcf3ed3a6fecbc3e5343003d8055585ed2199db4abd3debdab2390fb3f2ddfbc3438d7173af7856cffd90ef1fa4e56af3d21aa55918be3e3f69d209007b7b2caade6ff4a40ae61ce36d0187d1c157a80fa6fbe7c776d9daad558181c938315184a8c1b9ade7b5abb516102c92a573737cb870307b1cc0a6dcb81d8196d47f9314fd2c86330875a9238fdfdac44995eb82d12a60b7974c9b53668dc9ac3e1b59247733dc92f4d198a77215a8d725944a53e05730a041b020402b2da26b166437a6def372dc0fccfb19223eea6427ee38854fb5af4f99b4004585400f6656650d441e3300a4c011c95bfb102efc0ab7b2e7d3a2bb2cf9983eef37f537233d18c66a70702e6b3eef10238482cf26ca190a81b3bb1e3e00259d58b12efc17499c0530e13978f132dca7b8a21be6971967fe727852806a4be69b0eda60ee3ef86e028b52c5266191436f6d6ba444c43cc78212b0baef937e228281f759adccef50027e79a12ee57e800bbea41df13783470a0868c42e6bfc6d6ebe907cb1dda5cb2954a0051786b043d86a6b97915463f6aabaf6a6ed5a4d4d22fac405fa3b16cee5b502b8e4fd9a66274eab216ad6aa4bb00b71f8f97347b4f74a6f42e58f0dfd40e1e97d01f81c19499633e09bf8ed05263a3e7912bcb9baac192ef664bcbbcdf57521ca85afec7def9b4f9ee84aa3133504dc8f23188a4da3eae25c8fb28ff8b579b01e18a7bc908907c95139efcd722fddd6f11ab832a3650d0d45281f7c983964d3a31189644d8e5101f04acceeca373dd15b3f676428f01c8625bdc246d32f516eb2f19467aabc2100b47617d446865e237a815d54d36be678329460ef0730639a6c0cd1976d4747fa1266bb17089aaa8df961da553055e6ef59cb29848e0db2de9b1069aeb3d53eed1fc20ee3122459c381b51e14f7ae82df3f53985557915a32ef78b482da9ee13c253d627473554dfdd317c40de7f042339e21ada798654cb2a692d58dd8ea05091c51093f4c6badf4c976d60c466b5138602f5532fc7f950a969f0f570cc3487b6dbea683143aac4ddd70be896bd3717adddb5517629c6f554749587ad614982d72a4db207897ee9d99be0ab62e313861c5d0d9280848b34cacbeb8b693b176bba164a66d6384a74b7ef25f48cb3f1e8526e1b918a98c2b576b9fed7c960e0fa626c75da788a5bc29b4e97d83633804dddfe82c72383553e357b18906e221cd0aa4446c508813c35ba798ed1f4a02467a3b710bc176615b3b105a2787f63334bf0cc4adc0dff43faf26a528d24fd54c53ac71182877a49b343d72381bb3c2dfd9515a223534ef9cdc1830ec274903b5da6f7bd4bafa6d5acd24dab7d76154ad8656cb0347958fd86d31450200a9b86b515c89aedd21ebeadddae01461937d556358d6048ac77373f59e0dcbe4a46bb9311553d5efe2e5deef9be950c7eef22b2fc5f26c1944f4a4a6e29c8046d6c0bffe973d0cc75e36dfa88ee148c9e2c076070da2ac2452c3545b22078d920794cc0803e65c38e02c2caf40ebf92b1dad36fbaf40ac62e2e5f462f691ceca77781e193c6570ac216767e3bb1f0d6fc82402405ca895cb1c0fd0c02e23139dd7f599c4a5fb62f025e1abc7f6c36aaa57cae7e824464440dd698d54fd0b40791bf7f60cb9b82060d28c86820de42a24e5c45b49c870e8ec9e59e2f63fa230f3a6f1a2aab2b7e56b2e0c300b4d2535ea99665547d63215c60ce825cf0bde32baa43e58ebb459a0230e5ed0cedcaf6b81224462bb588e2d81e391f2a891e7c32a710c6908e7f32953cb7a28f50b07f99e4f6c5218d548b85704242baa464a64716568ec90380bf79a4ca815000d9696bd9eddcaa6880f745656d85318bdf9d2019f02fc9dd49024bd907c740fff5baf4f0564ac79916e697241a4dc748ccf75a09505928f035b3b291e38dcd456859c5790ba426d7ba78f82c623467c5fb039a86f89a46f54421ef27a0b1d6aefcb132044784a2083c2c79eba3bf405af0d6315d8dc48f10f347859c361bcf396047b5005bf3657bce1f07a60a542a72c3903f934ac43b7f13e6c10b481d12fad6e938d1746541ee1f632e7304ce317755a35a6101414a495a276884dcdf43c259559e7f94b9077f47e4e49a6808775c27cd9c9733a36e72cc0dbc18555f42fe7e7f8863de112a8a2b89b86848886316452b5c3ef8f4daae9cc6af78a96472c565c5d6a9b5a8fb228d312b86a7a0116be871679447a1c88882c8c37e62f430a5c234bdc6a80cc329a1d6fb10ca2941d8b0c85f366e4faac7ffae0fb9669fa483437a5373b92ba217c069902b6b155a1682190004149c1cacaa208a16bdaeb301099c0190394e2ba6dc45d7e8d8d699f838780f176b710c6880f96ab565b80f3618751e8a0a5625f9a64173a0867f8b9158ef582b2aa7a95502266c65c5f6d4d2645a8f0800e4658aaaf1a000e672b80716f0b59ec50cb185d8cb5e1119b45eefc1d7d046b9b3214945dcc9e6617da7729244d1c14c00e96c8e68e120da4cd91321b42a1433d18a30e1836d316822f48e23237ec640a177ea9c246f86f5e9feb7c61ac1dec889faadfa6c75e78acc2e24efdad25e7bde04ba7a233d1064dd915e9d26125d56d7a640155aa505b94b74818e90b2195b593cdf0858e5fdec78f5304c4a59ae0444ebf4443f7d8972d280387cec6bc373fa0299e66351f4a7393b3ecb5ebe2bca9d2e80bdc2f306fc925f38e310f5b9131004a04a08081668e296464170a3fcf2ca551b80acb78b6334c37129fc433c7595f7d0178dd5e0160367a46565574813b364eace4728d5b0ec614807404d3dfe06ca6a2c857992669732ed034fc829ac7308e0dbd5ff40e501aa2eb4622df8f27c1d303f2b2a0f86ad23b69547d53edffdb7ca355ca0d85e442543ff1ae81da1a84372e9096eee1559aeb00d78f822caf760612da377063e560ac1891ac86ef9a241c79d5d5127a12d42a1f6268a2e0c3640d1416e210355c911050d1d508a0743006b8db31a340453681028b935c5d725501635ed03dc429ecae987689a4e82091a1dc3e8e1229ef3fd736b0bee3444884a16b31826587cccd8f5691e68b92cdb91f44fa414924f65ccad6a547675bc92b80988df1dbf93347d15c30fd9ecc0b04d9b0310382dce12b4e95f4a1861777d3d25f1768898ce3d9653ccf98e08453266d7f750a5801358c116fb07b61664c68b94fd375b75c9c270addeca7f2f042ffb5728ab12231b6a0254ec7a6dfe0dcd54caca0ddf28580c83ddeee6650cf55f7a39c8a02336f4b998369edc0910a27afccea3a3743e7fe1a50cf267056cf27a4434b72236943d40ad8f1f4fdec232c99d61927eaec29f1230707166f0c858fbc5e455bc5f5614593744061aec1d2fa69def78a66f935bb6ce7149f2b9806c637d9e040879b0cc4ccc3210bd48d34d4ad33eaee66abf33d20d2b2e8ddf198dc0e534f9a3785bf9e4a3cf275537376cd528ef2d9724d8330d38c945e916ada4a33f8c4bc789430091d8fce6600199a0fb38dcfaffea74dfe43ceab0eee4297738ba26aaf85ad101cb3b23bf09c6890b695850be92f06bf998a27a664f4eae6c6fc5db07751d5e8cbc3f7e5edd0b4e79e711f8e39010c49037ea6fec1fa876023d8d3aff4317d3d284e036a2953f2eb378a2bad7803d8181cf4ed663788f8b92d2bd3ce289c39c0f16ad4e4ba2182891d10a403dd20e9d921349d51444b1ac40ad520527c0e5b8bcf9b3aa3a7aba3af40ca538607f5833deef71f7b441cac18b332d722a1f374490dac7ddd230e13c5bd30774829f5bc453925ecca69ff2a683e3af5be18b6ba74675a7066133deb7c3499abcb863b7f227d0e69dbabb1dda4c062ae054dc6f65cac656fb8c9a944d6d675e6a21402540d65e615c1a63d9911243bece5717a7980edf27e1eb7c7e76e8e94416859de4353507466effc08e8e2994bf5228a0b34ac730ab0735ac1ff10dea4498c7f4e2bc6f08e7a9d6b75ef889b0b8237871e41c8bda2801c23e20a9f5cf282edbf2f677162b14762a2c4d5b8dcd1c7c11fda2e14995a24eb0e374a1e7a3139cc01029aa47a4ff9416b6d3c45ce233f8dabf27aa39e5605f85e369c230881076b4aa61160ce1a70bdaa397f5b1850ff71b0bb810815b27731597fb3d7a03baf054d8f27f820e8f97a208ad01682db1cbb0a97132081df9ab9af6bfd85a225039299a714e2ccf5ceccdae32edcc86041326d6879b204f20e5fd7e1e5e5317835011c6814849d394c0baf0edbc87c1dc88b7263d866b7ec390a6fc933c5908940389c26965dccf5bb4f126fd56381bfe635a854c22febbbe83bb4e52bb123e0ec0e12ba4bf4eb6bf1382813711fb408180feec8ef8882a8fc8282cb3f2caa8a028133c5ab7195e0a32bfe55d46e298df0c130fab18280f7f60f7072fdfb31334d7f1da7a6b940f476d4d4ae2d51ad08cf34edaa321fbc88d8d57696e11cb060ddab6a36d5f77f6c87fe963be21987b8282cf7641594120f1e0b90ed8669660c6ba2fecb8685a92987ebb9732b95e6dc28d0d5aa36b98da047855dedfb173c21cdcce1325cd629c8ba2b1544560646b47281f60a532be70d6adc39ca3d48fbf73cea752a3df4574e29ee03dbdfef03ba2b728f885ff6936dce7889ad5eefd80203f5ac36d8f67b7d7c52e4ec0e13beefad489447b40f633313546dab8535edd5617f64e1dfad60baad818546308ea8ce0dc33d69a8ab209f3bc255c0b007848d3987855b803a93fd83ad44b9f0047fd6a49e63df71dc4a5e1170390e01559ec8112e9a66bbf1beb021f8776c1a537b8611efaea724d63a4397102f8dd3fa880313bcda08aa6c839f58b2d0d76c5f5f49f678f7107a4015acbba648c56d628dfd930221a0a8d2892f6d1e0d69ea66a0e0198ecad938157a799315482e39346c8ac24c7995f0a9d8db144a79e6e32102fb9e1c5ff03eb664601886fd18f9ff4a8136598695002ae8ce0addc7f9c0bfffd7682ca64c4f59aebceb4ed9caf16b5195562b92f05f1243f5c7925cd16dc48dddadfd1b848fb8fa694753644a405829e04b18475b11b05ea158ab1a5d264f1792fbd3c7e5ee94dca94aa16f797839e12a936abeeede6c926483ee0d8f12724fe25c990e6fbb5da9b771f5bf6bac79168f7599bbefbcc8390e1928caed9725412e2f2d6d6614fc5f12c582ec200e614c0d5a3259097b3416149de9ec5d9d878b3ba653b1edf40d95cebebabd7b0fe69b0cf666d18cae79bd387663445377b0f1d63076d9fd2361bd92270b3d4a79db339a6fbc8b3c2868f993ea225ac72d6b2c09e9fc60807600e92b80433f6bdd54928a8e8aeaa258b61fb31083d062030dafc3588c3fe15991bc8eef2f1c24797de08b0b8740f5c5b16469d7cb20a0df510a0116cc49810a7ddb291ba5c4c7532e6ba8372ebbf90db4df9852899eb5c6634a8d51f910c511e657847c24b51ce2fcbba9b27cd99df7f733722258e902553e65ea76782dfd5692b9c77061ecfac6078db171cad97becd724bf8d42e7a0f109df3726138100e6c3f7e130d361ae689c8de29820a2107555dac4b303bec5400981d17b25c9dfe00cf703372dd0a20d853cd052353c025ee6acd79f4e6289e44bdc2b7d11c17f682ac6ce4221706aec6c7c46d384d8f5bd91c64aefc6ecda8278763ca4e9d8b61e7d42ffacebb144f907d0658a28830b0e493be4c9dd1ee0d9b40b9672b8bb1b1ffc1b6017347824db98f6b702b5a088d83c206cdd763177156430a1f5839274795bfefa0232f2105b96f8cd3e55c87446cb03542095b1debb6d63a2d385eeb65209a998d1414eeb290ad733c53d970da42112c8309b138edb407f4c4e46969fe46fdc226ea858579e90eb3c65e663d57025bd4281d8388512133241d4a2fb19579c236fd024edfedcea837879ba3b94645a2af654a8128aa19f183b272266dddcaf5fe5933e2590101ddfcede0d7ca690fe0e210a27777c471e4ee34e81445aad8b752a360ff4b3ba9a6014479f838d95cb3796e5ee0beb5c6ddfd8fe937ed9cec042df210eccdb85083266f2fa95aa0498227de0225e4b176037f9f635744df0a70b9887044263f50a8c432a1658a24f8311d50c9aeed75ab5a0418fcf4b340e39841d2b096aed5cea41cbc1b853bceb35d842a3a8786329f9dedd5c49fca6656076e8b129d68f009e4989e4bc770d9df545b534d5d6a31e39eadb8d434799c9d381e486bc700ea989166d4e1ff64326b2984a8d2685f2aae8b6f50f6017e64170d3c96e61c9fdbe1d0072602c1f9343225ed24b0dcf41d78d32a1d0c96cca5e41973d2e27807caf79c08600a191e47e8da77aa08a504c5bb7aeea51f7f1ad4b312aeb7ab3667c7c674a83de647b9c0fdaef104eb30f1c00503333969a9962c241131c4b26a25a768a6e00ffbfe10a6b118236c62cfcfbdaa51cf055d8da551816561cc9054ce7b9fb33842dd5ec1c2a331960101118bc687e0a13886e2af3b179cb20966414180aed54c22472edad4e3b8affa7e877c0f3aeb419fa34211132f65bf8fa20a4574febc80a322ee7e853ac0e03d2d0078a6fcf9d2aa3d8c6ed1ff03a558b7cc588cdb5b3a306290573dd49880c5f15dbf7b701e54be92295f2036f0ae96c980bfb1b4dfbbb97a3efc5df4013fc7b1775be44aaa53a08661f63a021760bc89acc4067f22fbbd05d40dfb4a865b280656bca62c85bf67022ccdef45fdf6faed1b8a5b73712797ff2013fb4e80d276e155adf9197090ca4a95096e7b2e62ef162aab31bd2149c2b4bc09e5cbe28360ea0bc204870b609633f5edface734f656add16a1b8254ada8f9b17d8ee7b02882e56c52a1b2513969d12b89ed6fd59c2c2446fc1206fdcde4d07e154293e379a2e27d500b722d91035a4a2f64d1f37974e617946bf81be1b7067002c92649b1f1b757356fa67e2ec12c536c88e3c24c7f76ead79a08977e7320779d17d6c0c22ad3d325108c1cc46b06d44eea7d2d1349d1a6d0604282dc336cb30cf9bb460d1963ec930b6e419ecfe9dc44e18b313ecd56b5855523ab4d16e4008c684528d73328b6e4088b2625fa313ce684f7b1ed273fdb352e51d65148e602fb3a396d609b8e65a87a38e2ff872ce4cc7d3ce50aeb611f99587ec53acf8ac397f396fcbd69d33d7ffe2a580552ef37a916724f98b23ee5b5a3b01a0dcef5108c1a42b12a1b6b2e20b11ec2deb9ca6f089cf062c96e6330a6270c179aff1bbb9fd4c3a96258790df5ea7db71a73dc3c52168dbbc9568a275a7fcef327bc96a4a53ada1780cbb488d926f059333ffe8dad4cda234799968d85b6da5e8a3494d59b89dba819a7d32850a94f2fed1a77f251613aa9e43d5e1e65cb8717e9dc6cc510fa3ab844c1933fb816b98e4048d8ff3fbc916520de8c9c892d2cc1afd4b9a7f6ca138b47ebccb8c5b9a452c8bb22eda01c27381d065cce2733ed1111c970d753bdcc71007508a66954c0df9fd19539105eb4188915dff654c95c1c74649505f1d380855e2bfa43f071320093147af08eebf929c40c8ca063b6fb5faa97dc29b81cb979514d18628a7697b611948578946333d05cb608455a5bed72e497edf0796edab0656cac60d3fde4e7e812c4e6b64d796cb9ee93b048851fb5f6bb2d8570c44b0f4d409ee454a9f2379b06bd325eb74997e220085f6b04bcb48ea6d5360a1a0f86c971e49b7069e35efb053e746914c2952e4f15939001efbb5e46ae33159efee2b65a6f62af650c5c81eff530318dac906977f6ff66adfc8514cce2dd5a865922c4ab5fb8a99a86d871d5a66c994750568e31a24ac0cb579543de49a3d79b5bbc33a6987fc7b18d3a54204b1b65d95cfd4ab7f43a8324ad71e780eb3cb4a230fff387ad9d975704b573340a73c0a9abcddb6d53a67c80d6d139aa876ad1a933b5c86b5085f9fcece02f3e6cfc2c7daa2f719d62379ccfb97917afc68161d34efda87f7b8fe718f41d72caba48002726db0e1641b06760014cb61e546558254135be84ad45ef9cf501bf85876493d3253a1349567608b48f96bdcd1632262436fc0c08b89c0e48351616b1c10e5a3a3a76e3fa2e5a2bf9e2306314a2997c969c0f0ea2e458a14da2e241e4f5383b834fc8992b589094e18b16e89ac2faefe6b71e542340d0bed420f0cb58b9711792d043dab407cf33adc20364d8bd2618911a3667fbaad2554b291e8f4485b4eede8bfb8f48881658261101773b81bc3eb6ecbf53b82daceca1aed1fd9b746cc26d2f4b05d2b093e3fb823a184a6cbad8fe447ddfaa8d6f47c34d6abbc03ce521e5738ac63d86c0fa4a7d8d8829b1070bb91a700f8d2473b203b635e2778b31a0b4a9ec2134d1c10bb9b6206c3939cec18b487d41eafbc221f9bb02c6d5f6f65d6f5784b854e766b94ea3b642435ac446b71307e0800256a1a49280f5854e1f757cd00f2109197c1a63c6ae2642426fa7feaa522b6ad73788a89163f31aba0d60aa596df4ed6a5c9e2ec7525f65196409ea50f293f6076f725d6be5a060feae04a2e12591b984de20c70bf8732cec5f344b8c739031f0b520c9a476d041e71e6da97fa822b9f144efb49e95cf84a2e6e4192e9869e3fcecfe31464d96403a4e94f2097187efd2133a9bab24bcd8660ce2c147ac62a511b1fbe1ff70371284a2f9bf3218447d349479e20a6c6f3b348383d9ed23af89e3e329e28dea4e7290eb3ccae2de9e556e65d996e43aa3f186f98b31773d389478769f9809f0fc9eb4fddd0a631d39e2941f6aa04406b22b3ec030996cb49b43511e52ab276c25b7af13b0753a120873024eb94938053f80ce001b3ae16d70c9bc26cadf52bf22af538c0f54659706abbccd4565295fefba575565f1bff17899a05d8d440a976feda55bd86318266f2721dd28192c695aefbc3c85a2a0870f7c7dd4b6ed6d1a3f23b19ad292a43aeea762f690595c3d91ffe03e80806b6d3574256107b13f282f09cef79ccf2b71da308319f844e6b194a63a5384063bf9538d761a347c4c616be73be5db1d08264ab4379a15b4c37fcf42d2512083f3ca0e140f627af1e50648f401831d2691299ad0156f05fd18730d87f3709938a7482d640fb4711077aca8e19e19f39ad9dc06963b4dc9aebc89a039a3235729b8dadf36242f0264a435696e2a9234f864cef98bc8ac81a55a1e7478f1aebdf56170373b4d00e882f2a475922f7b120101d2dfa1c0d395864e92b689ce3801857444cde9ae7de350148545c85fddf5866a685ea907207a863ce83952789fe73b3766d44f8688f9e52cafca290cd56e5516d8d2beff714597b2785b8e05fd5db3bd176c983475d19d4d5880c9fd94d85221082260b789ca60c677102f635bea2fb323b81238283bc24a1a3cf980978bd2ee8a5eed6814af43bacb85c9c5a2091d4b2c396790085dcddcbd125fb6ba5bfa3adcbdbd25e8bf2983c44b728c84b716393eb2e8a36bd06041c7aed9967e40862790e9fb7c466a88ac4605429f793d8ab1bb9077cc04dd762992fdaf2162df8b821157cafdfa7234f017e2d2a9b5b3dcb8672d3fb940145bf68f780481c26f9a7cd3ac9218b52e86a8b280943575a118faf2531d2602bf1b4c2aace1f7701acdb326a0977b75cd35275e379e0c71ddc5f4bb4d9badba38384748abf8f1213d44bd473caebc3141537a724ef157678edf465eda58c9f75cf82c76fdfe48741d483dbab13a2f2b856c6dda1c3275fbc84b1eaa8fd8d9a0f353587b8c75c2abef0e75a4cd0dc8bad2dabda99dde9c623c9f4ce1d32e6f525ebe74e5461d23c4ae048a178d3664c7e244b19fe304b685065f9269a409907d565d3ff63381d6e044a40eda2859b7c55d6186ed4ebf112b1b179c39823b03fb4fce74536da8f5144aac802b67073232516a2333f5c6c87630f53431bc042fc313","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
