<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e95feb2d02c2b30052440a1c6efbdb1861da0cc79fb02716e4766b289905ae4104378f18069ba7d2239f9e8773d4e51678876a2aa0e69767aa3c45265e2095775e2f4595c9c80988dda88b26139a48afdb897367478399d7a8a0124f05cca6b51bddf70c21d796ac604e6df4c81ce40abafeacec803772c78b1eef89e264487bcf96b19d960e9f750de93af3bcc1e4187a16b92e68ace87b3f642bb7fe7cc2d7a2d68c9a0a13bd28aa13299210214e827c02ee8ecb362f3e07311fd7bb1cc04f77109d6fd1c5696342207183240ac84172170dc8eefd4f48c2aa9877d1ad6f6bcdb515f172f2faca192e29cb592a6b91d89ca2c49b7f4836c37f91635fddf96a7344f89bcf382f60ca8f3a7ffaa04e6aaaeed4b66df2ee19c90ec5c5494bf8651b1bbea80ba16f96b2cd691b5a631fb4ee63b6c3ad36d784f75e2b7c89b55d324f56ead9244a2c8f35e410a1eb107afd8a454714f4dec25040eb903f9456d4061c4c53748007e211caa7abf9cc4cc8568b8e08e952e4e6c12ae5de5fee8ddf9b1b188dd79aad752e33a5ec0be272dfb3c7c21eb7f13946485b5ed894c7bc03080cf223e1d683e7a6fc688e04d9fd0b834d61c015c4f06ae0b768c927684d0fed6ff95da2aad0fc4828e242317dd127948e213e7b284eb4e456ab86d11454cd72ba0855e4e6898cc671636f8fdf82b7530ee08a1f70586df4fceb3c055e4f1bd00efb23ce2278dbd1da9dafc4d2c6af860d94fa61f0270fe4d07c42621f90c343e6fd92e9d0de0f9ab7da706d0a3248d17400872c91c708331c2a8ad484146b520f410312c624cc8694418ab778a941c3bd80a3bd8b47a801f90e0ae8260a1af9deac2cc49ca1141fabe797e78b979115a6feac118f78267b1102eb42a2da037598bb7f134983fee8fe0612ea0014632c15fee946b4039304cad9903a36d0d7819288b66b062fe12e1d92355db7f539af16327307f34209a6068ebea082e9d0184010c435271e56c6f6a7f77ac9650218ccebcb9755f234bbf94e0476cff3c082f9d3bbb5c3605e31fd858fe8c44eb8d109142d9b5cad343d5523440f58145638228f48bbaab4076dec0e3cbe83b4fe16b0ef21a9fe8d0d8ab616606a7f3252fec9e61cf0258842b4ffe4ee332c4e3a019baaf4800bfe68442c1bf4b55b4ce75844d3e1f33f33627dd1ec811ceebe04e3c8dc1446b0a39e2e75fbebe44d81025235c60891c8467f8a1745e65956a68bdfd1283ee74245b8348ee64e32d56e8955081d63e0e07087693cdf1b7a2bca0702986bf25651c0786b0d8d75df6fe91e4e594d4fe4bdcc93f344576fd1755bfe732ee8bd59c5f932bc4ebf776fbf65237f7852dea0bc918caf9e4292410b6a291020657bc610a2e56c866cb9e7c71e1a59c180f8966740e83a7dd19ed37bd6df01d79c2147b072168c21adca4b66a1dfa3abf874a3255282776e0ca579ffe1cd12a6e107275ecf5992f3135c49c4a965bb75fad198c6460a2854c8475334717cc7a93b5595bbcd6a5fb9cc49c70a437d402a74303d7c781ffb307c6d0f853079287135ef49d00ae0891ff48fd93430f95fef1b70d55d6e5ad6d550d1eefb28798657c389fdc1685b1e3772ed541fb4ece25a4a4ff179237964dad538dd5149f21bcca6588003b2f288102446fc6f91824ebae20167991c308ca0fac0f479db946e4e793357108e6823fb3555c35e6ef6abbb4ad89904a05688345035e703850b1a91c199c5bd4686b01ff0df868786abd30b10dd484dccdc55ff4b85bd8b425f9edbe6d699a2217e876b664f6725b2c93b14a01924e84671d347bb0b6d6eb2d927e68561cdd0a2e183176c4f2a460508b05bb0f61e2758365133aa8ce1b7bf3f8a4598af9c8a82f1a0828ee8e35c7330573ec1877975a1703f3da62186cb7df185459971afbefd9a0b157cdcf9c51b3909bc60dbf1d714a493758fc6eb56fa9bf4732c3121c731072aef18776dd243228aecc4b1fa9c9b9acc054d1cb58f46c0d90e2375d436b8350c140705045d97af7b5842903dd12e34121174ea21ccd0eab9a5d490c59be07845b60b391ade2597ae7f80987241e97bd9f8e7aa56fd921a447af2527bd727a12d18afa3d6f35bfa550451674767a5a79ba916a80611084f7d6c4118482240db1004ecbbbc27e8100f5cfa084d742d98a8d28815267c2fb7c3cb31f84aa90d9c934030caa4ec1da226b94e4530872e2c257c9067f3f33b6c02e59681ed30f6bfd6392bb545d804ae59cdb05dcc353c5993f1cf7f4d9db8d084833583c1e22758ac6a715e7ffba06deb9802e9ff2a2a788a9456f23d4225ac1ef67a6a60cbed8a7bfa2283ba6d07d41e8cd1570f952c810774e0a4da9d5da0c90b977a8a0feb8aa32e5338355d35d6f868b236ee4ed899f6fd442872787da40bbedb3cadcfb6e0ed1315244c02d7d8d623f0ba8b0ece6204deb462345373d8cf316d46291b855f1f7d6999a112c1f04f13752bda9f22639597a14aef5d89659aa5be092a11ede7c165df3053025124d703744b14e91942bfff03eec2ce4fa10faba32771d10b9ba56f808ff6c826a168d0c7ea1d98c7946ddf97ba76260a617cce5ea38f546fe5e85031a05c081b3fac17e6d6e4865730e6b6403c75d255d4f6660aaea32e8962cc8716b35427aa3db016c9c74dcca07048f4690fa801ec3c3c2591cbe4a62d9f16f4d62353443651371e81e595e3a064940e39731c935739d988f42f75ae329e73a5e8dc9d2f4fcd71f08b1c2ce6134aaac3e3b013e26190cc7f7493bc0c5d7dbec5079ec746a0c42880e9e08d4933fd712f7f81492abe341fb08983aacf83fc89f0c4ffff760954ccfee1ef9487a6b0860965b4d187069f84341f2109cfd2c26ad8c4ce748444a91fff8e7fed44d2c601a4997718f7447fe2cb0debe20a39988a5313e9c32d012880fa7250176ea0074d919ea61f4fd7611f12120fdcdec0ca00ed2140126d6eae054f59f65a443d50fd45a09e97033846e475e64655c2e63993ec421f4cfa9537e652687b9faa0e4b4a2718df09e5175a9a75f64637fb4a39eacc788f0b7abb56bb59a9584437f885c481a4322a612feb4eb26af67dd14018efc09858fbe8cd094089f3463c2dd6a566c7057a59bd32b65ce211c39eada585785219626ead4cf10789a8fecfcc785bfc2714bb0d791407c4e1348c736b2a6d084a179af85becd6faae7359fb8ad47c4827de4c229f52ded9e28a830945f533da7e06794c3918f5969311bee6fe1a5d856f9ebc375d897d29662795f2ac8693bb4594ed0700a9d331a674ad3f21e778fe2347b1060b766996e3ac410262cc6e390faea6ec54f3079a3a325ea995a1587dc07e7a1d1b3a41ce8cb62ef3719faa16fab29209d274605470a38991fdce1e4ef3da8f885f220d659e7cf0f4cdd0687127103fc6d606fedac7420a1902d7a1cb12fd9e1ca63820a653a1b4795ee24c9c61f10957fbedde71521edd2fac6098e01f6062a544f2d5315a058417f2e49be30d8d7e5d64799dfd3588a4f8b49ac05885858d23d896af3015ed674565968a65547fde559be99e8b0bcde7db3a52de5703b7ea9986f4e8e7e23bf92aa6e9e37ba9fa892accc265c01f69bf1bd0939e97240a2721a230f83a06752826509fdedb0daa3de07d61ad36ebdb564c0e5bc34969c9e5a78444f2a7ad963bc56019732f7d848a883b65763c80a2efa1faec26e84094210f62e6ed294db99a95200f4fd106c4c8f1889009bd924f26a0018b0fc2f22e521d3f1a16c3b19903f22c4ac1705f9f1b8b7fca61382244eb4d116710045ec35b4db8ff1943ae641b19bcd039a2d217b10371c6163d7b6d783bf249cb0c8eed84c5c8754589d3467c54291552cca94b312998670b7fb0b05c38650def58f5f603b5487a21da390b6e75864db3d3ed9a8784dfe12e7155dcfa7c394556d32e4bd130837da735dfac74aa014005a1309589352882ea8430efdb737852aae9bd0a83af96d339ea4fef3317594680895d0b037bf170da116f7a7e3fca456cce3736d149ff75354f8d028bf6e8a3a821b6442562c58330c678aacc345e9430e4b4b05ed7e7079dc5f73490bf1b8008e3fce458d007781596b912631d1ff9b5be91636c887f0ad5d764a17fae0e0792cb66fe1535a5c2b23bf296d682e0a3230370160d220ecf8da13193da6cf498bacca1610eb8fd056fd1df9cab4a277f896e7c96d8b38e0738556ed695cf116484fe31680e437b969b7a9deb943d6ff62902468685ec97b7c8964e398c00019bb24ecca29e9b9517f059c766905b20aecf4b5ee6067d83ec940c4d88e6baff639983fa070ec3dba1950d5fd8234eb78eea3c296518964aa4045274bb0cfb13be5a7e5546468fc2d859ef4b88d9fcea4b87c95452b272094475436046213e44226c8678a0aba5ee72bbe427501ce6e2ab232072670d45267283301a9bed20c4679127ee6ae4069315c87cbe3c5224530f3f64a1b161e8144c0cc0159242d43c9ed26c382c038d558dbb7e002b0f483bba9d6757ebe077884ac2c76321df2ac51ce527845c61b2b8e7d0e228ca68d1ad1fb909d7d67e68a37e4f53693cea769e104a68a75301ec596ffc0227c7d0fa9ce9ff9612e392bb4758cfd29427d36e910b73924c75eda37faf223d44231c37d04841a5ddf67bfb1403217651c267a1fa2fb036441337db0eaef42639b5e50690c5049ed20770e852a00e52d9df07ba1065f18a31381e655f534e1813bdeeb40ee7554a15f5f5b63ebaf3bc3aadcc5ef43a9dee65b6229cf63c16c7e7293c2ea946d8784182165bbff7b2a4e981de35432a4595c7a16a8fef35830450080c792c97f969e258e31158afb9765147895492bc1ac66acd082627ce63b4b562c486347f9670a14995c03b29eea91969aa95547028a7c5e537c1e66e18038cb95189f962166031f2dfe8eaf48faf4363b1ace65d3951f9d1b97c7286a73fb3d9106647c7643d9265f610fd4e3ec397331b1405ca75d8e36e96c15ffaa81a71b21cfa6f28bd9c0c0f80b209008a24d8b32fab69679343abf1cc02ee705847c0123380e834652ef958dda4ac1fbae2248683447ce93438a62671ea400c3f3cbcba6496c4b91807cca3c941824f5d2dd0fb097a185ffe41c81b44b507b258835cc0d7c3c6124dcaddd1b696ed874b2610474aeebac7d610a10190969972eb3825355031991e31bebc72b1cd40c0de792f4543a5952d26da4bef7b954ae54d7b9e1aebf232c5b16bd8f77cce136c3f921eaa15f03bda403aa3dd206cddbe046999cc35ba0bf111cba50b1af0b10f55bc1896de6c9c1e9e993e9ec55e6a09a97612d4638d344fad49719adf3482507c80258401d5c99187da5f3f3c958c6d33e59ee43d9493a1cba25451bc4050c901189b2dfe6296e7bfdd934c97ad0ee7ced618ea9d0b10e164e0fa2d3280a0d83d47f242ba7599dea412a1110e3e244f4e5a84e793bbe5b78a318cbc9dd8aa58b10d4a4ad316c46b929658ed6ae897907b84dd6675298b0f562fa6016c0845c135b6bac562999c4b9e03ca39735ddfbe470d71e1ff5ed4278ab87f3bf333da3f9c51f0379cdfe930e430291ad723eedff5ce2afb3e5ca7a9c5ac827e39d327cd9ea28dcdf3ac2aecacd9f27920377759a23801a0e932e0a684c87a266b3093337d18c0519d122f17750d45473ad851200c007e176560da5877943c33e95195e75aedf621fdcd36a2f6246e4be3b9358f9a77dd5a20d6add0dda3ac2f4b373257bb0579f77381b4d56cfe2d8c3242c39e04946fef22e2a59535eca82050722e0fa3c28103a1cbc3da266f3275ba39fb15f3a8c8aa89c5ba4b488df4a5060287ba034ccd5b3a37909678c1134fcdd6d7fbddb44455830555334f0adcbd145c6a355cc2bf430879a1793f442ee37a56cd44beffa59d2dc1bdfb533113a4698d90b0bd3ee8bdff7c9febe7dfdf77af029dff06334c881860bb2296d20d1d20b99bcd91960769f2de410fba7112811d8ebdfb4134f5dd6b7f694df660f8ecb159ba35d3d5f8e1c277f549905193188e9e335941bf7d91dc032a797955a7f9d43a55965c4ad3bcbb6f4a083797549c986461475fdd95b9751f125b3d62ea6f5e3c0a96a5fabd4dfe3df06cad8ad5b53ae565322f981d054a610d63fa605048f99368401869cf781961aa28ec34f16ece8c1bda4b6e82340d6cc11e61b68974c80105103be4481b86874a047ee800877f0b94920f572dbe06a1aa56958de666c81d77e2924e23a3b1df4208331af09d3130b6503833755c0484f7a452812c20556806294b634b3726dd4c5a140762a32613b969a8bf6d47ee8dfe467fd8517ca3dff71448f726af2b9f1994b358d8313d9984c4d1ff62a5dd7088ec829c0a925dc2e17e0b0686b2deaa218aa0f20f5ed3937e7cf398c0bb77081d7678e9ab0b0234a7428f760077ca87a410a526dd85369d7b5db8d6bf25acdef60255bcd007c7be7d030677ec122e84e4f3cbfe235330a41e00ad4348547d737684ca0555b7c438595407aceaa72f71ea20efdbbccf464e25992252ff9d3a26aeeebb4b26d8d3bb273617d385f5df56046f4807a991e6292348ed1fad54c9bce24be1ef2d191f517a8d94f068cd5fbfc2367d8fc98d385a02c38542e3302d84c0c27e4f44122132f5723f07b9c8f871ba299e3679897bcbc02d4f55891d906d12d44418303e4fde995806ccb7a07a05838dcf7bd4ecf8901a4e0bf52fd037f186d9622f073aa867beab578c2c4689f762dee0d90ee70b729d3d5d91323534cd8dcf50d3df668ac8a3922230569cc2e22187cdd50fce4d3f91ed36f2f69b74c35f455baebb7633b27b8dc51e52bea417dc40ce67940535bfc282d9d9e53eecde1dd3b7c66a55e84500fad21dabfde9ac99ad9ba323a08fed45df1319d88caa18dff3eb2470760544ead2935c70fbf717a5e2a6e751ef54a80787ab568c9575d7ea4fc8667ff7180b506580a23df5b29bde89ea91f32f67121e7dd756817f57d271902fa548653b58358e9aec8cf7b66a7c98ef69235b9ea99cb6bcdd5a5627b9d40693c3a7cc57c2ba9b76a1a80645091a6d42cb87096bff1551cc089021e92915adc548e951859f4ac6cda3aeb935cdd3f70303245a694f97b93c15318c006f70e4260392127c642956b131d08c66bb94c980cf62b4cd47e818fdbce3d3eea777934052659998160683caf7c34c01791554b74b4a31912f441d68ec2b4af6af735e9b8b529717cb78c7c5477fcd886f2ef8380b5d92feeafac4b761cb82073789e7cf6030144a130b7a0ecc50ec797129a08227b62153265f6aeec7c89de904896e1dd55f6053fa8571140f6e30700be4db9fabebccd59a554ee790e07db04f70ccc0ecee0535ff00f67fe9d7cd8591d59a60e7a8c0a0abb130972ef2622efcd5c13810e5bd9f2016938df230ed23947221f8d29aed47019efd99303aecbb1fe410ecc07234004ac1b42f7dac0123e4d56fa4ff186e485ee2ff8ef057d6458ee242a30bdd48ee01df5e43a22d9e984f0522caca44fbc0027fe59f17fbd04afe67b4d78ed9e019ba4b428af12b9d5728ae49e4166bf95815007a265adbc5a14354dd71ab3fa9911c69a2017e7016fd28303c2715c591888e71b3f3c53612eb20cfaf271c9947bf002ef7746590ac35f6a36f2e4e0adfc80e68037c645e0cec3729f52594c5f1628c9916acb26db6803d4b651791278888bcfa9cff12d3ea6ba8be0e8f4bd292caa386ff926b641172e25570a3e812cfefce2428f51afe5c355b144ef1d030927faf3f67f5a2d31883740b72753c02cf27855a8c0e95fbc9a7c0464f7effd34f35fb6d90d3d48ae017ce96f54caaf6186190b68edd9cda640bacbd1566d5afbd618b853f7261de653c2e8a9d535eeba72f0007badb191ef9c44b689b12bec41e7d3ef602a9ffceecee51ecf8acb1c354a06dddcfb79e3045ef3f96e38a1a3ea96c26519bd49ebdc21c3685efb6981fff10ad0fb958d05584be411a4af3e9409555998b5c1a5552d62fbd437e3f0e3dce593b19cc41e35d4fe8782c44f38b36cafb56b202bb07c80b6d180aa24c6addd0c0c3b0dd4c5fcd8ec25cef4167669b35c18383e56d7b1c8ca21c47e174669bc3ae1e24c14a12fb989a9a17435d2953b3f4e2cd36b488d0030177ed1ba4014d6074d137e62ec9536eb4597309acd690c68017cf86c5eba424ad290ef3fdc601ccfdce76513e833280f93eaac7d0e34907f14afb29b133a2ce602480b3a76ad5d504fe66616fd915d62ae7d3fe21c6655bbc3e73cd2d5534e47274aea3ed9c706be244aaf4e5e48d1e3d1d1793a48066ceeb3b767146d2c4c2f3016cab017106f79b67c55f5ccd434aa5937c58771cf343fe410a4048c656f6d5e26d70a22a129fbb7bb683adfb3bc2caaa6d3e10faeba5ed42d060b6f62e8a2dce53c42d6b2549c420f6047c78bef1cc6a4712ac67eda7dddfdaf0af60e74d6e5cb0301b6656e9b5ec2eb6f73f0070fa54e4098274fb549d6ea80d567f41dcdd9639d176cfbd71b5847725f1edd92c439b86523530be967d4953d67d3577e573ab224de1b6a8676eabb7701c31de1d5995040b7b78717808ea66106d9cdbf98a778283b3d445a3cdf4fa6028de26a04c0e8a571523ac52dd8db5e6663ca56328b7137cf035fa2caa18ab0c29f2f59d93f24083447d921dc10664af7ab60dad2504f45d49b09d4bcd91d0f2d0e1d76d6c33f59680ed3855ebbaafa1976f55427f49a203752815503c5ae40e7e50492d092bc7170b39ce491d454ba8c6e592fb810b4625fb2f159c1789d08c7078509c27a69c9b8e80734a7bdbf75b4f4594d9bbf6c68a97524c1526a6e3242fe33da440df2390748b35658f1c044658a3b8a707687e69550a1b6883e628472208e8e2d67ec36cdbe077004fe3511724a82341a6ee27e7fc408abe96a83e257bfb7ef366b9daf84ca7554dfd9777c6e8c02058b78280deccd3c949d7469d55992d3af6930a49cc7397c3c5f6495e226ff0f0834008c77fe3844d0b4a9cc34213bfd6aab55c7b2ede4b53129b5eb3222753e435201222f4c77ee033b0f1a244716f9efd73ac54699c16e61e693a8d2f0dafa41279a5431d1a75688a2d1d507e1155a8f3627f7866249f6841d158c86a9ea73939422be974776f134c888caa2d283015c68fca9ff1c5765916541b4ca7e280c6281bd3cee2246dc05b22b93f112eb4941ef94ffaf41c83d03f8dd02e3ee5fb9bef2698e87382aae2888be2f6ca45d0be96ebee11dce4018e4506673823c3538508237b794c1deaab2f47a9a523c9d7be087676e475287b583dee29537f866ea90dc7a263b89b7ebc76766ea25e54cc07dc5e3bc1582078a4d043d960e0abb8af17f9dea44b1ae72c6f585f8fd1b4d47a21b1953517d098ae7d57a7c55cc6baccad3e29725b1ca1f22c62901add1ab4bbe369b955741ad1fcccb09ec8e02bec68ad447c3dc0e2b67b2dc570e60d6cb861b1155df0a6238c36320ca58c2588bc6370a9d907a984b2269ed04985b6135643e889c49904d6d5b9a3d26e6b5b77db65adc72691f88d8d27780a60ecfd54b10379ffcb7ef5ce73b91031d9c68d09e67f1f1f6f449601eed548a8e0d4fb6b2cd5062a98f17b08b8b295f537cecb6909ee08caa00adeb155bfe68e7361a0b956367b0641dc30614a84211c5ca8a07a4da1d5f5be249dbfc2958411df4e6911c2ca2b177d350cde6327f45912ff221b8cf5ce14499b98702adcccb1fb01157d84c2b70c7d7d7b6117898d150310f5009ea6e0846bd44952ea3aeb3161aac8169bd367700030b0ccc659a8cfdca7808c1fa0668ad2cca3ea3f7b577a637dcd5654c0ef5807a1ac9b404712d25ef67225de43afa8a49e4ad2ba52603301bc0a89143ac1c2576710bd02cea7559b71a20da864f03855ba879fdbbf5299b7ad47d908cda7150ad171c4c81a5ba0e04ac8f23850233ddaf7f471cde8ae02630d989da1c1f39e64bdaaa3904c078b8834efae07dfa2d97220e7e1f0a7a6dcd7db9238310bf7bcb40020b6b6c618d5b478e0cee0b9c9a644a2b343299287567fd3f56fa30e921e8e768f46081391801c436efe3bb64abdabd5230035d32979943778e460b64d1072c6746d5303320dd3d4aa05b25061cda121c154941aedccf448440801bcb95cbd2ef6317a2fddbf4403d19b79c0d48474dc79b0f77f9f960279a06686e927e413e0438c014905e51a87d879a62e98736989a1d7decd98fdd04333092e1a10ebf4c1034a4dfe8536fdfe1611e29ecbd44299dfe9eed2c96b08d68126d218dbb4abe77e3af658091598ad62d69c9232e4e0ae0197e7ab8c25ec121dbbdbd8c6f0cf1cc4e575f728e56e385fda6a9046f3182e653510441c1030159cd57f135e602a3c53b1527407e7d53014d9fa57f3912907943354b82ea26ae0869b389baf50e6a38770511d1166980c7b8b7a5a96cec2203bdf60c9bdf0d60798f93c92e7df03734a27c5f505d2cb5fc1ab39c3869210c87160cca0bf2c16e012c49cfbaee82a5dd819191ea31ca5b11be78a9e1cd409dd6ab31027e56fe42061713fe88968c92f1a3c427d3e5b97be7a6a2885ea92edc8e1bb7431de7881a04ff80bf7dd8f1657248646abebf19fdd63d9a3ad6d48a855fbec0aabe18d0c2773013f3353f8407b487d5e87532754ce6315ba6c9edea6038f809275b3de43708f37a632fd3692dc267f6b81459cd6a6f2ed13f26dfc2ff6952b26e1e5cbdf2bdc21b17b5a518082c8818d7b0b72bcb6bfcceb34be732215cb1b16e19a5614792267977bcdfda06798ba0bf4e6a99a8ec943ec8c76ce101f1999cc60565c35a99b1c4a31c0f70017f3ddf7b9a2d1f6c98e5d32af3c863c85cd269e5c8246c5ee5fc4752bf8d40e90ab13ce8489eff6c226097ad563715cbf357f08af3b29c65f859e3a54eb359c030fbd83dbcb8c47f23189974e194c826a81d612ec8f9b303b75606a6657023b4b65f536db394c90dca2952ad59e56d6d7e65e202909cc9866d352c87371d5b9c5a8c53ec58c73efcc0f62c89d9c99be73346fb045134d2e2ad93e5bc8d52b7d2aa90e36670b8ecc0e19032af6f7df3c76f9a1ae5775a1c2c1277ad5b5795c9926572583a6a8100ad44b25301d70c48231db63cd77f84a85c865df7ae6fcad88405f5908bb0edc3dff8e18c5cfd9aa6ce2e34450b5dfd77a1c3ab28e2269a2fd1a7cbcbe267caa5c53a4ef1f0fedb264a106a0d107e0fe1353cca2bb011fd77ace1c5f6d1bea650c2245078d94b0cea2123b8db9426380a1af41aa2ab00943c68c073bf2f39a79bd001189e0cf8f41f92355217b0dd312ef123d4ab04e20ced3a50d7ec206a722f730abe8fe35c25efbab59471f774011615fb9cb07aeb99678ea7e14be8b8410d0936c0435573a144a3afc513931bc0abca54997c860e3b7e3b52d6ead85fecfe6b942f46dda55d44d2f01b9c8eff835bf7fb1f26d4c21f6639322be52ce055b7c45dcafbadf9b2047d25a6cfa0bc5443247c95dc257f6c1ed07e8e199edcfac03531dfc62bdd6d7a4b71ff8c8ea5367c91d2363a58b45347892a50a202dbd22ad6238a872ea84ffe748ba27ab826398319d2555ea89d4289a905b95a64b29e962633dbbb982f7487fa7cda5f608e0dadd4b7240717590715e2ab2f6ae0895582bc94f798df8fa99012ee7b8a8d8dbfb9fa8a09dc52651bbb31cef33064ddd981b426723cb255488802ae14ebb1869e8e371273d77e20be098b3d0529644f6d12961f520caaa9e458a1401c47ef51d41caa213e3eb7cff59bbceb0d93ce46341584a6d4d5426da181377d972b20b032a87eca5fbfd43def450e5dac53682a363419d8f5a32378173437d07a349af61fad6dc7857ae52389f991e3dca0b72baa2c1dbfd14995868b5abdee55ca840bab8c9de03edf96f8b04244312ad96579ab36747ccbe9f936d2f531c4008d3fe51e1bcee8c2646d0e3ed873e515aaaa0cca48723078d01c6e97a7cd3609b7f76832ed0a0878931dd983188fb63250d1ac1bb1ccdc4f2511d69e1946af3e89c7d2998eb859671ae9832ff5224020994832bb199d004d2e5c95f3cb3ac2e5ad1803486cb66838e432578a75ddcd131f8c9a2926235b031f4387cbe0d304e92321f0c8ebac5ef32c7b872252c8bb3afbc8efafc9a3dbb9222a82ccb45c0a46b70bef4ac50286c0400c3831949e9b9f28b51ac558791ec118be46b30334f9e279023b85c00112258b405479acf88366723366c67dc1a95aee94ae104414b24b42ffbf8cea594e0ba05f23ddf32e6f0cf48dbe5de5967e6f99cef7cc6c8f18798c15aa92dce476ec8f5fe6ae6599769bef4b89910a3a654f799fffe3a1b435034fef7d0ff05999cfff02df47fc670bfcd124a3c2b97de66e287b2c2ea32613bc72298d22c4ed46679a16a778422d50d6a0e9a7bfb8c7445301c9a02f15020246e29c7d0a0a0d64a2172cd54e7c1804f287a5dd0a6ecd6e444d0c6dca33fcb10582a96b6b251c7c388d3df3f6dbbeb6bc85da226eca8eaa58808e255d20dca29059b15ba29dcdc2424e8d9f62b7f28f96f01993d1ddc2ed2f2339a10e41a77092827f3b4506416bb8d4417daae406537ba5d2714ad3d4d0be52ead5ed3c40e434449544b248a59e64e2492bc172759f1d6a1e7aff61f4aa6fa0e5b542bb1a1bf9e6bb048bf5c376cb148011affea8efe956f9eed2f449098aa6728d1865edc304ec6594d484b13625eefa90d812ddaa768f4fe1c136bfa233f20f7ee2c95f219b665d9d001df9cead4aed63c07e39253eeb2bafbbc11555bbf5d9a702513461826c935b8329fd69b0f55561853093ad993fbad8b096826df36d28eb98e68434922ab64b07e53fd153af451801f6641a5d089ae29526040a30f43b6aaf7231a236592459717cb401ac11c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
