<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a615711c94e9de8b8e31c789d204a33c90aafef71a9afe7fdc09446f9fb68d70d346c67b4e601708b9f66a1eac540df95dc976448451d44da9fe73b30e988cf2afb3afffb87b3a0328de301a98188a2f75d12cc105c1de7931a25e39a6d6de69dca1b6a2e85bbadb7845b913d75041e24a80df237b39143375d5326aeb87fdcf1e6d72db2a3f5d102e8061f9fa979bf68f2478999631acf1e2c58bbccbcf520b181decbae019ac76bb26c8c1382fcc7d45f15936dd5413226dd4c4d3b5437bb1741b802a0e24151a3e84897e8f6bef12f6648df0b26daf1d8f6c3a1652c3dd105fc42abf825ffde19752021ec8acbe0aa6a20d83e98a5a03174e200acbca121c0e2cb4efb775830f4efaccd40ad12ae8432ea4a506fba7d30b16ba1dea3d1fe016c2401f61fbbb8a26aa0c75d23a081c82cc116c1a7fe6fbe31d60686f6041acf8ff6df438e1013fcd8fa36d2bb4c5ca084851fba7d0302aa872135f4f7b9f272921417fe9ca012b481bdf84a1172faba7fc7b42528ac02ccf3a1db167043611d5b9905ed2498cd59b395859047283bbf03ef7d1ce7d99ecd66deb1933df06851fdce7cfb4d2c5b1421bf59e859658b962704e6dcf5548151ffbbf01615bf251a513438efd5fd5eed6e4ea704f680fb8d701b5c9ef8f7973a4f6c8c5ae281eda296586ec2a12883f7a1b2c27c533e964df4f483d22eb72863fea401800c7228bcaf44fe61861890299c09c3c036bbe1d84ac6b14ad57fc59e1f9d146d03c9ba9bb18d326bc8302227fb36ac6c16fd0067edd9c87869196501a8c114071c14a4e5170fb81812a39f86918639494ae3e6d66b1b55a8d74c929bcb319db879f95f092c0f163790757569d3e6e8befbee6ffc38112c26f93f14d91eeb01db1c3e09757128846070c07220733d723b2e4b9b2e4a24ae2f91b2c41862eb8f11a7bdc6c122981c3b3ec07cf64768237773add4c108353607f464a08feab04e55fb295c998ab60f2fd190352e6ca4b28c1c42acb61b8c016cc40e28435ffb931ef1bb4094bff945517ec0858b1ee8c6024521070df9cb632b2a23d1c05292251811a3a917dd3b64c5dfc0989e661f83c1eec250714c10b33268e87c1ab343301c3328a9af50ec45602b9b1b684bbae3dea13c45cd6afbd8957ffbce98c8fe113c4e03753ec32e6ef0a2296c68899037b6e15314f0c88a971c02e52b53572012aad9815284cd0dd7a6855aaafd16487bedf86bdec6ee5db07c58466598d5e93892f45c3e716f272cca7535a322fb726aaa32f0eecbf4837ded819116739ed624b7823abfff9388f84bc5eee156b6e6599a59101a00a1fdf50b68c6f28bc6e3344efe214de9ae3b871f1207af9072368e331d779dfb6e31477744a019f4fd1356dc76f2fb7094a532ef4d576bca303744f868123fc8dbc8ba51a5a0f9102301acc0e343733820b51ff400599f92c7be1a06bc7e8b7d73647fcea4d7ba2637f0e40fd7a0b0a1e66fab676c231b55faa51e592c556d94ff5d2ab6039e0f11b3cf54eff77ca678448edabc4fafb0e32d6e1949fc41f5ce6e3890902822afc8734aba6c2f54181a21ae0b992961b49c60c9eba32ee34c64fa83d256c223cba744245c51be41fd936e9e60072a709977f622ca13ad39729e373faa0ecea9883274824b0c93b164b6a6c1a0ffccc1621b17e1822fd417cafe01d2d56cfa898df77d3102dc082885e1dff96e8100eaabda95f30c1f3473762f0a929ad717865e3a049b61d5a0c3079efe86d13ef8f1cfbc7f54882337c4b664b1f067d5a800d821160d3da73756b1b17099be89c9a903ad1a8af732137d674be560bb7bc99fabe3469a66b4d69faeea66ec8929525cab3154f0ff7aadc687757f4513615023c0264940dc6c4acdf21396cab18bda58dedf528d003334af894290f6a929b46bca7f52ff3edf34161edf75bcef74f23e6360ef7700fb01b345e731533f33db8a2bf11ee0dd1a282c4284e89666c3f4109f7d13a21b6dc8c867aedc341b383ae0c4a084278267b591135866c45a515f114a32ddeff0135c2cfac119143d47626f8a136943edbca3248e797666e405d6f1058db4b9a667bae78aec57fe4cc65a0404daac15fa72653e6dd3ba2b0a2a65500654cbea23dc5aa2328fb04eab8a37aaf4aa83339414165149ecd1cae3af94b120cbcf0935cd42110862769f176c089f5f7b170b95a3e143c4cbd6e4d8d28a9864d9390b4b32dbb6344093d760191f0b0926d51f6967910d684d2b1819b5639f70c52b2c64817b2ff759a51e2ac00947506c8357c17111a7d8d38dd096e900383d54991770401c193333c8fd876c5061ca8d9ebf1e088137940fbdfd9561d58e27dda9c4b26b19c6aa272f8a1c87d61c1d4c838516dd3055722331cd7d3fdf9d1763b101f5641a3bb35b9f210175e8221492cce6f5bdfffec8a4ee53843c79ca7469084800fa76ec14868055ab62c2ededc66a15834301882c71ef371bdfcd533c48cdbd1564585fd87fd0ea0539bd2a0881026d93c0050786f5ef10f97cdabf7b9a5711f16c62e30fecfe157305b7cd9e745f5497ce65296213562d1ca402f09160dfb05255073e66301a7acfe1915718da5fbfdbaa8bcc76fd79f0c43f7fd71747f4ba257f7b329f8f28eec8ae829f435151dfed022e3370611d41c2b9dd8ab48cc1a4754cb02af8b26202336372ec66a3c71b47cf2c0b2a9f46bdc7a68b1054ad6b4c996b5a4a018398b51e0a245a522a2f1ae53f1e6e83b28fa621658373341f1cc35232e81a115a481c7352c81b7696d21e81c61347616ad61e710dc45f654ece383f47929b4be1be9a43bd1a851241a383f1f9826f0ae31103d16ad7a6be2735261172765f923e6bdaf46236ac0e0eeb0eaca8a26636dc3537875cfc460f9a926b7935c25323a063f95470a572ad0a2747154fb4cae516cd34249ee385cb7f34819ec653622f7723f0b9fb96a9685ffc6174f48efea0c7570959fb69958a0f72cf645a84ce464115d989dda4109e1813ee1c9462d71d6c06bffcfb57a3694d9a1fd3d280adb361181eb1aac69e8fb2894663029eb99876e8de4d87495fbc61d13857fe885526d6efe66c7a07068abac2fb7e15d8cb064cbcb09e8eb9852f9889b30869703c72e36a10fba9718d7032875b2ac1d48fdbd157a7fb745e2d40987971e1fd794e7fb46481862b5ab159790f81f60af40d1029e9b0d9a41ce822c28c4da821f47c0402eeffb9babf395089d4f329c7b8b0b39f977ebfe36151fbc4d6b8f04379752c3dd609f5c200cf17d614911fc337fb37a835135535262abd81a22e050b3d6435a0f9e2f5cd5e3e70f3e792312d75a47bdded747d75d895bc27659d1a862a80144e844e32cf71fba0df22d81e4f0fba81501e95682a5d5043a622ab5839addf0fa301b7ea36af39b509dc4aafcec7e663804d085e768bf2259007a8d9f3f701e745eaddb2f38ce9c41fde26c48de9c2f5d870812f966036d515d03f0565cf3a09702ab7af6e6d0125d929498d265e945596c75f94457c75c9633139f27a93d7c305f5b19f335a6544eb0de7933004ad1a5103639e709e16b0305e318edc720ea040121fd3465c3c45ab10b443a8d7e914f534ccc820cc6c4d5212e9a75af4f6b840161f4b11412b0cd8abcacc17d2b36b0be69e5a95fe1e0d29633466d5e3e3a01816cd7667882814a0f3b9ca44fab16d94acfdeec189c0beb9bb1b20370d72d6bbc423143b975527cd400a42f325fa04eb0832f3edd857f4918959af86e2d62924906524fe976c083344b0867c96d0002edddb09fd1524cbc95065201bda0c0179da8205b406df746eec5962aa061dd50aed4dcf1ad514c325e386e8a2ce833387b9d8279a26c0d2b32e5766efcd1585b1eff95349215ce6d3786892a9beb2cce6715b93d0aebc44aef9e8eb61f9cfca14cdd332a32dd3c6c16eb18eca26f54fac924509b487fe7c79088ab2133e30e87d6dabdc56141d671025e1cc09784d3a931c683f5db767bf9bbc4603b1e7a5ab23d204be45432908c6506a793b8c8105ddce5ccc0f452c8239173de45e5e4c14129f28ce414770695694dd12fdc2c0e4e7f461469a182825b7bcfb25776b184bc7969047a850c0756fa25569f54a16d61532ca1b399f066c65b480237845d8fa7a39b55db34eaed7f2267db71da9d72e16c8611057727d115fb4a2e23a296f3e34190c8da368335e15e5bfad1b0837102cfc59e244f41a823dbb17a08397b9c97b9fdbd69e27ba39a1cd119ea7768a971df73e3660f0e5433493a94343abe52dae60a3582983c64d9779ccde7d3c5d7cde995a2ea295927db812b74630f9a3e2dff852b9504345aaeae31706c54aad72249f74ae3c27158db957edd07ca99f0082cc747ec5b6bfa29430c9b56c00ced00a430c06e03483b20da3fa0412c6b6b1a0073eae6b9dc09d75f398dc4ba281338ee0cc38efe6556707c816033ad824708e59e536dd6df2c289d4a68976342fa32e660288d080814b29dfddbe9b20a683f1d3de00520251224f583973af1cd31f990b7275716c592be056ff1b065484a08f43e3b418449d3a21d2784178e282c582a1f92f5934b42e5854aa7cfbcfede149020c121c9fc83ca759cf558315192fd55ffe27b4b7f4d2f5e51dcf812bdfe9e056f79b2428584a48f082e9386f07a9b26578518e8d7ad1906fa3359cd286e99faaa5827bbfdeab7f302ddfa91349fb8c3af7cffdd8a188dfb56249a7bd741959b6c278f9e50eed0f8865be8cdd9589cc5f6c789d0ed6e4388de098717fcaafbe81aee8db19c8b9bccc8a638632ee119831a388e518291177ab2646cfc805abbc0699ac312f530e94eec403b5386b54f1f4d9c2bb2cce366480d59ef4a525b25936dbcb65a00ac47e4dccbc5938e608e1a4f84a12e441fb7debb8b001a9dc9d59ca6f2342ad418a420271ddeca2d40a6ea085d16434c3ddcf939ffbbcfd4f142c73c3cbbbbb2a3668d70ef64d1ef98289899f2d98f4b1ad54081291fca3cb88890ab8678055d0d68afa86a208bb3fc95fb733d851e36430e0c6c309ab91298d11f828783ea1a21bd5582e51d79735d4ac01639d1cd45845be4cfe76c03ae446a4914c9b3e455d5d036300b4141a220e6680cec5732276b5197b9dd75a96b7f0e8ddef7faee6398d45845a34cb3193f2b3496c8af8bca34a1b5e1e63898aa8af0e99b54a0192ebbdb2361d2479379ed9c5c00d1c8fc8238d39c5c2893cebcd4e44ec8d20315f5c90c5e0b9e386534fd4b998eba3962f739d2e8ba513e8ef58fc588ca93d709a43b0771b1691dae52f0ad964f89d1697c3ff22fbfe8ae1d682bd53cb43e2df9d2b90d1648a69dc4e23dbb2fb462ef6b892ee3fb00b8bdbc00edfa07e17237437c8dd7fe52eecd86b2c423e5e2ee8092d216e8f4d6f582f6efd94ce3cc76a5efc04abcc377d6f820e3bfd281138f0e949dcc4e75b60881af17751718c4970d1d85b60010759f6c9c585a5fbabbc7442a85fa91fe145214a7681c5d4f1010e70e6145001bca5c04ced806dda0e869fae8debaacaf07cfa87b4cb729dadab55108455d5f3669b42d934f76de10f5e9c9b3348d42f7f12b5033711c78693b6a80f51a7130cc3f298cbbfa3b4cad2461cc368086c572008c86df428def4543ace6430253b0a3ad8ad77190f3b96fdf650efc88dfea4081fb0114aae2b3c15e8b05b314030b5e2017638bdc95b2d77ec2684b46bdb341ac2c6f797a3f74e61d99bd1213f806ee05d989ecd2b18382d4c60774375688e33f8a45049f2d6cf80103481be8e045c0d26b399ce96a2377f987c528cd59dc2d5b716a002d4376d1cb42b84f5a49d1193c43285812e68fb441665b305a4cf766ad7b2ec0a7c81f9dc3754046b5f79c6fbe17180d9663b9107f7dbaea33cc48381439b10fb21fdbacff2643acc1c57e6017507792e81d8701590bdfea583f26b4468016d0e4732a30e0d997845747f62940d43e969539f45b0aa906d6e840c3b73c025e4bdd4b65daab451508f1d8d1c27eda816dc5a105ea6ba4c6f63eae0951b38ee4a32f3688f45080f0fd239d35617e310a941ea019f6b8d9f97b0e39c0618719860064a9083413c87e37549e257a07f96e9ea0a01fb7a4f3c2abb749f3c46a3c635361b0cc4ae87673706af48be30e9d08d64c70ea2df8c45774eaf60240610c58b09a063d6c6d3442b61724a036e9df3eb8a04982e2332601bacfb064841209e3508d2fd9d0507d613f81b353e1fc054ba6ddb3fefe1bee27811dec93dfe93ef1a5d47d707abbd75a6b049303ee4873cf03835abb7eda22002165d099d50c2c690600e81e17198549229a965fb90b6a29c57ea7e26d7ff5833a42d3344a922481211b9e51a0e7694c9cdd81a70643578c58b9b76aab5af02cc6394e5647422007ce2d73ac9307bd6351ba269a28950cab8f8febf9436055dfcc13a7c4d0dcbf23a69015c5cff2b9fe07a2d5518e992d538bc7ff0efbdc63dd6524a1090c9a1828fc3abb2c54e54e686d5b078129f38fdff3f69febc3166f635ac5fffc3a1e164f9225df16672d0479c03c4d4b5c02de9771251c2b0ee3af66bdf7f515eb947ddb8b05df5809f5eb474f3cf4b00d23ee49b9a12670e4eb107d25cec82733afba3d6da4eb716e5b316854261183c4795a70a20799c962228914196d749701a7d1ed7d8e07e6880a03a1055aea4119c137e1714ceace959c81600f14bb60142e1189e176ecef215c419529558acbf6bc02f67d78000770406776d73e9a8eb1997fa02743a18576be5b12053e7e20d41fab5e13001531eaef4e7a69d8fdcf53e2ccb60ed5c327fef4496f1ce9441d7266818db4d6f8ca9455fb53c76badcea3c7852d709a004afd74df624cdacc83aa3f1981dc18a989d1dbeac65f293eea73579b6aa50cacee072f046c8336d6edb7c21e701659ab567ef79fc1c43a7cc363199b982e26961d7eeff2756fad8ee9318e54b8610ea8a85bbdfeaf4b8e73fc7edc74e903df99b30b94283c03c7c14fdb8deaeee8b360db05761ed3717bff58dbd50f5733765f500844ab1c94a106808fb5e1f7c888c58e970a4b5465deeccb98299779ee3c07ae5879ee0061609db4c542fcdf59534a5732fd9e7fe2385f38288e76d0a70f9c5ec994b6ab7557a53aa661383a2e05ee98cb5fec8c0b6126f2f86d833cb3a283560831948e3c57ddc61a26d1815bd7c9ff6e158e22d6e94b85eadb97beccaeeac67901e359d268029e066ec492a41f459275b36800ee3cee4546e834b86ff7e59ec24a279c834e35d5f6ddb869a75024519673bef11f20ad67fcbe08d914f92cd7edb32aa9667b79d786871a1b5cc5ef9a13eeba6e4544898ba0544c3e938ae478fd89922b5893f7ef08e5a7bba191e971e5d6f7887e0584ae3f0022411f02410acd0b4806de8cbb968512f431eb7e05d1b938c9280df4eb6149cc958d2cc6a19f2b439df67d2895dc2404a9f4e57cbb6b42a724c200a78318dd953b40f70b44aaa5c7f6bc34ccd09edc2fe8e8e8028d65d2912086859bcb94afb049b0776e6d97e8b4b53dba5ff5988c40c233960f3b2da74f59bb4f5564e0346137560616e20adeba815d7b2501ae908d5edab872d2718e8b6f54fd52a6e33421c11366a778b299cf765e8a3ff4bf8c7ec66b5f1b1fe3097edb20dbc91e5faf808df18638b802775e22592b9bd84a57f3a242111fc493d1eab59749a2b98bb6d2ae53a0886ea641f0b88caf06ddf9ebbd12c814821954489c9b34496fe6a2cf5fecd162ae02d97e594ee236fafbfc579ff05de589b0ca66866879db9c541b4e7ca0ba52b8f9066d6be84e3548d39ef26a938d1d995fcb0566a2c58f8bc8102b92479e3e883580548f1c109306469ac1af9b47b15de68233641974b33e7d581dc7cc2c31dc6330d94ef288c4eb8204b92d3bb66ffba0b50d5093e4220a934ee7a2c367a086ad314957144d9019dd4cae8450ee525aae703c4d43b63bcbedac668004bb725a795c3ba9ea56c2f9b48c26605db6be12b9e92effda01a5b181653961dac3034ffc219eb274d95d7eb767c292c91ae97f667586af5b48d57529e09fde8981d8032f857ae8a8bcb23f124c50a070688e7b898c812c02ff8982a479d5228c63acb55709d0442a0dd99d5857c2e105a2ab2efff60ab6460922726c1189ce281a549c02a4c495ee970c5e8b79de28e593e06710714b20ac243312396da9d024e40731e06b4608313eaabe1ac76710e2f7f74a5673a9ff50441a10ee1623f57d9cc80dc0830ad04df8f71275f67e7f3b5e3917d18311818debca7dff29aec15c0c321b01ce8f9757f7430f7003949adc96c6ed25158f9b5df64aa4a83951cb0bf85b1630131f112a03f47b75b2a2fd343c81235d35a283563d67dc4cebec89dfbb0858bee8e091dbb2b1898d07cab9cd3f9c5d068e737f4813026fa576ef81796b7e21cf35d363e7e76b2d641f039882a660ab03a205ec25313948c7fed27d9538bec62a48904cc551ca3ed799a74ab26d86f0aae7c5f1219e1aab01a9ddcf9245edafdec0142614a36ac59256005cf77b1a34e4d15c4837a692bf6bdffe5f00fba10ab639aec312901ff1260417087a2c880b6f625b89fd016742ca5769481c52fef55dcd47670627fa0d8460394fcfc1b5414df1f1748583dc987872c40bc1894c8ac44b88dcc963b2daf9139b1c03bc795dbde528597fda453d8141cc17155f006f88c1871ae0a611aaca705ed2730932104c34688cb64716d035cf18c4fdb114582feb21d32ecb760b4240246e60a594297fe58ee50241496f8e186a7581c8f471832728026503b8e56d9ee2982ba7884fab146b626ee9a34adcd8b8f8943c7e0c006310687c887cb345af9fe3a7b84ffb103837aadd15e750e3e31711f781e8c704c9f41181b40a1821c7beb83d34372d3e0df1fd10fb7edae0e7e15519753ad22d75f4dabfc973208e6c170fc0085d54ee69ac18a584efab7625d09c2166d4b71cbbe9d72c46d9aa20aa5ba8cbe2fe451378c4bb087863b975767c0bde519aef7dcd87cb8eaf2293304d8c4f266aa257efb38e19076a1a1c58b702b866b82956bcbdcc211796e1747a6c6f7c4e70018b4585ab359bab81df4919d6947a67a71375644ec23cb7024ad31929a9b16760b6f2ae4bd5287ef23b28e3507a629af27f3b495222d9749a9d16181125a022e006c19e2b456bf1a70e08bf884d4787b519dc68273eb14f4030002eeec28be87349b8c8e3b88d39bc0e1e7a4ae118dce10dffd231e1c2c36b236ecb4d1ca0b9eb18b86314cdc1a99bbd77156f5d332aa7f4ffc951d685700f445d7bd82d63561c92f191241a02178906d7f70f27f8b2a559fba93842147d804ed6aa16586f4f725a0f7168729de445d19e4ceece472e417804e689b755217bf83f703fc29294704f93c1ee5d7fcefb2d735b1eff6bdc18644c7edb708d04275374f288698104dddc3ea78fb6a3a322eac2590dda569edff1d3dc81201981ce1ed59347532b68e5c23e7640b367997519cba95b40fda2a8f3de87b5fa443f686db05ef36d8cb528e5fb8e8b8626569d8b5bf3e7e78ca89632c358915c3acd59ff44c363ac370ac8dc7f54c6267cf8777cee1ec90f65054009d69b0e8408d7554bb77b6f16fbc0cce2c74eff6046acb77cdc462bc3aa73556abf636e58e087e8b9355816e32067b6e8cb666c9632a35c17f0e19580782d7c839739bc7ffe071238c9a6cb513a5385451c1bdc2b1211e05d1de6641cf0a8cc1326f1e73627412467d26333e8da18bc5373be5cdd6476b027af7a4e82f564fa401c62f20a2fbf72bf3d03c453ec8e9af19566589e0b21ddc115073f52113b3f61135181ef998eb327eb0ff22e1072ec9c5b53e217cb68d1c1ad475b831389b6d2c4bd58765d1337d22fa7565699aca1e3848eaa60fe32d6944501c9d1c8f66a2b684f8422ece0e70140b7dc58c9c40ff44c836713d4490c80a6b6d0d0feaa73e4a9465ed9fb56f1a07d68ea2fb9de815fd3be8ec74d680ca48ebbf1d75afc898c06c5471579d2083c430998f9b4a52dd97ac3b4b54f1ba0fc61a63f29570263765c72ae919990f18ac988812a0c55099cd6014e12dca219962f8b414da69ded33e83b029f557bb8e2b97f53502e713772c83f4ad8c4e41f74564041d10043298a6a4a2a57fa2037e70dbb55d654b764a2a014a7bc1213c852b29d760027ab66b220bb608f56894dd5b88403357256f4601b7b943805322196f70dd84eefd096d4e6c7402495e940934b1e6e1a614ca7a9b1dea1b342eae07fe450bbab8aef568279be7a9daf281c72f226d5c452c1a9a22398a92678e9ee3c5b2b480492f6e17092c175c28ec61efc89400dc307c6b373910c3472a2093c90a13a73cdad88be022d74032e5635de8b977896a9eddfb0018c017aaada7156d683dd4109544a473857729ead2ea04ca96a93704f10eb2cfd7ecc85f05e5b000402cb36dbb8074e6c0be5f2c5c5d144dadbbf50dc84f4cddb9ac22b23ccf784874934007d8432c747e1732176dd36b7d51c293b97f66bf268d1fbf807361947eb2a1951d1435d86d1c0da5d6dd3f66cca4847627c107b556cdf04c8d8950840b1a854ceb60c629d9767f24d10821f2a58212f402f21aeab0e33f2f19be0838f85a97b3f2226057ea208313ebc21f8f24c0e86953bd6631b881ea789a2637107cdeb8a74a7ea2a97860df9f556c35a9c15c427e22bb75c9de16f217778ad9a79a55279d4d80ddeb268d9015ae5590c599b349cd11b9f3eb37dee97f4aca18f6ba86fed8fd35ab0210d7018e78299b18074f2cd7121a0827bd1dd77908acbb20599e3d25d96232c1b066142649167550beab6473ee472349f74bfa15c129fb7e540ac45f5d3caba4dd7a1e16d4cd7a9ad0735ab9668f2ca9b6c14fe07256dc26204694c41e4c0660d305013d934b06e46ac158ca98013d1107fd10798f551050560f5f1b1484e432c2d51018d87a0678bf7b52c22e64fb0237c11702046baba1df2b08120a3da7c3b9fad319cae8c4ea7513bda62b22fa1a1dda76ab8d2d41501ce7764fc3e6bf971bb9dc5b5e1dc878dccbbd0ff57437d6f85eb538decee88b66c1d7c7c0d1f62bcd7950478954ed51e122c507372a6643d9095a54f91311a97afa056bec68dc601b4a7ce1875c893968cea14986f72d50ee5926ff179b1b266873bb9f0736de8014b50e52578b82dc10fe922c3315ab88bd180509f74db769688940b852427e19eadd82c797762133384ae524d9372572038a7c4b37d09adb0e0ee3b48a8413fe376eb6d2e392e3831a7d7bf20783afb5e58b1ea51b44ab067e4bedb62e31262c50d15c0d4ccbe126f95d4fed003339c76168e53e65986541438cf860b647fd0b00717cbc250eab9935ae85124191775dccf9eafd73ef7753631fd37d480d90d4a31dd396b052a0dfc61f30c6039397c8e022bd1d7d5d2cab2f9a1dafd230d0ebafc1bd79f42e6461d3fd7cb5d766de5bea74dc9d564af4f4b1ec8ece96b87a8e0a70323bb5e82c3558536a1ba2dd02aa2197356a4bc2f2c20b4c008abee4d56298d41bfdece7debdec7e7b25371b189bc63aaa0a0657e0d62c6da2c660c7e24f586fc052194b5134a688bd92c77ef1c0a7fdc28eaaee0d26e3602d3ce90ca0866fdc3183e98b78c09b96aef51a67ecd1f6ddaa9eb52afeb242ac0aeaf98c3ce502190c7505945c450922adaa5959d9c1812db760bcaf9c18d318c41fbfc255a71c1f5134d01f6f054438ce32dee52aef630221139bd3b439a50c3131b219ef0c55df45f06b6fa4fe522d05b6093fb34302e050b82ebe96e90125e49b30ee909d9043cab687dffc13b201b3b39565894c75ea2af0f984dae7970b06f71f6ccb01419b6344a6befdcea731733d7b4802b599e22558210575660e382f81ce04f66c0e5afc255494342be0b1ae2ba24ad60de2e7efb7fba76e3a43d3a83e0725f7f8ffa6a7746f744e5d14056919cdcfa8a18a42054a8d5422541e4583c9b359912ce5a2dacd1bed19ffa9bb9a294b14ed23fc1059ba1fd9a3024b91e7026a5803c79a9cddc35e2d77e38a9b6e2568a5b49997acbfd371e66b4aad7893c3c5477eb00a77ba3a0fd375a80fbf1e01013b50591cae0019704a8073d222635d02ec5cd9c826f722df5a9f0a81eb48b9ac787fa6ced92e3b1d2083f0ec63e1cbc0a6d15b36765c2b3b4a8a694194cd8f00894c2c1633b747720c049ff7dde5661490be9b22edbd680654a10022145549f61c4fe14e79a888bac66f4af7c70e341b1c2173af2d89bba325f6f03572f18bac5453bf2d8285f66a0600a577ee6dc7c2f056b58dfe92fe59282b1dda26eefcca55b46c4fb8f736b13f0dbc7dd6a891a4e25dd0227feebab46e2801d89d1d33bb88747b35bc678622868208b150ff54311dc161276ef868df98638cd2c65cf47ab727e602db52420e5e74fab59252f84defa46187d5270a466a6fc16cd110cc47ed1c70847961a6de2efd63a5b797e5a4b8e6935cad6bb3a0788f97987203079c1483bd1cb0abcd76ee8133c66f9c00cb8ae303a0157413e6e04e7e8e91a812ddb5bb051c611786007d39d4ced01d298ed732805d0c5d95ae6385bffcc8f651a8485aa062e90008921e9a624254e76a584bf572d6548469591946b7d2d57cd082500ea353def0d5a7c52d6de8689360e50b6fb93fd1e4aee4ddb51fe0d2b5d171ea4f30c4b4d8ceb3397507785cd0b90e587c0a68e0e16b4b7ad1f8ab34f55433cbe16840b641c9629ada3858db60fd3ed711804124d7ca7d10ac72a8b0a3f763c9627ccd32b73da401f684b06e73ccdb44b2cf389488c26932ccb96067f9a7499f5da27a70060aed2967701d0f29357ce3cf7b0ba7996d08ae2cac18f049080cc69472512b0ac","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
