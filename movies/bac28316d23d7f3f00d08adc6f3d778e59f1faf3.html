<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e3239f434b617f72e8577de8e02356e7fb9a0650588655378411ece8112fd0a4ed07dd1a999cfeed7097c3268cc86f2b90f86adc493b766e93e4fc744c8438d05cdc56f78918bcd04c32acaf26c2d7a37897ad993e2ab36a2a42ef31cf3e322a71afc33b4539d9ecc5d7ffcd435a2e297e6f099e15edc60bda736015b0630f0dd262470720e5532b84a183d60f3b52ac4d6843464e2b845f3b0fcd903b895a6ee1630d198c0f6d3259620330a2e7c2c2d75d43921edf7df1faa7bda329e70c21627ba27bc1d90217598a08c0f4d723463d08667f3b788b975c0e17d414d095877ec421075eab8d24e949b4f1299b50110d407a5f496ddc8f5355d4c3747934824089d5be9eadc91275f96a1df726dd884a1ee7baf4753ac0f55f203e0f96825332ca7cbbae0bdd474ebbd1898e7e24731e0fa1ae8a89511a68659f7b4cb27265da83f11d8fe037b80ed6d42710c9e1011664141c35f37d7129dba7d4de712a577676f44ef146fc10db9da31f90923c9bb04449db8b270658c539a9fe40b0038001720cfbe3da23a30df41d508e7172868b9501bbc131e909eb1ef48f1059dd986b535d0c8a00b1ba521cc125d523db99fc72f2ebff4d7405e53c44a950167bc4cf2b74cea60430bd558610b9c31b715412753b1141cd144aebf2e093d7e543a212c29e69236ba74191dc8d4d7916927a0d55ef49862e8999237826f37755e8c245f30e553d7a0e2f91415d4ba9548d2c70d1c434953d8612bd16dd3d62fa459f537c35564ebc9f2e4b8a1900c50f149e388e36d5f9df7e90f5cb81b013b8104d858f691aae91dfd6d02a14820345cf62f860265068e39f9cd0b275eb5027e1201c6f7fb5735fb4448d818df3661142f9fbf3c637d59cb45e04f809ef1cb0b3c5fe2a5bc418cf3080294a5030f629643e4694b9470993a1ec9df91d47ba1a4d32e800b1db19412ac36a7c246da47370713ed68516bfb6d588912a017476741f1b535f20784e0894480c20a6328b90ba0af09385fa3e1699adbbf00a79f48947909e5ab128194453cdaf09681413a462fa6cd646db44cd716f3a6736a469cd9853d528b690cd3592a6a13609a49ab82b8954f708680120f23d716b584d3b5d239534ccb783799ecb8117f4ec3e58942d181e3a22bc4f927c2f81b5f07d8adaf4d725eabd3c05ef00713542a60f1d7d4f0cd9ce499e883a3e0ab02d2b71ad61e7da3e1eaaad7a91f7f4f7e909f700941117698229306d03a0c8bdeaf69e6f9f79e95c6f59ebeb5b22a91179e9f43b0476965a446df47b716d8a609ff34a17b301962c42df63e51a520b707903c67b1bd3b20712985799fcbaedcf3418e0dc04248f46d80cb171222959ff951b10461a0597e6782d22fbce9433315f4af9c8e99db9125a58c2f81a6f86f191adb4d4f1c7fd3baa88d2c20a6dac1076d97d5bbd7066983f9ff0d44269a9682805d26dff74177cb1f283cc5f3558c9c18299bcc436d033e5c36fe0a86770d3b2dcdc412b1b9be199aa803c58a89e9f9afcf77dadfd9ecf68d4517830b42557037b9462f6905140a4e1710aa7adbfcc4234bb6fb7692391d78f10095a618ddb744b9bb0d2bb6d5fb97420ab62205a2464e2e4b94bba8eec90421c18210ceb6dbe4a11ddb94564538bf4b413c085c743f128726316eb699968189b3264a3371ee5f1d86d90d096b4e4ee2131a48894c3e02156f9632d1c1803be14d8c9119029b46397c7423702cffb8abb1b51cfa1f52c7c2e79830336ebf1057e60387ec54d98063ac13de3d55bdecb0f3d7b002610a9f4ab129d2806170dfb42cea000849e4b6fdc6f2c10484f9eb033568b27e8121fa331f406accc44fb559022f9ee859e61203be803e07b42101b8032d7092df013f95165537e88b116bc38708467814c8dcbd814de39e679c526d84744edaaf48bdfec58db189eb50eb305a421dd37aa0ba854c02662ba706a7f2ee45e75f26c5f344a7efb1d949565c34d4d58651d269873a70f15cc423d24f346c1e347bc2470c34c67dcb7c8b7288cf95088baeee29f430c67ec9590568b107e990237d01ad1f36b40cd3ad5ac83de14e38cb1140eb2669c04244f7a6181ba98286ed8cafcd30a70c267d151e648b2df7b44e5bcf5e28c31446b3d4e5217187c16f674e8767e45a5a8da926f6b5936e9128384e407122c79ba106e41047b123dfb766fbf9e4cd218a2119e57059bd3e7e0a6905d771693739db7d11604df7c2c891ee7e3e112785169e63c3c919aaa39c06e8586ab5ca54cac78e19c72aad442fd93efa4b681f5c0955c69524aebb83ca9994e1775e67952811749f8489dbd39b33853eb48181904ce9b484b85158020dfc7dc60086ad4a7275a70a1e99b76ac5ab863bfb5f12d48d5395b3f7f91491c75f103fa59ce6237110d138774685b411ad372cc29e4672447726d9d9ddb6fdb914de1a0cf339121ed8a98abd56981e1d28a21148b87bf07af45caed419e80291bc77a3765a5fc6b213ff7d74fbe08a14c4c7e6fe60d8f50d52fdefe3acd967a044580c476298976e070b644de081240bafc170f561dcd2aa30734fbf2f0faaedd577b63b5630fabf2fe779e88aa43bc9831048fd360b7123b57ef6f1792a54f5c62f3a7d8040bb7c58d499677f8e0b47aa2e3df5b4630f8da41ecf9cd03c3cc0bedc43319c27e59ba427458e9f0942fe30800f9322842a61f647efb0e8c534a33f1e4cded2eec867cf457a8d49454d288bccaefd65e736036f71afac8e79bb06bccb91d98027542d93ad6ba08ad4454086df25aef6528ade0725a22920ffae29f39f9bba2ba8e40f46539ca09c67f2a7319c9d522b9635c99e650b24d9df61ea982c57f4c70e4ac5a5b19de3aa8240b7ad2e4546253adf61293b1b95a69c8ec66cfbad12f4f8fd0130ec33154dac4c7523806db03b1c2aca15c3eb443fe0d33dc179935ccc8c48e0b19109491b22a07faf514a04d6fc4726102f4125fc81969b709d2c20db47ab8853145996d320a3bd98443406c7ceb3cdfd1c647857f3910f4d98fe8bba1a8d12b425462531ca209e292921082f531322542ae5c8bb8f71a49d0be0e49532b743fc4473fd0bb777df3e6cc774ec8c724c3aad0406e2f70da9a532e5b594047d213b81207139ea3c696735f68631ac17309ca7687ae1c51db2aa9dabfc8ff908beceddd1d3bd8787c4f036d360639ca48e7c70b8a628a72e837510529176301d0684a2b2afbf2fae19fa91555d86873f601909de521827ca3414aa461d2ad320ef9ffd0bffe74bd26f98e70aa277907d6c54c0c7a93af9fe6111b0c86da14ec4ce36b29e103923840df56da65898613aa200e23ab5577afae06b1ed8ece11297c4d85306fe78000a65b715ff8b087b2d84df897be8af0df5a3cb464d51519fed4c0dcec011f2e7f4e81eb3c765b3f79ee00b84de08d38c2c5dce182497e5523b5b116422bfffe27d43f1c5d66d7a1ecc9b36c80fee3121b10cbb8fbad0fecb44e7d8b50e5f82d90a38f5898dc7d8ce69a5ddf8bbb8c75a5c9c7c6f824074015148e490c6ad4101d05f70115ee76cab7d9c63ebc3a6facb12f50791ad5b85bdb3abf1b99b29ccb72665c69e28848cb9fadddade28d4a2d6e96bdaabdba19463f016f68aa8beadd5c39415a42857b6638e89303a8821adf41259c403c44c13bfd5ef3712f93082500c7aacbc3518cd08cfd2d69ade95be0c4545417306a658d6aeb6219984e0aea0f73992c66a338640c2ccd344eb3c9be7cd73c995db67062775b0b772a12fc1322ca789a838be0b2d5f7f520d69f2a148ce36849e14a9ef1e755ddb3d36029d168d1ac5d5544301643d30b2570f98c2b928af7e3d080f4c2c96c13b6fcab650cb1b07d8eefb1d802c120c8aeffb3f9f211286c50456023492101d80946b82e663204a841cf068bd101385a4873eca940c2076edb207930410b5c8a1429a4e44de93144d5ef22cb47ddaa422936a2212377dd1493e0949c023f148f45b8d94e0dbafac239f86ad586eccebc023866471f1a4b13f84adf53f59abdf883b437bd48e43f952c3bdbd44d6572358ca85549538aeb5dfd72556567e0086c1f759ef33c1f45ff369b2f4c8852ba4d1b5ae407bbb3fd4b8bd3d2b4502609207eb4d5bda05994ec5313e4053762a35c587ea5217cafe9c58f63dce7d6fb4ebd7229acc66464bd1c4f60819f05d561db64ca279694278328001e7269258f937775bd050778081ad776b1498d896b1c03bbbaf906ed7e9a48309d941a1d0e7dc30879452719d3b6b9c69b651ee5b013a7cfe4bea9e05660e2d0d03ec52f3c41e80a3972159b8e8f02290afa927dc135a6d5eb8ea730aa4f5d29cd9a2ba723ee7480991177193603b3143d77afdb5dc7b944853e25514f5c2efbc420b34e7b06232f5d688018d7746b3c4d424fadf1745d61f5f58005617378c00d2d05e81259666ab6e895dbaa9cda1415c804e82c99405f4030438e24ba95926486ffafcfa0bf8fb643e6e7003b2acc29a9db466358c555c2bf32d2e96629b8d6c57ea5e9cfa189274a3a85cef41dc077b3b72468576a81557484c1f637c17d41a52b35685c3882d83134c7261ff9907ed244e0c8c2d98169a80aec944f8cff11385f7aa735e9aa25db1ecc556d4ff18f26bdddac0fa131bd0f3c512c81cc9fa38053acf55877e4fff07a1c2eac5170fb30e1c970b3e6b91f1ddbf07b0cc7459678ad884d28f9a62b15b921a61a647e414b5d02581ba81c31b931514eec2f7334e77123271e87f0b0567add180f19eddebe6b15af2c683d7d815d8528468d802c8781d2211a8b2b3afe70751768df337fcf05b383bbaaef644805a857a500755755bc37c356d24acbb820bd28de920eae41967f6a6e89f77e874f5f2cdff01c25cc6339ee6c113109a94dab6b11ce902866b5bf6368d4e9983696fa319e9d6d050e64572ab1db6d21c681cf0500d3b37897c97ac2facef58289cad65805b00c503bc4225e8cacafc5d5252777f8db340ccaedecc7ee10189e3a0ad702775925ec887566bc9d7590ea057a3612bbb2fb5f499d4f0c5cb8138ee74f35100a622d6c484cff4ac7c47c3e0299b40f485e9f2bb079fb7d9275a58e7e1987cdc9a073a28ffbdde81710be9c764bcc6388f2f510ae30180967c225479931fd4b6c65838ac2df1c15e32be5b73541468995a3d8a1a9ee68e1fe736b51c834df95efe53a0d2ba2fb025f06567434cdaf2dd3d6be243edd5b88878bac246d0976c3b4c1a5647556dedf54148d1b54bef8e8a91ca8d24fe4040c114e2a4751e6be7f2e0adcff131a501ec38510df6aa9feaa98dadd3ef8e9c01bab789711237ebc2b3a4fdf2a2e654e7b155282fc650826837f991b53f773e2eb70ee0233a84217354ec3e172700ae4a9882d9a28647043df4ee35d84d31fbcdb398aac3af84467c32d4c72574448c5461bbd0d43994cc76bbc74a4e9e9465c2c033d91b4be4104957474539fbaf737d48a66194f25aea7bf598930d5fa79df782c4b416efba7d60cb9bf4837fb97ebe0c1205c75b12aa75dfd9f0d77bfcb4483078bceb9e77afe4c0ec7ff2a7102984fd3adb3128881d8c2a11f8a27d0d000831ce4828713e840da45afe20628e1925252d8cb3bd8788e93871d6e81c6cec0ca4e3625dbb756fe127461f7aa71ca0a27ad83a612593e4d218f29798908908348bb4084c0ac1633752cd6cdb3699ef9b27f8e1863fe1508c23dc88113da2aac56d003d0741b6b2118dcd8a6c49018e2b1318c67cf9ae14ef885d305373cfec3a7c5d95be42f5f60439d6292aab17303ca4ccaf5560e52cf49b13eb438cac1f53312d0ab5a7e116bd0af64e40f2c6cbf53c5356dc00dce6a1beda99295e76a944a81786029c39f6e771d239f2d6d1dcf386c281a15371876ec9bf55ff878dd3fc9b41efb2f1835564877e30834716f2f1965ed742a1946e39bb8f0ab1390384e15a5e2b168be30709f07b41651d5754f3738aea0702e4a279e5bb6778a06dbc64f1ed9f3a250aeae791cd6e45824a929069027f8a5dd9fd44f8ca7698ebfad22ca27e7d2824a626208c0e3cab62dbc6312603b6e4eb7574e0823290262cf2ed4005298a662658e69e00cb5a29e72c3b659d37f3c7c78f59853473e6de53153eaf208d4c93bf4280a739a37fd636b7bdc0378a1c24f40a91303699f3d03001d708d4b59e990297e1713a2e8eb3027e3b38c544878c52a38d43173436ff97569277845f31022ec3ed64db9272432322c94aa50100dc6ede00e5a33682d8f7d8851901148b4ede0fa412e2c708008889bd57982326eb087afacc409f1d791064bc8b29c14ad42028047739ff4125ce8fbeec88bda9f21be08ef18f5644dc867fcd17985da93e6eaa6514e776bda9e4f632fcb45c3014d2517ab6dcbe59f7745338323531e5ae80aa23140fcb46375b1583451ee8714925b21a4306fce705799dadaf140bf9ce043b2d56a04d21c557f9eb130225c52bf197ea620b0e2d1879b695a75e96d0c2bbd2e64510fa98d1d9c60a89ae6ba0b7f8244039b2d45d1ed5965c76e2ef9315db44a700f24c9ba23b77f23c1ba1638642c3fb54b62503ea591d2f776c6c1821b12c8df20ae63f20b461af60998e6b964c8f25add10d9e8cdd799f977efb155d3a079d623eb9770329f176b5b9d1b10365aa53edd8266d2b703965490b955712809f6ad8da80f21f6354b2d8098ab1764cbb9edd76f15e02be14630f142cd282db6589ffe0aae216f6feee3dafce1243c9ee7e7fa4260973cdc62305af5e252725de093d3f2749cd604ffa29200b33a51d1e686dc053e1ef0fa5a87870df1ed8ff00e114673955fd4e08502e0e8aac6e969c79cf6a5d73e2940c28203df2500558be8aa66ec99aa4237d40cacfd3cfd174c18f36de21ac8b43cae5aff9b32cec176703d1e716d6b777050f464830dc10f56b2797d2941153ab948a3815f57263751cf13df66a4f1b792e946e9fb2adc1038540eb83f1cbc862a4d74d16078b182b6e329d32a35adfe89adf5efed85d2ecda7813a950dbf99d3d3c5e4419ec3ef48ecb3e589f6ab4d951983bd4a8228a3a592b6c23bdfd5f07914eab7a4fc4c33bc6c401d591a04a722f4f2ccf2e0a5cd8160f11ad1797e149d7e7db8a2ad6ddb87debf13d2e5135c1a02253d3838106943fff67f4345a570da6e31742a86d9578b2418182ed8fa67730d7f4aef1a1d3aeaecdf0300a3a09cc3e9506bff8e7b43389daac12e002494dc6549d2f691a312861659d2c2f53e65e8369776cdfb8a79e08fac22161b40f7fbd5f3a68fb9883d89002bcd7f4e313bb3efec36a8a6dce3face53102c0a9cdc89d9b258608fd94421a3bde4aa79fb6b74a13deb23537ec20ae08a75bdad5ee8358bb3a321d68fc232e4cff85796ac5a942eb5465531b8f79ac77ed103c1ea1d56a941ab42a9cfc39dd9283854f4a7341640d920ab14a5d8918ea71e385f34d13daf0e1984b8ba6ab1a197da5f44722aceae2df84135c5e0999bae985ab7f0a947eafe20369848193917b55f1f53bdd8941d8d80de27e09edf5f66714db8a54b3a9d8079b0b7e8326f1d91dc1516235393edecec449f93d031b4d8a3a9fe7a4fe561c50611de6186d078a6902351314b106bcd569fcd4d6f40e804fafd8dab3476d07a95154295e5382632c79c3218b7ec484b1acca9a029c4b33035d2b0275968c3e6ad63d4f1b2cd79edf51b9465553d35fe7b0b726c86547b738582b9bbd01d1d187d8bda6d18a8f4bf37c847208babb9b8a16214443742dc71ac7928dc18681aad33d22507ffa0f16acfb19eda9f35a104e6dba4c5d3d3db7558176f7149db7514e5c00e7142e53bb202d05f7148cbe5f59584d14088302b5db33f1ae2bbeea323c339dfc19533d7dae7d848fa18a62f889e337b98c4f0bef5445ac8b71f081bfbf1be65913eeff317abcf32a3f450387edfcdcc1c779c0bee0b75d23280e2d10b8a8aaa823070d5101bbb5410ddaa48e9ea8d964814029ef6509193cc0a12a724fa4c3fba67dc001b09ae54768d5d991c7677975c4418e0a3fe349e44b935cf08bcfaba60761ec3621d8055473f5a43946228b5d25747236ff44b4a610cd0fa195ea592b70dc096a5237110355f882f89fccb67a5219f8557f1c5506d884eea8a085810685e61adae15a79582e584264d7ca34c29f0d034655fb49c9937713fc8cb36dee2df086051df6688852da6325cf28a412deba789346c7aec2c3f597e27c3092ece8f63533ea48a8326666dd7c81a624186286e0eb411f481ddc6ef4b8fd25063a12f4ef3524f2c58fbd1f1d0e11e05a9740f1232601ad4c1cb99ba30868045fbf5063caeeb671b5555e3cbf5954952a2fffd06f91607520c9c0174391c22bc08da470456f05308ac80d911073237db8559c3cf3989cba8ca952dcfa8733fb317097ad545cb753b1745ed0ae8227deeda3ba547e92ad31218234c6918c73ff567198305c74a71171fae39ebc43c38811c77cdc3c21a967e8a07543e8b54143127bc4195fe3130cd3220df40e688755d6d306d01a4337ecdcba135d188cedb052c2c0247924762cb0cb1b1d58e8047497ec3d0fd21bd2fa933ee4384a7044a5a2b3e44e4a2c6f408ceea4ffdaeddda5db34da2135458c165f59f0c796698a7901b8622175b1cb6f1f66a21a395eecbee43a3fd6e1a6abf96331805b60255e38c05b254dfb8696837e7421d38100872e431b7ab94af0ce73d8838e3dc578027f530a8bf89d53f8169e2e520f345017fd024af00260a47910220b4af5f29069b44a19accb8bb032f1553db4b173f4b1efdcdc14e82edfab7fc5dc37f83190f3c7c992d096fd184d0242b696b4ad91a4b5114c2b116aa426d5dd9f999ef10ca47d5f6ade1c96c3733a551b0a178af97ec7cc32416ef93a4c56883ae58a2982447d4e5e55563ff78820d4c2ba7b69723412054e722cd555a2d7d6be6ec41fd7795673084ef8f2675c407172049266855c78b055c32af562e54dbcd2945f5af8066b2d7e5e6a4bf71825c59afa44bcb9bb18509b242497f22021dd55c42462a6a3622a74238d6d5864b2674ce9e236fc6473788734cd0002d5e567390bcd07acf2741baae374bf23e9ac5475442b419402aaa6b1cd4ac8a42695cebbd25042e5dec545db12a6d5b947b5c758770eb5613badc473aa764157a11d03effee0191b6b1863645ab987cd69edcdd1382f3c943e8a5efc6759b0913152e2509887853d6112fc5a94786820d0d898c8da873ea8bd738472cb9d366232e263f981841513959dfa30b78a50c4e4cba9a0ddea3db8a4a6f9cdbc4edb0b4ac99d243a087aedf60006b35cca439e7fa35bc9d23ad80aa508095f893b21d7875582a3498218613e659544ad88dac0fb28c571c333cbf9a32fcd3758b579eea9b95c72aaa85bbd48e58fd9a1151a916f34a41a956c4aed90ebc526da30e4f7fcbdae8f76c5d7f9ec5a0a9188a8d733907258259034eaea8ef543c631e73aaeeb601aad4e32dc40e3a08b95509d36dffbd0fb4ba5ba63a016304b423c2167e0219c24611987f98c841c8ebf8576450b855884b1276a5137c31c4f29d60ac5f1c19dcb3f0d10d81e70f331cda8bdb42987c4bad7f9f490e316f1336aa97660f4d8ab16bb0a9e71a88cc03ce34ea917c815cc0aa33e435ef37474d7d79d96df3670d83ae5e18232b3683dbbc9a41712644ba4fed0c4423d3d1602aab4b535942806e5dee7ad114c3071764521ab200c605ba4750d15f84a0264923d00dcc970b4071c248b5cc1c708e83873f623bfaf5877932eaf5357f0fa2854a46b9f298762ec74a6980aa80a75e8ab7829fa44d0e0146993c74dd1fa66ffb0c2c7a13269f4247601102629a40299934cff958bf4c362aeaf75b22aaa2d5d42ec5c721402591366af5e92e80f59094c707e25eafa5622e7e20ad63ac4071e7e96fe6206a39caf3f21b399285547b77e2da62bc80d82b93aae80f7e0c5996171704495b9370f1b18dadc74ed4e62772e1fa3b40cc648f710ca7c632b2a21346aee6d1a2d97edd873bd7eac253f0aabfbc0c30974639a2e8207d09c6bcda26326128fcbc380826967e797f781719cba21b79cc2673142cfb7d1f7e509c06eaa1d4c43bed54e8f23c7c6946c1b7f95d72535557bef763d90ec50b51ed456d307a3a904db74909c3109885dadcd419f60b285c9fbc77bb1c34af1d98b54f47b5e46c519c9719f55962986a2ad6f8a3ebd084ca029fc4b488a56f753529a8d29ceb389a3437b22066333ed49edab4a5f7397a9f218792b3fdb7be7f71aceb17a1b5970f333de76dc31d9267eb64508306d36b30a6e284917edf9c15c5ea7a09544bab3bd21fdf71e8c302ecdd7eed983cd7bbe5a73a7a77e72dbd1ab0d8df45aed15eee4bd4f08416e93dcba4ae1747cc7066350ca53b7ff108341f600f5aeb1524566a9e04b8e09c38f8f351795ff1812203f9a9b47175f947f1d1f989fc61c3bd1435a9efbc47a27bfc18a4dc121609852638723e2c0d36eb24f8a070d35037e0e9bc3e180dabd665e7d71c0ad5ece8717bd0c9d16e92f98788ced3007b85ad54564a5dd4086ad0b63b3d4202f49198a04a9a3dc19721aaea3c69c62f9c0c340a0dd8d018c2824cbc138ac0e68609f7b585f22d2324c3f5712cab67e4e1990cb64e0f3de4f74013cba6af0cbd4af23323cb1466284bb9a035edef0d9876f7e4a7a4ed6536e34a5cbdd911c92fadacd8fdca7b525fe271dacc01a3ba23d6ef07eb06893dde5ba5cb90534a78b2c7bfd094473aa3a4c68ddcd52941dca1966091dc3107057eab53dcf0e20712e10eed00af28ee849682a534d39a42f3eb843fb74328e5401654eba91419f509b7e2f16ed78938a7e2c8e846a696a0bd2696aaabfbb8b0478bca6cc53c64de2d82f8cad3cc11aa145e7f1d36989498c3068bee9bd99589cf1b98c59dbad934e620bd134dc11e745efad9802d6d1fba429238e013f461d10944be676fa09093d8cd2174af0f18c8a927933ce8ba8f2091158392441832a4693ff2891ad76dbcdd0f4641c9dedf0fc7ae36b8f3b1f8cb44c405bb5c2cd98eff0c33979f07a76ffc4254bbcc002b30c0656dd57b14847549ccf06e02faca332e4ae843a96c53e8705be060ff74357a1d76f459cd9d3fc03df725a97ee904971cd9407e96d9c0805ec188f890f973997b6a971e756928658bf36f70a380b42c777691aa2cf719a3ec73341d6fa1915017b50aba876a5370da22a39b2e6e734151e4186687561ac9b06b67088f981dbf78e7936f7626feeb21439837d66121b36422c49128f76f94f85fb73d9d2ea84e3cedbe09e430697bef9a7e5a72f7c870530e75e02388d8a99fe1a11c2ab22410a79f425315f8df1377029dba257f23bbd55ebf9e513fcf92c9a86832692e958174836f3390bc851f35af88e60856ba780889ed46be36bb8de5bf998dbc3e0c234dd231357d3c0260e0936042ce0484d118697cbacce8de5569ae0b55a152d01ee023f417391f283ddd5a1016c216681aa516614ff94f544dc0adac15aa7ab9fac6c166ce849f62fbed2fcb1a1a2d4fba74b31513ef8a2815729d4f6ac59d69c098a54dfcb142390bf506383b6f4007dcefcae2a693842f4289afb7d259d8860433e3abf122bec0719d5475dcc2148a13ca85fcc03d37be82bbf473a5c994bfaad99b2421b20ba2b32ff94a165adaf8dece64beeb2fb9e65da0c8958bac73c0ab625557ae0fa935046535e215ea9567e5ec8f29d18e256e46337508efe41689041bf663b108c311c24a10696c1983e94ab891584b6cc159198dd62df29fa4fc522cae47a6e8b54fbf22c088715e368bf6b112ce0487807fe36ae6750a7b139ba19e86f8a85c1317a768a868a807799ccf8d3a768a0cf7658236a0185e775a642d3beed6ed740eac64e6f33c535c207be6d09bf04c9672aaa684c93c49fdac64a1300eec77a3d469d559a2aaf5be4f14fa4d9b6f8b2a472ade724ad99cb55d2a066d3c4ec774821e1d523444d10474eeca2632fea72cc12beba25b90312c914a61ce0598df6e4386ef65bc0889f8c0c39bd4eca749a5e99c5761812b0ad7851538aa6846f018613bdac027bf25b1e9c658a753aea836850fac858c4560d9aab0c3edc89e1275c8d85c016e111222fce56c473b285bcd6f7700cef6014b2606ab4d7ba4852968b435d3ab1c69073a8fe52c1a9232ddcf2c3c91b16c3ed654ce9253890ff161f5006c07bef52aee858732c3b36e37dfed694e307cf812869fa9b1f6a366fffc37f268294cb43551e5d248e2abd2d33bb0b5c9216b858fc24b2a16d70eecea51015604b3a3b4171a81ae84559f7fb31a3c92ecd61ac8cb7f5cf81995b55a84599f29b5e3ecb2dfba24d2ad07ab0bfdc9a1643d4d0f38028963a2c5b3a35c8139fcd73a0dd0d23cffdc90cc2245b89291a7fa49b9ee0c573e919cfd7039d5ac2c47fe8d4c488ca7079a1d88bb6cc9705d410f48ac940d683951abce2b62a287c073d84de904830dfd05ecdfbb1f661076d022371d7f855b02571b6bf0239cc4f3313b1e9b3a65e5f449c952f46e8827b3b49f9bf482dc447cf46a0e94af0aab8a66151a1c76b26b8089742b77df99d38187363cc901ffce36cbeb93ae73fd0442bc630caa1ece59e1a51cd27d397a8c81e28097c293221b664d32285498eba4504ce62ca26f2c3a6c33d69f381b67f2badd4d96ba6eec999da329f903fd36de025824f83a271181cc362b3dad60911995ae7568a34d6b05e49271c5f43b7b51db3366260b23c65fa6f5a82678e9437680d9c506e320af2aff2f5b9e701cb8578930f0e32974bae44e9e0a6f616f4b91377167ebdeee6027af316dad15a0d74d64431ee9a1b2749481b99fdbf49817c4d7b11456da0fb5bef63951c11f71ea1e2ee00c8dea14dbabab3a1ea53ade2f6729ee93dba8b6db6e2939927c44de70f5a8b73f70a7f44cd1f7151802005e6be65","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
