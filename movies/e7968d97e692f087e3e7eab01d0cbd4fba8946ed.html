<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b5d1d48e1b1a719d8f544fcb771610ffcddbd3fc6d89f6c21f8c82b2d255afc21fe68cac50b9268f5c366867bff7260c1ff55a1fa34fd11b9ad07497dff22abb18e2bfb8e904149542b3414f4d79c78e616358d7462d7aae2185e3ba46c9279607d546eaed04d8a94ec26b970df8a4aa36fd81a5bee5ca52bbc0e940141a9ffb29e5ac3d4683bf495c7acb492d99c3e6fc2c8598812035edd5ad3935182693ac44bea5f7cc9596eeb741630a0d07ad39e3e6fd4573e2ba5f3fa1e804b1141f8a086ddf6a3f1b95adc52f275036770ea8311357c303709c4fa160683bde2d6c2aaa1f7ce5b439d057d0e67e6e7667cb2cac94e53061efa0474af775c4a17d6861d0e741020c6c9a06290069efde81a986e2ebf4c8ac466161a5f9e83f01aa3f3ad23c365b6f514be330bf080568c4573ed4678a46fd934d7e62ab699677111d70a7eacb5ae4644d81c93b4f64f74236c01196b90249ac3ffa0bf0ef6b15069ccf996b4f769431a5bbce70440d7736d70d02b8ace3919109a08e54878ae1471f82ff591942b225909096cf3e2a70f815bad93b90361551ae0553df0909fc3544012af1a06f497b885b5513fc3912219d5c12b146d968195dcac95cbd4cf51981fc74812e4f6a40d7686e712289a8ec27dedfb8d9839ccfadd27e8f17c060c524ee35a3044cacf3066b1665c36565c97c48ae439fa84b6e4a055bcc9aa96b0ef46db8bb2645e7bd1526636b15d55a859aefa0e2802070403d59edf535c1e8ccde7c5836f27731e099d3ba38478c8d1491d00a8d43a83fc59dbce031c3a11bdb745a6a337ffb6fbfa8fcea3b13d7f3752474ccbab7330f3711b0b62769d2cf877a4686c1f924c1d40edb1f37a27f63754a52488df23391611967a20476c03a3320f11b612bc43ca17f3ad92ddb708e3cf849572d414784bb41e1301d2a9cd83c254bf6cbc9575e63553696986a389ca64c4a3e1250e15a8385fc4c04bbe7b475e7db19a5f5eaff19ccfc3de4afee0f4319b889196a9234d02c8caeb72123a6f54f4cdf391a4be340e5b9ffdad469b6bbab43f2ea22e6ed120474eee5002b79c3eeff0d05dfbf8d77a518740796aee4e5fbdef440bd41b63b11ab79dd5ff0ffa1e3fc2e33b6d893d9b0668792843a14adc660b4854f64562b5b8b5b64da09cbf06c3a2cf6966341891b8c0702f9225d5f348851c28c45114c787467f927c832ca1f2e7f82384a1ce476dd96ef8c118299ca64bfb24e5836045466270b914d9f9b6f19b61d822dc458358ee909cda79d9100f0e2b70f69f1bbdf04b9bf42e04e2aa1f539160646647c42c79347138715ff57e12c7611369fd0668e5263338bce88b79abde749ee11fd44a6706ba049c0386303b8caf79c9764d0b0a16a546859c4fc7d8816eb7b0bb951db86508d6c5fb5d828d0f61ffa87ff247130560c279e4b4f4b32fca06321e30e44c9e4de373b6eb88cf38e396ed57a4109cc41300d4150c5a39c1efdb9774bd9a158e8a8eea54cd79e7e8c6a08bc76c24d3987675e67605f57cca1dbfc4204ce613f792dd0799dc9d0563ac46064a23ea5edc24079e35bb8b179744b95849a47eb3b255ace99739eaf55546e72b45c58d28b507afd00fd6d6b29b2029b045be5327306b3eece1a6fe5533ad6cfe870de13dd19cfa8fd1eacd7d65f6f6e021a7e0ae7a67a6b40141ef1bbf3f9feb3be608966956df1016eb682ad2e04ed29f45650e01515821424e0cc5f9daa86ddee4e06d79206b3ea09782ae461327d22698a421a4fc24a4d2ca393c69298435489d7d185ff80601a8bb7c35167c6e4e188be1dcc009e9671da1c1f942723268a3dd2e04c3da74a87d309746b7bfaac54035e5be6469223faf37c7426fe1e5eaa07c677d46a8f96a3ec6eed47aa3bab52b2ad22a4b863f3977f59bc71cbc5bba9f407d5fd3d0da5331a1919ba944973bccb0a5f03d99c672c85d68a09e0801321ee2f857b05a37f6ffbfcc3ebf1a144a5fd752f49da17bde3405b1e692c1e4dc77b84f0eb8fc4809556e09a4f99e2b26624874d6bc89e347333ecca382734c4eb523a76af999c55a3f5a8ea82bcb4131043744b59a4a33e0f717e456ff1cce6c06b3da49e281a223cd10029ad60c9d07cc13c9a9d14ecd54a20f34e3b29db7aa19010b8909096b1ba6a4b27c2f7ef80afb045413fbd844fe54daa72b325d7c70167977137d8ae01444ecc0eb63ff696f534b39a4fd2135e004c1501a64bb06240cbef1df0cd9f0df46c95f05fe30472fd4f236e4f4eeee8d17d054a9f2b45972013d7f4eb2af5078c0b34568bd2444b16f6961b47b822b9ae0bce6ac8bbb53b4b8522e491fdaec89553569975427e3ee4b8a7aba7732993757e078ab5df07e451ebb40af149739dc6587f83d1cae42e2cb027f3d8522e72796e75c89f2a104459bbeb6b956c42dad141f4e5a47d896259895625e025000ddbf1b28953223a4f56b92e65004fe5fe35ea4f47555e6394f047d35aa7ecc4c3e7be9c46185e0eb362e00f545c84e4debcbaf3616701d99b407ee8d3a3a2d7373ad928d53688b4ac50212b460257e52dc6d94e62e50d8696659a2dde815f54bf032b49541c4b604916d0deef98cee4aa77d3382119393e2c2312a257bed9a3475954924bfbf227543a22c22e8c20e8a2a6d3bb8e1b4dd20b0344c49d665d6cacbf52cfc28fb2c9fe55f9958268dcdf3c78c4ed400cbb671d2ab6b09758248c145e2494851750c805aac0664083698672f0da9ef810c72a8fa6ae97467fb5a214f9a8783860c2ada422a354fc16b7f8bbabca55fd28446ac2472323bdde965cefe982751548e22554f6a5ac3d847bce06f9aedb13fbd4ad6673fa6a3e5542e1e6bfd1af822377236325ecdd78ded9cbb53b450cd945389a41cf4a1e87dac9c62cbad90cf7e413cbcea9851765624284b84162ba9a88c853f91a86c047129053faa707bcd69a46d198eef6166670f53e776eaaa96bc8795b814315bfcd96d4cd2111a39ce0906c6beeb2eca659c31bd24c7c2f31f573f0fecf9217f542185e3b0c34b7908a7aad42d50b78d9d778f9eb45137e8a874d8d082a953ff0acc86511b62c5d44891f3544f3b8190b8d836865dbea5e676104906a5a1b62c7c34d9a2bccd52b85f37f10bf70553c3c77ff13747315ed45f613038a6889110c0490bd83829043a473c605567702e53cc94561fad71cca5658e1b679c21d7ed4ea588a5794e278ff4c9115bc1b8c7a882700470990f6a73c22d10962a79454f7896434d252bb611c4ddf0afef91ebed203012ac5cc884f4ee8d817cffb1b3e22e6b3021a414194a80a386f49cdba282e9a68dbbb1e6ce697188b94bee745cdde9343571d3a95b36a2a1c3a256c8b6ee1120ee76f75a2f091fdf699e8bc8b9f26cc31f2e454bd99ea6e38b08778113db5e405f1d390d2c3591ff5ede6f3709763908ebb0d7f52057f92a0a4d8c175bba768f1ee430baec0533130d0437f45912649429e815d847eee4dd6d88d65492a49d786c7af76fa073752165044c8b74f4340e413892c49b1e14643e795b6dbd02054c6ebeb5b4a4f1f455274e247b161986b3a3553cca904aca1dd6271636343cdb4fc16399e5cf1c22d2ea8408ab273ac9601f2242d4023cd453283af53dcf0f0dca3a4fc6933215ceb3da315233f1d2e0f88821446ff605cbde2e5627b189daa5dcdcb2df918e9c06609ff69142dc2e11e82e6be72bc59f24d1d64ef14e6d0de9696496c3b1c66f6b3b71ed54ba11724895df364d64e942488423c46269372a99d90488a1e81f56bb80df369400542306573ac6d542d2964069335df2e5087789c97245354fc96a4344d5cf913dba221e683d1909b7805d4300e294278f82b33b4eb1b10cba9598bd7abb2dad4e57169312fd934b38960133e6c36080e282cef1d33215bdb94e64ff6f6046109d05d0b199cee98ea0eb2f870dd50676ce76f22865ba3ebf2e8178caade2c5372e8b7be4eaa1bf8f7d316cb6ea68f04470e070ac826002fb2f704d522034b76deed379eca01a02cab47432456e252d1334a936d001de6e2c6a06052c770157d6151edd10ce172ebb87195330567ac8c22e4b1069ec88d98ccbad96c555e77f6fee7fe7c5b072f01bbf992c1ca27d73dbfd6f29714da061cc5c8507d91d1f88d7bd60c1124cdd327698d298cbc6fb4d8239a4aa3f3646b4b2df11080da718bf200fc3f63488d235fea2b9f86d6ed34016d55497cdd79ee96a9c7a3f07942444b1d9999ac18516f62aad2b18f1fcfe3f0c3deaef3abed1964f02dc6c9cd396946a5874edfe830cbf7d825c2e7ac8fec41caf90e3602c46f80ecbf521968bb859e2be0062f7788cccb94cda9cc384aec688cd30dbe8c822d096f57d4b686d033cf15306ed3fd0b0797c0e4414f947eed729f5d22578ab0c61df8f4e3137250438e26ef3cf23f36116b5d57cee0c685fcdf55d1eef147106e6e27643311b577ed0e903e2d15f7a64467f2a73018630568ea3049767428524708649aea8d20a2a0b5df98761f76dcda5d9063b7ec4a53a9fc0dc73277e69cd6f7fa86d7f1c14579bbaee57122cf3b2b6360deafb7a19b70c63890520a633ece1cec591c0c85eef1752dfe4a5737353cbe86cafbc09cf608a6f4439f083e97f280ced75cd7cd828efa394bf47abebc224d07bd8daa0598133f2f7d60777f5f6070383640472738ae7fd0ff0efd77ee73572f6e5ded1c824170ca207e5bd2eacd3a82a97dfe54aad0b23f37d33429780ad6f09e14a36cf498f253d16e1ae5c8005249c52a76b77e6fa66e7029deec28ffc612356d76f6b545f393212a1b0195256cf8057e6c69db1cd637ff2194abf48dfa77049411c5d8e6b173397bca39e168730268e13ac8abca76219cb7eca596937131149cf65c39b06faedfa453974ce1085da03c60468290daca09e589a3c3f76f2fc04beaa34158f2670aec897b8b2241c69336f667ecd45b7ddefeec7b935374440597817d7a4cf143de678b59baaf122ff43bfe92d98b323f6dd51fa0ebd1dcd9744038839d04a8a0af595cc58dda663628cc41dcad663e074d2e17ae84b6bb1938326576d6c2528613b8f64287c00cbc11f90cdc91e6f4ffc59b7b12255b58a56201eb89796700f41cda9a0a09e9104392adc503945bc31422282adced2ae74bb8cd9c5c304a0c5f0d9431957d123479918e67410edb272de299b836e0b8c8f6655323e9ad17599b25fa7446b497eaecad9d6ae8e128d54d4c439cd35540c3295d5709aabfeeaa74901b566dc121ad38848067f8a74ac0a33f72f0cbd815da41436ef30336835c203b8af0b8830e5998d75544c9365d32e969c318db020de4ec1db8e78dc44c1dcbcda7018724af9c9edef5aa680bced5e5db211b30dd2a2679ffb15c061785d21e0b356853565f4025bd6af04aef938c62b5eb85630f8443f3f1d1c52f4d40384e8192ab5d5a003e4da72109c2d24c86931fc6421fea73b8a570e4504d424297b16cc182234c516966982692c8ac34b62fbbdf5a57d836dbce72662a7def60470dbbc7fd8f85297e5b1c393a7a13e6f9dcbf9f71fb7472739ce09d88f547eedf5afe6dcda31c5680f191641a4b823daf023ea2a230a91f5dc4c5385802d9d047f9fbb3e3a02d13eecf6c62b8fe0437507db1574a2ca546fc0d4db5a582423a343bccf6c25c7a42bcca44c8845d78f9eeb008ebc3f287177ac44c59cacbc522d78bb9637b095f8baf6e9216f996991430aa00ce50aaf54ff2d60b306bcf1f82750f2cc7917c13491a4f7e15a33adbbbcdbfa418e6721e946dce89e15847474ee5fced6b3230c062d2011b64a125339ac2eea31170ff0dd6107109dbbe5ee9bd68fa80195d2f01e92352c1e1468865e068fe0d3e9d741c70f4f4a5ebab8e4af7ce695c37e5ee7e6b8b9d6205f1341bc668d2d22e16056339075040438913e86b01a1e11c8b8e42a344535014d98437be4351d7a7ca1f09f5b6a3ff1f2680e64bd68ddc0f0e45b7af3cdb1462c7f0cdb8645b5d4b176f53b8f15a42c62a86e8fd7b66230f484337bc12ee72f760d7e45eb8762ffd94ba422edf1c87055dfec28b908802a7fca5d92b6c3ef81be14e341132722417e77974b4be9c96b864b898311bef629791eb844348e24081ac9a76b27e94845c6b33e21eb92be19337d447fe41e47caea3ed066878e71064b2b9c6f6adde5880805b27e011c392ef704658e423db27eb33d79b7279fc1276eb9a8b0a3a6a403fffb0815492a8bed99118ccde7993a75568a389c851a2dd16f2e956e7029ad02bcc5106a95b26d919d448e12fffcfcefe1ae04be5fb45b7fc97845b25e27352503070767cec3b5617e8b17254cd2d6139aef5f38c28a222e6c26b42f445d5379ed2f591142d65dd7afcbcd422d52a5f311440faa54e7efc41f0de061de1b212dba13ddd9a247c3db526619d546a138871134c911e702cb43fc0084b8e1dc7c159f4202e65e2209c3db384f3df0c80035c9ab6c825085d88bcd5a837f5d388f699a4703b6a0f7b3f9a2c6e27cf47394ac555cbdb95f51cf9f483d1d91c499d42022033dd8a3735a2672232a3dbc0c63275d6bfb93cd664b4b822b56178388db36d6919c529473314bdd7c87a61ae52cc72e1064766a25f3241e589e3abf47cc6a6bd4c1629d22fda1de68befb957bf80453255e70ceff1b3e6664a53e0ad14a47f0ee61221a91f83d4892c223938027bca7e9a353933f5645c232fdc7c878247f97ad33a8dce70a245f69c80d14d47f19cf3e498e374aa10bed7d18683951004d9c3f4262e7bc2167da25c30ed6d69e3449e0f786f5f9618bcb94e00489bdc8d59012af9dc6af9d433907ee2a91909bd53691075fdc1087549e9f3e09176d7398ab0102a2971f88361fd19d9e6986b033580d8e079803dc8c1c5336bd469b3e0f228d9ddfbe7fe34d84300bf116a989ba3bec2f2410593346c59624f24315b5690822c77f007f2d016c68557e248102b847727152e348097f4cc93a19ac6378d199272dee76da69f67e7e748f0568b256a53e160af2be6c43324b7636c5d9915b332ab15ada9b1e4e578f6e6cd868353fe37111ea5bcefe52ec0783acb69dc508de40021d8f587082450f36fb149e0ba4ee9df4a85bc44c81e3bdaec9a7bbbab13f42eb9005ab691c42ce5cd02a6d0b25619bd994f2bb9cad0909ffe285f23e35d426a26899685d08c5c4cb92168d3b64fc9b439cb774a7c0de9d3c3d685d9f9024f3019b799ca4dac779390d29531541c5b1d8b258ae3882f07340992f89deacb8f214c9d70456711077a1f45b4664f99cc03cd8d79101d214889736c4193ef8a7779aca84e6f5e2860ae102e188d48c9bb5b1a17fcfd4129129cf8abb86784a1824d63a079b07b23acb91df799e3f6aae2e559aea3626c86d41c79e01dc4f266061a7d593593d8032ca384952741c680cb69d6ccecc951f948da87443927b9fe8102a8ed047efa81add970a802570cab03b0890dcd0ef9bfcf8e4b8efbd4678272a51a9e48340284260e75291e9f5fbb248f6530cd5b9074718215ffe72ef5097aeac1815a556161a7d7fc9b8818998688bd2311c740bb2b113f7f9156b900ba625274d236cd5ae205448e3bbfc1d60b5db2ab2e40e3bc12ac56cf947aa21e1a24c989a07a654ca9c84ba11f9a306dcd47439c7745b84a1335b8084a2cd30bec73b07fa318401f28ed2606fbc08a7892f927933d4930f3c4d85999f9dcc67f64d380d06a5583ffa7034df821df5038f75ad8a9ed2eb7c4a828edf8702467d7b6e567c4f67515845bd0c53f67b12c065255131fb444e538561e04d7277892f7497f8e21687703b0377f08fafbdb919cde3ad23c8404cb6829d62ea2b73a5ee3eebdef94b435778a9debe92ccba0154e670319802038a3684fda8bae206ae8a67a54e9d07c7c0b5fab2c7fc4f0d1db1f8dfcf26b7aeb2f96b58b52e2778a9a7d427db49e7035aa17edf9f2b2daf012d899f6b8d2724b0ff2823a77a861558a93fe05e88d8f489897d4d54e4692323c106cba2e4f7318d821262a3cdd282cc3b06b696b8f1e0f2b57e8920194c6c7d2cdd563bee3674cf43ce0effc6426ce9e94ce9921d5a169e7c0c7e180f429f53e31fd45593d18019669bfabd48e62af5d869771418c874b3b64f0e740ca4c8635a877563cf65986995ae7b48b6496ef50cd572f14b24bc4313ba1c4c4500b14d47b9d7d0765c4830aa78590ad5729ce9460c3a709a542932dbc2a1727648fa4034d7bec4186075f5970ed5d48013b69b07950683572c9ee29d240c129d9c243c3852e3bc6915920224a28ca59aa0ad95a8bdbe1c91efda6f45a3d39fccacb56bf924f9416e561a42d787e5300934efbb03a561cf2132c28cbe13a9c76b504586e46fe56a1d8d73398275649ad242c927c40235a28a76f3e252ee191a16e745962da1922c8d52c22c40137659cfee6427ce75df498558da85e099369d0bfc76b2596b1b696c3d0aa618210014a91d26c18110c57fc17ceb625f6bab2fa500a3166789870ce7a09050958a089a9b0df5e7d768ec3aa835bf13b53e1cec81e8bd52fc426f19b22c1dc636f4706a3a0059fb85ae8db2438111011090b12e2166b70dfe740c6b745d4491141422e845da6e683d7be9c9127673b2728bb26f391af06c8992330a3d2e4bd97388826605d9a4ee63d37ab6fbcc60ee38204a2aadb62003b1fb740e77fec8f220e677c5f9228f6794fa4818337013301f52a9f9574b361f7b8f9006caa34c877b3e1294f6e34073cbe4527905530048641b13bdfd8bd287d84b1c943b797739272e8445c9c525b053d7e6e2f05fea80e072b12153b5bf1d7978ee59c09eb264c825613096c4edad77074982aa75c95ecf966746e7269940c6b65b50914171bd12d650593e7de80f6b1620c047aa901a1303a145ba2f62a343601583ddfce5809972a6e83a4721d844fc75f23c84c6065800e2975a17a20051e26c7f77d3c24ff3a7b5d2c75ede8b72aa060c2dd9b2cd43da249b7104b5e3ecbe4d638a161f8fe25c46488adee624996e1468edcdfb75c9c95fc47c4c7b66e1875c657393be40ee064c37269baa9938df8070c82d715bbed80050825b2e35b6cf7f7f0c9913f305696807c1b10610d6560d83d44ca65919c867ca9c46cc14b90d669bd5e38fa7ca64392691dd86e0badfa790c33721cae9507514e80261d49843ca81a7a6109a8638c32f147fc3a1bd80020785062b40da9f19dbd013299293d6bbcd5746f8d354db07c6cf1296486de4e71f649a5e588e6c250735cb777c673a686ed03cb4b023828f62972d2a93c2d9d2811e8854bf3ee55ce3e07d45350c07ae3b7c71a2b343bc3ea315dbe6f9b8dce52cd94ccccabaec831c6697035c3bea4db612a50e28b932b16e732758cd9a5e6f6d978e6c76a8da4b3089f7e7e33ea2a44ad8800d6baa4a3e831482cbc6e1a1393fc58f2553fde8f47ce78820a5ca41b93c4d579fe634703f295c790e84472fdee599c0b2d930fe05a5cb4690f3b20a5b89a350d21856b10c04da889cb618533c07bab3ebfbcc6c2b5067a5ab6b456f86b130b074293011c3cec2592547f84bde09f9ee6f4481aafaee19634cca7f23c8cbc487a7f8fcb9cb67900617c48017e784339e0413d187b6efd3fd5516fe612798e9b8141022722d82854cd5924d0fc208e7674b11597673aff65fe4eb10e7a1199529a86b3da42de2a72bbe66257ca85547dc59ac3970da9698a1c7e7d6d657aa59b8d96eeb57657f0ad556b419d89a871e700342e581b7a60f067254842e48d2db230b2c5d9c6608c78cef553549681069eb519b15571b961307cc922464183cecdf2cbb56f545591214d6c69389f0855d88a4505a4ecedfbfa8e757eac5d3549cd6c84cf83c8d3e6cf71b01448064ace6e328ab23cd5750e77216daa8230ff4aa63010bd5ecde216a48ba96bd1f3ec3851ea3391a75f2482c0e0efa1568facadb8d1f833be28d0eb0fb8b3ede870594a37f0c83f18c1be806e263b942021c86c40ae32720497f1c4e8f95315af8e371afced6fba2cbb76733e65a54b84e807141fa00b6ed3e7df00835cb40c85074a41a0d15d0c277b0e44d5bae47f60abf2b3e30fb3991a83db8af6e18cfe416dcdb3d860c6192690fe6fd51df77812b9df859e3215fdc563097addfe2c82790b8a8c16e3ffebf6557c9d1f1d1f3e64a43c871b872e6703dc80571ae3abd7b006e57da26e9a752803f94b6a3a8702e2d39facf5cda266b68b8af5ecb782ba60a3a9fffb595078c15b41df4edcf8b7e6f214c0e59e02131645ee96ede812e5593f5fcdbc53a7aa97070991de03c97d219cb5f8fa6107c00a0bd7997ae734f937ab3b8eff7387273faa1a11d38b7f04ad9fc9a416438fc2951b3b1db07413c2e6ef51bbc1d788e2972f81bdbd349fab323f30e39e01894a20f4923907f4d9da0dcc14b20704cd55e2446cedcc6e4bdd95073e122135830e524787b3357eda48aae18648f8a0f8777432bc731cfc55dd43c093950bbd491026f08e75a9bf86017110a3bf1f85627866a51b4bbc436e48e7fd1cd4063037c522e394d4c56c2eb227f88cf157eebf20b610a14c7b4446a40bb414600310b1b1aa3b45cff0d2f2795c90594e7b59def8482d87a20744c4174620b212f0cb13fa36a9da6b96977393f9b4ceb0a86fa4091330df600ff6e245b767dd99ae8bf7b846728bc6c1b0c7da08a9f348db5e6cd075e1f999d1dbcad084ebf554d7b6e55f05a0ae326ab464774b4833e62f6455b6c1fb90959298726ef60aec2bbc1cabc9ee1e08fe1aebc77a74715e24df0a6b38b524d2b88db4fe48c6e4bc66bb0507e048bc89dfa4db89220c3e955b4d7758463c04f66a6a19a64eb6129408bdcc33a2757f196cc2c339bf9b3c22d7998690c00c4aafecb8244c267a46c7d39f72d660983ec50a70e323be688857faee3a4a7e66c8f66c0b43d92cfc480b3d2b511575e266855b6ff7b3fe51257834d9b98635b750c354780dc751b748bc1f215617f9c2057dff5d48ccb05c929bf8310ce2d792684ecec1b90170022796784181ab292f993fd8ee9a372b3854e5c5224257a0e4ce2f94679ab38d689aa3f24c55048b7e95e0e1d7a3270947dfbd36f724597fdf2d304d541a77d71906168db055629b1e945631db1f4ff624162a421da2d4fc09347f320cdb83d3de3f38459f56c05fa6f446e07dcf49f334408881282c3efa4e5d1ec75f8e85025d308bdc6af5623c238095bceb07d3a3a1bf7c028a5c515feb419249909cfe5784be42d9aa50b56e877fceae0c4a068c1c7f43af89fa62ab8a91e76fba969703c44b72599fdf0a3b9a190caf14b6311e767d8030b420e4627758ebfac4989fd75972da4fe37036a1bd605dc0ba2cce438325e40b2b1ee6d7743d0102431d5519cf49888440ba5c2803729afefccdfba7a4542675b91f73c7c774a83873a62a3614e1dc0dcada4c780e964ace1516293893f1b6c22e5f866b1b0121a0886ae5783d3ee883822e3d4dca381ad8a115c2f644595950aba0119227e0fa68a2e70dcd33628babc9fbb32c0b922b5edbaf5bffacbbd1686779195aefef258fdf1606ab85f935753e6e0b4c29c199b5d36d0e93060f773b51835575e6440fcb7857cc7bbc5488953725831a51bfda5759bc4162b9c6f43816f50d8f7342b957acfc0039ed4d3e8a61b4bda38c7782c8c0eabd0d6aa18357ca9702050936684710f5af1991b47d42220191469fdc133c6e3de44a9e8ac63939f0d0b3abf6d0dea00d1ce7972874ab5840d2bc40cdd7e8cd3f9fa7940b0fbf4ce21d1c35077a2ea0d39840f833d90ab1bb2eef8a3abad907eee0b5c1dbedc28ca89e33b692db7cc6e89e025ebe52d95ec2692afb20f3bfd3da74cab0500dec51adef8d8adf99af91a423534729c9ae1e0c1a74016da5b4fa208eb03b47768dec2b3522a3e44c902e6a831b65a21e190e4d62417b6d5d9d1f7bf8a8528c9d75e704fbf1efa973fa269f0c42def6ca305e30d08c516ba9c1ed8650acd1a3af9f2ba092b14e9339353a521934d395433496c7088e3cfe190323a338a0d2d47ba439bff80d99e373ae0eeee48900ceb7642381dcf714b1545b6abf8e7f1ff2595c452d2c8d00e8389d8d9f80550d59f25afa6bb61b25ebe8cf08311079734b68c94fd024682da026b0f668fc52143bddb02c8f5fbcab7847e21ab95a77f5c7bfe13137e8ccfaf82d92499a00604eff92876cc8dd054449b795063445bd40016b6864adbe165cfe621a2d2920929e9476161b9663eb327670933eeefe333b11dda527f4b5a3812e9125563886ab3ca46f26a874b566d2333b8cc3d6fd7e6e2054e503943bb3efffd74f14128628aad922d1d17d77441c81dc8f70f8a29cd7014e25dee17876245aee3a958ad71cfb9c8537f80ced7e3ae1fb8240b1ee036693061513c5958161c31991589e0434d539ef0f0f604ff65130ff8470c7286a1504610bf07cd91c0ced1d9e755960eb8edea830e45da7b3ede45a0db2ad3869a63e7ecb1dad03fc8fc5f10e57c07ccf5b03e8401dbbb5f90e44e6906e1a4a83a1b4770bc73adfab2915b6bf402a6af3628cb48506064b8f5acff1135ea3896f48174aecbcd41ec9f190af4f5fd6f6f1969735ee6557c8c75592b80c40b04dd57df5ff3b691cacca8d971e23a780e1c428dc0b1d0b5ab26d73fe557df9c7fdb5acf82b4ab158edd5eb3a6b9e9f6e3eddbc79af005c1520a2f93fd3ab9019fffe684ec8f76aba5bb3980583a4d16c7e4153b097d5b5befc726ba2f53c0b1f6fc7df58fd013e442b20d03d955bdefd38d7b1da43d3cb68b0acc1617e977fc3f71a90befbb2640b677ec403c767daee3b08d9974b9145380d5f7f943e82bc44c864a9cc73053c26bf32fea614d9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
