<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"232fa9178998244be404fb0566c71d446ac8f22185ee8f762a546ae61c3e57ade98448423904406c8faa04db3fa763519e8e1ab1efcb73c6dbb4fb54743c964c876780c574fc1b950df13ba18a7640f86dda57ee318878d7f9884ca2447cb93e7c9320abe260436562a8f17326b6638fd353357ded00b3cf5521437003c5ecacdd9e3ffdfa0a2413aaae8f266aba85f6fb940986ecf80142d7dbbca520994fa7f6bc78410021a62fb2edc8f491a06f13fa5138fda6b642525d89c1d050aaeb94e49bcdae293709f163fdc829fc43d80bda9010b21825334d0068340a886e5b8ddb04800230b31ba01b83836ae08998137cd55198cdb7d0c7363c5340ca1c073d490d587aab186af10bf33b277db5713ba0f500fabaa48b322aaf6b4426a2650b5273ce091818323c45593a31f7ff7ccb86854e1659c7d24623b2aca0ebfc4ccc54030970b5bd8e596c9f86ef9bb6ab9a8bde0a540a4e84fe7e691fcefd24b5598aa85df390a0620f5894b822679fe14f9b6937c36796049aa20f3e7bce6ded5c3c56db98e96b5c991c587cdf78ba1f0fb1aa7593d71be51ae3c0ce8de49e37ffc131d9dd037aff60ec91e962d35bd22f2c4c0912e70fd9782a61eb9b569e4f9c24b83a3ca42aeaa0089908925380bed001757064d17a2f29fcafbed80dbe17fce2203a5e9d2bd1e7905a3c93102f9ea7a1ba8a325a21705a457f919ee7c79616f7dedc8d6e29c91e53a29d3a9618b14117b75e12360ccefb61f175a0e142479287ed66867ca70fb6aa2133b412a53a10c4ea07e3c2db33f854ed5d6a05b047b3ced239b41522ba5d645f5a0909414d4478fd4cf1f0d0c88dbe6583642158ad90c1b3b6c8d54b55b85a76e0a00b05e4fc7213bdf23e8118433f9543516718936f824b7d2eea3bab2f356aa6cd17c5d3c8b56a0cf6b29cb865a22ea025640921b69e1b017bccb3e1490cf1253c9f222195e751961fbeb54311c55e65dccf199bd8286280cc9853bf80ae4f758f474ce3fe478a546e6ec00588d14831666c272c59cd29f2343c23cb874365089610780f365a4457f4bbb01133550b0ef896eda400d191274d3931e15e84e42bdca3f9dfd31615441e7d58c7587f25d0bf9e10724b9346b40b60c41c58a472b10edac9cc30aa622ef6893a68a4e9e23eaead957f46538178fa33eec3af58dd0100cb4f4a974a933e1252e779856a2bf1a7097b00e899fd84e343dfe72322d9cd84e6358b4cbf6385c8d7cf977136a3b69ad7b6a12dae734e2dc86706481d0ed4455f55ee90ff03f4db5151ec7ea3f3c4ff095b733e256a444a3ba4225a0376cc0064bedc4a941f868de5f4e14304181d713bad6b79789e065deebe7beefae2cfc8e6c603f28673ae029cdbe30af958522e54704df23725153ae4b89f95e2a83959f56adbbbb6736aa48b64582c7759a78cb710c0d6ce2651c6af26951761908c556b9bf7b5c98988996cf5cf146a04e9e0cc02452656e5cd3c3150e1ce82915157ad8f8eebc0282d3a7d5ea643e5ed433bd80003874dccdb8bb5bad2912133e37fcc729528aed5ae5db70c9c4434ab379ddbb6ada3c2cf6e23c2620f281de8d54030b2e68cfd9c41b815b09f35dd7b82b1a888c4d78c611631e8415d356ddf74d46713e11858add48909545676066c5ba49edd152d0752b06c4516a83a1b33f79026b234c48371791336fbd300d8289b288111eaa7538ca294c1be1a44b28096637af625e6d64ee2a5bae73a068e403eb96ad779ae10c6c49b06c3af53969c45652e750ddfb3be577cd5fdb719797c02b18d4d353c422c079c179eb93b6e5be4ea4719569d22fdfc25eef65c1f99df9dc771a3dc08d26f438de0b86ae566a5366f4e367ed9bdb5d805a1cd798be14e47095f142c4e548697b4c91cf6aa17a33e4538587173031d2297a85d8d387adecc4ec8255202582cf0a7b94ff9ee9c9fc420d34bba200600ec286b7e90f0e75bce567eb91f6a4a36880c142ef016fea0822b43cf60cc08e76f46201c1cca48ca9b64f20ddb02c3cc1c08bbf7d9e93b22991f322d1740f7081748f98b6aade843a89fc7f8703a83703991dbf3150b3468240441b91c7fee9a9f41567b0798bd5faa603121b06edcaf3900c867a4f85e5ea71f068ff48fcddd53f1a0af057f7593e7b7d45efe83541c9832dfb15819107997756db662b4c804adf6bd813a9d76fbe3b600169609ae85cb1869c4692a0f2d276b58260d8333bf72262e654de501a969b4f7224e4b5e22154fc52009071d4544e7826b28d365ecab5b53ad7cb95b8167c85b9a6bb6131275b9b79fabc183dd1f474bb8f6715dcecc88fad55d1cf208fe71efe20870dbda854fd9d78baee4c2e58f64c9a735e90fa3f089bb2ff18fc39a8292442aaa000231f633306a7aa20faad38d784b036d10e208abd7eb22d27053b31afe0687863ae123e7d1a06ebd186c788e312e99072e5d37011663977004f3750bb3f0cf8f1cf57f980296a251aeea81f54f21ae0c4b46dfe398fdbf65b0492c46efa070be507ed92f668aae0761838b0d54f15c33f70498ad51f68a519883b864a0c58305a3df730fa2bc81fa61a28419167c54246926d54240cb362efecf3d014c86f89606a7b68c70dedb74518c2e6633bb690d0646e6ef5caa9b9e689c6c1fd5fc31d186fb549fe1d6cf6afb04103d4801d3f6b037a520034cff48851c400ff646a8ec7db4d3fa616973a8383a7a3a51a7f7295e9ef0e506e1dcc8e92be89a366bf0dea1538a33baa578257f6bd1472c99ca69743536114557d075dbd48ca326749dd1e1c5f96610a4b48d091ffb3fac06a7e8000be9d79f099c76a62666caf9cddc2c8f1c883173a40dfb9b3884ea09d3856108431bbc77a62302f55522bf03932a2f48866c4a6376c07c5a0947ba6a415000e8157363f42ac864ee951ab8f8573e829c2cb242b26bfd3a2b79600a90f900f532c28f126a741bcd1319a7d16a2c004f45ef1527119e9225c51f5144190f7d4378dcd12dc2626eb0b62a5872ca8a2bd6decec16426904e111551dbff8fa0c17882c80be2c1e540526721c4bb7049c665af471bf6e4dd30bf8b603a439948f09a7846309d23598f0f12dfe764646e473faca762030f5624155f9c1d0f9ea9600b078f99c388aa90e879dc74817668bc34d864c4f0132525e0aad5f12af7933483130c3bee3ea4ed889d539adc5f5494f11a89d5e5a7d3ccffa4d50f9a72cebeab371b51bb68c0dc765909b276fbed2221c30d5c6c53bb7c493bcd7618e92a719543355c60792f7d4b6d0f47cc1e0378a2488c311ac107ea907dc1cd01c2db48ff22ea9f755e62f208903bcf63f4ed34ba6002fc0efa07ae4f24edffff1533df7416a81cbc73063a60523449c5a638d894d5d646abedd07eb5e383d4563120c5d3ad03d0d45a49235ad043d1d8c18085c6dbc16282429b11dbd34fff283a3f480fe57be9e8b8f28409a043e6e1176175974e71854bd3e5a67735450b0b90b8cab03f647e52a99bfa8046a5e6d202ff148869d14d4bcefcc30c089e92ff64d3afebfe9fa593c942ee14e16bd0c1597e04ba39c6afcabe9734b808d8aac604fdcc39a81f5e537131d7798b1cb5dbf8fb8ad3f8f4055e78d5c56aef05f9c628fd7c2c5bc27939bf954642d8d7ba3f86202cba2c1e481e2764e1888d923cb990254f12e70c70608eeab329a2bf9a1e8c7a4e3abb1b15385821735fd102185cc238206cb6e04383f917b549169be9a150864a4713babc89a032bbd2c0527d594b8437c2db4549b366364f64b4684cb1e136422c1d9035bbf5da4b8a64494b5144cdeb8c4a3937316f0a5a9fe68312536d9edaeed46169fba11252e91739ffc30af3449712ab6da26d25fb0682695a7b9aa733de4451af36da48e246c1ee222c941c5221207e5c669323ad48b9603c2eff42dfc9cf3561b3bd73af92bc099e33d7ba2638d5084c4e9b376fcb5d1319fff2a2c6ad0592a179111ee74c5ee29876a34e1130fe97f9712b5c69a38e65c1078c49ae66b809da3938cbcff4ec9f7810c0d8e17f799d23feafaaa3cfedf189bb6158c1bebf1207eff4f9b931a110edec8327000c73cd3b0ee782313e475bd11f080bf804e7523414e187b20bbc604cdc524b7b4ed545e43bbfbd6811ac1504c253286895d79dccc76428ac4641e15b199211d40cac7be15a7553a23fa5364ef3bcf759c02aa68da61c3f680fbdbf95f0da381fafa57989c33f1aad14e80d140bcd07d180cce3f452f8a482b5d3f53c66b192b1c1902d8b48c232a6d2c47f9189727414d942ecd87bfcd7225a2ae1a16cea084217f02090129d97ce53901c3ccb5665495229de4d5a846ef3b49a0f4159f49655054a545b6fa35f8cb29b03b42c055cf4e88b75b57349053235f44792fa2e28f9a0c63b5b5b728f95bdb6c3cba37d4cfe1a5a713ac627da41921e5cd5fe7fff8aa7c2003372b4d659dd461f1fe58ba5804c696046ff1cc319cf91769d22399a2dd8cd10d7979868b05a88546d0baa9925ea850186f11c4ef260a1a233242b7b9d60afbf95730be6b2bb4f3438f1e77bacac5d255695ffcfd2bc128888c46db012593db26a004bf183b692813ff1b1a81f5858c8974cdd299ade1c4561c9ca98f57f4f27eaaf96ae343a48e1a73f293d1116e7e85fa8cc84c6fb3d74717333d71f439b3d9acb5366254e3d74cd3489cad9cff929c4646ac5e032deade3a070bc5095df52f0c04528e1abbb0c0d4ebd80d65f0e4ce6996bd818c60993dbe6bb81239e1b9d62bac01c124e78b222d877f3919d15a8c6b376c72c83da759473695e38a6ba046c6c8a3f97219d99a1871a300bff4726eeb2cfeb7d6b766a9e0382a729369fcc68d7d2f162f7eb527482d4c04e64ed740675ee79c6ec18d003802ce6ebb3334c245d59079665967f564637b09c34d2ef92caa0b96166e90695279683a039a43e89e8edc3d2ea6a683ea65a5bf4462196ef75163343adf9dc487d26f7f46385863a065f69fb36f4ef9a482c75fc99e3b59e9f2caaf16c4e3cb304dc91d6d6b37d93129a4ff32f6d613eafbe983433dfcd5f5c21b32c92e4c3dc4268336490b0ae48acf85692f0bde60b95ea92bceaa743807b10e354ada6d5119990585c858cd8ed337043ef114f77aa88f627a38b246baca0f3279dd6dafbb672ad2314efbc79aba57dcbb98a1e15c2225c1980bd545b3d510c082480bc9f9bb52632cf03d785e8af729e4023c846f34539dca92fd181deb10490a1b1b91bc426b109070cf33d965897f18acb50cf9f3ef0a3cd1250e24a2d71c5640a1155d17a266641c0b3369d2e7c5a1484988d2dc7a6499bf53d83f9509c4a0eff87718cb98419f432446a032742b4e1717c897baa43e5abd1ba16f5a9124886082dea15e951c307c7cfd6deae22100e7fd96858b5df5af4bb59c02edb3ce4cb8e0e7e8021e484a123cdbdf116d8db215c3db6685cfdafe5609303bcae2b6db67fc8e04dbb45a32bb221923d0d027e7e1b505832ee6c8e9f523e17132d1dbc9e9c0f5cee23740e5ac002dd918157c0324db2d6e67cb803847897537452cbaa95cc356edd7a75972c3069e0d005289855774df85366493e8c37b8dd10cff929ed32009177890fea064ef7b9802c2cf0cbc00f036b96391181c2df4e73120144e5a610b9392a3e6fe60905501ab0cd79d71eb7c57db7a8b38980d179ce092c29a6c16fb55d914e557cecb34373e2d8ed0448dc519bc519843a6e1d9f8b4173057e6f7faa7e375e7126348f8bc91293db29f71d2b9191ce40841cd7256d8466f080482005a6ad34176051f18a804f0c1d9f335d052eabd24f7a2c2e28333fc515498ef1faede50be12dd2566689151d0d17789e33bf26a3b30afe39dd6730e8b6f270ea3a673af464893c24e8f22be9137fa0dd2ed174b6ef8ac5d0b40f9dfde6646d78b2e87a911ce289605d9dbe506dbf19454c1349162461d9568ebd38d76dc19e0076a6cdffae133e1393bc1947d6949899d3fec4e6735492ac2bd1b2638a7c989160b24cb6261f9c653a69cd1253e55adb9cbf2256722d4fb45ac550269d2670681f4f47cad7f593daadee743b5b4b94c59a03e6ef2af275c64dc1e3bc7d9f076a6df24b8cbb06760445018d15ecd0c0ada5b5c6e3952ee4a79087575ecb0bc9a051ef2136a2e71503407f5b91b848e61fb35f97b57fd291c417bd8638f63092f4311de1d940d135e25888651a512ed677c435a061002603df3f2c14b12921d98cb2c5df625c8bf59438857ba43eb48b5dcc39ce37e115be14a448143a968e28ca99b7a5a0e60dac3adacd351c20754b5cfc4eba55c44f933e4ebc83e6a21c71af9eaf74e4b7f144a9b717d285e0d7216223880cb1097c08f184421fd471a7cc42500f53fdc94a23d90d296f12e908862261d6a986cc95725078eb7161210ff180100d3c8c73fe6a9756326d05beab4f9c04773437ef2f7f86a25f3e9efe8fa7696e219c36adda87259bd5624ba73fb8bd728ea90548feb392a1e4a38cb05df8d07b83b703e885443b224f68525cb31505d08a19b402e261bbefe168a85c85264752b58321b37ac10b9fda25f4be3dd8950e1affc3b1dbe9486dadd818ea4d9f6703a4e0788531a7816feef7a9222f5d631e3f70e43157df76552128b4e3ffc9b8c71bb8f3fd05b88b77cab8385a7b1acedf2f262f0c1e087a43e3530c3a1a92241ee54bd65aa0af0f5effd006b2069882a6c599178b01d03672fbe107a63a30e3fc4c166a04999ac5ee51dd377be227ea7926ddb6bb86bb80a2aa3288ca36f191ded6845875f6cee7b0a9cc851542932f728a828b2fd812f53850d0f0109e5eda41ece2092ad6515e8ed30558dee41982351a23e18d62471a15ea0a4ca95e5b99db986ac7ca6109eff4eb9ded2328a19b60190ba51cc075342238c235b0d375250ee947243bff708483c9deed0900979a4809b013d56c838fabf72f3195eef6ce280e870076433f3093a0eb663d72e01aaf7cecab0ee95fa307d1afdde934b4840cbdba686d9499faffe726f8e5f3b17b2754fca497610c7f7408b80c7b87a2b3ddabf836fbecfdf00f3c977c58e8396178618917c1e29b414fa646a242e8b092305174ffe9e6da374ed63a0005aa6b6e591b3ab71ac375f610ef326fbf28e24623d0307f5e215890385be86d9199a9f8bcdce6197a43e661a3cb301574c8d6a990a51e4c7b605fb7b1bfcec4149519386776e5744c349e4537c5cc04525ad99922651090057f33511def0971d46e835469ca142d85c07e945f19fa098162a2e7aa707fa3523de2f9ac5c86941773a0b8ddc9d14937026f236d34851a53d6ff6607db120d1ebfce420820acdfd873a98f5224bf2f22a296831358dbd4d6eeba2dc7ce0dbf3d33a0215a8d646dd7fcbe930caf580a18fcac32d173bb679d9498abac4bd86a5b357973b388cddbc01950cbfbc052dcd504028c286bdc6fd3ef71fbb36cacfe37222760e826a0d90a9e0d109e54e59b465c3de1235b99f6e8c93b889c1d2f75c0e241859a034db3e335126f44bae0dde1be7befa17f7077ee31a6edc205e827c8b897e2bf4da9d9eeec73e35b4b512f668c233967009b987dc8a6f8db9767bb4ebd1aaef73d834dbd3f3c69c3a5d018dac7e23bbc1e3de3770e909d044de490f821ca65171184c0210536d3a133767c64e70046c1545740459e6e3f2db3fafcc1bac610c288c9f9790e539ee8ed853fd7d4b6a39f659ad4eb66a58e05a6c84cfd63bea7356619e5e9de203f79e8a70f508c5760046163a10adc7f646929fb34eb16bfc013dd48d5569b163e5a7bebcc95acc199f7fd6cd3e9feb8f7d4ff0c13ac278e5aa861b3a7f44cc60413d95dd201910af5de24cf650e9553ed0ea143fa49dbbad297fbe7e18945a8ce70c241023869a92f234e57e2da1c5f2dcf8bbccd6089325d24126df6b004f95c31018b5fd76c1e89155222e2b53fe12643edeb0cbd6bbde787d5e801ce7aa933969185ca7724e0939ca5908219a1cc17647ec7626916e9302b1bd65afb1a5f656ea36a1f1a73480e57ec8a8de13a97360e5fc09b658cd6c5ea1e454f1bdd533b2fe19f4ad62c9fc71caed49194f5e6a59755121c0af8e72c4fd685629d56caed361deae7f99b07b6b5e10bb0fdab3094f6f8ece3c76cbaf096d33ab84b580cc814c6273538747f207f2cd72720e4db5d31f006c0153be22b973d79c3e7d01e3c67db80ae1ee9c313a1fc344c31758110aa3dc6c2bc583b84af1ef5d2c0f93d39a968df61d498cbae8a2eb9acd7eb6090638b509a8640674ef2030e159fc8a5e8236e9cade7d2c33860a842392f6b677ab5cafea8d76ce7d69a72eb115c7ba4d630be44d5a2548a2b320b9021ebb4e1fb37e7273f7fdf6fe9fba7c862b8b42d7f3eb74d88572ee8b5ef2270f8fa5dbef9d5d0d24791a048e0e2e4ba29041c88beb83cc26da564e6c92257b834600a56a2e556c436267ed07499486d94b9367918ab26a97df85b61f3c2839e71ab942998c5539219f81ddc1cb8c5b99a6be1fb19a8137ee3f240f95a1762ffa27e9c77e0814aaa88fd5fb41136c89d1bcf184b19de8b0c5ee87da6b4df17e6f1194bcc6d517c6c0340f6e2ea225f826a62ae90fe35e2d8a02e2e84406e26201079f1632637076dbb69c583895098b06c52d8b1198c551fa3d4dda2cd33f2825f8da96fc7ce016261d9a7e5e9b4090e3f262368c7db3ed01a961a99c0bfa03f59a7bfe96d206a89333842bc31d3a25d25a24f54705ff9f1e2dd0157442966c4a54604fb22dce7a2ab5f9ae94649d20b335b1b0d6e985dcf406ad2379fdc7ba64c0f5a2fb8f8418abf2f7e0a853136857be662541d7ab76ffd19131bdd1264b9d5ab973598a6ea5e275d463d66c6e486281e61fcd962b5c4afef5708406cdce073ba007863d93f3f924d4200fbc7c8597c67d98657261add74d06787880834fde4dddfb474232b500467825beba296d49c69618771d0f3e3b47ee340b9f9edc1ecff478b23287baa8e9dbcb92bb79405322bd261c0e944fb26e43fe961abbd78bae93c75f9b060c16bea027524417fbfe86bd87c4212bad04e0e269e606b62a6063c4622891a4a507de0fb7c948b4ac441a4b8ef67d598bbf1a648b3fa5db2f5b4e9740dfe9b7493185f13e58feb289352dee3b2980533442ed87ab8e1988d32ab748077d6ddc538aad4fac52d10dbdccd3915d3c08fee32fbe4a0c196670c8f48cc6140300b74461d387bf543dc9fc19f28265de0f98dbbf9194c56d91aaf2dddbc33bbeb76dd14650b069a17b41b251f81e3c6e5f269230a61c329e932034e12c18831f4e752d5b7cbf69d02754b145fa157a26b00f4404928ed05ade2d855e936fa2e9d5db762a117f0c2d829c68a85a3b1d85f20ecdbab3b8cdb47104205a55e9d90fe3840ed6823dd6dd00b2f205109972207f54a23ff9629f3edda1fac55348df42c27c42f16e2a5b598a8a938eab08e5a8a7fd1d13af65241e99a8a047b59bd97d5fe48d1943e7a535c086e1988f5568a4ff17c9c9cf3b255d561adb71569b60114ee4313fc27e2592ee7c9e3307c6c75ff28efc0e50290bbfaf774e4517438b36a720ff86d5607edfa10538b019ef03c27de7e5c3dfa0aeac01acb375ce08ce97fb8a1821ca584a14b741138286e8f26c8461938d056d343a588a2dd627b7f5cdccd47aa19eeba2db33c56d73874524fdb2e5705f82bfb80858f9c57fde2708e2943804fba12dcd20de99f557d10107cb47b059bda26a7e2329ed646f90c9f45e1ac00fa92342eacc28e5b8668ecd457ac1890f57956bf1e25aa91cb89d42d7b7bf8ae78c2fa6a90ff8fa037cb56ba58a90cf11d730c3dd2a5a0939289574c39f40988e11e27d3e1c0a1d76f5b97d7f9bc223b2777b37cc7b823a9de63a69bc3382b27f3e642bc75c33b04d6c74832eefb941285bb25cd511eca6021ee5a5a7cd37f9fa632c5c6305e411a5232d02c914d966ff7722fe8d63daa7b3f90270865e32f2c700ef41df04d60e014d41223d51fff38e161fae67d3404a4925cf502575180d8488ee7894984f136bb0b22e7428f5efdda0a3fad8d8ca88fd273a251cd9b56485529737d54ae5b05822010f7b85dd63de1475d47b8330f4b9f3b443901cb70e0c550476a328b88257b8c7ef2d96211052d84747490fc2ddf4b5f45b78ea443425a8a1db6a84495ce513312e46fba34eddd60881ccee742b274263b91ad8d0ee9c11f941b9c986a1f2e3af4ab68f034cab2b164eac99b8285bf49f9ab15b0cc06f89bc39e3736e110201e6dd1fc000615bd7a0cdc0fb3cc3e0175fcf289b5f338f015c8aff7be8a5045f54967d88a814f2697276b68d5e2353db5277b69d3cfee7c73a1b0bf4c0e6e29098dd1d26e0cf6cb85b995171b54517a5e127b9144983dd90b7eb097327faeeb8ab39de33577937fab32b00bf25bb4ba38816e4f8bb8212dcc3e823e71e1e7b0aef171ac2ab40bb1cfc4278e07a310c61e30424cef2db271019ca11e98c37d942fd73952bf9b816cdabcc976ffecdf9885f279b64335df5c4e35706d0b190f28b62f76ccde7a3a1056ea7c9e0a5dfaaa270a02b48f7c839c959962093b21e0aa8807463921d7a7914eddb0f4243c853b879a555e0703572f5d3588bc667a280702f24fe53dec173c5b2491e8a6e262d56087429e43b3005e4d81eefa22b533d59c65f1459c9565392f28b380398a01584362b9a2593dd54bfe52cd299512e5c394292f0a9e735bf4a460faa2f67f46359aa494d8eb086ef67ee7e3c07d951dd88297745e086035d6bf5d3b596277a579f265dbf98bf07876cb481ccf3a432bf2ccaf20eb9d1caccb35d6c2edc80ba9bfd6349b282118cf99f248bef1f05548916b408e6484f0def0736315457bde76d4ec9a04d20659f58e7b10150ed8e743df9fe9ce190374c2ea173e1b886e9de7240da9519f94feca5a1f0f1bb4dd415a716a980037212c4d377063b9d2e0daa703e0c862e03d068e2a3de1cc78841a6df24f7a812c3dda8fa979786f02b8420b2339c8049d83a0f16802689e7b159cf6d100404ad613aac426eb071e79aa4135fba1c8b6f476c0f43848c1fd693ee5168f20b83110691fe40d1ebe14cd892f38e74898ba4062f8979c9a0a753872e7ca98c9a98415abc87231e0634c8375cfd5d4bd7446a68ad46a060b5f9405bad6f3dbec4ceb425563f675a724d866db9fedbc851d06f04b4b7820e7b92d30aff18976fa44824a9e697f52c153e967adeb7833fedaf5684fd5445916411caa87d7a98668df954204681cf1188559fe683438757dec56f8211c553826872ee2da8c129a95b4a0c77cde4d2eae2dce635b4f8741615a3305e4aad492c1abaec1c4b78dcd1ebd79027eed9988293488138c4b6cb88c9e1a8b34f01d363526b2a83602cf61f1646384de7bab373614de77839e9aa7f125dc3f233b4de889e4a6ce0d6433e9fcc8e1d7e5e418dae105d1efd987495fe2d64b869753b2e0e7e47d39aa8c4a865bc80b9c6517509da364b945f8bc9ca4e55578939ad3be1c36335b6ebad2cd968470e14e6ac259e3450f59e0669a770383ec93b30eb38ead8c1129e9b263f4fab86751d38ad389b1aab98675047588e19361692987079c43350936e86dbe245ce534de6fc1aacacfc864c7e20e99ea69291e0f782bb7d566e2733b9ea24c1d6171aac8c985d8c97261bde461a9f9d7cdd23d1e09db246bb37d6b7cc5236d059f4ab3f4baa651da37dd07757efda1c4f3bf5ff0fe140ec6437894950777b07aace3d418004e04be912d657f074915fb981616b3f033bdc81e0f565b93a397298032564a18882659edabdd1bc038a8e84fd4022b78dcf9a0bbe184a4c01f893ef00674c078404e1dd2dbd5b6028945a941235c642699b15d9d8c52cbfc57b903b14aa3b7b812d4222ce4a90947fd6c58651da8dba700d1b85bf480532691495fed20bd5b47f730d9ebfa848c5769a905631c5664f4c88e7819a9bd40ae99a91f16b82774edd76c3e17acec88f833db76b2288975fef14bd13fe80a68f48a21bf8cb44adfbb355be5fcc042756487606b03e7c73f23d419a746e588beed29768de7ce074ef6f746a6785f9ee2040e7984d41f881c7022093d28b47f2a829a97fcd6fc1dcb6e4c54fa63d3d29a18a39961bd24311164d86421dd0a7d3fa9ca32d717d6505fbb8f701e231de3730382de416902f050cdda8b2115435e977a6833e35c94bb07c2829e6cb611672ca16c8806bd92a6503fd5a7cabdae4b67cfad097fc0d7d23a54816319feb132bb173e0920ae59c37dce31ffae7951403851740e0e499f7f086dc8fa5fb0025e2652b2035a6af5e6a94d65f8f77f1aa83f0a979b0a50cc6f7a5efd7bee351f6ba21cde30ff4f721609b2474c19c15782454275a9b98b856a62aec556adb905f3244693622a903e55c591bc5fe3d1fe0e055b80464500f1deac8ecec71e0f353e3470e680797eb9c5ad5742f0bd6456f217556a907e3b00e26665d0e312e728a1af7a35320eb82ed5686f36b20fc7b841bc70fc6287391fb3afb27b5a3976511fcb82241fc7fcfaf02efa973fdc5ce9dda9d877a4b60e35528c288c57abaff276f80f3b2255b0ef8177728f5a456615a7fdcbf52158cde5b45ee330b8df7ed515385633b5d3544aba7044463b9ddfa53b2960f931eef67fb2dfb2e1cace91c2fa834a91efa5932c088f102ab73052d3c724122cd8ec23416637992a404b307b3edaf6972e5586397a5a40faccd73d968c36c060aa40497ba8a8e68f8aa7d69f48c1ff2ddddd67d18e6e59e6694eea9fcb9d66ab371b7d08c311ce73e4270f5a7249424982af121f160e219e36af337419c2ed16d31bf02e1f77996d0fcc4bcef26f2e3f4164d665952fd5ad083fc476239f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
