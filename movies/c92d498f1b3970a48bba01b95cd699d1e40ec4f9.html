<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c0510f1c5d9eaa78d4c78692f8c5901d177eadefd1b280330d456f15b64cf9e00f6f4180de772750a6c46b25a99b827ca8fa40b77f9c52c4190cf1fbe65ff3c26c360b86c486e16cd64dc3a589a57e868aad9b102d6801d1c7d143175faf525dbb7f7dd5b699bf9749bd32562b5eaa801f235d16ce2740b6f709b13721855ec9f47f19ec5d03d8ffaf9f82f7a3e056c154c17e0e27974258e82ae662cb2edbfb0d9e1bf49ee8807e79799d86d9f2429a2480c3b1d2ce32f2f141c8f5ac33636f4c8369620ae7e5f05a1c98e046d86f9d5e855a64582d90ceace1d63f16ab5a7e9b87d3ed4d6ff6ca742fdd9b7c9fde598eeb8e2350efc2f011cc61126aaeaa1ba9eda7c1f8528e49b47aea7a3227e4e49554b26bb86b31944cec9a8c8adc70e503bf05ee4f481202429c1e1f87255436ebec4e6a55f92d3edd02a54013196926bcf1c39bb307fd55ce3d51b98c62a82188b8b0ed3e0f80c13d011e71eb881011e74144e8529f87e73994dd7451bc93f233b4e446bea089646ff1080063367e4d9567e1b87bc77f7af64339456e87d23d679faa579db3eb01ed5477cd9bb83a4a4fcba76493f8993413402f8c35bd3be1c1a21677470fe6cb5e80e2561ace09957e6fe5d56efee5400a473efaf813686a3c20f8cf807edb1f92470bb9b2d14a27ce40b8944ad362d8412c1a07a745e9773e3497482cba01a123f18c25d31abf2137604f6f41cb230dc2df9c97642905fb9874eda9a79c0333c6e0779f081a2b71bc8a67b92dbdb626751fd5dfb464a157314720dd095c487363f78dc646aaa624a779ed29ff076f523ec9d39ddc6f814343f89733495a3e483507de7d3a48428fb821573f7deb7dcedc345cd5450e776ed10ad670ece5d6ec1d802d52ace32dc212121d278ce7f8bf433522b31ff1674cecfb2e3048b93078753175ed39b3dd3d3ce42f4c87de98f2c253bc4e1540dc6f20831c88dacbcbcd5fd331d2bcb85768438253a40068d73a7925b27565b80e606ac6def81cf93ea635dc0e69c93012ce909ea8557c109df2aa7c32e8f5a5e91c392c52396e4a8df6ef2e3e29c3345fc1c4a08aecec604f0987dbcb41b800f81c9ed538ed16bce2448672fa206d9175221cdfd271e1e8dabd97c9221b500f54bea77eb66727628efa1bb9703071871c85b345890d540679ab393cc546de5adbd04821c0a3d0a48f07e645e5d2eba990dfee8fc9b51a1eac18179e9cda97a0f840a42f666d44fd6e57a58878bf4fd94bd7398a72231bcae3f9678bfbab14aec4ef563e472794227e34e8843753a37c76d8531f5d89f4e8d63dff76fc06a2d680cb3ba8c2ae006887f1313b18c4dbce82090689e4390137fe6e81dc69502dbbcc3c10fd4cc665d928ad83ab5e8dbcd4ee5681a76f5242bb5e591d79446a943583e1352d757bace685ac8a41e6a9c7e1723884545f9df29ac5594b0cba4a91f368286622f7f777280fca1c5b742eaa25ef80f7564448ab3ccdacfb7f74f4fec790f253aff73da9671c6763cd47b4e9236c846104d9551dad2dc1ce49e4929c6ee3a431bed23d3f026b0f1033e5af5b45cac2251834546d9cce4625559f98e837877b0d15cdbd7456cfabd9515d55cf7aab793681f70c18514ec7a2b20d80a651852668cb869683c1a732437f8cf93db9631bdbf763272dfd77db3afb7a96b5c07d576a90fa46589fee23f6f1439c3500182a20ffc8d4568df2ba59e0b9cf6dc38c747d2a918254086a048738e6de603db23925ea4e4db10dc82e08f35185b63f1bd0d948b1962a17b6c598bbdb4d934d5cec5167616809b22ec18d31c364c681598888f015337c1469bd507ec8cad3117d499d2b0b6f07a2136bd33e2cb37448227229b35b58c1fbaadd7d792f405fbcd6c9a6a34295c799fa8e69d0ab0737f9650c53fab9a3547a78b9030813b15c6883ff1ddc41c372f38f926d04124ea8ea2ddcd1af853684ae9820134bf43e144b5f162c1160327e1a081b4910f94c605886c7cd7a00b5f6bf8d4a8adb936b72efaa511ea717167b0f75c2b81b113b5da15945bea9757d4e9ca5fdf739038d5aad467bffdb4ae030f68169f837ec321899dc8f337adccdf260120fd6148eb10c4486d2891d3eabd68c82b2983ba5d7d4f38ccbf7069cc2412cc09e8d4bddeb869d022f14b3bd94c1049c7adf72de1dc8ff9d2309c512ce3b1a4c86ffd12a01f8a2106778c459c9af5135247e22306a76c43e03bfb4dc9e74abb15fb2e35dfff763aa1a18a76db3a37a5dd5061fa99078605bb8af8199c2cc41bf311936b350ccfd06df353d0f4ab86fed2359344ef3470e5d73fab32c07625c9bc3b28e92271d5aedeafb3a20ebae0ab3a2c199a6dda0ae0e81130757f9ec502d98c3ff6f5af028bfe041a4e74920b80e178428e89bff0063015352a50c085a95abf7da92a4ff1be71040b9f45bf3322e4de56fab082468d13fd9f12c75b79cce6f9a4a193678405c84e1d50284e4f98a5e3004b1334378440f37eedc5429674a8d3ae33955778b95e6737f20d1ca0266b7ad84f0556458a088c8a82ab067495471ed50f76418407c317398ffdc6d88328192b2c69e4eddd0378c598ed74b916e0891029768d629dac6b930bd0c195a5041a7c3aac9ef9bbdd662695ea4f3a52194a99d176edc014b6c83e163ab78d216cd7177f9b4d216680ea8060b438c7846d985cb5a7ae8dcfdc5aad0cf01a51738fe54db5f60bb63a00a1300c83c53de8a2331dd17aa9d2dd1301707aefdb90ad72912d952123e3b89e24e4e69fcdd8538d5de4e2a07504255fc2c6032e37075edf91522c38ad9016907cf29bfc42db41d3b623a7b283a5e5efea98c4d0b18ca87ebcdc7824a4930bf5064ccc704bdb1e0b32f8894289b950e32916a90dc156a071374cc4fe4a587a1042f11c92a32b367c56842d02c716ebd5bd172e78659094144d0ec51a66fdd27febbc553b5d114ce30c3d75dae5df5279bcaca344175f8e1bcf31e47597dcde371b50bdde824ab9460ee931a9d7d6d438a372ee92806e76f67476ae66dd39e4b88a4b061a8ba6b59155af6737a190249dfef02342424ac506ca291a8b885678091a41595c3e0370516e468943024e0c0691297315416184ea9789c8526aed66ddf56fcfe96dc4a827dc7174691b1daae37fbf9ce227912ba39d414b782a10fab7f0604503396d0a6904802603a738ce1de7acdb352e59364444cb5dd6066846f9125ea2bb66ed333a4e7740ed21b98db360d71b20a0b511550f283eebfca306f2254ec628e4d15e44d6d8bb686c22ee85290f969c3d12c24ee0d76f415ab71997416d9acd5f3ddc97d8460269ca62ea86887849bf99789d0672cfa5b74fb2da285f79c957fa9c4e55e9e68eb8aad73ff54bafca944813d4c0ac22bdf128e56ec7696b65e171264453642da62ae99f0c725a34bc420dfc2430701d01e3070156301b19a6cc1b2eab31d6cac10a06fa4ddcec21b495bc2a546866f735adfddb1ea3905179e43f3dd49732f66a94a2923b9f3b9ce30b73d83764607be7f574a6925aed6a9175759db9ce7da539545c4152ce3543cd85419a377db8bd1236fc65b587a63c4ad35c8a263c4e3cbb7df2b116df199bd166edcc3db9ca89591779479f83f8a977936159ac3894b3b9d015e39e5cb47fdd72644904d310d625b0b3b0f284e3ace895a47fb92dbbff83018e6566a7a4253443a4197bd61ab3eefdc052ce4b4fb14823323f2fac639c5475c76d38ab1189cfb4cb6e86d37204b9f199c9a9b9dbb5f92adbffba4e6a1b48e4f28cec9ddc6ae48b211395bdf6279a62ccd14471a77e43254718f1382122682b6e0289c2c45c36cd36d332132d24b2f9d17dee72b465ff992135b46bd994726b0a78084195e7d1ad8d0adc587789bd166996f70035fc5b9b1ca0b5d8f84d00e67bf991d7725d29578619f2484a667f13f8bb2a488c294bc4bf87700c5f7b150fa4b6b543fcbcdc50def24a088915b3c28d3b861dff85fb3127221582724affa495cb6bf6f7ed820eab31518636e220ebb1ac1890607b7009c85ca16498d6bc4744c2eda7e9f065120e692ef1948bcf630638a6a2e57888c8b2fecec1b9cc7504c9fcc8df940cd1448da2d347803b01fed6aa7649c84a135334db4872c89aef4f27a32622fb0e1f844b90ba90f386e1bc4d2bdf3d31a031a6c53c2a3ad9d2bf3ccfee8a6647aed8e990bc3f9d89f24826306848f53fc73d57497d1f0bce48431c1f6e08bcf9f7d4cdaa96626569dcc5bd1b94dd3b956bf9dae8a9fd49506a6ba153dd74a9fc139bf8340cf9e4791f8cc8f143bb450ed061ea9438fc73eb9b74b269d41b7bfa91a773074b7c0c7b7294a9d5ed1341afc692ec08f8743f296f11da318609fb77cb13f7181563bc6e732c61dbdb0c4901eb381130ada45327187baf1d6ac865d4631fcba84330088a105f2a045ecb4aacb5a523dbf49ca48af580b9f4e2c5e88eb379eae5807c972f51d06d02a36f50d8606648ef6297f671a4c19eb10cfe8e43d867fd993b7e2a30cb27e10f35ca3a13453e62835aa3fd69483e7dd783f724337772929dcb7317d84a9d38fb40de5cab764f07a0c659c3f385481eae2f4682e8d18756992559848d7f657dfd6f338421a0599b031886c31b877d0d50fd24fd2744c0d63f705987d3465f565e33105da43d8594db7ded89920a5ce029f319e130b4fc42507a57d7bfc2a638f82a35c767a47f1a0e4fa92ab55cb95e3137b95fbee6898bde7bd70216035a1e9795359ae0183941408642f79809f75ef1c701dbaa6ef1a8976686b1542b9b1f574050f00bd953361885e890546e635c25e7b239de066ddec13f1a8c371ff3e07131975cac9fea546da46fcda682f97f6c47acae077bf637b9eb61ec96478f518cfb4a03fa0338b8ef34aa1273ed63ae4ca7eaac4d862c03cb3429456a3e44c5380c7bce6c541440c0520fe73204eec307d8701256e581bc82a500256ad6dd7ac095367b5a723bca0a4c436f0f0025f3bc7e651a04bebbbc2b2bbdc27e0939bfb961571e7557ffdf113e6e00c8129d04248f186c69a6753e0f808919d7ca366238750a661720f7d5c2b314b872ecbdf53e25171dcaf51f7de674efde60f95645587d3c0019007a26916b443a1e77c280ab6649616cf47ed2d75ce1649afb55ca75a49cf226b61290daf42725ae6c42c70cdc0de68eec503a0609c9fe181feef1b83e267520a6e07b14832fe6075293740c6088d31d65d4986269eac71fbdace037e4d5e1a9f2707f6038d9cde85c027950f4da199e421037cc9c80b26c1e5c3d03f303e0d723d082ff2dfad38a77d430607e2364c607e3ca3d4fd0c15eed9c72b6803ab86db8f9a2c3d3b1c6047c242c6376c379fe9817816cf44ea81d5b14113aafbd320c5e34810ae54cb12c91f536e86c9cb86f95428ca7fabe9271d37a9375d7e20ff24fe37ca9fea8c99baa0329d7b41c7ada11f0d82d594f00553f832c201cc187bae354a03d69560903188daf1cc4ea4d87ba7941da16cc620e57ef1ad2418bb263347dac32a06281d7da0299938e60ee49a28dc32dd48121e3158029e988b1229e55c317577ca0a5f7e3d823b8f49533fb897e61d534fadb22751c6d081cd188a30b1718a93c474e8935c4a59af802abb9608311c958c6a96beb4d480217b0ef37a890391d72b40cb72fb5d09a005a2fb5ab540111c88a61bfd0e0251d4fdcb36f9dbf5a5989d3443e29c2909aac788490cee70d40d4385397458d8eccece409fe810501dc8eded766c875e5c334b146867aa3bb73dadfc4d6b0414e7545258e6c359bd4adc147246e06f0508874f786108ead73130bb5dc4e748638f44d1160949da82607b872348433d7771b3c842ca42103473765f3daffe1e0c947c1c08b979d3adb387885107e6c4f90cbba4b3a20d43af432663b69b360925ea777bd75e792d86edb3c03b7aeda4d3531320f3bd457a7f599fdf0517f515090437c7bcdd7248beecbeeeeea780b3f26093d40b3ddf03c8a269ecb06049dc5229547f3d3a3b2e5bd214d2de566ddf4b6ea73b56f1f21c152549747e4562b1c872c3feff7ee7c5f1189771f67f9048193cfdc3c83fd463c26283e785eccbcd32a47132b7cb55cfbe268cdbb3c09519de3110521b6c4295e848c0f893ce0581c758e9701e09e10b95d63f77dfda630bfc0a974792ec75a4bf9f3ae81dcfb6a03d9f2c57f4fad0efdf3e9c71177de36e5c80171987d45b9e2ee12cd9057a39f055f855fe9513f171dda6d884920ac1aa236d516290296504b9e3fef1bec1cf3dba5ba4bdf26493ab2082b867132413ef807092a3674316523ad8c480c376e66b964668ecf41c2273dfc32a7cbd01ca9f84c15010bcd61999f24a5d3ecf0c958dce467fb1d23814f72ba996a322ac59104fbbcdccf5ce1913ece182bff0bbe51d2380564f5104d2b84f8789d9b1630085ec4c00f52158c79aaa55a6cc0fbd1636009f25b7691bf07ec0814aa9b13af9cf0ccb1795cd57fe097b761f40b32eb1f519d23ca3421f98b65ddbeee11161e9fa660e67d891d3b4e52a8345d05fe31518b2148bf350cb33702320e079c2d090529481ac07a9d62300b6ed671b3de25a5e3a0019928284cffd779ac4b53ff1cda93a905d7ebbea717d70308373baed8770c6ddb60cffa4f93314624a305dc6a187e5f222d38edaafa23012d22426aa464a61b24cd4c2f91f1d67f6ad8dec2f1e73a1043e74702a705df899c916252c534f3042e43965f5fb2498a089f070154fc37df8ed9b90ca9b960ebdaabfd76c3f894018ff397e61c5e87ec42c1bb67e03f14ab9d78381f87cb0b2ea36228284f5c47673616d4b7b36df6245d1ca4a88e6fccfafb080618f7874f0395f82b894bfdcf08c2f9c3c7a3355b58c42e7c624f255b4271824d3a5a835e283784b72fe84d1fd2da6a939f12ca1d1c75268c2b23b8e4e948ded8f4432463309aa462629367caab80cca5aa2ba8b2a9f1a41b85a391ecd93c711e766ec4eb9c4e80f59f57c9c8daee318ac9d099c4c35896e47e9aed5b1bd1aa61a9385a4116cc17ef0eaa2450de6f832777e4ff758383b2eef5c2ce8cdd53a1a25b83ec7d12082f07e0a7edb8ee9f71b41f8f1c65edab404f0ad6b0f3de5ec5298d473756ddc1a5ecad9dfc0769a0e113725936b9bf140ed61a74a476270f3ba5a51fce1023d7777759797c90ac9c6b397cfe79b44a4bae380907f0a4c304bd5a64887b58da24d60f7f4c6e304474c36ce9f17a83a15aa0542c751e4d5cf18cfc69dd02ae2a39b7227e469b2b4ba160a46013639a992be7c8f6882ad92a4e211fdeaf374a5d53c9dde9c80d825dd96316395063614f117f07c8e5b46308cf6da17fbdbd98a68285fa1c2fbdbc1032146095f611a4a7d96bfadcc30bebd5c61d917e4daf08f49119408a9a0579b8e5ed7b0a3ad1043fb1fc293e726c32710efa8afbc8f2dcfbecb241c394555c829b2cd0c3604b0a6b7ba0bcdca348defd7a1dca3e7aa42ab6a223e220ecb5e6f5acf417073737f1af82c7fb3764f6af1d5e6b5e9f9a161f9e98858b1afa99b49e0295f60d1cc67a8ba77294ede30c77d4ac99c12719b825d3aae58221066fb649c7b33f506c350d9e12b24f4626336cc51c5911a09a9dc64db0ef51bfacef2754cf3b2432ef85f5c8d64c7f48ca9d7fd8056277424f481e7109d85f3f9a52171944f0e19f1250c3633c04cf9917020e99a87fe3a94830507a996664e14220dd668fff1a572c35dacea2341d0575558428fe61d72f46e22aeab220bcc14c60652ef2e4af9658e6e8494a4abaa75353d17b5b8d040a632d18359f551c16a4796471a7661ec49ae31965740e6cdcf49b4c1c8ce1bb773f3371077a033326dd72f56b9e3c379ff01188bab81ff14ba5b86fa721e1c53a7687fd2774f88863ed3db3c90a139ec4b224e5d0199412a5e250a7fd11cf4c30f481e2d68c6abd2a251772ca0fa0fe3743482e2c1540f416763cc7275015b8504ef9ca37e547e1d1bf9f0e99e5d6558ac7e6882a53555e99c41d561a5037d94e7804234bcae20ddbc68e6388b9384c2285519628cc83c070722ed3cdc72d35dde91feef5eef97dbdaee0659553282810b570b4a66accfcef320dcae0056445dfb47d2a51e3cda6457f0c0b9aacf9ed7c150d0062889fe0737b94f53e8634c364ba97b4368f1a26dbfaf00137cbd936dcd9dfe5dca3edac318ab9eecc2ef93c7b9e7781c9ba5a7e2d08a9cf2380395205e1a33ad60472f49f130dd4d9d1c651dda167316ad33b42a0a49288cb28842e51d07880784c7e52686b2d6006f0caa5c92ee3715b91151d41bcba74ec463a16a47e42b7838c4f6a3137b3af51127a0cff7a51e602bd4d018846d3fe2b5ffc845c48cd26293244949ffd2ae9f8aab36299403dac3538bba5795d06b9db4997fcd28552d93aff6783b6591e5f92f8ef6f14d40cd044022f15bc65c21828dfa3b8a45cf4d3c5bdc393fd8154172419e6ced611ac12871c388f58bf6ffce0c0d2b3ed6c8f9e88f7858d99673134d3b7cc378eafcec004db2210a3cd7cd8d4da019687ad8508bc494a4f3ca893ac6a241f2dc4934fbd3799a46ceae4f8e1d1fa89e7da071d382722f0e345eae56c357cc3098c1de1e130588c0ceb633bb12d713090f6d23216fac453f78f3987c710202f8cb899a204cb73588620f53e2fdd4d94b94a23f57f91a4f6fe53eb1dbcf25f3b52736bc2479343b694570ddd1252008b72af177f254532e1480f9e62d0298d837fb789e93c7dcafc658948469f80c737dddd74d8ef2e00e25dc7c319c5a0eab130b1592fb3a7a3a9e61c2460082b0b11c3cdad5d5efa55b0fe2003dde43e1c78a55aed3608997acb05747e9db402323082badd7f2478f2874df3321364d2092bea1f750799b32d13e58ad69d7917f8a1e6416ed1b1f287244bc2567eec1b741adc35a30d7df234f47faac8c073ef1e4e79cfc81f94b9b403c289a5747ab019b0185c51fceb93c62c1bbd2f402a8d355d641ad81a0cde3cbb15bb58b3f08608b80bd19df92ce1a4f91cdc35ee8d4de38f6488802005b08f3021bd15213a647e88266b31556a379fb9f4a457646694114f6c85b5f1d77f4e215a87ca012716ca4f3d82d5c208fb35e927958538a6bf2402205e736e25519691e72141293be24eb716be3d95394cc852f0047397474bf15dd9412bc486d675c62c0a4c4d76887bacd9cc0099b7e29156564b4e5cf002ec17339975fddd883a46201202bb4c6666086ec4b9e3deff146582161c052955316ad27df44100cc237b5296753c5e8ac862bf9ed7556cee9c76a12a7774f0d9cf5de56cab6de1c8b2e791de5e4b916b719ba0c290ece777808892b31bcf50cc76417608d8923cf23f5db583455f294a8af45283da98bb83045b48dbad7d761402793dd79b0c46fe5d72d2c360c25034d4601c673634e413d319f53f38befd0af2ee8cf6bfda50ea1e8918a9bcebf305748ee8da9c5c4993e651ebec4e16becc07744b05ac93b2d1fdbba3b7ef02014a90671527ba74c59f220a0869752ae7b2544479c7773762d1bb8ac4ef49fc92be5fe4265303e1112a661de56b3c82e333dcf3608bdfc91380978f747faad5e781ef4405db3f6ef2d229796d753960d81744b49c0fe0262376d0a6c971c45bd741be6d3f76b7dfa68389f79e25a16bb446d8b66471a808229b180fc03a323c6750df26983718067a11716d8de8366f98e41c400379e097fdf0b783bbfc57915768060b73335f267219b2ac25ff6f65c4c00435c56a140450c9f488140c06b8de35362759fd665bd90d62035ecfa24e2f7de928e38b370e5dbaf97fb73ac7e30d21ea8f7530cd02b79a382975fc433146a9175f71ff4f53ca8bdf4662b00871c00a43dea3fa4546f02a16301824e613711d5166cfd872ddb3a6fe9c38f112e3c3d06f2d59e910ecf4bcf2a91d09373a7434452cba6c610f58b4075a7aafcc48ee5c038aa2f3f6bf406a5e22a55fe1a99f7d01782ef49a4e0a9e3df89a3ecd9dbd9371bbd99561f19d7227dba31a74a66bb7f8a6cd81530ce42898a532e84e3d4fb637339d1c52cfa63e56c97ecd5c024c4be8ca1fcd058f20529f0b2c2bae81d0a83b09843c86c70bbb1e5726d9687bf37dc62855544fd4d75398a24561d5502a4398fefd5097b64ed9fa2ae51f3a12d858324f80ec8717564fafc1d3986c17698c624a76c144b9408123d6d72dace80cb9be510ecb312af7c82b8f5bb2b4612df3df7408f3c37823ee57e9aa755472c46fda308d0d7058102c9cc0c81936d7bf7c2d793180fd7de3c908fefd2f618dc44444c427451e1901093a76a4605fe20d81d2087a4bcfdea801ed243db05d1ebea801f8295afe49378a273c95521bb0dad33414c9444bb2aa02e35c3896272683ffffdd83ab36026312e4392732e85bcd15d54e0ab952659836e9cf9ce389b00a3d4fbe0edaf3eb2903baf12d2f160db907cd9a70597b7578ce22f356d71c59a1b52939fb5ccacaf5f86aa63d94dea934390fcecc0cb86895d02807a6ed44c34827bf2154cb48fb3ed9eb50199e5a1e54306a1a4961cdf4c89070aaf029e3e3357149c38ca27923415830c090076819ecb9a6f31dfc76e4c03c676bcb94d150add1ac02a41189643c5b2b7418e434c919c06c4cc9d58bf1816b8662d0427028439b109341fadf221d735112d4891af637110bcb25fb2f2f5621c86387d5f94ab6cd6cd73d216c3d38e6e9371435ea8d11e5fdd5b28319087730057fce36cb83ffff9d161f03db8f155c40432e8ca8b2e60c0d6ecd497271a531b75c4377bca5bffaa1667f53930310195559bd2fb3e8569fd6e41fa71de016ad3f153ce5dc565e7b0e27ec8126a7ebe3f3ce9147f7aaff62746d3f65ad1c0fa408debe3bfdadca6e247f4fae07cdb4ea81c316c445eb8f2b3e00af96c5c137430bf09c16b98bfb1864d7dc840a8e21d60eed2aa491f658a35dfc336125b4348fd9df9f0f59d30c94a7a4ad3b1965ccd6469bf5ee533dfb622e1313841407cf0c866bea20880b047cb6173201cdd442e40c4b1f11a716509e064c5aaa22384d9391008ce313afaacf41e91c6417fa8d13414548389d989091db24c23389abe3780aa49015842a9dc37f760fc1e32e7b6bc1ce5bfb71f5e4249d9ccba8526a7be5dda75292fba578496c3518f58310f6da44a23f77765b45e29f702298b385275ddc374ea384dc39150a7ef91accfd0c66a8ac3895c3c2f71571906f23019ec991e69218a22e86d58189c81497a3933b825a4ecde16ec0d0d412fb886da501a45f016a1e6c0ce97897710ca929fb0a2fd7799998403325cddf51bfdcd0d60913a48a3d2776474863c18f10d4c2a426395f8828ff45eef21c5cf1eccf76ecbc28d29f0646e720acef2a153c474f7de62357f45ea42622994a4fb17bb971daae32a24840e67b420ff508eea2ae8b6a09091f46b0fb787ea3025cc58583e5b4f0c6341ce05459b5092d909c9c5320847be347860dddf7839d536c0d1d037fbed4e13a4fbcf95c97652c68bb2a086b7564ec1ae7931b61d2d9e1720de8399106040214ce53da335ea8fe1cf6bdfe89a6353508a4ad91b01e0357619794f391040b4357e8353292fd513d193202670f062b0deefdd64a2eb26d022e268d51f920009724d80f627f72525c781fb4b58ecfa09e361522f1ed18bebef02e2c2edc0cb2d9096cb38f544c5a5d37ffa216fd5c126a25e5f5a30d6bfd6e624bf21698f941fbae06614ebc584e9214542d901cedd5d32dd0bf04ab71595415602293309ef03ba87ecfe958a1e83f59a3728a743fd3be6a1b02cec3cb52253d7525b94800d49cae2f4b8024b45a4695dc148c98e7ed7e30988b1e0530eaff77142660ed8cb49bc5465be722d3201ffc33d02601922b82679a01ee0c4a0c1ef2ec33cad1e3e0eeda2573b072d501cc50e909ee8e7ee838726f04bced5dfc70020e0bbb1c5ae822700c86de4d6a8a0e0d40f38ca860300d5eba3c9d8bc8c4ffe029b3ba770e1175a7fc6c3d3df7fb3da1bc0f2a8c83c77d554678d58a3804aa5c2a016ef388d04c42ff006939ddd3a9895fa23798f5e34194b11aee579627023c42645a0f758cdcbd2caa25001eaaa661e7a818b017a1146e19813eb9df66080788070b4f2dbbf5c8dcd208a8e58f6500836d3de3c22a4e51623b8feaebb1d02f246f3fa21bab4cd1de5f03f790f42cc6e9f67007a9a779a45e0235201a0693b9d520927c32ddf52c587ef5b07c7398ff953ef662343ca6f0316ba42f5d54d199e1e2982b8ebd99083cf864307f20a4fda9db4baee30c56633105a387951e39f3c5f5efca8bede29cbfd507e3817762b3c88ab94527786de3ef2d6af3498cb43662ac98b1b361bcf395fae359fc6737d871b8d5bc0c5aee255180d09c45fcd055990d7e8215900cc049c67b10b52630ccd869d1033c6998bd682bf032826d77727ba1b1c815a11dee61f48b2f6104fd59f39091e5a148743f1cc0d96e8ea03897d06cbf7aeaa7d7ed2fb4a8057a0e750be85e31bdb6bdb996c46ddfd89a70bc63e7d65eb7d6da144c3468e2eff5a6aa618928997ba9635d094f6a617bbdfc0ee5c1397ce7beb163554e57e20facfe4208a91cf9c7565d2ac1f9d8aaf9d88be0be7c8deeb791123aa98c364feec17dd446a366f38a8cd0a528754acda95ee8189cd5d4537f9f09dc3c7b054214b94c79024c4d9b1b39c3bfa73695f345afa30e0eedfc733871b0b181c74b8677a35e8ac7c25bdb157486dd2c59bb95244af184f5cbfbc5f49590428a6209bd5df355e7d823c152ef4d0f6118c578f14062ee6163e0b5daa1db1891028fb158081485ff61711b9ac2e5d406c4a9689710d8082acc4c91dcca9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
