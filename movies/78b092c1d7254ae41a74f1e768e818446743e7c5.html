<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e252d9725f163ce76bbf1a7c2d344f3d67c453f54c5e031733f84f374bc7652cef36ba19241d04b2a74afc0ea0946da2aa04065962b96ffba59738a23c679dded12acef5a4b99b98a44c66b7393e631c8681e2281f336dc9f70401900e62073ff9f649fe5106df765916ee8eb90d74426a7fe82feff29cab38e4bef56739d1d1cdce05516b8bdd068d96c837d4167db96c5f409b43fc4262ed3e76e8854435cfd049d13b85f736e5a95ca1bcee58d997bf79d28f44041999002b8d6d16b9dc600c72612f54eb43e2407e0c08cf88c0a723549fb826805b7739d3f46ea8c478a4794b58de9c9329a7c40fc57a384584c5839ff25892cfcbe9b5cfaa3f2fb5ed5928fb62985f0501c73ac876feec6707a470ac0457d4d7dc39f10cecaaee19d7e3598a61331dba0da3cf5166d99810af02758301387860fbd73fa756f16a4fc2b3e945c12f5dc8e3bf67c5da0fa251a5f7b5b64676759eba83e22bd1a8fdddfc2d2a3b1cb5bf2a26fd9d7d9d64ed8f119986aee01fc317d999bf6b5142f19ec47d3dd6ff6a1176de0f514d6b623a2b7e95032fcdc0ac3686e8753adaa3005d26080d6352e43449029638d6dc4b380566fd1c24c3d10e9fcd2bd780db4391c196bcf605757725797d8776f45019149aa9239562780e3d291729a0bad79c1eb96632be823ee566453e22ff0970e28ba9647045bba6ba0ec264bb9d08fe99c3ee1697a110c254669c5a777cf2db18dc91856607aaf457e9b7d05e39caed32807d43595e4d6eae2c586c3f128f16b5ffb69c3448d26bcc0f9a1802c62c9710ef36d25170a27f80640c3581baae4740e5d1ad19e04a430ca1e521b78f2499407e61cd1ae473aaf9b1eff3123abe26abafa4f583d13d1556ec94cd79b90091daa7efb07673512c46d9d8b24385ff00abe7db9d25f0a826a145554855a0a05b0e3db17ef173558283fe551813edec47445090e766078f4b0f0d3ffa4025fd4ccfa10f57ab56395a38a2f49a64e5110f173a3f55c9f4ceb5987831d4baa9c3492f3c6f62e8894b0abb30518ad200cf0caa6cbe767a7922808d69ce0a3f2da8a86cdb761132af98879df8ead134e1af9f8fc1c8da6f94139cfb245220476da0d4d005612d63c6207c8b72788e94868266b0d2dcaf6309becaf907a80790bc133b69eb1985fd5aa0a0d88635ad1262ab502bca9fce91835dc2bba0673c336e326bf411e327a33c176c37a922a600f38b2032cd9c3b32408dbf0fffaa0d4d95db310c80a12b24879b245237deb99f1905467268d44cd8a7ffa91b03a971d271a0605e67c581fe0bdfc1426a9e0017f035b908e9022b422a65c40bfcb42d6081ff55ba92df2e55efbb7525d57883642eb6ccb8fb2ab351ac1d0a818a8d3beeb9beafead901b465942644b80f317c46efa8f103c4de9390931d3e7810e3b59dc7f634041883215c383962b8c4c30460e2a60398ac51a2b06bc02a43552cfcb79c79b7ea4e18eb50e064eaff62edcf2a883690144e403e7c073f37048d353552d372f546fa709b6fca06157dc5506951c913a57a7ee0cdf329e41511533b0a92a88da023a81489f088d0ed83c770c550523aed018891b5bab77e41b2f0c0778a695b465fa214b8e82c2b7f0fe798f1ef9798285f942a79432cf872e90fd103e73cb7ea9647be0d812223ecebd60c96207c621982f9da0d519429816dde60bd111ae82bf9ee2010431d0a9e57478c899fcdc1ed64ac327cd440e45cbe6bb7e2a67bc5b27c8edfab5a3648cc5ca1c3a88c0eebd19d872d33d092de956a11c1c2c11e0760bcaffcd2927b12da8a8cc074aa86ad79c4e75cec5421d19412106c258ec75068d8ddb5dce654b9945bfd0f638aa5731b5fdeb823f889902dcbfdc1a54eef0b453bebe0988f07cdc74a02de6ba1e6ff364dc79d09761b4426cbaf67066eaf5c98823fce376bf2b244a1940bc8351b8ad32d645d78750b41fb2f31d19c391f4a02111617aebfedf22319a724f7de9053862f59b514b968d3731ed4a4e4f60b52519eeb822e30355ce9a4cfe7bc883fbcf92269d2e2b85a5540b0316f3377f4a6d0dee3f082ba375c5e7f91b19aaa494a68b46917fea061d1715143937b9d8874c1138076ad502820a752bee5f18b1242e1b6ee854984bef05bd7f248f26821d739778f5ec4e5802b70b1ddc04a8e030a94cb217c2d1ad2dd6210df7cbc7032ae5c17d1452f73162c6ddb27d6a14329e51c0dd3288193619f518a903e37986b51043cc6aaa4864ad7e60bac3d605390958273bbd5effba602d03c465d6de0841c33e2f5c775629af0f9b0c8732468d91ecb44a9057aa21a8c4c09558e4cc234b08eed9c51d200f42595db54ce57b3098a2f20523f4bd0c6e436ee6c763edc6dc46a261872a324c1828a9801b6344e6482a889e716bf2c6059fb23e663343394fb692de449c1592d2c2c4fe887681757c1ff0d6b5f21bd84ae77531450e1f7ae992ce68a352df7bef9283b7a74ff34d142148b04cd3eedbc718527f41a493fceb4b01df3a972556053035c85df555e62f5e499b0da5f72ee53ba9c5cef680c90005cd4aff17b85d57887a9ccfa429fea47a405811d6c67c1c3c15d27324585e6c18bc533b11f79405421b2e569d3126f6d2bce2238358328bee66e822a9bf114d7804d202974fff812eaebdd0e9b27dd9300ce5ff78e1083509bfcc05caa466e8f48e7d54f1208da9b21bc713aa72cadb5a7a547de4446f1488d9eee65dc59403afa9fa4ba0d5b65c9502a287905adf756e2a341091bdf06958f0d940786d3924096b7c3f1a50d1a9df7ce2298c673011e359fe82ac6ac4bc36ebe5a1648f7810e54703143c67b9b4e82850a57bc365fc397fe52f84decad20a8b5d88a470e0ffd41330cb6872b0dc683419e142eb3bf416a0fc775be4db89c3a0905e9ebfcff4c6df2a4e796965ebf8a0ba61a762a53001fbbee868e5c685efde4f9f016d9515188d46b409417a7363fcf7baadd473cb345ebf8555bea0f34b3bbed2642f51e3783182583c0d6cd750819994ecc7048a1d637b1ee5de270c834e03ac3267ce937c066dc31116c0f1b1b8c3093f926e2520f42ea7d47b2bd4049a4ea61c9ed9fd0fb5fa69c6fa2e572553228caba79d0efa873600cb1fb5efe610eab39233f19719622d170df57176768a40d0ab0f0f53f51641674bcc56043de82a27e72e87a83bfb63d0fa3f29adb5e24ff1a745f205122f2bb330b6c1b4f25a2c1f65533004e31069949065cb76a3f1da43022cc7287bef7aeefcea2cf3dcc5067d5197e85d91725aa40eeeb9d04740dbc9a9cf55f75ef471f7f36c7a8978f789f71b7a00b1957990c61606bdf2d7ff6a84614dca10f94e5e03fd82e5906ca84e4cc076954af983f4c78f5be05ccd2fc86f12c6feb693f8cf948aa1cb0489bd8f11e214e92391bc20e6ed2efa5c08e90ffaaef1d2542da227f1a03722d50309ab5c6c92090210feaf3101c53b6d4b3981a693c09544a58970810dc2f6b7e9241affad7d4ff3ad705cfe0555e0f07703346e0d4bc2a796ccb379d332b5a99a62411ab3fc4c2c6d6ee403d795863c33d6f31424919d3c650a4e800076fb06016a85a89384b04acc1714db17c7a93396b8de340cda28f89a13097d5d94d1e63d24a06c2eb95cc5fac803e9abdeffedaded02d9f1ec0a2b004422691ebe8cb8db5e7fae35ee98f90831ef6b641c4fc70169535a877b040034cf626f330f7f35d1407015cb6063942d44c88ef79bbf214a9e6a1e443595844e64ff2fdb5afa64ca0b5cba813c457baa1b94795103a1eb910693414acb573c8925299605ed37d0e99c3e78edeff320b4236ab053e26b5f0bed7306b68544239df972011e51d267f5288483391a0969835bbb19f119ff0726f88ec07d1dad1ba6d08d2e5c62201a33136d42373f33dd42f800a26f2eb1133451e66f02f272fb06a7a37ae2bc711a605f3c4f47135849a37d5746d598837e91157f782134fab44736bfb5bc21f6aabff96cdcb41d0b1c53ad7087c1f676f4cdbe56ed84de23d1976c522049e83595be929cfdb28efc75c47200a75dd0c52308438caaf4a4b7e1d5fc52fbee7704f7e5b97ad99b994af974964641bd859030e06a707e2bf8ef7e828b20ab50d4fc5e842a952d6384dc62c4506c26c74c09a3b1f51c1130197084ea9c8ce0efe4aadce45e07b5de09ae1aa874a8ac8a89872c02f6b54b8806d551f2561336b2b1d2f0a55bc19c2bc057ab709b11df11dda77ea5258df5fb243e91907206f026a97fce6feb25737ebdfd65f42c53d1c2d228d7cfc4861c00e26671399cbba6faef0dcca5c3647ddfcb181c6b45a12bdf3a3e7706cad976df1dda4ae93a4ab681d5dd705f1243aabbf5427d08a4cf33aa0dfb46f984fa7db259e31dc23b097b616281057360468de170351273b5611403434c85e9b78e4fd790acdc47814fb3db9989eb5600fd8913e71a14f54927d250c7461d6c9a795f3c4e3a2978535f438bd64cede3d52956a296b0cd1a441fca7680116aa21233a31c8e39b069eca5738e7622549249a6f964eca7f7b5239c929abcdbaab2d192e70b5943e468c0a581516d54536685b815198a514451c8049737018571c16eac705a0d60ecdc7d23676da8230c7360091015ed41af7de22d3d9a583c07420c2b551fe0718fc29efe80202ad112bec3dedf3bc37f7c31ca30723202c3c209c6c4a3f8ff60d24620600186c00bb809486f175e6a9f5905af597b309ab5cbe08993c72a8beeb2e3fd06b74e6fbd4be6443e20dfaa821369c77d89b5ab6bb7c5c7b02c275313d81e29b58c766dd6c1af24a740ce7e2c2c53fff0bb488ba53b41572f54a81c0dceeef80207e7da61c518698d3693b96b57a6172414dd86249f3d46590f85a9baa76b10851ed4cdee94a79b82ee4a025bba3f9d656a76b232363c577ef661ecab13e3b221f10e9d17a168ad222c04d62612a0c08eca0e7055c5b1e0b6d947d62bed73b012bce43111443a3cbc005043956cbedb556568ca1beaf7e0c0a1107b46ee6402a80d38b5f35aebf417be1754c0dac3425636a1b48a537a01e2f4c85c4b41406222b2a2ca6b359ff6d599792ce201a65fb8086bc29b3f2a0e48bebb7f1cdb18685f1e66a545881b01449a7a4703beed9888caa3a1230adf6262924712b2655ea19b9a3024c6354dd964e44ae5665c4864e353785c3b18c9affd0c312efc790930faecbe60d8db2a9651f2fcd59a367d2b7f292a0ecd5db736794c54c7374fe833935656ade87c75afefbe88aaf29480c535f521ca53f5260c4fa3b82eb597fa7fcdfead002e9fbce199c1fce3e0bbf076005b596f0f5b69df85c96939a6c84caf70c4ec06714783bafe51a0760940e44713e8c934c0720c9f703fb12a3106e1a5e56b9f0520b8b5d1ccebb59a9ecaa2d566810daa5241ac03e755e783798eb26020bb8fa23628cedeab3853b7c4153f90600c611136a3ed8e8e781e444074aa8662e729d765dd68014f0daf1ca82d155a2ddfa4c74102fe9d5ad9ee10752b4aab6fd07e02c8c33a96c390cab0889ab5737875ae3d418408b3760ac33b7da6b082b233fad7ec1b8981613977879006c5397fffcaadf9fafad2767d2dbc0a5a65b684baedd32472a7a52850f9d09d3897b5f924a08d74a5ca72e9ef51315a6cc33cc0d8a479f0eba926b150e7857e8260fcaf0b1255c6f9866daaa2f1ffba53461f7b6b2494eb52616f00d1858f77164f3d2d89d328c78a5335c3c635393755206c1190710918b8edbe0b47e4eb8eec132dc1f75244f3d867097f4f8472c39fb454f457d95850ab330f39cb7f3c4b8de1618c058ab9edb96c2be4d613de1cde279a6a69df6e1d1815ebd184e7c2f545664e4db1a4f297e842ca21271d8f8bb4596b40283641c1a54e74e0d2aeb2a1c060a5eb9183ce6bcb7752bcb4dab012942abb1a74d39cc7e019e1e1984954420f35fce297f8650f4663655c3f83e3e896238c9d4385554043b47622b1a7b6c5b99eaddb95776b673ee57d64deeece3a978bb1ddb3b161423035a2acf6c229f5b32e9c4c4e54d545c418c84aa87971ab29575ab4460421a3cd9ec5986eb725d4ad224e85d10bc73e971b820ca287d91a50bbca0084b42d1dfa46d3b315a6f420a4903a8d13c21bfe3d9a4372c7b0420d506c4633951dfa9e087263615d3bda90575d7462d79761210e737f9124ea97f112d864539a8d949e56aa844fee017ca4377ecf4c60e257a4cd487608d481e132a755ddfa40edbb0c807037ebfc36aab5a52943da1053060088f54383e8913aaceccc035d1ca7da16ff7151dd71e8c5565344caefe423f69a2431147b977e03474fce736796188b97f6870c91cce0cffbfcf2addfada292c7533b17ba75139f0025d135ad91e8b5053ecc8679f745490a84b60b8f3596fbde3beaaaef217f8c359ca2463931268c20ef11af6dbc2c79f52104d1da6c5945f30aed9c862bf063f91bf0c4b38ad9802906320b516ff1c69acc0b973d2335dc071fb7cf5aaaa7531b2adf860f20c2a8d85bd50b9d5a19c5d7ad995b64370cf5a985492d4a67a9ec53e35c7c09bb404c0ddbafbfee8623d5475960222277b247419dbbbbb512ac4ab2292c280f81e2d177f4a92c32c217952d26b077bae39469214e92f5cb6fda1676df23e257ec69b02ad8107343b9d62e04ff1f45d0c857854ab74e5c2aa75bef80940a25c3d5929972957a3a0710040798cbd8acd0df71769ed198d60e7d38ff47fceded21f04ac1242aa93f72e7818ae7357bb08b8ba9a1feac611166249a31ee37ef0f362b989f717e7aa64396602d1e8b851871212e8f09976784520b399f092360ff563f26c256c47e86f5750b86c39bccb47672f7f08db7b8b9fe95d887b74e41549c7c936c2c91f5da26044f0359cb8a441655a82054f7cbe48ba08938b296bb695eb94eb58a9bb73f4a85ba1485977c636672023d86fe2d29affeb10176889d5a096de43620ce27bc11d474b12d53e09dcc8f4ff0f7730a3180518ad5f68acd1253542a5ec5773cef9828c654c1cfc156f7ac201fd9a17b78d6ffb80f475dd7ce76faec5d8eda87ac8e2be38d2f99b0ed00d86f9d7c5ccc6e9454e262c3877c44db4ac6452722f3b816da1406ee2e421b9baa73459c236810867d3677be4f7f04308a777995efda8aa4ff9aa4f6e7281cae31ebf0ba4e36dd43d7e63c8c421009523db12ece1a08bab230dfda03acd87806011151aa49a94587de0efe4958cd04966055af3828a9314beea9c1b9412d2f7c8254e0d0ea9357b866f38fe5be1faee8af52a8b6f6f3d48ba31a21157d8dd64bf2c3abb246ebef003bf166e7e8ef774d4155f50621b86fabf7a8ab2e348f27874f40ffb4513bdb16231033930b15bcd201cb14d35f2ed6360862aa1a1a284b33eabe7dbaac1914fc1a15ab28eb49adbce4ca8738b285945012a3e5151a3ff7e20789277b6aa76d32c10b656ef1ee2a6fc3bd1548f93f51ee1396907b17e02576d66f7a1a01a2e5bc6e23d3e86755f35b55770977bd661df347ced420ac87d37b76de947fd8b2ebda01d1be76f10607010c151115b7a2486ce3d1f9346785c4947318ef62c95226dfd07805d8d01d6ca82902a65e9817470fcfbfdbed1d06722c5abc47b7c3621e1b8c085065bc92825d7ffb86581be9207ab561b523d830800d68467bd5c9d8a72467ae285525ada4329a464f46a10032456016df0cc300300080d8fd0881c6989b9e5f2bd492bda60873fcf0c9eb93fb944d951ebcb4c04b372718c1a39a19b1ae737bce47ebddb525c9ad6a617ce97ada1e86c5762d3bd2c5a2b4d5ceb92b6376e8eb893fa45764fe932d91d196fbcad6e3a141d3ab23504b5d5ddb5841c6d14a76e515936c575dc5bccb5028b49bcc5df0af4bd886dd3be6484e333d26a3a3e863913333cbc2191cb5e74dad036c7eac39a86f83789d76969a5fb43e7b4552922dbed27e80cae14bda506ed3c194b6d851f90ace8d34c4e6633632362e513fbe2c33b039d0759b7cf124aefe33a4193416d9c9eaa89aabc38ae27597d3c4eb1405239f0d6ee89455693783511d06ca85095123af4bb30ca5fa850b422eecd7d6ad1d268aad9ece5ce639324d8b0eebbd6026fa476147454cb646ed7ca48641b972e66fccd2d3d9b5c5ebc7d56d722952e4d987846113511541cfeb22b706df62bd7047482241d2255f677379f567dcc5452a455712df2d0eb187c484e4aea0dc1015706c99373228915c3210e5c5c5224fdb611b4c9cca034bef0451162dc9211eb5f6bffa3faf925739a87164b9e885e103dedc40165dc932f9a4f98d1c4d3a0d7012ebf2f978d827cedc460abf8c803abd537939fa7e81d8eed862440a1f553b987970f2934a76765f38677a389c291089d03c1fcc0757d49a23c2c76f816c6ea22dfbe51266489ac5741943f93d6e6c0cb0fac50c900f3abea0c09713a52d0fb6ad6bc7edc766be1814ec59bc1bd54ed8e6e54f4f02a5faeb8754fb459734a2d6a369445e41db020b91acba80ede83d9ad259c0ec8bb93758915623172ed951863471af06dfa44ef2e3123915191839211016126858ddacb364eed192123067514d261b4534054b13e4d4db8d722f54f56d141ba762403792dc73deda6d29bb75d7b960e7278de5fad536c5e7234a4bbd73d3401a3d111950a6691d9678fa1e2475193f9769fa599ed07d20b325d8a16eec783cceb505886912418eef143c586c2e591f40ad5f30fdd0da553576715a939aaf815e60bb7f71ce9b7e45a5f9efbc577bc8a656378cb8a6fd9f6f2861ea074ca2a877bc53f1eeaf142ca77c4de9f84915719f20ccb49561e9878d0ca366658c78be0dd39ef8593606a73cec28c5b1a0b0425dce2a933797c4e1d655f8af748b1af2dce41a8d2a5d840107c14846f425378a311f0f01a8ced6e06e14ccbdfa35916e064c4636ab9aa855ce86693ffc6639b5b6af9cf62be88c1214c644ec5b32ee86c352b0c82efa3a642fc8cc6f58d5f190d8bbe4dafadde235ead389bb2e5a3da342cd32727e03125cf73a17023242d5f99fe4c0fc48c6fe47d130c02a4dd4feec0609c1bde6e1e5f26fd30848696e3b38f680b52e34735ede899d18acc2b738d3c6dcb158d77f755e6d4bcf218c394ffd33e313301de7652df18d086cf801f6a81be08387e34e4e31808395f46e5fd9f7fe3bd2ec8fab2848979a2de387e2fe76d81d612ace40205d76278d8cebf1edf24068c013906a5488d73e668b129d44037563708011fbba2dcbed2130ee4c4090907da6ad899a224acf5100ba7cd705a134e72a687e90d85d86a2e12999071589729fa86951d4743ddd0d313ba8c050674b203e7392e60a80ec88aea046d7d9f8f68e1933068a3645ed5e7c99a19e2d3eae69e15f54a6209203a921389310008b000c02d0d953177feb3caf04a9f4a76b2a9306de37c97b6621c5f5869e07211a3633c7971735bac93c536792ec05708f86b32dbcafccf315365038712a2d2c00639fc154c5bec33f6fb8e8083860c8a77a3100d6aa96a017ad5a84d66adb96cd0b27fc7ab138333d014c6d2be6466add5fec2343c2620964ec10888e4951ed0474c1ce2cb7dbe600f5f3899180a9bc5c35e095fdce9deb917c1f539e43baf695ec993a4cb28976454a2def93ae7887015944230c57e75178f41a1180dbc9f780409e5c7495a2ac995eea4145afa18db481debbf0f080663ebb26f3e820a386239e43f3c997b6068c3058213eece336b8f5aa32d1b6aebaa630e46cd46b0a04becd968b9abd3e3889cf1b7ff1799a76c651f2b88d741f4c58ce5d5f7dd49817816d2f4288fbe03f6e51d39367acd307732892af410768434f2f441b5a85a6760909b74804a607635b7f079bb270eaadaebc20ab9b395fd2e0695536a84a7f12bee777ff80fbd3f8a5fe32bfdac0d695a6190152b8c318c8ab6e5c4753068573cf4606b8907eef75a538eee70204b16f1ad850769aa15b878f189512b45aefb863107df57dc692a4a19c4d2b2bb15b40374344915cadbfd6e855a1a5682d9c72a97b09c3b71e1128ac4696aca8c1fd50283a6f8d66957e2f9c039cd96ed586f693a0a3791fb6cc820f9aae8b3e1d7f10076904cf31b9f4fcce615a3fd49d15fb71dc06a56e737b8ef0625676c5e7d63dadd73ead4d592ae9172257fe2ff93688a6318c93588008516a8fb421f827e79c4511b83d4696a3dd61476ae7080d19d544489b45fbf9e944ff9cecbb795fb81f1325178a13b6a2e007f9d0ec4ae5ea9875914bd7c5acf34ccc5d8c6658870474991ba0d369d087c813db1420580f436761045288e59b3fd64a512cc34bcc4794098fb3292b5d39eb5a2f33a1b72437f9474bef49584b84cabc1db11d9b9bbbfe733daf793cd1af28c119b69e6d73b8e266b538926238d52d5a5ac47456ace0bb801d950103d738228f0104055de5bd20514d909fb0d7c007a7a23ca6920f5e0ac3b5a9735658338657860c0b48261aae0c8ecf783be53f915b484c212baeb3f973ae97bc952a761a3b008e254ec592fe141f9d23a293535b0864d8ccda37fd14fc149338b03d30972ec171947bf9531a1e8851c5f9b7a6d57d6e3307397a571b9b1f4b2858aee73d1161041ca412fde7f050b3cd570ad8fd6efb2e3e6df3eff6b459a11bc442278e81eae0147b69da35345a8c6259989b3354e687d3c7b7fab048a27e1765ee793e19b9d327d0301580b22f55cccf344d6bcf1e1d398de73db8aef091ebdcd1edd501cc615eaf42c7c4532c11393566ef7361a88c6aa5dd6d76e7422b26123ffa61a3d8d72e5a76632a530c0a3dcc9a713d131a94020d359fb4cc05d81e0ce83e821ccbb4c6a98b64a7ba4652f34dbd1f01dcacb3044864ee5e285079b8633cf82218ce427547d67586c52d5cc52d5739df4b4a56a3504b18af38308d8c10087da0df7c410cc34bda3f7742a1c54bd1c83a0b04dc065ef66cf0f44c529adf745d6dfda9f702c4381ec521b7e79154783b52f3b8d5bcea57ece9f6db326b10102a724e9074ff144ad9a5a7e7b8d8c6d8c6f7589ce5afd60c2c4d7765c61daf991418c4758f336f6c2747d0527b5f8b8f89eab0a6da8f53a09ce96beb27115971f3528fcc677d3af1c3cd03158e230b0495d0061fda437edb0c8af39a04c4ab362a2edf048fde57d9c10a39e750aeadb14cc35bfc34642aec80dd2a7e771caa55c40ddcb18d4497d37ff3a8a1223f5c53276fd6550f587f954723516d7e7813441da6f8e96bc885cd36d280799089ef717cc06c983022a9a47163cbf787341cd86fb5c40f1de08b38187a5b4066be50cc95db58b6489d8c1a2d1a020c9d165a029da5579e66225ef3e189f97c4c0b4d67c2aeb0a6f3df1182badbdb1434eda7687682c5f3edc9a4d28fe0cf61824bf744d10f25e951a2be37610abd743847f146cb398473be78ea82021a5ec4f5d1045d73e829a11ae629f42b817ad08984e33f6b58e2fec40ddf69bf1c872a0f4fdcc9e9285a0c67208e9de9dd8740aafe78422efe86695718fe9d8d8eeda03d6e80efc7368081188faba263484c2509102e073a458b341826e4d84ae64efdf88191e607b185be0dd1ac88ede16fca4da23356cf0545117b0b0d845657080850d1b71828b735ae94eb23bbeb63d03a5d72b4b3af93a3ce6a4c205d18e38c4b6c922afadb2a5e1ea61fc08be65f0c9c257aa5ad6629c2f74d4847715f154ef7fe82ea66cf76f8003f5432890bbbd6eac2b53eb5d115989b81443bc4ab1689d3afade0417e5b86e3fbb9f1829e14a80caed559bb9eb1cf9bdb786525b23d6b406ee29d3ffdb260664f8548cd93c27fd4b3e882e7d3cfad94ebb5e693bc5f2cbba694c2f5c70cc41495f90bf365649e77f6c0dc0bb4d0481b8bf394ab127aabfa916521884bc81b70a361e6c6ea863f45bd07439852f81e7fa1d082b5f433a96cd3f82d807603ee6de20d7439b07b81b9ab6b77016d1daa4577a3f92699840fc4007ce3bc54015ccb3c1a15c12584269a3ae744f60c9cc9156fda071ecbaba61a72ce1216a2894f91e7069a315094c1359191575581cb402ad3f4cfe15748d8ea108fa384fd57c293cb5639f4623861036428e20784f4722341c04ce56ef32735410c59e42ffc690a6af4c3d861e6f44da9ff75d43dbdc97a95adfca8bdbec8cc65fb32235dd8305c4daec9dabd7472a29bcd95abe10d172d52db53077bd440aadb54844577c822df6560dccb28b56935627f6efd84a29615910919bc8ad68bfbe61664885466882abd3320bf94894ae695b3c15eaa91537bb54f7340294ae05b059f8e3d1db891520a3e16750ec35ba591cd1cb3e515388bfab9a3b57ee388813b6b6edfa03df8b447bda4cf39989bea81bbd1d0802ad437877e44fc952d790201ab26ec833a89be94d618f70e08063f4d6a83893bccbf8a5fe1b400b816189ec393d0312cfb11370164e1c0dbd867a8084b2e639b2919864c1a9a01bc6d350059f0b85084deeb867a85cea51c361ece24b39584b129d2f69b1d1864f83758d8feb92b4b92a29f7a6ee048ce5039da091ff6dfa41e12d4ceec29b91205b10833e6db3ed248899c504c9fc6f23c80f7e71743714279e90b9372497f808897b4ae6458639986af89eda5531a8dc5af9edeb120d0b8ca1e4561c5a7c4df60e7d490159f82907bb59738db4fd15ec04c4c4129c0dd615629c99bf10ed1c4a0a1bba894c34765d57d536e48826ebba0159144d64ab17b2b60b746e7f340a307b4a8c94885fb137fa5e99579fa38e999ecd78185ccd3d996fffeb4866363288130c69c2b7b5dc2778d4912b1df7ef2373cd186359fd473fb3cc809109b5d2b904284627ec1e20e0dfc4322b4256593e1fb31774898f5e19455b5f165c8112f69aa63a55b893acbb302497081f2b2864f14d5f92dea08fb92e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
