<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"420e7b0fda201f4c95ad00b08614992fcba0558ba48a22480e1f6d99e2b1a0b3a677be8065cb964f085df6ba582cfa09c451c88bb1c109359ec579e79bc806d402812c822b932d4f0101b865fa2a9fc8d6968ba191a466bcb775dc8639c421325cd03b6b0deb48b6d94a1babe0e7c8088feedc9ddb227b4fed1b5b61f2d86d472ee88b259975352b3e4438b1a82512c088ab57d9b548b48e3520cdb463514f495c81c7582c826e07a8515b0b6f3a74484740757af54ae2d3706d640cde36c76504e8c09b8076cef650d4fcb33b8b85f8764f584ce6398d5d42e505c69dcce9aa105917fae152011550c70337f1f84562556cd0995a80241a9327e04da463f97e996919d76c89517a763789001beeabb5433eea17036a7e58477614f850934ad7f0505efa45d3421d8086154118e8effe1298e114da85fe90c1925e20bf91fe5ce7fbbffe7629b4268c29deacc076090aaca05d064dfb925d85a3fcb6c98a3cc3a34fd17292b61573cc95354db803e03bce9e8f3f99adea6ecd2622f6a40b4149185b8ff1123159cde3314661f42c64aaf3632417a0f10d03371049305ca4a45601cb48c197ecd5990a11cdf32d0a4e5d4723267f0f9acc5b2da9b57973fa885badc61b85e44c0d0d7d26b22ad529b02ace07542d01e7b847924ec384299a976b2fb1726d0732d71e92ada8f5c047d654ac302c60a5b25605c0299fc43821ae1501121e8acf57147d5cdb388d1f91da3e610d0d839086a62400f2671f7f3e2ccd0bd36c10abd8bfe7d201c436657904b23bfc44643ac418807ab7bb944cf044fc0b16fe480944160f5736e83f362f86e6c2b43bdbcfa3626fda42a17e01708cf3341910ec49fb0c4515f34fd2dc3d1476962979722f00d734fddf5e8e1d78a0808828fe543e3312828a24511c4802c25aa4df96efed638f42e30b9eb8ed22aa63ea3aff9c9f0d14104359588ca60f137b013faacf6563678057f0b952fc05cd0156a99fc56651cfabbeca5af7d8ed50b93ce8ee63045307ec9cebd337c33406cb1931d8e9d93586bf161b87174d3685f5c5516564579e10ceb5a2d98b2423912b234169a3c9401e7ae4fed4e6d953e0615ec70d313e6e376f7cbf48fdd1644594484baa2840bf9c94ecabc70f15a0ae4a7b87bdb763855d71e0ee941fb7ca453bd032c5a145feee9f84a21869dfa4f15885c7d699d159a6fbdcea7e812a8ac80baefffafcb86ff84a14b5eab69ab197d8e12da7c7b1728106274ec51805ca56cd12a03a201a5887df0657d866567639f68dfe442d7c4b7b52ed5cabd7b1dd516746b4f2e2d0de8016af4bc02a925d4f4383ad39b0fa72779f7f71b88a1efb4d4e44cc06b3a81445ede0ca8bf658a4ef3e5494bae82dcdac5edf3d3440dd1e8e7474620d18a7f71ed242ee7bc671f03f9314e217bfa7a29426dcc6d9167054aba345d955d2363af38e02cf65cec55c12b87dfe3c60db470e86f02ab227776002d024ac3dd279fd76b1b277e71e4e417e2ca4501239e8095cd8f5dc660a003ea9c8a8ab4798d3826464189cadaf6a309cde07697e9143902bc0043db91a94d4b039f30b0d2cfba9ad7cd88618202898089bc0bdabb88bf52aca378c7fdc7f9e5bfe1a4e47363a7c38daff3ea4f8212fd7c5a3479adabf099f1ed0ae5136b9005b4618dba6082d7fa61616e6a628384122960454c73e981e7a3818a34975f087ec8af270745924d302263d5a90f5a5cc615eca65678cfc49c52ccb40f446cb2ae5a57e4760fd36e3dc45120670ff5c67888b9e45cb414681fd7fc567e1e08273c77109b53368737090dcf4b0fb697141195481211acbf47002957a392cce24d0c81421bd73ce8772c4ff2a0a7e6648efce003fe13cd90cabb6776597fd11dcd97805e7e2873ad9bf7a52f05edfb9e04651f5705edb0c1878561fcb713768c311d0f4eb44ff2a9b2b53b3febe97d9446f5f3d5fa82309b880a6649dbc7494dbeb3fdc4a30debcbc559bfd47ee55cc06834fe1dc98e24c9590e985a893dd1c97b9a7a2380f39263f3e2785028768f2f557811dbdf581933610826460f98427ac6022b93e034fb9ab07c3c9ad79f113fdb52a5e67c95813894a5494d2ec7886c69131d25406ed23974dec12dd673fd28dac876657351d3132a0dcf613faf0e3b9b5c456c2d40f0912218cc6d942ae132aed0e66ad7af3f647ef78dced60cdbd217155ba3f31213c3afdd9bf225e2e0d6765e72a6ad0cfce6fd366424bcff5020156822955a4b7afe9a944325e50293d8ad1a2c9875fcec2f58338ef4b66d673681156a5193886f3e7140e6f6589720eb51d5059c48f3b69703cf4fd7af87be15a7ef15ec8b0cba2a1a48ca7732a192e7a8569bf25e665868a0a1237a3e79e427ca420e1c5539a223cf6930ef2dd6c10d7ece16664637055430396deabae82fa1355718d44f375167ab8d2dcdb16f8a180d2b516ae18fd8a6efff275cfda067864d03f127455d9127935b9ad230ceaa7f117f7d8fb72035e0c9d424a1f100609d63a11502f806bc8532b2a051a17c77145e8b6ad0be6056eb4550c7a9fd43e8173546d285350cca499473d609c29e405788a403c8a5a036911e1f7b471e8cfa167f3dbd3dbcb7a21283930e27c6612c7e0e24074875d0d8ec0d215a26b71141d69096595110d7b9b8ecb12c143e06dc2a1afe152997819b55c09d6ef0abc390ea9e87c576a2143118874bd580061d6c2bb23cb405df1558cac15dee3c61dea0b05cc97d384ae55da8c93e2b7b5c711bd1afdec65182705213173a699c8bbd5f740df060ab2e018319ca9cdd089f162b2557414a822039cedfee3df9a346454fd668b3efcd4ba62b54a4b265b4a0a1e795813d2ad79bd4f008a7f8ec218a098499bebe0d6633d9d4f62894357ecee892ef6384756dd7ede419ef80c9c8ec447cd58dbaf082a9c9ae46987e410f660e3c18d70b23a473e4b64e4877230dfa86be4c17ce1b4e607fc669e933a2224acd58a3d3366bd3e2fccc4a307dfd212a579200109691c69bd1558ffc12c7fc5183836f51105dbf823f5d42e3b6346f59ce32b54721a3d7cd3f3fcbc797c38662fa67a7d1b1f6bb97ba1003669e8a6fe1834e71095d9ccc5633a51871edb5fc6289aaa9be5b7eff365de3fd8d5b3220122a2d2bcb527d3cc3999dea03a08aeb3568e98caca2eb4fc1ae0916e3ad85a7615ad25cfb784f9da75c738410c006398ac6c3d4524c23bdc99a821d3fa9693b25e6b670f6b7b107f6196380a1ebf957d5a0411230b272018028ac1f8720f2c36afd4cf5d0187a57762bb8573aca7a40ce5ed7efef35fcce75c1880419278bf257d6ab7575d83e2d64b2bead4382d03c60e5ea3edf75dca97113c452f6931cb3c38ce5a0769d865e9e4996e830ccf5bf466f06579668372b535db19f78ea87bc0c7ad5d45649be447b99b7499621ab3922469d8f684a8830b5054fe6aebc4db2808227949ffeb8816ae46747f0634a2ba28abba11e839c7c49e5feef6901f5f930825f3229d00839e9b15988b0d35032b054ce2fb5d9ea0d5aa0f0303444d2c4ab48d3dce23add7fd3b432ab1c2850cc437385d92dc885df940baf315491bee11930a67050876140af44382c07ae2032488b9430e799ab6e4c395f40099f065b90fcf694187d44f174f6707813faffde84951679ef69b85f92a414d1045811f5e63f1d5a6248960b7ed8563fd582d6b89f9c7a53318579af9fa33d65bf8f8acbc594ed2772921d6d9f2f335c1c9d2f78bc11b8b52f365150a75744062ef121a69a6be7a458a82a8a6f6b4273ec4d777c049c7a2303b1135bf3e830ea1d86695afb2bca135d94a6b6a90cdc3cd4a95f1b5a7a82e531c3728705560b9e76f00731836589767da9c64c1865668e0c9740d77cdbebb1ae978fddcdaa239b30c6f245eaf044e020cbfc6335d9c5c9b58825c3a2bc1368665d7ca488f730a72ede1a895b0f1a3ef012fb482ef76c1b3ef253da36b3e945e0f66438225ddff9242dd393ec7c4f97dd80b46860aa55cc09d868237c1a6d544751b5f4c0e1b0d26d66ae5b6f488f18451f01f6dcf150867baabc435bb8d718cee37e29df8bc86a1eedf1a56b6b376cf9af67e1974ce2877ed96c702be5b3a020fc7a9c1735d91a5d88bbc0e1b94e8fb88078834afcd2129d37bc7004fec1cae61339052cbb2c0d89f0e2cf81ebd83eb6bdadaf1d3817f25636998e19b1f8abbfadaf4f6cc9e14a127960ce9f950ec30f8ec7c2f2b79a825b05f516d96c68bbd4599f72a6aaa6408ddd830e6a0998f3ae2bb569da4516514c28ae98a08de648b20d86cd6949337298eb854beb6c891d6164ef58bd72a5080573840681237e22b7e081ab3b879c89029e16280ab651124b360e4d9ad3d6607e35d0678e05c017c0a82da2f28d5057f2334997b8c5af058da571de8951eacc2f8d713391a845d6371497ffae3813e5577a4ced59618529c763bbe28458e7f3eae6144edf9057d467fc6e7fcab8d250af0a48219db08fe3e63ee05b41daf0b72f1014fb1dbb6c2a9d26f18497905cc5424e6f571cfd0b55c1edeada725d4916e0b5319279770f5946402e6dcd88ccdf0af2328f43675a8233e1448c479594791aa1c426f1e4be70ab4affb290cdf84742da8119a6af3ae5267edb17a7b7190f381bf8f6a29df42078a4867638d79fe4d2949f0e7f96761a86c1921aff85a402e466b6b539441ac4c087a6ac9995fc5e717e2053ee38cb607a5944ab276a9f3a71ecf9a79dec64d385c5f55b2c8eda9d6c1a9e38cbe781031a110ec7ade03cc4b147e35354f32fc26d7a2100d16362098f39bec768fb0cc52beb5b71d2c5841711cc5b93e1864986b5b5a6b8318040620989b476329f100d49608e4590b25f6705b42c9f6c5d914a1eba33b2d97fe041b60734e133bd2ef1f64a6d26519f4dc2cae80ee683e60ed63462292f4e0817b4e06ad874cab5de16c856939b9f28f5664362de7b1d81e31f5abdf9e24d6fed5c2b5c91afa844b7ca89b08ed79b274ed3dbd8bee41aa71cc0c2ec1d699901cad24b07506a8144ca7e26c28238670fcc8d062f6f135a308c1431d6de873ca0731fd63c1cb33b42d9520965f18ae8b54696dad890567228ad5f2c0d0ea3a98372718ba6ca88130e04c9fdc64770b622634e305f7e6209c827a5388b22b7e270b330393140a1b975002149fd68c6570d9f33e1dd657f1eb89bcb9df6086bc62114269a400f5ae7f6ce9ca283d9c50b2822828d3ee1a750aa294bdf79f98473a0dd63e08014741850e62a3309c8e56d802e4eedfd5e2180c7bbd6da63cb70c0ba42c37115db33f60cba8ea9f46bcc8d8f739f7a17da3e83260e39cfe3396e08e10e412fb91d9ad1b7e641ec6b1a751db2b1a77f6371bde1c1c01ad27bd3c904a005452eab57bed8c82190dd93c46c9836faeb3951b025de23856df99b3fa88b74d21bb77f8a0c6e48377161dbf0c24beced831bab194fb04ad9b4658f733a5f5411107c10286b6b4d7914b9c13c70249d91d634447f9397ab9663c683014fcabc018b9772138b4b4de2165f0e0870236a5c5280d2e84df4348363af29f2159ef321962d00b7f9c725614bf96a8b049c69ca81a3f46cfd2f85be9f3bf599bd381fd5c779166432037d44902f378431b6dc56cc1f0029bbc2a5e499a5bc77340f10bc229fd2427ed5187b31b179ac6ca46975481ff89000943831c29f7dc8d27df8253e5120a7398b04b6681864628fb910cfac827d66a4262f6a1544f32239eb60930416e71daab91e44a472148b5faf1dd6ed9fa665a54508b286290a5eff1049ac6373a15877f281a16082092b21275f9d7f0a2bac2ea4352ec72901b1fefdc687c0bd34b39dfe765218b72dd0a28948f50dadb519737d7884bd3e5458ca953137cf4a4d5b69537033ab917f413e375a0d9d657783f0f5671fd38728305aa23c5acab43c19efe5a69cc7ff2ff98da0912ac18c8de16b1ab2de75bf738b4972ecf78c46c22ec96d64ca1c8bba8785f585a60b0626ac87cc6a2abfcca1c6f27fb1491b9e437b3f324d6052e5cbb1360edc49eb3e8bc632bb9d483d918bdac76f16ae8c5334077ed76d5df36ac57a301a999839d8a14f388fc9c65958f37c202b6e53e9edd0f67c92ea10f162a18d9ecd38bb02dfcd1a4c0e541cdf5956c2ba25a51f2570d7a5ab635d3a0182fefe59f41371cd15145b1a087cce999f04d43eb47b233258e512fe7125043cc16528ca232c3bb7904d5fbee8af5793a870b9794af47b4655aa7aabc042caffbb4ec5936c5c86869e5213f245953c7af3225aa7b8176451e8e69fc7f74c640cdd6bc614289e38215d2e29c4a1e0bc4311351f3afee463cd7d45b7b28e330aa492e32e120dfc6572239a2e059a782d7b197af469f3766750c4d7bab88860e171ea8dfd8cbec75136def125bd5e11d3843525000b42853a28c64db37ab92c93899239ddf74110316f0360c27028b272f42c01acf8837e7271c44ff536fccd2a7697e6e302a348c5826294cfca24771d844a88427e24a2d49b4d36d979ccddf5b64c54e16328e7200bba58af96f2f8d2d51ebe0b463c22c5fa08497a832ebffaf0bfb14652a601d695e120e607b4bd966856fb9ad573193823409a2880732a8f85cad3f40118cfdf9a7a2e69546fda5423884823acf8113dcd92b2af4b34c60fb8583a436b751a8fcb7101f10b8d18ada7670dfc87607f20f75035ae0cf3b61e84c6f807279d3fad2c5241687e405d9cc31cd18e31d626f8a3650d94bf18da88c0fe358c9eacfc3b38d698e523ec394fe5b718bead4b6990527423bb4568b142922ff2ceb8522d1fff3ba5eea61f16ed41c84f4cd81902e57a5293a16f8555915155ccd4ff7ca5e24adf33ecad1e62628373f14c4f9ee889fbc7a92b8b165f6a1e56420d9ad490ef8d99b737b886a45069ba211f490890a86667ed44b1ef132de323f6040303adc934d47060cb013968d21cb03afe03644e31908e616c21d2b1989442f0d102899c077843add4aeec281bb56c052fe9e935caea37a3a3e1458d5fecc8262b0617fb6f25b86f336f6f50c92eb256e92194d0541ada5baa3efbd18e82cb0d3b55a8df6087966af579996af961cc7363dfab2af9bf4dfeaa89d74011a0d2e745f80505f2e94b5723bba4f2587b2f3daf1d4c3bc6fdcd959c7995c20835a1e58f19fe8a741e348f73ee96ffc23958159fb0145f383bf23f1777980d4c5aa68ad1bab0128494bf86c70aae03df9a1f91ca3f064396ffd91789423a63043bb4c0e256b3bdecd62163680f0804c64ec9f82e30c62eec37bd070e688b76e7396e5fdbf51db85d92453827790a7b8bbbe21189cb7d27186f2a105146ef48e47d77eef5543625634dc932a8a0010465a3683255bb46d74748e03f01d6862eb53b3fca28a53112efc60b2782375389f8cfcca97e349e9ec1fa37fb5d53bc537e098c0bca02170d2d49b0bd638978d1ea94743e164fc0530a6e58b6d77522263c9b68d8bfc51bf5556230bb1d35ca69e7054c01384aeb594f21ef8578314cf1685685a3ac29612a1ae78e73d04a3c3c55d06a5ce30701d524bb21a4bed32d49d226a48df1b2eb6dafb75ad4c44527c48e9b46d6fd72da3f0e15e95e84960491b3d691fe8da2b922883a898d9570f1e2aaaa5472a218d3df5fae3e5825440d29ec0c03b5816846a26197efbba09b540e244f5744214b07ce931fc78a6720d3cf1989b8489a92129f99195405745eace02e16e4ee3bfa7fd050cff393f4acde6841f7537a079e76ebbfd0ccbc9dc3412934f98f593f04b5afbac8c19c437ae4b6f4479ad22117519487e18950efe845ea60f9eea9ef747e9854b33cf11ab1512d3afa230df9670c66ea6603837aff93c936f47c435dba341a29072d1b3e5b9049ef81fdfb39d823972364dd6288b923b7fb42457c4459b467865268425dc40aa25ee6a6f978e45f0b6a4013cca19671d264bbca677dfbb27f00500e863f1e71fe1ed43e14f72cc23b6939092fe750fe52fd07984a0d24d4fa878278c41a83d4ced4f7c282b5bbe6327e1aa6357c4acb322e8d8e5e9ae0688106ebd563b9ef5d56499771a7e1d3b4b420418a70404ecfb8ff72ccc2c98e54a9f8e0c8cfc5a778b20376b4bbe7691e1d8e0cd12ce281907d4d8528c016414b55fb8301501ac7f9d7a0d84fd40b41af92465703d0bd07bb9fd22e60f1e8fc10b298e5f67633d6e4570f97e18cb3cbace0eff56867d1c4b195ab39118cfd581403f8c7dbc5330198350027203256c6e36708caa925c239ddf2ba1ebfd13ddcfeda665d37ed0bddacaa66dc277c5dce03764321f7e8e691938a7392fb7ec5f593e869b9eb7a04b05a59313752ccab67167687403258f4b29c37eb0fcb5403e1f11694ae8f3f1060532563e3f9fb36af9039d36bcc70f8e878e229751849441bba86cfda55a755376814a565cefe366ba920632cbedfc1c6372381ab12e6542faddfbeafa06f989a16217679f4064e6ce186c66bbbc2b90b96e34e1ff4781a4856dcdc9a3d81310b5d72d9f74e4194a91b89872a69c333fbd130cfd93772d0ab35a1d72ac1fd9e5e962c2e75d8d9896e588c00e6cbb628d30926fc056f064c03e3c0920fb597333d076dee56bbd3ae37fbcbffeb1a152147a04ccf81d8544a46e15a6c4c2b33f020457c57d136395ec466eec9947b4dca51c81b3e3b888e221542a1fc8b6ea4448bd6633e1a34cf7aab69427732a85b5e8a1fa25010056a57d628c99bf90dc128d8e71e9973b02403440fcd4519e8f5460dbad981c7157647700d5a87ae609a489768504c3e39ea425fad0a3f2f1e8e23b2ba6ca05eb5fc21a8d1e41592e90c56f16654db01c1cb530e7e0357be0fc063bb66fd72fcc64c368e2d2bfbf5b307406575bcc50298524807092ef08540b21db79881f6805ab258b4aa669a4cc02b220c6ab6bce3c43593f9904d58c9e69f91407c97092ff5185a0b947bdf38c53c9d854fd2e63d31c23ea94128bd2c3541e210a38872ea9d2e158e3ce9c95040a1a1ddc17af70724088565d6d03b86b9fb2a564aa14c4aa921d61189c96b3b557617245ad0fd59a8e536ed17e9f89b35536e3be18e2d35bfc91583443923f0d54e267807fe1c10c179346bd0d6860274c4022c358ccc5273263286190690dd92003f0636ac14c091c3d03b2517e7463dabc59a40ac92ff0aced2eacadff8a26b7afdc5969e329af6b3161b9343213d06ff6ae0fed56fd936054896f406147fa3d184fd5809a5d6b08a0b62aa6af5e8daaab90b552048e87f241a9af3d7277ffa6a039651981c138a8b07f342512ab5f409f1d058920276a1e816f867eddc241013a4dc70a7cebcf8575ec01afada245b77aee569b7a17912b79d943eac5ebe2156365260c2cc10b8e4ce1ed4c3a838f947e8856cd910c59c5c8f22e8f5470fdb8c969531d1e715889a540e58c676c9cbf0c0da401a546c9ecc9f562e8ba9626fb5c0b14687eee85cac05d15ff22073b3bf7c0b81b14572edcbf2059eb2a4c6f40868a8da3f7935cc40c00770bef0686eea5788e69ce12d910a0428098e00b3e8c74cc170e9d5cccedf146a1a878f859cfd05889e3097066de9bcf9cbfbc406ea6f6b1b1f8a0026911d5b192584a89f57e7f7700636443ccc1f82a98c417024fd17369336aaa05e363a15afd83ff2d19262c0a263be56ea5fcfae2f871b838115781023c4d95db1de10016a79c01310160c185de48c200650a3cb76985adb59e82aa50c82943b63cf98ed2acb0d53a749f63b551a915485179020f13105190f3fa2244f88b4c62d4adfa1b845563235310f021d0a115d0041e944bebe65e5d5b8bc53ccca60ef84b509881fd50fee06d78d680bfe594f8889cbb7a789566610de35232e46edf6fd291f335f695347c422142d000b2b21eb199bd1453392bc2ad3c56323dfe4bf15dc7106d4b0abee4b8466c68a10583eb8d4809112cae107833a4154b09647f403bc29ef538c40dfb2686f969aedab197653d8c458e79fba3a3ccda7cf09de826b1c3f59b5395309a1c9ed4bd968c868f38de8a745ccdaa14f3ffe801dfe4155e3a85e082033a70eaf72b063d2b78080e98a59c66d5f35c3ab278316e2d22f54ffc7acd12161563aeb41afc569c2c75470f837926595c26113af27652f9768a74164fa6520d3b163df680ba2b54e7a2b09bce069b2bdec63cfd5242b8e25ccd61993aba1e585c249d0c3c86ca886c11843c345176f94c3e94513543974fd8afa2058c2996ec3211986e1882314aba3acd4480f0e4992a56e3da624fcf3c48bbc38e64bc050f5e804ee90c0006e95f069c2a76c9b8d26d7317aab3d10fb4113fb081b28670c845154d53bacbe015d81e302aa0023a4d49280a1cf157e5c687041b5d84d45ab7fecdccdd9e4d59e70756c0791ea97f8afe9faa4a44238dad99e3747d2c4f830a78e9b93c0b64e8795e8440dc204b3e8fab17d41c750037626f917c34fc79b97a1e123068e3abf2413a83a14610ccd5424522ec84a6bf9f37b6a77fdd72453784c23cfb20211da9a4c80917c93a0b0ec48063bbacc7a1f82ff998470fd551be146086254f08c1153f9a134e158b633482590712134d56c0bde24cfe67f823745d6bf9fafcb63a06b767df1a2b490a764e2af2a9a1d1d7a427e11cca5265ff8eeea188c20915a80851e92c67e5bc9091ce8cdd604f21708149c8876465d73c7a7422d33390ed57584e2d9e1e47f634b6b7c6a2278f50d5777eb678f01f094e0b753aa65a0c42957a9085d491ac5472bf909d191c3bdb866a35ca7449575028d2a7c04cc8f72d8b2cc41629c3422cdf485f3bc6ab462682beee95ba6cff598e86dfb2cfbf047a3c42e3ba74c7388c71bcfde9a8260f33dc50b13825e802f93435ebba5a2b41ad86d10d25b758ef1f8d3fc1c97d6a2e9a3b63d7fc90a101fdd5c25a8d81ce5653b13889bcbee68632b5b2f0b465932bcdd6c0ab2c7abf94ead7d06439deea52df0ea3e66a16281a6782d3bdf8c63126ef0d57accda854a861b00cdcc5a4e0e4ffa10a7e8a4d9710eb23fc7fb18b9d3b8df925be09df0526a2cf7f28036cfac2bc09a29d327e1a9e8a00203de94b4dbf95541425265656a605cdb14420e6905c29ffcbe81e9796060afb10db64a2fe3614d734df461f38284df8a9d3ccb590158caae1f62a265d364b88ca59d78fd2a7aa29e8204ad534d5c9d9e13f8bd5767646c0f7fe05c3a86ad56f0b801e6f2a23e286208e888ebbbd8265b8621b916eb124d491cc30c4d838b06c172e9a300115417304dcb650681882ceaa13403a011946e2f87639df50b1322c4d9f85ca3cfe3e9afe6647933241bd2a05a1d0677629789ca9c02085dcbebb861b404327ae0ea702fd431e81bd29a0a717dc26706bad2edd4392977fd8cb9b8686883a359652db8da86bb97b7792021bf92fe823531ff24c5114d8dcb4d8337176b25f5e0c24d5ae2e6b9da3d3d1462aa6a2c425e8048f1f9bb0f9a791e86003c08cf28dd3e5683ae4216bb902968893c3bb1af50e40d502ac1d8c4c24e0428e591f974c039f4d6032711b077ec6775026520a4d6b34122920e3abb1f2789d3cf84d0d450b00462e105305748f75824cf5ab62ed8b97b80c7fba9fc6ee9e47f639ad88ada15bd3e664edc7816e2431b06f4010a159ed078e7f344c7e4c4339b2209a73a18cc87b930e68de9c6ed834b73b85652d3da42fb29df71866a06f416ef9f0444743bbcab8706657f6b71bf59c23f3d1da4256af41519ce1ffb1e03e7f471b97574f1aab322a59e2a001a006305ffcd36aaba56941934c4ecec9008784045c562fecb40634aa052957f036ddff16f0f2c326701beb9aad73d6337b24336ed7bdc0e953b92bee39a2be9721f23ad98bbc5cc0972cc042791f337ed815f5e1f96ebea4ad53bdbd83c9dce26f6ba5382020c3c1ec117dd2f4b7cfc71488389532d198dde0c6d4dd3d94fe3c247a3654bd0cc8d8125ae8c18a86caded9fae768cd3c4941d942828b008d38a741477d4c260b03b24d5515da441ecf74f46fbf44a451f45528b4f87ad3244be7a7355a4850969ad6129fe35593787b37b52c15bb9545c7657148abe878c79994b4cef0c4317e050ee706e9a8bbe4cebf166d95d768414f72b79809b9a85e9b6cbe3160647da6ab76648cf7886dd802c94256165b3dba950631086bd70334a8735ab4d00dc0cb4d6110cefe78055ff440ef3f5466e625dc512b27bf3f1974d12342c5d823d9cfdc8711115b03a5531590c5a51309d2e48101a2f3082a6333bf0fa6d9698e4a06250027829410e2f87f7c8cc70e2931df00d384ad631b9c5bd33a15a4dfec9e393d7561effbebd27d2db89c967d4ee2aa5d6fbb2280b9b5f294d30678e51ccaa877893233797a836244f970821ee2b368ecff7f085e058f00578619f48ab04efd10c54646cade27bbe2c307eba49b5df51822acf3c54bfa9b1a35241af79312acc3755b12738ec5bbe52d5e2b3234e614bdd48c5fe5325e753ca8ff7338d0b7bfac159a51c11efe1843bec7068d866bfb0c9fc7096e2d0806f24a2147ae867d443f84575c5d26842ebe165c2d2c75b8cc3a9964b21b74f2c1cf6c02a7095c4189726d5c6fa7a294d25e84569360913da16b373127b45ca945c249e01945aafcafd8735023d85042bbab2e11b235d3b2235dabe9b18051dd799b6fb3fbd1e251554fa1c57ceb280ce28d28e672e16f12d6d859d4369de0ee0687d0bf30889f7722399f2e7f825b638c46d8ab9020a0d9347e804aa640fab11bee5c00f5e86169380c6a85ccb2bcb228c9404ffa4f80215bce1b111d428b9132b728a0885bdeebd15a4f77da59cd4898556dc2ef4379f9cf3f10b7eef4e75b0ad831245740d947e10d0cc8417e1818aa4553e13179b1ea8595eabd2ac46f97c0aa46d9ce76192fe25a0383c0440abbf6f39e54d3a1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
