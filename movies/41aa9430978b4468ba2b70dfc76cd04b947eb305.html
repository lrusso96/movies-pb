<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cfa4833ad8ed223a85ef83b92216b604f157da5ee410b9fca9238cfb78ea77b15e0b2d0ba86fc1eeafe2d03a62bc27167949e79da95fd33fa38130db8edd7a77d8b2aad499f30c9f46c5445394777372dcc09dd199ad28281118076937c360fff99c5251d120482727f7ae4baa3e9751bb199a3861f0b7a40302204a5998084f4ba3930fd3ea456432d6ea7ea3ad88011e8fc425b6a017dbe0240314a920d215900a15e84c145372e8556e493e3a4c46b399958f0a68e24892971324011d1b3e75d7433d71a8a90fbf9d6a7928801123cb929d7804a2b5257c11de53a8e9d6dbef6bdb49d3792d6b32a1b9aa21946b15652f0e5b7fd85c13c17415eae2b44fb264e38c8620aa59648c72650fb3dcf4ac789599e0ef066460585046923ecd996649b636aa36380419a3e50dd820723647d4e92dc43d87b9a793738f01819b0c0162c4a75d041af844e76b1f07b76b93b50bf3aac4f76cd61b7d81e6ab2fb83be90c97d40f3da8131589fbc34a2bb6a3ce2770c3ce4e22d51f941aad48951e6ed11611bcd5037527457fb6537ba44d4c4469cad85d083a6d83d643dc1f665b03f3c59c94021e8d14f2ea20402aa2b2d94c95206204e448c7f48632dca7b7db051a4b7b45f30ca97b0f0f92f734fc1cc03d26ca0e762e2ac42a0bb0fc997c88ebc906c87ebf1be7550b10c188dfbebadb4cc0cd4b78594ae35ceaa6ad7d537eec3218270551c588e6bee100dcf0ef0990fae2e88d00adf938ead427c3445ece849014343b56dda3aa95b0b0459d164de26d9744bf4c5bb74b6d19f5fe4f379e08bb626bebad158017de3d25748facbe6a467f6a287d98bb237d07bebd7510b011a15b9da05e30a198a9b1a96e6ebdd93d061d28bc99b6d331de06ecaed983fe5afccbc7ed5815a9875497f46f04bbd7cacdaa290b4efc89f330ce2fb18dba664d41b31f69ea736cc80d55c5c3650f38249809ad0a680c53f49dec4f65d989463b8b01c2501ac06b673e8a20357e63afb7d8b5daec4514bea1ced4210ae3d1ca423837f91c930fb89d51c9c05234985d1fb5739133d86ebb4cd0213fac4c74fe4b59ae6ab40cdaba4246ae2b2d86a2b62afefe27a502a03988627ee16c2158ce6b57f3d98f41040ae757a10a5261e8f9a352787cfe58fd040f393fa5778082c84ceececd460abf359bee76aead6c9bb3acc031c16d72917ac44b7fcd5b2f7f5ce5c3770b34c687744eae912259dc9d8f51c06f00efc47f66dd86974a999ed2bf0ea854018f4f1e95d5e6d6c908c09f6b1ea968e8d2cf57783d048f3d0bc66e449dc7b453c81fa969e7a52834de25291689614d5733614e372b31d6c7dcaf20843742ef75637814115ddf99527dbd357742c72c0673fc96be617618e3be72583834409b79919052db3c7e1abf1f2ed18cd97ada9f8825e1c3cb656f9c49e18c97b1557d037e0ac890db7e78715f740cf7493df033e82cbeaf98823d82de83ff74248608d5c2681d1b7c11669cf53e1ffc54cb1419ec16429bbd50ad5a4dd5423ef46d3fec77cfd1df397b210acedc0e138e49cfb213c0985cf8041c039883d10c0e80fd23d2843b0d7b858ceaf70412cfb7fdb294b71b3fdf35c1552f3259e970cf7ccb9e1b7827390ed860ec82a5eaac98ef8acfd7049ce9cab7706a69c015709f707cff8e1c6698b3c8e7ac4858b60c21c43211abb309e31a76a553686565feec2439048171b430bf18d501b3cd7762e148f8c233e3805bc7fd30290376abe80e12bbb72d74b72252f015f62769f61402ef7358a2c754bf55bff123dcfe1db558ef4872a5df8a3b523c4678780779cff34148f0d10815748a8d6dcac1823f0e1ae58b1dc173f35e168856331ad936c8170b56f06a449486faa8d486199220e797d9a9325e984437cde92282b90322058f4b239ca0c318c73d029d305a00cd1fbf731a8c59f0c21047864a3b60d2218ce703fbede602dc6f3633adf64dc2e2a94d7750f351c96d92d4390ff8eb9571df882fa491b6f0114b997d8b2f88b7fe8e5b34cb56b93e29aec9d4e887637a1030226ac44abe935cc5e84fd2784dd4f3fa10a272c1d028fa58ef8aeb6ded3b32be6efe0b921c45748ff5ab0a0bc7a15a299901b42cc41d447391cdb4d99e27af334f1167f57586b29e9b871db8047cb1141a6b8671f59729bc522701e30faec0064134a4cc8f7cee34321ee6e644986e5f590810cec94671fdb9f24ec1c679fceecf0f63ba62ac042e986ad08e447dfd9ac60f24eea37cf0ac66b1a8f79265ca42931ad151c525dfc7a647d6f81ec04b191781c4a23adb0d304aa01277e075b507d68487ce3472526c9de63b3e10cb7de877b12cce6545321cdcf15cf344541255c658c86f9077efdd51385c7542a61cc7aac774f2c1b6566ccb611098371c67ce9dbfc4145be7e5257db88a2e071a5bf322e3c42895538b609399b67bec78c0a7541830491557a78f5b9a859558bc1630e2bf4c339d1a0b0a178d7ffde0d5688e62168804704c03da6cb4897c9cb7344b4cb6457be4fcb05f0017ecac5ba1aa366f0c53be4d193810b75b287d9501d208dc429b818db4aac4e0eb01604c34b1841a72365eea2ec33e7dcabc4e0737655c8068949bd8f4dd92601edd541f312bcc33351b8041faf69975641a255f7e8ae860d74374096759ee2c35216c47e70c80d751efde02b14dff923695f262b81326eca266cb80c52b116ffc0d7f024be61a975c80859cf2a4621d10f05ad5fa43b33f40691c579b9fa1349c38181c23898771f0a074c18675cace2070837bc6f8e73f73795a1049ec70eb1759880a18040123f16e4332a07314a26a3f135d95471b49c15a00776c278481047e516cfa2b7f473a347f167611257e6f8f5386d42d64f8268ad71c2f82a4958874a353a48ff6314c34c3037f9a49dc1eb970a0a2f9e8f1f4d89f24c67b5642f510b6c311c9f8abfb15f2f234f83f3abf66f9af93a8f6a1b38476a67fb534edc61927a0a43d1efe1652c1f78439aa524f3fb0cf80f60a43f13ce350e9238a06bcf6d11dc62706ada5db0ba801c6decbb6cd9f408e0902d39c34f3dcb5e20fb46aead86772ca62e1d31572c8d768e239ba755a691931e5f6eb48bf306353c4f4816d13744ae6bf8596ffcb7b7d6e3f7698a6d8c7d6236e756256bfedbe152436b706469961c9bdbcc8fcae6b57715287ed77e2c487b80e28ba366c394e4d71e09630926f5ebb3c48159d4ad4c61bfa54f5b4434b09328797fb54af6322fd9adde9eff3b206d47e2515500302e3adbab265f00474d8b4954b5d3c2a86311deb0bab6a3a09ab56b50977b8d60ec6bf270a49ef9de7e5c38b83faf9887fa95b8d63978d7d72b1e8b268347583eb46bca96128e79dfe25b6d21b2dea08fe64f70031315b474140b1b304a834933a59a2f73eee0d278c02be95eefe95ea355a8fa84016a4f31fa41aa26ec396187da4b90be783efefe592945684d2e33c5dad6016df45313301b9882e3440c3c25b052d292e2387a4d91549e1fde279315985c9aea6c88d86eb7f194a832402f924f3485deb5161eeabc0a39bba2ba5cb1793fd8bfe126e07499a1bae75854c8606d9cf3e4861b45755b468d2940657a575b87d7d647fc86770158abe4fecd5fa7a13874a04dc27426ca223bdad6471194045949ed58eae9919bf3f6d1cd0a69f7bb0b2a637c53c233f6f1efe062c6f1747f952ba7a3c33610ae9e99b79ab99c518df705ec7d8adc79ad4d62c0e60e5eeb2537cef8b7ecb65e7cbb4cd7cc254b407ee7c54451e09b319cc1ed9f2fd59da38b9b9aad14e680c7d1b81c19f6d8ad06d16725389eb9de2dd5e8e4fee915fe901072a795f6b89c0b15b7b2315b767435804ed0489c7c24d1423466b81fcb0626bb29352e0c59831be4e882601c27442acfe35ed674cd4cb108138fe16c0b25a5dd978fd7a6d75e79ea275efe0c17ae3a018d9f091d1ddd7eb703c3f3fc45f2224090b5ecc48e2ae4538089c57905a05a2677fd556378074a11e290a2768298620c107c6ad163e94ea0fa826024c5cdfecfe558a0c799690049aa7ae5204164d0c6c22807a8b36ae3820dde0bf4cd54ec8fb283968d687f2f09b58d6b24388af7a89959e0da543fbc51e9cf3d4fc89122770e66cf2463cd8525fe591fefdf1217e8869e8c51b70d6fad4404187615e71cb25b560daca0f1cc2db9217cd3225e61ec8ed4bfef627e76e591372d016e32bc0fa215cbef8ea35b3db4b55d5e6b609368d791817493302fdb7d261636c93d0f7cf21396262a5751a466efec6722fc368fdfe7582b0203414ab3eb3a0f4a8a33e0f8b1331c4709541c4c281d4d38fd7fce2fc84644298eeacfecc95ca399c92c56e7d465d2d17cf425e26b5836d02bcabe2468ead28f8c5879221e7e2fce3aa3c82bf7a0b0006fcba458d6708f7b4147795c557b223fd3c82b3880591e335cb9a2a132fb74184e7970bb00199a9ac89bd110260e5d577d90a1a9163b705162bd77a8baf710d83e62ec2f105bb051b22db965efe5d6e6331c8edbd944a9598544395be5da01d1d055de706d8261bd9fef147bc827e6c46151690ec55e355735708bbf34e6009b43bd46f805c8c5a0e8e1e3f570c886c633cb5920cf88e45761c9f3182de9415532c98424edf2650887035cd9b61e6b0d3dc3e5d726ea523b7681a0bd028c04c717ef10094e533f77640a88ad42ca9d74ce63b370cfd7af28de045b4c9da075001b6e5a69ec3bc7ebc80a665782752477b208dea035940de65663168745434518c7f1a59eab9b9a01196de914532eaf23fa9ada6d075bad439ceeb707d44dccc43bb01593840770f9817bc8e360041981ade3da9f4892d0a8ede5fde8d5d01acae3687ee59b945f9f6c5d8d3943a95c273181b22af258cf70451ef40a7a787a9f3daf1fb044d48144d55597ee94dc5018fccce693db9e0619a75d025807d6b91308bdf62c75b21817339805ae5e025ce225a5c77b2b8821b9f4328175d9b04fcbf64e503eef11f32d14cceaefaf60390d37096c1cb5e4dbe1664ac65acf969610ca3c476cc83ebae53265ec738a9acadb312a118ac73a60f6d3304dd29ca5850454e8cb5ccde0f75b0dbfd8aaf4c8f76b9449d7c1ddcdb31cdb8cd1bbd4b2aec8725fbdd537c7baae74eef439551717abc121abf663264cf65a820526c10240e9fca02df04f38d1c0b4bc67338fd627c4476c9563f5dad4fdec34652d6f952f88661bb2cdab035c74dff6c19735bf598fc57c991539dd7443d49d1b1c6f34a57821ec1a825e38df0c353ee8989c993de7f9005e2ad3912a859efd9b33c845fa378f3c0cbe41aab84be6b17a2c0081a90ecd03639083f6bd31726f1a78c31c4a5fcdf63cb65435d26ebdba14cb381173c79265aee8f1ee90dd44bdc8d8528c3e011411c25436b2b5b576f1ad38cb62c9c16db3e2074e073d1a58df623a008d6543fb43501602cd3724283e6c5cdf4172581a58350f6258a85e74107d0eec10539cfe0cc35c8634d06f6c8c8e6fd45a589d1b8cab2fe0d0ccfbb6236941a416245299be90a22fbc370b170556991c48971a2c3ded24ff0e5af8e897181f584e8b19fe67f5d28cffd8092f1475cbd3a91ea3c9fb817686a338c4e7e1abce13a07bf482a49df2cb5906794fb6cc4d1bde471b4a30b5c71cdc1dd1c3e68ee09cc461e7d5efb095c345ef28b4c601f7ee1c30fa91392b34ef376861ab4ce102bbaa5c28aff517c350333e92ff505fe52e8e2257bb953d2e172a0399ef8de2d6dfd13b0663ac5a1bc514ab1112a3cffa49cc5e866879513627e2503aa11b849ac77068a79b310abe0b4bb9395ef8a8300be502a199346f670ec32702710bbbeb664c91a4986c48ac54854d8f3bca70be9826c2adf7ec4c899f77fb3e5048ac217450c28a343eb4bf357cd3d7c7870b257213b0583e566678afcedd2666b5d23c15477ae94236ebdcbf58e9531ba3d063a09c7932f18a5ca066d6a05761efdef1cbc67592d1e5139b75191547f3533ae1338075360b58ad20be4f382dea6d1e3f906dc6d383d8e488f6c6a7ec72b800d2f35e7f76fd32c8f379bcca23094a86ce598109003aac8a3eadf766d13c93684616e8faa4c8a7fba876cb108306b67ba2f7a44f0b4e802d48b064d25e0f85449039f3899ac7e95484430e453b8db7bb87a84be40d68eeb68a60e23f346dd3e1b600fbfeabfbfa5d6e6ca0390d06baf9fea569af9fae2b625beb590fcc274d1e697cb100b7c734eac3c1ed8097cfdb4b9ef620f695650b3ff3a25d6fbcf26e318e348385c918b5e0c223e47c00c9db373a23bfd6479a2f941f2612094bd44b81c3f84ea9d4d3c3f44aa69cd7e3398c4c524884d8b55bf3d757707e70430703317c78d9ca68902080eb00e2651c793dc498c006015934f2f8dc48ee8c0d63a41825a2814fb251393d05177386e180fdd5666d91a70c0f7e893235f543cd3098cd678602dd1841a14d69b57a342b4cef0cef389ba8d2614cb18a9e5c36bbb22b620c528b7ead9c44f899ca19313d37ca8c65ee7243f918cde77268e4f8cc5cbcb602f40ca97b72e694d741cc6e75d8c11a1653aa04fa13ff396233f3901fde5901300feec8089703a5a5f6498f31f55a233b63e8d54e4fb382036935600e09fe6d6cd151ee3f9c53f15d19abba0ab2fe3483225c2dbc562921bb007c024757f18195622020073d06ab3c71f90f0942b445dbc0216d00fa897d86f271c08e009982bfce8ff014717e5578c34143a0ad9736b12490bccaab32386a01f356fbb3dd4e65ae316d7390185e57187c7a3d176c39254d78b86febd4f07302639ba366bd143d71dc06b96acc4bf31aabceaab355ce05471d52361f170a549cdef4ab839477acb17ce011889e6a256ae1f79665ec3332d40931461e1c6683ab5180f991a231f3fe793cb07f560a2bfa6b1d09f5b83891537fb7552e7d5ad766ece9f5bf380e718336ccb5eceec879c173d5899ac673deb7fde19d1a8f908c4ddbde71e8ea792cb0171bfe43b05b3d5b9e06eb6cb3785438f9e0427299f19067d1971b9e3728dfbb14cda06649a7768e0758cfc79bc41d1a2c370e008ce896fb6d616ce0bd679424f524f04bb8cba71231a5c2133e53e9aeb6883cb88dacf2c83d06ea22f7ea21a4d49e205b8b465da97167a68e7a1ff0767a1ee458a7f9207b6f14093b2fb1d0b27cec11666f07a7358ed748c2f72ce31560253bd3a2d2cce171314b9a44e3fe63653744dd317792b988855e34a8045c026e1c05da3292939492231295ed99fe2a1e88310cf2c911c6ee17c1cd7e7d5a797b7330656f766f631c2919fad1c54486a9a18f4de651e887f866f01b8914af8a97f3c9751eec638b4f5050c8c8d319bf5de04d9077178e84163fd6bb23b07b6eac903c4b3fa489da723a4e49aec7daa234eb96ccca84a6737433f6fe4aaddd87bbc90c5f95edfd7755fc7abca55399fa54418e752a9e5cddeb5e6fd32103790b734cff24c1defcdcc1fed74655e179e043532107b05a63b1dd4128bd157e6c2326d90f87ba139383dbc8090ea65a00960712dd18b3f2c727df9ea3d696817aa9e4e2e064a7fea50ad4df550d4131790bd723eb43a6848b64ab34a84ba3443dff934adb4291c73015207cc07f7bd88449ebe7f2420cd2a31db80906093e233b5a11ac71f5c14e82a109b038788788b61229a656c84fc531b407863d3dafe832c8e818c09d141cfd76933622c0877e9f738f4d1b4b905c12b65b11e7ed57379c2d7d4eff156cd177ad5506163859dab69b9568b5614c3ea2575cb44b01081556738da99b82b8ffc60905b9ea7c40e154fa50a2e9b1b10915b501574aa88d00feda8c2f4e9310d429b47cbf3b3d040f150585b4bb05c4adc3291b0795d11fbeb8461165ea6e4283b01a66bf38f769d37b826430ace5e21f665b92fb392b69336b200884c13ac9787b28c8d18e1ad21a58787b9a98a80d7dba0343cb56e5ef8e9ad81d60de796408ac436aed3865c24f9dea7d73b97e1d9b5a3ae07238b575d3dac2c64febe5d6085a1e8ed80977e11a2d274c1075626f66c75d5988be9dceb816c2fa8af0776b59fe9dc1e9585c13aae83e4de12674a29f0322f97d24aec36deee58fae4f1cf336de403dd2e3ebb0377dab391251f2b2e6fba64176f33666bc204ba172b58eb23a224618154db1c77add2a00a7d4a8742a9c614d2fc04e80828bc665cc2d25c49e45f266140e33135460ced660531baf6f579b52e5d58d08d93d19c6896d4500398be86352e254f803aa8daf064d5d4481019196a9b1809ae4cd7a0f21c57b9c3cd93a3efaf2097a052d44ff23d7311780fdbc49d24ccd6750131a5975a3088060187d7c8165d1ce3b4025935443d2142369b93b4686acb0158926de50e429898f805174b7486b9aa29e8e1ee868da08df636345c0a0ad28ff6b321c1e6e293a12b672cacc7ce2505e40d2603c2857638b0a4e82c0b1fc6fcf8a34511110d9f130c8ac36632ca2bdb224be912c9ee216f2175ecf4af2e14a392e012b0fb61d2a995fa8ed4234337fb53d42f141881f31006d9558f97aba014f6e4bc09ae532805fba5e4a03b7e783e8b0e08b43d7df1402c430d34c69bcdae0e799e33980242d47b7955238d840a82944279e176e33b3673eaefe8e36bd020979f896b7aff0ad7620e3958ccadbd164c1ea9e88c6670dda20ab76aeeb84aea535a400746e3b83ead2cdf87af7d8f57229e6d7ca6b6918a359f4542ef00b4b55b121ea26df938c539c82d342ed55aab868c3e17619a02cc1381c5e07b691293097a232a61adb19debf5324296955d9227b15ac3a313fa79b4016e90163e43a85a2ef0b06ec93c49b1ddd4d5649be67dee7db517fbc1211eef7a85e2a430ae0e26453a466ecceea3c329a3c2f2d4e7bdcb8af15f05e1c1d451b636eb4b73c71dec8881b833ae14c57accf2f6bba974a291b8001ba86ffa194e1b94ec5c62e82fb298c5620a080901498e606644f6e7ef2642f7c944dae8d41eaccc3e8c7ddd7cdd203b59c2b80d3e6fe89c8f8ba5e204c8f194ecba56d51452cfb81e893c37be112209c838840995a97276d45fbbaa19cc7be0818e4d6dd1e610015aa8496f523e63854ed7333e1db6191b5b4471af08facfe26900b209709ac3f0b8dba2dff7428edc13ed9b5e83b3f347ed105430406d36403cf1a5854a29918bf8d2888404a997bbc8d1dd9a62de4803ff9c60f37770058fab7c4a44cabc09c324131ff2f9acb05d63d50475977c5dd51d20376161e6af9ddce29c3c42857f8f237da4579b79c62e8fd9e76e98e849a9fd22305eb210b68d394b2e525f5df550eabfd399dbe42d2498352c0f8298aa94428ac99643840c3a49131743f5958d3a880df5a622f1f793a8a2e73e23d0966f002e39ab72a16a9b18fe3206aaedc2bdef92322846638a65849773627be1431e4d1da3090d5e8805b01f4ca2d729d432de3e689a95f7e76b856d26098c5b5809e3c8dbd1b9b164055504c260bf9f1132963608f41679f8a2862b35054772ee9dbf95d0944e2e58525776f2a65eb7db545d47198845416e075e8f2f711d5e0ae19f3f822675d865eda19d8662e1591ebda5add06cd033eb14b71d8b20817b880f405b8ce101b52e8a276253b8c304f61bbc417798c64b478750530b28ae2f6cb8bf2aba3efd2f48941d219b422349200746f78fa4ffaf1d0a0e2e6fdb57cfc14b80e0756ede2fcaf525025b5eb01e9c24c0d4b00094e4dbff159220613c3cf4f46c792e0c8eec915fa97f84370aa3c3e88d82dc8fe6454d1d40639d1ac69e3549a0ccce1d3e5489df22dd9bdcdb3455ca7ef0a73814a913c5a0f540c81ed842116a5219a97db3a4a0474303dad96a7b8f6f43e11075690b293d2704794f71f44fe80b3f6e12f3126b6c13f84f42ff0cba8a239466763fbf6e60dc817e7276cee5c94ba2f28ea438b66a02121d2bd9a1b7519b47190090f3a2f2ed64b9dafe8cc0ae11c20829338b337b6df3430ff88b2d0f673c65570f96d499293f08b28cdace4dff9c69417b1f26de1b99974d3fce1354cd79ea3ff47da231a4e133177547cc53c593816291ce9a07143dea6512eed58f50fa231679716bfc36412f23958abf097fe77246513847e4e7949c27e5ebf4009babc4b021bbeb5becfe9661f114702bc516a3755d2a97f8e1d57deec4bf4e94aa41e8df3d20bb94252ba969c69857b0e472784da5256fd60297f3b8fce046351d6b5c1a7c68caecbfed54a37d5766036acc1dead5f4772efbd8417dd4bd767164d0cdce4c1a57be78ee86b14c83f29ea57b31f67bdd65a760f77f4e65e20657abfab54a4312631e5346fda285d8432c43d88ff5966cf4e5d3c08ca78ad0481e1ba408ec6bcafe1913d99c045d0377eb372008aca05676f37f9ac07fd81ec98ccb670fc8c1e34fe41f7c33198874bb83181b67537e45a5c28c5296305b12a73277a77230ec62099092a73da3200108647eef65c9a418a801cad8e9aff9be705183251e429f37efeea97ccded97666c8847c5aa173e4898c539b62d26619140e6dbc70641d9e445d1aa44af93218405ba2147591d55d3ef06deb203f2af28c311855d209fc89ea47e33dd0318a45f5f91c38c64d2404aa3fc12af0b26788361355618a478103eeec6db5d9f80f7cbf6be689b0a909b13325f68b3017a6007af31f539043adc6dddb19004b8579d71c11be0602d25b133ae94600f06adf320f97b9da7889a91337b407ded54b8ec76e3cc9eb54829abc2f0bfeece56f74b0c01682a33558c4c85f29749463c7a6311d62c198c8c2d130fc2cee5212dbc2c8f2073c9a97db165f3175307ab6b9909246fd3d5fff184c7aff1ae520dde01ce0bfae63bd028eabcb2f6453129295da500e8bf573136ade7f82ce86600cc626db5f7c9d56d6827d8a7ef28b27b2e3b38ed7980bf8b2b4d451475388c6c721561e1b7bcb250478904fb9dade7d2e4ed1cbbc1e4c5536afb94f402f715f2fa239404b1bd1e07054a91fd0d5971892146ac876078c875a415f86c95856dd1c5b48fc6a2cc9ad85d9a1c62db77527ab7bce6878e7ea7d2e5d7632be2af03370bf49bd5a43f2fd0b627c67bcf7b5de4049c62605a7335b6d2af1a074e3af670b3ae0766cac9068f65bbdec84cd5df2ed2f7ed2e35da1d3061dee9db84de085c4b2f8c60f540000c3f0d95d12b5ef65c9da3c26efc1057f5da78fb03bf9e085964da7c84b4c3cf9efd1d36080deafcf45662d5adfecdb7edafb0984eeb8c6987c6cc6271593852daa1d49f5dfc3b18e15b2d233fac877df9be569009e813f43b30baf8c1e7eeb368c5dcee90d0e05394219cfaf0bed5715775c9b76a47ea1331587aa78398ca1a47977a51f7fd54926d3fc704742740796eb25476d62677573424f8a52d6f360d9dd266b180037b24c29e9f0bcdfbad3e7ebd9742a0e6168e5bcae7883e3adef82f4bb39af4e0c744f45bcd55674919e6cd35a77e273431bd52dfca6d367b9e4e273c0fd0dd8762eebce8a4bebe27ce9155b95e815905c39b64ae811dbc376f6eade54d846eb92b5f27d0cb7fe257ae241a1ea06f8ea7839dd9eb837e0bba780ae801c3c6521bfdf3fc5141b899cb885ec7aed66f6c80bd4a6b0c8e41a7b6bd92411e17c10ba32ed9662ded8027041aec79e375f1180674f962b6ea9879ae8a7e2eedda02693fcc443b0cfc8cfda1fbfa4c664dce1cbd5e084d4e585e2cb653655c345ea239e0d59eb220914047d5a0a8db053162d6b39c4590908482b44dd6d9a59a4b8b406a177ab6951cc4622285b12dbef0f7c5f1075f6d0cc640eac40e2fab0390eebe7925790ef5781bcd28b3619c315b2b23a267d30f2da9195e9ae6447d0eb6363a40cb3afbb6f0557fcfaf93eddcb00323c0719f97ca629c59a80e9f1e68dfd38e8232351b89ecd69c6bbc41047a6e96bfdeae0084ba5c3e8e0c72358f1b1f556dcd741a996d8eb2d065300cd5c279397fd3200bc0d968fbfc14ed9dc260f9931c18c53518d711fd2a267e3b6639f903a348bdaf5466d5b2e9133f686e7f8e64f7d9cefe2f1061d19fbd934284ecb0232fd0867d7c1bec885a7b581f8aa6897dad3b908ad3fd562afdfc5b75e1065fa24b708ac4e4a360e5351ef76309a1b0782700a4e06887a51cdb40a89dcf49269b16718cfa911c492a466ae8d58b2227c92e4b1e66e41712c66fd4cc222bf7d9bb50b8e49834311292b356d19e4810214ae1fd255eb29a5ff8fe09125fa732baa3c51b0a09e82cd64fa8eceaa61b92a293d278d790bb321a784cf9e5f10b461ba22a92df64ba16e0d419b142756e298b8506a058c22a4e9e115a357059373f98b14a9f8b7c93c0afeec14fde74d27ed3ce7072379ceac617f6ba190d1ba701be5077fdd71f18045fd416f344e450b23dc6e4462b206838d3d3d8544e8b0b333fab7117a794cac80421138903b6f41d33c94cf53bce3a8b9aa663d9a2cb441483243bc8713ecac0679657bef0af92d373298c34d32afd729a1079fb1dfcc13792256b6914ab1f7623927e4b9a35c5ced1972934cdacadbefbfcc2852369dad929763e4462f11f2772d9c3bb23219c5db856e19a466c55cd8b7fefe36092f29b960c119dff12260ccca7d93e96e78e7883190313c5091b017986fe2d682a696f68735c9cec5adb67b54c8c1f89157dc7e843e657dfec86ba51adb8b670505ed126df3f28cc825964c27c9c42cfb07da6bde75e8e5b37901e503658fa498958cf571a917cb7d60a8bd52a45ade3a27f257372c9dae08a11781375ccb7b297d841d491ecaa485ae1eb62ff19da96d1630ba31a2d4bf47fadc5ffd1c21b5e7299e2e802e18534d77033457d049d01cf82632937ec760308f8b18803e987627e293631061a1b5d39a56b21f884901bcdeb4f6d85d028e55318fbf68207e259c1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
