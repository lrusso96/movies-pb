<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5a99f994c506334b16005e6c60815fc254cc48115b6f9aa6127f8523880e4f9e7a446d06b23422d86ca69ec4d8e4074b24f37affd2c2a993ee019f0a69a9e56e4f70532c70bc2aced67e23996b21f7d3797655e03e6c65c0ba69e05eb47a016ec7b5084244c6b013ad639c9ce0ca051f0a24f116c4edb8a935dee42611ca5692e131eee9691b3f858cec34cbe8a056b860dd88aca40e2555a711d6c3ded37b6d61f423b36cd07a96000d4ba80b686087ed44f054091fb37917fd7aaf23648f6d01d82d63ce141e09e93c9eff5eef822a9993a93e6d765120f0393288b277a4fbf2a8521993d97e080ee43cf43a22bbaa97bd54377494993ead6c0a324c0145f54337edd5504c6d0cee5293ed6b2ee5135791ef7e9dd4d4d04c1c31a4d5827e93af74cd41ce42bfc54dc4cdf61cbfaff66b917b60b68ed69fcb51020a574ca84e96c2a5af4c30c2209522fc3e64e6317e3f4f77dc48ebcf3d358abf6722680a81f0c94338559036ff72b018848e9fda851776791e479eec3cdf3583b7b27946353fde4fe054d741503a1506e40890fd3fac8f5219679e65f29892b8b624c8a0906624da67d519468c46a63cbd73a36ded3d3d156c5b19a3ffe73d7878c690920d21dcb3209a12200d888a91e5998f1b3ffcdfe223073d94c7ca547c5b4115d65c1917914b6dd69c972adb9af3b37e523e2290e0110d5f6cdd4bd4343667507d30bf3baa97cc9370c396e192e68f75aad2cdc117aecc6073c1a27c1338a3b10731c05efdd34ea0675a6e14842ed861d7fe17dc309648f1a7a4624707fb1833256f2366927ff500357925a39a6fc67ff54186bb8ad3beee382645a3ad719479ff175e4d233b253d95dcb370023fa336598ae9f2f889b47d559b7b69736a96b8e6e57a1e71531c930920e1061fc5fa7ec894eb9888b779eeed2c5f35fe909df1c13c0448e9aa81323b0a665382656733e2a00d8a2ed25aec7010590e9afee0ee731d5556075c92eaf16f1ee176b3c505973ebc83d50c493b87f01f798dabc0fdeb7cbf8bc84622804d856a7ea06ef7a5c9077f6eb1a4e8afcdee5ecde609b50a20d7c8ebc0e7e4a1304d61dfb4d1d45f6960c59a7787a5bcabb6f3a0282b0b482533abaf05a285f81927ccfe66912691e7027c05958148c8f93e633c6931cf5cc6ba8f337334c108d9dbba11a11be232cc25efdba5b82f5a3f08fc6ce83561a4646f1b6809793b6016212d7a2140c4ae8a7fc5192de584924da8abbc679dfb55a49932d8b814aa1a9cbf6ed5e2c3d13b3bdc79df2c2758abba4e76faca4d2b5642af6ad726fa0c457a0ea40dcda54acd2d2f27f0f5ab9b2676e39b29c5af5ec9dfaac83002c3e9d31faa8fab60ec28db3e41d931cc0df6df97086a48d81049cbcc058745abf7128bd4d5e8fda44d6acce8232fe70801399da96b69636db467e7851023bb35db2f353b0a320e90ae83cf481876a3aa2aef58d0497ad4df45d3e520d71d2bcbb6b19e2ec9fc0b55c76d8612861995286d62ae38f5a1c62641c600146ed04a7607c7cb53b66d23e06d7e038540a8d2b4b35c04a0abbbc5ac7470617474897a7aeea4485c6a9b6083cc6b18128eecfdac5b286f1a1974b952ee80f2f960dfc3a64570e7b15eadb3ea7fc431606ae43e1b2691be6767fe51f787a2d54ec986b60460b64cc28dc44bbf7317e5a650928ee18c83e9fc9bbbb2aa3dcf3002db18a453aac2bd8e1f5a807f231f3d6e1f2467b0fde12c74bec54639f8bfc5696aa3d48b7bc5fbfb61ad69f596ccd91d9aaa5077ac70bd6e8a8806d67ab3c915b221c19e8bc4dc2e697871c118ad22f101a85920008589e68e90d8f89b4baf389163ab466048a233718309117919d4f8e236a9ec0aadb6b01f9b6377456fe44945ad33e092ed4585caa2e9ab0b6135f641cb88f3916a1f2e50a0a2bf5ba881c48d0f9242cce820240d8ae8d7d7d97f2b89a1e1f57eda0d0b6d40a10fe4d86920a9aaf9c93efbf79b4e16aa4e92cbd05fb04c8d7445988a8c16f61055993f15772f9ce3579c53b37bd17229f0409102c7da4cb59c200d1ad63c232c366f530e2e2660be7271fe9bc74e07516403494106f356380a60261096af034670d15c7887458b19d6df947ad68ac56b6c886c8a93e9766fb26cef648087a2f34898aba50f297ebf52ddd3e9a5e9318d373a27f43992343fc134ba7643f4c8997d7dcea89fa26b1dda730c1c87b3cb956858f8073dfc99bee29eeaeb8fb98562514f17d5050e24d0da4945241bdbd5409bf99164a20eea4afbfaac60295e40810a211980435ca56520cf60c8cd74d555cd49b9ddd146558dcf38732f30c574b9169deb29388022dfa48b3e42dc0542ed370b62cb66ced5af4dc40dbab3aa822131b07aaf55b24f56d7b20e973228eb32e276984f16c347d8e0979797028a7290f1ef4b2019a9bcd724b8dcc72f1d78fceeeb53d4380c3a40e45e4441f9f0e7179e147352ff852b9698b6d0e43694b22d2c32c941ab765eb9baf2ed90b001a8d6d347e33152610489560405c9353595b05429f9a216b93a09c770b3d4df65d25b22fa7bba1a9a2b296d20164b8a8e7f86be4a12c1e2d52fa8976d84a136d98b353ada5ded7066e25f00f331cff87f96db53bd695ca4b759c9caa1f7c1d7e6ff8531fa04e65084591e1c579a1b886b99596894af34d926a51467a6d00fec312348c386ee371aedad3bf79c66d86c53b8c500c32b310a913c70168be478e3399c9e6a88283d7fffa240d9576104c693065a2d4fe7636b68323401745be1f6af47e536cf9f0e4c9026d610e960a558bd716b69d228948d351ce1e987e25b5499cee0bdefebf12e0977fee34176890b52e2b83c7c70ed1108faec33b1f96bebd3cf4630118c65c377afeabdc79b1e49463cc806c3c568149c9cba44dc79f262dd649fbf840f01c3dafb1b8c157bac3f845dee5f3219e964fcf4743ae409cece4fddbd5766bf3083f87ba15a59144aad9eded414b92889e076c7c0aca434036a87c623765038930357e0fe10fbde43236a7d5131d0bb0032717e445a504ed8f84fc1807137bb844386dde784abbe523a20d256732b037a0091bdcf822717658f763722c100b24ce8609dbb6c98cbb6ee2d2e88b0cf1b30111c0043fd7b42255902de0a544aa505a7e93c1c50a9883f6013feaa2d7b9c6b960f13ff4d672c2497277f9078fc8871f96dd9acabcd53adb708f61ca7ed98e9c9e8c7d52709100eb3ad2ba558d8ea51be00d94296129c148442555bf8fe6d84eab6423412ffe43c216362ca32645020b533de0d9cff7269e9f0d25931ed9bad8a4569b63b7f93c4e7fef7afc7b21b21e63a608efcb4a35bf0de70279908d6b87721e840646ece63893f8f72c63f81e4f8766be0a6d4925d2d0f1f3c90053a6a96ab082271ad67fa72090351f871f52f8fcdb2a034df0c5864562f418f8f8274ed232ce804554abfa8bb1019037d3b379aa94c3e2a8f128519512f1c197bb062f185f0365b2a3864eb31fac1583c24d94d54a4aac4c020c11f43486ba12b9f79b642871a579fdaf7bb5d03812eea8461c0411a2ab1f442ba2d0e7581fc8129ea4a6d78dce5e04af3450476e90b75f25a325872589a69bc8a00f88febb31a135da30e8e95f2d1a4b99ef144d75c36a9bf695f81f25f7cdc0f788dff7c811435ef91f54b14ab5cf82453cb2815ac5a6ce58a93d503f6229e84ad9b94c2c11271018383968aa6c98747583b15286714acf83f376b0be7a7ea91f28382025fbf704621aac1fe898f660815d16726179173846ec49e8eb05bf783ee3aa29d96ee8850aaf838d370323de8d20ae202ce83957000b6e30e9d1a2b55eeb0cd46fe78d3d27aba190b11e46aa4beef3a9202a7adfdb891d20370276fc7d0ba7744bff06289f939ce8eaf8c791a33d9ea2d8df8672d4f8323b064b965b948468a25109c2dd9447403623f59a6bed3b3ad494f4052560e3e24c758c702b4a7020547c66aa23d74b174e89be3e89945c4c61ee34e4dabdd28566bb852a2f211bb15506912e7097e59095e5f9aa49aa36b087c75d21a08157feccb54b08920bed83dd3b9c1e92c4627672d8c6263533c588e3ff8c1806a45087d9ac5887f819ec962fdea45da330e6b6ab85154f8a9603afd1551564a26cc7a575ffbb5f2df9482f0b0c0bc10cf561ca4b9a7db396daa577ef49d1fcd6adc1f7a914a77f21d78f3b28acac7ad6d2dfca876fc6a4bffccace8f95892bc4da9bb10f3ef9a25d092dd01fe3ff6b225253845d2accfa2c155479fe12bf137297f0adc2c84e9a989a1dedcfb524e79fc76a2ff312cdcdf0647c99cac39fa8b8a13ae3bc0765d65a5220a41971f927f25ff866ccc29a2a67ca7b2055dbcd59e4772788ab3b0cf48e6b3239dfe3c6c67c6184fcd744c6311a00fe7f7a03ff41c1a67e34edff8e9d086365582337fcebd480b96c9ff3af416e9c141baaefcdaf90c75183e4bd27c76783933731a795b657adc38de9f8aa12f4527cd28044034f99d4d5f00703fd2b76499a20e16b21a636b1a280901e3acaa4e23aee5b8730b5ea336d14aec6c320273b70325a16136ebf5cf0cb5cd7881d4fc162b25e7f13fb7da00d2f7cf1387837e7d4cb02528ecff2ce92f30527e103b23e5ae36c2654688b530eafc59e1e3652fd60876ab8733f42b9b939898156abf2c5172ac5307d84fc3677562a354d5045fc64f30cce3b2e86edc35b2905b046545b00446058c606a2348d372335c6654dd35807e912c0c09c97818f4192a5e97ebf709c3db5e1bace97f06a94f5cbbba6c052433ff8c56edb3048623c5cc0671f0b9bc27350d14bb2cc4d7700cf0a5bcb41249d4336f1356d14573cc4998b16c8b3cc62ecc1322bbeb6c8fa05c6618cb16239f4d24681af8903e766621bb2b6a03bdcf2d8f9ff354253a9340da024c82610fe2ff2a0b76822e32160825965b0ecdcc654d6947240a91585265629fe83e47b7d8ebb10c553a0b8dc92331c7a5abf48a3f97fe5430f5eae5d571cad7c06f84caed205904fe774cee29e0cf47a79d1221cabc7627a378e103e3183985fbb2c047f869f1a349db1eab54c4d443df971bb4cffe622df7e06e4517359ed80e21329ee1ad99a8d3e8af55f156e72d5d68ce9b586dee737e4e868667c4b651f6db10359e80da0e670b5d0a2dac1cb5014a9e76368d5817071788da3c810eb6a5d5134d37239599432e465b1f4c9e4359131987e4f5d8d2bd231bcdbb3b791d58279fa187c25227e0d6a342717fbbc8b51df4e7de2549b2ce6b35d6bf746cc2b61e591b42230d56893b2ef9626071b1866bcd7fd5dcf481aa7a15a50fed0576b8695cee2e4bb0704adfb810a773fcdd485743727c24b1aaaedd437269dcf915e1857bf7e32e8c529211f1172f79208e2b770c7e014683e38c245d83e4f22bd0a09ad84c38a41fd71973c62f98338bcdab1b37a29f48ab9149e828f2430394da72d68bbfad07454481e45a7b6081ef59011aa770b49231565b18bb3e30f3e836d83858b07382a65435227e6a1f012fa3142713d4d1edfb0ecc04c42cdfaf5b72ffaf009dff2567e2fb3a4ae5996344ad05df1495255f6a16c699fb83d70a7f1ea721a7bbacc466df1f1ef01c9e650d054e1be24a5af8ae1539677c670c3633b73d38571c3ce48ba5e27be9e8cb1db5a9175a10763c37581b93a059c98a450c20f50dd9955ddd7c9a8159974e101f59ed4d5847a986a62bee1b83575a9e8d71d69d7399db4775a5d98cb0b99a8f3f1800f5768e21f7db115f94173dee892f42af5abf00e57cc19eb80731a7b85f201ff852a539a7dd82aea0ed35f1c3c0bcafff8957235e7c440a9e708fa847519844b425e568273bfdb45ad7058f0b7a7a1864fa84c349a346fcd51eef5ed78d99d904e4a8b4575ec547352a3844d23da19a9d01c364383c162520c36e6918f770184336ff36d9d90990dcc16c21b904fc75ea8184827fb4f810052e5f1129b2b3a9fb973e09c844b4a8466c11d0982b2398a7ff12ba16b80831f275f757be0ed2c241a4ae80994b4e757d6fde05f0bae242d28afc74c3953bd082515208d3b82583f614f43f37dd0ea391de6edf5b6be4464fd24190e446b5decbd5d4e82ca4da37d1f9a5246d6f3581a6e76574de9e61848afbe44a7314494828b9c1919bda97cb7eb662090a8c6403b74e4c1d38dc2bfc90af02c281270df1955455821acbce11846af989b6e4177c78a2408273cb5e955c965f80e54fa3b7d8bd09cedaa8cb92239a10363361b6370b45cb245c81c8f925312368fd8a3d365e98a13635cfd0937598f82f1dee8faef2b168b6a65e819183603d1c2adda90f52e2467585f2598de6ecd0001c84e4067485a9067f19b76ff468f3e75fdf597791af6195ff7ba756ab25de2aed63bc204b3cf20e4c565e0b54ce3f56aee64e348351014bddf68e2f7cae8f5728d9d23f3921526c16e6bda51690e02da56f4d2e5e30c09eba92df5a8ab427e2efaf2bdb4342660da4edc8a7ee59344f393a3154bf4b0a766abbf386211ca79fc8dc88b5aec080f99becb8e0220155aa47fa2aa0258fe57840c0e8fbe16c878ede43cd191995eb709d330dcf1b7394a3b1a32fa09d3d126e2bbbf29901395ed445035df9897e7ba17019d4e07246381d5c3b1e5931f08c77b33e1d8a829c0c6c6c02328fc746f158fa4fa770aee854d397a9ac4c839d53e5cd62765c1fa95baf8c9a9e9cff895d04e05ac72c1b1a3fe267f4f99ff45ff0b78ab8194fce8256c38605f334878d08f3633dcc2b03ffdc65fb3892221dd0f0dfaa58fa026518b5a2a62ae10afb9a2b70a002e7d45eb98adc9d82a89e64c55aa663c108ab838f05b0528af5b85f5ecf04f9ca0ca4a8e7a9044184e8cbc9735d01b268b5ad0379290b9898a845fd0d4d924c6c89a93cdbbe48b27bec060317c60f4f60de22d7825b3e7d7a8eac20a3bf5021cbea0b933ba5aa68c954f4891bfdceb1bbeae6b3378837d1d62135ef8de234323428442162bd1696c232c971502d0cbfca321c8387450caab8ded95d7b6b7db1057a7a758565d94acca26d326945c0abecd2787702a8d25ce7e5a7d0188fb3bf99d0636076262fb5aa5fc5c596fb66b3d5bef04ef94fd0d88f743955044a4796cdcd8d5b21189a47c4c7a83a1c556cebf9d774c154f1dce4d2492ba5803af4982167252d265ae7b2654c7dd57d394b157cd6a47b64613624b2583ce50e0f832914af76f50a44e1992d94563ca8167b7f6872d40e07a6424c7ec7ce0b4ff8d93f0ca39ea8b8958c24d5f44e03bfb43d6a69481503a1348d15846480c2bed9be2732ac04e975ec53a8bca6fb8e21cd976b47675d35bba39f004524973adf23cbddff756aafd43e1000b86149051a2a6f112309f0e5805cbb975d21fe631b37100754e6005bcde10fdb7d1b0f074336943d60ce8e152dd918ab49583c0fd428fd8bf990dd027bf5f07147289f1a41d934a0d6d3250af4e052db921e4ca688fb86889014455cb1d76b1c13e852ccaadc328a37965f9c3ff7a751c9d6cd19972efebac8b74bbabda9473043d7fa1c974732112a45be9a0347f4837ab20c6e1aa3425f2a9af2093edf45e53532423c97c9024e3d8fc0955051f2b3229342ed811ee460bd4d3b085abf03f9638283a515416bcd5368984923ebf4df0006ba5e8b27f7702979167ef2f5be26f69dca0561d303b7a479eb316f0dc7300b37594799c47a80c90670122b1d927cf8c9c81842f658b94bba95f8f083696ddbdd6b3e7532397458ccaace86f06019d4b3b0a6c19f0ac22ff2371bb5a3bfd82243ef7ba84d031f7b9191149d4637cd857250e5847cca82b776fc5916d81a216b7f5d3f15b77da2d90e600b3a5d90926cb505b587be07964f4dd2a3f0037d7e7702616dff39ea9f487d53a9eca7cf7eeba52311334ddd266cadddc4d3dd2e124f894d4942bb0fac96ffae5310b0e2ea7af22a2a39491ed384db36ec03f5154dc5a3e4f670533875b65f2f2b0542cba2609cf0861ff6581e86c2c9a923f728ff490001df38cb5461304ed8715be0f247ce2fa8e54f3cc99a9840434f4d148a37162a40b3f7c36647f74314500c80614beb78546a25f0ecee6e40ccfa15329da7ab647f9ff5262c45dac57458b02baa28d23eba9708f60e02a17bd6637708e2ddbefab87dd9b7940e94fbe79481fe18d61e3b71a01b16d404d224c845b4517ad867ae9b81e5f3cbabb4fcd364024e2eed6848a5674476de0b15449eb2c8609499e75ac65a7d35897ddd8a5fbdd1b4b4cd6024065d465a0190d3e0cc5bbe6048d19a6ff03c500ca39fcdb92027424e1d84ba4b38858df7f7d1a65e25f13f754aebd378f49a37f99c5315ffa1397cdd8ab653515f9073c1a27b6a26ef835fd865d8649cbfde8218948ade41e7b9df156ac35c757bf335fa220d03d8a1a309a87f133b3bb386d710b900aed8e58ff28e5d6d704bc89f5eb4d84122063726cf96eaddf14771ccd6d34693d7284d754a25d1d985e3efc1a53c30bf55327f7b0a27a45317515e00a91dc922f87b29224b866897c0543924718c384c05790f2476fff6e9c117bad6ec684f811092515123d4d465086b2f9733af4038802a0ee20c1ff90e05c48977b7b4113918b5857de904a3cd63c84e8b6460be32f51ce46439a5ae30916d996b47b9246c4ff02bc649749016bc4b4800f3f8989a3f9a69cedd54c867e62c60ecd9e21dd2cebf136ac4e25d7ea2f63959bcde83fd67f4eb513734d5e921c8e342daf49dc4ec2a1bb400d0f67601f55b67f6e55e68a705daa799f66e5a4ca8d80d754d2fad038dafdc80a542f8e6b4286d0fa329e4c8b1e1e088d4676223a6821910bb101f057aa813e256ba121c917ef581c96e9eaa9c93133b69ec694b2f79987a4a767281b72bd1658ce2b87cd67d4a50a03553a25f96cf018b30b8bffe3932799ff594a599abfd8c3d4ad066a78c3714d5797e82ad07044f4995118afed41869d7ce4ac150f9cc52e22f6f0b5ffafe28369eea3ffa7ca763238df26d01967e483f8da8ac4f19343840133d2b364652de05cfef9a603307b3cfe0b289dbb4345ed2dc51b75c05d6830fdc33170a1361fee3b424a1344beeddfe27cae6401522b9a9a7270f7d2c96ffdbe8e854e7e6a1936c08ca1c9f120f4ff4251fc6e453921dc8886dfdfce99a08e4625d807fe999ff8ffa4515bbef0e28f3d3aa23c7027e429818e78caac6ea91d69f0afe462e70cd4ca267973822a2538879f64681d711d522d681ff9a66861df41f801b0a653f06eb2795eed9404bc51f0c5662c6a704d01889f9dd2d8114d182d617dda079b144d2a4e9fd9d9f78f5ffc8e59055d5eeb8e57c49ae3f3d3f61e8e48eb5cd0f284d049c6a887ea618bf3b6749e413920ea26fe54be8a6042ded4ce72babcc0e72c98617de07180da7049eeb1ee75bbced5256729f833210763ca771a454b2386f205d608fd3e0eb7cb3185f371faef3363ce18d784408facb368f9c61018ecf6192b241e6f06e2301135e326d7050493cb146ed54870293773e7208df173e10064ce947503653511749614a47c5df19874087b6849ad9b0e29fc6a41b6ff62083e7a0af900b301e3b6cbdc063e6e664c9e0d8106e27f84200bd44dbf4815dbb84a16c685c60254610afb2515d8f0354e2337034cb3e24478580db62a723103d2ba279a40e529037128de7bf393e09a2f37260b8a9055fb1c7896de82bfe8bdcbbbd606f87c63a3393d19089368166da305bc365ab68e9a57c31a1251a9208c5231f819fd90fdeba0ee4e1316e2029cf808370a05a764d3e3fd00350be30cc79fa00ca294f6df7f33fc38308cf1a16b1b71b8fda1f9f453129bee463c0e8f0d9ba4b71a64fd794ce985d8a7e58b59e016d392e1c524e511408e9194e9098fde8743e3d8d0f217369efb376ce8ae887194e001c119e9daaa522aec9cba5f94831d82e3ac3454d89d5a0422f55d27fe020070cf0194e559aebd2592a22b9181cdb80099dc1c49aee46ade6592f94c9f1a1adb2faecf5628cab17547f3d22fb236813d477564dd3e63978a2c77fe7aa36142b1c6b80a989a1c15b7784aefd1667b1da59000b18ef7fe4ee0a1e7a7894acd23c32afc5acfcaeece3e45008581110a555ed98409e027ebcd2a5f7498d09c3b1f62aa6d2920a5e396baa8609673baf61703ac298eecdbd6f5ba30292732d7b5cab20169ef3495955c0952c9c4e90e93192aadebe4e7d26449b0cc46baeefed03c40b76dbfdf973cd9f36135bca8fb31ae3346361be84e07a10f2e56848f12b9077523313eb7d55923cf704d74483c3c9376e2a0b1a828a01b3f37c55f1b82077cdfa34e9c3b823e45a45811c9a0492f144aa187bf7d8d458f0cfb53b6f14f3365e6a602f9dc84c88e184b7e910338b9068d6ae523cd444834505da8aa64182353ed43b35bffe864fb341ce61ef9aa5e93e2f8f0a0811b3295b8d6ed55a7caff8ec3e66dfd3b98e85af3ed11881ae01a22b3c57c311c6a2c36d7d3fc31bd6d3c6320e4af75499952701d2633d69226982c1c80dc8eaf2920ce7704964c84a253ea11056a81c225baaeb8959401be5dc4b04913a00c8a352d8c5fffb0482f2731acfd050dc9b54436b25022cc7540a9fd8187772de4691ab1a87975e54d16e96e025d73e462980bc296127177a0c1f51d76ae11abaf26c316a3ee2a28ce8ed45a7f4750afda40a10fb07ab4f34f85019e19905978780038079f77f0e1a7f120c4f400f2519536c30d4fbdcb4534a1619c13c76a24b7d15c842e53fa231f37087a80490e28389e25363c111d36a7e4336d2a12371390a85071cab53c2f04c426d9008402c8fd66bf0e5344f4e35862c1348e14c39578fe4ad843b081debc8631601d9a6f908c92f1f7032958f6fca18aa36c98745cd4ec5ffae61347e895d1f47b0cccbcfb19ebc19d1cbb78eb29e0bba3edfdfaea226523792855a4bee5c7b70fcb159b6aeec1c088fe128a5cc5f03617b5c3b8b6b54c828f97e3525ba8bb8b63606a033ddd06fc7eb71b8c66ce7edd34a260e6fb4350c9cec6820fdfad03b5f48a2ed0c61a4d65eb6af8c259c580fae47010a6b1a1dee94cbf06c3750d61acaa0d73cf2badf9bb672fb820fd600ccc481a541a38f69b5cf7d766b4a58b3ae6f544db3729f994b34036ce1161d8ff7356146f2dcc1a3a93d37169c59dbb0d66a6d0457c9367c59e9bdee8f445384742ec479ade5ff33e9660db2e87d79b31c915f6ece55b1373f7ef05c833342fb5b7daafc6d91f4276785eeaa1e18aab665acd111a20c706f987d7c3ca91f05c9d971b2b3ee4ed1e6c71d988a3b3829a6a3c34c4beda19de0bc789edb9968ae4ecf10feb183fcff299ecd82cf917863280afcd9776836ef11a816a26b8dc61f3d7748676cb3a537a2a5571b8b5f2d03f69c03348829c3088e48d743321e0d738947841b1291d180475ee51d2495d64a334884114c6eadd7f745a02fd31fd1d5f3df39f3145200d9b8d9062ea354eca78a6251e98512858df9a9cb7d56bec8d5d12fb5a6208f7d35110e77a84aca97fc1369d9755c0b6b5932ba2f079e43e3c0fa3ed7efb3b2957114ab31ee688fb3d3a323c25b7f956bb51f687b7d613d4251638acccb2f3f098e901ef03881207f002ba6e12951dc1569083a97706c3532d61e1958e8b92da62e659ee40ec57ca56714416ea33c1778c2b63927fd591ecfb380eb436da7ae2f7d5864af436585f81ab990806b4488a09ff47fa8361f46c4239a80d066f161252be42834641d0461623f482def36a581145dd1ebc84ede5fc7285175d90dfb2e6862bf9426f43dadc08b46d7fc18c14142cba858b99a5336750a3227065fbb331e7cb84b06990b9cc2de2bc4556c6a03a5fe7575aa27f7dcfa4cddb05acf65100227f26fce35a262f1c6d481f60d41a95e46a8d36e6cefc11269bf3009cd40c6b6e4291a2d4b9cd0c5680bd95b1ddec55b591a5b424149fc7d2068d130008365618aaa9121d9fd67c584c3da465394a02a46a506eaa07b02a0b774f6424d48215a82cee59e68bd27b9ae743e10a814b9efd3d61b25d91faf7a4fd0a27d9280a48b4475421292e20676a912c95fa74de793a443a0a12684961f8dcc472f4e262aa732911b5870e3490cdd39b95aeb6e51d370f5dd4d606745bbe83e1a6edba412ee3fec23fbfced8e368b8529046d6c4569982420c77cd483996d7ea14ac817c51bbcd7b28f796bc1df76ce517a2188378e412377eaf49301015254ba43e5189b111cc9e8e97bcd159622273c96fc34c16d31f46241f3517866c1d3a36155f7e5d6cb80e62fe9d40ffa73eeea1bd8e8e92d6947094c453c93c9d73690586928dc4a26ca3e01936ac21062fc7e03867fefbb31b29e9898c07cde3a22e68c4e0ba17611a134e8972c46e59fe03476604682627a0156e008c93621df51733dda32cf8e68134f19508d689955d43281709d7b853f011dad17fc712a0e0e256017b40d6eda6d5019e5992f41fc94c5ffb56f85a52d9e2e08607fb601c2535c414bf4aa541a82643c69e71f65f521a621967365a560ee444c92e4207f27e9380117781778827b6c5cdb4459cd4df6525ea5d8f514b8e37fd93ea8a67c06c885a9d4d0ddf1df8b881f36274cab1aad9f8478a74a38c34009dc5d52b032c6fd9da8983180c5313e07ea26c843845a553805b429ebe4f6f3997e6aaebcbdad123896232440aac809a7d895af682aac783ae5ca7674feb8ceb9d3b9d3aa15cbd4d128324bcccbdb1c8b637bbaa48a857593786e46ce303adfdf92cb38ebce11f4ad4a5adcd9fa083f0ca2878565b5b053bcfe7f9dd4f725e92df9face2ee5af5968c1b205eb02116d1c2b60909a9936f740ae3f8c55bfc3e3e281d75a56a747d2c1f451a6404fd8ba509d36d9eb959d34de3eeaebc4f036fd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
