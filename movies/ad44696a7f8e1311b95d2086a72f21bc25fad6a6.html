<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2e802d83fc6d3bb80fa1471926de99c36683978e36cad02e067189d114a0aa51cde4fa1ea28ba1315ad6e8b274d56e70fbb2a11049fa83e7b2f22d16e5aa62c297084a82de3420814c8e57071db3c6abf8a780e52c1fd95a7381193e0ae757892d63770352ac009d0f134ef8607e8bc8c4457fda04751839126daeb705a32b49eba5a46b53fbed6586c8959661a79c18c4ab3daeffde8a38a8b1eded359439848436261ceb08f29d91f32e466637c55767bb4f2b0bd68f670e8a624dff4c082881c83c897cc626eabd41b0e756d098df6ffbcf190147e92a317722eeb032bbf6513d63832278aa2f5b0235bb4554f6bbc4817356657cfddc011ca240bb3f589a4e5e1d3ea0838148c9ace98f8272f7b8c45c492789e1300b18a5849fdb4d645ea2cdd24234da9b4126e775c2ce52376cd78fc1a4f4e84001812138fcc3895e8d7fd1b26463a6e520fd3e6f48b4e09bf86d214b3f9246c0e12533ef5af01e07044d6d0eec6f5a114c74e1393b02913c8007fb0a9a7fa0491faec8cdb3359335b6969596c9abbf8b79417db9b463aa43e051d796599d97567cd86cbe63f8f1da949d3848b031180ed76fdfbad2b398df9b79143461b9464c51718060de04ac46f0ffd6bc7e1abcf8d6506dcd7aeee1cc417d7e35571d560af5ce600964bebc724bd1435b0bae5993b3515392c6dd52e8f3461c2c31e2e5624aa09096a2b2186439438a4de9bd9cbe4e2c1c68789058c2f3fd4ba094f0f1c820eb560ba45eaa4fdc16c532f7c91644365d4cffa35be1133b7b85fcccf5d69e386d33040612c4d1d55eed5d4121df89770b4c2c7430a7e3ddbe30752dffd0e00b5bc79ffe15827fd8f0ec4ff6711ab403b9c6e50b287fef6e014612dc8c6ab447db6764a8380312de1612cc67644cef1e45d45a6e6dacf4372a333a571adddbbd6709b2eac5f4a1ef99701140cf9f72867ae943454276b325a3daba6c56e1c7f1d6424b07e313ee0b66b064ddca2a206ce1207e72e35bf5c887bfe68f07723377821470d35eb5b9074ceb39a9cadcf90de788d3a714b9cb2e7beab51ec61ee05c94c6252ff0083d8766f6ed96d8f41768ac3aac6fa76d158d4c20edae957296d1a8de6252590dcd5144e527d919b077224dda4be38e0f6070cf9479d191292ad7d3f300e8cea54abb8136240db06d1005196192aab1af2cc718c1af6f8b7c53e113d94889f7a4a6d1a132847435fc8920baac16bc196e27326d58b0d1d58d614bd92f5573bfef3ce82a350e7167796af7f291268f2aa8ff01d8e485d9dc5d9eb3a2be83af29ff4ecfcb3309e092b2f9262ca484eaf0246d726699f83cc7edf831b0c214c45319ff1b7422b48548bfe5a1f0b32398dca39777e99753b7ccd609e6bb5f58a8e7c13978d5bfa628169da154edac5a13f737a901e95a961ebeffa9f3aa0d4d164d98f96b559b2522e22e62c4b6215e3a60dd0416c37b9f445f72a17a7c4812ca62524a295a352a4c0660cb169db0444bdf1fb7d1d81a0580164b9e7f78483b87c65f9725eeb79e805e3f29b1662b36d436979cbd04ac96bb3d8654d9eb8fbac044ab9a474e1d81ed970bec22750d87deeaf8b40f17198cce8d80070a01480c08fbf321bdd0ef52af9d0c4cd9a85f3bf17deb5a979856b1738aebaae02ab7e1f809f395d1d3546ef79dd17da3c25ef3ad88a8bc38e6e36898fb8ed5061fd4788eafdde35e652f406f4726aac313b891eb670e28164713a4928aa15fc163f6d9aa57b2dcfbe9442b85c6a1064a159fa3ccc72aca638466e45b5a141894947ac348ea21f57d8facdf3b41a978c75f9b2a4fc54b34795bcf88c667225882a4a6ba8e964c7e91b60bcd5c6879d362f5df491ed8a41caf45f0332106be0d5d8a7f0b76b49461a84f261fe80dbbe380a69bb88b4518a6c389d74fcdff21868adc7ac23bd68ab4342c2775192d1e7b1c47df4936cfd0e94a0e6d8ecbaf3ad2c828439de0fd661ee29faefb3bf0143162c193b3f00612fc5dfaf49ce425c28476b432c1984e084496fb2a3d2f31b6b3af9fd15cf9d655d42d174d235e292bb993257c5a43ea59a7f441759563748b87064f2edf4fcef5f1c0bb3558e07fcc8db6ef3cd643706baa5935b482f8b29e3d8ba5ea1751f18ee93586498e77fa80907c71ec15cac0d73f82d8b5109217579d283947cf4e97e6b138b9ec008a6439778c5b936ae4ae70e0493c7dc939de6f56633eab59095bf7f2fa049c25e8c828d654bdc9d74ac5901d0e4ab02a9a4065ca1acb40d7b745b2424bceffbd6a0e791fc0a07f8b43c9b64fcf904ea25a95321205aceb3b657fb56141a3bdfc60915b75d6c6b15fa0849bd3a569eedc356c2e3d8319dabb15b519f95c5cf4343a461bd3a84388cf2401184b0413cda67b6d2527715d45ac3b8de6392e9975e8ef9dc6c1b53965db413b7d76905e3247c357221d6322a6f2ac7a6a40310239eb794b5d8389486b6510207e3e96769c23726e5f20373aa1ba206db0ee3c15338934c82e7b3c3cf8b12c4f3fa8a96f578b7a5eca9fc8c315a46a1372dcabb6c9e30526b6e3db4540cd6746b39a0f1057886c035f9dcbf34a273629b632fda58903afbb1d8375f50d266206fa388306155302258d8545cfc9e21206c35e6392910f74812d692cb8599d2956447647a7e0d3ad4cf0f6b8fca14c3accb490846a98fb4b97c2904318b60f88905418c76bf95ea8c0f9d2209b381e851b3bfff39162d53dfc24b843c4c95a2465a9a12b197ecf53e4139a13590e4b06f18d38e8437501e73a3a69fff20dbf0ac3a9055fea42442e26ecceda6f8fa04d9a146a3ab9d742c0abf0e2b2ac1a227585c1fa7b16e7fe07141468aed35fa7696162383992076c6946d594d1eda9d88515fdb5bd35025d9845371dcdf2a627d397a2e89f8d60c3db0a595e323da5a98bdcce6e14d4a40552fa3465010f0aa971ff0dc7f246598043690de07c5ea15bdad1cd7f5257866775e0ce055f96b62084a723de6820f7366d06eb1056e8aa7aabb639ea616290c456e32cfcc9bcaa5384849adab60aa0c85547297586b6fd2e91ab4364ddd8255c3e23264dfd073042768f77bb381fff350a4894fd507ca30bf48494c50049b589a989258d610cf9acaafdc18ea49f01e87403a63b624f247b54086aeb258f22d9109a7bf7bd282a71eed0c7510f61a40938728ed1a907c6d4cdc7a4fb58a52c792933bcb380f301274c66592be4cf48e1f440314380585de210b2a085de9de451260a5e56e006771f546e6779122df5a9402d3336e9fbd4bfc1c2cdeb808f51f5ecf5149249d669c693948f2f916eb243111a93a6d1fd33cdb3b72a7037b54d22ad6493b7763af60348d6cce7fa799b3317a7368d9392f9e24ce8fd32c40dc26e2b342932123f3440e5eb366103c4148e6462c90004f50fa403077e863b8bcbb0a29bc760c5da4729082e5888c49f8920d35b59309098fadf04cc8b2b850afe9f63eeac22a56a8c1f3efb8b5c2211dcba34affa04ecd4ceef579ac029fcac0b634a99fe65ecfd0f77e33d65cd991792c3050d0fc09649e2ec7796521030e00bd9cd1ead7308cb5550fa7654dcabb1737a4d41cd6dacc8563c797c41ac82200823ce8938fac81841c5bb33f39560d1ff987e05b9fdef6fbd6171d5f7fbe2053596b16982031b3b0e393021f3bfb44a3d5d659f203c8b0b1fec1389c091197041fed2d01489bcdb45d4e97f0facb463f92869af47c8d42e9f5edd3b1b3641894683c70bcb37af2ed5fb14a4d90d7723ade9e4bc9b61af777361a26f82cbb9f17392b071888946f74aa5ad60fdfce03dbdb7400924d5eaf732ed56515fce11325df320c5c412011d5ea41de5ba5b2a6fb577a20f38e17fef44dc0d5400cfe0cf4ce85bcbeed43c0dc92d8ec018a9cba2281743c7b13353a1ca53e6becfb13348836dfeea1c598114066c3db45114636d2d84af7b719e6bbae5de0df40f6c2d056304765161699ab9603eceff693c0de65932664a77fe65eceb2518e4d77021f4df4c7bb5a60f0d3a9ad25e3914456a9725d3cbb9f923c384e9ca70316641a7db8f3f0f8a0a8af69b37c5758136ae9e5e44ec0884d1d48679eacfe27fd6eb3f0ffe7f70a01f2bafd6dec44f3a34b50bcd6b030e73c2b4422a98957232e64a971ab0c7f31f87fcde6c690d4e3208ab13b8597381e3ae494b7c30b564f7247cd0c966d2cd689bfaea4b4a564e717230859915db3872b9d7d852eaaeca5fb94a2a6ada278b44053e8505455b527864c8c73206c62c11464d453cad773c34bd5d19b0c68baf6f783b7089308cfa0fe06f396d2b73f26df1bc052f60bd239cd874b6b95ed77d911beb3f9f744b4f51be2fd94d830a54943fe708f5ed5414d2ed81d8f487605e281478f5edd86a33978b89c4716f9b9ec47b766b3f48b1a477f0fdf61c34d990c11aae6cfce8ed92141a2aae10bf4c2b0b76f67b77e7f5bfc42f5703122b3ba471e34731143ecc74a6f78a4d00ebf0c57dcd4a8ddf112e56f0a21f3bda9eccb1b468be8d22af8d9eab7321126dbd6ed473e302a77cad5dcb24af1fc474cb4aa8e60d197edfccc4dc27a9652fc7d19f408a231bebd96eed6bf12f638ecddd6df8aa0f6030e9a78693f35f467b4bb613607f1b094665fdadd1007bea3449760d0ff7f91249b00c111636c1ed978b4fdc8cfaf647cc3c071f4797f99a9275fc47a9ab7f647846d571f2f61f711e34b858522b4adef25338108da94e53df569a9d8ba1fe0fe1b8d23fcada7b9340dce2aab511f0947bca2a900d8acff54284f111bcb00806549113502549504838b784d4fdf3dbe6046eadb677f2e62793a2c8606b02d01f5cac0549915ff51e0a798d225c4cf116003da39b3ea98eb2273effe153e1e14a9cc3d3d9dd0aa245f5b7f72701eef3ed4db47896dc68e0db0279aa7ba0f6400c5a6f2d428d52091e4d94b13f54d9074d50f2909aa27acc118990f75e400f9616fa0b664ef58e6489ef23e9c6fa6ac952abdaf2fa23f3a0b159f57837a58bd106c62e1842c0c7f39900187c81dd5849d6108629fd8687dda0d70db6d86fb4fd87e7589f6e10c41193eacccae5b1a1142c94d62fb63d9a050b503c11dbc0e218e5db2cbfdc613aa5d45408931d3eeea7ea97a4800080c0f0a8b8177d7274b5aa1d4d96a7f0e1a9217fe8791a4de2477f5eac3c465153f5a5452f6f0eb92cf556e58e533a9aad236aaf46fa63d1045c82fa8204ac87ded93c1155aef8592a7c701f09865803d6eb91fee6a70e56bbffc32bdff2bb7790afb2f468e7f288813987dcb8b60f35ed572beab7ae81aeb0c6c429d3d70404d3401d0f260543cca0c0164c4efcb7782e5dc110c39ef069b91917443911a618c70276fa22363f28b61e9cd35ce14197a0f2ebf8a7b428a067ba2a15728d3e0f7267b06779e6c8871bc45dc659f437fd68c19c949237e6be7d446dc646da4a4c609ed5c36e1a765b980fc0852c428f1b93515d2c9427dfa22f59cb928a2d4d90d98ff38952faefb3db108e5897bab314553d1c9fa61feaa7432338469e2c0fc7a3d665bc4b26be85fc874577fe78c41c8a3f99932bcae764deadcafe011ec3abd350fc6dbf343ddc1f3f9401648d7328091965191ce608336d8b67210727f012f0b203dd156f09a53c41c326fd511c565a5353c4fd195db6ff53fdccdb07559af36a656abb643113ff39a406c0ebe8dd0686fb96b2958d9643666950b813faf6f551af248735d995566e996e871fbd5e0caf082d37134f81e7e8a991914b5ba245dd9faae328c71807877880f57d5a18cafd17aa4e9d679e9a914bb5defe3612e1b40e300f350fad0f638e2e604f9d9c10e0ac40b2b5b8b70bfc977dd2a14b1f501b344e8b440469b345197c9b26ea9bb746ffd4e96683cfbeaccb59fc4a1ee56f28583422d0bcddbd31b654a47e14aca17a11b62d0e94058f57ba1745e7f33ec58f67743d85b184a1782f98807da1bfa4ca9fef442a397eaf6774724b831fe233a119c7c82011503a42aa4507c2fd4e185e87db136d5390d8bb9c71dc5fcdfaf0ef3fd1648ef1b43a50c43b7cf6b16bdbb8eb673d246d5a39de14dc22c009820ba5d298dbabc23b4f7609e4dd8d939f1f1d4132492e498f24f1cf05f9f9a5265fe32fa9e0e07dea07a14dc3d714377f4a65f633e3a054f248779befc4639d092fe5dfb3deb15b492de013c440547c20b9d39cfa587a883a96726520e99a8946a78d2cfa724360973c5b73bf6549beee2d7ad2ef3ffeb0f7187d78cb79698832da01597832bbc590724ad639fc21d6fd2494ffc0b5681208e02609a4567d521c92b89308e29be0b077b025df9aaafc7a68d660cdf152ccd58deb16ee5dfc26a8b4078461cff6ea735e2854c89b62e35557e7321d2084325b59a90c72352e4a65ca191b01807f3bf1814067e4faef910b7cb25ab211a52fc075528b27e0c0cb2b4ced61655d689bb0af2416706dfbe4e641907609ff634b9500db0b5415bbf745831226492a343d1e24c4cf3aec2954fa7da3083f6bcc9741206fa1929810407f9be003e8d7f3fce69d726d6b3c2355a6337c006b9c9e5e4d332a2f2153b72083575f3ade16f71ec62f4e6ed394d3387ac307321de9b6d19f7dea01ffd3cfb2eb21823101e3a78c806f586c89da6b75044cd33a28861dc5020e428c9db5f78226e20441e527833d292d54950bdf24e3388092b5a10b62e293b447c5b6ecc06a5b168f1ba8ec8eb7e4bb64660621c284ecb7c4f2e1ccc16184390ab69fccebb28173b702ed15140d01b07aa5b10ad6507fc316459492589066d08258af5ceb35b0e99aa624e11318369c05b0fe1c2d5a31103627705b9845ad94a21aeee2395d48a3bf293b4cca1ab2b425546498682b79a57a0791baa2e37afc781475c842b12af8f50281b0913e11c2d223dc95af86775fcf932c5369c7b71312245111163c024e23761e93f0b28fa3716065b50f26d5ed55100544606697578fe614589068700d2e507e5ec1fae04e65c09b615f2f183da32cde9402847f0fbbe3b7ce3ada9ed4830de6b8d3ccedf8f064bda4b5e496a2e9d2af14042b389710bde9d75225f2a855726f24403c8fb85ff30045a41cc4d8970c50e2cac3978fc1034a0ddfedca76fcab91767047a578db6f8d04a4c79577683a45acd25552ec86dc58da00f920f61d2f77c9fa868116644f07ade2f8921c71e7b31bd05b18e3b0945d3f5ba48d4cad9112dccd2e0e80f67919c1140142879c1c1a306055ad2e83691ef32bf5d3dcfc49a056aeedf69768a941bceec086c36f5f0a09b41f9a6af88fb67d3db2d80623d30475d0193743c687a03bb09d0a1702ed497f5658fc8b46f0cad1fab3f167224620c8745228211a93d8c24d6d72e6a60add45111af76f215e3064c1cc4fa4b1012240a7c61e878fdb5e18dbc3290912f1548264d44966576c2773a2e5969989d1d7809266b6c80a0bd746a9421a9ce810ae7779e500bcb8c7e1a806d8211401a7363e460c7eec39fd9afc9b5c77b5f211cf980ce66593fa6d1e4b9bc8d30529bc5fb835ffa4a5a033d564df5ddfdff018d7d1f346b9d906353081c108535f6a3aa34763ff9f505556092b4818e5045755a1d52c7865456b76b595a59097527e588ad10779ad56f5d24adc0011e1231d564234eb1ad82838a68536e137c3bd93084256f720264f38ee86de4b09fb1f2d6a1da912a9be99c70b0419110a60bcfff5700f0d440ac921b0053c5f48571196e7df49d602c945b7bac19e02eb1baf4b7d10aa30930ca2ce7947971f39a044b3da07f5e7217224f8c89780ea1fdd678888c8d828d0d983c5349ea685f9fc913a17b9b5ccf9861d8687c983b17f2ebae624772491cb3bdfc04a211800be6fbd21dad4dfc4b3d3243e5eef2961a2684eb64d0b89d67fbc09557fb38134b312fbb10cf6e9e451b23b9bf25dea6c4dc298ca7d7e32422a0d66b8cf465e7d654c64107bf024ef062bb2385080e2680a9e5fb9616eee9417bc0066f0e643fac3c1a701d2338a8368ac5388038d4699a25020eeb54d378345ea5d9508cf51c3797b98f904e1dd543b243b516236d0b07affbae810a48179879062d3837bdc8dbd333c6fa40c77d81a314ac934f1a29eb3fa861ad196759e4829235649b45c58aab9ea92038c8c902cad02f5e891ac1f5c6094ca838735a735feb9424c92a07ebb93126ceae6a5ac8d865d1529da42fa6793a50cf868f49f59b8707c4fb8526f6943e29aae8cb076da0c821d9d21105fdabbe9dfb0db90c7572a8b2d5571dd85877ef158d82b396839fa1f2f16369e08510fb3024e5915ab8af4254fb186b8761c4bd1ae3f9768412d4f192c711023fe0363856cdcc1160d3de48e2e370ebd030b82638b68d5c8bfd3e6afaeceacc3143e19b2386516d1f29f5bc82830ab80623f6df32db741184b9d9cca05022f5b643d5c4a0b14787b9bbaf57ef2d478b67295e1506c6b27d12c923196f5345157ac9a6d7fd6baa1d6a08b099f60a3546d54b21d687dd89cfe05e0faded41f32602d28ee06e810274daf94553b5c70ddaf977d5aa80929367342201b8d4137348b8fdb09aaf001d9c066a61f1603037fe5d4e8d8451fdd1b9063c75c60cc45fe8cceb6e3f2f07ffd0e4dd55d6e997f3256436e59ecbad376853a8106bf8491d00c744255e7f3d0dbcb976821a34e8c7de5c41073fd0600b809211513a8ee3e11631750a889dd087b4212e2079e8cf799222c97959f142a1685fd90a10925e062bd2175809bd6ece1270db8ad358371ed4ab6f20c3f5ff01fb6e67d84a2c1c89af62d869d20c65c52bedc49df00eeda0f626175e1274637431e6253b04bf4b2cf69c3ad7bcc7e64ad6494441053cf428e9cdbaf35bab2cc7233bc2b3b32833ec153d3b32001ced387bccff4532e825de66cab7226266156ef6b23f9cfbd5e0a2b6f0af219d449b52534b4cbd7fe8e82bb5d271fb7f6222dca58af2154eb5ca5413992719e0c62004d9f028aa7b87aa381a07eb715c9ab066ec13ef9e0959ef5ddd52de00a9d3f7aa48bbc48ef2a435b45efe6c1edd2b629926315ddf76c3be1f50f60b9b68ef508760fda82409297191c8f71fd8a66dd774a18b3bf20e15eb728a8f4c6fad3ad82ae7aa71746c8459ba66da1f18c7d3b3746d9a1ad1b336d7c3672adbda16e58fb040314af6762e4fc4e891b9a7face5e5c69746ec548288e8c1e85128729f18a5af4665b8b9ff6ed52642e652a9c06efb5f3819cdb8ea2d4c9fd083b296c7fdcc965ab82077a59621026359558ee7add7d970e51881ad24800b57cbecc4b4d2e66076dcb538646b8650efaca5e2cd3d27378a5b52d8cd1e43f21afb5fc38b8f5d67c1e7c8843ee3b8a5df3ea064ae46537de940057ca03fec982cdf6dc35c0114ce29dc45f44feb5c094df522fd9fa77baf0da42c35dd2a9e023fca556b597f1d57d7e5069f4f6f7bdb97bffd2f2713c89717b9632a2c7718b47d1f4ea3678fec4a78b9ba56bb66a83a462b9ca8ddf305a0cc508d369d9ea2869c9397d356c2696d8dd28c0e3e58e58f5df8ee50addfdd02f8980d8b4710bde64cd4cae50af6e58e65600bcec631d0bd091cde0c3ee29e1516c879e4f9a51e0e763bcd32c19e61bb4c62ac4365f3380f027aaaa67e9d11036436db3fed36451f7d8ed0dcb9b40c6781dc721c47b4bbede97d0e4943a95bf37e9a59cb2bb66f9a3b20e3fc4ab89dbcd875494394691904c73ae29b44fa9c77728d533c4ed0dc9bf3a6fcf0a8338d792f7e3826311db179f9f4d33df23779612161c03ff8b166463467bedf5a78b4b1af0e978dba7696a479334f72437c8c1ce8770ad2c2b8e75f295d6f2fb018df4a43f34e454e82bed7f5a93aaff01e9e6194a4ec90d8b42d2873079c3cb8b6ce72c6a6cc731c0969a97e9f6a2701aa2df2f0472e628bc4728df35881ee6eda1230e81504ed492a3964d6f72968855c1469c1717182903cc71b88502f61a8e5424cb003937937114b4c9513b9958538a9b8135830c53982a99075bbcfcaada2e59818f6ae2a2ebc0442d9aa34bab6d680f4742a32106136dd5615171391d989aa636aaac848a1b55f85ce37211e718251cb1b85c17de9d74fc1a256b441c699f180e063dd0aa4bc2aebedd9d66431daf60835ec8300871d44463b41d97742b3face383ed013926f501fb26ab479b7302274c3aa4b1ef2e863afd5784a114889736dfa8224943711ebed0c673b60aab620d4616444b57b7d9b38a8d38833adebbe7f084d7387d6a960aee2d6d7debebc25d03cf6c5a646894b3be39cd50a55e14b51888ccf6f56846b048726588ebf96b50763b9c9b67e3a561e04c24ec2efa1a4a7d290125ab35a34a390352f9c9092a0c3a782075c650533b84be33caf94fb3cf6f5ce10d6b3a49611f4bea86ced740265fdf23ad341e5ace267f315968662c7665bfcfa3a4cf3528c2bf3036e0d090ae345953db70c5d6b52c54e40e65f69156931cc048c8668a7caa9b85de0be6dcf48e8223c7cae9b187211572733b5b5d5e599bfe68382a80e75878775bb2ea18b66a524b3919232c022657e3623e252ed7b616f7106635894f14cbf1f8a7cd18c4368b798babd8af612e12f7fd2f2c45dc00706df39bf30f0ba2e7aaaaa522373b0f1ae526a5f8089a5ac7809133850d8a759a34ee4d53787cd33fa3dfb77e3d1940b57a2e1eef3f196cdfc7d4d03056a9d05cdbcbb0c3e0bd575d6075bbccaabbd0e87f024c4585e33b62ea30e606f4194a79c239d250846bfbb40ac391ad7f85e63f9d0d4e35aeb12ac561c16c5469e428130eeb89d540176f3f5b2cfef448b32e428b4d9d7e80cb9529f083e765cdafb4bbf970e39fe7621aff367d44b96ecc92626dc6dac94baf3d1725499fbda8a3982b9146b7b58cf365225c2f7961ce461aba0f4b770aac06e381ef730a4015eba3a019442028afd15fd8c94cf97bbfa41ba3f8277cf31bd14c99101c86b60b22b3408b9d6daec3274f985f88e022672c663dacddc6b1ebb1dce35603ca52fa73f97e2b16e01d5900b17c6e564f2fdad4bdb37f6eb8724b2a8f0c4371362138f7b77ea2a7ed926f51ea3b5e6506f8031ccbe5485783d865b2f59e463d5520d80b523af110e71bc05e6c6c27a0725fc880a97df628ddd2d6718cf3bb89db5864ad87c3102ffdaf5cd5fa2ed735c5d9ab73b4f896ace11faa6d8ab45a15eae25a14d0850388c74688f99c4339401867841a8a46095b81f522fe97cffc8cf4b29b6eb242b3fa18f21b9ceba80b016dee18875f6f54d7b0fff6d676aab9af2eb062a35437b1ec846b4ad0abccec9d0c15dc01601fa52ea19bcd2244a1fd0726abdcdc06ce290b32d67593e0b9a05ad2d0ce01123e17c15763d76fcac98f77041573ecf1162585368560e176e6fd7cd70401ef05bbbb587abc5cd5a2267e124762b77249b7226443a3b20e1f7d2ee531ba532516ba2c279b76f8b778f3d96624b3555825a533149ea1b89fde43e5294e70ab0fc65c24ee6b3164bf152152901903c303e925ea182ca0b07034362f9edaec649ac69d50d86ef43dc7c8e844585ece59de3a784c5e8d1396562b3accb6087fe455fbc5f15a459b48de6629d741ae5493ac6e95cb164ab98f1b8a4df0ad0b79e4a8af9b73683edddb66f4bec5a02955c77b110ab8f05206673ec8664ba3fd03f3b091da1c2b3dac3c92f0b6df48dcfd4a07c5961336b2c19ed190b827b7d152103fe2a1e4940b2da6cee0cd3a8b74ebd0f7991c2701eb2ea204389b083840f492d7d19907c0f72343de7d48279453239d9525087239ed457e1f590f5f358d4bcaf04212f4919d7881b72127b4380d2a78bf55b2ab45fccacc1cd8b2c81a25ee3801ffb35aa2c9dc9f3d8231fbca9fe21f8aa1708a74129a754fdba3002a1b5b423282c9713cb285de8315f7ad0ec8a0ccb2e917fafae331b1eb518547439e892aedfe00c89f4050e3df87062e340f8eb9cacf65135ce4056d1c76a555631919486d44109a125020da25b4a4f3ddf015e40b2def5a1c7565640407e19844658a979985b158325d6b9eb236c3b1253ba9aa14317f7b49906aa8b103c0c844642ab129b4e3ecb500c0e12062b2a724f52ac8b05a5ff6f513d884838b5c9d9adfa9e1f92f524acf4f23ddb5ec6bafff2bedf40d7a232f95f440d443f6c2b556c6214a5c25f8cde36e70c384a065b27b91e01e63eb04c32349fbd9cb238d9ffa652fffcf6dd3fd291ba412a5dc18feefbd331d288d458a99e9aa0e01d04d50975ca89a5f771773e640ba940e710bcacec9f38f700a2cd49963fb1aa82278891710dd6e966ae617624269cafaf5203c00a673aef2c857ff346da2a10ba7bbdc82975dc60175215d2b5b663c2c5677e0ee47058fb45361164f73823722038e3219b82e6380fca19a94e2902c6aa57124bafbfd595ead3fd2ce3360d6c5286bb85cdb7be9c07b2bf2f8588813c287f494807c727107b6be5ff54bececf15866ff5a549d58df64ccd69a18215dff4d769042abe9609712b3c370f35613f23f0bba3d49c11db0e24f34e79045e2cdb4cb65bd86aed1be0a94f1c4b1406a417029984c94e75ca269e231c3edaa590306d83f83e6dc253c9d20eeddb1f9bbd78f6d360768da597adb618d55013414d360df0ee1d47171e339433676a1c8fac40b288daf0bc5a036880d5347ecb2cfc689cdfef700644212a3065e3dae5146c019e25fa16f8a239965e9412b8e96874d67f64b8296f47b97874c8283fff431e50f67f8b2861dde69a034ce3372e725bab23b2caeb7ed5a07cded403e091ed64212f9f1cc32df819414f36848880e1c4d52cf835359a484b3b5bf1806abe129fee58d58280bd546e95f63461d1135e7de899242cb31bf773f202d7f6a1dea560b8072f093f3d25c8578c7530ecd9c30040960121c8b8e4ca0bf9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
