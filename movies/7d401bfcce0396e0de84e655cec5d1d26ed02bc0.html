<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ec3ea337d26807a9e408256afc5acc507dcfcaf7f453ab7074797435cfb967c78d22612d86d7c367fb2ae27de66b8d868a7b1057f9b0b09b6cf0a8ac286d7c4835ed37dd49ab35c41a6ff329fc96e5698356583f3855a224962ab5ebadeba98498d2ca581221136ca5212ac07d83ff724256a36cfe14299126a9fd7ed9c9f3c1039a34850eed0afae7844ee6bac1a58b140042b57f41ed362a4fc4d6dae9c427cbd2dffeae7a4e3a7e05b0a9a93f6d5b2371074d577263a38e523eeed4f1cffd40bb50d89d1493102affca97218c3c9f4d57e62cf0faadb608f4fbd82a6b86f57a3818349deda8bc80fe56f12ab39a2e005b69b70ca8332b9f07ca154f765f7299c4c7af3197dafdcdb733d647ed47fa4dc4377c80b3792f6bf485a0664cca71a4d163a130aff0e1b6ed46f7177618058d61a232b5044a2a4a1587e850a172bd4d7556100e56662ee3c319154f1303868518002d11c37552c7db354de2d70e4a349ef06f540cc9758f881a28936b244523a85cc24043c7840782972a6b881b1a9ffd78e8b5112824ef389e8b278967363600b205407f317aaa1e76a154c74f2ca66af56c27e1e7483ed7d4dc1af007270cb2ecfec5ca7d82ff84d51af1b316e54fbfa20c6845604a6570cb1806d30c2d08b621bc68addcb441dfb3173b1df9e0934f0f998a22dfccf0280a5c2324f003cd9bf6d18145a00a7c78c2fe0784f1ddbf1706b75590ac8e922af694968d69b0f8531b29e15dfa7af9407d20681fb3a2379d115d78046f554d0d22ab475fbd6c86eda1d2264dc281b22f82fcd65f98993119964aa952806cd9c5ebeb61312207ef822c24f950b0faad224971d439ff95ecc2aaa885bee33e9ffce3d84add8a4a94f56ae2b9da45c4f4379062758996b9a601ceff424b8b8365abf47df4273037045abdeac818d0e059c1b0132db404240c0a2b0cec667fda8f658b9e5f40c9461b7e1945841d8e4900bb8273b8305aeb61818b43960c593bf6406c7ce505ee588dc1ddd86e755786dfbd8680ff4f77cc74ec10993d2279630de9479a9b1adfd22d5f8fb73590ac2dd434b04f44a90215403dbaf9c226bb5b446d2ff8a71c3e2ecda629f1fef05d3504039f42dcd5f4921228fa6f862d4d58543c553bd148dbdb90c3066b85665fcbfbcea7eba8cf630c7f17337484a28e2387e22f1b8e29442ac43558423558625f7a3c6a230a6af3da1278e0dbde02e973589fb4229b33765f73c40a1ed5aeaf92fbc21ccd48ff6af1798cb905baf381e34460af1372c31306f06789ee916f39418b07e29668c1dd96eae4d58aa3a30829625016e317c9e2432114e9342e5a362240249bbc65740e431ef8a0bf43a884f497f634fc93ae0c97ae4099009f2c9461fab70ca69a36b838f935eb96e8ea66635d98740d02a249c14e93ae66cd520c3024c637495c7f6b826a3c2c57874773614eea6f5886a19e90fb73bbfb15e7bdb0b5db3b317a4549377163e18117539b5ccfbe5afd86979d07a04340ff0abc54b2af680d215f2dd9cfa68350ec4e8ec3b22540b0a1c94387847bcfa9adf5f236e52c3fc95295eafcf09f21eeb852b8020cc9b5b6e7ee4bbeb22ae82c9df220ddde89ea4f1922ad700c61211014009980fd1c2912b048a18c7dcfa7479c6f7d7f6d38a4c368e6c8da55c4dc308b13e2665ef79e35d8797908f023d0a9960c72771bc0fec113737f318f1edf619599bee4d9e02d66bb26e685cc3200d002147d8627ca059a4fb1897386c70e3db5258e71486ac8e9a8dba198fcadd3c66eaa23ffa9fa1a3ca2279b5b681995ae805273f8d423386aa5c016d349fe65e0c0023a7cce57746439a22e95979e32e05d57fa02d8f8b658d2547be45fcdedbf7ab1a0849027236104abb65bee038195aa8ec2d1ceee096ee6c3cfae6f0635b68f072dbf01e831a85560b5a016132e72140a1b6680ec1ff5301dee90f79c10404b6541e67cb8224e386ccd3585572c782796b057b4aaf79c8755c8107f1e792edc0f52c7ebf92dd8924fb9ed5380ff72f5840fac140039d29d45f1f7d47dd52784a33d7d5f6875e51a63bdc1534be4f78b7842046fda43f1947fbcb20e4a354d97c926beb308d04f2e841248fc1d28deb5de8a7e344220303972b151b9518aa50984d0d35e29e705d88099fc4fe63f806bda341017eba0e48b81eff65c5c3131be3252ae07c131cf26bd001a44fd2c26a141ffde76e1ef3ae8d11553cabf87827217fa1bd421aeb76b7ac38599718f53d9ebb6778d1036346372e089278b17e1e92a4b25a8f487005fcaf85f3b0f1a463dc34799e559a4e9e27d80d5324b946878f75999ea4564fe7bedc845b0497fec1bca0be68926a69264fdb9d8818db5c4e6d0afc3ce7bac4cfaac8a149ea4ef25163af61d73b5000485dc2a109b2116b2942572600798d4133c16c25c5d6045acacb1111565a2221101d21e91e7de9b62c0448f469a9b284c52a82d7117d1466c027c64c1808fffbee83b6149fe1a6d39b5c6fc3eebd28ae0e0577cc75b63391ae58d3dd464658541b711463adb936fb15aab1501275eec737d8bfae933dc2ef50c8d5d6023058256141656fada2da5901095c82bb5bf176521f48c6f2922458fd8aea3300c8df7e9316e4ef14fd7c7b78434ec068dc5c1e3793544d66981f92a4c28bb5c2e48852b55908e1b003ec3b4095506967bc0b5cb466acfd7283591b3b995d58b7a5fd356abf9cabaf58561f129a3b0b05bfc0f47cea1fc948b26da85629921d871516b23c0a7618fe38f5a5f34171308ba000613fe5a923a475b367e5de870cf4893a2a7fd12067df8cb6ac175c8fc22ba45c7bf70df134eea2043bcc986b86a339e67577e14b12bbe3eb21bd3b26f9784682677d08ee2b9e764f061d27178b072e251f5d64f430a764b8dc23eea878c53f7984f1ac96bde2c2a5455e309a1fdb4ba48c11ee6f6c0f258afda87a4f71e74217aab0da5332caa487d71d4248cc3ff6e80889de6bedda2b413ef3cc4870a74ff688de3a427b769e2dc8e843547dc95ef18bae143979ed2697872a2f9fd7e4121a480da8376470b90dd1df1b97322136fa59805f3c4700a31441fe7fb5f9cbfabadac448fdf1064e83acd3964226420a8d8bf0064ea5dd48dc0e6b576302405860632429f61b8d21560f6b74d5c3f9640ebe460894142bad7239215fddb55ca9ba8b35ed04e934b5ac75c298f99f8603c4bc81f9a24ca37b6e80556efeaa315208be1887bb2eefaf25db8e34b47022196c0e3b9907dd294d46f569cfdabb17633c32096869ec4e0c40a1a434b9cd42765a8696c9651fa391817967f5199344bd379c61e54f75834b67acad011e1060040d0e1c625cc617a0df2b4139f6144763f8aeb9b6c6e96ac945ad54c2d6d03b90bf7d7ecbaaecb4a970ca0906b88a4ec6578b1e9b735fbdbfee4a1093b9069c7c5aad2544b0565c56b1c4309204d77e38636f9899fd40e8a114fa6c5af3d44c76ec48b410a8c508bcfeae6a4753b44cac4cb3205e0e1dd41de5b25439901abdebfd4f3da8501322a444684f6f8c0cc7d4c2e9228d5375f8678523cfce4f0eb376f4141c94f243afe164ca647a457d9405d704bf2513577f474a7d37c438634450987c396f9b6bd717a3488638b9fd91cc96c86d20f0226cb9ad2d5898b2990a6e599d76ae2128f7d23c4e4707f7b66cb20e7388f005eafcc26aa15041f7eb180482c9d74a88e9189234a262984ea47feae9e0c03df1a22f896bf8c9640442acba6de98af763e6ec324930129a537e742cce9da70cb6302a8be51fad69adb3784facccf6e5b8353c5028f7560d24666638c034805594ada39cb4663cdc30de792cf34e3752b2e6defc77edebd9edebbd98cde8c5f572ba719b1d96db0d41d9008c54a01240fca81f8127318150ba6e55f2c0a9ede898b23b54b03bd8030f561f4b36dae17e3827365bf208c1d0ed14e7a2513d6f9ef58ccb53c706c23a6332bfc2e640353e532a33124d3425d52692abb01759c9db7f4880c75a42d71989e402c9d0fdd62e063e29a7db0ec05b3d7fa49b768c4ed4dd17f3a6abc3109720d3c58f0989dd06958ed228fd790a7b67dcfdc81852e8897ed4fad15c5fadc36a1dca6c56e5c7a1046f29eb42a05ce3ceb2fbf1be12a6bc62421c23161dbea4b4dc13ec246d17e34c2da728ca49dbb57fbc7eae493510d2448f6ae049ef8c77b0b7a7010ebe477dbdcfa275d03f2e9d9138db393abcf7f14f6dc4be18955421fb7aa074d517746a01e02d0ee18dfbdf9c2e5eb4c021886560865e1b8c67ace46779041580ca7ad9ff90e542a143b8219775e986ac4e240ee7f452e9b4debf55b73ec3120428b255d38d6960c75041f97f7ff88cd36af568add87f282dee2f2cce4d7351505811d5feb98d60bf72c4172475e95dab20c7dc98da05bec9edccff39b6d5b79c1384cc02ca860505f1b477f87035c64857863ba2a6f14bc57ca2ba0fd66a52298e4b1c7f9e58c22aef818c614395491b3079cfd9866c8768c5ea962c0a9e4bc49f1ec0f9de6554041d0ccb2668baf60e061efea2f9b251932fa6239060f0cf764822b8989af99e6ceed3618603ecc6d48528a51ffe76b05ea709ad85b1557b09abe836ebfb6d67d816d3bd887257cd66f2497690083e32567404d5552a5ee0f7f4dc4827aa342ba712aa6d1c70272fdd5cb55b5457296a3960327e6bdaa683771f2e1dc4510947df0882fe8106bf5c9039a73cc9f6ffcf6a10f4fe231885ebad93359214e3d5cff305c00ea315e0566d8cae6ccbb46290acb3dc3a5c09bd1879e097cb4261d19a77619e7af486efefbd3b05142455761b6c11b396da261f20ae7d583de4bec49a049b88417ab3749f0fada26846426c8470fa270eaa0845495c96a154f84370a1d69d0fc1400dc415e5776a3aca0203a8a40ab3d8a5ed170994738169a3835b4a88c239271b2b45cc8a66660933b383baf1f32f96275921e7243129bb5248c82585e70fe26dd97cb8d9dc0a558141ae38bb1b17562517543d2570df9cd75be7e28739850293aaec2965e69ff4d1e1ab08a2c4a14174a5815d9e47c7e80006cf315883f232792eadca74311343996dc91da8279dbe4205a02aee6a3258c80ba0766142e483f6f47f2f8bb55496c5b1119259e87c5c7c5e44cd7a6de996fb5695458aaa9f134e834edcf6e0946ae2de07bd3a183b61145ea02443a5dd5fe7d4dedd677617195358af1caf55bc2a02df30574f98462dfffae996f88cea5291d2e44bb740b7d00327f9402c05f81f032b594e18f0da4b1d0a9e2d5364da6ee491680ff0b013d6e42e52f516e88556cdbf48c97eba68f291009bea1c6a9b8606a2a9ce591b5dcf9eeb7603564c2f7b95ba408f96f7e6ae2768d107168dfe00d60ea49262e9ec5848ce764a527e2e36ac5c32bb47458df058dbda84346818009e016496b157ab7d106afb07979c50aa8ea6e87f4fef7b4463e36aa97a6895cdfd764b514c0264b8ae53d81a1585f394dc06a8475b088b1f4c390283cb51e19a1165dc2d07b7b9784277ef3bca400196556e1d3a3256422ac59add3e1cea8cafad4d48e06e627ca77d1ae23b13d875b85c64976cc9576978dd8af702b2342023cd2b35b01cee29cfff825fbc42dae4d03dc0fc20746455aaf4ef95d61bd5273d939715e71001f3cb9ef1738623ba903894e395abcb24975c9b3fd00b93af0f282b9fb77635ad69d3ccd5e712ed7a753c758d9bd55f9b7a102327e8e4c20154fc9b139c5bcff3ce07a31c24c3a8d4bba1139f4d57cdfc575a5c4310914dd902b52c099204c9f83039be66b56015981c334bfc804f599bd8af71df949d71a341498350cf734571d9cf811130de7ebbb09fd12a7cad64ec9c2dd675534983fa66d6832ba3c32ed53033bc538cfe59c994b31f882c182dd877627bef86a7fe6b0bcaa1e4b927781384ae7474ca6148ff023ba2d9e0730a6d9312c89279afb5b8194b4c9527c8a86c96aeb4856d4cf4dbe9b721fb9920c619e877db48e28f4317e6b8132702ebf67bd7a1c5228335783685ffe0bbb781378257a82504ce56dceba0626d393ffdfe8826dddea82eff779c99a1467ce091705ff7f5757dfadfbeb2b6c31b9ff5a5647eeb26939d290ec5e6f349f130c7e1e638f76403346666bcd42d93dc00908a7a4d70837545f6f3013348f93742cb95074f940c5436ce0ca26dc877d450d5d5b4d1cf04640630a19c35376184a782cc385c4abe3f82d12a896449927dfb2ebbfd865200d6b40dfd2dae14933a2393ff1e5575f2884978562d54dc0477639aca6fa7bc596255d31fa3ba8dff51465a0205f40adb3907795dbd88ee171ef286f67d0d2c9053ba9b0ff1f7c70facb69106d1bca536c9283d29ca1a74e2336162d9060a4e7f8af6879ad3792c11860a0e28135927c38eb10bddf5d2edf2d973ddaac73f93a6660986504fb3cf68b549fab611eac6325e064c19229d2d62840328dc1a8e3210bd60800ef8db88c1c13a75ce2a71991bac72fb8944acc3736050fa6824c0316f5b7d4a452149b129d6ffb72315aa73622b71d0ea2cfa28db7ab2f03b3d0288ca607e6b040d2666daa5ff3bd71875708b8c01b68b654a047d52b0ad041acbd9b8ced90047cb25bf7bb6f7c24dc0317814babb434e8e7e32d46b4d05c4dccc5d2b5674767110fbd53ba9fabe37433b84a51824801e370da6b8ab996d2088a089114fb008d4d2a8681ac50ae8df685c4d6dd195516e8e7e63d329f5995f65cfda46e62f701ad475c96a69f8879296279aa3f81a36bae87afbb1c638dd5d59028bfef8a9f024194d7bf0bf068ea4b5b19f8bd31c4efb26cb17aeb5dcdd28e7fa9250dd4a7c99f87c49d17e7e1d5f603a704aa67396fa2acde50a2cfd1926123e3b37a51f6a93cbe2c39e80782cace84c05863fff84e2c8d5690aeb05b1738505c264371501d089ae8b2730413cafa0794c65b44fd200ab701cab91d918a17f06e14faa8d73aaada4670795fd526f0feccdb2eb15b8c60abc4e00950f423e5df893aa91997925bdcbcf878eebaa596fd4009cb7cbeff3469a30b9c9a4e91c6ec94d207c343fe5b29353e6167446de674deedc1c2a395bd620348a37d5a68a6f06d26174da5d94831b0ee8d08f372f052b82bd64869d1804c831d715a876d7915e081c82a4ddc31c4aa153b516fa822b1a634827a09d663bb9b4da392266e399d22d214254a786635a6b40f6a507908bf7407c8e094780c2e43bf8dbacb29abaedcf844b4f93f5b5312ada8ae0198a6ab910ace6dfc43d53c3c19203f7da8fbb5f1d0ff018e1811bcf223bb35c3fd7cbad910d1c6349ecebbb2664d2b1710f549c8b24029a38bbb8b87d4ac075d6fc971e317ab8d9c3f577123162ff385080e4c5c8da3c90cbb2a2e07ee0bb09edc363b14258ec05d32fb1f8e74126a45eaf2b6b535647f832b6be0c54d3f6b911638a790980464e6085784b202e3078b87643d0ac3d5df650ef3bb7fe024f3c947921ac9f76fc03a0efbe011485cbe1242b456b3f526aa1a555d91c65b39ae9869978d84dcfa71f90f83fc88d4c6a75d6c7069a0bd2c7caa0d3257db8a13ca6e0abac0c9cce6d466b4006b4377c9204a589c1d6851c2e9db6a2b920437f6c61888666a27afc1f7db19ef5ea6871c7b04e475d7cd2a9732e4de4d20b27f7e4491844862060282fd9c95838a7d995a3f439e5c427204443daae17f64bd954284d673181eaaee9e5fe3cc1ae4d34a6b70b7c7ba83f64c3544bb31feeb55753d5abe5bea62b3727d5707b4bc33eb884cf15809572b760da83d04bbe437fbdb92c410aa0228c5b08630bfeec2dcf8310380bf9ccd34fbca51b6c28dd733862df1117d4c02f3e3cadaea5ce21c77f6ea77a7b1dda614340498ab8c029ba0d0ecbdf0c38f07113cdc58e9a4bcde4bc30afe086679fe07d350a48280d12f046933c0600a1292f65afde16ff6fd073b585416400f9170a274c65d65e72fc086857881493b31401f5066a454e57f883bf67d12bfe6013f804acebcb6bf035d95d7af637947bff4b36ca60548f9146d9705690d20f36b919a2791842d4007e4346f7bc287e9a1924fa70facb0b8487fa87dd62030d5f7ec51c6d37d6ecc04233dbeb8f0c24e84c09d949a0546eb7956f3a4cb1e3e0e3155c321922b6acfa2c40a8010ab197dd72afc534e0bff66c68b0385f15479f7c882af2e11c667cc32fd93fb37ae3dd0843ffc39682ab152d339b9579881b64c9063c4e091e55839379fe9f4392fe3ccd1acfd609b5f121ca6e14b1dcefc9c50b91de18acb11d97459a77bc8f78fb2735ecec36663977c06cd8b8eea4aba72546123986af0c2b3368c24c798b1de22415d1325af953ca4dc170c7c704f64f774108dcc632e1ddfb3dea1b59307d9540ca5969d7d3b33288fea8d015872edd84733e78737e5cc58339f0b3efa3295680ec4f0b08113e911788b9e835f54dc58342ef092e498b9feca05b451f9a9b9bf61a39e1e32b2edb4197cfe39ec6cc51a749fbd08957b4bbe5ef0af06d6f648f283dba42c85a5fcef3f20373ab5f24182908f600887ccc536246d0d98c99c44dbc60b6fe9c631e8f02344675f1908af1c3081e2d18e0c27af85a8b5e9ff6b9c2dd7877d69581cd8119777309aeef8d552576145f3ed403a6788650ced4fd595d02095e3902ae144ff64d3f389f34ff88f1fb509e7d012f30830c1cf500494f633084562b8659cbfb3d3545916fb707ff50312944608dd10cd2df6b08fef6e5b256401d10d0f6172afc88ed89134bd05948de4095c52b8c0b919eea2466db970bac7de3956519f7219caeb56bd78f6eb438c41bbaa19f658470733ba4411082baff88f122a4403e46ae98474834bf4a83c04eb56a7e6423bd40e5edb73a7ec857e87b7666bedb5f59de8ed06fc2aa09849cf9b05c6e393bd3553978b4293d67e785079ee636dd98cc087ca39846afc33a9e1bdbd5a16e1825b52e039023d7dccff0f013effea174edc7049436e288ac14a705c5e01cb8e690aaedde40e4e346d3807ec737856e80e01b39e0b0061bd20dd4c751c71165dff952c45baa42b05216663ddbd5f6fcd8f0e35e271dad8e113030680fb7647c815787e8ee28f6af3208777e33bd47a0dd628561b71188e59ed439bac6911a1968f4bbc5666bec6fbcce322b5a2add43ffd21ef9021585ef13a2d969b7033a5cfa31d934e3a7fcf86641cee20e313e5d5e45b1670ba9f023a3e0759e1ba16a3cf455fe0034d8c59a3776a865f3eb2757968b25dc4933d76bd71ffda93eed05ff5bd894bd566f874a4b27c1fb14ea2ce6dad5a8724971f5d13cbf4b4fefbf75c9b8b8cdc6e43f35e23994a4f0f49d47a484bc2e34181db17dc6ccb53ecb34dd5185fa5fe54f4d43554d4fb17e6bdc356d963e33b9adb7aede8270f70451e66ce7d7070802818ad31e01d74706fe2937d59e274b90473d8acfc99661a317b8e18c0ef16141fddf9b7e2e0682193edfff63695a321978ed808c6577be4c25221aa1d270dff4bab2ce9856e4863779239365abd4bb2dd5078a1d46cdb128cdf0873de5357cda1865f38aaee4e84ab7ff5314e914410cc73e6ffa25d542fdb8e04664e54417470758198ca10c144809d36eb2b8465ae2a53fc4ff02a68136655262141f0e6ec79ce6856621d0ca49481e7841a64b64e20757d538270794a417d0ee8f2ff79a55ca6b4179a5c34ad6f35c6470184446436065f9e70d3a818b5d9271f0ca9162db4290e6ea86fbd9888661e6085238f22248028102798c9e9bbbfae9ed82484f8fa2cab620ad3ca91eede92136eea5333312031dbcb623beade0b71b01ed20ae2efc02c82e826e2388026e32aef11f75278987c110148a8fa9d2a8345b358f50fdc8324100fa8f62b94e773b9a290d72d45188ea364d2ac0e342c0a8d46aab019d502c38912e50639b8f3d6a332d144fa3be32fe65fc7fbc757e3ffbea76ad9a6fbbe19fde0351e454e35bbea560d6f99f3d06918106d4b597c5e56e32d680f3cea49dd5a28049e8bfd3aead7041e6cb3097f350ffe04f79bd4ca28883c1dd390cbdea948b506d014e774099d8a83fee61ac51a694cd9e4f457dac80fbbae791efc318ae5cf7a51c78aecc03aec58440debb2d94b6c983508db396d0689741d204ed7cfd12f619b7867596dfa08549da1c7756c30af1eac0f7488b911c63e4fce21d753baac19c6e915a65d7c64bef40934b5c818a18edc661c736c49de9879a3577195a98384a526f08a5bddc1b6a8ba8c2931a4cebe7175a781819ebedcaddeaa950b2f709c7077471026b60a58ca2dfd5dd0e96d3c85bbfe9b44359908b6dc4667e86f85de1ccddde2ffc3089be78e3fcd81d8695148a06283217fe95cf963011c458458924e7a4f5e7c0fe8b1b61f3e45963c6650e3a3cdbe20833d5aad5c3b2f57221ab85b85a6d1b9003adc1e45a15a5e55a2488044ec986309a0ae3aee3b2b034acd8d5b274a44b68b49f927f5948238a1b8e8753d0a0a91c899dc3c084c8dd74b765dffd60f5822eae402a5f8896cf4939f0f11af05b348dedb987683b5bcc5c4e51fc8ce0dc5bf21beabf130f8f84cf0dc85cbb96e9d5598b36a4a07eff1e6d0fc4fae80568a61d10e6e8a569eaebd263f20f2a8b8ea1db15ce4b7b43e20595a5b1d3886b3de865379ab29c37a2857b096c4b4951abb78d40cbbf707a61589f64a9375f51db3e5f2b5c0907b811df5d49c31cb8024ece7e051c4b973c12be963114a9b061767052c85de7ba071fc18797f0111c4059577261085789aedc7be9be14826f9602b2fa836457b1345f94cb67a0dcbfd84b3e23cc786945e8c45e92006c1e95aaa71ac19ededb90330891546e917a89eb3e43e1373e570869e8cf794c9361c08ae640f9be9d589ee6f6df6b3c40096d202a4927af206018a85b5478e0111ec8ab0d693d8716089226439f96be03246a5cb6a44070e9206629350a942cba9644c9df72c487123ee9abab25f556be7ffb8f31009f953c5310165e2c9c9834496bba5623f4e4bd356f45372550f046318fe578d5a771005a1db2740ff375522a7d060bc550ba9a29489facff77f591e7c2e8132886020f67695e46f71b48d33a9545cdf9c42785a3193c8a022a6ed0dc6f7c7e019206bc5bb9832ce8e3c4f98ab2a10a426c8d58a5d3bd93900e10128022150721434bd2b4be7f218e36c19af942e06c697428e8b37fb9de7d1f8df497950ad9369f194f30e395df4121aef6154c2a7ae17e61bd4d2a55ab6bee0ed7df88f32a5131794ceaf9ef517088866a4c4601c02a7acec36695d4cb2c9f6a551b77ae97a18e5aa12900427b44464793cc0ede2afa3cb0234630c2e77298368b527ac6024d924062e71ae789968126d48cf38b23b6209428f550753b2ca9b79e3d6f23b670319e5d9a4ecfc20fbb6aeb20057f243240eff1681c326f7c8a7907b49c41bbfb545822b8e7a3202d67bba5ef56b91e65d45367a29fd9195a9686d3011d4d362f28b85cc293f3b7b3b991cbeb29c6b35bdc08052546dc7b8a6cdd077213a03c8a4bca019efb58e10cd1c22f0563caefbe83e26cc4cbd0060f87326f05ed5783087c60c920431bd32f5e99e05997ea3a186e6ca3902bd355b0d6bf1646991a88c4c9b126e83785cd1720070fcc2e68e7ca1797df6b297ea43b98fc2b50e042bbdf169bf9ccab4e1349e844962f728a871e875d4a37ed5e12cc4cf365c6c2a4920f05ecb6c32411247484ce7aa7b1719270c96e95005227b509baa37e3998734a08bc8be12748485f602c14631af6c179cb64b84a83df95d490971066a930159d1b5423852d5b936c2951d829eddabc9c3e9e601507e58eb51518879ed2e0594985f2c372195f3635095743fb97fddf537fd328bc74fa48eb6360814735fb9f291319f3c4b086692ab3855563a91ec410206afcb8970872e159f4f046c1b1715d1bf1d681ef4b0f148cdfe521cc76c3bff1b24f86b4f4ef69116ed6536ea3ca2e01ed85f3bac056496735f9f1e852f8f3301e0cf71641024f23cd8c28b5540ce1a0d28c0422e6809e2e0d8c658a142ca0ca5f65461e33cd4be17c82bed588922f1a4b9dc79fe89036fa5b9d5a7a961ea47117a3a925fc6e635edc64e4af65954aa4be3a2771d0ed6db61e7a9ddea43eb4974541fd2cfc7b01e805f1d5037d5434054ec86926c32bcd2c2de8a515e9ebd6c10f9e118ea87e8ebd9fb99c527f371d482a7d142aa5e5e144774b871f329cbf117d7dbb3fa6d56745b9d86fb817a2e467f7db8d52a6a355052633170d763b343f1c4703c700270890754a6627645a5bdd67e2bb2e612d564ef0a3092f58ab8d0cc0b80af82ec30a3e50aff9a26daa3c24f296fffcb622b161940496ef0c820b5203e4d0b604b145bc6ae42c5438eb0a626d387352a7681533a1a8d241710773900e98a29626bac38cc76838e5a932468b2387d38b264402071eb3d634e84343ed6043bf303caa5bde6dc5a74eb2970d36d04741625b7d1698f2eae0993bb15db9a41f7049872c21c2e4171ca7fb4927a50b5191c615d7c0c6ec934346cb90df64efd7766637235afa24c86ef4f2ed6b06e2ad0e28613e5d96a52bf39ce6ef81eda7f6fa5cc31f992b57f9616a695a7d843289de93fa588e1ad2fd52258a3c81a2fe8704dadb783237330e0ee07ebc94d847f52a6514b451cd88163c7a02c889c5d9ba00962bb6cd7d091b57827d4d593c7658a9e8b4859400fd68783ea131b2ba1d93ea7452707fba4f0ec17552972da4d5f8f1f73886eb8750b173f0f01d6a96cb1eab14318a95f9355b670592fd14f834134f2dcfcd2c036779f55dc9e066902abd73b8902aa82ab492105a62170d63924b42c17a319f6c1b7b146d7d2e5e490c2575a527e1c137ce96c16a7dd075e5b4393d68f8ef4a7b5ca5fa3550684f9666bdf4e6cd4c072dd15169025b720f7d802cb7227f80730c0135371e5693fa4d145427e8a0b76807b781568c5ef5c9e04c10c9eb35cf67174d6b0868eee3bdaca5473f2d9572434c218dc7478690dde8284b36c95398f4a04d791320eb59844a506b9851b2107838c5800b920b330c5df26ddd26b0c0da5b75729ca1eaae3370c322639d0f70ef15662beb256bd245c29fba158cf3c19a92aeaef4f92f5633bd659ac626389c9db507b991a8f9676","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
