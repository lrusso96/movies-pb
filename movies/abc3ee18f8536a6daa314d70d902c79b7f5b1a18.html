<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"24677f5a04b91473afc81342b245523e0f3c4a062fefc1092c807de091ab958d249f860df6e29959bcf3ca6deaf1f3be5fb01dfb0062532454f1b5fc28d81c21418e4d665e3dc08a74998a1792f5ab7d876a53de0e2755f3de3acddf3565b811b5d1738dc031befa17193b77165693d7d6054c3cd85de83d8d6649a77b1f4c1f83f2fc51a23f135068b6b9d4a059ed0e228ecdef10a6221ff6ebc2159ac9bae3244bd71d3d7c01857252ec8186866c8de758e1662c04a5d1b54de4f090d3dcd32d76a5392898513f8be97cdc95eb6d38dfa679b6410e2d7ab11f9c5e7e65fe0127171b7bbb808c9b99685a5d28316ba2732765b54499e49f338a0c759cd467d03b6ab830e14f9b4f33cc0d4f8ea99c15ae96713cbe47de66ffbdcab6e02d14f639263aafe1ddfee0f1bdd2f737f8ac0ac4332200c5356dbb6c092caf7fbc92ad68e9d532c95a905676031b8b5c576fd8d5c6266b3074e885332157bbe21a37d32265a6f32cb5e01eb39555cfde3c92e142497286d88cd0a703083451183997cc811f383a8e414b92ba43e8d127cc521ed5c4c5bbf14c92a27f43ca7f66b70329752256134cba523e3f58209eb2341967dbe0d48e4b693aa9071eacba30a53324278f993e6c2b1fe708ec7cefa899d52cbcaaf441dfb7c3742d8b26ceaa1a125fd58c4c7d78840859557f6c724d8b2d54c3cc5861bb7b0d780f5601eabf2fc4dec1ef3c1e2210b6ec925d52133b5966696e7171af9a54e2b6008ef49ac15cc4b9917a00263ff42dba3375433b45b6b62d64dcbb76694070e71891f0bd056fcebde488f42d66320e7696f1c387ebdc7905337d5a7fb5cb782a2dd3ee7a3b4743354ca3c9baf682696440aed4be03de17827fd0aeaeddc4ea188c98adc03ba725c9bf4294ffcfe1d0994603a960b959bf68c2fe8500fbc7d29441f2ec63166ded47fa790f43e94016c87acfe9c65b87fb8ef775e3afb0b3fbc02433e6d1c15b40390b25f6d59f4a50520c6c88175ff4e90ac7b2eba35d057fd4206108a2540182cd94cdbfeb9b71ecc4681eaf3df2cb01a2dbcfabc590bf80f87598f695032278fe9b8b2b7f07b9299d097c246d156af48e705f38aa0f5f9abc740545c6ef2ec2dd3cbb6441dea69c6110c02e79dbe8554eda6492f7540634676d38a7c35a4dc546b160393bc01df4981a7f222ee36561c0a2c9cc37ff51f806e26814b1c2ee0243a277cc1f522cc5c0035b89dd039fada5c1d9bfff2c353f5c574f5fccac27ada5275deeb73702a8ff82e90d0417157cd290fc7fe2d725481fe56b46cc44a91424a62772864a0b8b45132a154858301bfd529717e9a8a17aeac0416a6b5f7db1959d39d1f679148f0965962641136148800cb1d248002309144b216590ae81ea8158277faf8fa05fe5f73912cc87fc59e37c1e634b379956254ec0043592fea4ffc92670d06367e724bbddc5a0cfc116ba1baaa711e8c4565fb6645b9816ab00bf8c1cfa2deb6abd9764e20b7b53725b128aae9b86bb27b75cf13b585fbc0c270a3df0c1c75fd8f56b6754e8059650def1145127797f6317007ac6c64a35fa9a080f7cf985853f368a1000ea9d7f403d2845b1b84ff2a124acac11da3fca669060d70a722cf725003b41f31072fe173733891b2f78782bbe08ad35b4c61aec743ce77507d6e70cf0feb2518c7f7899dea27eff0734fb3c51827b78489acd6424a4ce55d616e719cdbc5d03098df6877e1d28f991f890459b801483f240b48183c39f5e3d298bdf6d97069671be387787f3d5cc23fad15eb96d03462fdffc1a7397b6fe5b628ddd4887d58e2d37480ff73170063398e7d80cd3e8f08b3f90a8e4e27324a2b8e10c4b568edf058b02686a6c03bb4055f6be3dee2e57b750a2cfae14b2b014bb82a86efd5e6fb0bb5b7d48890c5f410a2e67b6ab4efad1628938b343ba476c6905a41346ef2f9648fa236675f88ff3ecda94e7ce394f2b3deca8d24eb0bf890888da2a993bbf5cdbb8328ca80101db00c27bec551f75be42e0217f5caf6a6e7f079447926742a8817206d7b234e6caa5d3cb911107bfe4a6725fa9136ad6b7aaffd5fa35d90253b259018efbb8db492825fbab4a41ac45e1fd68b22836ad28a88e4e7685cfc1fc8ba34de50bc8fbe2acfd4dd66a88421cabec95f108d63eed88953e2be0f3463772ec59c5d9f5e59ff86a458911fc32f599fb98f369b16e85fb2df3dd45c02cdd00bb35332109d293ea03e9d84e61fcc69b2783b9d0cd2bf9985af3df69b7a5b6764905a3d3b00712cf859fdc3361e114ca1f4c0c319609aabda920fdf27ae42c8e34d24466fea90d5c66b7dbeba6a93074db24055139f60e456517f38cc874dc920aaf64539456cfcddf2a34065e55d1b470b9f7abcf2bb1f20da85734d618c55514d9522a8de12381e993484f2a974e5db869ec3b02311d0eee760a33d2eba64435d2f09eb6cbffcbd3866d443a81d33165a70713ec8260104b539f2b3e7bb7cc0da741f9c34320c69ea8dce0062bd8dd62cc7b308a386c00b98e9aac5ef14254c733f40b42d4ca7341a55d12316cd0951ca5c32d34abdc1802d541cc74a59e0bd75816be7312c69287456b2b53e7f1c898cd7b545705d02854048a4cf3bd89569c86fdbe8c7353806c8bccf6eceaa03ea9fd201d2ce6be35e7d203d05a73bb28886435e6b87ab5fd897c3465618c5a177af2fc9f9018b3bc62527155df2da710769e51c33cced608f119005ef5a0f6e99cb36e823c1a54ffc34bc398504e757fc6808124f3258c4303f4e3e167dc89448ea2357d0537e6ae25bd5653ea5c8c01e632ed46145a2041676cd6decd010cb6af7f4cfe46f83ceda87f69bed0af5ad2e0fc85a3da21b53aa88abd072e448f1140b0a2f297c2af1966af368d568b2ffdd0aaf829c7c83e0551bc1381646e406d238606332361d12feb92f4f7438003576ad55f3ec584d216492c4a487c3cc61155ab7b263342431dc27093da829bbd6802b4e6313fc217ae13b57a96d0a47af51e21abc0e9cb118954f63a1f777b9c4fb2cea375edf36ac59b3251079d74d7e94bc7b9f09a702b816964538c94516e92a3b3bf4d508d83a6a31e0d144686e3fcf966d525894bebb27fef1319e7feee848041efca92f4c3b778c7e0849f08ae2a10e7f4bae0a71e3ab7806dbaf77f2eef355eefda90da65c5b31e08baf01875f5357d45f05c39f9a3aa38890e8ff3a9380407438eac45d328f535aa044e10745d02b1e39729b8df308c3cf0cf38e66f7073a54477fc7809ead09d19436a94b5063b727351e717aa6570abd677bdbcc402732acf4f6714a2a76673bf0646a76437a95c6281e8f164acc56766d1c08af0fe4664955ed1b21af40b590f796d6a37a411da39635a6cb7e55b96a2296c0d589a993476b89ba66a58a50c44da37e7e098d623fdcfbd8dd902f364cf64b137e8965a275e1eaec401db7d39dcc4feae0684091bf2de52c240e3cac1216ac4e48c5550e17606195857869fc786ff5f1918ba27bf2c9e2cfebf73bc1c19b4cd9d4a53e29d8bb3f83621604e9f9cd87eab046f97c18b747e99c529cd849a02dd0a12e6426aa88cc7fb453f0f0b33b537cd39f4c42a1f91433fbf4ea33085dec0a676249c063fce08c25a7c96e82356716baea13455943746a0ecddd4bc8a5fe1a5d116357acb951a5867eed29d151fa69cd443ba08c8ff8b9a4c6bd1057979df7bab7bb6538482eb699808c51557fa7ca8afb813af8f86a6890af5884698f02c0bc3a98f7f16051d957549a65b6cbffb52a9a49648c922100dfd92836bfed57edb97b2fe942d06247f222ef6a67198f24f411648175a8bdac01bd02c42ef3f714b9f2b22749a765e8c211e5143e233b5211a435aa17610f61d5e97e51162f471270baa77bf38b7ed9212318b1c5cdef142d58cb8524a0c42f0d58793d2ac75b45425b4514cec1842c5dd63707b5bf40703f7fc6dc264748cddae7ed3931c8df8bcaf741f08bbefff1bb834634f61b4ef8fe697407ae747c8a26338c72d2842e1cf5ce8b4f3f25840d349b73fa9708102a100940712e2b2a8de00c5690062c1ff2749e343f5227383c6b37b7a124d0938780e8d50b0eee2f2218437c7959896eca57663fea25bd3140d994bfe87c501a2721f5b5ed7c63478f7277970b24a2f34625ecf567529703b7f618c66322d936ae7c3be9493b3c4e620c9120eb2c5f137b43cc32a2120ecc599868599f6ec0f9eadf61c724c492fc2f99e50e3481ce1e51983305a79678247ca7f970feddac38b167f11011e12cc65a0bb541b605b55f42d0a650cee46835f442f93a04451c785d425cc3fb61ab427e92aed956836c8a2696f82071ce244a31a048b41ba93259987982954ee7ecf2378d1e60415ef0a7088ffa02ac1fe5adbf55cecb413bb49f381b06021ae970893c73d7f232c7db05407bfbc40e6a92631bc3dfd39788de05df04151ee5e6810f4b464dbd8cdf2503fa9acdeaa613fc835a777c3f58a62e9ade8158c29678501455169351b3213bf850b64c4bab8d152fc701222b260fb70deeb9b2bc06472d8e0d6d5a4af5fb457470876809cf9d24a7ebe8377446ccbc65bd52f0f340699522832c87118b1afe085b133ccc9a9b893f2e81032b5a5a7d2079868d618fe6b538f1047078b5aef92a7aab8318302061706d4d869cc1d424e2546f38248f694161b9ba607d307c5f5be858b87c234d207797f0daa3cdf2525c28637a330d552a758db89bf068de6baea2d9a804bd31b908903ff1d3d8876bf37eee47d7f0d00423e99065223f9c9d012ffc855587b7903328c4295a08d28f176a9681c822b8ed60a1adc887a6650953e0da5a32f23d91f3931946a5ecc224127b32ee0423cae07d3b3ccbbf35b3ec8f40cc2efc62fa58e2dded980c3a8547e40190616c83872232f8ac8acf0579613fb971bdcbf63bf84cee3692ddb57290e1c25d9588eac9aa4bd671b83dffc01ae6d27941bbbe56324a898eca554574f7b22aaa7783362e8cda2cafc3175b01eb58e95409927a68294fa42dceff8691377b80eb6654f3cd3ffcd78511a5431d2d5320aef6439f523e788f1791d3aaeafa2beddb35f3b659baded84e07c23f4bcf7023e512b9fd06fcb9993122804f195581eb986f1436667377bf083f378b289ab6c49361ab150f6df94ec7212e7dd793dfc2c8720a592b33dafcddce566ff1be2753ced128344ea7c7a1146e1a21acab79e0675726151a3725ebee7b02d55d8a05d5e2d5cb3c9d83e4d9a98eec107355195f44335f28c04f64dbd497ed285b84109162701925bab1474586536b7a9fb73fbcb2cb295267de0d0b14f2cd482c679ee913e5c7ddbbf56500d1015d2b516af531fe01674574f68d32e58a5cbace27fc1b7d2c26134133656e15a2e4f77c468b462999cc4ce81cbf4976225b6f990a33a0f42dddb975df4cb7fb1be7c43e996d5dad70d1c48b0b7bad49fb9f025e474fabb9743bb16b521ceaecb10660edcd1464e38301dbcd851e2a827b1edaf79e68280f04c69bbb177280bbdb29a2a461afc515951f1b3f7d849af6ef3e3806e78a97ca5e314ecf876d9b3b85cae023637de450527175dbc7c6fa046b147d5ba7f0acb62e5ad153de20397194c5da2358c33047f8435d1364be7f9d09d7d9eda95220a8c9eaf3e8c530cfc721e33527f32f952457938f85048ea6d755428dcd676b8127a83df4b507ddae75ef503cf3b4f28e2f3def3e40caacbf6383eb9f89740b8f67fe147885b72fbc3923f01f21bfc397cdd59436495fba499bad67f3263c3b4af84ad1dc4c6c619351a803c37e17c8712a2f814c21d855c8fe6fb2cfec0b0db845b8afe059dbb5770b12ca58695d93cc3d10e7a1453670fa2190b4790c3b9ce90a3cd8c4b11802a7cf9befa0615fdeee680002195440f16eda1f0515d035f839ac164175946256dd939719b30f7811c2523247bfcb967a7beaf24c929821d913209aedcb908a47723dc8e83ee0858bd643346646286a1beb9a897dc13c71b9dc1b0ac64bcb9b331d02c0cf355dbca9acbb45ea7533b9017e948600db61e919d5f83644f680a0c589bcf0b3bece1e898e634da7de58a33ba018e81eb4f28cb6e4ec29030082f4eff01785e4ab3f712b1562b460a079a818b1d30252aab522b0c04a2de9ac82d4b4f61e3855fce39c9062fcf7a9272b250239096e894baea417473e09eff231ee32a4f135344a8a6a6d2632801b37035e896f6eaabd2e35fc24e00fc09c22ed87a4371eac553c1596f37f315e0d2a45c0d1c053eabb0fff566c2b1bcfb22ec5b7ff81f408c8b4c48370059afd1f6e8194120ef6a7ac8965f711a1593c70b5fb34edb693730dfea758c22b328658f588fdf48901a68c8dd6993a4426dd429aa4aa18ea062ee4b663163795060bf6246f7302f7a88e98d4d00434e77c9cebff463a4e5f5fddb97b8450f0a772fca3297c18de0ec3bf7b96ad84166bb17d7afa40a905dc6b2036bd0f53d37b090232c40a04b46c43333dc1bb6ab6b4a460e1eb216487659c3105d76251660af73cabe17487edd4ff2659b1fdce0adc023dc7340ff827e8fcf4eaa0e3ffc28bf08b3eda96ab6f591b64888d641b8f409f6ba416ea0379de74580fb45950d7c6de4231e601b51227115f55af32a04e4efe706caddee4a6396e4fa0d620605f283c4302734080e5a39a6afb3ab27de04d9f19eb86d301b163ec44942b537881ba19dc5b20853013cfeac62398819767340dab8372e0562c358f66b82261f2c3cd377752f00698146f2909d1038c97919a3dfd35af98a99e0932e3193e5f1ed4971df073a7205d0253c61d8c59adb4e6cb1a95628378fa3b064a4629bf5375d83efd4a1251fb1204023bec598ec9f16c4e8153373e0c3d474fb51057ed2464b33af8380e543f6d33435441cf2cc6c4ba6ee009933737e867e1f75d8401c5866dc49d2ef1fb152c38b1a0715490b612395899203bb5028e52d3aa8de658d9bfe2d586a93cce42a39cb3711038e4292d47726bc839e179f3d1483e6fcb74f60815797ce12167d8bec139cfb128440acb8d4b914d670e5403a32e373f22fbe8ec903543ffe2b89ad7cb5e79878872ee2a06d6b15850c2258467c2b31a4a4f2a628a5d7907d888ed1934f8688c9dcf6687728887dda6b9ce04e5792a49a060bbfcf70a45f52afca7bfd39a3e017b6b1ab64bda44238911788ab8a7f2abcd5b1b67dc36c3adf7a72bccb1553d8ef1d39d1ef9d953fe1d3c433059fcd6349763e0fb3754064469cdb740d7b5229edab85c74fa6aecbc72be54c0d818780f4cc107f74e60ee7b1d65510d2885647d79f106d9dd99a28c293a601a23a8f9559562ac6e7274e1822f9d9f6901aedb74c1c31e64c906bcd8804be37d1f2dae854e825e466a54713745b26446f325b04568c2845f77f7d524104cd1affbd2ec48164c7fac894a4b478c654d3cc03799933888a0bedd4697860a9dde256b45e734923efabc38d11ca6359b3e57059d8aa2d774a3cf2af355fc78108a27881e5a446f53a4ce3bbb9a1b963757cf8d0b12276cf1d218788dac9a6d3b6a11674c9c52bb0907e67bb352ec83fe6e005b001d1135867548516f8d85c1e5eb836c3e4437a22696bf3d5787be0cdea79d680d0a8ba881c766ed2eaf5f73500ddd2a839149f3f03a2cae389d0a4a0659bf900e06067a6a3698509f7f02ea56541c501edb455ee706c50ddeb62de9ad93888f730975c6cc42551c862015e892e8fc0b18fc328b9d597ee5a479f05567d9b029b1c4f0505bf811d287d08d3b4e0f4eea19c2970ef55f7139cf53d4fc55872a0259bb6f63ef73c79447c37c045dc0177c28982667cd35be14659a05f5859aeae7e13e6fc486d62e77435269ae6f6d276dcfa405ae0eb388b46eca413f4992e8b588b3286d04bd2ceecc74d51ddfd4ab7b00e92d7c96a3892b8b1d206f94a47e226f32397382bb5ee694f3c83a94e16a776a5db66cdd2cc8bb6cd065d62f25b807fcf98b387cb7db7488e49bda4507056a156b5154b52ac30e6e6a1bcdc3f0cafc802e243a58d044d5e323ca04143da03527fa7bd0a93f9504cfcd66351250ebb078a50ae6c6eb6b56bd02f5a7eb0ae1c7cb8c0b06dd9430e62182749c47dbac6d95556d05ae4bd757e05c655238f3a5b460efdfa122aed33ca24700b42fc432db4d391a99ab9d258d3356ba9469d3a698e8543658f83ff2bcffd3d5c3737acb21ec27b0781ccc4fb20d48e38e23532c06a59eb34ab6c71ab5df0b2cce4501cbf726bda0f775ae2bcd4a1d64bf85cc3ed3be18fff1ebbf729f4470f58490cc6ca8b17c3b6b96b94c46dfab365d786e616e6729bc27250badc888d2e1b5da3db65ae056dabc06c04d7de751ecfae87aa72e48908d527ef4370e6c9da93002f03aa14a9413109b1dee1c8a854dd5a718b691dcecf369132c90c28dcaed32431b532f18080e07db9432365ddbd12f161001933b05b242246843708ffd4110fd1ad9347b70c024620fff40461d5d8469808e09b62fd44dd8a8187de10db9790420f6feddf7023fe2fe90b24fb5f7db974d1e1e4818157d9367d27cf766089eb6c68f900b89517aeb075b78f8ca00f76d851972c8e807227e1a3fe79592a7cb61a3b4504221a7f0f8deffd787cc108ffbb3646e2fcb0f6c9d6a5b0b2211c0394f88012d62257ad8072568589e8013b290632f377b0213f8ab543411c44cf2d6390afa090f2dd9d3c13bd8b6317784eb50647480f9ab2841540ec9993d0d91629600c8f409a643d67564d1bff7dc9feb8e6e644dbf031f0329ccdf1534f7261968cb7ee092f91f4b1786b3e98703fbaed51998f8269bb92ef8d13e4fbf6e7a5e63d1b94de31e43e2f224e83467f498dbe8111648c6f7c81d759a7a32ca8045baacebc8dd93148a3863ffc442dd3c6e1e38935043383409a9a48f3a45197336f690b0df4b9c1f72044f34b3edbf50b60fbc3a3fa837e77ec1dc98f729cd8d7236e904977ce171c4f1aa7a8846b0b74f76eec6763d59b7d98cdbf5878b1bfaa656786e6f76e3f0f5d922863e3247302834f6675c79be0d5385011272594b49b042f470de5168e1486a49aecaf731a57159effeb5bd02397f4e602666a9d86026f617d9f9daf32acc9b0b4bbb372ec0a6887727218eb9d550f85129b1ce5cb6d5e2845e90492744dd14a20b890657a7f9c75f1c0cd6421d25c863a556c8d7115051545ae71e60db797afdf520ac7e76618567f14670a6d028a79dc6b83419ce048063c0005b598933cebdcef40a8ed34a1a9999cfdcf9cd7d37e557fb63986622e775a74837251315e8a1a9ea8678f61649dc46b93e57d1928a16045c7b4cf4442dfbd81006442a394360eae4b6be3156b115dcaf4b81b43c8c8d3fc01b51173e741f68647c6c15f55a23584f8978b0431d1a9f918913ecf6d1c1df152bd1d1a642bb30442561e7ea92be2803ed8eeeb96e3204407f50206096c8d880181f4cb1cae9c6339805315ef91bd8a1a91fe6984a32793bf7226120ee56c174bf5417199f1f9e781713f962ad1e6f9ede8c3dbd84d5b9b17f4b36e8aadecce1a0e64479de0bf2881dd0e3ae61c409531b314127952c7cf2f3de4995c5d4cc1152825c76268e1cf900aebc9049e92a6b2ff185c7567bcb8f915e4b7f7b4fe29b03e81db7f27b7d60540af17854a32ad4bd75e6385d7400178e09ff9737e4c14f81a55560b657b666e2656a38e7464c943a113b6987a867a0a89fc033dab05a9807848c6d7b2173fd48b4fb3aa4f3e16358789b356a39a96eb7ca1de8ecb2dbc89456d10e0e9f2c7c043505ebc787daa9c30261d1796b790e4333dde8ce8f7722aef08b6a84ec7e5397a1b441a0d081555598c88bcb8653237c6f997193ff31aa3aca67e921135782b2fd44c2d8b71045753e8c3921471aab644a8f38f047f13ddf325b8389c0c88669ba97c05aacb3b95cf163736ba9adff78092c1ac36c7326c1cd779905510e178126757ac64b425433f08c9def16d836ad7dbd7c8650147529d36b9a927785768efef131537ba6d6f36036fe4418542bae709bcc40d73b8879d003d64ffb20df1b55abd16c07af43b1f1d52f010b3a646b8f5a40eed5fd289bdd051d64a1d9aadfd1ae0c4655b5d83908c02f9e6692d71eec04a33b177afd0ae3c39298174cc3f8d424f4af7abfea59bc0512324b1bb725622d07a76fa64006877d9fafd2ec15d3afd0d57f0a351523303c8cb93c609f3e4a895985bc5aa0347d4e6cc9dea9b4fd7de02bd24ac20aaaa1ae894198fd4d12d85b09092b1f3e3d8016c5400d2a7ba6f8911171e96f2f42bea8b0c10bd3df07dd38e2b2ae7d9502afcbc55128e0886b2ea4c62c6932e80f486f0b0345343b41a276af8cded09a2a91f2d0bc73ed5b34b762f5a47ba0267cc1f30e97d2805d16fede6726e64beb6fb2a19bae2706818b4b7aef52a113ce9510fc7a004e6086297ae5ef6ef36caf2426709d0de8f72e564a299a893714b4a4eb080315ec62755e1cd6ba89b0d4c1f5d5f08dd12d2a2ef90bdb634082f6e5f72bfdc303de514c608d132cf35511b3e7b299e9c470431305fe3cceb7636a6f32c13b5bb837d15ae565a1e7d48ea607ceddce1f9046bec34c4237031c4ef0d24ecd9dff6a13810137be3a6cdbaadbac2812fe338d20c9c58b78af093878716f92bd4ac8f98f5e8d303cad1505eecf2005538e6850606128be6d6e651f35b58044431d068543b67188d60fc6ab2980347074006dd221b6561f2cfb55a8d867caee7c2745a5f24f1f618cc7951f0d41ea9983bf187fe7d5153070ec7406a94a20ecb1d100b838fa1efaf586e0d0e3a272885a48dd6150339e766ea7179f21d8905e46c53c54aa047b04396b80fcd2f7f7f7cea92c9203219ae435dcacd29b12089d3b3aa736b268e36ace64d25b01d95e3f229780dde1ae4201a2833726ad69b6fc8f4cb60177b2734e8d5611adcca80b9dfdc1ddbe8374ae420fe89dea68c300e2d94ef7f57ba75188a54a35e19cc5209499cdf05bfb0e2940ab104bb2846f4776ebb9afbddb02357c39f4ddadd305f429c65249615fe2afd3556f50ce52222fc6b59dcf613f801f3aa621a65c1daba98b27db2cab45bf172435fbc695b451916b1e858fd5d758860707710aba13d7155037e5532bbe7d50d839bcac0580127ca3ef28e87282ccd72fdac7a44c16fd2c1e64064fe47af244cfad853b1050eca7e4d87c2c51f0c3068e37ee90be50f08ddefb3ca7eef6c1d74fb8104718f78bf3afca879c97294f85fda3bf538ea6263ccff8165e3cb8819caf3cadaa81b58e1a43d21bd4c6f56553a1043f0e6249af95473133ff524bbb167b259e6f02d159011c2eba544ac5bd18f0053a3605054a5c3476c3d0cc742b5495aad5f67c660ab51813b42fae0b5b0cca3f89778689f8857235d06da40491ff15a4c0a51b4c4289fe3f2b8e2f6d2ddedcff2be3b784aa9224d56eafebe12c3d56f7bb7642e19b9ea24d5766aeef00e329226f6f252c567efde0c617649b4544968288a992098776006ccc5cdf02dea6e593317eed6ed47d795cfcbb07196ec33167ccd7dd6f0ea290db4215851f4f14163c0132393ffd90eb518d614c3bdf62faa1e56f2df4a81aa6102ab931a5ec85030b5263e45cecb54d84a21491fa6fbab8e895a6ef23af822283add36dc33f610abd30cab98f2c297d3b531badf0a2b86120aa89157f8761de4c18b3170c25569f1bd1d5dba824a1831ebdb0fc1d8a0ce96cab2d071577fdd1605acc79867d87472faa26ffe05319b6ec0fb0fe946b4c0ea0c3d0849d5442f0a64ead7fa9d9799bdf038d577db9e2ac2bac26d68cf2ed34347453c1a0366ee597ddcc3691514f7e1b65dac3bd5998abb20b5543846522aee14044c3f807604675069b7c1667c990f16fe8319f16892c47813545a383a3874a74abd78ae0b1ee1e4fde85c93355b0a0c970bcee8b2b62fc2fc5302c3a2e686e8397aa15a10c4da66fa8a8d54ac4fd3ecca29a2c9320ba2f663b42a0cb3dd7da477c241908bdcc17981596f4546426be3b3a27d87607d79a6ef1e89206a9ceb3e22ec767747ec28b3dae6411e49be9de9ec137521293427b660a6645c0aea308a9cbad9457d0b87801952274ce4f2ce4f888c2fa6e820c8b1f0a3296aa518027aaa636cf248c9bab5bf3133cc0ee5925cad819953ce81da1082738d33597587543a67b9999da20939e77d40ca032241b2cb980ad7b50e2b09a60d4ce8a0c14346e41e454894ec2fb80debc52a3c4de8939ad523b866412f6fe21d0632cd5dac077a73d2da572ca796fb84677abffb7fbc90c05075621c9ec270375546a29db34731ea6c48578a6ae50122d1d8da0c1eb226141cfcc270079335901d7920a2e28309f32dc5aa30f2d1ee63b724e47040a64284d07338bc450a571c75477c01fc573a78bc220dd529a913959b5293d7cbee9657183e5ea3e211de5435a5324954799885f4db1355def71cd901ba5c999d2100c5cb567b41e46e1e40a19a43b00d12772190bac595586eb0b99d42350d3263e128ccad0aa5388fc97dce7eab3b358b97233b9fb146d76d38e83d89fee1477c3b83ac4c563728344a380c2b89a8f574531c3125c38fa6c263d35e0b8bc59d279aec3d19ea970c80605a31d70f5ff507a63fa916c4adbdc3c874ae77f3ca859f7f8a95be891090f635f14bba41ee84203cb7a12dffbe4e838d9e403c4e0fd4dfb99e0d849672c1f56522617d668cc85c614b6697a580cd2ce0e91c1f49eb6768fce6feda64228ca0229e6fa073aae20982e9a08f5bfa58ff7069379ddd09882ab1164175d30e75c0f699179cfd6046abe09e327dfd2d186c37223b25f4aa16c70c942b2c09f5974bbf326ca935907d80a00732e73128d4ab4964506a7964","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
