<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ea4d95ba8255c09c1d68e46ac7a01e6119395b6d84af04fed8e4d27aca6d0cc1a415d5ac40e5569fd94940db5e63d3394d6167311a570363fee18d082f62bec81039380d4c65489ed7c8bfeb2aac2fad4bfe62ab2114a6c650ad8056570cf01e4b9dc26421bade1233c03539782f46a90959b7f11119829d5226bbe8a3326e0770a8c2d51303a3529c51a53b7a60e5bcffa3fa054e959eb517e59ba365d2476eda9bc0de73cf6d514b10e3c61b7764b201599046e18b53761b364772cb246a5db353bd26b5298d0ef7ce672225fb1b000d4bd352d1c344e2bcc0091d8c0396c4b249e4246277606d1595a26b761092f01a3f330340f6882e222473d5886d67045442b464cd1f29e4e5781fdc391ab61feacbd38c963ed342b22afdce7e06ca307245e3ba4fad66bc5a98bd8a712672656f1165b725b89c2c3e98d9afb8e6c2ac375a5bf0bb0044986a2dd599dc05d966ddf9fb3540b97c84d32d61bb97be486b4d69f64d94578909325d531801de4fda1ef8e6d815cfa18c5e35eb2d0f02f96795edd0aa980c9c3615066455a11f111794fd3f2e6884009d372ea232f513acbf183be4c6223a2828dcfcc1c5ec4c57d6f7d16e31257dedc4b11aa99d27a071cc4ffe844de7f53b2a01d3c691ff6acbc7bfc9a3499c368da2d5d72eb38216408dd5c58f4ab926c8d6644d6a1877064e3e5a12997eb461fef53bff2000738974c2960787e00bc6e188b7863b985f2e0270f8c7101443d5a1566e82f5113d9b72735d356e8e79f58ffa05db3905b3aeceaf25cd44ab8f7101a3cd36a47311e28c92ec0c5c0d0c88c46ecaf768c520d7fa55e9c65c6709ff3a9c33194980df014674075411f65790de67c0dea598c99ff8d8dfbc7b25b97129a3d1fb34051023dd10be8af2bb0008a8aadf67f8bb6517ed15ff5e27b53154f00ada96cc1205b908c230c7d570a310700c020ccec5ed05805a877dd44522346b1bc0f2b38693e909e4b9fb8c8bc43c44c12e0204db419bab9fdd88a5b57c853fc7e1cda52ce502f6c886041980cf44c49fb59fc45cacc6ef440f87ca73865619a31b94f0136f5000ff4744de2f61effbb731f2e0487008a266e28eade6604d7d8fcee5678755cf54f2e1f7f8885faa1827b57ad7768a41a846a4a12d4c5680599a29aed91813bd7142432bd1c8e82de36086e5efeff3fea075a582cce3007f9517987992897ec5fa7dee07831e696641a1a4532fb68cdc72f891a6473e8612f536edf32b2f5b417fd4480dd0b33342997a647a4682f2d9b84d677e78b8294d9f2b504b360c7fd18b0f535d21b54b0856abf5e02a7b7ee69585f989ea39058acfff67d6e5f754ddfed2339f52283807b698e82fd192f5c762905c66b03a20e9a02bc6500d3b7b66add5119f4a6681bbb2a3cf9af499c403bfd8a005720af585073079ddf6393cf75762ff86c0bdb27db0f2563f0d310829cc1b6c0da9f4578505ffc019e74c457bf78790db4d7dab56984e11a2082c3290d375a0ceee0a3f06c4d23f93f243bc786ad09ea79fe001cb58431fcc21ef83b9b380b270d063012c0475b2dec692dcdd91094e25931d813fc7e30b5f74e71dddb6024ca0d065de9c62ae37196cb5fc99b1a1c3a529d130abcf3757f5b8ea83dc931986c8f74f7b7c79b175df840e4faae74b5260b26d684363f25bce7b1c3a038075cd219bd671632693bf32f1845348d828b58793e4f34f43af72f1a58dbb189f30ffc0a43f11e018e4ffea27241a56540953c65cc91bcf419f477b0c66bfd935536a0dd092420c3566620b54dc7c0bddc7b5adb71e9b33769a9c601742497fb772cd046fdb1d98db5b3eba74081357735de654339800497d342b1bbd45f9a6e5efa35abe86109c95c833a4b92ca276737ac770d57f168bee1093a94042fbb7c17440f8fb2d80dd17d2501be376b5b5e5bb245ab586d8e9f321523a9a103a9bbcb3cc11f8abd88cfcf83d8bdbae0b69010e3f80129f6a4c52e38d9edadb06f63970a08adffdc39f79b8320f70acdb88adef907c7e1822cbe3a562ddb6653953f3490d730229862e3df5d5700fef892ea10b6dfc2b348a61bf27dc31eec7a41cdf5b472c439c6118f89d776185b0346f6c3645e8711022531706bf9b06fccd879567750cee1aa53a87a159ee326fa78c7b017bccfff88ee00e372a70c75874e97e3c40b95902873f09c3d43f3a0457c3c3071f5de6d8aa0514b7628af1716252e4ad02d876b7789826f9acc314fb52a19588e84f2e1c74eeb36e3e825275872c7086920112910aabf04e4dce56138b3d09b48cbc558d80e9a2655a8339755272635084a18e0af53554936bf7ea2ada648e10b7b32f4a47e61f6da69262c52c323bfa5baec79d4810e8ae634dac32c17783970503d9e7836871984f71e7f4b2c2856b652b9913d6768b3453ec2bc391100f773dc90b9565e2f1f524af8a86a44aeeb4bbf0dda7859d8fe9ece6253f609a0ba9896267f22d7b0ad980dca15c8b59abce0f9501ba26ad6b756745fd145923a8cad4f74659a5d2e2d87e0e3af11a55c46fc49161d469ddaf375281e68e9868485edff76dfebcc2abf543093637274ee218f1e12950f4cb151f015b0636b1720c9ae94529ed834f66a4f45aef603a7222328155e65e57c18691ff0bb21c44b6d99ef1b6ede7531065fe2d61e66741f53bd3a113d0329f136ea109bbcbecc18b8c4c5236babfc3468a97b80e714df1fce7d354119d0dcf624fa9d362722aaf316dd34be30b4310f8275647b6342d26fcbdae74ec021bd15a4e59a84ef963a57aeb8132c34631eb541f2bb3e4c71d261f21eb6487d1000f3bad1eba102e6dde3dbd586b5e4f63ace435a5dfa14f02bf3295c3809114d0acce28b9929b795f6f6de5e93661eec5aa25fc1719b5580f153b898863e90be26951214944bb8d7a8c16c3de10c93115d735623ce0db883050b3c0fc3263659b90b71a0ac86e7b65ba8301fae82cf380ac65882bdf726f4514a4bc14ee9560f294d17dbde06dfedc0b12a381118b73ae19cc3ed726a0c9a9f2852bd6dc487dbbbe1377a69a2396679748dd43f3214f13382ea012f6d6388425195950fe68877022667398803cb3433c9bc8b70d31b60b4fb28e20cc2675d8d0f5434895303e9a5af25e3876ab43b8342544abaead0645fedc412b15729c74b4514a91bde97af75d85c7040fb5e8be4d8dc927be806812e3de795f23eab0fc97fa2c749a5c135407f4fa879a817b866fae699596e7cbca6086b67002362542694bbec5f4acae1a79735bc2888cd82933731324a9576ef4931309d285d3727f32ebc2cf9b21b44548700872ac527a76ecfbf44fbbafda62275a6e2a5bb5c5151b8e4b5f7c643e7db642a14a44610b67ee75577d087143917f21411678cf5f8d1849fbcace171eba727c519c4d537a78d2a708d349b4d140fac5122409474b16803e7fddcdb267d84c3ef1d07e8971e6569f78065fb9c5ff0dad47cfa6c9f32f6b844e6c1b8cf0392022f12ff0b225521814664665dd2e47479e8870f0d89dc8ce5e1c2a63adad5937b29cd329433e30f206bc5b67f9acc364ec6490b5a7a7107643829392a75e9b98c01b68bf155840d644cda8770cbb081b346b17467da878849f5056fc084822b6102c03e5e6df6653d0099cea1b3f422d1af6885e12ae5efd782fd7421adcbaaa86c13cf1fe4f863d9fe6b98e6d534d2ecca9dda3351776097d355d8328ec132ba1c895c5f8dad95f01cfb60af0c8bb1711958b7c88982642548faa9053eb97e6e73d2cbdeb563a2b9bb94290ea4e3a5f67574924acb0ae5584819d86ac33d55b9cdb33135ca65f93943f86d89a474e0b9141556b90e812332f2805bacbec94313076a894fa3f6943b1f0a4eff10b3b5f2b1d664a905cbb707b65e5f01a653037a1013431eabbfabc8b1088a06ddd1e842295abcf08d92a44b9cf1b2596951e9aa504586d8d968c453dcb4dc23d3fcab57f52e7d7f9c8d6990679d46467070b1d2783d1504aaaa91bee27d978776cd80a1c2a1380ba127a0e0f8a832b01cd4278e33875187a5b71c6debb7726452f3f7387e6878d722a7a416937fa188d94dda7d1e093d88953595a4e84de81acae6abcff95a8a2425582558077928c2d37646fcbe794c37ca89e6ba4d0ad14f9cb9e4cd24ed03fbd17dc9fd51648c8ff5679d65a186edb55160397103dcfe67f56f35e8982e1d036fa4438df768082e5cffe0c980f8ae6dddf368745b510a16424039fa935174fd2516e98f320ba4fa60d976d55ce801c1abdcd15fae0208b1ae2a5c0a580bf3e37cf5bc5af2005ffa220749aa824e1f864f1cb46e3dc2e6dc309185938b5d5505baf9532d715e81268638592c25aef099d593dae5e0ce51f72c5e5a9413f18fbaac5294006f0fc0446d78dcf8bfa111848e2d98cf2f7f1f120b73b16045a8c8c641bade9acfd2dad6f70c0e7ed9b14b44df2bf9165be85edeede5da8612319c468a69d49a10c54173f36feba02cefe720565eb29fb551bed454e4a53e8e33ed71841ccbd6d3a6b4b8e3b4b349f3696015e8cfaad96f4a8f40259937ee990ae35251e46c305682f7629656185a2779a961defb88932704c1a88dffa20b5af3aaed4c8a005198d1d0972e6534a7c799bd3084185b48c986380c6280cf9b98ad432cc1266e58cda67fcf18809845dca07dfd9a07a71dd099077a22a9999c0d05395909a64e6b945dad1350ddf7d105bf8a1822f7f08a097ac07b5633e3f8a62315fed41169481fb2ea6fde14bd4310aa1cceaf49bd48cc93ae06d59f87028447476fbcc1fe9963b9b2ec2f1a3e071447313440fb2df46c4b6531660bba916f91d25300f76fd6f3982d769f9d64b4908af75b0923c07fe338991a102568c65f74edd88d34d07094135b89aedbfefb0ad4f25392b724f76f63e49f828957e3bdedb8b5f02cbee7cfac084f216a4e7155749f1a212442124462475189cf0154039a3b5b9bb622ae0c58d01303d3364620c77263073b49a9d9920298a8bd1a7b0392036a8631166c24fff1678b62f3a8d861152d6c5901a827e93307664093cdd65c3b7fd30447fdee3848ff5879f7062b94df1e6d29e856691213c71cb025ffa1de21d84a64187e1fdc0f36507027ae51ccff3035ea0bb9af2b308990473d3195d690f1d67c7531201d4e5693e52a9e936aab4f83ee57e8ee11ea4a1eab307d730f8973fbee45d25d38d446bdf1167803799c73220688d03496ef31ad3228f510e75357545a61317a97b54824920202f54c1881402ae831e2af6557fe3a7d717247b9e66ffb523927bc6fb138beddce9795306ad6c42eabd3f1bff84c3e7676776c393a6c14f2516df3b8193e705fdaa092bc40577f78b9dbfe1bb760c8a510ce4be972059a72c1abf16c9036792cf2e129ecf97575a506f14a75cbc7314fb951bc82d064ffe40ef332c2828ba8ff672b7460305f610c7bec25a39b74ad39d0878b0abb6e77d57f0701612eb1ffbc9018fdb28a3c0f848ae88ed083dec9acaa4815773a238983304e4db0aa650650478b44c281f4ed9fe2bf6685fb007bf215caba8bb310eee715a5521c84e4166c9675770cfe33ddb7a7071f3cbba00471f6ef2eea72df1a453f08001fe0e330c61410f0c2bffae8df8e03afcd446c10420edc7b14c0065ba308f495f7407315b433d374bf5c71dbcce6c5b22b47915baa3b2f1af3f4b358e4865136f921b2084ab2ab6842fe263a07150c0360172dc841d2419de0795cf3e8306c2b7a650908b89587376a92f476423703aca716bf6f2ee1553bb2f5da5c100226ba67a5b5a327d8834ccd2e52f514ae8e5a1eacce9f34075989f13b6e5277cb9324a35c76bbe5c4c8d8b97eb420f24425b9f22f3c0d8e80a79b24b03e3dca12ba054672e2202032d52bfe4810cba875342ff5444f2220976cb460e4473d9ad42c9fddb3b9998cc80b5343860b3e0f1ce19060a26c0c98237fbc44e064e142c2eb7ed5239cb4f1ba98a779a2d9007f1e52010fe3c9c7801f9c915babfe0e7ccadde2424d562d8e9f1f6c9697b075f9ed61029a86936783468490c310d28d1ba060c5fcd365998b446baf6d7bea137a84b98a6223b2ce3ec9a2da463915bd12a473078d9f0a792163a32581a1486170d23d81d13c195cfd5364ce2fe5824af3c02323df6a432f8c89db24b5837b12ecf00a258561280d71bb88d298b0640983e7fe5a6b18a56fb86dc3ca01eee8f5eaf23f6daaa35b8faa5c4dc027e03731735cdcae5c951a3d48dfc279d6f676751e14a738e44a6b4c4756f33c11c1c2492a286be05a476259714b074d7ef22171bb6482f2b44818be9679ff8185e65456d23c5caaa125de52acaedd371732400a97eeaae286f2d1ab20a949c86859d6bc9c96f7e6d7ab17f63a718f99c3c9deb8e14b2b109dcbe2d6c0a8a514f01935eaede5da3288585529b742ea3938cb30704ab59a93e1d9e3cb04f759d95423d77b5f3958485829818569862ed37b610a0c1ccf8149a2df1f4246a36393f67da603083f4c7d545c4a863ae84e2e54f38d90795d158a6ce36860f6d8e1163db8de901cdf7cd533d47e4eb40fba6e9ce08716007cc054cca5ce0c5b9f6b4a4a104bf2dda8ef198851785156aa81360a6da7c14164600a15da4678fb5a9e22994a6d00d94e2a11ff510724f116304aee37fa78ca3ac108374e7e8db867db6f381d138dc92a228fa172917998a9ee75995fe72bdc00ef7f49f70c43ddad1cab983e1f7c5afabc98554a89199d59f866dd9e75accae6bee662c933ef8a1c4d8be9c55d84941b4ad0af2ed67adc1d9ecd6837976bb7f5475c2ddb40584153a0dce4ad6710ac3854f85f801ef468b3174e6bb2b36005b19cb0ee8d947cc6c9ea03e6fce768fe411b2168bafc7e6db5e10b3e07c551faae130bfc55e1d94c80de5b57d7e4f3f1dc974d3e6c8f0c28fca6ae76903859f0474bf04d5d79e7d875975792d14bffa5ece732221d782418c5578602b82b444fb5bb8159288c42b8ccbdefbc7506346665a67948cc4094487dd80d31a931ca877a80879cc0fa85da0745c112e3eb8149b2d9f366ca25b733e30344d895b1f69f5135a91017fcc2307905e3527618c153d53919fc852779fd819c577482adfe1234d96122d426b20005d5785b4f4d54d45c129e46c2bd66439753cf997bc8803a3396bf1953c0a705c4cccd142e3f43eebbea105be969d6c6768c639256973c17c1fb05e29872103d7e06cf80b86fb84feb3195762eb39eb1d145c364cb092944bc940556b4244a052068bc5fb0acdbe4cc1a705ffb8b40015fe632ff4ba7338495059fa172d4a16eb87794cc40da9839866d49110f7eae1604e5fbe2874bfc7861e974adb108370dc76948a24d9d232a3aa60b09183166cac474a91c4d284a96c4269072c46a004fb7bc261cd4fca188bb55cdc511bba80179f65eaabf02ef69c36cf7ec5f8b6725fcbd7db502c9c6622ed7d137cea61ae6d4963ce65a4e5057b975e4e00db8b9a4fd108c0f8be707fc2054cddbf58b30ef1e8c5f5c75d9ecaa7e237e7db21a0c5582c1403a2798ef7d0c1d715fbbba16979f282e628cfb9f57ad02965c56a062d2a9f83595880c0c53749ffb8e23194f84ff5f7adfcaeb318d3a1bf66af6af27cbfc1f7839414ee286d21dcc99df0841f20f95b8eeb575e8a313aac0af88ce80caef51e028611b8fa97d48383d9cdf3d677bc769b32b0ba32a536c586bf0a50ca5e08a11c9f0cdfec01ea1eb0c4b088165154f42b7285d340036b4c9b6b53eefbcc259f82a80d66d355ca73f2bf71045154eb0787f8faadc92f5154ad3f848e6ffe99f1ef245729dabe61a41845047d850750767d5f82897bae8c273e02d32968e771352b870bdb194e5c67ac60f253157eef8367e20ed962aed1972517e8730d6406d6268f38add0b39717ca5f5f487639d36bc55e96c7c50965a4f73a69e8a5f38d3ddc5cea92741f91ad6dcc4e8bddf5648a63a10eb24533b58fe4f3103d830e92f7569568b83e468c0071fcfdf53947a8f2936f06500eaee2ccb4fc3890399fb0098e4c242892ba9439f51a263a19d1dc2afd2c93d0ebe52897fe41ab3de5b4ea79eb16e12252a7b5f2be24e18456518782dc7c8fcd3fd66012538dc48fa4a80a11e3d4fe1678cb4b0646266502895d84327395fbbb50376bdd9b963b26ca71a4585f4afe684fddfc93182ad9c4633a7a06636eaf5472994399922e7c06f1402c226a3dbadc6afc342a4252267b3e99f061f18b4428fc78134b2a9f4e013ecd2fba9f1dd85e899c59daafd4c1a8991e44e05099d0c37e33ae0a8042443c27ab16f5198fe000efbf2085c0a2efb91c0bc301a7ac1e7979aca143138c911911b003b9787c5fe49ed625e8cc7d1c58f195ecefc684e1b73c2bd396422e3608754a1302f428ee29523b5a562664d9aeaba83973e024c6ad5251cfe28d0911d63b4ac41943aa81931dc3a260ca02363d950a4cc64312e3ce4fe0259673a94140063fbf4c382f1a481e41f6eabc9e6b53fbd4b4f56284c0147c11edb7bf26fdf9eee2879cd485af016801fa0c8e8bee212ad88857fca90f38b01b655a359c1450a7196c2da0b87d0ca85c7929bdf08b0defe6038567aec76e2ba46c02d41941605e0b0328c224129ecb17c96719972cb19f7bffacbaba2205977cfb45f21fb0dbcd5892bc6e041bd7990cad8f7d172342a735332d9c20a7c5493ca3efecde0bd330f713df2a1167a5ea2ac53aba718c9d93762f10d2663b8409be55d315bda5bfcda428f4c3c3a90f9a404ec3b129387d2f06c299d13ffb26f9ab6f11a6d42af754e205a0484a7b5f9570611d7577b663e6ae12a4c27868407bf1169c06f9fe5d1929308b183bf667ed865d1af8d32e59a86be837358a3ca014e71b3a7dd0f9597a41ba968741ef52461877314927243ac3353e63ef137255caf2fe20b9be3f44eac7d4025006300c9ac1a9ddef64e1f2aec2ce5ceacb5e497ccdb8df98cd1e2e210f420582899998e41da23e4772e794697025a1bcf6770963710a0060f9d4ce06f49384e6a102749c0c1f23116ff92f90688525be681549eb5648882dbfa4bea186ec63df640c618928a1c9b5fa6300f240dff78c25362eaba268d64ffda35b5999d3c19ceee0a05470b0bad124011127bdfe72e1dce46c8fe670e8c5c4b685ff5f8f628311f261d19bf93eec95d3dd9096325539dc68aeab60183893d655df0306327330cfc7cd588211b6ac07f6631421d6e888ab4db1463b1853a5e03b5300478c363583ee020c81c4eca2f59efc92afe461970e7f89cb459ddbe54525d2521f4043435e3cfd9b7074ce35be22fc49353383d80d8faeb3fc62c7971dcb4a7fb12da0785d68e740c9c7da9d45e16fcb9e85432de5338e9c16e4d75908b04f4e966cec3a69c462e9eae2e5831e886258390cd5e3ff260b1ebbb07499bcd81b5debdebd1e9cd30f0ee2597ebcf108754cbdea20dd61651ddec35fb3e726b9f9fe36a4cbeaf8978b46b5bdbb56443b2bb3f3f19120c18a95098af00380f8eede86a353c8c89c32ac0ec21e10086ba6e2da308e9d67dcab66be43933ae439c256ab87a207ef74e3e7650d25958fa970a0281d99f6a220dee1462e641a48e209b3c82034dc65ea5de7f79782a410c88c095ea47313d492403e59d2b55dae6a710d82a5a361fa5e971c388c627162748323bc1ff8021368ce08594c408ecad2804d2dbadd81de412252761ca836f1538e982978b453f8531e16ccac3d0465eddb0f3c920c1bab6c197a15ea6f810b5b0aca53e3604be82e6829e5b2e753d7b5be4894d54c393dad9637f3469511c2030976d8bcdf071a187762c70bd7d2add1ca4c9640cb6875e7ef5fcad1d04844b2821abe2c94d4128b232c3907d21f7f38999ce465a6c9fecd5d075ea38607df30985f5ea12d3797954206d0fa7a0acadf6f6bc8dae7df0ecf44ee204cad21a8db274b3b64c44d0e70d3eca4d8d9accd141b3b62f074f5cfc90c81ba687bfb9f82507ad5763f374d656f6cd0e6fae02fdd0e4c3784f9e864d12f8ef8a739019486349d4ce8dc1efe83de6a74cb5cd830968c596c381794cf70476d98d024e3501da096bff550d2a43a30a01545b03ee71c2ca9c144271960ad16f0d4e1a5957ca8dbea203f78876e9341b8ae06bef770cbc9b3e3a9672cee6b5368cb0eac3e454988cb9d3a0cff854c036eacd3e884b0491f2c8e5ca8163e39d8cef95ceb1ca9d0a0764b880b817164b139c274f1d1eceb0f46ecaa4071585e41af854342f6e925be5be926b5630f534624525bf878fd7bb80f896bdd3bca8257ce37f34c0befe33d62a3c6df67f401b4089e1f5676bdb8659ba806f2fa1e61246c0b53fdcb58600d9ae4e2d6ef72c7061a14af43da0f396f32553be03ddbb48eb039f5e6e25acae0026ac286f7a4bb48e2ba67e8ec84abd3e033ee339fab50eccdb36bc907443adcfdb3b435f45614f3b6692c82f83981c2209a3b974214a0d8676b91c788b071e2a6e59a7f270b0bd2d39268e82e3178962fadecd7d134ff0a06d4ab71d35b66d73dfa538c830eebc9a78862c3c84346b6252f97d66dca47c15657d67a1d759f0f8908ea2c116baeb18ca0e1cd51febc2a1f5cc1109df0b06cac866bc49f63253e10c55e79a92bdac11b69f46228fa3fabc2418b76dd632d45ab3a252e67c941028e5f60ffa8b4a1637b5a56b630a933f710d789e414771c69c50cd6fbdf51c1bbcdf5313dfc4741bf462b7872b06a51cc39a5406560fcb6f1ea4ab06dea63b1c666f4d0df10730e94d5d2a220c60ebe1ef963c3bba32bfbbd5fbe37b0c035c3e5a5e5903ea986f068493912741dc2bbd5f1c8dbc4721102502864f3f85c697c6c596cdb5e7f41ddcb813a0d8d3b96e4a22e064bf7bc185fcad39a6df210c624c413902699e4845dbebe8d7a16ab6e29a0cf58a237206995c53fbc015b0b0e6518815c0f8fc5aacad82b8b756414d248d0da44211939b8b39b3f0f445d5bcd401eefac7bcc65529fdff6543d78e28702fad2eedb5da4df515288143c9f12c7703dad05e3c88beaa5878675d47233218504e19ff98ea4f5755736c2a6b1f15dc53a9d9ea3ec7112aebb4a201828edfe6e68bcc244971be19d6a25872ea3eb3f7a3f9cb58a101333876b736b58799be4903fe58a26c14e87c606264bd37ba0faeba420bf4343b9d1b37c2f44713ce389920eb388630f48f916a9dfda01dea592c0745bc94740db8ad19288fe4f69b193e8a54b51bd45f29dc911a6929717b732bce7df3273f376a56a665328189a355ff5cd6662615ba7ea197c0a93b5c23c9c4d0922e05e4a15770ff88a9c3f4edfd8841838e45fa1008e2f73c86e8c1409d19fe0e1d29fd6e5487eec741dca12d213e0c73e38f01f9e5ac5dbddf85329bc7690fbe70dba9e10c8b88992062a2312d4ba54c49619a4b96bf07d3b251f66f50ecc3e1745e2992069eee0821f8ea73146867c0ac1d8b2df0bb3fbac249974d391f8ab1876bcf06a39b83e920079f59920ff4efdde89a8d77950f7e95624c38a0ac337b3e3847f70f22e0025873ad8accab195f5b8d92989fb7f0e5df869ced2d8e40a4cc3c687c65212629c53cd98af7e4bb4e9a612b5c433a4f441082e11fec2915926c51b3e2dc100eaac319a120201739f7815eb4c52a6131ef21829554891e0142eaa8b9b76b11f39b5b6f19ec6d2a12d7d03c959299f1d6ca818f524a493ff04aaea486b7da8c764ee0bde00ec315a83f1213114ad9804539681b9374d608b1124bd41e114d6f7374d94d58a74364fc5d5a489475c3e0ec60d8b66a7fe5ec523032fc892c3f9d4f1b229e20b69f63cfb1ddabaf9f276211ab6ac6118f9d0abbdc2ab7273b37933fc311f57462915a26325dbf0020ea82d0276a4b435260fb0e09ae51b8874434dd016ab3b68d9dda3e7c55c783efe45d364b473b5630393446a5bd47056ea3d61455945fa147bb3b7f864eaa4ce929b8af552dd0656013363015d3e1f69c179d627fb1fd8383d0bbb1f208baf717cac9122f8720403fa40197c2a1b75cf4df1cd2767f05db3c3a3261b6a9adc7c8e41abebd6631928109b4a5f25e9d95758c86b8b2b036d7fff10150c1e43261e1b23b21b21ec8403e9d7be3658fb56a1c4ba8f9ecc7daf35c0056af9eed5cc72a95a1410ad21dca327a9c26d292a9d4bea276eb0f84bbf8ea0f2d1192d0c671fc6b9fe7f65d9aa28e2e756e308cf37276d5bc790134af4a6136034766b28e5662475381bb4f20e53444060682836532edb6a7b2a8011ca286c6885b7393144b46eeb976a64268eaf79823e97a5b8c97664932a09a0440de148a78536c4eb429b31fd09e821a688bdb582702808bfeb06c581164e3aaed8a5d69de8b85093d8b4121a07f749d3e9b609ddb5b250032fbb1cbecdcd852e49d96cebd7e62e65416e1112d747a6cca36ebf0d09403bab9abbf0ad5cc42e9b5273d669fa9d77dd57a8d1f99d7b42a42e092d12a2fb2abf75ff0f60f1157e6708d47dda53b3cd4569bb5b8d3d234f6b0e4c4c085f8c82ac14a959dc488ea76c4529d8ba9043932a47ed953420a52e9e2d7a847d38b8c5123ba0ba69819219760ebd0b3c17d7b422cccddc4c562ed6c5e7b71a34ed52df75d102848aaf23c5b028e98e5a1b44b16d2c63f3bb452b796d3d8339a637b54622f9aac8d1d44758abaca8f8b398c52b8a86debdfbaae27175666e51455c33da1c64497de7eee1db53eec286cb6fa833dc023b6db9f9a7cd24fb823666f1e51c78b26e2827863c1db2950beff05c0f5cf1d0d4d344bc7974a78ad75cb114fccef7ba707261dfd1e53f654832003c1c479599ecb628401d370c3fa902680ee94ae1be6aab528c7ba6c798385646b82c30e2591785ecf0d61e4d8edc8947623c8939d8ad80404b7acbe6d4cc2a98","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
