<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3df3e82b6fa3e2754bf3dcd394d61ba818010f98e901fd4d1d9f2927aa4b47668af67235c4d8f023d01a9970f833d5a246a79690e3b708b5093f82920552bae770e12ca73305022ef6615c36ebf8428b8103e06791fb4b7ffbfeb66aaacb1c91a969be0685d5c41690cc0ea5437fc63da1c2a085d5df8a1b70806ee6d1ca1af2dcf2631ec91aeb323615565db24fda58a865b96d7423ad95d134a1990834c0013bcccec3bc0d4790f1ffb85d15b84831d212823517fc67397074659a9c33bf7321bed6399f74fa8d5be1191d5ed677e77df85b18bab6c3841ab3e9d97fb085006c31e190314fc0a2bff7f9ed84ea4106af50db13d1ff1f91518826a70490bac5afd1593ea586792bb157a237a020263026f2d0852e80e236ba43578eef9cfe3adf28c17310a9bc261d3aeed421854078f4c488d92caed4d2d34c0acb714016af17d7cf2543d781b839210d21bb9689b06d5f04b8c73da9d652a54eb7b40b569c0bbeded4c7922c4bdbd50ecdcbb23ed3b20311bc7a142c6d8d102a840ab7af2da96bfa42181f76b7a838e792299e55f659dc86017621a08ff6df813b8ef6ad5abafa1c8938ec897f225a3b6b08b2baaeef75fa5cd2c088351767f9e0ec262bb3e6b2208cf582576ee1b58f3b27da31d425efd7e8ce7cdec32f1b717ee5a0539213bb022595212a2d9f2655ca80a2a340a70535a8533a54f3223a3eb1ad2bb887e76162964da3841d410752cac182a568dde1f623a585bc35e46cb4812fc886c95f2f53ccb00a5156b568df8d9e06b0955ec0b41d9618b37fb53d6ffa5cabbbeff9c6017a03d5b8265fd2537109b2e6fa17285d40c5d43fa09c75eda9881248a07cdeb34e72d1a46f85dd01d9f13b6268ec54f6fb35809f8f9499a1a986b8249df8e318873df39a5bfebabd64093ddbef45680c71033ee0da7ea7354c8c8a2c8155c5545ebd2ec3fe57e54c10a77c1e334d96d8f3a605563b55cd901ae3e57fd1e11730fbfc4030808f1cd7eb148a9eba4d67b9ebd6efb9f293ff53b87fa06e29419009a6e24f13941f482c65e9010903acb3a6d956aaf976ca168121f719d5c5723347a537d15be06f7671876bf7b867d594b59ef66128d8a0a2e3016dac5ea21dd4cf657b38d175e5a03478a2833a8df779c0e2c8c41546b3139416a56d98e365b1bd63bf8c59dabd0421c6f085dc47fbccb241d8711b6b67fe47cf80380f4a6da4f6c57058dba877b2c2df29d24e939886fe44b04f2797161027a621c7a041fc38ddbafe17dc54873297e175c7baa49d25b83c7f6c889c5038f54997275af4ea95ea96633fb60c89f0a03827daaab2066461e0d6ea6f22f923d25e8abd6d9839159dade1fa69ae97769992b8bdb1e50abdd5b5e390f20051c95696d541e87646d522c2bb9cebe4f4ef8be02cfaa53306ca200b2e20f0b5d37d6cd8f4c0fe11ed73488bd06588249fe47eae06b2594ad92925068b90789f68186bc7070988d5cf7b1a2492feaffd48b80d434ccaf02517b0e1ead2b5d08fde3ff5864c06662e30e310c6d5f957e862de66510a9e8d21e9d99bb31c37535c096da3df07efc41aeb707343696733fa0bf118c3fb36c50305340098e32354c064c461505b5b28ea70d52c8723ce295c9e400cb195c78b352bc9d3129003dcae57bfa9edb37033c1546b030ffa1d697b09c6fe87756b872c1d813ea83c5e075375470e0e22f2a12b60404bc40dd1874936a9801e532ffc0c2d4817bff29af0bcf85ca4e5542ba63b95ed49843b7f51d6fb892ad88cbf22c8bf1817997bc9f9904bc2a31caaa6b245fa09b6e1cb33625b774dfff730a80807563bb707f30a6828d20d0f5466021ce62ddb733ce78d4287e3cc10c1ca20ddb8bfb589d963417745915fae61f9f406e729734edc2ccac1e050cac3b48102f51e51df95c16af41927f9055087da32c6de1063ccb432436b053ba8de66a7ecfcdd0a7ea830ca3edba65405fda675f7525f757b75ae1bd185caabdee11373f28431676e43d3e2a0be4c7cfa326803bb1dbf49f68bde5f94c1f626774931a6c4fe67a1904dc6eeca260d83b3e9ca33b5cee414568b0d0bba219a3fd59870b9cbde3a58df7698105dd7c6ac6358f1cb16142b9a1932d519d4637354b0361aabc58057c8c68b5294cb9df3e1c40d1ed4f00f6f44d29149ffd2c302afc6ee5d9a5e163315615ac7f5df8e82c840c89e4ef586363204c405c8d503212efa898def383938c18f105038b38dee1a509eefc94b99ad4549f85ce810c4ff369d54af454a2b95a27ff9e90b0feaacd2f4cfa2e1107805b6e81b123b178174defd38073f2d360011d2ba585711affe4e24e4be248586b2bd6d046b19a173fa699bf2baba11ec33286b34b1265d1818bfccb3208302e0312bbb62bdf8499177376e3aa672b962acb46c4d6d2cc9322fc56d19f573f7db470b6711ebb495ee1b8c0c3013771baf7dd1ea83d1b0f34ba2bbf3742797c75a2d18f3beb329274ee292266c96d259dbcffa5f5fd73ce640518c378586f8eb402f70d2dd5d139975d025ab85fcb15c2209cdea9daa824f14f7f66139fd9494c684730743ee78153c020fe0362ecb4104fe189b3d6d7629c806e79df5560418bfe49675d5f042707958fd674535f4a8c45678e361e9b0cc10e623b431835872dc63557aec9641e9e39065ccf2c7290f2d6f2b53a83f02ea0ff778997cb4f02ab5008bb53bc794d0cc8a6c76452f7fc638fa447486c8eb2979d9cebd22786becf3d6ded54abe8ab6c874b83d227649654044d18938d1ca488bf28d675108fb16994c7d4238835f35a0b74c0eca68b31a6eca0523dd2214bbe532db08b4858307ab7934bf7623147711c83e579eca97807b91f2583f8221116273eacb13667347ef349804f183e253fd566354e6b68907350a422be5cbd9268b93489f7c29fb13dd7fb436ebde01e7f61673272f929759297d31881deec70f5e4365807159371857616fa08a1b618da27436fee3cca101470e6e39d5595c5e2a6d5754c3400b2c7452c9d00937c9d2bce6b08677ef5b2bb06fe5d10bacc37366a08723d83a6527c31e26ef3dfc044647682615f1472067b99eb58b0e552b295bb4858c1bdbca87f53a280aa772ef0767e1b97c239ea4681b7adf832770b45464513636bd26a3fcd67bd90b1a1d5142880444073ecbae007af7e70e0757b1b7665c67d3eaaa5df3dece7716c0817f583a13b8af9f9d47d7d3c4162e7187f7805bbc03f27786b8098d4b339948e197e28b50c9ee07d04c99a5c56ac18d060cb15a78d2eefa534d416c1b07f119480cb8b081eb623dcb5b4b89d80df14e2b76564bc501912a831cb645b9c5ae3ac1b883b27c20407d8d01f8737c85492aebcf5ddb791e03e040d42eb8556c78a693e06cb7d6fc74b3eaf94a16c29117d22b74c5a1c7b8cfa3928d707fecb6366ca14c8ac81a75a2a782dba284df70fea5a8af552226188bba39acd5e3193efc2440f1504c1752bf1746cd458e763c1decedad35c673514f457ebed75186bc9761029559ac571f1fd7fc066034163f4e8a9e12e063f6db9eb622bd699590b130725b6d30dac32528a262bfcee8cce37c6f6d5288c944dc81bd1ecba8a151ee1920eadc81bc0753bd83880c73c401273a87f2e501ecaed3137081caa9d5d5a0a961c47e33388614c81010ec24fa1a0a571a8b56cc0d95b99b8107842ff6beb34da1c2ff1615463ed3dfb975cd6d2ddeaff9a0d457ad1a076d5c04e161cfe7b0ef944969df251a60e832385b93a4d8b91c0d360b5faa1e68a1a53e636b53ed84f36898dc045f98bb646e5afcac1a51495178ca996330c846dd8e227b351654a0532680f7c82f8a147ee0c04c1cef9c5e35da66a536b7d6ce1ebf7693e0602db69d966e249b296a204a62c5bc7af5e3e21a648ce157e45f0be50eda12bf53b448b2b68f0b71c59ff2e3933fc0a3b8c95422b659634cd0b979e3e1e929f176b499369fa1b7827b7948d8ab63d5e09953cf773e25537018dc89713fead0523b5c10e44305531634f6289da2a912f5af2dd71375b9c8afa8fd104db3b6a96f7a91cbf3cb8aa623c360f24133c2a7cfb40349bc222bb9c5a0987280603a051894b48cb8e8da1a5deeee3b5334c255f9d974dff11725db1aca5d61c130dd26dcb6a487ca8828d9c5794a8369b0b03e33d9564850f3fa661be02e9b64860c099f2e3dc009b04c458887a9a713d313b022f85d9f629aeeee99ec3ddb17c841990ac52e6168852f29e1ddec9f166a9eed4109c552034d1e7ab2d01d41b622cd7e6dd0ce36c08ac4cd790587207062358e1a4fd7f6edf0679554f885877c24b14e20d124d97debad68a505c9e21f27d9b3d3bc9f6106ef6abb52420c8dd8aa36442356396079758d50fa9c985416579b3a4a7aa12cf3b7957a89074f72e6f91f03119e0df70e0154ee55eb3afc2db65e587ae9ef458cddb2ae6236800067ec5cdaacd5870bca90b94c68a08d56319eaea6368442138bcffb43c46f9b0ea8adff8d3196780ec19640111c606a6a34dd9fba00bf1b665f8413a8fc263fefa804d6703d63983685a7d8214ccf6855edc4ed1993884bb7708a94f799d876611ab1c01c128e604fcef7812448019ee5958b9e582667468d14158d436b6953b0889825fe8727dcfa1e7b1861dd080ddf83376537604e24df1bfe5fbfb1dbb0efa9647cd27f61d8b1ec36cb4e8d1b4b30a2fd529b213d032e546d8d70af0506274d7eeba77b7463acb3a310ba84c3d8bde3dbd34664c3fbf9bea67dea370152abecfb9ba77fff2692b111e411246961af72e8882fc1298e713eba2660167ab17fb0f1e9a3e18db76a38ae739c2ade28f0921403f0e9d69e6e3ddb3c7bdfd031b79d5fd1917a94c2c23e8985b5c40b347c626da846b6d8ffe7953eec10d1f1635aa8f3d517f0b0a9e0764b2ae814a5bbabf5be14762295d881fdca871991a06d761ea3fe901eb2b3b82ed85364fcee2077da66555d796d14f51d8aba6802eb628b648a818ce36d06d054de1469367c1db02b94d4285134506f3c97deb15fb199b5c72977e9e2a83e8f318a2ace3768ed5636ed9213ba30360405157057f4a12a76aab95c866dc8d0a3240c1e2fe5ed3c8a86f0940a6ebde396bdbe5da86e30f417fe2fcb8edfbcca0d009e5ae0b74c43b2851a73a1d16f36a9640c2b5d01c1581f14f074d1422bc866a2bb888a40de3851d831d2a3f627b83da52c6f2553482dee868fdf6d7b38d0cc4235c43a2baf0d3b86e65141e84a4fb71b342ce529788fa0e24c751eb8f86f027e8bf8a23ba2a47b090693cf406ffcdc1571bb7820c34dcdefb289d3ac0d0eacb2334f9d83996c7f4b89f1826f5af2c44b8149fc0ae9c0e0b7b1ed0153d9fbf17f91700d5afe787bea0cbb1ba882ac79bff2021fda592d9b5ecd479e9940a034fcc2f425362d1bce6de7da7f20758eda581d6cf4beae574b8adca9b4d4c87001c921cef3b8d322fbabdc06a1bc0eb3705250b1445a4dddd9b95463124bd306dced52323f0a8a81d1f189a076a2f467cbfbeb4285ce7c507f64b4665c22dfed2584ca5984941517bff220bd0656d60b72f80808e2549c58789a9212755c672f2e5bddd07cf1bc421a927ff3ed00b6a00b086f933d39690d8a876d1f55e572fab959b62be7744d283ee404ad15b5230860212e160fa3d067e8712846886557dcc26b36f55073c72238cccc75ec19f01028f547fd914594fa186a0354be2076c7fdd9403e2be2893fa24e1848f238975c61477c1916e40989281c7a83ab1d6fd455261ab82c06c27e778b09e4cdccdfe07b330b046c04c4a4240655c23f524913e821de493f34d7b219ef78ca8a1aaca4dd82d15eaeba620b7cea4a2722b84eef3cee6fc7f5a63fdb49d376b47e7cf43d715087ea94166b8287641e564fd0511a344c75292209d071185198c3b4e210a8074a8d68675d2dc0fd71baac6ca372c919bb435c5f54a58404de1eb91a350942cfe82015fb2a89ab56f7cc951ccaa30880e54cdd7de1704eb2c70c73db7f6e13d122b11d3bd0b2ce5262abb0413d4b4f52c93b12b0a43c39a135f09cd1457bae8265db61a4db516fac26b99a7714af50ca20f0bcb32f8aa3818aad7930cb74aee20217a70ea227ba4bf0d316ab8b88c068009f5aac5fb96b266060b2be613c4509d2e388fbb1c50d0e2f3faa7d8eae9e2e52f8f33eb3bbc10ebd268c5a6033de1464bdefe5f5faf6193d4b9c5a952b5728468a1becbda3c23f0a3654150e4caf8fddf4606f1167b6acff1446503cf2dbfc1bb40dcebd766d587e05f38ae0ab2dff2e919cbdc37212e06c9256be3fbd07aabb66708caaf213c9f2c4e9cdabc83b61624bb3149676a5594b96718917b2ced99042c18042de0df2f3fd3db54bf5323c85c5504e59a08cd1fb36b39bb2630c2887dc61f44c25ac933ac858ecec27b0fef37adeac77c7b6660042177d199447a9eba918eb8be8ba4623323b363b31cb0b60ef97ff6afd9bfea2598a710cac297932406875639c96465526f794a79b10b94b5e34a0555a984671535def5b5c4473a58354a90f6dfb28d13a3016992f33aaed6ff6875b9139a485224845669d87b66366f6516728acc3e62cfd9d89c27d7ee715b23e57ee72c1b4195c9374f517c78f0a3af82211ebfab1c56e73a128cd04f2429e695ebee9e7ef228e1dd0c3d07d0c9a3702db840a8d48060edc984f2372341fe693bd4fe7b2f530b613f0706c94c853f69b1786e0c47f0a7169244ef42e1bc4ae2701d567ee0c37d31b5eb1bc58ac92b4a257226a27b4c7993df64be80590005bc0d7f6c26211c1c442dbd908e0c7c4c4d9eed3517c10effb1709f7dbf08341475b35c6d8ac88df0a6a51633963c531f17020bd65d81674024fa6ad7ecd1cac2d29ce162aa11b681de494cdfb92ccb7768f3ef29ab15566574d737bd20ab186fb1599d38d7cf06500fa0eb05df244420a9140dd3020213075d449c51c7fe28b379ff80abcd4cd7179547d262ddb6cb4cf0781c179e7d7521a2744d673cfc138becded7f26aa6c1fc5f094580043893195c38e7ea44711086e12a2b9ac271442a2297faa257072cfadb369968bc569c3f83c35bc3e9cc208c399fcb2c7d0c4a1f8246d9ff9cfd608067f50e2dcd1625d8d7d87e3247306de8b55ba2e57d9c16b39018ddb6d81e6c617f2d3d61afe1a1a8d99e5f62b78b91e1b682032109185a0954493794b00d563973837fd5a7522627e392127fc58f449d9cdd0d4efab09d7d62e60b8f4b80638174145691a504b0acf0054cf2f88e7c52c8decd2de235a83125f538c2d7e2bea2cd4a5b7baba4d915dae5f910fc236a33afb875d3be30d2ad08dd00c07475e275b9e3b434f88b6e88fb6c6236994860b97f0b5da87074cc980fc4b1bf6c0feda7866d9ba9cf8a2f0500df9ff95b6b99ca44e99717f5508afbfc29a6b1cf0dfb1e89256bc8ee372377b33019f87ffef8c3a804abac983ba7b7704a75e12cbb8498233341281ea1f043bbea75e8b8a53a079efb17182cf30183e44ba87a999cf9793378e85325a4f3c490d0d5e71105fe0251b41cf5677b1ef74bcb8eab6b0b07c313b5e107fad957b4f7ca5cf6e9f9117c3f56b9d70be95f139c397ce0ea9ed3452b74c8c9dd4f24085d38b9c1f9a9d805bd0db4dfc6aae4162c397450832ab01b1c2d7a7d3f2d417531fedb04ad7e7d66122f928e0d44d87ad5a45f2771cb92db21841c51b232d7747d37f42b7260752b50dbb6fd69f46fe9f7a32b1533adeea4337b0e1756505083d8ed084e972de47cc8a829b6cdd76ae8ba5ed0b8c23297f7b7043e58269c2736aa1430838c1fe2644db5c2e1279ea210bdbb918c1cc7cccabe6ac52cb44381312a6c07cf0bd8836ec62901fc990ed488ffeb8d5707d3f272ff744b6f2eb528553a434bcb3c3b170b51843b2f6b394988d7558c6478cf077008e23e130ed75af0955c42c5e1f4484d0cc831981834a99f40b5d4444bfe74baef4aec55eb553571c9e40c71536327e00c09b34b68a3c16b7f555be2f0fb4898eddf9dcddfc4bb16ec4936df2380a4acce483d09082c2deb903bc446f1a4c261cac148b2d9cf8b9992b7050abdd6c6f94deb6d8293a2a1d3ece1ad25eaa3ae883e30380bd4ad05db75bc76f7900933009b9a9d4cc06c350e21df98a5dea2318c54ed08739fb94cbbbc0937b3f80f283567b409930d0a73cbee7a918a902a3772dddd3a1459b571ed3a507b6f04be231c28cb41363e1dd618809be9c6f91cecd14b2e7a56c264388493cd2096250835d5db97217230e87adc3fb32e2d5a0bbf704565e631d4e35a6da3b309717fda075cb540069188b941a3262e3d6a3f2aa873968bc0f05f4e8e3126b4c99cd365b04e81fd5b5ec4a9e77e7744b10fae3b9d52c493aee4eb9346594625ee8b00efa9c5cad9400e3e906ed88c4a15c3d3c17794ef2c78da03812d60c562d0a717d3e2cf94bc7c936c58f8769e672303b098d73e99faf714b5464d4b807b98107f97b7103fe0cc80ce7f09a831b5c97d2cede31ae3ef2fda96fd8e382c9705c7ad251ca4481c231555c84174a8ef9ba90024d0385a5931efdd8b6957386afc92e699befb0e612f3d48a6ce0b66af80b4a150849da92d019597df0c8bbdff6b6fefd57653ea3f52694d1c989b4ae212359df81a02d54228e3e54f94866f94bfabf0b5f05033cf4f1e31e56ff2f3e263849fd4db7609e2f0b3f689fc8eb02a34f59039c347f6f7e3ec588a91aaf5187f27a9167321e711bb4ac4ae4edf7e8fe7773481ac339e6f9926ea988b381c6a99e3b434ae1c4163be36d2a1d7813a529f8ef31e7fbf20f8542468cc0227dfd937dde064dbb57b387165d0bd5f361b245b2bffc172162a6ca98d32b17a74a63c2357e0ad3d97fa08d61db09ae0fefd9a759565a8b2cfa975f9c859e9ab6f1e2d8c9da50b59948cda8520065ef8ed56bdb9b3c22940a6178b58b46c35244cfd64259785f2a715d0b07639425010194f8d72dea266537e5e000dfc1d46bd2796b1081fd073113c0f3b91ca4705614dc5636eccdfdbf5a202707c3d06b43e9175696f9f772013cda1c3f5ad8431dfc649314da260e2ea8bdb8b28de0f693e2391e893208742731c5813014949bf70a0e1d4c3e40abaeb21f9647110991c940c94ed92b04efda11902de02bdae5b23319882f5ed27e7ce310d60fd4e8d98e13adbe69730c8ddd0e548d267d61b8ee0704240deb1bc8539a5881d484a643fd697e69432af6670ae43fe8504529b7e2d94f1efedcaa111c83091ec685fe210c775ba8381dc4964d746007fac36f19d287abbddab5173bd54b1559866d66a59db7b7d879ee78595d0750d9dde695d4c027aef7e5f60badc29749af99cd9a55cf350ab76f6b8342f2bbcefb8fe7f15c9a942905bf3c1814ddc73d6f649e234069fd7dc708b792cfe662621e2c3f2c437ae00d1bf3ce1db48b1f94a49be7d02bcd686eaf54749ecd0f988e2d925529ca2c5c2bf272026100d031ae4fe7d00cf015665cc67bf803725ad9d732955072d67cb8f438ab62b56d0b5a621e04e0590c6b4514342f1c64914f3a02f85c6a1ee3b9db9081219cbd15809ad3348c8311625d55e6f88170da6fed7236bd03688f8d03fe66794682fa4f819da5929a90694d3d996621d9a15cb779028b7333a478572f6c4a66878b4dd1c538aa803c9ea80953dcf6c7356814ab724571d5d978eb87887a4793e0a43e200e404e6043704a4eaa576f8d9745ff3a8655b3dacd88b81aaab1751b11badda429c8f0120cd41f8d3e35e94eea7c9ee4f2c50b47597836d6487345f9e5fe7b176e257992be114f36474fd819f8bfb7362fe37e0426cba874d6607aae119f7f750a5c76e2ae12028696a83ee3c64f2d8d7547b9784a5a6d1e1cc455ab5aff733a196788dfce57d4983c7b20eb5f98ff766ed80404fe20fdc4bb78d8d8f7445ed2728e95bddf0f9bb47e7e3f4ad2ea99f541e4bdf884c4a46cc7602de808854aa22f519f6da84c769463c1d13bc3a8cbdd417f010588a8c2edd4b5fa53c68a0b9df26a624900e5f3709b40c73ffe49bd1fa1ef8d623325230b762779e83240c606a99f5a1a6790e15abc2ef2fa6922568e6e14a4302848d78dcd9822e3af50d60e1d7c6662ed9679bb09029c132b547594f653c94d1a8ffe75ac6f209b9f3187b876d73ad5f3e55200f49b77d8cbae4a49a0deaf8bec3a1628e13d2c516431d11cf4daea47271156e4d0b8c7cc71bc87170c3a162b74ee58576e1f4dee618205e77ce211c7b02ef955f18a4fefdc636815e615e7389a1661affb7fc7231cd4bbf58dc47a76fd7650e177cb387c0e4df69eb23403583189a3810e3a8b32c28378bab5657004ed55bd30d5732f92a2d2aa49c49dcfb388a0827aed0be87ff452cb4f6dceb82af7e21f57acf3a011d4497e908a8592fa2f0c650045ebddfc6b589a0ee4bc62d5222e3bad7d22a6b16c12efed48e9c91fe032ec1942e7d8851d4e2f330e802d7f25cf7714a45163d2c7425fe7a75f9cf7201468494f180875859a7837ea2ee6296f35d1200a8fce630228275678f65399b2c0b81665b088f4c6b754b6a525e1b49ca86e09afea3057d8501646bf2a150e9c2ef40a84641ca541ac01886f0cffd0fcd025f294c699d4efb8c03828fece4dd78d5af71f380779c17174700ae9bf4e3aac21640c9be2105a77f2f494b78c1c98cb00d225c21e25d2da790b1715012312ec25c17fd10ccebc3fec693c661b3604d94f10a1cfec037b48ad723c1b4c6c820bf6f6f53886877430513a54dc855c1001cee354c20110105f00602342950a9a87120798d98877be1e56e09c0d3721c4ed9d46c60712f35a9d8d9184c30976ae9c7f4fbc8beec983db14f0ecc6c3d7733a7ba88871319d60da246e56be8c69a70436d3d4596637f6830ddea2089133c50bf59b1606e17c2c83804b223dd80b51e0be6e900296aae82101504e104627b5691c00e6fd42fe914fab0b69d4c8c54dad271f5b575ab9cc37488e74fb41c29df3f75320fadc7d7da86e5ae6824008908a08dce4077a0ea2319dbc50568d0c940a7afa789d60f1bf9b3231df52468f826e0526ce083e3f59ad726e3fde654d96258bf2973bdfc7b59bb132ffb898a700e50282ba783a55831f53d60f05b999a1a35d77f871cad48a1411f7874221d64a853c332a0b32e410b637509cbb82daf21b6ff5620fea6936a1cd354da6c2f3d023bf74972d7dc402668c033fc72c25001fc185c3c28b123a89e8f5b1210398701360756931d390582c8a767b82a5157af0f578c266b5b337d70eb6aaa55d7e072b3bfde4c60bb1612ea3bd03aae6750bf6a4b498c90d7a1fe3824ee60598525b673cf20d105d21bd63be49327b69336d97e37c2813688fbcd6e28435ff7b8f90f7c3b8c690576372f692c9e347079e2968664fe57d7ce0ce5f6229ad364f4b4ca52157bfc93c76bb6f2d9eb2a3554cb0fb3282ac71e1c72c18454b5085a043cabd68262ea063fd05584700c898ccdb4a932d0d6d1375478d07b92a27df40ec7ba32917aaec2803374b28c23c00b02f2a2c32e3a16c3771e0669acb9fb7a82ac286d396b6585cdc1d7239cb92731b2d66705501182eb6b1fec3515e046216fe6355b1edb4d53c8d256a8e2fc3a0b07f62691389d357be208d186c51b99d54e57b6cc2646cf325b5c29e87fcda945574e18d4fbe05d3c27f7d3eeb7933bf0e0794b313382a37784a5d6b1c73c06cd007422443fa85d22727d7412a45f71810cc9086a3ec70539a33638353fdd72b2718e84eeea9f5eb28f448adfa5d51251b5164a7205562e5898ca666338cdfee99025c3efb4d7cfebdff2ee2524040ad5ad66316915703dcec5c18099ef7c5a91270486ca17a5c1a0fd45632dd02dbfa8e35f2ee3335a69d042202c5524b1830d16a59477f3a6902e8047aa523bcac8652236bb2b46d76bbf97afc1aef5072722b48edf21d9b2e6d2c30074df898f42dabd3cb6454348a00b39f3591ec2acbe794a37119a70d32a59bde398c3ec0c7f0e638fe5c1f7789da4ccae30762c7062da6a3221d791305968be9052149c5139dc471ce9b6259a7b1cf0bf251fa696874d3c89a959fc6830952e6ba9fb425211b5c22431b34db33f882d394b6caa23bc423baf0bdb8640f5c5eeaf609472a6dbcddd9efb9366eb92fa28efc6fb9c0b9889f08ddb17ad7b505e9b005ca04aca093e38a09be9933b048c73677551928990b5bb7a0fad340e34f62df11a36cc42beb38824217e4b201a6d39725a54605dc227efd2b6f0e29e2e571283237522009eca9e9b2206390aa7b94ee0a6dc91139d98cac2949d123b4466d632207eab9a3c9892eaaf98e0fb0ba6c275bfa172028cfb8894064fa6c1e8cc884f30edbe97e7b8b30adc4a2e1802d77cb4ac5a7adb57281b607b577b0e3b371a056f72ebe38fede6dbcabdf17430fc1ea6693bc5e8190853028599e537b90b7a8375b462e0ca7f7258d06304d364d8c633f33530bc44fc0c8ec70f1ad6ba0ccf70655495ebefae8504af286a47b7dd1ad121816a3fb509885e71a15c539a0a48513475e82f915a5710f446ef91c77c2b8f20bcd0175953a326d044f23da485f0ac852652ae95871961781cb358a17e6f3105fbd5b88795d43eddc999d58e40ca45a7c4e73f07717c0ec60bc161f285f10068af0a3010fcb160ebf39f1445d5c10a316df892335c133e2ccdf16fe36649ebc885b2118302b88f79035627327a74cde85b15ebf2df61eecf52df54c07e93aa472b097307bf9924221cd8d81e0abfb6bb398e02be5c461eb6d66fd355a1d5ae36a77f87790dc473fb7ebcaccee4da6597230fe5626527137b5204bd8b5a824ab4919448b7ffa5cc8baafdb459153bf80cb0dd9d26b5d207f384412ca5c6e433eb62f854ef0c14842744c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
