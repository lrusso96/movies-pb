<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5b83f950374fd4795575373e437340869d98e5e268a6298800b31fe822875fc8d7fed2f239971e444f4f58c7506861f24ebf8f089d8de335c8a6592f0c4afbf4d916ad970b89c30b77a642353d787aa9fb879024fda4b086ef02d7a34142b7ecca05d1f7a601d81013c298e033a0cd58e9a167fad5b6986f04d6bea8fd0e9918897ad54e9babe7b46b48d126f570fddf88af26878a405b7bfa0ad4637b7af423ad92eb0e4d39e3d0b702d69695e0ae4ecae792020025c2962a12416abb269b6780c881fb001f666fbed15be4d621a30d219ba4f8e783d3181bd95c908f68751203d634dd926788d15ad7767eae68eca2568bd948b79ef52963cd7105b63d0ad52d9a0a80c63849dcd94998f57e88e28350ec5bc449ad269ce63af92726bf18bf78af3993bf90df8e5fe4aba95df29e2facc53236248520af682f2c696c5abed32e63d793752a58426f0d29582c0a7902073ffa10f62dcb9257e6bdfbcd1af46adb84ca32dd1a72bfa3530917e5d4d7c674af7ddd6196140a2f21754612ba1f5540a5a92aa58a9e706f6379029365fafdd7da61710e63b04ff001c9c65455e361d57d103e2b2cbc92c4ea0fccba0861d3d72fc6b513e7aec3a92d78057b6a731093b0faa85c74d11ecd4c1febfb701dbd29c1f32b35712d0b430c51cd9df3a4b75005c6d50591182642a6357b047530dc74c9306d5773510b339bd974e8b689d666ce4b6d33e975b124db4e3bd642ae0d459e9229d6df185d0c1c4d553daa5b21359305871faabd84261084d050b33ad59092a5740915c2809e1f40d2b24e8cc76423e17f5e3717c5ceb52db58709e7c9950814db6587cf6ad244833f9c49530109ab7e7e85cfb7cbe4ef582c1d9ee2e6137e7f0b992fa4d4755f931fbb2606d0a053919cddc3e1608d5cdb924bbd30675b1dfeb817720eff642bd5875ec25f0aea44789e9e6e9c781f0ed4b32ddaa14bdd1003f524fdc9929d1b962c730e957ed71a551676500e01414b75fa82bf688b6d2da2c4703882ea9a01db5b15597a8feeabcff8d6b23174bd4b1d3b0483313d2ad71d0149f3268e51f4e65c50914c2f8d1139e189676a9cd6a5d019f02cfdcc0d25b49b399308d6f70bdbf7e1cc68856c5a03ebd941386017fb43b33669df19bed38d4e9842086c9fedf0032fea35924402ce12ea21e2fe5cef1828152b077883842e34904ea473a40366d3ed6e68341588d2a41dacc95317429b1a47c2e4855730f2624f99ef9af2740dffe5a634c7bf85f399f8d77e8955028129c4203b9f8736feaf3b3b221aa66af6b41b08904f56b562dfeec09f7a31b140434afdcf60ae55947ff72d2adb9cc6713770a46cc3337821e86df0d93dbfe64bf8d0f7d5df4750443a656f1202bff981547184cef9b6149561407f97d2a967a64b48591531879efbba01f5677b556d986d589bf1f66210097169c45bda9b0b831d64463337d88aefdcabbd9b977699fdfd1d32dca1279f894e93aca44999caac1e401bf0c61af46c1a86fdc15b6a2dd10825b3a9806f96481ea369354109a1f59a572719719edca8493422552c54ea8e9ed06760f5e0330821f869e838aa8241c0795038a286575e54afb1f766fcbe516ce01da6538a938c8dac7aa07dc4ef367a467a6085977257d00921341b55f5174bc134f5962e4dc75abdcfac7aa7e0abff1c62bd072a23094fb6fcb4b90ca62dc6573534e9109f73be944a980d209d19e3d7dc447872f57e6e12672e057d51bacbfc377ee917bdd85ad8b0196c75150321380b9f6d97c74c129f83458b5608398ba13e604db28495304de04833133fef41ef0d161542e7fa3bb886f11bd30791418d72b56fce070b4ba577aa02452c26bc5705518ecd10a1779ddd8d22e92f531154ee168154d4ddeacc7cc626d8e6753e8b76ecad2dad7df21fdd9d599f7d2d8e2d7fe13065eac44f62a85bcbbfa90fdaf7c8a5fcc28e3bd1d612121893219c128f18c379f1703427c85d99cd76eebed0f2902ae2535733d625a015e642d4ef04bb19dbf471f35bdee0b45c3266307d77c8c6a7c7cd503aa4e66606f8bfee7bd38d9005327c2bfac2ed2f923c9ca9b1c498b284039079374ac0c25c861e86e9eed70071326630622dc7b2bc10d96e0812a3cff4517ddc60e16ceceaf80c4f7db2d62e3ca6b02048d47b3a049835b1a5f2c2902359e7f280834c32a9debd9699d83cd6ba88a5bb90df2d1562fd088360b51c4038dcb5c7c6e4f026a403d7ea11144846a184bec1c7fedfaf4ceb12bf6fda3156d9160bdfee6d1e8aefb2cd80b604f56c242a50309881b32b88adb3f5ded6fd5a85123fcd50d22fcd6718b084c2a2f8509cfe539ddae6785917b1567d6b083b3eb3e615c66a552b4931a9bd54159e67fb29add68219bcc888105c582c7782274e31e8469ce1a02e4af55bb61556d73ae1f16c967abb6be10e58bb61abe4b9a56fbf5a2322624f962032a1682ecec426e50e646ba3ee57defdd6f38cc324ca4e7f25666a7c1db1ea5cba1e1b7fc91c9824e4fb276e6a51e9ad007b6cb6b13be90df225f40c4756a9a05225c8b2be45159112d67f30099b655783c2801479a020a95c402cf5564eab3e9f650bef5540562068e62f935ea0d78aad2a8113c5af97d581b2fea11943376b17eea78a14aa8c71fdde74569c85255513c489ac894550968e43bd5085d3df11e73a8d854406c6c7508c7be397a34e458a3428aee6b337a9165aa4b66f9d0cdb0612335efcc601864967ba83e4813fd446496bf1951a328978cde65ef76269cbb910f0631d51d6ad02ed5d815b2aa38482187fcbb75dfd5c1cbb2ac07ca9c80826a0db3c3bf089a124ee338091f4b559b41615c6f24e402de95dc924383e94e81a570aa4466e5453f315f31d54e4cb065e36d99ee67bfb325a7ffe9973c406c78d77836e37c3609825c6b7bb6a32dd31aa8af3679ce0346089847360e80b9a480c63e5a0b7842e67bdc7bf9a0d27425f0d9f24d8bb041ebd8be84e3e427e95ebef023391652d717c487415235448784e4be79ba5346c0c7aaad3ddc18a696a4301967b8872e3889eda5f3998fb5eea90d9829c9d6a3cc857c5722f6487137afcb385fdd378e26692cc96b4350027427c2d34841d401555c68cc34973ff1e67dea6bcc2855dc73470912a8e7f9df72710d849863d92d5ceed281a9738192cdcd4f37dca18aa48944bab63e5e610b245a0ef3c97501c0c5d8cb56386b6126ff7babb25c8bcad46f696d97287761f2edf31068cf39e182ecf86cf4be5d6737143801560fdb02402a0466d14da26fab79a634090c65f357f68bd7142510f53cf518026d6503d39b5d90680bbaf8932678aa2a34984ba36d19509b2a84d7343af6372f6f880517a20b52846b59dff7b7d4c91788d773099e3844b83d4d30306a002f3a592fb67011629e8da18b6f0ad1afae313a9c7a48f7a6b947f913c1f41394d98129a99ceb60461833acfff89bff3f04f7a610095d16ba0fb4e7e8194446981656a2fa9677aa69cbb85d51bc6a4b5a89e4fe3a7e907be380b38f1ea5ea1fbc6422c778a55f1141bd7dd1714639b62fa7bbc23538c0aac845a26d7d105662b422e370c2745e59a47025394a1b3c05631ebd128dd877d3d47084856bfa4626fb63daa922ac249981d182354d2e2d48cea56e41ba0edba8576c9076163992097a4c7491ba4460bc23eb4025e4419ba4ee6a100c2aaaadc175f275a599e075acb66bbc3df5108192dd9e6642a093205c79d67a1bbd9ccaefa54369914743d18ff84800eca88d13e170f2602acc9cdbc570e331fc28eca33885d6b63804081ac46e07430b92295583ae129c20bd4d8331d0a79c4a5323e77ed726b897a76571254485147479e22ea78a4be668386796dd720239783bb00b8d9295b96c88fdd81c1603866b0172169eed5e964effbfcbf39c77c5346fea60a932694de81c6ea2db7f3d014e2256927f45cdd3e696869349d65b0a8266c8a1ef93d977be220feee89c5280b68b19e280f829f1dddf41bd96d6959e19f94501f79a9702fadafa649aafebc5228117c9491f3347ad28dd5da538149be5da7762614ef8a3bf1447a9729d43adee6ddf4f00439ab0ece3eee86b5b77eee14e9f91595cf96072c30cfc5fbb055c4663b2317a535588adaf533c5ce5c212fd80d4db67b44bdc649a0f7febfaab9e9b3288346d20d13db50bbcc6a344ef4ae42f4e9e56f24bd2f0da2a62d9c38df8f9ff1f588e336efee7b6b7be6b6e2a1ad34210365e83876743f3479b02a8a8fc77704173803fd0fc17522e29d49ccb0b1b8c2d5da7c26195fb5e50a4549028bd6c10e4ad692eb6539ad8b720155b52fef2eff96883b56fa8551096d40a16563c4a58a219bc9f3b1704e6c39bed0acccbe85ae77b0b2c4371fcc4e4fdc52fe53cbc3beb9165a8a57e86f26e0045c82c0912e2877f4f8bf8da7c9e84cbd135860ec0e5c8263a5786c5693bcf9c245db2958e3958c369e8d26e880d74c1f56d7d97e7bd3683572eb1603c115fbd77c39aeb22c404c2f31d67d2673b630f5bf73179fac783b5b3e24d9753efe90c2a9c0f9b814c755a88473b3d41db72c40813905a0eb8d632834783059b0514f51ccccd6462aa5d305c0213edc3a8f9233cd6cec1f403108b8bac5b5507aac2de141097080aa953f066db904a3b53762f336715b1a496a81adeeb2e21ee88732b0e2f6b774c3fe58bc47c1b04af2272078d39db93f5f448af0fa4eb96487ad00dd48d51dcee7cfd37ef97fdcc3f962dee40fea3e2a3dc72fa612e076d1b5d3198528d263cc534e7c31ee3ae13370a49c2ceaadc974e6676c928cf73641088c4f2ec60c22e8889326c405efd94a01dbd274990ed4b39f3d9585cd9729116fecdd30eb7270d7dbcae77a088a4dfe44b4154cc8d2613b83b68df44022f9173770ee7c44c1e84d6ad604274c3bac927e0a5ff395dc5215015db315d8e31e3c3ffd736ab2ab85d17b1c1973cae321213790f72ee659f3af9a400a61e8ca2d256699d205ac944a16ec9c137cc982e3b5908c256e50f53a7f21b0d005b24e183dc5b10ef6488a29f7c4933c2361833670e01e5e319a8af1699ce7f94484a4f71194eeee873d094ca1d6c7e0cfc7831cb249f2ca1a8f04efb8d9967d878daebbbd00848702f61cea0c272050c9565ca068bbdb13b5f307d6e4dded41f59033dfb14d3da1fbecfb6db1198ed4a6d9e07d7078f5a066a44571fb31f81154558b5f93de13fc8785313bf6d9125536a259342415c2c7de3bb726ffed094be8741ca644cda43bd9f6caf137647314475c1a9635f20de33542d5d17b8b194bb00fcc70cd1e5c753e3e5d7b513306a01e0619b5c738016b16b8b10cff134b1a8ddd9c31b19295dab7c88c446bb8e48df75e4fcef63688fdb19be74e3ab3b31949a7f29d1601697243ece08c17ff92c2eb32bf67fdf16b5dc758def346f4753651496fbe6a5bced9b583d4401283bbc0a21bc383e6c752bf392d305e6ca73124b93298c814238ad92cd8942d77b8832181a676e55dcb4f6b49ab0d27dc0c08b94a43ef1f51e7384e78fc57f80821d0dd132e438afd6319959a7f6afb440e15a51fc85304c46eec2687be04db060ec009c7f4135fca73a441c64dea22627177f45c303e7db2943a3e7994b0933bb0efc7263623e184781620b69f7a06d555d0db6b439d9adbad2375bdbd5d72e5e6e1825727e26f018b413d4e4157c2da74e196c8edc6866f652e2aad98ab575e6d48838abdfd64ba064c128fb59e557dcab0a8b0a8c3d5ae080d7091e5d74681b61601da8a6bdf1773c203958aa8da62b66782807214e1d81ba66a043099494adeb86fb9fbf46282af444d50f6f2af0d5e73f967e4c239683ebeacd4d2dd005f3655be277a3e61143fbf724427882d89f8a4211595e14d8d3634aa7826c30404d004642d0e26f9b1bc7d0e862cf6365ccca1d202c71c1ed15a9d8da036d7000072419869dd4b529cd8a5fd8d929e4fc7b5e41c091a481084fc19bbbf51b90bc9d8805c9d9d6ac2707418cd698fa42d4ac0bfe0c49369eb41ad7f1ed96e7dfa755dfc51b4d1791da967d9e20a75bef197a4f01e504f5e3b788aac4f487945954ed54f7ed600245d07c2c110576819782d425f9c8979b6297ac59f1a5df45b7e9a64261c69402cb472b70f05bc48686d8b78fba8b72349e6752f357d6918d60ed585c88f6db68bc3126fe445bd78e76d66df9ce90057382d695d7ad10ce0f42221f2c1df14f914511da06fc5c10c10d86e350a9b733440630e371e331edfd695170ba735381c9dda5d1d3a208870e048205cf6dc46ce1d842ecebec47ffe5f809089cae0b5eb6a8b9b836313ed27dfba9604029563a106472ed63bef985668cf6d95827efd2342907dc8eea0762fa68634f6af24295f0e4fa2a7a8569076792d102df29ea38c93954eefc55554f7c388c28b61a458f951a5e6e196a7e9fea3302baa6dbd2300e543ad4a12404f8126822f76d7b70129ff4a870db8ff25eeb8e7ef9e9907ab13b09168257cdad91196315df444e387b8d1c7eabb065417e2ce5fc732c9c53f3d9a9e42cbd69f752f6e3bdaf04ee7860f464ca4ca8ac923c5f3651a356b407fdb5e53913db85b2376d5854b5d522c3234709487c344485023c4a55a876e4b98f9e2e63b3f9aa10cb1f8549644a7b3fa951a107eabf88b0246cb5a8c388f725a62a61ccb3d55bbfdd130cb53cd0949a02bef329e3606bdfd529140d1c27560136f8699981fce9887606e7f2f01d3ae76e70c4192a5038a0e5d39a871708c3c57826c691bd9b764cdad5b8f9fc7edbb5c1436fbf37864692a2152e39c9d8c01855bf79253c8b1adcb6ebee360bd5c872ce656dce42b08a305726b07246a17c728f6bfb70b66d636f1e46f2c7020e2c4f7d4b49097de071787205b3f3c96ed062d533c3bfd8745f71d0a21148d3eeaaf8cfae98e97bda84c51bb614c704938dfad308b26c1493f5ac45603fbd1309677d7cfcbea6ae006eb53397225826a99154e0c1a22547a27b1ad1e5f54d4f8db7e40d41ac6401af0b5beaaf71a3e19023a8fec6c846762410c5fddd731793caaa5d7d42374635b93815f61c4dfcbe4ef9f7e2a8170f0b76921e78b706d1b7d98ed60180947a177f294c7c32e42fbf4f6d96c3fb8c9765b2869439cd196f3c0aa2833b786eeb1dd41818c188d8f30a03b09e11a93710688a66b4d1b7a338e69898181f0b8692f401a3032e9f775180bbc420ee10fee8646e3c6c15a4f0e4ca9895482da433a1d8d291751a574850a507d126c36b6b706da19a270e613d9cc61c82c5178e85b667340c5d50b5818b1b55eb3392f25d5942aa6aa3c8d7c333333fba86f76dec33ba96cded9b0b3ae5cf19b2acb264baf0c6e50b75c4eb4c0dc2f024bebea8ccf6e957abc1487f13eeb1ea30263863ec836dae5e08bad1bc2ff2e013a6cc3968ff40602fb4fce1b55a0989103bd7c36382f056ace2865285d015206ba9b0125850c235863574a7f0c326f24ac78b202c796ede2e033a91d9f7cad81fdf66a99ee58d7ee359433e38354d62aaf43b8122b4ee72267f8e4c1f1df0753f57f3a4368b3487a40dd3ffdf9c419f0d5bcf1d2dcaee4af03d19da8c32b6d13b7957cee0de71a32d76fce4972d996cb00c3380eee245adcf369290d38a7d2ed2cdefc0a0a560a689dcb5de230bd32f7d27c93072c36112dcf0d6a2afeb10e1bbde1a486846322120b0ed65e6657c37e99c34c2e56d2fac7c703e1642ae6ee215fa33138c75926503e7fe6b46845ac40a1c7684fb0412669d041f7eeb76743c5886686a873e070aff246b50169e7b1481d2fc1dc3fefdf89ca9aee31a08b3a6346893846dd2364abc117f6d9784a44182ba162280546fba849556fd2e7e1c73e98221b6e6d1921b75645c006f69f5c588d27e1d93a8457feeb4e61dbdc884e063ebea29dc921377476db443d312ae9c9a0792da472e491683c5cc2b43352f9514c9f5fc0774c4187c5c678a4f36fb4a28b00e22aee84d1a18d1689584b810eb68e8c895e42b966e316c31ad572feadc4fb0c303fe452b6c226e416edafbe86c5fc5f014d68bc97d45b827ca066ace4f23781224040e4d887beece6a2631c4cc538d1e3932b2f1c23fedbd8d9a1e054c5115ef21501c5ec0cfa6507bd115f563d5c851571e6f648b1ca6fac423287edfb1dd740484d0c491f5a0dd7c5e1bd7aa20fce79ac33f20a8f72a4e2a57e23992254b3cf04036fc0dbd4d5227f8b9aa52c79b6cd746efc2261af8641edafc7853c37519ab798f989ed3ba183ccc39ad07a284777bb0df9ca1d18f97f7dea6e3c24b596fb823f0463d662e43ee0627e66311e896d9008bc2895304c08ec8ca7c650b482fbaf8016d508496ed6b2354bfc0a4b8d5379579c41201c3cc9f2bda18d4205c049420ed450345692b9c2ebeb2cfc09bf94e52768545507c14937f793b0295e91a35142b6f580b22e22be3c9447016322c0e2670e88421e5ab678e5278c521f601863ab458676eee932892763fcbf4f0ffc386efb39846d09aadfdbbd2bf26380999ffab9de34b8dcbfb93d8559af7c0b419c209c7656e29b0048ce8e0c5d00b8dd4801c052e93e3586bd5c7a64a7161b60665d9ad160bfc2982f89e41d7460d5687d92a0df84fc3247835981f882aad99129f509a425d0ab9f3db69f749ab4090ed54613a749b097f437ec8a41c0e585893275472bd9ec8ddbde2b3897da7ef2f3334fa62deb62a92006b8ada0edde61d58ae72e72636971ddaf59497e392c5c8a2f088931413f01a072f5980dd835bbbbd9f9bb04fc70fd094c2eaf850326ea30035695432a3af69065207092dd17f3e565e90fda3c353f1de9046ddc2208466f6a3046ea65a007cc97e89c7910bd4e44cfcf1026742823e6c724afe85752d7f29c7c78e1d32e523f8712930fde2eb5239be691edc6c11ba7a48c15e7e38b8a86c3a86a90d39a39c73f6bdfea01b456761d46cf455455377d5ac742ae4bffae6160ea0523e7fd89f44f57c357efd83ad4db5a5b1a4c0a5fde4f6e6e6625bfb890edbc5cacef41b3e2c2816ef179ae12a605369d1f16290e53e5942739d04740576f2454e6762e21f3b5a790346bbccd4833f1d50661ea0dc34f07ccc08f81af464d9049e07f04f8e1a72f378b3c11615955a213b1b65924a50b912809a76a275a3e3b92cb69b5d733b47ff7c28b8e54d8ecf1c52ea61c0758fdb0423a8e04c544b09b98e0c454f2a10f96cfa84c7c00917eaa947414d6baf66221e9f870e6280008aad3fa7b16c89152c4f0a6f9df13e365c09ab989b009ab29ea12e81d7637c0ac8dbedfd2ef86414c54273b53dc95483140221553fa73e1e0515abb24fc047a814bcb312f5d9503693474e4ac2368f500124a3b1a28bca60e1510212ae153be7a9fd23f303ee136a7db9b1fc14969ce4dd9b20beac5da62de67f8d4931f5ac183b43c6c80a268feb0785f6f62a5aafd013dff2da50047a80a05ab13f387033c3dfa05540111b72d19852c4e0b7fead9a1c1e0577021a389fe717cc26b9638aa7c65bc1678f4105bbcd649874792bf037d66855e5587282588a515e2404ae2d2c844957765b84e6ee244dd7754ff4a257b92bfcfe3fb95cccccca5e5ca68a02d3778a0df1f93d0e1c2fc83362c50df11e9a8e45bcc959ebebb7ecb0f9cf784e3c79f4edb1ef409b4baa7698db7eb603cf02046cdf41b0a27396b4669b08dc6cb1e0969c38a894bd54dfc157a5aaf334915dcadc96c9b5bbd5eb7f8d6fc4f129903419c95b0656712175fb855c5df7a1daced047588cec9fa1faf99ca89c27880abf1ec399008c1824994ac9a4a882090bd4bee50c99bcbf956d6120cd8e0fbf15057ef9b183b56d399f158e5d1636130c661c52b307b7334c53088bc89976b0219d67e6d93e2aa683ff4b99c10884e5ba1e52977fd0c274b680a30ec8363a262949c4a55dfea2f88cc350374fd4889712211174d173aa08b99e1b9019af3dd1131c2387e99e457e1bbeabdf1eb92f9b079d7119c6e244abb0ba9640cdf498211ec7c3c2b342262a73aedbb71ea9f3295ec201e3fa8c28de2cac71fe120e1ad67617ffe415fbd8df3cb5e53c598b95fe2e228232b3d21aef0c93e6800f59e62ca7fa5a1c68cbd4624c5f541e62f7eb2de1f16f96ac0db8f99e9b1f1a337bf2a09eed4b8993c494ca9feca67b5d5bb0f4264caf1b622c12c205f3529d3b7a8ada50a1261ee90d670ddcfe75e6a15d64e130283290e99789fea15bb5ffde8fac350ddb79797c007e75a63f1bd0a3a38e9a82803e0eb73c1efdc222f055c9109958cc6dc631d5c144db1fecd2221ed0fa24ea41920d45f987e5f46c0426aa371fb114d8eff00c576aeca4e4f62ea437e7befd785b27def0da558fba29f2f9b8eb3154e48de03cd75a7029514d3371b8460e8957ffb04ba7395814b1ddb82f639d2f51ce0b4035ab1f783fa2da0606ec646a24654bb77a331ccb5335c272c35a175499c06b7c6066a3665f58ea7d61557ae946ca3b76c3ab24375e6284dd93863b8ca07322df5a727227c1ec3d070a28176b4ec8c92fe40d1a50ed7253dfb956c99ae24224bb256c456f7b9861dcbdb3c87113a8cfe25d0d52e5d5f45a57c71c6b779e556e58d84c2e8b72a4ee1ef5599da1f0871522f9dc3e600cba5c9b06110b99dabb8a81bd0da824c2472d041b1cbda7c15e0860a2fbcce54b3e5212761ff733e80f9fc9adf54f6e9c3e10ad501a8a43d3604b446ba9d7b43faac43409b23f4900603683d95c86ea638f0f8a7fd67f8de04572b4bd4bb59c15519dc518023f09cc8b200513eadea22aad044bc54582055bcbe19b545d80276a251477bfed01ad50c1c1a9c72bb25b973d311267c905fa2affbcb24e8a9542e029efa2d8b2393825cd58a73bc885421711dafad63a35e3f513aa9d205c98df4f89f5af77ccd2b9555fe6df1442a7ef40a56dcf632588878eebf729032f6498038088b72b88845e18bdfa293cfffde96f9e2b5641662c06507362ece0b0f395f042c59333ac88b70ecc46199bb82faf162e8b6e888bfa2acf1ccc67295a2d95c10cb9ebc4659c047b9c9b432c78128424dec5983b5491a3621ae40e99354262d98c11937316f68339b5eccd7b944a2af24dd28c9c6ec299a6fa22d3ff25395c715f323334513e56368fd626a942d6be9cc1e08cbb47ee87ffceaf51c1f6f4d3a01d93e9bfc5bf77f7cd2efffd3c6e137a7b8848d8f641355ec39411202b75b801dfa201e41ecd8110df77763ce3d3e00fca00106c375d149cc1d87145edbe5541d598c4ac5505ce14bab13ab77aaaf29497c95132b7f5f9506c8674637f432f3dfc97b71e7c55f9bc96a13b355fa6bc679b9db93844f83c290ad51e1708bb48f1fb4c7070a4b991164e49b46a68a0b7da0e664f38c9d5a427f175710faaa43c9b3213b862cfcc372f78792cf2eb148510d185f1659dc6e3e2a909a75367707bcf10b3eb7f5b147469e664add33e0b1ccbc0e383bc38c850b1c47cc033d38950345585d6faab48fe11aa98f013355f262da952ba8f8b6bcfd82926a64f755c1f3bf9cca68bf6e19e03bdee1941b15788d7027ce2f95d4621269299078d17fc0c0c4a690cb3b05cf0715783b61efe597cc5867dd55c97ed6334f1d2ad94a25b4b4fd1d18eae2d845ac020a8b4f9da514530f4cf70c58633df06dba1128067b1e2817e95567fa508fa85dc661a58cfb7c89db97315703686639f2366b99f44b32d3b86df721a806a2b51cbe5f0b56c82400189d0241be3bf763e02d60127ef41a34a9e5d7bd5f560047953f03bf107b3f884231d7e4d145032faac11fa13f1479e6dddb28652f5829502f926f66e09edb918447cecc13b26d97785f7808d01cf156dd750e827fdb6171503889aab46ba504721db93226562ae1adbd6b5b35a4aa97e3c42f5bc21893d888c167d8d0dacada6a6cb9528683100e1b683164d1f8ca9c793363048141805f35aa5dd9f91d9d4fd32769442d7a3bb4ef004545bf1a8ef06112dfd64b878a83948760e56cbb7c7b9536d7a743e23c97584a39d18fb80e3a0617326ba42e0d05609ce56fd6da2d37b0363cc85efee6c0162a7979366740251187c9a8242e61d6dbc528366cc3627b8bebf05b277200158baffe3450756795a95f90aaaf40a72e4f32712e3cd9c5de64cd8f9e43e6cc66e4678c968bd9846a0486818c613de7735494ab8055ae6934abd27f22050e58313bc90ee3078ebc298aed227e65d1c6603eda52782f2f91f2926e903117f7a7d78b5095b10e4f2353cffbee7f12365142b1746a9beb86a7ea1dd7bb2475fffffcfc0151cb4b55d16b42d5f44fb015be4d3cdae065cb851819d86a19867300cdd6ed7a3e00780a4a32d27fb98f5ccc2dacc964ed6cc030fbf0e8e99dafe52d09670bda43d20c8188abc9c71cebfbb5f744422ea826c180ed7656273a3c7a08d5dc990180990e99d7404443ec902b6183693d469a2d77e6beeb795c15b170a20fae9c9b2f1611c2d1981842d5e69212705a527b5d063fc650f2be7fcd009f94ccaa6737d46da7dcba34509e3fb1807d6ecfb25704d5e17d634e3908bbd9cb7bb7a1ced4814d61c89593cf022f1102b0f4fc42b7a23e421d10fb8a517a83ae12f89674a2da9539b9f7de152ab2d459d0e57a69dcbc15a2ce4f15672ce310350027790a16733f16e1402456502110f239227dabe34f6d86c0efba4ae54ea131cf0ac743d84bf95c64f1f55b63e4924d4590b80e2ba9ca098f422d7b655f58bd10fc7931fac1d7a9efc6176815036da86a8ea403b82941c45e1e457e92b3082ec390c78aefd50fd859e322145be2f98ac95a8a5a4e80cbce29fb92daca98571f2199dbf674156fe32ff09862cbf09dbb1863996fd4336da24421e2fdb26798047127932fa9e66d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
