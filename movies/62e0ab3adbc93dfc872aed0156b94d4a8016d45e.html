<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1395bff0695b48b8a6e396ea75d2651a0c7e31f5d18321bce1b43d936382cd55d65912dd0ddaca9015b38f0609e9e66c78f2563e1b00ce9b793d49a9b525eb4f469495c518ccf2920a3c70cb09bdc2aa35af77914979cdebd13d36f2d0c9862cd3f189249ef005dd57ea49cc614d6cd6c58af8dffd9cd788a02775135af90de0d5631a7664155dc32a5273c89c699005598d2f3c45434c2ebd127086d295f7a713b26e602ffa54b797feb6909eaa87ec1507b0c7512bd75462bd3a63cddedb04ffc26a282e524ed6ceafcfbb70fdb0ff580136041cf825178f453f8068b530911342542e4ac92bcbf90ff9b89e9feaafcc2abe13fb0f9f93a2821b1044100cf28b154d545a33d493d28e05d95c6923fd48dafb8141e0b31dccdc356f6e0131978d9c180f9a38d838ca83767a176020982a55c854763329eb7a83d6c083099a398dd21b80f8d85400474b6ad4c44f120be29e555454e25db0d72c1ab62050197e98ffd1838d41292abd516500e8e7a1042a04e6cda39638f3ce22717a0d0675ef9a88e30f0c334f5bcf07e2f8548f6312da5ee5319a74544a4ba1fbe34a276905045eadc9fe6d075f9ed99ac05318dd7d7ad87498c69ab90368aeadf43be336754430782e36849d3e2864ef5942d4e2fdf18fd27b1b2acd581214b6ed7fd712fa8909536d8bf0ab976af8a5e1721fb44123da08e1a1e0dedefe7e87c69f42ff68a9caa4f2482d251d44c78f60fa64a814e1e323f3aef56b2fc83353b8b612dec5f6b255f9f53470dcf5c90ff7ccbb6f1339139f349b3ff7a6a57ff8650068a018ab1662789556edbb9c8a91a1a5cb243f31de9645f28badca40cfac9c628e1da47697c1a8281cd0c9c2abe1d70b603a4b2af990f893bf7bb5e2ce8f95ba6475e1c7c1765208322496a453ecbd4783f72fd8471e0d7c65d88993a5ebe8611927f53926cf217a33a7ee85401952a1935988c1b08214456bfa818143880bc2894836f6cde69f42a304d1b583ae9dc89b3eb90484943b2b41b07b45998cf5ee4b3129de483cdd0ca5b4bbd9878ee7aac01ef47bce1d070431c26fb238cd55f68f936c7359f545562fe4e30d614ff079a8745df1b782dff45e355384aa0d5db19a8ad9339aa2578585b42c835ee8a086f538debc5137b1ca3632b24a7aaac7cb9544fb200c2a19e786e049f291d6286036a87a40d2a307cf8261f3cabd5dd4cbb75be62cf8b8bb02ac3f2b5474231fd49849a2af5eda2e34262cc4225162aea6cf5634308c531855b62d7c706e60a3a294b4b9a2ae540adfe3032cb934f01d34efe2321037e842acc1cee328ab62475c5d3538329da5afcdc7c52db154456655f603855c743fadbbd67edacc1341104eef39b8b1baab028930a7cf4704e2fdaa0f0f8f6bfeef8c99a1c89b4411f4aef1802dd3574c37542d402529693b94d720460916b6406a7f415c4d28cca9fd9d6e3902e39c9ff814b24f73dfe69669733779c4122299faa9f36deee231062e5ea3efa176e051ac15303f501b54c4cce5368a27a005db34cf9542d52c172ef798c69668fa8e2e8fa39b176ff732de9a13083ddc935a8eb1c0ced3bf2e50a83ee3ac09b1b206e75ada1cb9ee9ca2dfe2709a655adb77b122fb3d2e398414f2085df697cab73e851b0514d2d142053bb0914e450ed8cdf2b16959819dcfcab5fbb117f66fb9b9a8abf00d76dff66b58a7155473ba0621a0eb80c59d48fa04385d06f173993cd85e154b4304044c7be8967d2f5fe34e97fb31012c76ef2bfc25ffd25fa83e03189f10616112a61c7c8f48c3ba275e22fc5c3bec3a36fac731235920206210c667216532588026a08e78e7c34a40a18590c7d856ea6223b240a01329178c49b73bf933b8f0cc2818fc0c2595ed3544bb6247b280801e2778fe4fe0d42843c9020ea2c389d4c06057996403fe684bf5515605906638e6bd7541a833a2bbdc39c6728dd2a1b0c8f1372606a9afa669fc667e3d825153eda09e86c553729c77eafc8555043897459f5992e2607c3304c003e032e98294639cb6339f4eb6bc482a55a3cfc13f8380e8f56eb52c89025a00e061eb4d827c24875fec835294a3e18c79caeb4b8a170899bbdeb857512d8cc8bb3db54cad384c8d8e89b336ae80b2439e33059bb0737e1526e842cceb044b2724c212557d4384e7744c6e979efa3381c1da2c9d8967edc7f0c95da8ca2ba16839e65b297b37681410dd3ba4db1ad32b6ee8f5855b845ed4a886e574d17261f07e9481ac5a612f5d8ef1c3fbb66dbd15768155abd0053db01033f55ba37ccf9e624b74cd287fc911660f4e4156fc758d7e11f435f33ee459403fea4926e96a9ac772c6ac1d0f58ceeb1cc094248c5951d2ef8cbbf13e9f93ab6b14952a8e11b84eea012c123bab82635da3c0300c36b8f6ca7ca536eadce3a24797a258aeaeb295ee32cd29978d7ce15f5ccc641d6f70cba735b97f931622462269e2b51fa8616490db970935425994bf6fb759a1d3df745f049c70f636e5d8ff9053435a4d1b98adb546628987aac85346411d8c3ba9d9c3f530e2e3b541dbd1843d970de7671eb30aa61fbd18cf57fee1b2c1708eb50f44d74c8edcc708e26dfe0fe470a4ff84aaa69f98fcf257d71bc0ce1960eedb51e7c1ab9774a06259073155c3124a6e4b1c41754df37f9788d551ec96dcffc5f1846677d880912c5893dd805b5607d59638b9497ff592c37af8f5f84947715f15ea3e4208a0fdaeca68d1d1ba144c700fac929e9dd50430e9f24bf5fb9935c54a9d9531c736af42db8998552cb53a81d9dbf763965dcf9efaea8d514e33fbdbafbd882c9e0e623b325516724c02de0c1e950f2ec0e4ebde5a7da006ea62fb26a232868ca76dfbcd8ded9ef7dbef3455d3aa6b7dd7db005e3c1a865d49a19eb31985e4ccb259b4c2d07cfa9e5135278ebecb2eb3d52e95685c7ce6dc0409969759c8c17506d274ebf41c30ef2c7d4c46924d3dfed8539b217f3760c8940200669c409043b349c244809b1835bc772b590ca1cc3d062cd3a8a7e19cb619c2d02c22671e6a442f561e5cb8fceb87c20161211fed677dd0c0847db37082ea5639c7fbde86c32699e9673a9e490133239be0e723cd07ba321cf918f03a551df618ed904e54d3119f5203fb406cffdf6ed20285a59093b8d18898fdd0bf77e0f1be87fb3bb66dcf4be3a54dd82b73f80d8ea9602207a780a05cb4015d3d0f1fceffe9e06a5cebb243bec8c640d0e5d16e7564d6e1cd8fa1bb6aa874e964bd4af3d9b9d782cfca9c68d88e86b575e449e5629ff3a1a38cf615436c6e33ddf36c8ac33891e179a0b294283e4b9a397ab5594a642a89c60144d71f73fccf2135650142c619bf841f13d0f0422b60f9b987369462728e68587af69ebff37d468102f3e8f4973959dfb2679685c0148e9fc76e1d9a2abcb275efd4d3f21cf5f543bfc00223f27d549ae638910c594fd0ede79b5ff603a09d64a3ce0a1080ea431c5a0c7bd99cccc7a981c9ad54dcd637f5216089b37dc050bb950e15fa94114876be178e28d3b943b55aa8c39b4505540774cbd0794be9b3a39c56ac1b78ee096ce83ad15cdadb603c73823423316f6bc8ae261ee5799ad44763b62ed9edde9532da21100ad7371d2a77a080851d0d75539025b6bd8ab4866c508908416c146b6bea523dd0a607884d5572dbc7180ebe204f558d9aa6b61ac8aa094472d7da9ade2110be8b5e20941fb9e476a6df3dc7651bb988cece9a32b492bb87079e262b63324e22776d80b89f97a78b460826e7cf78ce72c35e3bff7a35e79e7fe1db4ffb3d077b66bcaaa689c63dff2db13b2d12ceb73b505e763603de639eca31c4ffba57becd5f240bf034da57b626fc6117a7b02714f45ae84a637bc537173092896a83cfa712f904a71b98076130450a471fb4a4feb0a90c6edbf5a50e32a35a01aff9f1116e3cfc322a5bc5d76e7b4d653d14491cdbcf78504f1ebc1443084fe51e8dd922b8bbe513a5bed913ae190ba90c39fefcef2157ee0d719d1e1338325b092004712fb30488607d5bdb1261703d31426c2253981d1eb9c6e34bd7bf5edb36728805dac8cae18ec763f724825f69b32f16e88608119ab940c11029630176ceb1419340a35bdefa77267d7e10189efa2001e4f789ce7aa1e6f203c76d1c538d424d6a8beca784c927610c9716ce0e9e4046155309215a208234627069e9b77e6af4c9a6a4d948fea19ef0b9622f3a8ede7d3a92f40607ba2694438fbb9d18629c7ab26f1bbaf9cc448018f53f2168908547d85d9da18205912b144a49d74b2c51416ab7839203d4b1b70698679e98d5c47d41a874eaa727a781ba57e3a73e97f45d22f22cb803f68e40a9ac904383500b99418a72a140af59b98835b134e1dd56477aa003dddd3477d72a242185131ceb8b189200d3e4674b3dbad2ee2c4b420c0fefbb5306d37ee80612192e01af09b741f827ca7c294cf6e5d559196305caed2a1dabceda8e0d1a7b5f00d4f89df793c1d951970442a8f546c2a093f0463fdc2c6cadcba326d8fd2c7f0fc52e30272e3093623798b7da4f6e0688c7a9e19face3ee4420589524aec34c5283fb50b24c80376ef61dc12f7b8dd2ca05794d9c9da6de2626a7f960ac8bcf864ff2f9a9918103b75465e38d4204480421ab1a04fcb7a8b4c0a0ed50da0c2c069e820167189bb37db88b47e12f452c672911e801c57512ee4ea2635fd3129838b62b27baf57ae5263c1a1e5b294a7209ec8649ebc5be94eea4fa629445a94d70dcdeabf0ee50e1f7dafd7d31ff0e699041b5d81367831e1335d982cdb369098455357ca7fc63a02619f6de10f6f15859c6755530878b910c1f104a4d6bee43ea69b01f1cc2a3aeff863890892aed45fa32f6341ef8a80ce27438f921d21105bf3e9744c7afecdb849a045f92d140b9f3afd8034ad4b4ff148a1e29bfd23195e95cd321c8b1f4c489814d8a8dd6c8f67e06d6a3937422b4d705228facf694a58c4c22fc04c9dbd2e2119971f2f15f04fd97459fda79e19774c9c79e45c144458b378b07e1ed0791d06f3fdcadbecbc70fda9f2bab8674d4e9c0687cafbd37058556fd19e8bd6eeb5468e8a197b6028bac552000a36d3c8878a432449e8b57ff8d765057c4306516194bb841edbafdb33e8561c3b3b447e06c311ad823f93defb76710913e78dd739ca08811b916c27363f4b8d838f085d13e8b28aa611eeea721df7eda4c3a74e8784271937666f27982645d2342ee785a8f98133b73b29e9adb8c50cc49b97164c549cdb9c7a0be02b898b14d3bd16dfd4d6d6604cda1549126b458e1dd350ed8f32bd5e97cd00ec51dabd1b400985531428bb994f33f75cbdc38accd90cdf44b48fe34274bd04ac128d67e4327596ed76b7bf674c6ee22b6765da60a8f1e3ea9a92b34b973a24c001b8cffe7bdcac81073e3e61ee6dd7afc39842aeb275495d9c144b01fe70cb447bcc1db52785b5258cf374273af651b7c0bab7208fa21582373f198e572f8d298ef890cb1e2cbfed6ea3de9174537fddea4570b98b2d70b73d5962c367521e096f029fff2544867159659bcdf23915ac8bd94ea211f9637c246beba34387c294cba47da5db0b55083cdf6b3dcb9f4a467cec370f55a3ecfec223a05108fcbc1d836b607d0c41cf0c2de6540b3837133b3a2b4b190b2ceceda9bad40d07a4e18ad4c3b8a1e2084015282e9ec7caec791f14dfab829cb68521c35f16c386675436386b8b9cb2f190116cb65c7b6c3a89a430db5cd3fdb429861651a67939e56a9c6a4fd55539febab3b442cbeb6090d343918747362995daa05127eedf4e69d18e6261316351181e5a7fa2463cad821ed9a4652e9da0f6266767360e2820c6aea3a9ae9a93d136415bb1d6af115c1e25fee0e3ff3a382fb141afdce34e4a0fe7f2eee07a0b61e13e91d7ae860917d670312a6a10dc4177fd31484f503b56f10064da272ff4e7d104ee83e9ac0da14b36b9ecf377f7a041315feef81192a6aaf8dcd03573b4851b37b92b7be6cf4205287b0229fe84a8791aad401e9baf84e88f8b0bc0677b0d5e72382a95be136e19a1459a89eda8155e213f77b93033115c079286ccde6fed3395290108df95f2059d561cf9bd080a5ae56647216ff36ec4e4ecbd8a5f01b7eb9dd38261ff2054f35a1a50c3605d72a2cc9e4d711a19a8cf90304c4d76426b0b951eae59f2890daecbcf55abf950cf3ea9dddd3e9a92f805c082171d1e26851a9d0e4b3c097f4f0ce386565525379b022f85de01706f5aa78545630c62912583b20344fd256607858ed012ca9093da7229df03e2e049936ae9fe5cd04c49f6381e81bae208160735589d78de544a2f08d56a8fac688e3d3c6a25a624399684889e70a5aeee0b6ff63a2b6b14440f741f0e791c40c42fd891c930111e16945aebd3dd5ded0d8e91e10547773bdf67d4fd7aa3bbdbb44a2452833f9d88fd55b0f36c4bb4d289ccab95f313a5fb6af2a4c22661c02bdfbd3991befb049fe8369e9a9dd2f0105f363ea96cb29008a5f0b5f0aa2fe25b570d43ba9b0846859217ccbd99fe287e7cbd938bc02d0946b2f788d1c5c2d9fdeafb6dbee9f7eabf28b51422fde3eb0de0584b45cb0f73f00081abc376a91d45c16bcfb06673a08937dceb80a3c15e98154b036bca60b8c5fb779cd02437df1a67e70244ae219d7798dc1f84d71f3cee4bac63a4df73f7d39b58cc29979fff2caac2727105994724d49ba0c7581b6660e5f8fd048df9e37ac3446f7980ba4d869513fa66b355fb6584733cbca41c6c08cc6098d9442ea047d84b008963cae2660ae6aa90b5a00b178d0ff7de511ecde516ff39b13c63b9389b73f659857166236b731d6e09e3a018d2d42047e52b2a3b9d74a5a857d2d50568f1a6b0d748207834eb62a9b9cf4bb1d77e7d6dd663a6185d3f1d822d3e20c7be094f9190071ac38e405d92e6a85ca1b32e4a72ea966943059c7eb76e682d2214e046181bc14eda7002b7da831b45eb0e25bf72fac8764bb00e3ba60d25be82d538fb894791d540fe4cf8c334f9e223cd13356f2e6ff56364984353a3c36091111d96a79065303eefd4e09abfbc49acf4f30162fc90bfea9fde8aefeba5fbc62586b95ff474def1f7b808a7e5998721b2f50ec2b7fcef52fe5940f4e84b36d0d5b1e46be6323c27c702f02fdb82f50cd0328d056677dc7a5fff8daa7aade6907df304ea737d40208664361836a7e9e6871d3bb2a49d880dc83f1fc416f465d7bb3b848cbb1896a0b65f8cea4fe91996b3cb629fbdb84e9e1a4da9df1ef1ad2e0bef2a1632da5151ed5cbb702dc045811138b558b23042d04b8982bf1070a1cf6e2aaef02ec563d9d5ac4d27a219fccda1d2f21c460f32babf7cca8b2dd859add4d49115a4a18757c66d9b6f0d4d4e85d13bd99329305b8e59f912af77473b7e2921d140a436c0df7c7e9784c0eea58d211ee0ae0a55f8cca4e283558adc1a7cf9710cf9fd46c5dc4c27f93e086d1b5e57b46cea228b4416df4e8aec9897c8711261a1e9dcf39891199e2b20ad1ec050657b9286dc73aa6716e27f89bc202e8a3bffccb39722568d17fb15897ee616bbd6a08b4d2213b253b6f1828c257cbdf1eba99e0419f6762d6d141b9ad1ea855be9955edf67acee5ff22bf9d7b9c72455ca5c1c61d5e1832d80bef78d92edf1d1071615f3579e4010983361417b8a87d3e5c7399f037c8919d35ad6c29c4e5128dda06d92acb0cece70075e1f7142fef933e4815264696064adeb489fd9bc26a20d1baac834e55103a9dca72c60808f7caee6ad85b8dbdc411aa895ab7a08bd1f6dbf3a222fe0f08399a40db6d6e9e7c68c89191adfa3ccdc3c339fda92ce6877bf435082b7ff82a3255b491f071a5768143c47ab8494534f065cf19032d0209a0a3a8f6fa421c6f6053c08f223ee0474524c3eca4a3cfacd658ae97248617bdb3138f59d3d174c36289fcc4387d0ac9bc7b753babee2f3263b42e9b7fc4dac4257b9e468d9f1ebbcac0e19e97337e080afac531bd8d99fc1528628c7421e3121209157c9fc8077641dd31f7810536189e23fb072fc152285df306960e8abc311f34c5dac4f7bae2c2f4ace3061dde9406f673648b0137fcaba950bc1fa527e58eb5ade0602fd1e2bd9001d1da4ede80aa737b393cb0cb5c881766b2cedb8b252bffb825e68a918f3591f193be4ee7a12a1d8d419dc447caec418e6625b5575a8c781f9132c2143fd452aba4ce1fa3d7bb923f6e5ad117be3b5002e40de30c9a281694c4a4320a18c65f3acd87026fc14733b75b8b10b458153617e9f628240799562b57afbec7184c986a96aa253c388d0fd648bc12ca66ab021a689a563f55d5c35bf69819271992284fe08d8b5dd368573ef08298c57c539356a020872b687435c091808830112893ac2cef37e7d15a06cb08747a9a69dc000fb94c2df47dcf9ed40c96bbbcc71bdce9500a60e0251d1b4875a8de242452f0e11d915b5c2c17e6aeec0a20360f140611d8ef3865537eeba0d831a229ebc0b5b6f0642484bf2c23b9a0d4e629ca078294d7a91524d590001b84090265d2c40f25aa6a0362cc67733d942a1b74b226c05f44dfbda5375610ab04ab1d8f3ba17609652e9cb73ee2f8ab7bb9fbef96232dcd242b779aa09d6a2fb54e1926e5adc6f62cbc32ec143d8e0fc3dfe0b500e3f15a965194a587a125afc1d79bef76c34a758add9cd6c4ec6303e30b9b899ecbc798b40757d635e91e090785e475cce79da903e5cda922e094bbf45ab036c25d4a9311bbdd6e0980c111c293fae91567f60af7f2f48e17288e6ca030dc68fd86e73e1d75143554afda7da0adfc4e86639e79c5baa310565b24f52ffb51f56a058ec8eb95a9053c0587f78bf25ead55aa9def430f32babc7a592c8bb1a932f921f9e35171342ed03c308917bf3f730238714b54e2cfb33fc68d48ecf7ae324f544a442f01f74660a4902aa231fb6c443097b26bfd2963a220db0e94dd7f5634663d9e80bc3fb33e4cf790877495796a014cfca11e50ba397daa5c29ec42865ab917de7d6c77d5d8325fd501b04e783a0f8f903f54aa35b4a23677bb7f2516f954ecd4fd48c45119ac720d470f3832ca7aeddba9e5324ebfe92feaddf6ad37991aa436d75c59ef9b1a4d338c1a6152ad011b289581d50f5a383df540ef25eabfdeb1d6873141cdb5f58d75dd4eb658a8373c59dec940a3ae1c42147b636e68f400f22a6d0c39f31a1e2c470c3612e2b977a3fea61fac2f99be3756d8fd07ffe14d22cdea9e4da66f0b8baf16eacb7d3f08c8b79f53aa5471d0fb5c1bcb9f89c5bb249a7222f1816f0ef9660deeb16d292c4bba1b9a6847a74c35407972e1278f1ea3fb78d1c898a72548ec8b959296d60d6dccbbfcdbae10ce2804f9128fe161e1ac088c0528d6b2bc7609959b2e1bf56f6db630ac8cf9b85e8eefa7fce8cac4342231de83470841638983232af5917ccf45deebcce3983d30d670f09d57b16ec670729dbaf63b6a77972d63eba11a44b95a72e9f40927ccf455468a657a9b316eafaa7f44c45a5a500051d0e38e526804ca82f77ff266757ddefa4df0cc7dadfebaa7b665de9b454337739c89449e8b839b46ab422875f2e3e3aab1e7642460bd71bdff11c0c8d423b05ef6726e4ffba4e4f7e0aafbcc3d71001604ecb1fa98cfd26ba073c45162c8f1a15dd755912141b676c67fc0ac7b436a81b86ee84b1b4f20b9166ee71b4049e0843e0c0f2d4a26a39da1b180d7401ccf5d20b452f1af3f8216068d3136a85df377b764c17efa6e837076b369894cdeab0b530411cac06c480f0ee825788156bd8f5020f1c8b70edde69dd2ef40ec403b47880c1d3e80194c184832cee0143d27461e4012b15a4af0100a4f805006c617df6a8c29bf32edbae7fa301bd64d8c54316bbfb19ae6ae54305ef3252547ed314a30c62d779232b5ab4b87920a96e1fc6145a6cd741d17ccbbe067ccaf1679d732f74d886dc4fb92a72cf80f8c27cbf74e02c1122be3dd244300ba04ffe620a5b4babfb5e63ff18099fc0222fad7f5874e62b775426e86a9c661957173d817cdeb00dc9e3c6fb9f199e9c6f79aaddfae3ca71d2eb3d107eb564d1158203e19cee4ee67a81990dbaf91d72beaba3a5ea7ba7c5eede186b37cec12424e619ca9631612ae22542a377448729f9a37e1cf67915e0fbde65ff7430c980560ea30b7e70c99295d9e5edd9484a0ccd91b22b8b838b2b121b39a023536651ff29dfda71377ee4e1d44b049648bf97233fbdc3379a35d3300504d3dc3569afb21b9c639f90bc66c93dd28a81f75d6b8160833822dd636039ac88071254bd734be0a3201c487d7856616ba6f2654651e0d38eed90e6b451bf919f3d0a51149331243db3c4ff8293d239fbb51780396e8e17dab09fc01ee9d771e6d2b369ef68ea3f05316b5ed7f602e6aab89586e3ea23d539b19e851080312e60af48f4741dd57e25ad8fcf3cbabcf68fc56c2f273ceb790aa907e08fd82bd3728d8d4099838471625c1f68d3da09578ce0fc5c380b3a2117f15b31ed9675076402e272c74ea0bd1b65cab422d5ed9c179c947e75329dfde0512d7af69ba4f234343065fbe5cb81f6933676d8449b596a10b4fb0595632843fd488a75fcbb94f423d282d85ff2d2550bf086b6161da6920ecfbf1916bdb8de61850328556bc76f2f6d5900512a2a102b99a79882eebc29911d6aa16f21676000e0c7784405bf2659b53221325e9d1ff83738041568e32433cc5df013016094bb6abff48725cad7f41e119c5b7e81543f42af6647f6abcb342e7391d19851d5b8479146c95f0e0a153e46094ee64d20d3e265adff12175e735edcf533358a648cc414ad05370a59e65d640ec7b350d4c1279ee83bf092f95cca9780ac61f0383e9eb5521a92aea5f86e88b850eaea78300ffe0fca3169c14a55447ff5b396f0cbcc8e34b003de370b62efb210a5c36dd85c00f400348a44e213c0c65f79bedaef496491a9f48a70f4cb47b190cc8185350e93967863d73ef94603469bff96864580c76b7e7f46bc1dba3eb86c1277e8ef18ffcfe5c348d16b24465a0ae1b9430c3a9b29a3801e64455d9c08bb1f08bbb07b4751d19b122ecd8c90798128a825c727f7a5a30e4a4bb28344f4afb8e9291ac9bf131e570a97b496a8ffb01c4af2019e6061e44c5675c0895c6642626bfe91aa50382455065d8ecf5557d4b2431674d6500edc4bef068e927d809eaa95de1f2046c7f92b28235577f96f83fa5635412d9c86dbd85758d0f0721fb59a9cfb18ed1ecbc5e602c9fe1ef691e3f8f4537550bd485d9c7c6cf164e9a16bd88cc6b82c92895ed7c0989a9a2f979e06a9a85173f8672249285401752dd490ba6a3c82c39a430160e6b73f0b90262236099324ff57f1a4bcab0bbd2e8aa74a1d9a0cf1095b55660eb794566358f6b28fac01ba5e1188773fe75f2c99334eec5f5eb9a36757b6441c8c3d2a9466da87e8da064c9ad26606c665dc0abcae518da18fa4b45fe7b0380832e480ad979293af99007f14335882274954d3382c696286557d167b8aa5d15253184794311cc41bf52d4e699983569717f22bdb03da03387fd1d2ff33723844b82abe1e8b98faf5b8b58175db6465ed32e5baff0989c1765e032b5d65f1eac184f6832dba4f3e3f067d0c99935f4202db9c5c1ecc66b1cf62190e9c0bc7840706a3144bb8840e6923a73aaa464902405cb910c90d7b1071733e73990b27a3ca0314a9ba65dc7d38c20a87c2f60b0b8f2f46c6460e85907c2d10ae18a0ca50f4998062dbb6194bc29877d85904b79839482aedfd9c925794782bbcff7b77107bfbee43842889d3eb0d988c05cdd501be0b358de25e20fbd3e113e1f1db1b1383e9e3445cc490122f430f817a5bd6ddcb4736916df1ee7ea739736812fac472773d9092596c721344749ef5cdecbab2801cc5b50dfb9c58715ed4f9fdadcaa954810a86f77b950117bb2f96958dc9c39a598e2bdf967516844232d943e7f7698679b821d2f46f24da964dee4cdcb51d8d07c35731c7517c40c0a00a4aea4aa89f2e591d49056ccef6f994f2d1828fe153c08b0dd176ab5d78e6d1ef3bffb611d6285b268064ea491715cba754f396a86a77458acc7b9973a9a5b9dcc5ebe5f2daa18c9ae4be82c159331e0045de05269cfd9c03a095b50fb6896ee51577c9f06ea6aa0a05d7667f57c46e9468c2ab46fc52337ec64532245c64adb22aa430c6610aa500a3d27599dcc01c370be36188e5374ae8bb1da773c4011922126fe2c55d35825893195d007ea6eafdb9a1583f77c4b19299318714e11d4695d3e551a22957178e6927fb0e33ad655955ada41dc76adae1319f9dede8ae59196f288f008e13f34a81551a971d8eec668b5e5c9eee166b888281d98027d3832a0729a496e9e9da2679b6bdfdf63b649a9b174a49b58525822dec5a2a6bc18e92163efe059b0b1b21f39120f22e6fbaa405ff219faaf7d77d7cd223ecb2d2b75f93bf61a98d576717172f9591cc037948204a3285b6c23615af2b60dcfb2fc585b0c9ed4114322227b2a061515896cdb4784c3a4d89e15f0be30c526a8be14c2bfbb7e9081334f060143956e62c70ff082afca437b3ca3ef4e3d7697a02266eebfca90377b1dbe53fd75c92fdedf99f9e6ae7e162a6c2cd50848ee43e81585b1f8b6b052f0a79ac214ad7ab805e53ddefeb1193ea29970047d48f16259e75a520bcaa5a109daf360f090e4121ba2b9726e53d0a8388fed0511f3adf1f34d7819ebbfbd3a58a31aac4180ad8d09aba469b34b1ec10763719fd18633a7e680fba3f54c2c1682d665ef7f141dc0fd4041bb4fd37b8265ef6aededb7d7496f303458e8efbecfc65d51f48e66999882753728c893fb9ea9d93a3cbe","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
