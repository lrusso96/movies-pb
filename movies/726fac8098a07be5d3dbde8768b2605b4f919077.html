<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d49c3c3b459c2833f00fd54bf505763d48b892e4a32fc9b585b1800b1379a11f8faf8da75671ed5373e31da0b5612de7a24ea65adec039bc6eb81c79221379bc569199f3df86de8727074d92986d709eaa5624a0a8079a6bc16b6f2488cdaa22d35ca1797ad50bf4133ad0fe5db10fe3c610e8c3cc6d2c7234fc991a5316e35ba7d5d960a2e88d0e5617ad12d37420865c3c92a2d4fd8cc4cd4dc09de81c5b7e5d7e6ee6245ff4169d6a8bc4bef11b262eb61b98774f4272ff53eeb6c0eb0f6fce00fbb305778f6d90dde259ef3594e637b60ddb18307907fd3d41032d41934d48e855d7dd2900630ad8285aaf7746ab142c0514728328ace41296c57dc071ec34042559d9be53c3d38a72c193126d75e0a6cc10de20754be10393e2137843dbea81bd0c3d3da3bc33f229e5e23bd5b46d9ba2d7d452f07f1e108ac8d6ea4fe02039a0cc775c3f7590b04988ec3807a3c581243462470ae3c0ac4c7c8c7220744596869599dd553ecf3c42d19f2aa73062b7f29f9f7288542a13c0be30f14fe61ebb70d85a0408cb02e933c671aaff065fb127ef3b1d5bb98e8eb6a81fd3e2df6b001e4124e3a196c157a4b9515621f65d107ff074963e29f979c6806cb4d5de897ca867930af5bd88efdbce0754e1cf00d2d57b50db3075ad2ab2ff6ffdfc0ac23af3e8ddce1fff77733f5d0a2b5c47fd9d865a7f83d84d65930ae156ad398de35a4924227081a4e513454262fb50df4adc941a0a46785748acf69f4f951ce909cc593e5662bac2423e1f29af556a13eaef618ab481d6eaecc0821e4f9a0197deb28e838e27cd93faa288f126c2d72e736760eabe787829092508da652e5812bc43d39db068ca5bc4caf54761a6e0b00eda0fb379fd4689188615fbdd5ae766b6d67422fd14f99361c79226b87254720cfca0a4f194c3429afc5d6e4bade0f54742c84d09c7e85d2829d4f1055beb0ea7b76245e2851ba2e99d527bb2bda8be36c001e27bee65e7f6ba6a4f1452a87ce6d7e3995f22c4dd09139b72424a27cb1738394eb8303e696fa20a172c114fb8e80d4a2cd7019ea249ff0d36e5b2d59587762dbb27f871a26ce12ceae379841c21cdef796098e57e0819f4220f94de131a3a1ca0bbd1b078a9fad445cf197c85d3915f73cf2ddb7c484de3c4c7f854866ab712ee488e1883399980e8dd02fc6d99a6a2769f26485be0a3ef7c308876e32a52a1966e83a77551a21dfae5888a422b0eaf10c94f5d88fd5fbb1b1a0df4aaa34b084446a978ef0b01332fe026c5414c4970d14a0400b93df890df991c8cbb2f47c9ce7e1407c567a2668debb9015bc7c588c15c876dc29a2115d4bcaf4ddff3aeef4f1f4624a88dd8a9423947cc9cadd586167b0fc85b8970b94369a65b9103e837b7403e62f13493c2c8cc2d6219124717b49952c4c7ad6347204f706b3e9f5cb620a7aa55ca740acb978350f82eb0cf6ca72e059f7d6572745b2afd2ba59009ddd2354bfbc5ecaabef186d7ba36e892bbed31f292e3634cf54953e3690af431d01e12f93d676166dace31eea64fde27cf5404e4c81635e7c642bac873a769c47cefbc76dab3b01adae1463dd7701ed84903ce084023303939edf1b5567656b8d9a949aa91055da042d9124d816ea51597497f65aa2a81313412d0d1d853b06a1d7e516ff89a48cbd022912ad7a9d4eaddad52d7c23d7eec44731cd29dcf3a4ad5cc2611c0c1c1283fd4ca8af7856b1ad89aaac670698a13e647c23560ae5b24648143f997e2bba3e6fd05c277b0487a71d12856bb08dc0bb4417ee321ae814c7be57768f3d9981cfdfd8190a4dcf957124c8d3aaf107654d77c0ff3aad4207fa4b59a54d998308b6995b694b5426ced8e17d4449392fb0997afaa004e25637b6a06ef12422d81f8864a85792f6ba3845803b400a2c5f249777aea96a15f233a6a9b79b8a1731b416a1ae0101687dd89860954635f37b3f9a1a278752a6e8ee6836871815eaf4e215b0652761a6d351479d6d051876c187e37d2d209ddd4916d3dd39f4364eaf9c4bd4ce14770cd0aa8cff93c546fa607a3856cbe88d8c57bdee5091da5920218671fc632ecab7d93de213d52ff2347f129ef41fe8a830837cce9214761b0fbc8ea6794fed1a7f19614336980867ee7ddec7f11cf0d1ac6da298a789330e1ec739c3036972f7d6c45dc6987ee9e951a95a1729230bead419725003896927accd49c923c3ac822b9193496a565c78986832c5d9152ee66948a803a9c129d9528cf0f986891957cce3a103afb0896fa1880dfeb13181b5dabb764b648ed3a77518ae1546b3198c206ffb78aa97d66ebeba7955bb2daa42022df6dfa08a91101d041f93f4109c7cc77f28f8a8032b28579b6d34d6d419248bd6c607c7bbf0b1cbae5ee0187b13bf3b90a3c82d469780932d9e41951b56bf379f89e37b25678714f51b337e22eae3013bd282fe703d7a730eb5b351d7b8e5f1d74c9e3321294a120027fff6f78115d3d8578ee7f6083210452325fc661442c7180ae0e6c088cc4837e03ecc002714ae3bb3314d9c1c0fae2986d7078f62024ae1f117b2766c68f358d3982d6b632141bf6236ff722d4e9b15525759eee34a0c5c0600bde7296c289b1beb29dd99ed1efaa33aaaa10ec030b94b911d12e446ba6e045ec22666b15a9bfaf2d5bbc44ede08dae4b506c4d39dea6e46fb728ff396d3ace127c709304cba4db163b1047ce4bb3ad9936a6f4eca7979952c52220c00ac72ffa268cbf08c9fc8c289ca4d966ba074bc14daab735bf6473fdea7ee08274fa425ee447bd671fc62a7d9ef9039d465e280ef6a9b988917b6a0f65e4947a005565bcfed241c16cd62800e9bb427cd385a9546cdd0f134b5c4aca953fc83e7871ee1fd39c60aa98f8a7d0a50fdcb7c0472a9946025ad1e89344756e6053077b820986b7c204449bb07fe365f30d4beb80587906efb95cef3572a0f11879b670ab543b7c574d45fe565abe2840fc3f14daf588b3ed5b174e8c4056f54a65896d34a781130f42408003958f5d0bf70d1429a18ff44154945748235e19c2101fca0be4bdfb80b03abb2976c0f58eba676f8578c25802f7824d8f4fbf8a24f1c03e491000ad2ce39a9fc8545b8a8f27f320fc3e8c946ccc9c583750f4ddc69b880ced03a53d80ebe553a919b54aa99866157a1e4b90946bcbf792fe5d8b2df3698aedb9a5952d70388fad42813ae066f2acd530519329d776943f2a217c12be872d599bd6920037282fe40e808a73b0ad41942d963cd117b4da0be36b6ebacd4b5a62bcbabc507dfa882039f21899a2a710274b4e95fba31aa2b8df4bdcf391ba72c17e0e856a314c52cab81bc40213c2a61ea87d089a871ab4d6f60f4036048aeaee7773b634a5edb2223514f9d7c74c97e47730a18976bcdf5b4a893e40308284de386b7e6ce4c2ce3cc3a6cbeb367ab60c0adfe80b9f8493ed1c3dd21930981b1c7a77e26393602be93deed3541d2683414a8d66c05ec37a99657a5ee5ed4dc0ee93b70881d8d3931b12f9ff11ef3b3562a3efdfaf2de396747a8eccde487c152e1ab66d568f71f4ccc7079651344e595bba52ea23696d24f2e98061d92d8d7952f3e0f6432a4be3db203f6d25aae67295212d879bab9f8fd8259f0cca418852af1fa2448835a0881184bfc57e97e5f643683befd75f01d0cdcd446be76c4401e43e3b363530f9ade66fa7001f1759a462161bfff411552217084227482d71d08c50c7c847bd72939084bd0459ab69310f68ade51510326285996d69063da9ebd491eab810bbf4f4e32461715af37c6d271a027b048521f01fb45bc5309abd30decddb1b14cf029d383fefbbb2656b6835210841385f1aa28c28bbf082eb945b2fdd6f1ec186ee90373e8cda7bb2ddf13dd6cd5c237ae8d83209ea45d73dafbc91a34a11dc79e8eaa4913d16908fbb960ed006faf33e06a9eb9a67eb6fabf85f3e757c319847a0dc23957a9bb9238d49e971d512e0013db26890886d66c30fbe51745fe962179d055df62d0484c9eb53165281ac3040e797e036e28777256e7bb0ec2b9922c67b179a0cdf9b9fff173323e11fe05ffbcd1e7b2c9ea59eb76ad0427612a35b31d21bbcc74424102e8bbc2365efd3759db4ba66cf3a50b1bb383b243d64366471ec2330659acf0463662b16f06872b3b2955150d8700bec045d5b3af2cdc22adee3b6db97cbe13d2e19aedd01a8ee8e57172b2a2371854f39c53e791e72bcc3ed2019f8c4465b192c78bb8edbee60b0f25262100f0edbab8d094cf549a5347215a11a55b99c149a02fcb197f3e8c245e651745bd670f17913aab7d132f930e16d8aa1a704fb8533580b9e392af239fdbd3652dc666dfea4692cb3dd91a2e3b8ea8f016a55aa00691d12dc620cb1591e00a0054a7bd3f114e60483c8f79309a362087f6782179bb9be857194e07ab25411939eb11ad23b0e361ee8acb53a57d37ca04fe8982b6472a962af2208744cbad5bd46be813a663a745b202c220db92dab3fd6ce2e45f40da05cf977263d789e7c0f1366cab80c21d036ca8d8a1780cc6480d43a64f1c1c1843adba4e845911d8c2ebd1cc6febc8752fd0282cb1af8d7f2c1cc4c740cd940b5c2620d23360ba41ae4c30b5785382581105aa19849613338efb4838677e71e33258c79f219bc71b41756abc3c4c8cc77ada2e3ce0200c1ae4a0b213131172f9ee97015a768d9c54e40efa53e9892a487d55391fbeb9846dc4d7a410087bcfe4b009050a8b90471c0574a98b30c865c5f051c8c66a2414de14992a78df7c7c8b553a0a811ff8f84f59eecdbfd5c11e2645d3c62baa205b4f51167b0e65efcc6fab69041a0d1775e85857d7ed1a8ce0eeca90c3ec76154cce15b248cc396660962d89bbfbebce89ff8c421d2a28ae6a52f430df981f73cc27135abdeef7788610423251d52743a1c3bae4efeb8f889c9f9d528b6397641b75e76ec060227840cfd6bea7ceae9716a6ef7e229d32d06a5632b9fd3b567175f9e3d6e792cce9c2e548d3448ee8e2c31aaa605b9407e26362b4ab393bd69ed0064b41c289bbf416a51fe7feec46a1820945a7c2203c5c197f4875183ef870fb29e6c1a775b525bd721558e11c3ea9d516699a96f3a98b18db5bba03236ebb4b2ad3bce4fc8e9ad73aba7a9a4af5baab9080ba1e9bbccea52ecfc0c103bfd1e6adca876e75313e6e602551cd4e4774991ddc8254d1d0d5feb1af3f572ebc0796d5b18833dad06c3d9abe9680ba0f94d60b03e489fcf9be290bd85bb2416f8c9287d0f1ce0a7a2e44eb71d337842207183183ad0713a9259f6e949eee090be9434aeec8840dd4586ca3902a5e792445f16c1ba19d627cee2b13cf54a64ce314cdc533d8e7c0c10626c17b4b85006a8e9eb48ac4342bbcfc9bc5fe78a17b819e6245a84e768ef0742101ae296d8f1b58d108d63f80b1d4e9872c1bef8d5419ab7aa179a507830ec300c152c2287933d682e5969ee79bbb8807454601fd36342fea32865a85694d1e345e9c1da135af5c550b8bcfb9e8ce4a8c7fa7a075bc2840071fa746d1ee125b07bb8590a3a051ba8df9c103e07bb8dedf57fe2570552355b513b5767340b2025f9139a9f567d77d0540fe6177a5fcd64e542041d2463427be282048e187a40b612f3d144779ba7a0773af6c5e7b32a8f33c3ba118685b4f1169150237fbfbbbcc10709922f2bed502ddab58bff90be446f28ac886afca7f23bb077fde5664cb6d140666fe4b158fd7e112ae190e31e16a917b5b18154076d91732db8d0ee8131d0b12e9d581b6de4f777f99d0529091b86fbed405afbadce7c8cd1e0e2e3c2b2728fda21e38b794a73581ffe6512bc5ec1879cfa62d2d5f25b00a6d64d54e10cb7d83b35f4a18032b76a26a481cb6985a1edabd977b82dc27716c0833bffdbe23f70bdb15558df4572fb5ac48b07d862f04e23a18bbcfda714b4e0180baebb738409b9a434038f01591185da8bf41d5a9c107f8a855119b9126464020785d599de2d1b656bff4b4bb74b96518cec155d448c6c75bae22cf3a66cf5e6725b8abc9f9b8da4ed059cc2a591bdaf4b2b403be8669c2ceb38ed42d873f9e26594dbba1aa9afe52831388020c2ab181a6e03aa637d9798b221c2408f075a92a377e7b66667c246e36c7446d3b8010dfb562eba65569d1d41f7b2c0b24b3912fd771507d3a767fe31ea16d10bad6f24e9821acd9aa3dfdfb6f282ed53e46f0a6e30b5778f8708107cab9c7a497666413d3e3f0188493524c4b5e8e83b370cd29cc8f5fd8b546f048a4b87e0bb6eda34ebe91ad3bae00b975454884c5e86416bb37fa5a0bb03aa3e3dcc321df0affb7bd2e28703629ef1e93271d5e1f267e0dc13e93bd6215226c213e6853101aa5fdb9779ab89acf7b8751502e7f61434d0867137ee42aa2b133db4067196a419c20d0efa459dcf73bbfa697f543d13c3ddbd4fe56ad07e1eef564c9e4545a9e4401faf65473fe37caf0861d32a026020431a3aaa19cd4d41766dfc4c62216adc7c02fd1c4bf9286740fd36db76d9947ae3d25a99226f945a071953b4d8014e18a8d495ec39f2e1350c338e1491b180b5f00a8a0a3e870b27fa67e0862011b2fdf45e0adfa4887c6d8b6892587021a448df363702cff09ffc15f5da132e7a8d917aa516224eb8e0aafe7c70f48531382df9aea2e8e520bbd352f83640ff2e38bbd57214b6e073ed9ebf2786d30ca6a0c95415239224116702be54d55b0f40a0b2f9be5e89fa0c0f4f00dacee9c66643e2646db3b1e429b480bdd47465167b2f72d7ca25ad58583808eb337ddbc281ebe4b671388997368947171f3d70ceeeda62d6523e8de8c955cfe1b84827f522cd8a5e4bf8c7f71ca6da5722ec03e335e3c8113bf438d0efda2cda5144edc1786cdaccd3ea64a014d724a56ae587da74d19cbe04b29668e576e76571173001ade3523437a8e032cb91fa9ad9a428b8d7644c711831c02367a094f796542f959f99d6802840d199d5f491fb409d5c4022ff33e873c9c50526294e87a63629f7facdc630305e819930b16fe458134e71ab0499b10791b31f9bcbb8afaed2669c4aaf9bb2accca624fb46b44f4bc6d9e7466a14da9b8247fa8f43a7f01343f8eb5de0292e020ffe1eeedcc2f1864eda6410f8cd2a450c18a712abf394f6a29bc551cb810b76759dce84f432cdb2c02b42590c7c50cde5b831e3c855f8850c9ad189022eb1a16658201c7422a019d245c122bd27f09ea7712fce69359b5f5c8d3a924c7a02a96152ecad37c1aca802032b33b1c49390431617e935a531c609c40a0f779ba441eb25b42ee701b858f9042b1350ab6bd484bfd89322410c85c5452fb767a7b3e5c20f0501c78f7b52ec5ef970bbc3cb4c251d1962aa5e4fcba3ad043e798816386d879cc1070d1acc6f5b38e3843e03312f9cbb1692f9bd9e8c62604049b06ad60deb4d446f3bacd3286a59f36588509310c5bdb0b94357c26047d2aed86c36d51c7971015b1fe944eb100376fbea84912ece70bafc987ce2486b967633e62453897fd148a4b5424e5a023ccf0599c542656a68563250a1620cf7d016a955dc4d184bcb6e6c483e8c0bcf0e76c441591b8540c427ee8a568e3977b1256041daee313e60253bdd5e83c537dbc45b17428e7c06c6c7dd4f885622b0210435e1358ccc843651f07269d4dbd40ce9b91e1f1c33667276a5a5f1687b1309e6ca3de3adb5709e2fd101bb2d67bb4ce29ba80144c7476fefa749e27defd26ba42ccac8a4b6bf73708bdc3e5c6d9db2f80bc10df79a2b41398bff280b9e1f9e26cd8d3be13cd332ffceb6afbfa6d57b7868764e3ffb85ce3274f2cae1ebe84ffec4bc8e43212e0176b6c20527d0180963cc7e7f24f862f8035524cdccc8c2dc222e9c69ef6f3912330da479d3f1dbc622126ce689a07480e7dd7bf1990a3c2517d22c336bff3980a1036da8255e18a6d7b9345aa535bb44f81bf82172180db5917d508076fd0e99ab01e1fbd54efe9d15d4ba990e18abf12bc1d65a5321e0e2b6be3692b0d31d5a54a2fa27c4a225647e0ac270b1f3361f75d0770880679656e110806d4389f081803945b5bfcd34329116fec8331a5817810d447db12ceeecc105a237bf06477d13fe8483ce1843a44baad2ea9726a722ca618e2e7e6f534ba1633b8dc361fb7392e6d277dea845c623153cc8d1d973a3c865ac6546fa219f2bccc1950f04aea4607c910f91ea40ea129fec28c0e2bbf43448933084638e36a2e6dadcf2cd69c7703d9db57d5938923b1a8c73c5ead3f2cda371a8a49b7adcb05a65f4be1bb7ef48cd6b539684e55b24271b6262eea6e3112c05bcf3d337cac7cf18b81470500f0611f8c3ab1a3bce20b00272c355e83aa536410638f6e710e3d3035b2215d3cc65f966e53bfa1df73cb803031b7536981bbd875c913a99f0edb4bc0814d220a9055a1e03c035c47450f7852206a3c9306f3ef57bfcb36503a15f210f844a01a8596aee5c5b341efa84d933f05708b4e443f9979c0404e57070e9ca0ab0c87c4b4dbda32be0f3f5f895668dd6120c0f105f84ce70ff9f5a3ef8335e1425e5845772f5cfef55f0b37fa8c80eb3907e5be66eadd639edd835da398040ce18bdf4ee3341db8f09cc25afecafc13bc6fdc5c44faaec45520b74d94eb589f53662f597919515f960b3c4945e18af9591664e06e7d868efe1d37215528d04537f8d59e173bb3611ff02d71a7692ee9ed75e2991d01f86258afaa4c6e800fd8b07134c902590dee293634b0982f7cc9b0ca6f4ce818e303163ceb1ee89e3230d778c280042bd786cec37fb3f4e86b43eaee3938e10121b63159e0f331175d46522a3e3368135ee798b0935e36596770c754e0168e2eb55064e644f17628a26fbf923003189342d20ce6a8f9f83be93cfb622666bdeb3d6e15c71ff9706168d11cded76b509412dd8f79f9131d6302de6b268c6734dff28f0350facd862e7f4685bf24b378304de6f2f09538d4a8bef562253cfcdb73c0296dab3c4970f0200c60319291fa603ffc5faf7d8396eb73f487482219577a5f161c74f9b631f0bbf803b3a817092caf48987493f4d5433ac6b8d1b27092f05021621b4c60e753fb8106d67bdceff0fcae21daf2dde0f05119ae44c2daca680e7820e8926bf4e1deb6f83a5ed62f6582d1fc1498a9531b8c3036ece8d0d5806fc81c6e78836f62e0a594c79e40f85ccaafd966a93043c4f1e190e30aa4073f02b0a7645e816588cd31486b85d8d5bdc988987b684925ea83b38641667cd5b08958f96b60d9ff9ee4d66722174d17768874be46918528f9e8f596d9521c3713969dddbd2eb61b965c86de091beb6c3cc805fd3965325f3e8543e98727a3a53308690c6859dd3207ab37a4d440d5baaf56b6b71881df22ee55264c87be31941b334fa12d34bd14f2c3ba81a223bf9e9bcbf9569bf3791873ee2db7093282bf269237b37f749153e24686753fd42bb8a4151e6e0705596b8c0a88e0d89c0245638b104cd9e8a1d3c9d93df6bc70647fd79557a9d124aee1104c53f66a8f53d1e85a36383dce202baf0545d313a0d16e3e74ea3aab96e1074510b735580bf583b4643137ce2c2af7ecb6bdd449f232343025474a15f220aa2176d341bcab35d07c9f05483b1973f49365ac8b8cf2d2df5e4d9a42204a13790c18a4a7c9a840d1eef34ac6040eb2cfddae8fc692131126ade8bd23b006371214683c2e03613b0e5d2616cb2716cafc5b9fa03bda74223795b9f661125f85569dfd0a4f2d46857f013207667c7b48c48e15785fe3b6570bb48c04b713f6c23a5a9fd32268672462acb41d1cd1956d2da9fdf2e2223b5a19fd96076dfe2dc371f611d9ec2954b339a6bb3d1d862fb4db14fe65f41992c02242c36a4abb983d43d56409c2ec1db248bdde45af864a1aa514fda0f8802e604adb56a89312876e16cdfcc3be0a9a2ed9d033197d3eb8cfb5ff09c7570d75aaed5f8807c733b8e11c1efac2bf41667437299f0357b03402e1ffa686b545b03df5f17703b0f3872054d2fbc7e3a147c93094abb218704be68a6854d628413c899772366c3bd615aab47ea2acc3646fcd8adb72954386bf2c9b30e63aa53389225bbc56660e4f631aa22d18e4d8dc952984b014e3666610fdbd0eaa46eeb06cbd3446a20911f9de844f1d2600427a506e37fd5bdd8004c81e31689dd83207485827cc61095fd4b674837525356ca519991f35d890be40a40b8148028c00ccf38faffbf502d57c93cce33f2b31b27e137b30af77364fd6575f1f405e70a4d38af0159862cafe9bae09a5c4c5004d58df71de9203e1cc3620f7e27c9ce966435472cd4af38106323b4a3d1b5ceef87451abbae02818aab90444cbe483750cde8c62b52508a4193886afd28f5f1c524a2be3a8d56463a7ad0680c731084cb64ed9e56a0012e88e84c80e4b37e128a0b453335f8b80c7697c84da1f05b029eeee60dac5b93f22eebb52edb54c6482eda102d735f24539f3deeb5a72f647658ec2f4c7ebd0c32e29d9b983a37ddb00e54398a203c5d53673074dcbe597220d44e6eff013e583f158a10266349930ec472189e7f78236ab6775c5182277164bae07c4faac1393eb23e5942e8e0107d2653bb48a88203e94cd5b05968c12ac870195de665443052adf140a2531b80aed340501dc23c64bd730baaf615312183507931a82b05bc84518e20f56d82b598b1b36ba787c65a30ce80ad85204b7a092e6ec07f5842cdd02ef9fcaa2a6c9abde413b82424e284f8eaa9521952384d323a167f5f07b3b45beb374fae105af5c913ba8fcdf94c5d06b7d8f70d822681581cc752792ab18fb7b7633d0f650f592e562e9668e3a9a8dc71e97026e432fce11f485dcc9d59eb4653544783ba8d95aed02e5dfa580e393f03d7815546dfebb0e5f02e29ca08234d6ffcd517ef28c1a77de16c7ce39c61e1d29e1585f16f8e790f1b6c8fa4466253aa5df6ca642dabda4ab11be86b05b610317468127f9e4e29e36c745a60b227d0b810092bb3caacb82b08cc952c66273bade22fe153c9df9cc08fa5ed2c1a37725e7901738913fd3b41d85609b4ef07f0bf8e38b01d4e38461902d024abfdd3ab34c369626fd5b5211d660af37b6ce03da024b7cc8244f3b4cb682157796c06d8584657f555a5fd00d37722011d7da518797eca9b697bd99209a50210b4526a42497b9688c8054a2d56686e24051b0dd91a63dfa43e06e5075adcb6631bad9f4db3fdb9ed78ee1501c9c9442455666a114edd6234e61eea0d607324a1c73402da2ab601034e1bfc00212c201e418945b9fa09506533b16df4e1f75903b444e5a9d449add0bac35fa88cddeecf4d2d25d8296b01aae7eaf363b573256659a6d0679de7bce8240717643a83aee1e2327b9f9cf1bae3e153b9eb714cde1baa055d816df6014ffe01239c5ec39ca09be5f7a349da1cf6e30e77a078d6261a66de3c5c33867884a5aaff7d6a2dbbfae02cc8251c8d41e5cbff9467aa35769d45dfb0448f95e88fe032283eea8280330e27623cfc2344be1e54a97d6627f9d9a987024b5dd88a7b227098a385dd15752b5f1a80b2c22c9885a8dfcdd4818c270d2f4ad1b72fe22c03e3d50d7e45e21568925c89844baa70e15b13eeb2d89fe576921feb5166a83f3ada3499892c3bf11f4e1295d81d88f909abbe4adb054b20c8387dd0c0c832069879198fb88757cf4c058246b1009b55f1feb56696a7b35543a20bd17ff85f931fb606ea675a1d2aff33db7381914a7394a079a9aed62c5f6f94e89984458fa0ac3c5c9eee8d5ab27f771eb0bca30d559b9a98f1e9d106eee894b3dbd2ae84fbc81da9120c0c70bdbeb2d31f31ad452af0a79f85410f0b52f9352607f7011a68abf9d81a76fc899855bf79d41dfbff31cf326947490d2b00f8574ba8515d7c528c52772520ee9cc28fe87df1d33f0cccc253fd23ddbe7856db81a6decbeff750a83c2ad4186a2739f4e17d2104ebddafde66660e2d3d4f46dae8266b446db6996dbec681b507ed67a0261ddba9bb5515ee22d3efc937d912b0d55aa064863a1b6f3eed20c65faffc2ba38847fae56c0eea1e7bc113c0a471008b53ab1c847555a48773c508b10deb5e98621382ab3b8cdd769602fa1f9176d391cee92f9131c32bb8cdab046a5899741c6487fd0ee6f045278cec7bf3479984247204256dba282d007c878d82d6f7ae655eb500341c6cc3fed0019ab6c8e1880899e1f5a99ccb6ec41794e59a7f571ed59cdbe23caa64a9967f40c87c141680241e77875d2e9233286cfd6e8997c7166093c0e847d32c670dcd31789bbfa91c3050dc5de24db4c2643ebbd5f1fadff0fb8e80d91941529878f3ce4c0026df4966881b3029c375a15c25b1f0b0e436456ae3c7f18e0327012b1c0ac8468cac13f4bd3f66b6d6daf5d36e0a9888530e76bfb46b56bb02cd8164c10aa08d0aa544d392335a0e95c5e3f4208d812b1e0424f4b0640df427e110b9d0722bf60fca4f9948339c8278caa6584401d5f2a26ae28b0f3a2000d87a2dd8a14ea366ae2787895219c6eb0e8789faf2283f4a1e999e26743e3945cf2a68fbf501dce906abf538f9f28ec531dfa4496eb009628c9836e91e97ab055f094494296a72820edb8617ec8de9b67762449dbfe85b3c1cb3a0d03a99ed19705bb22ffab7f25b60ae0e248a65b108a5b0296c26c9901d3239e70d24fdf3ad5e1b0ac171174f796089aef4d741eb32fb58407f0729886eb436355d6a3f325819e74a3608a7d8d76ba18ea1ea4c99862f9738987034be80c443163377c37efcceaca6624c9f832f7ddcb87d5445a9e949c94ecead577f2a547b55cec197e8819e46e7c3fd1d5a5d8b1cce9a579f33cc131d395f6a96a7dfeeadc7a8695b3ecf4d5402e03ebf3887898a36a0e5920280aa1ecbabd4011808dc70b68ced00ab60f9ad295ca8890ad8dcdb88b42029ab0d12efb788ba18ea4e607b6b903fe9306de51ace535d897a9a315fb258be3746406634fb9209dd069b744ff8a01d96043a386b75a3b30af4b685d51d04d1da9164098b789a86ae66b94b89b9cc7d266ee6ff3d67b20e8f82a092710c26c6998fb76c24d8907af539da3bb9d65245a5345e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
