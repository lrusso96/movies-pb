<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"986e440cbed6809f57f7d6b89d7aaee4706d4ad4cafe245b9976caaaabb6c1497c0a098392e2b25f6630987abb3b5c8c580fc4fb86ca472706e6d156b17d1149681826adeac72e36a235c2ccdf247959b36c51416e7384ea7be50891dd85051fed5404cb2b2422d0336271b3dd6a343bc236f49db00202739b4b83fb9e9a098b436e4691048f555ebf4d89d5b7d45019a0a4348f993ea9c184fe2794b8a2f945e20dbd917bfbf8208c51da8763db3214cdce1fdfb8a35e8ff7cbce4f74bcdb68c4daabffa330443661353a8b632c680d6489bef9906f891cfbf01dab9bcf9e8ba2690fd6ee5e083f4862e3f4be9d88e8f7b58ccbac3748e38dc4807c6cdcbc152c2d1bbc68b0fd4013228c88a7a5d745e2833bdc6f17a354b641fda2d8155db75fa23eb7e48c07cbdb962172ea97d1f690f813edc9aecc59f5c438838a63b0a3e890d12d6e5a6e3c090ec9ae1145c723bb8a308b8d689de8219ed27bffb3bebae36100fdd59b1e95c31dc8d6be73cff397ea3e1e56106e54ac052a71548e52f728a263b9af464e451bc00ac743616a23273ecdec1651fd4d518154f88007755297531f7898b07d390a3f93db5af37ca167f4319de8fec2d70ea38546a4eb62196192d66c3dd7524065af22c91278554369054172ea13626b31a1fde3f0c639d5a144d1e4144ba273d371b75ae375873712b8668785f9a5ec0d77a93511a163ade8a38b65e3e3ddd4a6221a33713d9b7a3a135155029fd71ab9b483b1bab8d9d22145929caa4a6271dcd2145e32c624a12b331ed72759320d84942ad097d92e757b6f27fb1757b292054470f655604e9bcb745f5dffd479310f01bc734c03084180669ddcf7d94189b6879485bd687b96844fe993deff6bf3896bd42b64d14fa98d2701df83a6a344c9f214be9d69aa74d1be11befcb3fbefa587cb1cf84c9d7446e2adbfc0b4ed09b3fdba48137377d63b10431eda4afe2d10f4f95294ac3fb4aa6b5dba458957885570ac343345783a5d1d6fb70900cb9f192229e36729dd4f213025c86b40ac96e39b1e7a0b6d0845c0422d4b5758adeaa2f0664829a4d8251282d17e507e6a955fc7d39991a8f61dc07abbab86f336cddbbc6cda56166e097317ce5195697c0841e367907d9c5291fc019b51447f74eacbf3e0b07394e44b4356ac69f849a7910dca6535c6c55fc5e43ea266f3a059ec7848ca112eb44958c1e9d73c28adcff9f0ea4cef757a7d8414ba80655be6be7b7fe073610f64929337feb9aa6040686fc141f1d91cfd9b0e7c083773f36989688a7987ab06b359436f97ff4be6448f9c99fac229eb52db119464eb16ddfbe1f9c47d8ce70c3def13d8954159eea39bee473815fab3bef3207bf26172b186a8b75fbcca2204fe892f04c4eec9878834ea2c101ff7c25039d648bbbfca57c7503b19a869195a73b9e3b09e5397dfc3da4d9752b0532506745b7065c05955425ca4fb71b35cdd86aa3b48460c6cef55a34dff968033ffcabd13496f60499d6e44ac2cd7eb944f75b5e1ad25f391bf635cda255456165b93fc286d86b4466a88206bdb62b006d3ee2f1972dcd2c43502b1fcf7336875e4501fbebf84da6e968a30b6293d92e0bec257f6ca1ed930fe7c63a74fce9457e574e37b172692dbdb3cd3b3fbcb14c48f14aaeff398628c2400d6971b62e1ad806e69882cab09c173123ea08e5c2f2a3b56366c249abd2cbc441c7758ea5d170f606eedd09f26901d62cee5da8889a7dfdba936be9493c0f0f194ff668d3f157757cf9210b4f7237bf9a1c4c5725b3798cdfab5d83d5cde6857bd923c84cb1f4f06bd14249358311a83eccd0da98508ee9a92abe5e9a467dc519fa6a4878b8d13d0868abf9eaf3dcb5e7c18be8bf58ab0730bbc69cb8cd72978f955cb47cae0ededab38e72662bb0d2fcc5efe6fb1b36b4e46a532816067f001e3513c46f548d9a2bec5c2fb8a1b56cee503eacdeada2f771bd0def23a95b46eb6a3f069af3573dbfd1f0d5b0aa9a6b5eac638aff946ce6a97492f28ce92b98aa3159ee387af892656b11faf44b16177ed304ef54108b90c569c53ef2d2b25f1b6e2bc1d8d408693e5ae0b7cf94b558c292d9661ddacea71c79760c72f349578fdaff3f70b2caf8c7238313bead634bb02b3d07ecfd074dd8866d89016c8d8d222ead230844235b40749c9c677b6349197fbb75293a4be843cc2fc689724a7f391eae0045a3121c5df236d3f11b7aa45823387e5dc89c72f211fe65344765b8da94c8b9f0c3ab752b77fe7f71df92c137814daeeffd465423fbdd7c76ce4d63995db47e41126a4077b4f739d133593a520404799c29a11230df9057767a3dcc4c46695edafcde466b7baa8d3d15b33bdf7c76b1d1e2d1677fbdee21552d98111bafb85d96fe8517e69ff9072002990b0ae8fdaadc4b05679a36ff3a9c837985cbe79a93b1f246f4f7b97e079806cb1d02ed566100e0b7b8e1bea70c5a04f17a5adc71ac0525a141622637629bae995b52dab7101b8d5618c8d2f14824f3239d7510f0456a5484c322aae00fccf708b61e67fce410b355d4e40f9fabef90f86f1d0c8b6b6869713a65ecf4ef9061e34f6f80b463aacf6b1c8edded7ab0215e6bee0e1a6bb6d71da2b4e583c7946be00387227cf4ac1810d73b194dbaf758734af86106bdf5376d122c314a276b7f4fe8419bb2c392647057e1e0e4c7a1c15ac7a20830c27665a18ff2ade9caa526b9cbc5d60bad4048cf450c6f5ce1e2c466fbcc4e88e445fe8306b6622e378d1f9ade1c093b3b732402be27851167b963c97c874ddf41a6b3c6a6dccfe490239e2298d2727859967167db377bc50b53635c5417b472762b70aaf1d8aac8ee388b5a75f4c880a97618caab4de14130116289dcc3c489eb9828d8f50912e8a1bf61017a4f462ce2d61079c4d0e80bdeb4068c58a428fe4ceff8daaa703ea0bc1fe220f6ef84dc859de89cb4254fd0b4b3684db95cfd3b70ff4dac4a641a0a2a368270192d2ee545c509361970d856cb2464b64cbe706795cff15f951b57df9f665e6feac287bd397574a0ae6034e5ceadf47d14ea29f8e2f0a82d336349e4be3e99fb9bfad5b43c8404a2ca8c5bce1ea15a838439a35f4af7b42796287267c4868061990f73d537bcbb9614a122cb32c5430fc3cde3fba76d747dd4ea143a681b7f5e0332f17ba3324c26bb19a9267e60bf8a3273543416aa6fbaa794a00be5fdeabff5ce98ae6dfce145e0c9dcc4945e61ec418696d6fe0b7f314911a69d88b6ced3aaf2b8afef9445e3d7e21f5d7250493a3136e5e7ea21a6fe7cd98aad24f08ca7fc99e4aef77422e7173b0ccba24122f1ec29da0fb309c9f016f8bc8561da9a71d5931d1e512bcd4491a37388b130632168a8a7f31641d6bc4283bd790504b8852897fce14da7b13a5e0cedc3ff770f0658aa9489bc7878897922fe92a26cd634463abfa1e12dca87a94634933dd4cedb7c52f83a19d254d075cf1a322ec2aa59e214eae4c6e5cff3581bf312b88767b2230c907620483ef2bde32f3d286c600a45d7ff9fcec8f4b4bc4efb9b02d78db6c324e6665dd0614de5e9ad5f92fe5f6b06491d66df522f6d9d1304937bd916e612cdb95f7df84dbed9df427762ada35064f735c9fb32492a2af126ec0902e189cd08eb792fbfea8b256f607e1e776edcc39d90e3d5d014dfc7e422ced0dbb859e2b2f9f3f9b74741732085d4f90cbacb607ddb786af248ea812a7dbdb2776b6cf1e2705445dda40ecb57dd27a99687e88af298b270014670f550d060f161a4c6672728fe5cdf1a0771e830a45088d6b20f6b6abde426160e47d817763e50c3a558fbc758aac02dc10589d8322b81c577681e7b94eab12547c797a1e59b3bfa80d363d8951d73f7f330bdd5882ccfc1f47a01177df783983e840d009c93d426f3f03f7d27b8c853bca89d604aef8b6acd85f0d013cc1bc0f36666c6309a863dbf1edabe351ea906ed4948bc1d9609ab97f56b204d40b9211436ed6d2787bccd39929b55bdc73de11ff5a738273c89018490aace2ccd940215cea2faa37d7036bb73be9562c5f2269765cf680794fed4a7da967b93027ecd2411be19b0f9ddafbf035448ccdd48e98e71719c8c43690eaa34e4e03c73ec601e8980b81c95fa5141083c6c0fbafa2391158ba8ee79d08e00476cfaa70498d93eb83902f8930a53256d39ca9a983aa8ea501235ed3ac8df12a21eaf63ab4ef845fa8751fdcfc915dd5cc06afa241dd35f3b69a57d2b1f261565a7e7adf79dd61efecae635cdd73f713a1fdc9af93874619eeac457d20b19f6ec972b386834dd867edf7ab0cd3a55849b8a3a666c9b213a3ccf56a6ec5bb820613a6e61b2a70ffd94b618dae9a23319c13cc93f5833c11d7450ea419727e59705d5205995951808086897b63e2c8b8951d09e8894aa2317bbcd5f4ccc09b70d1ff3dccf64d6ef6261a484aa8ce3a7d390afa587b6a35cf2b1f9ee330eba776578976a328d660dfdcf601eb1556e7fa35e5faa8f8b6cd9228bbbff30e0881f7bda7200ec3608bb24dc025c2e25cd83d022bd79909623fffe37e718ddfdc58a582a11db218dbbbce16fce0c2ab7e8ba692b26bd2858010855313102e6414defcc1f4a99b5b020d82702488d81b84306a51bbf8a609c214ba12b03c31d418bc63e6b214cdf0326bfa1f377308ef920036f05bf86fa9074e91d965ddada65326e88560c77e27dcf8644d6058c627c119b46c6be42276232cd5aa1e9d7689fcb07f4c70ba6fba2a87b44c59091fbea9ebc717c386f7329c388e06e90c24037f229818f67898b6e9adc6d30e3aabb68622234fa01c7a94dfed84e07891bf8f2c3aeafd57d809ed1cbaf984b8cf189fae3e5fb332651bec9a28d6840068c57874401c16b261c9ccce0516909d457e3fb6a8576cbac699f7a5baa2ce6794bbbaf3231fbfb9da48dbf42d4278f36e4ee7566a41fc7a6a53fe498bbfd9f04251d9fdff7c028e99a0a4ca3601ab7cda4986e9802fa10df97d8f0396fd14500a074ffb492405ac84033b7b1f47a995b471693a1f3d5be1b43664630bbb1b5635d42de030079ea87794098c16425134e97ce36cf7481aae326f5fd43c571be47f953bf2c1d40d2971c8699bb174925c8b291d7adef5acd5ed5113ef4de91ae15a76398479732ae68ed7cb2edcb7945ddc4347f19e8a39578118d8bb119f36f24607cfe6f5d94f1c5555d87e7dee4b76a760ad14bfb2086becd47a0611785916defd358bd6c583927c7206297fc27da90725e9e5d12539fe9d6f47f137a4b212e96ced6dd786900d06048e8189fc988f3b82fc45095e1388a7c614738ba982986d26da7784d208f59b920d3db4a736c46f4aa6d0c354f22ef81ddcd928ea8257485da474705463e30916a94416e7fb4ad418c666f154971b969c29f95c17f1995a31f11cacc32816786724de89c1df87e6bdf573b866b0ee14c039fc0dec90a94c93f109eed68e287f8993ca2fc572498d1fd3f475e1bf7539cb853d5a86bf254e63a2e0e82bd1d003a58be7514ea30d3e6e9aac6944e2de6d5692d3050e40213bd1380da113ab40a76161f05a960d579c541665d23728898ed0a969bc556371037817d6bade5bafe087fe9a4bb1997f1a592d1c46b5da7fec28d0f439074d9a05e143cfbbc5cac11fb5303c79eaf00e59dafeea33738537af27a0263089948261bf883520fd1da4ed264749dbd1f9652f7a95b4c04d10aeb4121a6b0f804c470eaf4dc4e8000f449d20c0716a48e72b8cf0cd749eaa493cec048e4298109a207e6b5db28c8c68d19271f281aba39e937b61dd3ef5fc3fcc53217fcd5a26014fa86ff7e1177e77de1ffd5a218c08481301d83be38aaa17431c6cf494f6c5808584a1ae706e6435e5b122bc1109240b11ecc3d6452a12aee5188b65847ae233942e78bad83621277d264896219ceb1c15d7a8f37ecf8fa21c58edaaf365e68c2167bd91d4f9744aa02136804ffda84974f98db70ab555aa606c8f27ea26870dac867d24256f82a3b329e3c8a0ef870228653a1d452c362accf7c0e2e5ae61db4844599413474d27161f26520f8f1b7dd87aa44763e9faaaea83aed582ce6d3e47bbd0975cc50d18dd518a2328bd0f328c38d3da474b724c1613af42c514e7761a83c009d312be9299b024207b12e02b0b10563b80a04d60b303701c82a411d1c64769812a7059ffa8cb70798898427dde1570374aedaf6cb9187f852923f6e4421f73e25c0713511b87bc24eb028b46b06e17a943e662191f709287a308e8cbd6fedca0974bf641bf10db56fccca01c30ebc03b65d22a901c72efb5c8611e4103bd8f719943d020f0b9615ceecb4f5cb898e9549b83e760a5934526761decdf436e5ed2c8ea4f70640de58683eae6b34a2d8d9eba0fc9d87e872fb2fc80100c76d9423f97543f0f8fc431f104b2a68ede4653e40d75808c157ca2269261be21e35cae5c0d04f34998c4f11f19587d9e62f7a905f30bc5caf9faa8e41a0aefa929652c2eede8c3c4d5c1e46086077c96fc329ffade76cdf6b9a8d5f35f51b3c29d91cec2e282c59f6163415766e160b77f69eb9d8403ed3b602c97033f81b00507f9b2d5470c1b01eb9769d1208796c4a10495a8e6ed57b91026fcebf95c163dec80e02f67d48406866a0d1ef522b6f2273a841ef26843c67c8dc4f1a8d6d0edc8ade88d42e39d353318e0f8b0511c4bd60f55037cab726f121494250edf3b1e14c08e0f537bbc64c8ac060dbd70cb5364de8b3ab34fbf3ede658a32bf243270cec8b30ba40f63bc5b1ef56d66078e32386c1630821897935d529263f345a6b846d09c44561be86566d34c04984320afea2243999aa0eadf1c0ec2ab03cd2b0cf3f0e746c08e1b1385c0d36b2cac22ad5f6eed0b9164dd652ecf51d8dfce982dce825040d3143e2e884f7c8b9786bf84097c050252a749729616f44f3e46ebc7870299023cbf9586307a0b87aa6480addf4de3f3b632bec0101f061eaa1470fcc2490821fc34f15dbff280d708d19fb77e649d665d2d399ea42b6f04a25eb324e91d3f19082a10494949957a53d200ee11085889d7906b42f80e3dc51f47451d8dca83db4934ad60586102915774207c94d553f915e77fd379c327ad6e9bf9b90f99ae2605236c36efde2c48156d90b4e2debf5d6811e9b3969c7c4896f566a7e7e0b5d43f8d1888d8b96695a826c8a6eefbc7ac2fd8460f0498023a5c8987b95af4c2321502aa16b80762be3ce1f63ee6d4b17412b2ebc7a318ea96be6845d5ffbecb62b6dc9093208e93cf8ea9340469c7d2c6021f8870f341afb18da1f965f4abfb885e6746026285dba4c6c6974526da0f5e418086ff0d2a3d4b107545e7f670dfe47b60ab41fa7918edb543622d5f6138a9f8a0d762722376d53e26b80abee7b75147d2163e8a0a1056f6b96dfd7e906e70f427b08a2012677c1bb8bb17bbda0b2e653b01c8f8407a12307694363383e43f0a82335c72d85b6887a540be8cd2e09a38537e84cb86988cd0a404faab643275dacefff72afd3a506daa5b9ee3881d7c0547545dc12a987df935d993cf5aa7bb3c16a5341e2d92b55fb963ebeadcf52f22571fb479aed39d711252018c0ef91a151b1b326d250056365308a09a7382e46be0842a266763de21fe40b4f74b03c8b9b28aa8ff440b805c54f2dc1ed8c7787620752ef394af698b238aa2d9679c3a025b54e653ee09ab7c207733e6fa60cdc28087abffa28acf7da13d4b8289941ffdcec2a3de3c943ebf37b303f6b19c3694b7c6c53bb1bbed59e9153d97b40d2da4674b6e70cf9e6e33732de96dd48f4ac3ec8f426938b04895f085425b4ee23bc92af29d167784c0ad1f19542879092615dfe45725540c5a0cd5204c4d9caafcbe5d2f0c41d0bb06dad35fdc6648b51d6c3fdc6f64f99c70f4e988a846ff1f50f867c9d341c3e8eb65747da8d5fa3c9b69ba7c4c2b7cec15fc6dbdf6612e2977364dfcc1c3bf32d4e5683be075de272b5b0023b8e61bb627e5393643e4792a401582577cf85598ae645b40206bcb51a9279005427aab54702cb4e870f75cde109358af2c868af6743bf5da28c52ec1b439e245859203f71916a18ebacd65233b207580c416824d699089a4544f2b68edb09dcd4e83b894a0c9ca53f7303eb7e43a4d147998500c468dc60a91c2a88709f97c93e1cdbc72154d529bf0e52c75249af22f7be828c9da9d184d73792d0b6c33e10fe2fd3c595b661cc86a9b52aba8e8385bad2bd72e6926610d1ca2bf5f3862c8dacfe67534d143f57c6064bdca72c87855164f210dbbb169b384735d90558778acb647aee7a583909d37eeaaa76167ea21ffacbd39f55477ed36b196b89f339dde5c9a1b93c817a102661ef850669b900850c97aa91f45fcd679b2d02802edaa964aca07d4710ac0445e50967813a5782a60386273009a7eb6ffce59bcf39995d07c271ec16a8e0e349579c02db6da8aa72faae5f96155f7fcd397ab03249981cd639fff269497e909522a59ca064bef78150dfa0d545590d83f2c1dcbdef611815bc8a754b5ff96f084d7bdc595a690e622ea5158c2b11bd216a12f0656ef1f234a65f1ead194fdbeb060397e722d8cff761cf23d89c2c701cfee466b082aa491a6c039b92dc694fa82e7f578356f6d20e5da08d8694bc4bd7bc0df619d15c3946e23e138808f2e1b0f07647b8ad9c25626e0f36be375c1b1f9f4015725aa2f4cfb478b45e05e6d90e06b66802725cb7cfb8f274473178cd0e380b55cd15222b6a792fcbd5b94d6142f0f80c43dbeba3ded7d3cd5f3e1664c6d176f55bed7744c8db79d3d5dd29a382ce8a1d75c673e1490d171b10f3f5bfafa850ea47da55eebbab4178f4f02f4d0e3b707cdc6ce6006559dc08c8c6f3479c42bb4e27c0281598751147d310e6ba5c42a6bc00129a24ee8c752ddb443b3cbf6454f0ff36073c9627fab65cb0d6f9b73299b13580262ff2ad9d4e0f1f1aeb4888e20d0dec9ee630a779d21446e99d2d54f1dc8a96e04347ecea45d246a8f46f2112009aa701180e644f4b7ca4ea80f8a0250950a8d56de3873e6109ce795eba6f902c22e35d79803a32ad349461d57aa0c2f3fb84f99259c6a0d8ee0be6a65a73a7d589f25a2e681f60371c13dc78009f09528e236f9ba5347a9365829543464e4c1feaa85ae7ab635cc7591aa483b36e447868d2ab03bd0d0e010d8039f3e89bbbe0c19554b7100c6c603d56a5c3e5cb9b551c2e420bfff8a2de9781f98721ac49c52ff4620103fd88671f04ef5e64c1bc2d99d4a1b9ff38e6a563a8e4117ba26d8b6e4b719d9aa39d3b2b3b35e449c3ed6fe74e408d13e52bf9c1c12b86b1325796062444b639bc8a9428f0a1c87a66cdcdf91c12fc97fc20e0b500cdc77801c2ba9005ab1e0cbb2ab2cea729eb773fbed48e6a990aa50d9e9fcce7acc549c3e2294542a0405f62b170443bba046b283fc4e3742e1cac284a6f33f527e77077055e8a2362ac51dd1785ed661d18686dc59f316329d1e1aebb05771e6230cc4935afe39106808f5f60dadd4067d22ddd01a3834e3eaf88ccef2e1e987397d81c56cb9d5f12adb4f3c471429910ddca03d25d97cfbfea77873abe12329d4ac5f525d14a1ac7b67804a2df5c81f66b5f7b69c7f0b9fcec00116e378d3a331a40e4d8899e3ba5702fab69bf7ee79bc4c8e5fca9682a826c6d753fd87d9bc8470acab40de36184167450522808baab1cd8edf76bb312a5b4875bbae9b11ccf227968e759da9bc82bb82b3951e948f1341ff9ce047535c4673c264c7de8ea3944d76f18698cdd6483dab1e7f8e8cef668d2ecf68610b475889a15cbac983694e8895659bc2304e67cc892449439833263342d92c302a63e9a0728407a6d2f44aad6f2f811849183b1e11cf0b4645e169c774216a6a92f86e87ca577719b63a3458eab8504118b9068651cbfb7fd95ab04af2286fbcb038378a06bc72c70af6f59d9c70a6948128ab5f13b3cc660cf2429c116ac3e9e804b6ad239186110336305b9642602a9fae33c940443b1de33ccdd63747a3a5f20a0ad9f00e440223dbdb3d9567293446fbb3b02092b1ab40683dca93c686163acb3341ba62fe70768781da01b330e8f68a0503222e927f79ad19a1ca1947949c8326d56c0903b69d8b916f10854b5f51a0787eae29ab73f8c8c44db8632c880978a3adf80feb417c038da3c6445b15a5a5fe5dfd420e7e7a586ecb795f4dfeb0dcf3969cfb5dde0d2670bd296fdab48a96eb571c13f7f36ce45f11b2262b356ba9d9e6185625504378aa64737708c2038e118b80ff1a6505c5260d503b4100438a4e9d1bed2e40c1dc8e3dd9b13d43df7a753607eaca60dba8122cbc8bd0c20803f8372b81e89378231315dda69fb9e313505715d64e5d758d6941738bfca050c4aa9725ddd6c15afe6940568617c08a47c2bc7bc94531c3935524435f8b38a61f0da8f6cf1d2b78c71d0e77825cbdae3a4852e8cc6922c4df092a6a1bdccb9bc39fd96e6a60e864fd96dfeea5980518f4ea8f85dcb4543a4ccfe73714a92945f5e3e68dbf52dbb50e7d9b14592a7a7e98606ae9027ce27f53a58d9c0a7be7da28d35eecb8821ea61dd044a97622a2d68ad4575239cbf04c329f2dc09dc50631c3a124acde8fdc908e02c8426e953fcbaca9fdf4aa54175c7c119894e9c1c8b8774e01350dafc4fceea846b788e1250aacf2d41b410752402a803f0df2dcdaff34ff09229084624d57a652f7fc4b70ed59209b5b263c0741e4b432f49fa3e8f315ffc5589284ff4347ccee679473fd3496a3c2139c153c1dfdd79c9c53ed1f7c4d22a3e4a86505e3b63780d0be6614b81d53259f3cdc61ab629298e4c84988bc488c751b9975fbe4ff9fcfeab31ba63f973255b8f39b8d82299a78e2e68acb7aab22ee86576136a82ec0ade14044c488266c17f8903b4cf2b4cdafa9a5b2c37fa10c64aa761edc4aab0ce88a87a0d39d119927313948a1c7dd9f8de53b5347b539ef6e2c6f8dedbc5aaacdff57c3b898baf3f05e652672b7377189e796d220b4550ec3df0ffce858f9b7afa95bcda2a04ba984cb5184829520bf249610d968b447b80b1e0d4af145fa8684ea652f5289a9a16d11ec4e68e72f9c3651ecc0f59471d9e03468f514a601a06156ccaf591a836f19c2af6d3c631308636a59484acc0ebde1e72a091ca95ee7d391499b321d791edcc0f2bcd69d9a805e345204f87258670763a0173f758b0cec8236ed5de8f0882f09c88840b4cbb730fe20a00e9b1326e46169f1e099e5050efaaedc3e688c430ac15c98ff2908d90dd746ccfed8a25c6aa49de9d0f2c5cf865e895747d40055187d429a0dd763d9a97d8e835a5416153b46ce5537855452447d8d7184d26ffa3cbd9226a1bfa8aebcb2abbc3bf9a80c72b9528fffa1271f717347002d77ed678a2bb3f19e8dfde4ba043bcba32fd5b071935a04e5377cf941963bc62ac551685bea103cf2e3d7e96589061448e764820f1f1ff376c8e3872deef7f3920aff08e7eee02504701a2f64d291c9899f0dbf3e393773b08a002d6b276691b88d96efe878f9281795a5dec6b6aa5e76ce8a762fa22dfd90a5754b246893c12628f635d8ae10c8a10751d0f599af8c6fa9a35e60b4b6d1d8dc31295eab616343cd939aeff51fd2ba09262c330be76d259849d1d6db3cf26156127056b239dc54705ebcd9b85b6b32d2197450f12d88b58af7df6acd289149e913f8a882921fa67c5d95e71d38082a3a354f5befa75e96705e23a4951ca9b36199b067379007b7263a8652e53b92c064946ebcb07ab8d326ae12f5b2063fa32eb49e2b9ed8049c5100ac4b2e839131df38bd611eeea540b3c9a8b0abfe51fcc5ac4e2e19764793c5aa47a2ae69495e54a11576f5296ed81ed389618cf6c506766aebcdece7086a1885592da17b79f73af63f969ccadc900c6c49c31e0480b21f691bae85a763fdb4014b2ce97f949ca0529341dd86513d43ca062e8b1ead8fb5d3b59ed9cb1dd3b12f58a558b734a5107b6bf9434758797ff7136f81aa720a7c2e600b21332b59c8871914f2ae59dc28470febf3a9319d2e7023a01748993f0214af0ab7b0ad82668f4fdff4e100cad63f0604bba44ad3a76536b7819ba13c6f97330cd6d2cce2432144f1cc633227f4b376410e99505ad24b7e3400de0f12d2c7dc9d949734373152e27907d2e1c364256508332c0f6856fa484af90d99f856aec66160b8a90cac7762a8d1577c5ea8f1478078c105873c0047b4c48d16f2d31e3148e7c89c1f579688dcdc54a1934459dc6dd6d147f3dd578b0ebb2fa8d16a4d694709c72d406e502e8921825d1b66e44ea25c28e5cb8fed58f74347e27f6e34fb4c71892064d37ddac945be2e3da933679b9f2c060366e72e3d72ba695d3d6f0385912cc93292cbef73827470cedb42b46742787a6681d17cb0507baf46e9dbfe5ddda750548ebec5cb38c37d46942f7dcf1a50539dfde2b4781dd0485b6dad9b80dbe0d36d8d0a6f99899e11dc98be641fcc05a78abd9ae79ed7c7b0cd2e88a0a409cf97e6b1ec0dee04fa94b93918f67645973b7ca2e06ccca3346bdca4dbff9e6f1243379385dd49c44aacfff8227cad127d5d5885b015d5a101ae888c78193f6c9181cdfeb62dae8ea51796edcd1b67cd0d127e88859145bfa5b2eaa525f3afa721a10acd99a2869e820c058d2d614747b8790c2930a5d69d0af9dca4b35a618ddeaf622552583ee08406085b19a5d3332822ea3caeb233ce94bcb5a85b5de3348569d7ea9e319a18f34a50bd1387b9d5c9addf28e854500aee8d44f70ed0d45edcb01234024624e49f2215609aed881b054cc3de81e56e6e71b38f6c9950422cde9049d2dd412aab5be7fe87f7ddaf229612ba","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
