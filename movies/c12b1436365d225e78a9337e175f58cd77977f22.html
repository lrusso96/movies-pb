<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6ef6043da32fb92f1ada5f1492dd666aee0b562509c09856be2d7b95a74b9f7cdabd297e1e305c77a7d67fc8103d67c42825961bbeed8db076bafd753a8d853a65d1795dbe06924c243c9958e616d3b70d2717de81fff9b05b8d32436b8adc932c0f3b32552857ccdb95cea9e19e8beefe37a3e42ec7efed32929417ce533f4ea87ef667dd95edfb5138bfe636b29f975386aff88a903e2a87a1ff5cdefba9634851b1083be377eb8ef99e1741575dbe25cf28ef0ae0e63503cbc449ef5236e937ba23dc1f3b53a5bdb94ca86ff56a9aba47c8795bcd4ecfc30d5805a409da0fb0959ab0f29176b9ce2b7c712c964c95338753a4c5418f6f9a319ae2aedf7d8c08e4e0e44e569221f41e67d2993819087c50674872b42c5ce1c5c9462c8fe92668e1c67d12f9494e1574d034128a704d05414afc0a259b0f7fae867a6c3a1a5666b3e55b6873960588700086f3cd658abbb7d4f693543e4d8491eef3d00275d443dd63afa24d89562e648e06f20c4f40ac2fc9d06ba0cebb09ca8c987ed105237c0769fde17055e61054c867ce46f9332ba4cadfab83cde80265b7dcd9ae58721025be46d09cb29c09427c10d8d8488df4a1ec21006a3a3f49a0aeba748ed72468ec5923aabce97d9b5d2f3c73180cc85d2172597d2f7fc1d6f5853eb9bd388be65003b74c32ccd38b7de987e7e0e0d1090f31d1e6d29bd937ab3e7a0bfcecb3e628937c163481a4169bdae7ac13649fdd91dfd8fa00cb730e11e0a7adf4a90905d970e3f290b660dbf4859a66c1f8b30e85de59e758c5e9afd57ca4d8f27c344353a4b30d6ed62adb65cb107f3f76bdfada195922f549e7d657169710406e85fd572d13eee251df009069c4c572e064905432c4d07b4458ff3572c71d5e127a096aac7c6f3e3cf3fc79280367227e10afd0ccab458f7b9141e6e7be6265847af8658e70c882a0a4eca8653b9d2db731f16de8a39108fbbb028433bcb4050bab9390266a37d94af5c2e6345b3350a17b4296e99d2cc04995c243d3ba7c5cf4d7c2dea00f7fecae1a8b802ae47bbcf76f7f5d5ad238586485ac1073ed3f87750bacf7896f87286e9d1fcc1dd41b648f352dde984d622de609b6b3284b4816d70235839402c00e0587c891a7fabe2d53b31009ef6f878fb695fb713f6ef09736a907ceca6232bcf154cc6db7cb8f09ed79d566e2c07ffdd13dfaf0f9fea1d6d0c55527a511661cfa68f560f4d5efb532d82b79448d6d3b907bed78622b6129e5039358b4d88ddb27538301fd1d2e187d2b22cb9c66a8122f3a135d2bbb078dcbf9049742688d68394a10df890217c56c677120b0f6cf200fbef951e8b397ba783ec830ae538c4cd0087c6916f5da60367789d7906e28f6d8a98770771f0f6cb9d7c2a47794d1065160cd8a0bbabfa867e58ef4e567b4e2f7fa442db3e51a71aece15e7895ce56f52516e1abd575c47c1375b4d0b4d3840f97737f157348a293d593b26b9d3b4ef0d8ec11f930b5301e89453eedfd0388c7c32481a512426662e029799efc062b0d447b33c53c12f25a96f20dc95f955fabed657fe5395b496dd5466a54bd9363b136b0b48dccecb25beafdf9f4a6a11cbc83f223cb68f31f4df830e46e3ef76d9de25c231672410867303d0e0e1adaa6e7e2f5dcc2839ae4b9ac9a595d428bff804d41768b0bf3deabaf5a1757de2520b289ad2f542a8ab2ca3c99a6666e42c856300f9e51374bebcf9719c370b5266fe1c089a4ddc2a52b3eaebcb4da5810b94a042aef84bf70da23405eefcb23979ac3dfe21ececb54478842683e9e7c15f6786c5ebf0f0329233b029243cf6fd01f4ff96645ba40169e30aa593f1f881fef7533138e88f4168d227520f7670d209ec96985ce4ffb8765d75d3360ce12f50531ec14c84faea74865b4ae02b287b77dabc1608a9c885ec3dd7649d16228d6e8a2d5d37382295adb95ab14641d1aee436bac9a9f0b661831c5c6e3b8573c315938d197fd0304df7175ec0b3cee9295d28f5d1a133caf40da6acabb4b6adc1f777732aa0962d14625c4bac6491a6749470601c7361edef84ca3e69aeb1b94c3d5746003beea44f019ec8a6c1667dcc2a432b639f3c9793c131923a91313d16b34763de7988f93d8273ecd4cbeaf549b8165b06b9b5fd3a74582b8b3c5b63e83b298ec343924684c359b3e1084885d2f2d0747223ccd4ea8c32528e90ea8dff056d9aff449aa9a6ce3bde0908a36a9baa30d8c560b8e4d650598676cbd06ace5094ef4773d08295a5b4dd5cc9eac4262730401407aa282e41eb8c22ed309d9b562d6c9bfe9d4cf6f71e2886b8585ed97591a2e347933a208fedc8b2f217f1d7ccb2a883b0ba01da935c773ff790a7fb767fdf4339f245b78e6714f6c2435164a120a049963f1586a409a9330d56b4f0294cb6cb424859d2a8843e4bfc3ef41beb23b16c5b02fb1bf4e47e8d0131910be0cfd4afad1ab30f6fb641a6ef93916e7772e38f289e10648a75995f9a65f32482e7e3eaf6244995da0c47bf1c2f57fb03879cd42e8865eeb99c4d433c8692f392c35ddab1299a5cd9a8a99d78b9a96615568b5fb8d945dc32168f8cc41c70622263e48e05671cf02b7688052b350f0a0801948b6df5c39805563e333be64731ff6c1d4f5b711571681e128f607d5a76d5aff4123e00f0f2962827161ba2486101e464dae9b5ec4f973dc869cc1b8b11d2c75f563ea9c679662e8263b5f28ad0632f1d9140c255c4f31c7d31d67e492b1549716a301db4f8093c7042fd6620de51b4214fe84761a1bd9dbe9d7fc777123fc91d3a509dac0308a4fcdf5e444af7e5ed55b93010c8d2f89ba88ecfc6ce33d61bc7826fc1507b3a31e2fa69eb1d4225ac0369a2694b5d64b31412b80684638a60d864fa33dc8d30501cdf491b676a3c7becad53c8d111d944bc71a417c88e219694482daafc09a1f0cf10fac68a8667baac6344bec3f20de0f68eaf6474c6968c8c6c093ea3ab4eaf93216df607c5c6dde932d9db12d9ab515f9d0a3e20e626321bf1e8c3002a985680709d9bf749f5f3c4af0eb16aa8211ff491ab4ee1fd746299b3791a484e4086ad9a9058f5411bf7b35f57d4f4aec8bf1bd28ad559a758499cd5e861ba69441eed64bb06c0384d2e09f7d1bf4cf429945cfe426f194e149851c479fd632118e6a6e41c87323968330b22bae8653eb86312cfa184fcf05cae5193804146d3c78cbebf56a0cc7eed73bf19fba5e6f67435652cd7ca4d8aff5a2ab1374dcc163270bf8755af7b1f66109e9188d49e75bb9d7f298a699f786b9c9bb624176612db0aa0086eef1ab9c2ea9800bec5730ca2439b351de114b4733950566d6d5c66f4b5bff576e8d9ec14d6e6cdb7b44bd63308940e6b2455ddc14a30aeb9e2bc23ceeef4f36f84b34407ae9ef7bf5d6d192018ee30fd377dc4d2cca29f944651bc48f360037cf14bc3c3c4d10281180f08a5f28c4d87c302ee80ffcd246d4f0f9891c67b4755dea701f1a97c2c68cc0b30cd54f65c2c3cf6b851ba83e98000743146b48daee7b9fc95a5702063f43d5332f01c4f3277c01019a43f7e6b157c5b6d70215e3654f6d4b645812e696fc67c016daca837517d27238a82031bc3f35a90ae6de75f427cb0dc1c479fe8ccf0f44df04ad3d0241c3c9f189b852ca28981ec26877128fb2039b86cd23a1f4e0d134f7166af66c93377abd9820eab70c1dc34dd306a01c55d434635b27942da042f5004545e9ed2e0ebcec5617c91ef527b7735656b77089cd0592a04fb323305183bc59781870d7684766b9d4b66cd5f037036da44b6e81f19e973e3ac5749064b756896785bc86e1f5a1fbac5265bbca1d6511e6ddb8e899554bd1c353d2db2a9895bfa595ae1473872c233b218932cfbd57ab89cebad5c9d387907cb72b5e9ca909c165e6df29ce5cff11acda0e3fc64812e2825c72ee4e15cfa64b02efdb6742953392ebe81b83e3bdae160f26fdfd1431b557246ae601a8b395d02042d7eb7894d3350e9ec95e05b0b9797068e6e59b7ab57306066f3a8d0f476615d12c9919ba45e89068035add28b6546cace43486e7d975883f8e840cd480fc7b33d7d986e32a52b2aab1b4966340a81caff914d8a7d29298190e4ebda80c26e821d0bc2ba90e67c97a4a40dcae5a941e9805ecd10751ed93b893a92570cafc2a44a923ad49af2f99a5509a9bd9b87544b7e459e1602e510ce989054c1c4e43a99156925aeac3d437623e2f4bd7f9f8dd4a777b613344577f6f7f3ce70f5168d2d4804c6acd29d49852c3079e29258a21f20344e29ffd25030d778af646ddb7fa00628c298945f4e4e5993064aac9de3f047a8c4d3e148967de3dfdcb8bc0bcbc2989558f2a5a99d8a8aac0de21cb55f5ba46414319650ce3e4c25272ad835347d0dcf17c7f34387293f3fd19cbf34be7a975323e5d9c8fceb2e508cc319c3dfef4c795fae71473e07a122328a6be3aa7a3993add81e923368eec2931c146e9ff28e4124f27a04490552195d875c094efbae32eea920c43b5d6e67ddc31639f2db4d4a5a9d8488ce8a466f605a476f9ea840a415de90f46e26764f2a0132ce757e10247897a7eaebff5960ddc5c21a27417dc850fda4e8ebbd8954963cba3dfd2d782b42335d0c5a8c180e03186d05381045338b1150f1a4a0c40ed9ee2434dfd6f1d96415ed24d6b3e03ac5f0cf887ac97e3b1e2e233c41232189540158e98fda3d3138090a3a12e7ce918cb335c0e8c522b98e224474243503a48fea1f820bae0c634345cb7d15e974e4ebad1631410eaea14ff650ceb1105cac040342f7a901972e71db7c9d7c67635defffc44a1fe675ba49f666122fce9b6e95d19439ecdb0344b90884ccd42cecdb968d22c9380ebcd47ef918ee38b2afcec1977b05591b9cf5dba06372e2de0f78cdbd7df333f820069f4facdd7926a39b61784bafa27aedcb25bdaa73ad88e342ec109f5a138bba8ac9a07a89219020125bef4baf00da4dab20c4add31dc7be2dd63c380afcbaea7672bb9e280df46c4a72651ec35755428ef2a3f49b5db7b84f1dba9aad01000ed08f422fb80543c5e53e0c97692e5984a35a0a504f928c59eeeef30c39b1410ea996578272c543dab25d591f101e5e5d21ab5dd69b3e73cba4c5b4eeeb3a8435b0d81411ff1dc71a6561c855c7c3f820605d4a4ec0c931c25e8011da3c9c6b328b17d0dccbba9f42bf49ea0fa875829deb1d81cc20902cab910c799f8127932d01a50b7a229d203982b00ec7408406ab15192181e78cf21f9ba546196c855431183e6eb44fd427fc20b04b8a9d4970c6cde213cece9d0e6627cce052fd6ea37a2f9b5a327457461664e5fb60c6b220546d489bc7c03923213e02143f59e8d3d6c042b56e1b1a04f5ecaee610521cb859c3c332b9fac4e37101bae4fe5819f8332b634923c2885b9988eda5ccef1cee18c0ca39fadf59fd08e6c5d8daef4e0ae4545f41871b7ce56c2798665797b4e10bc42d4c2efac18c7e41ac8d65489e907f8a8f50a52b9814c33241816c30b3893434b36d089b09b2ff1ef90a8dd98ed5b7f02c9aff033fb2537c16a21215a7058ecd78f8506a82bcc2052190d711fb157ac1e60f6853820e7af9fbaec4af4641201e17d067ed523e8fb57c2303c0bec5ea87093df5c2382518e2a689de44bb06a8832180f2317a3dd14227f61e73afe6060c10494346df522dcd4acea0808b7e31bf7e12cba4e4521a9c599596a26ed3fcc27dc9a9dbdc02bd25a87f28746a088413d4807803a14ba98d0ab35ccdf62eab240f946312518735685700c9224df5bc0388440e8476b4ddbc40b7df6535e0cbc6f1a661ce53bd9c029d263443e3405270162b81d9a41b0c900e6615a1211743416641f4940234e441bea77fee5cd9527da2fbdee8b889bd1491785c128d08359e6fff94a7598163c84b75cc807c3ecb77071a3251036b6970733077a304da0242ad94b1f946a0424c6bbcd1743c4e6067438ecd1253425d06483e9d7efee2498a0a47230cb378bdd87b4fde075680fb29dfb4004f0c825cb0f5794b6f6e9b92266db1e5d607ca9f396258f62a560b11abc9fed4a095a591ececff03e9d0a9fc215482d571a6450eb578c0f43a53f5115faa82a149ef7732bd8f7c0f5fd5bfdace8596a93ee3f15414f1ba473239d28456ce0c7da821bf1ae6687c37d4223372b20c851e6c04c5f05b08c842db53bec145eba0691907d2993f2d47e8ac63a31b71de888270458cfc534b84f1ce861db75db9212c5c6a3b15fee9a4697b6dd19cab0519c9b923d5903d8cd0cde2fda3d9478de2a3460a8b66e33c4ad042715e8b2dd3e1e8e17f54e8b35a0839ea5d62a9cb44bfe97005db14ed0c1723691827088a7ac4687d47f62db3efd3a2dfd9ddeeac15e5072e8401623a5fb01dc44cf84a9d77d15b7e530f2c193969ce5707c12a1ff43545ef484409cb2035e3644fc06b970c198cc9ee4af481945c6fd2ef4df35abbc14397ed3b3ddda2192ebd032f175b40f6facd2561c86ad1d5387b227ba69e79ae5d86f13c7fa0f38abd31461f4552b9d4a1488baf418c94bd2204f675a1d213cb12d93aac93822394e72346567ec5eb4970e8ec6addccf9f8bbfb411579a64a30daef8ccbb9b484b01eed9a4c3a6af3d7c0511f98ec9e36ef8ce5b235497e897b78036d492e0dae7a6bafa54015f28cc82d5e91a1514e79dae38fd554f10fbe15fbc7bbb17f9a749513ec93e3214b53f7b7ee72a7738584889c38a62e8b4264c7434ad983eff7808860575361e095eb266c0c3bb1bb518b6b1c1478928f941e96651b66a45a417dc77b91c0c5cc0b709136ff427bb37b38bb042950c4090d6319710d369c0de2ff8dd5ddefdcc571fef11ec6738c1e926003c7779860bf84289a6ee4715aaa025078cecb2bfcbf49889d9d09a6bc1ed1bd90019120a23fe528daac5ff4a3cf9afabd67cf41b4642302c2e6b505f9791602aca42bd6a930319f6ec4173fe5880b5146516bafaabdddccd87692c5daf4aa3086f467d3f12957a74293ffc38e5f52535ec7917be131df5f0829753f1ae6c533225a51e9639a6cd52ccc8517e0195cfa1550447213dbaeae15ed73561980ea507c6d01c2a20bd731e512acfe2c2050890d8b92f92eb6d0bb027a653b8e2377979dda6b87b3879415f2e901cc5116ca51d574f967f309fe06a5260d26bcba7d379fa36162ca82cbfdf1dcd453dae2fd11c2758c16b54deb09b8fadf53586502b9bb09cfa875780005c6651d29eb7a3e7c900cee0ed1feeb3b53151ea18ef4fb26308baa6470b48067ee980e8569dcd23386ea89b0af0730f996f039da68c9a3a3df5ac2e1fdf9ebde91c1ddf5bd923005322480350b317ad60586b1fa62efdcd74bbba3365c254a7a0e6ed001f9045d0b0427d8e44e51d95f0b60ede2fc69e148ba5f269cf473083337479a151d9cf21d7a884b9c6c58b04d563c963525913f13761b5c4bfd8086c5a90d669fd06801910a5090ef8f050417766a255c845c523104d3492eafb41da9c912662b04fea6c2eadf2af081936d306273f03859cf986c4aeee022ff6fc8d34ad821042305a398c0afb248ef8ed3f925ca167919d443eacb71e6a65ee3aa0be9409d42981cc0229273d6694f080c95fe2b5e0a06612241fd391ecced5962a2463792455f720973d3c524d0708828797eb17f2a6b47cc0936cc84ad27cc3446b509e98514b973d3ea2efc615cba1b6f33d230067e0b1a8da5bf2f7287e2f85c40dd9a33f38690ef8a2bd85024d11b66b1291959cafc6af61c00d6f3d0cd4cf3e8fcaf5dfadb12cce5fa0396fe501083f0806c7251f38b1231e50a056e934a59691d9cbd7fb6d87c1ab72a00c5e5da4539a50b38df8d16a02226529841352c44c79208d432649fc333dc84eb5fe54f4815ded36c5112642672501606045b9170e781d8615810769ef8a993ba21b013af2384a4a3cebf1c083abd07451f0eef643ba981d64225611d5721a05b45d4f028fdd8316257b8f5cadba393ecc461bd64de57043adca8370fb31e46a73a45acda2f6443ab7af834e0abb51f8bebf881945dc19423ada48ad21a0e416b1e090f79a85ba91c99e4b42e91152f89b009835effb17caf835dc72dd2c1f26470d331a2413339858be3fdc4a489625bf8a4214fdcf76dfb4b937f1a881a9afd3bd26279ca70373cab5021e5a9ae71ae45cf242deb44c17b7795e5405c70dec0c272431658b99241669a1f0a7ded9f274f7b3bf49ef625d3d88f85ec2c7ef87718e28581e0c776a5b7c2019a4ea3e4a72dae06ff53bd3c87b0e64259d1961f63b5a2955f6963ffe1ecb1266614b56403ff0bb7a08c4f20d60be8ed51eeaaa2e5a9fd79e814771aa4ea3fa3de5fdd99495ce887f1a0f62d60c00fa3292a6baa714653bf743a8803ba498c24520783023bd3f1d98a0ffadaf6ca9e6f8e0ab570edc5057df4678d2e0e2131642097c65c394dceb7239ab09d3c197d41de35fbc0ff23ed320d64fda3b923cb57bd1ecc98d3751e37406b9ed4c197fbceab7ea6d56a77a50467b9c0f772bce46a8df1e8e0cfac420f25d910be2dc733c48266566541cffa631beefff43dc5e85d931c8450aa23e7759b2ec19413d8a578ac857f068773c5b64470e5cb41dd4996a10ab0379e7a44a0a4faa11125c714fd797264dc70a4fb091f2c8fab4483736fab2a5fde770e559db40b402d8fdde684ec1ec9c1792e107f2389e18bd12b500ac4c3e0a36f4971b842aa0f9f3abb3475751d21f70a84d0674f52913949fe76ceeeb67b49de5a55e8f2c7207916b025f5ef3331973447b27508724d869d7193fb13475b706d10d9e43e5e439f12aad46d285b200b8cc90e512f7fbd7d61623909912e94db84bf96df50046469a437709c8461c040993c54d474017510bfc9da5665ec20c0d3236ea4e109d630399e280fe9f55c40feb421b3744c91cd5ba0a7b7dbe0339cd960d156667e109cff072c4da3fc6d0af2bb421c4c730123547a3713d15c45ddc59b131352243bc5c01d0f23e21c0abbba7d2848a8715f6d66c6dfd2edb48394aeed00fa3fe27a8a166e0b02a6d8fc3885fdceabae10a81b46c3fdff7ff4bccc945b4e4e2de1bd1ac54cf2123636bbf61867d0dc9ecb11e802fd1354e56797df97f0c4dd4f4a1b0e985128ded597274dd7e07068ef826044c6740afa3ab8d812e426b021a7ea6d3869adbf73e3446c0ac2b6d51e1f7ba7f99eab8b7813daee8939e83e97643830e3dbc3f633d003e1a9ed3b6bfa0ecd7a2cb483312c2c45999ec2317a254254935294ebaa5fd181f95f5dc6da0fa5a7a779aac4b1f176793ec94db900cc45621ed07bbb2ef74263e310f108ab5d65dce9630054d8f4e45e9220d7b63e5412cc871a223c1e82bf5c165c929fd95425b7757ea7bc3baad7406b6a8dc1b92c7d66a3bbc687f91865b9ec4d4873cf2c28826fad4f61b905485e5af4a05a09c741602da383d70138d3601a0e33e837875e377cba0375545b3fbd47444d68c9b46c1b18ff2a508acd32f27917e6f47c4bcba7a4009a94358d1ffceeded16f45e5852acaa60d61d4edf751ba3c2f972bac9009653c9eddf399bc0de85bb1a5d290d870e905566172c5a8648e775102a84bf292963a063dae4a41aac78e2b8168f8464171372548a36ba304275b10be55d5b34e17a7d815e50624fbf7bb2350e7772cfca4077c591e6706fbd0af233ee127fa0385ddebb0049063725f1c4e45ad18d4cb31f72807104d498da584f07f7af021c22bedb8b25a0264598d7d74618e940ff4fc66ed7754a28589e668a4bbd785bd51b669129850a10bc7130295e41f669d231ce7064ec738b91ba77effb38e81032be761608822c16a5b07a6a20ef2457a3283969b3585c27512eb93ca6421aef52da7e31d87a8b0be297c41780e12a9557870f249ad940f35b10e68ba81a19a1b287a8c7644500c647b41bede5e37d42df3c110da8a76a66f96f3e2c9bcf77c5443a563aaa4ffd87e077f44d3995a8371c06279d0cd284af6e01a5e95401401569b2d3e45124f765f10f275a3a8ef03a6a3ada89aea955f15c9bc8ca68c8c36b64795bb9ad01ebbf6c10f34e6ee0961c0087578a2d6f8aa751c1f567cb7d302203d47099721310cb69f1b5a100b0df5606c2ef3eb82e3e128885f82371fbbaedc60eda094a67daf3ab48da52c34ac5e2c5046d60ab692b9641d93e63d043ea898807df3e32c3a78bfebec161eaf089ac14eeb6bfe25da3ff6d343969362dc8e9ec1d909f6ef9cb4aded99e3c980cae9a9ede8838df257a2158d5d382d84daa41d36e9fbef9e2a6808a253d0a6f9c5d0d476fd2a39f52e46ef8949d6714408f417f1fca0d38c6f4427c65397c20d8e4c6293ea946e5fa992af2b77930bf7cf36a1c0407b10a39e1152667c75e17e66957f26255c51204ddfa16fb29fdce75a05867911717f5410638240cd021f7369e4ddd982168304070f77c3f323e8f3dee2214aa5993c5f1c51a0b7f1940db74bf2db94605be2db9a6c89ca9be296516fa5d7449d44a3f5641e3d06c7973ed1b93a35a47910a1d99fe9b8bdd4e97879cdfe2d2be811d01451c258ca9fb11199aa08384cbc1f246a319ffe6460778423cc421253a43b5497e67ba137ff74cb7111df1cbb10b64d0ba1c1f5e8dd60317b3c07ee692a2e97fd5368aeed53a485e0d4fabe2c4a42cc482b3da3bc50176d66f0ff05d24f99ac4fbe4355bf21ecbb5cb0a304c6983c0906a2228396318f50e431ae1a13f077d19bfbf12509b8bd0d35a5952558809796db2335d4fae38be2a49a7a10bab8184ade7ff38e7fabd826d9f9b9caabbba55d7592bbd3829fc8d1b558acbed46e754d9c4ef5c4301e0af1eb0beb852059d8b1d7b3c7e3ecd0010fd3219c890577dd3e9cd7149b86dd1a455324a50bce98868a9f75a9a03795ca6ac656dc59fd9dc5e18982a039f0536df76cefa189bcc32915624c41ae8b594850b584e582811764ea8afbc7ed6039632f9b84a65c0b393dd39d3027f34124ecbf0cd1d84df9708079aaca551de9023d94879c7ecbc5ef652646576cc420c80b633fa67fcab79169a4ba81172e35a1c2f3e1b4a88b96c013fedd497f78aea3896b0b09514c49178b1b20681c2b1e3c8b6f9fbac5ad62e1b7ef7d9f789df95c004a034814a41572076c6ebd58f81a1433361b010f1be657497253a7e52892b357a852c69e0bb7a8f0f0be7068eeeb1d1520c905ef60d72b0184324300a01daa9747d40b172803c20aff4fabc0ae298561f65446e89f3b5bca5ecff25001276e8b2b89584b2b24111e780a862bcb8610a15464a672ea0fa23f887c95db62d486b51db99fa06e773cbfd14f17724111b274dfd23e7179e45e5e34d2bde605ed683fca8675568a304871793da7aad2f2bf76a7ca15681941d96e08ca2f84c8edd0b2765badfe34506329a5993ade676773f31c33b956f407d2d654b9d40ad680f3339078600be5a0f4a9a88eb77506950d1e67bbb8df949fb00da02203faaa4dd67767140f470fe78cd55964da8c93decdbf0716deb28361df673cdd8e8d7f014721b33d6ca65e86d3bda5d811e52a509734963f5b400dd06cf4cd6cec1a27673031978a0bee64673466db035873c053570e00355e977bfcf7f987b1dc50bc4b848695df83702a411573518f77ce5248ef2b5958479b064fcac909fd0ba8eb494b1eab4cffcc6300597379cb4d023e8ca623dde7580f49aec034231ac0fc15dd11948e5241d7e2ac939315ee6ddc6e6f1cd662173e41dfb8da142e869110144b5312114e7fff8a485ae74c020f18272e8bbbad9aa3e267ef18b8cc3d81ad38b0e947c9b45d452c410f9c2ec42cdfeabb76b92ff4b749af9a453c12c28d2249fc7f02e972e90a7f5117fcdc4717035e7a21626653c37c355eec65df3c5423d33bd2252510ba580a99a22f2e005f20009c33c6457d93fccb4aef1cd1417bd29d308168cd5086435f73c9989cfd806c1c5f7f14f903e3de1aac9889513fd086c5059e39c44eb0608d44b54ecb3f236be8ab12612a623ae3709208939e8855e24f0b8c80edd43cb7be5f0347a742bca483f6ed6455a964e7ce1d67753f06f2e8963de615ae8ea80a9d4b315f655647e341f8ff25ec6dde872049404bd837bc5aabfef0ccbe0560418d8519d65c0b6e8a3ee82fce6ee4340dfd48d96bb7c7ffeefadfe2b9420a8d0af4bbace2e78c14def2f9191b90c8e29f0b412fe5b0a1bcbef618426f04f9cc4908ab71e6fde19e1a3321c4bde1f94cb1dcc14782493bf3d24317ed18d252f768209fc71513b0e4cb985552f823ef8df74b6330542f798f2d66576bc9359b49ffd5ee0dd94186b43f910bde15cc5a3f8241fae3e930a7e3d81b5395311c2820338a357d702274338b119afd5e06eef2ec499af6d53883e96f351e4664e08a65974eb52ec507ebf393cc7913596c7d34a07c59109be8c15062a689738faf6299da07a4e2b1ce41dc152e67e2bf61231e74d4ae65f49ac4259cb9f5ca818dad0ee0ee1b4d06e97720ca1daea0d92bd4f596ae2ea93b51d331501670d76f3c974d2f7a14e83eb65926491807c854ffe936d95c16d6cea0676eeb3486d1b0ad890afb5625f8760a506af1eed08f62c666ba7503877f69574e17aad12c7785067ceebc5b8407e280e93f8dc37d637c0af620ee3c48d534d1a52b6b15e3b0285c98c340e185e50b3e3ad098c7aab7ae9fe3e8f809cf8807da3af2beb5fd1ec5a8fbd31ccea87d6f43892f2b33996b47281ad7f4468a353540f46ccbac1d7591c8129c55eea5d758be1e35bb9c0ecb4c2d32aa757bf3b0e85de7cd1b8da0373ae47a3f376d4d6fba53656de2fdb69b8fa5ac716b4c4711262ca5edb9918af5d280c83bd56b66476b5267078263757c47ffd3d6e264ac8cb626005d4652764d8ec2b5da526b8d99443e12","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
