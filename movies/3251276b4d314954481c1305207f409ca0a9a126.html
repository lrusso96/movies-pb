<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"684a7f77d248708c21169cde7d5d087bbca1dd75f887e40a75acf8a826cc238e3b7d6c40612d18a80a297221db327a5e73fe65a585b6b43c1cde05cae4e7b7b075733e66c9e6f5e51861f14c7a1769c2ec3f66133c7113d4be10d016adacd6e0c74ec40d6e115fa9a7c9feeb18ab3806ce1f474aca94eeccccc48a4f4c51f57cbd4cb756fe348f595d591fd650f2e6894e01a5ca350af49f8246a38e71fdd00c491a3719fc7a6d6e36ee5ea8f72478002ff76e086225fc67a87a7c1ba2efab6121c419f9bc4b2798c34892b71078255051669aa5c3ef8aa7ac771b56c24aebc014b7034323f6ce336e09893b0c8d2a8d5229cd57ec82070d33370e7713792209650838e1a48cb54207bbc1259804701683a7089c79580c374a172898e36cc027eecba58a8db59b8a409433dbb3c1ac93e264833b7fb5917dc83945297280a669fde9fdc972b2f903a80addd03087ebe9fe0b7833d2e9b72538798e88d7dda2076972c14f850b4e8b5e5bbb1e20848f58216a605b111eefccc33119ce630cb6c86ab2ef39f4a0e9cbb8da7df428d823506ccef97607b847edbfeae427eae83068fbfdce226e6c982aafd3f9313f665270ed2c956ad47808f3e5b1bb940ae93085042cefc182411b8a8d1df4d09775a6c1ca915b1b8e7b60825e480ad5e67776390f24c25dc4917dab166c4153847500954983f9d571c1b6fc014659b3a2dfb100014b361f4118d2b8586fabdbe6f0b4d21b60597f7a62a6ddfaafbb552690ce07683e2bc8f69c8efbddc4086e745cff7fe74ba1d923226a477fe9b2a9be9310bcb7bc15ed56dd0b8c55285e315e849b90a67ed09443320815f9355902f39a44ab316c95e68a39180d180f101b71a1bf7f0643a1d97265acbb24c733777f6dfa74c58c2e5b250e2e6908cbf97aa794c8013d220e2dc3af37b9bc86e4dcae5f1d24b6c90e272c27d9827beca0c98de482cc1e02cc49420da06e9e184f32c47ada6992ce25021e3db2060621ee5c230ac1c0c55d45bfb413036d2665b616c4e53df8fc59aff24b447bb9e5754f36a691a3bab98d7a59cdeba8bf765c4f4d87454959cc4adcd2f38c315c4ca68872f444309e15922b7bfd2e2ba0f0e020b30a298c1c7259a0854e1d1f8fcd24cc1a03c0ac07790e58d3a95e052eef43aadd6ca702cb8f3153d44f642ec64606f05314c1ff37edc60b751185c2aa89baa33152872c50e847ba6dabe1f218b20b1ebe0955cbc9ae2a3459d5cfdab563dde0260f196a332ec1b5bba87350aaedbef7659775803882ca380410b0464384028ca6cecaec7921cd54e8479fb15cff9e3db69d2bb44c7ebf7769a18489ce694cc65cb488f5b00eb8f4af8ce92ccf533bb5ac80a389dc11bd2dede90e540c98003b7ad4be61ceb57cda62b6c101493275afea442d0ca13928c28a2bca2a36261132c872c7861a123c0011a05f2b3829c746148991151f1ce7429288109481a6f89764771fe5d8ea8ed9af4224c57dcc75057cfdbc36c2479f8d004889e0fbab471c01612a02f6695e14ad99e16ce2b9036537bb11e4fb1ebb6c57634d29ba741b5d6c23b54c432e78ef65971adbdc868becde51b70c1c1e76d913ef964ab7dd4e42434ffb4d6a53b40b4b8d8ef30068451b23846af4a1fe843f1e5c46f6151a183524f49a0fb17c6404689a1a5c199b86447eb1e238ddb6cba7c6dc9eada0d7b2a02b83b3b6c28bfb947c44882b2aec40be40a337e7624b1cd54882a980f05339532df6181a4cbea4ffe2fe26e59ced507ea22f711f6935715155080561d036153b9a3f1d1e26c36ef96fea1b9cff337a66afd7427071abc4500814f92dde997143d638761a5af944861b0c8695146c705a70a272259361d37bf43b766449a2c01a90bd7d2c8ac0a0e20b76bae077902c1bcde56bcf294f161a74419023cfa72aae3186b21c862faa726faccc34f42651e92a8c605a10ab92b058cd26a016df82807822380f059e4239b580d6bc0656f448437544a80baba80a5ca1d687266159eb18bca81b989a3ff3614b40a1a8b99d271a2de78a2c34daf31d3b1119ef6739996c5caee013d75c5e5c387a1c1a3b701844c7ddb38db7ec2961a358dc2fb66d0cbd3c93b46e49d28758f263898f0f05a540bd92cdffce140940f2cba0653d329a7d83fc6fed6853fe2a8ead1c17a4bc6ecf75d07eae0bc33628d7877fbd5eff321edc5db4759f16a49e8f67d89938ec53c5e2fe3143941b6149e41d8d05f0477665180c9c65e6dff627eee5321424f45886426649d80fcf67d7c9e0a9cb27971dfb5f3efd966d53171da3794b515b78c3cbe9b8065fdc28498a968439db78a5c63ff1f8a4a4f0772cf694b059e57121158913309a1fe6d1aa31c8edc66ddbb025ed8d1f6ecbe876e4476e7d5c678c98a8373fdb57ecfe2929078c23f8e3e27f692a824d7c2bf1189c1b69f91662c26a496d8899379411088dd8ede14d0a2a12cda963dec33625cafed1b681fa4f2d7f568f5b3f4c12e3a5427294eb438a67837aaf46d1fc3e8420e47c5915ee7135f37ae9b7b61a12b145b91febf44762cdd8527682f9ee774ec6b2c660b49836b85e444683cef74f16e1077edeb6ce67536db090ed7d18aa93eb0df3070dc2dab720b2731632ef993ae17bbc237bcfafe46401cc4e671a1e9d5bf1f6f404f79ffb5e4ffb37cdc94344fcc81f8ab146728a815a3fb0e14fcc0c67ff86e14b559e87272ac9976b4bade44a669bacb0e1996e73a5f297b1c0b0b535a712ccc478b9d8fc9ee58737004dc1941c84274044ae2a5fa2df3a2fd72a90acaeef3ee8dafeff28e326669f71a399bbec146903e5c0b6bd3f91b3e356a48e5edf415ffc980de243b0af3cd60633525ff4e0a9beb495e388dea757d1bbf3fdabc0c753aa10ff81d824499c2f2f49b778ae94ae3e1d7dfab4ae71f306bbc44aaf1669d72a64fdb9f3d40d6024756ffe8c519c5c607b936f9403b56fd695c9b54dd3b4036735173d08e12f435f1cad6376cf105ece737f60a2b9cc04c5d34a55962520d232082858894c5d3e77f55b0663ed2e17e25e3896a433d3004de8b3fb27921a933fa166e17caf8464575f0ac422810ec5f937ad959f17ee7eb931644c20288b31b2336445fcb4b7d1a0aa6f4c253fc2f5f29f07855a9d3b82848bd72511848471aaf9bcb72efc85b523080c91eb68045ad81c1d6ebd424bac2a79a0c0f50fdb4392feaaae0dca30a6c6acecbb7b392e6a53045797f27d54957ebdc21c4e345836cbded1a4fbc33923c150a45d3b80851b2277ecb9b783d1c8dafc1529496aba552904b365af5bb81dc12ac2bcdd5c36a3b250d63916336427bd38120f15bf73abb6a099cd1e15c87a912510157c758d376d5778b3fa86f262afcc238e0ebb8283b2f908a91598b173f59e4d9d1cdce52b3e8c1e450926b165bfd01713599b391068a22f8898bc4ed63db2b450e7e2bef08ac44093cd161788378d1db31719a80d09c00aed365569d88938ed6a9d5581a222c7b77c6e301df76e7ee02d6313eac1ab8855d1f08f27505d0c59688798045f01ae1f5c6993102ceb724026039c4fa6d7503b9ac0cf1ca77b034394f8db55bd61a0e4961176fa6e9fd62ba1b8157c449a9e95dc2e390a06a5fe12ac2172bf7aa3a7c70cc6f8f5685fd0334ae9500dd6df70509ef9331e9119774245112de312fb2318b735f2cc13ead2474d88ec6ec59b26bcc6a430f0ee7c161178df125ed4afe9013c81a62e3f5e60ad77869467481b976b808f29cdcadb75ef8a1579cd56807b9e6602fef9013b0dd7dac01f1ff52a81310f176b40cb64eef54612b8a2f09de23b07b00e1806a06eea57b8aea94a7b932ba0c73e453f27938968d6ccf24ada22319f82f7453dda6869628e68b352ec2ebbb79164124c6f3cf696f4f059a4cf5e6fe569b49971b7bb56faae6f4b5604ea77b4c91117f96a1875027c17736e4ecb11dbf65dd7e2ecfbf3a2b7d399c948aa8358414184b381cc9773bd45475479570828e86afccbd2bf60119190c5580a4c2aaa3e63941ac8b2198c7c39a9bfe5465bcf59570477c0dbf04ba57a01697ecd23ca0ca52c412e8bd74e3441fc16d58a23c726903290e57183aa33a6e9acfb85b4ecc6fb72560948c96364a4c03ab0f872e955a4adc359db8551e8fdd681b0a337c791e289983f259b30809ff6ffcbf7a139d0fc3d3722b32fa54b2c28b00f1f33fe82885cde019a131a062b187bcf53cbd5b38c5c1c4ac86e2ac2df55721c44d2fc8fc37ee0d60db17b2ef75f47b97f571e7dc659f1608feccb5dc7fdfc15cf83e2c2fb8fc2de9ad0fe59cf9de7f12cfc3894528eab57e01aa319208de1e53f2a5f0207dff15f0b4783ee20954ed926c6c8d799c7c87258c742aac18f5e406f16c10aaf0d2fe3a1eb62a3592720f93ae6de65e1c0d83aa9800c59c21af685deba71ad2703e29800ee4fdc898a58e7a260e34ce4cba601546e43c4bd240d0208d03e8b6909bb5cf3380180fa2a45eca8ad1e8cb31de64b428f88d3cff8d41b188f63d2985e01e80270349009490f5a752114f886dc4a897b5fa38beca93dc978bb80864b3f7febc6f822bd018fd1b0d898ee76a388998718bebcadb4d46e5cd68ed6a51da1d68b23dab6b7f28f05da98d960132f3544db8163f1f7bf0cd7f18c89359cf519b371a6bffcafd785172b84d06c08969329319d280c604436b8555482360e89c1a870ab96ee2a7903406c5432751649273e216d449c96ced12469fbf5f94ccb1fb390d176e2d16822fee25e0965588cbe949875ecfd5e0124503a842dda380e2140b282488ce907cc28c9cd59d6cc94a20578ecc0de912d4cd64e5b4764b63df8d2207044d185154c4f6e2ca6754414e7a68e836419c8269f08ed312363a0d882bc1bceed9b8b240d9c3e5592e22dd2751bbf073afa90f9c97c858935d1a303eee755e4ea86f520c6ab7ae6059cd2442ceaf67d655bda3d1ad87c114a39babac7d65ea2f6868296d8c4fb8a23c701061a721a111d7b2cfbd34b362be25183d9b334b4bf017cce5e9d055912ef8669b918a5d4f2d9444a162054fc4d45d137c8a263e84c673a0b6dbd7e90c9dbfba7b065691c1da4a7e8f1b0427d3fdb9bb72661991c450e1d0ba0d2c3fd11d6739a6a0856f6a99e1257c9fa37b2e57990340cd6fa3f57d6538660b99f88f9c50c911746f8b82b0d0631f5228aa2800ade4ca256118e1d6a767187659960497a6fc6b7ff90533dfba780283c55645e4e89b6acd0a5d597e82f3238facacac640a0927503a0b030b2c4ae10d1a371c77dc60f7aa6674435dc47ca30daace7fad5a2e0803b102f257c4713a5936a3e93078c999c313b4900bea4e2c9ba160ed532027d972a8bd0280d0159c78a719c12dbd6f50103b1d3fad5b9c2fc65a39585fa2ae4961a414dfb96733560b0c3e2e04259a0593d2c460d8c53c2c79120179f4fade1122fbd50396150f7ff51eefc6312b651ada36c01332062f34aac9bab2741960d2262aff8cfa85427a6e7c03cab6c501b221ef0a2e03da2c1e3ec3fed411df543d159cbfe8dc44675f34e710aead42c13d492653ddc5d3747ef2e9d8a0966c23b0459550d06d91caad59a50a2bfe589b2c040c9c389502b1abb95d931a34aed93b62a4610a193cffa310b7c0a7f8b00b88b38aacb378738bf1f4fd4ca0653fc97967b7f32c2f9a4674fa60e31e6b3dedc7c729bee84df5cf04a3e7f61187e93ec35bbce4e63bfd622be76f1183b84736efa40a404eb9ffed3835ec9fbd58148d2ecc0a1c7814b7aad55d6c8f4819cfe76eda94b0eee655531298389919c97408771a9c76111a1e697fc82c47d0d53ed3d4f10a5064e80fb56c2bfe7883fb5aa942f8e5c02ecbd50856f48a75d680dbf73d7bc1bfe1dfc62b20366fa7252ec8cf96d7cbfc5f67b1ae96cbcd23f3c0827edb7fbe96ab60f3aee8c05ba2e721b52683f09202a2da8d592925c9a1b9894677c8821553fb5d694c674bc1cabcb8aad73e305e0c96c1f7bd7d5d795cb3f7927e650a92fb15105669dbe56ac7300901391622588949d8c383e3bb0d755a27b7479ce98a7ea20b9e7e6c0bf267f1c6264d3942e647d17c60c5cb0d73cae354b11d68e41c4ca2bdfe7e2992c4ac7e7224580284afb691490b83b47dfc26b3ba91a15ff160a6d99e0d549fed28862d65485b671ac2578d4776f293543044efc4d7cf3a87c6f5b4b21224d8327beb9f31441d0a07ed9d9287b22d2dbe83dac39c61930a82d7f102b387be8c583d7b63a2960d473865c4c7c30df0c3eaa36be4ce884d9af41622da656ab2fb30d81dba3ede25055030458d6719fbdfe7831e7645c387fa1f164f4bbe9f1580dd4e9aa29180ceebd0535fd715196147e94189da4bbbc4b04f7a3140c63de8d081fc906a722f46ace4f1b6fb06cc2016eb081fe5dc75e68891fe96f2f96015d3aa6c936c125c4dbb73990b4aadef7d95dfde969a421de3b9f013140b412268df435ba20e76c6e7b18d78f3ced43e850f2dd2ebb9c256e113e0a35ea0931a431fa6dbe9bce784a2570b04edd76cb49a1c9f0aca991d11af291be1ec00c74b81c3a3e59bb32e1f263332fdd1da0195dfe3bc9456be122d32207ea296519d78398fc544cbc02f36d2caab7b4a12fb900b959297df27d3738a846da7e92ec29e0b3131301e0a4e5b96169f77ec358315f3761b14fa95e697699d8f102e8d6c77edf7ae5e57de4548a1a7827e446800037a3b0a6b6f40dfed95d458ef3fe61919a5cc49ebdc3375de8b04bfdd86575ec3350a8922184ec07ea3581385f26d0b39f5af3b2a24ee6da2d3b5127a76022cbeb5f3b26c93db70b64777fc5cd006dedec91b0092079a9704a8e126ec280ac8f4ce33856f794c295a4dcfcbee71a98d17a1e47cd0fa33be29803e217bd543b9d366a3623b13f1dbda3b9aa5d59c17ce5ba82024d525e26698dc428198b8c0d1c1942df9a9062952b664fbe626cf9f453eadeb95e53a637ec0e3d39a9f5513081537aab59e14ddea9830dc962f51b83e1dc845bbb33d81e5db0ce0911910547b56569300e9d117978d1d81be3425a704de86fe3d10306384ec76a8a9835d6bce9c0498c3c25885bcc51368bc9bdbadf737767afdb5e9a58eb37655765d44d75455fac582280a32ea87bc7c2e6c846cb23cfe13c048b4b0b20424367dd9f9a923df8e7da64d461296bda0da320f2f1c8e5401af5ce12989fc2e929194feecd4f079cb34b8ed8f7a07f240f8adb845e23d2f0fc734be93fc4b43f912f376a80eb89479c36d45615a57e927460b1d8c864e865f883a3d02bcbebe3400d6cf386c1fd592c928b75d025ffab583fc7ca01b9a6534cd5bd482ec70942659b3806721451ca06ceeeaad2cdf91a34d1f370d9cb229f4416cac952a45ee666d48db01c6dc278ebc8acf47d250dc721196c555f8165576f113df64746243dd2ebb44808a072a451df73e68cd820949ee841d7bf7618b1ce7470055dee334096456c0ea5912bef7acdbcec3d72139e5f566a75bd60b79f1bef514160804d67b3650c62e5cd6eeef99735dfcb9be7cb89237d335a69f8bdec856082c96fb9195d88fcdc29ba6e0cf3fb40a2d2fab0c03945636beb2ed6c8f1ac142c0845caa3396c16ea0c097cb6e822df75c7616aed0a816230aba93f21cc92b0bdac39a0d05eb5194eef3068158ab817e0d0a4a5fb4e8d07e5d9eec97d2f35ee1af25ae040b86c067205a24e256a794e2d4a88962e0473c27f5da5ab2f0c36a35c832f4a1260e1e256f50dd096975ce855d8cae45a5dca1bd534217fabba8208d97f291671b894503ceae0b6c05da598c46516043df5d2789d70cff5ab332eef703874d7434d5623f20540fe556e1d8426f25a56962f33b439a44e1cdbbc26490ed984f5484e7310edc1b0c5ca9cb17908df35f2d30a413c7ef41f96367325befe9f7cba69027eb0b008aba1741952a792927381da81f2804b45946302ca0aca13b7ca5f102118a6a61481c2cb2f60719ccee9d86b1aef17e906c62b9135faca4c783062763e488da0b7922324650fae9b5961d429b57d0e60640ba37a39df09c20206c10493c2d2f46a866f30dd0194c39d1bba3d2bdb54e8f6169adc6ccafd72468341ffc22a7d321e9e509900c15f71756ce38b17caedd48b1faca104fa1edb991b7d319a75115649bbdd38306b10f1a14ae0e88852d2d8893b07f47e12f469507ad9ecb1a10e2e4e16bfbfb920c1b11763de530abf716717dda286ec29b64f453c66c1a11e8d79d8cd71b647382a5a4a433d775b32c65937fa65a580bbe48d07e6ac239382d0e85b8915db6826922d2d0ae2847af30d1eb0184ca926576050665536e139ad165f6fc45fd44ef8f9308a00585da736bdc9715afc1cccd9201d43536858465872632170ff968e039992d658b724976a248146c8b521bded9e0171448658500da04936b53941947b2a5710b9c6ed0e3b28dc463e7c57051c79a07b5b44a9d77c4b8fdb4204654c097cf6ac51f42d1d1d823cda707b489c470442de0df3a2785f04ff6ae3f262ef9a1a703d068038cc3a8d694d5e943e1bbaaa2c43a0be00af366df9779c86864a8f31853cdb19a4890f820c73b1df66926fd1a43026463e48c6dc7cbeccf7e93ce22353fb3cbc7fea1f7bcc6be3f3e84b2df9da456c2a22ea1034f3e55837a6fab2efe6851c851af454b45754b82fbb6198e1308103dbd9252bebc7ab7e89dfe8f60cbef75e0212faf845666f37feb71f7b25e5eba3b7d036032f35dc49b793366693c43d9f1bb85e5d718732752a31be99a91bc921065da3016d60fc191580ba45cfc9cf2a90eb135ceea5462a4ccd8fee841b132c92556e0671331fd0cdeee32545909d27169954f0dcde9d48d99d586f58c357704ed6babe1988d78eb8cf11942ba340d85fea2045aff4a8632e4a895dfb1db14b046c4ad8eb09322eb4a6233692094c312c20cc6d921e596c6a78ebd4393440d3757ceae5a8c3f7696da78788cfff53352f281b178c24da35b19bc079a722907da9920398bc8a39535307f417b9e0810a7081c165a1062d75a60717322401b54645876ae51626cccbff9983c2dfd1e83d043dab02a23acf3c26811a2c849fa30771abef9a8decbbfa35627f5973504e71f15bea924b8667fbb0296c04cebec632f747285477fac8e6c17fda21ab7483d2d15be5eb0cb4ef10e9393a26207b4964b1de5539b8a33040c1e37719224bc26ee645bf11cc95475fac8d211e145e80c010aae910e9b27494170681e4a00f10bd3d86b6530fc3a7ba56b529ca753b7092d588a961f554f0498bc94c26be91fa77f380e4882048f3c8a5d3cd971d3e378ebb84ad4d18174eafafb984858181812d76094fc2d524affb895ac01c1f4cc3bddc5183579da3b8342dee82e8e75685b82b48a205811bdfd3855b3af2f13e51b2e5a0e0a54482a999f141b1238da193b61d330fd7e9207926a3c1c3b32789dd81a8ae9c57d13c71d1465d214a6aeb034d15e57675be0b5ea67d7d31d6a5ee92ab9ee4265cddafb87783fabe547ab2c68f848319fb46c84beef3f41fb35b1455455f57e2ce6cde3f7a6007c329746d2398e434841ac8e38e5fcb81bb5cd92d755b94752ec0293d434354313b4974ea8888e11f8d6bca00e47a4592d5408b392c617667026d06c1c51f25237dc2768eda55897693eb240f84692373d5ee43e7f78afcf1da80e3ba2fb4f846cb63845e7ae653ecad52a126712f3faee6381a3035851f2ed0ce590f0b69e116ff37a664c1b602e6fcf275bd4bb75e9b06fa63da84c7fbd91a0e97e88a4eaa58baba3edfa596864a81cfd35a220c40cc66f6a61186448d789d32a99349341ad893fafb7df5ce8ec185f25952758769688bc277a5bce8b9257e01c395ca7402e4a38740a7ed4841b07c888002ef3682bdb0506b58b22aab027fcfce6333d4f5b2635a0f871772d7333d64d44f8cfd832457abfdaff3ab439dd3d2b19670b5f72bb86d4cafa96c50f795dca824d609285741ab9b813330ee15e79cdba18a4f64840ffd8de36e7e28c29828e052bf1cfc735b172888da146fe4ca972e54d4f563c83fd30888962fa070e162806ecafe099e13249285ab730b1323e93e0da9ad7969e670cacb7454dc4e5ed7d3311a2380d74b82352926f16d7610e7a75c3d1390ed32dfd9cd645e9d50d74139e81574c4655bec2496fa88d18e8669fba6b9f25bd080754560cca4acb4000fefbb71f2c176f9c45ec9afc7fb6cb1183863d6d35310a8b933e2474ba6f850a20becadafb0331502a6df662c3f04f95afe26b0402af780abba74aee9d1192b21645c977c2fd0cf9cb3b2f40d8a1e0edf7eaf94d4994fb69335f349ab37040967d9f2ddf0601c265fba3e6d48345be77e6406ea08d7088d672381db6d80acc97b62b30ef63139832c392ef46e4adaaf72f43aaa4bc8b278d5b98d91baeb4164e7adbb83329eb3c2626e0ceb4df145f6235fbeabcfdfac0484d6155c629c7cfba8be97bcb17f0ae0f4bd246a3495b85018555eff9ef97a61c6dc70077b91889bbd32b45b0b44a92352dbf7ca16477bf6f36e9644f10480161cff3f7b6dd371a391011ebeb18b6f92fd30b2f38d15004270790eff80d7a1390dd8f11d948394c47615fca882c762688f8fd3bd913f31b97fd387aabe404945bc78ebea3de3042df27ba9902e8fed8d8dc8d77b5a00c703c0f27423a7be27e60b8532eee808c1ebd1a048c16fc862c239548749cfeccf66e98cb8e5c18900bc25731d5c14bad89fc8842d3ca7f7601fb1f33d2be06ac3c65ce2c8a250d0c6010676f7de5297abe043a3e6482b40a4019fd0e910e686b3c9261efcb333473c0071b7e533c7415c8425b86b16e03241f95ad100848a187928e5a793ee804722e48e45f6f87433215e2ae012312ad65f1b045ccb03c086b799ea2185ba8cd0e8e096d680f38733aa57a5fc6345f6392dc34f03d866b8ec6b4dbc633e9234c8f70fc7645257c4f9559d526e608dfb1bd2290fe44495d5b1530d2cb2a410bdb015a5e829b81b20b23bee077cf998478ff94e15abd46f441a7e65f9b5463bb1aaf52a95b123920e5cc7be876499a54f483f30f061cfc50d0cc63d38233872edd77b397cce42db0c391fda15d43caa6cda730ccc5f18780ae61e9e728b6b823542a2ebe66518f90afeb79ac7d52709410d5a673aaf4210117be0cdd5f29adddc851fba1368672dcb9acd8fbd9ae31d991fba069507ae6bd3ebdead71fe74444eecf81f8d1deb3491e2c2ac6683331239e5cce97ef06c35e3150d689e847007dc11d017c2e4ad40197a18513540eb7f8b4da4ffec727d161ec929df57c027a014f5f150cb81e248b3ef7480b20e5e9c9dc52ac4e27330f1743d1a995fe6e759d7a2ea92a01173f87f80fc0e77fe1871db4d6b19a5814b4e43c70234992d57635df7ff87873679f1ebefd5207daa95143e621006370329c06258b03a0f342b89a14677dbb0fce148a66b067f05ef359791d793dd3437f775eb32ac3a5cfdc6b43d61cc16256a3555113848f3f5549e73317e51370b08f408abe043e595bb590816b1cbc31ed46c90adf66f835c5d72388a6f258da77684a3aea9748a7787ca63fd3a163b5d7c8b06a1478ea3598e3a9e73f921fde474bd283c9fb49f59ec51a36f718cca52b7dcc1d2e618a409f96864443c71c6e2000a63370f69641a403a1284676058337b7e336ee85b938c0808bec8d483bd54534c5ab8924875823bf4bf623035d8a0f4e65aa2031a048a7bb1d4bb8d5a09e98ca7e0d57375a28d9035586ea8099fe63d02c7e7d9e826f90d5bf21e1cf7077598e92920f58d9d453ecd25ccef5ef0146e0a1270b4d1e86d24e3b0c5bfe5316d8722efd6ab2ec56715ed6422a1141d923643d3b285dc92b4546789ed889d1cfc9c231901efeab59d58088f88f938df7ddcded63d8201760bd9a86943281903dab8a8204f88783730e98c9de485748a8d5485e31b308739ec737491d4a357a80634a11fa963923f5d23a43fee537fd4b2829420159ec36f91fec30f0d770ae8c99ae3faaeaed18343901089f0cc3cb9ef66696ff6ad4d3a233c4becf5537e5ade95ba729f327f1c9ee9dc549c0a26bf05035d049015f3d0eb2f59bcd018e74a8732b76f199dc2c77fe1197047a9039f9cc530961527f9f02f8ff9294b03f328c2c4484085b4ec6a1713c9a729dc8b20df5c84830d6404c2120c520e013e93c1dadf4073a2cb7a22f67084b0e8f42630bf1a29f1ae21fd18b2294503c417c1ffab434302dbf358bee63ded59574cf7fab4e8b8d69d6199023dacc85b3b98be29163b7b1b1cdda6581123b7914dd0d7bc92e0dc4f58320e624ea86fc501335ed9f49c91a60a1b9413a28da5a1353c901486eb88e460c9d3f499f845b7f8204661386da4a42a4136323234127b64a3be8cb7b45c0df3c4c837884f7af8ffb7a221628ffd34d3ac7b8df8d5b60a19c93308f520317a238e5cdc9c6729c51293d866a9e241f26baa95f9b22c045ac3683db33073f779ab34a54a9de59fdbe87741305f09f311b0a69d061217f11974cf5973dc9199dc75618d90df79053e80048aa65092bdf39cb150e6faa670e28ba104b1d9a3700e0a694463b08d0ba5a86fdb4f633c9598ce0f5c8003ca8ed02ad62c9b012fd67e1fb289973827becbba525c91b55779d5a63c98ecbbcd7a08b61bf6d9c98232d3c869d25b86f16e2f386641c30e6c2215701021cef0dd38a38dce2c23d8c0f10006b3271df95e4d3b2ddda13a69a40d9358a370b4f9eb349c6f621d100a5719b8e5af976defc171dbe60fff581a4f8eb5925c2dbbf4d1f3419243ce2d205f92fa3e67e441c4d309eb18938bbb48ddc90e005ebea42723d3ee3a390b4eee0523587e92b5e22c7684c681f712b108ad672cf2bf4bebd536cfbd50078c819da9646dc11b7b28aa480e2b8ec5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
