<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"52fed7db8b1748f3d48622c6b01967f975ad0aad89f524d5e7442495c20e0a2205c2402fab31cb74e85081f344ba8f2a83bc3ca0f349281eea46b41535df2b5e6f53bf0946cbec6f365757bf7d84ee66604b7c30661513116d50cc34e9b0726399feb96eed0d46869eada0f16afca7a6766f31a6ff2b0eaa0db8a2755525d558bacbe699452d98b78a7f84be21968c05dbc190d73b2d364c051aca2cd8085ebd413469e7021ecbb773a482eb27f9024544021e0e5510cf20a5e8a38e1d4586f7f79e02d60fdf7228d6809abad71cb730ca5f3b260cab36773e05763bb1ee4c73db268d4dd5e8af9ebf3beba32c625bdc9be50f4427d0fff3b147e5a08c51fbb0325a20e10a49e981bbaf27193ca5e40147e3b45a8f10cbd77661cacdcf5729e9fa3550232bc1424573210117332f99091c7fd21e91117958a1d069aa092d832bd87be486d2f8b26b5479b0caf25cdeae95f15e5832da71fe860445fd0ac725d50b78e7c4b3115b1443e7989a08a551792bf6877a2ca9120d8a390bbf6d282bd80cba8d1bcc9edcaedf0191a3796fe229617a28f5446451aaf19a270b0a740902d9d40e96dfb272f2be85dd899eed02628d2416b2ce8fa7c8073a3bcf69c181a2e3fbc1ab3546341e70980611010e469681007e7f9d91d52c5908e259204f1695999403929383b3d644428c6bb5700bcadaef87bb746481198e71b98f2ecf47ad7c6caa7258c017aa04dde1c55f6cc2bf63e164bf4e71f95fdb10c600a0286010c9d5a8d2a0d8c7f02576b3e82dfc12c8b8fb9ea148dd190dd9f07f74cecea57439c669e0545f05e6b0035ad3902b71dad34c85a382f51709516b9f0ec71bbc67a7b42c0152561a863efdd0f5b4b9e648cdaff58629ab7b38d13881839d77bf3ce4a05cf9d91c969bb384570f99c3a66048c602311a467e73a5305181ec4478a5e9a755da93981e123deced90374b529adbd68c4097ff3dbb0cb672b8b52ace2c33855e16bb2b47ddf7ca22f9f691e4cfcd64390ee8df304dad35e251f6c74427eae22a5889975ba23bd81c997a24d70a54ad45fae848c905db5ef68409e2c5ae974d5a84830168f2dba68c311d4a7c44139e1f20d02ddda3d59af525fb9d50d4723f262e263601cc6908468dea9540a9be830caa6d4f023619a197f73509ec9561c8824326bfe423376eb74f97f32c027209ebfb911630c0fe0518518ac51b9a168844f3975f9c715b781a4df17776f91eef20ff893c7d5adfdc1961a3eb0bac45d817cc558c38d047e7bfc6d09db0eafbfeef1a5c1ac0838a3a1c0efdd1f67f1c2c6f93fabaf578a24d707ff464bd70e11b0dae57027e7edaccccf5d87fba128bdc78414f49a7c06d0d13ed71d7f95893668e87f654547dff13160de335d182cb8498daffecc9b2465167d00f64f5bea08a5edcdb461ce046dde5b2ec6e09fe6ffbe86e6e56e8c656203ba699ed4507cf2ebf658e8e8e77ca0be68fba0a797c91ab1f2fb14cc72511223ad2ca9498e28af417c6e85f8676000dcba243e0743dde153dd87a571ecff1d081368abbde0bd54e98ca3f6c19264e77f91998a6ef1ba433f74b28d9713ade0d2f03ea44938166c28ec35a080229f612e2827c24426069fb4d8a224adea1edeb22e4a65513ad2b72cdcbd0d84ea06fc5ea1278b29861c8216043e507f48ee9df54bcd59659a2196393aaf8f675124b0c45bc5ee167ff083d0e75dbca061dbedf290102307a1477d3b41965d4cce87df2ade9a22c6a87ff0b7df7de0718772b40205b7308493bca5fcfba472d73fca746b54fd466807e9cd1395a813058a5d4e231dcbc34ca3725826a8165284110ebe8e614673b0cb091677623fb7433fde1c86245746ae0b261032dcb61ecc1d533f4f5c2e62bc19f92a4672e8a8ccbe5372004efa97aa6e97a540e2e0c48d7ea3609a94fea9019d1929e65c10b70c5b9820a632b5a2149ee11e16be38dd997a7e122f039062f58fde0b2c5075ab6ce9e0567ef0d5ac5f6ce3576c1fe2e562282a43389ea98b8d978ded7def9231280788596af1d35a89f7a511d17f1736877ad8771c559b67bd8d5ce87acf0ec60ae05bddf6d46608b2233deefa123b6d61ac664a208eba15301eb196f4f76738a5818218981e13fe5e64943bf36aafcb3a2ed4283430d925453d13ad9f2abed62ddea3312bf3f8d28cf7784b39eea487cdd0e6c30870d179607a12ad7e120a3fd5c1694ebb82923ccf6a70eb9d8a082c8436a209f015d6030b2a7a5e2a5b769aa1991516eec6e82751f6124857a7cff6c154b005e82c3189e58e1b69b254069b9574245f9df33674c0afedbac160f93ca4c3621dc6d536529a7a6270e207bece40285e63bdf7dd7495f338aae30254c4b1d80adf9920d5c1ad4f3bce73c6cc104a08cfad89d7464b151be01d413ab0e919e1cc1d5a25e6d1381424d75eeb816871986ad0ca2ddf7a7b606153ad37e9df623cae6b4854c0cfa4faa8ceef4b83fa27d1ae96d78d9f12808f54f5c8ba204fd49295e88e99a5631def0b838c19a07664af4ca43064d353a2ecdd0fd2c995458aa67732fedb37366a28fffb04f0a5bc7ad656d916e4809f4e468e34b30ec9ab0852ca24b1362fb530e6326c0133efd33c4f65b7628aaeed1f88a7344ed24e84c7b7df1c7770ce74e6d7f5b8545a33648b9a042d6aa9978ad8be7a2cb6bc9df8db99b0daacf16397343ea9d422117383731e098e4b432fbb5648472e3c1ef4575919776bbd57285904d943791f06a0e5a212432e7f6a5727d5d25ea322c50385a42fbfba3686e1e2fc813cd80b7ee6400d25927310d7d015702ce14bd4f9709e7227169f3f81c8ba35f3a2a2a34b93397a3306390540e7d848d1f3da1b8f23119a5e4a0967c786ba1c3ad7daf5f5016abe9a94109e15b44e15d5e9ade405d41343d669af7182f2a20d7b148c90e622d61d352b3bf434dff52ab07aca63589583fc1788e8f2478f64918d91b11b99e0dacf9ee48d3c82050e39887b1f2f74703915035590376ede1e159cb942a8e0153d813df22b2e02409938bc0fa8b8f426a3e9258efdd8853cfc11abfd0cffe4b2e116133b106991525d03a786c0f348764a801a549b7c234521b138f42ec80a242737c72d12bdbce9b4dfbd51323f6649d971b0fe9505e3918454c17a4bf9d0c2c37591f4d0f5948039861f993fcb9e9b6880a661aa017c83ab6ebe53fed6b631d1fc1ac65987d20c62d5e607a948f02f597bbee66144369e2a74bfd0a322e8a81cf1f2fe3b8f56a29deaa961a235a879a45b684dc7d8045b30300ef4ad85039746a31f53f37176dabe5b10dc233339fcc712df6ca732ee0daf8b2fce7d5b5027579b1d02e97f19fc33e01daa352c2d8cc2b165263095a830da1622b87c1db6d547e3fb7191b4baffe4f72f3c63b3d0bfdfbc32883056b8d39249c8a46b2a8ffa0d78872e6b0a10b5834ebda10892f48188dbc5f7de943651c8cb2dd7477e0617da0a6b7b3d537638d7b4701c1f9bc24a75cb0d4f3ccc7967ddee742bf5445661c24d4509220123931e0a3e575123c814ef75b3acb9bf13350fe524c20591301c1de698ab1eaf185624de83053630a7c5b0e8a6212bbe27e47cb37b62c8d8c6dd6962c650a42083bf3f40f0296144a3d7e8e46f3a1b1986de135114c830baca549c90346a2c02d452261005c484185ed6af4768e478a1f200cdbc51239c43b78293a4f26481d55fa02f6980bf04920f21e0f4b8cb94a4145e5c9399d8e178c49ecb0e94543a68fa114269cbbc34bac89e1f5652bea793faa33b19034053272a7d689ee138ebaae4aa9287113c445cf8c0e6cbdd5c5afb49609e2efe8e6c31abc00dffabcfb8a16b5c71c14861a55a3a59f48366bf72517c18a48ce9b1aab287456d6f907bf6e34aea92ac1a7b3c71dfe19723a701c0eb5b3ba91db422ba93d68a1be0a39525815b3f9b0f4277cb1febed5903da99f573ebb35dbda060ef15e09f2920cf45a0af7ad2c73850bc7776b9cdb1139b433b782c515c1067e7ac90812e46dc520c36cdd13196348614f47a55cfa512ba9eca5c8726f46308bc7942ef14fc471e6c2410f4419a18877dd9b750445404bd86353267a5ede627a4b43f42b1e374f0f66889290769040acccb06305a4d4d3d4e1d85b46483b2138c344c050e1a65ee31a70ecefbacd44992af50d3e22f24055242ea348b23df38bec57b42e7396a8467ce1d20df3b8a167b53a6147e712c4923600734abe3a38005417baac2a756bcfe4a9e31ae23272db1b66f9baab3993e083d9859f897e559bb3e92b575b0ca9a06c417d2dc8c66e794331191a10ebe16926e5ac50ab495b5b342ed62a2788f9b70e1a271f40e0de5bd3c6d36522deb4c1ebd1e154ef3121e0f37c9929f0f314cc9c82c5cdd98973fc0d7523c8dc6f7a30fa4f81219165d84946efece888e842a7ff6135f074ea6911aed5098e9e85052851f36089da6dde91b364ec98d82c6d7c8cff2c7f76ce8567f0aaf16e978e62a2a8f9c8f4e9a97f7a6cea3cf2931b194b332f0f403b58f900be9ccdf4d4646f93baf1a404813316a9d6361fe654459b05ad866de01f8af1cd6770ffade00758361e8f27f466d213f8f5a2117f2e2d6d672a32d57c8f452ab63721f9e7a35fa71d283aa4737da949541447d4a57008a556d159681673ae86e4dcff3e6ac04d11447db62e946a6bd73d015767833ed9c1b38ee3cf1f52ec74fc6587a7326613a50ff9e9380e0705eed99988fc9c1f96275a6d9c0466025600e29b53c08aeaed9f7ab2f28d198bdcc8a577e1f719aef4b274092f1828025ab499969efe099d8c47f28b379713a4c5c383a0267a237ae1a2006876d580799c65543969393df703d997425a370e8d5b35761ffbf0f300ea5fc59375ffe11286b137a436d4054f4381ebced999e601a93bf513baadd19d5aa49b8b029ac5272ebaaf19d762ec54efb73437fbb1b1765fe62194259107467bddd65f52ff03245c16d7ed6d23668259a6251e5cb5556880d56d2985fcb3b8ae5d903d1fcd7f19527920f967744f0e9466c44d82a54aad6c86aeb7898fd89abdca6dbead911ef9d6b0264a287ca1cd3ed35fbb337a17bd9a8133cb18102c73e2349386ce1ec2f51a0c358fb3ae3a82edcee2ee8cc5e9ad22e3ad737dc0f5b768e931f2552513e10e6d9b5f58f2fd52260b8f185dba86186cd1efe26d4210a5f22734f45b276da7a64d4244efb5bb516fc3602b784ba2ad1b702fc6944f4818f542953cf29500072f5a28d1c7787e54ad9cc7fd7fdc883de7e67c34d807344dab599d0966c9ccd14be3637e1c11b07245d294a1476ba5dfda4cce1020b1f867b1e480c643e9b24e21cfa61ddd0cbe88b5582e3ef257d4923400b4fa66b95e64f5b31ab789d4e9b926ef4b7d5379d82f10d5296d80724787e1b41aa58cfe363cf143d39c771dcfced814a8801cb567d812a6fac0b3bc4c83a71f3a46c8951a6a37dceac7af6aeec670c5d34c6a8243310c74cc65527467989be3058b8e874a55234daa7f56873b6b1703b73ab766633f82ebd3c2d406863d329f77a539a615db3e62b7a984db6426a39e8373ca882eaa173fafa318289bdbf66229a36822a9e89a5c284f032dd1cbe160b00e3aa1cb6f4821173de2b49bd8f5acf7521a0a16fe588df927456b962694a0bf5b5472f588da70fec303492026828de56414c9d656fe3d3fc5f4e0a62d32cfc3ff9a5d74bc7e27870fdd64ec1dc0cd1cba150bc949efbe0a3cbe084cb6b3a970cd89a8a6cf2111e124dfc61898d5c50b4e902ca02b50bd0df5952c0d249fb7f5edf8c9537384b98e21e029a6b8664b86180711ae2a5d759290485643655eea86a14ba80fcb4613b7f25e6aa0daa859496721ff6eba2160d5315f4c14a1c8508528a51160fa2ff43a55341156da57f3186327363ea4fd400937c679c884ca1c5d5779116c02d8a8adffcef4bdabdf44178b10ef27f17f1cb7d8d0034a213336dc2de48165a2d6d8030b20e38bf22537ae9a6d1ed1d8f4471e3b68c6c1d02e353def192e31d155635850354e73286c0442efc050666e7a156bddf67c10635d99f9ad42df45ba82613e424fc16f70440baf9a61db62e4f72ba5962eef632659ef25e70a6a9fb5a6c076b2c17095d6a31d892ddaef21d381cf860ea8cd935a1be8e184942668c52ea0aba9af9ad960fc92f61c86250281afa6583064474d170da17741def24ebd6b01bfe2377184ee879d0b6002c1cb2bbc20f6ad57cc2b54f3c1d87200f0bcdd510ea0bccdab0f6aa12f1edc348a93f8b1713a9f5f54b898568070387f2b7fa6c59db5b538e45f637b01fbdaf772e9e61a30e7938cba87066de17c255776056e48968d78f0706acdc12915fd03781039de5b41d0643a4f01225c8aa1527242f050a04e6b43ecfeac71904579a408adb905bca0cf00bedffc0798cbc553d5e111d5cd6f23fdaf9a44d96ce60242b8fde31379cf3c6a7483f85804394af7c40ec9670fb3836e79590f5f981e1cf3d4893cfdc4e0c94c4122f978d0523b5be0d6b8817e15050d70e325ae34216e9b3116bff9ffe04c96fbae09f84f44cfdfdeafd3687711b3af84e44c6d95bc004fc26b9a4a1fd1ef719065fdea7c86d2fa6dbe9a8a75df0255f756e37753f7b6a10e543750b9f4768355951329d60a737bd6db4a1a512a45ee5573fcdc1de97086c217a4da7ef8a9a0871faff6f97f3b0bbd59651c0d1ec938942c0044bfee34a6d4fda79e88a557000e97532b893a59689971fe253d00c5aa029f354cbc57baa0aa58d3ede68f64b149995252b952a465a798cb13505e33cb9646f353a567363ce7f4a00dfe54842ccf4aedec3e328a435d239571bc6b241e61cc9bea231d7dd9031b8d49f06544eaf69753c4e4c68a56ddb48e69e5b0d1095920a222de648fdbfc98dc7e0b3b7bf560e97f21510c518eccd4d60da8b50239371cb5af9675e7de4f3b88fe6ee193c5c3ab3d09da6188a49f2ff0f9644a1e04dfc72982ee0f66b1191bca022d79ed081c453e549b9f0708c6ffa887c45bfc02ca4fa9c9d6cc004a0ca71ef313ba369df564cefb3ccfb1da378d294c617ee5d6212e74fc79080ea3a610ca6355cb00d9aad918e28d502361ca86bc8784378b9bb6160b9a9b3ece748faa14e9f6a0c173d222ed7e77b8cad1f9e8e95963c9345365e95d35959e648d6fe1c2b30fb2815b9c4db16af596ff7488238195484aaa55fc497ce0ea7826baa1485279db27d2cecb7d63e2076f2f540b2de9d1b2f983ad237551998bb4d6fa934869719de1f44022b68fd09613d67e76fc0aa8cc8ddd4ebd6017d00858d6261479868f205810341f3bb4598195be5d28ccbd2ca225dc5fc52f9785abf951a3c62f43d22468e09ba5d08c933d937495019b9d0645e516c3113ffd86e0c5062f4b9a2b8cbde50eb6b9980782b8bd59c55b629ec6fb9b73e90257e37dfcdc68e1074d9d5e97f281f74bd3f922d68480fa6af8c7969036dd6c378e821a14abccb185fd5fa21dbffbb1673d40146091f55ade6b8a3432894567e7728a1d539a0a5ea81a572d16c5fdf2957f21a23d214836ebde7915e5be9267cd59e1616b39d607426e3a1a8967efabf06ed1ba6dda332402bceedb649fc38ba8c8d414496049d0d834f8ce01754c2caeed9db9db3886048f0210c869cfe621def1a95b0d5df4e8dd4208a80fd71edfaabc1aeb7a99ae06d83a8e5cb40c5b8e377c05f350371f3922cfa1f0bf0fa1fd4747d362c96963136145e387e57192244816e74b0559d17534cf1b7af3792a58bbad0beaccd945b30bc0e1468ca9f7c036fa04fb4004e50cebe9fc3b57ff4cf04c8d1de16b9aa23279b08c749734cd7feedb8c12feed6efd503fcc3db83d539e6b74413fef035bc485afb6e65c10119eeb022830d9ab62fda921145c3524195b9a3305810bb860b29425d93b8b58c075806ace711b8c65a1ec294fe165aa1a3d3d33e7d7d567e43a73b5dc672af903b620e7ec79b70171410e270dbeb8ec20083dc096627cb32ef244805d429eb489797be20316bd49ccff25a9e2e1029148d1121991470a0c2c494f32549a403e7a5d56ff19874b51713e842162772e8657b2bc245e2260d7a7ac88ad8e431191cafd9536c2a8ed08848454c2a5d22f731af70cdbb9fd61e14921a84cadc3ff82b65bf1a3e0ca5dd69f3c18b823f914961a2a936b6043a7df6a06b959e78f5770179ee6b7ea292c596688d370edaa74da4052ca9a313775487ff23733612eaa3cc15a863347fa92cbdf454954b3bd4b4dc5336040011b75c3b8b6da37e32490d0ef35e0a0da63fda2229f5f7bcaaa45a03e80660a54e5b4118b22ddc11f3a04d9841c4ae1432f3a1262efe068119c374908fcd52c141ab66002842f7b11ae95a001c64f2c2e57c70c2e4797f30f0f5431665a3f123b6d16d74e1a750eb1bbced7c65bcd265dcbb1fbe3dd1cd9476ba27731208d9f5a00d8c14b59485328e1cacea9ed13835e03376506b1b771aad71cb9cd0776f6640a70c79c694967c572d712261bc239d01366135f21d0c831c47c85f3bc2004a69ec95ad595fed170287edb315b21cc2f551512fb18f2b8bd1248e62c3a54ef98aaa335cb070314f55708a0b8b450ffa8eeec69687fe9c4f23933a21d4c22e0941fc83e022f2e4995ad20a25ea8a813c739db2c8b82574872a34bb430cf61e58a826980428a24f865a096c8c549e3ca948da39b6813610081a6829b939d32c23e0186fc08ec6538ccc1d77fe94d469ba2255aa8f73f9063ec5f37f2e27d959c581382d490711b79ff3e86b071c1b161d7edcecd889d1f6d1173175bf5e9f7fbfee1a0a7f6522fc0ce72cbb6d99dd5ee73a6e9fcff6caaad236d91f4ae16e3113ac8e915cbccbe32b074868a301f55eb38ffc3bc4a70853ecc279dfc38ccb2998f6bc7ca047151235d36c537eb18f2ccfa6677f76d15e79c5c6b9aa8c9de9273485164a164b3d0a73d25051f7e7694b6baf2841ed42e999c625da29b3d0d12dcd2b01a10edaaaf8c973ab034f92df8d9a2c1fd46efcdfaff49d6f4f1e538e0b5a42230e46440290f06c9c86029020be1c09f6e131ad6ff9b1a56eb6c9f6b794d139f5dd8782a56c257d70e4cf9e2bd44b3211f659d185e0b5bc27a82de72e910c56bb4a43cacb4eb2dbb31002fad97604b03a86a31d584fde2e375a36bca8afddeb3fd48ed89ebf13868937c6b57fc9de3654f69a20b2e007c941217407a3d88ac79bc71b816c5005fb2137188ed0e75c7efa16202c73f286c2775a20f80716bdda320e0e4a874645aaf0de14d38abc28a63aba10d60d90d23cbc9e6b3402012c9365ec2252845077ac8c89baa093fe09b9614973d9c6bd19abf2a0afdb9a0b5769b9d85ba0bf9d20fca6cc78a2c6a117e480f81a9fb99c0422225b0de03488b76d6002d53164bbbacb0cb53c2a413639521b768d40aa32a82260c9f8d5e62d00c60f132a02cde11a567633c3dee80c0ab24f8cd5b17b7f85d076c8b4f9ae983452181245ab71bf5f6b814204a4b8d23f9597cfe22fa85a7fbde5d9cb8ee2d41cd788125fdec0b6851fedc84f43f63de6a5d7c71def8d92c32d72d48f93facb9ec0472a254d88599044b6fab134df71f23add64bf4b48ea3d609a88a1a91806bc5da8b81ebb7d726778ec0d60ba055eb1178dc31fbfd9b6260b5746e4eb8c4047e2e32ed639ff3294117f6d75c294d7e928f3d80fea3c1fe46159c1cb67f2cd83334302c81e1754a207f3b6463dad098cfe374991f69bc1f7042231f8dc0874a9b824d8fd131e656cee1d4789bf3de24397c45d53941b1b2c5116fe00a2115b48d71ba3d3f9a93a644ab185bce118b1ce30b7fd7f3c2da80eb9703849f6de47b3bdc643286cd9fb873f01ef2ef9fabf3b0c58afb7b11cde57b6b4fab9c98e437058147026720b9c5c098e9be8113dd78daa05818fa9f51351556ec24f4dfa982f3d0706905ccb18b17df890ef19066c74e51faa4e0b4d50d50931ab67bb24f28b8f011d88adf50cf229ed5e5f5755e07a5953d65f71a3f0b3408d30f43ed6da902e4ffd57907f106b7a37955832e4fc5eced4fb65c5e6826a3b4faa1c860513c046c315fb9e7cd5689a89be611dcce5cf6db507c0318582af26fc00e8fffeaec31de1d800b21800f7476305327eed81ce585b7ef1975b064099ea3d86ebead7ce0095cfdd09892fe11263db3b1d15ee4ebcc54c8d45e4c1e0f1cb0317c347e1f835379eb2786d2c117c7f28d641c860da6cb7b6768d7edc4a51cb993cd6d83f31822f663bf865ab05c87bfe9944e0c6c700061df86568df3f571346ea09b2c29f3703bdfe67e77eca1ef2e94268433c3a19d5b13bfa75c2d0338660aec132c20024b4460f02e5aeb5da63782b2dab9c51e60b28ad8c25e6595bba66a944e9aff9bec0444664ff0532b094f3cba8fddc0dea0fb68a6bf4d3eeb76b7b8862955a0835ec8ba112d536cce09f3a23b635189a6694250ef44e00a54e6ef17ca8b14c257da9c79288523efb6311585d9f850253975f40066e8c3a4ace6c07b00ed4c96b7fbd7eb2b5af8b7808a79d33dae7fd42189cab7bbd1ee7a8780811d4a6ba4c0d2e7220f6820bf1eeb34c424a2f90fceff818603629565eeba1b1712d296c68a989a90629c5d441797a042554f3704bb6364a9c5c08c49347bd3ada770e18cfeda2b0d92967b2273df1d931d12874f78b02fee4efb52e15705220979e580242b815c0190c9bf5e8970600c3d6af0d64985624320c3708f06988a392eb5a316a0a7c15043d06bf987d811d8bcae0307107434a6beff9f76a33079cc8e2ec6c2faa25ade1a5d6561b9b26791076554d6d62c3ec7be16a180340ce83f67e8b587975fcd412bab68b4b1744a5f603c82415f1a2a8a03c1d7ac33bececdceefb755048d8c0160040fa7a4336daec9b162ddc52c70750b81bd03b7deca7265ae329690cad97af8132599c67e750c379988b00600a71fc569e90b57602f82b523961e4c634547ea33d92ee37d8a1550e28c3e98606f70e7de3611df1bdf9aa76f64a7d98cf088458d4bd672f2d8109368494a0600ef1742b02cb3b5a96a713970fd7cbe74e54cb33e02bd096ea73f05bc3d91e7c40f83b323ec6cae319521ca87893da54d0ec0bfbbae055b27609c6807e8a3a82541ad3e6e553c1307f97999026e99856ccb3d8bfa647f4e36d56786a7b42cebd1c0ae7c806c8c10264365715122ea20cf2c0694b44e29df05b02daa73093b560c2dc2f692d57e2974d67ad63c05a25f96847eec4f8c078ed62883f908498b1899e42961230458fa79a22542acb27cdf3949df36c2e46a91f795a02069027d16bea6be3212445767413124223e923c01e9a0301e250d929041198e8694cd8451faec54eee93015831f129bbe3cdfdea92e3865d0d45fee5d5ad9fde25f56f6a14853c8fe3a1c5429007e70809f02b8d095d3160280018e13bd351c7082efd7fa276fd8e3f47ddc8149a723847256757864d72241a10d655d3477e90926a4a30bd907eb6f1ec5bf7fa85c2be1bb700fa9976e8b35c7e87b7d298acea91e9d0b835a08e623584827df85bfb01929045e424462df1de39dfff578d2d7edcdb2339f98454bfc652b463d0e46fe91570aa68b003035fe2688b4cfe71e5ea09d535a75db6b28425c18f02494fd80229446db7a5494b865562b4b817f1a138803f455a9c7b7a8bc3f82be11fcf8e4bdab2cd3a2249b478ab010c47027c026b77759dee0030d3e4884c35289aaa8e6888f37a5a6b0dccbd85c7accb10bbaf3f5b2cab21d82716ff41294c7be3f43a046c2ef4670da1250e92af059d13993215fb72fb5a146ace6679600b86770020430a32f09d1da905014b89c4b1639013db7bb9e03ed864c426c276a54919569f9daed03fd3ddc4827a529e25b16b3412b3601768a0939d2cd659dbe4a7e1c669ac52377ecc50dc114f0950f8d9e670bfd3e9989ccf301a1b480d31bc5fa560a2b15889c8b0b31a56c37d1ddedf44056ad53d1d041b1ce5453164ad5f937c8bae638207ee5ee9f5b5c3c84c62f770b9e5d854fb006f2d129f98892d0ad80a5f6775db9291849abb3a31b25d19009f98e47789300c3e11c8aa65b71ff81ff7f6a64d35352589342e9b5741645dcdbbf14e935bf02723e82bde398dc6e304d613e988acbeb5ec2cbe0e2d73cc61092041a9062bc744462b346ea6cef891ab572f0f9ec8475a669189d44913ca303e80cea455b642623a6cc7b821a84d2e6aa6eb8952b86ab353681d3726e0055836cb7ee94c5008c0d1e77ad0a95d46358bba673b59bccab1f77f645ff4f4b13c9f1ed9a88b7abb321d56041d932070b4eb041ee7cb5a3ec954f2cc9583f88a80898faa105fb63ae900c405e6be89afb9b2a4e5c134fa90ad0834800a2eeea9d93a5aa5ad1c768530d4bf24c13c04ebe6f8b4ae1e0aa188f845bbb49abfd2f2a996c05ae31dc1b294e1ab0204dc63e645c964f9fae8def53a2b205489989461c2a076493585cc0d6856b1ba8ebae51cf113bd94bb1872d07fcd2fbd37014e6b563a15db13386391105ab7051b1b411451eb7fa38aa7fbbc17142d4c52297a7c10d0094e499206a4831ac15d633053d8e223c253c8c44370dd83e13a16f45b6be222c2720dd0254b46426b4f348e6fbcc1a05d6832a371d81f08d2e014606ea5ce3aec37d0ec841bc5ac17031681a295688157266f29339838c36b38bbe9ae4b5aa7fa9bc150c75b6fc6f5c90761075b5d84f80a5beb6e233baf2a41e3a5251366072b9fd156990a75d21cf12062e5aa927eb65f7b50d95593baeb9dc7630c09f9176f08213aa2a34a232c1ddb62b038bf0532e08ac1578e54a839ce256cb2cdd49d966b15b2b85d4333fe1010a4f2e68775579520c55038b04730b33735d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
