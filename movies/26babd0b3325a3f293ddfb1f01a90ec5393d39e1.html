<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"67bfab175b70f50a6d0e12eca4c73b96c079a376da3bec96f10412f92417b4b9c4fd551dc7774d6dce09d20176ba7ed83bf6b462bef16fbd709bbc0603329e66cebd0e9221c1f6d89d852d81b4144e34ec1092a9599294640751ada12d2930bcff759041a6743bb74822fb2301928b6c16296151b7f6f6e876677d016c1e398f0b91cb33e1e5abfb0ad54a90c7104ec4d3623fef30c61e3fda01bed310a3b64f0a9d0de7d63a3cc5cc6fdcab1ed75e408ebc3fc59efd21001ac4870a671e9abd7d607b7c6a55b3af4e1405f0639b477a90e57a8810431580b8dcbf12c8354553582a71cba969746002afff5b5d15e824292e42f9afa0aadde892ba63b8bb661bebd85acef4189dabef0ac847a43ced486cabd1bebf060c921f01a2619428b5420af43b3bd8cfacd871a65c6cf7ff30b8131ccd6df181393dc319eb129a4c02be583bf5899bfb61c034d12eaba2e7b7ebfb6ba8e43605f645e121620c9f2eac4a05be1c0a116523eec4ca4cf18189cafc882dc84430f563b397c7697e25ef3606678071e278a97b7dee51bf6724d8c05b8b808cf40e66564db690dd7dea1933ed596ec0b0751cdfcbb14a6e0b2168790f0dd485c2e3aeaf40d8dd253023ea47dd3656f45a18b38b1c5c6747c88d9fbf3b97952e92d20c0f4ca470fbdec683b042369df6feb8ce2bfca0cf0178cdc27423927b95bb46c6f905c59ead2dbc683594325f839171f654f1fb99d2f000b5b749ede765cb026b773b72db62d660d4d1d95e02381e6a2546179b87b941ea37d386d45d57025aa983de17b869340d3934e1901e993df112c5c289f77afaa51416b75196378d2327f00e3df5ce6ea4dfab0014c4239f39f0b669959e69e2092d8eb7e99f933a544de79b95d890642040ff58eda3976a3e597bf5dc1baa47c8f8980feaea05b00d12f85e4db0ce1521fa4b711d9fa1694f3e97155a59270f71cdef526459f2f6779703d63c464e203af1f3d0c421a9eedf278935d5e1db00efdf3f461f2052f52cb3a01c4463219ad8c5e7ac0281c4dc7923f59ed886bb15b3d5b9cb9019a281f411994443f16a977acf200b9482865402b3263532d61ba88d6867f449b357664a61ab01ca53134a531e7c49107922ba5cba2eb486f68665cf343fab884f7b457c8c5a42a755778f0fe8d3e0f44b825893f2595ed807b7b8e2d19d9a8c749b29f8f5e1bd0a8f0614f0aa894457f73ab53d68f98dd69415e5e8afd9e8e80c5ed8c7751ba946d2ae737644a717e166dadf334039f9f2d9b2a5f794ab0c8c85b087c4dabd7c8ad3e4a86802e57b4dcf3e336a8d734d8cbb115e7ad5c8c8256ca54306aec3e4b98fe1adbe8de7a3264632201d63d38ea3ebc4aea35a9f1881a6ee180d3bf7c2e30154692c6af3ef1cc6659a43819122258635c19990f458a21f2159170cefdff419756e8b5ba09a6a9b70aff0dcf00d7db3123bc54cd4f8f7c760742c0959f6305598332be914059c5e444269e96edd0d85b989e4781bfb57ffe4056cc2ac3509d64c7c4f8204898b85d0f0368fd757cf406e6ea2f8c6a58c1e436e40499aff49b423b8e30d4f4eaeccccd2b10dd5ae97b28ed123c9924e6801d864d61bc080547ea243eb31a2a2f178804bf12ebc2528238fe8a2c4e3ce30145f5e8509796c41d89fc2649e423d079167e6f3466c65ef01d2447d5b59964b154f2d70948a5e74fb731b005a6abe088049631a0fef209d3f027fc5e8969c2ce003331fb444fd1dcf782a77ec11242a06c300977d8049154b8dc4f890992c43eeec7ea1d37060f7e4a903f100388d060c943fc29c79f374680912385c4e4c681f1cdbbcf8116c2ac620ca746f0ed1b94fad21b6a0872b8c8c068abc2ac6162c6b2e60d9925909bb0ae4aba71bb4f6b025732fb5d903c0ba69a40c87f1b64dc7f5b8af240fcb7c56accdd83a525d0b815112afbecb5444764886f06d04071d4d040118e913ee2456a68aefc483cd7e51d0f397217e6993785051e451c97272d8752b1662d9707dbac16503ee9b5a7a36bf9ac3255c7f260f7802209cb868694ade9012c24bd40e2b3185488f8bf7cd8040ca3d9d3d95a96665a0b413ce44c3f6de31585ef75a182e212e865ddd570a6f66b272d1fd18cca323ad929db534c300c8b504aa7f86c45e36a845b39cf85ec57c1750d099e65174ae30908c5f9b8762834837e82f906ed6d7752d3edda088e159bffbf39e8bcab1152db1c3fa53147b47fd76e5abf24e78539e97431599c35d3fdb298584db9f0185e6ce17b88d7d832d93622c8059205cccc7e4ab549d3e7138210404c5e99169af89ef8615dbaf91105fcf09428138368723d2e8c943e8f8fa35c6a5368b128ed9e34ae55fb8b612c3a61bfd6b6f4a83c6649c0bf6a9734055c880c346bfddcb5f257b6834ca419a99d03d77f7788fc61bfa5d460eba87adcb602c7b18f7726169a35538f7b7b3d029a921e9fb1e8669b30daf0687393be70875fbf8c5fed23e9e0d12216fc1929c138b2402282ee3eb6d1c0ae4f51ba7a14dd259a8e0d696fe5d46a748da52e3c323553752da94868f35141cc9aec4af9cfb3f441b225f1ecd9901703825ff8c3aa7ba3e5bb586334c619e87702dea07874353d2aa6d7c2d080f6e641a0f9430d8c653f27bf147e9913a539ef7fae339bfd04d69097ee912c0f58fa67bd1246bbd9ef6d11116a1c572775418f838811d3da45e3ce5bc25e64095d179df43d9152af66505b90fbd7bdc1973bb25b748756196ba0431c7eeb7ad9c8addf1f9a36287d475e52f7a702f09d5c042e2a6a1f17532e9d9de28ca596b8ad5a844bbb364607c65228ca9766fe01747b001c035ccf2c0f94d29adb40cd6a89295865cbd5e9e16238342275d4b4d179b4ea3b94752de5db1da811053fec562a38b7f7798749e32b771058fbbe07d99486be8e516b421d1cec31710a6c614efbf78bf0f57de8eb2dacbfd5f526b0d439fb503ae45e84eba3982a4364616e235ae31e774c72829088b03b47051fec674624f9e48b8b9256d5e4f704e14effbf8a77f97e329f68395522df485ac45a8b8adc52e68fa59ace3c421a87a5bc6809edbafe4d0b9e13d7b20443898d6a8cafd449d0cae16a77298b09896c15a91ecd7b7123385bc676659b95330759786ed0be99d20e218108a1e8d529d074039826f81f3ae664e76186fe0220a4bfaea8487bf02cf6f266caddf36da9f247c5786957604d0622f6939cc01594cce3a3c4a4d39f7c8e29eba9399745a01a9d4cb916d4f0bf1f80ea7c9eaea520854d3d6ed72bd99ac47f51929c304c534806077719321c731f1f9211937a280c2a07dc19af1942bdcfe549fa1229cb0566b4f6a5c805c0bcbd47861f3edb74b6cc5edd0c84362f34c8bb99ec738d3169a5db60d8c0a0f832551d3b394c3e8828238ac7c6bf3d6a12c1bba78b2dd6970ef89fb2dbd1f71c5ed4bc02005b25f316b835e9bd2f4d3a119a5742fc00976bbf2c68873b3eee91f34837e56385d5e085ed797f1a665f2cd418c6cc0b77ce759a8a0d1a5825997340065c04a8a906cbc14df5e3908bd2d49715943e08b7bee25909a26bf527242cf29effbdd7764fb1400c0abd3376bc83a93e33627a2bac50c1f8806aef193df6ad71712f983602e4749461821232d3c589eef51c5b4387030b344ec3a15753f4f25eaa608485efece4e1c89f8c15ac2fafa4f4651226d9863ad06fd6b63ef97966b95508af9abf9aae5c9c728746b33fc5e8e28029c9411ccb5b099efc5bd020ea2c485281ef775e1f0ef3f9e058f330fbb84103cd4c84aa9018e77b3cfa8577fa07facabd56b7fc59cb7afb4c18f2ecd785b3986cef403a3ff0e06533feae7d77a6771930b52d6b5163b0d1d106547310599c85163a5b646ad093004fb4f23138134f7872a905ef072233c8e293d472de30342bc286c44d351991af7280cb134c54edd242e4b722954acd51853cb149c0a8b7cc97d308ea80a3405920403ce5eea0d820b2151842cba70f6d6600de6eb58ffe74542e2b7a0fa3048dda6ebe7fdc1b8031c0f97e0d9e0e28e5ce2cf551dc4b7d399129c177aea35034e659ba4d3bd87eed13a923cbee9d148fb8866f0dee0dbd45aa6e82483be9fef49102aa0f65f82e0715a7aadddfbe6304d225bd622cf28ab34d54094c5ec3ae99ca4acbdaebf06ef276cf878d072b760050e54689d9cc0b516ad93bede304c44db201b4a91f037c39138cca347b7b7b11f21ab38d44f986afeb2ceed26a566d0cb3ea2bec24d3d956904728b4400af169db90b12b154bab120bca7fa3b37c51485d9f10c3220aa0f7df34100635ee0342660154efcdd8f052b80f3a0df139c5d51448ddbe28c6fb4c8c4cfebc5a3759286f940b8d17cdf884482ad21e2b88a0ee01720d62c3b720ff567f98c2b745b9519a3ae154ff9ee49ec6a467562d704ae5af7683dc2127e6f4168bfac561a9c3bf1c3c4bcc21dea9046adbebc49036b2e3ae0abfdc8094348937cc53a60c61ec81a83e31276e509d6fd95442db4fff5614b099cffee41c600c3fe7df42de7747d55e553aa0b55f9e214bced0d45d69bec1d9878a3237f1cab912a8eab124f0e8322740cee0adb65c238a39a39d68350f374d71108eb69990eafcd2c791dd525bc2b2346a61363a108b6d248eb9c7dd258fb3f2adf0ff9165a1043bf744432eb1b490113f562c8ade74eb9cbcbb18a48ab058128db0aa4d28b2a1ae8bac5e28c4568ee1911d508cd9c2bee6b3842292de48dfa90502c94be657001d6a0bda00bbb8f2e59b23003d95e45af55f567fd9be1a6d1ac1aa073898cd7648bb6f7a58eabd7699a604f9df3ac85ea5fccbee002668d4d3bf40cb6bb6bea8e693b5e972beb524aa385955dd06d9c1ce91a83e97544ce78cc48dcc55f715c524523d99d07345e1050362e77c6ee86d04f8317e91766e1febec5cad39e53f60b1d2de073503e4c3296a028a2c435610029625d6d2d6daea1bc302392c014bd5e55c74a6faba5f0201314f73acd9179851e5702013b5a4b286d3e125a6cc6c235269fe74aa5f2a8f8e73878822e7be51fbb3d017a353b50f28652586f0caeb3894b97fa08c9b0d64a666fa4b5385bc7c21ba1f60bad54924196372cd53133e369dba937ad2a06edd2ac66be2a1b76ebe3332a719fbe39da1473a776e0c9e67fb53351771df7c9d90a6623c33f961718711312ddda36ef983bc0157d8a0a9637a690e310ebd69bf1c8536b95ceadafd01ec54ba2281cfd814458ae342b7b1a4bba7caac188831d05f96efb9a0d306a15ace10397a90b65e5dd669b39da70d35cfc8f45984097d2a82e0377f2b9448ea4b9ba31fac38fe600f395027d2596e089792bee1881bb7824d4ed5a8f80cac891dcc826a93ae74e5a129ca8045c6015ea9ab95cc94ec895117e6e4c92bd41433d06596799638e847c6c824c2effc770448c05b4b4d0392afb0a4c50351ca92477830d20d804d5b8d2f285ed980634b8d70825dcad11f68ff58cd1a32f1ca83b7d6b2cd166bf617a925ebd2e3adbca5a9cb61d83a3a1d01efa8d401f476e9a17b5fd591babc7358963f6046e18c6badd92754a133b3629eee2e8da245331560e444c79823b6515ae0204fe69c7aab982a361c2a749ef4fff6bd7f34db9122eeb81795fb236a95a1d887d946cd03292614417024386b13e78435804f68295a7d32ced6654e0593e49cb34890bdf2733ed038da1df1088bd455a2eed82dc1743a8759dc22911479bc061c28567ada6305e6dc7435d54843cc319798dd9af9b769269087df8b103fbaf2fdc8290a6e1b96b895bf14293a8c4e0edfcead2d2976fa7d48c3141da12a070582f863407a74a41a96301c9e6221c20e2b28ee511aaa4ee589461777919712f0ad09c9e04b5cca885f9fb7fd57a98d5bfbbfbc8d9e722e1dabfd43e69cc47ff90e98a35630ee9709c58786cf5c5daaaa0af7a2cc71e14fdcaac297d4cef5182b12459780b1bb8aafcfe71d084c974d76c5a0f69cfb4f642fdeca292539733ea47ddbfc171de3bf36390ee5785903d96b762f612df04a91727a41402aa5ed5b7d3452c2ae09060b92b920762cd31207badbc79e64711d63b339fa3f73926b92d08ea719a1f51a6fe29f3320852e8798f99d8d12052445ca9b11b2a7a911701a1fe209f4d26ef47e73d3758f6fba0601ad7bf6b5ce8f7e503264fa7822928ac9a43e09a95cd5cfab1d776e69bc48883f0c0133c5b1953c993430dc0db593282054be1bb036e55ca587e5f8f93ed1f3e1d3a80387843b4ff63827600a9b166185bd604d71b6702a1746fb4f539ee93f993e62ce218a0fccb50a375f98639539e80f3e23b1749b6f3345174ba1d3d3eb8990afaa8eba5ea4a8a6c99b3e57835b66181b89a85f05f0ad8d60d84fe8e1dc29d67350db7479a72ab3fb1fc07ffce7dff1e102d4a1c490965cdcf3cfc99014e6d934b4db28a3f42ce62995122d5a3c4f4691e9dc673c9c6c16fbca20b038688e5fb0ddcad500c7a9be111b811f1d2a0e7b33104f2ec785ff773aabc91ab8b3c2b4b336864b533ed199e10e11a1714969497c6ea923a158771585144cc002bc0993aa54e965dd76e9178744c483b7883b5edaa38d87b850afff137c54fabbe1bfd17a08b812758dd632ec4566cafc889e0dfe73a91671399bb35c7bcdc97bab09cb3ef1c8d92658efc219846aa9b58f998b858618ee9c092a664c1e18cd1829f60cc0d2f33f5ef6bc445a39854208316ab882eb1a3cc9411724226d9a546be77a238c33076b7f7adfd60e55bcaa60b20ed05ec0488fc2a441802c5ba0168eaf6910f94252b1b5a066e1704ce8e8e8d855f86a739625d7cc7e2cc8dd96e4db2e40326baf8fa112ef9558f3abeba4659e47bab06b84508f8d7ddf663e11cd2be63b389bc45538fc9677e5aba122f94e1c8d06fe074c39468a40a83317eb0bbb4b848567b6bf522d753a4f59c1414fdae7c95493293e01bc2e6411c2e1dbddcddeaeae324aacb27ef1d8be11ee39908774a6af2eac241fd3536bf45091c0fba97fb66cb0787b7c7ed5ecc56b9df204d08eb4dd2a35dc21e039794d4a6e414016f5dd285efc7cf3cd9d58e950f50abc51775e7ac5b1b8c6276b6c6c03399f3afbc42487b6bfd0fc7e17c0e15d47c8316fab65e5c83a5f3da5fcb3f3c771fc573c1f028065bc2548648e498680a2be15c89c8c51b84d1809724166955cb822ee63add93be6ce61f6c05fbea87db00440aa4f7fc86186920656d4f23d627695cd466d4ff2b782ded5ecd0910b72250b48d3cc94561cfa5e1b1352cc5c44eeb7b36babf8c3957d37304da7c1b41c55d2ebe4bc81a82a855ddd9595bee8aa7ec236ae553b5cbc548eea924e8c028f3377128555198b451c7336e76f84432fd1bfc7652d96b6311654a95c798b2f6f02dbb3a381a84288aae89ea53d0e9bc6e6c0b7df0839af19d8fa0889159c68e7fa12fa7f5ffc8114038bd3f7d25365a746a12f863f624c43007556aa45ed66dbc46e8857c488572a32ac3fbbc38fa440bffab1553990ad14fe0d3aad213f9eb8e677c9f891fdb2666d88b3a92013104d08136d7c0535868384e739e225aa62d404b6c76727b88e4a238ea6fb12c3ad0f98722fa86f3f8ba4b5077b53d3c70ba1e5aadcea5213e2a76450f1aad403c36250436247231793e5fa2f9dc1b6d3612a89d5b8e1c356729c6fe6046af8156ab39519d71fd9ab34def44b0245abd5f9b58b683cbf034b8aa36ea4465e9481b7399d22e76ab2312f02d8792651fbcd6aaded2eb626d93a042df38feac4999cbfce201120136da8c6b0f0eff6f36344864344768845b7034aa0a22f0c02aaaf5cd8dc4525ab124f157e003d202b38b32b5ff5e654e9fd3eb6a762bf436a2a4a8aec1cca32cbc8d386602964324c9f12139021388aadd4f92046669e122addbb2c80762d64ca41b65a602a683f00570518d1e9468be2b591e2fe154ea210ad5de272305ca1d2c49548fc2a031d959acbf31754c39643e8190cf1cdd96dc6bde45e5677f1355cb2587481eb93cd575b9f7b2d25b1e5e453931fbd888e9bbb450fe50565225dcca277dffc79179b4541e9eb1b161ebb3e4ef2bb6aacb7040198f2be69c33a58dcbda29de0d17045c9a2f6117d84680735cae1f352a34026092bb3ccc0298224a463d99c068536cc8367edb0c3d2ee4c564c3422ea6561f069f7592750f0e6ff124b1be4e1a1e7340c11ba48252b2c50b20cba8a69e5d90266c376f2bd6d752424adc4f80f585bd444967e1e222e33ec7520fae30a782222edc47b61d135a0e41298176b17b247e90ee39ac03a9ddf342b73cfb460c3ce736c23f57406c165da459cbee967d5a2784be364b325f6d176bdeb5503f0bbc152e8c9a657b0cefed1b246e9b742b7ba9da4a7a8703f3344b8a8490adca23730d4c985830201cbd3e4a823c20005e60f28d1fcc4336a8a3e566d1fc9247321aea958265a65be0f5c937c3decd4568fb3e3fa4797f8e4bc7264a92b15b84128a94e19cef9c663d5f208b1c580e072d44bcbbb94d18bbc00495105617b463214cd2046cd6dc0969a38ca69c434be8ccc6c46573c65549cd6fc5b0029961d1507bc4ff1a0bd53b27aea0e76c05876ab64c165fbcce6558d25f0cc7e305441b1f1009d1d6d6d36af3e2d9f73fc38d33aba3689a49288e0f602b886ed35e4ff90cef0709c7dc2aa72d3ebbfafa7fe734189b9077586848ebea00864a67590dacca35c859c303721840dca1e6b26bc68aa1373182a7050a8afa7a7ac7546cc3d2018939ec77990d8c84d769c234e17a3512734fa612f7ea062af05ef5683801abd1f97db58da4ba8f70f8de65aaf50d95d5eefec7092ecfce28a5ae9458a53746f81f3c2370d94c0055d8a20d3c8f184d4596a051e280abc171a303923b639c160251bccc02d307c2c3a5487c7688b588890f9d97fbba77ec6fe146f793ab9305131c9265a36241715d2bace43bc3f705e40808a7f7b51941a7cd24cec7ff0488378d29ce6f644515839dd81cc600cb34a87ee625a3ba4871ee4d02e47874defb9f608e8bd3a37556396307305a03b282e07c6819122f79c771e263842e5556cd4ad2682122453e118ddfa1d36b13b9f3976ed5674c086e57745ad7a0cad1ccdb26ad768169c51dec8ec90627ed51aa21d8bdeb165eee2c4b67ef3d4dcdb66995524eae955fa69caad496cb4b4af7d891daa9bedd7f85efa31489873316297a51a0dfff420ecb5bd6defbbe9d1d7ecf7119f06bb7e88d3d9def8e1eded1322aaec81ca8c38ed493bbf9006747dc2c24251fe25185064d914fd82d624fbb601bdd0a2dad5662b369c994c190417879f88e4084518d76586f0b8e45553db8dd325865a51f215a9c23635468c17253dc8b349b5f9241f5a926ed40ac25ff1764948545bc24f8326e6648de68b4130e5e239308fa302af6493fea478e055603da9bf123dc3fa3d3ec4e4e0d22813d74ddd6bfa4abb8723230b44c4784bf813869a0499877d6d21611529e45a0436c15777e86a9299b569b2f0f7fd6749634a15d3c803630a13524be6c2d90efa8b767f0586bb595328641f0d413518723251f9763a5287d4abafddbb67103b73f2ff579675db7f82bc6b6ecda706c1e8a0c639777023aa0df5d2d93c6d347df1dea16ca180de7480a5fc01067b4e1d6938a4ec0a28e375c4bf70e990dd9e505dcd2a91bdb3682a316f91af6adcb89c5036f143eaa15c2002962989d6a2ec1e890a0395da60264934e95ee95b6491a597b49c003ed0363f4b9ac302ca94e32b931888d39daf4da3b97a24e49deea68d79281866f48736976fffc1e59feb2b0ffa5d2a1e9a9307ca44c5971ce0f28fd2dd7c9162b8acda28c839dfcf356e8b9ef8cd8ebac56532b84489239987164fb1007185f5b1654428a507e06d402619c219ac24afe7818577bf8b1799b1b7bff7b2aac74abda0fe1eabb2f845f69aaeb273bb3b4c655c0e4c43dc5181829418d5408654c5e967ca804b9aef7c3d383971ffffb6cffb2eb47b50214d7e9ffcd82a5949aa435f6117c9a80c66b81c21a8eac6fbadde7aab576c64cf87fd25967f941d06f26ec0c42f7f733e1fa333efb9668651110ce6279e78c12b3e436767b373d3c717746f6560378053d82a4c47803cf0053b75e410a2f2bfca23e05492bf6fdcfb0dbc3c35e948bddec105fa0f61c5d6093a31040e267079177f5b786f2a490b7a8c1da43997a85c34932bde479c963f04760969277e6cb0a819e09ee0c638aebfcb477f87a8a24720af7ed84cd0c1b5b26c29d2f81956543e416c704cdae280ba7f0c910d4615cd2b39f550a8209abe0460039d42ef44a0138c9bb938e840f1273cc29764b53ac11eb99a7ca8369b58a57177d2245a3e0c70a25232c4f3214862c67514ecbb1102570536b7946b0062cdf2e61375021bd9b8bfd4344542b882d9e142dccba06631d088d986fb0a014c94cebf54076ad7119102d50f4b746a0083be0c298498491dda95e4ea9ea0c10a995f75311338428a3b8cc6bbbcf0466e2dededa707815c2e18e3538abaa49e4edf14adaab54c0b7b27cc869116491544169ef8385f9a8c29f2d76df0918cefa2eb31de67b1d9e1feefa3e98fc21809d58a03e4590453aa17c6eb7ba2e2db59afe0a49ca34a6b445db86e0d2a0b768c6863f9473d908066c740680594373615d71e53a3d8c3818761d4fcef91e6cc77aecbf1d52bc116035cb8329a7119f6f1eb08420faed51498900e0854551838ec8400db8217cc648bf75799139e5b1f691948214daaeb9c9c94e42de5e19c46db00f52c3f5e3585af7619c60d3c71481032f2e065e0f2214ae7ba8cc20b811eb20183573ae20305a130d1a2a0557c313c49a11ede27087ce77546fc125e629e0e27987c77f335b119c43cd20446727d2c6757fd9be252798afe7fbd0ac4184fc9143391591efd49eefeb5d82b8f0ffc720aad5a5a0ea36d4689e0018a6599a244970ca4daa1d54d5a596f5fc956e0e45adb8ed79f09fc5dba28ab12763705473242d662ff0cb8661036081d3c4bf2217af5fb253f773a94cc90715c3811145deafe7156d756299c63e32b994ab08a7a88e42cfc54b80fc18214e0a6f621e18a70e87c88e3409cbff37384e31f35d1ba46c7802a450048f3561a1935ba05a899795eb8385f8773259bd8dd74a689d03b3d1a464a92f60b4bf9f52aa30c72fa1155e2ea03eff5c9f8758b7f125a56246805e4a831fa0715cabf557b73199356939e84054950e9136cce938820593a6b4046a45e123fac8d096068f7acb371e25c9189e0a628d8518ebcc09330ab16b1450732e956cf5efd6afeac63d0ea44eec3b7c0b91c641a552041854d23dbb6204ea28b8fce74aeb23f0f24eb4164363b6951a8a94c5481fe921d1d299d94710ec99ad009b6c369a4f03c7f390097ab6e410c469fae6c4422f99a0ad7594ae752c93369e02a0b5cab40b5408ad9b7f0db1fa952343b68e5d0941b4a596acbec760035755089cd6026ff86a56f3339f3c20eb5eaa7ad20e998f83828f7304b4255518cbcf6013f8772a8a90bfe9eb7309097a8b704d0641b313b1943c6f7dd35d6a9a9b8ca299aaef871ea009c78acfb991d0144359fa1c680904f244f758cd759882371fa91731ecc939c6ca01a5203fc20bea27adc272dac85d4a0d6f49baf90016b8a8bf74d58358c4c1fc69e70fa356a2791d4b15e18d5b7f0fb0801d178568d893f6310bb0bfda01893330eceb0be42a8fdf98410cf1df8f975f91dd0072413a1f4239098a9c066925e01a1f6aead462245c8df066c7af601d3a401b4bc5c0c217de9572a321cd92ae98a64d56900a2cdfd3e65e6411cb4eb8e5134bcef24e7b8900827c1f279ab8718a7a0e1832ff556d033aa8494a3d98189c98ae2dfdb085e3c21d437b7f7236b46e5fe443263014993a640f3dbed05e245515139a340346b0775abc5e275265707d369518ef1ef1994017a5944cc8b4d7d0fa871ef38ace1f58dc68746f0e243248d84a83fe3b5641e6b274f78215f7c3a4676efd5ea2d5b4a28e9fe3c3eaf3337268586739367e50f49bdec8b766f0c2cda516fd56dc4b8e43229f690894f2b00214982cbb6cf2b52368e4d3056e95848d6dcb840e5337ea7888e1d5a38cabd548b9ff3f6ab8c3569bb780c407f9d2beb9e4c5655eca16931630a92e134cc353e47cbf8ade47d4429befbefac7c8b09745db96cb8381716bef6523a2af93dee288f2f2e2c8266b3dd36a7611673100939a19e56d708c86a8aabec4cc877d08b5bda17c2b3f5cf79d64e3eeb8710cfa0648fde3fc44414cac6c567d07848e09ff321ce259d06df0c157880fa38ccd92e4795860e7c2e91fb14d2e58723c117848bff7e93c8989ff2f0aef5c6891d487adbb89ac36ba9d475b4ef0c9b939c3b26459a471f20dd5844429ff1565d4d76ab8a5992254b795d5db92a83abcd5e5bb90e1b7f57d670e82ee8d008ca11d34452a73c15bfabdad4d958260850d77cc58dcea6adb8c2ff30ea66ac3127f8390f4bdde3d64679c3f0cdfce34d293b0e9649bf6f30f1da22d2e16545cb27f6fdb38057b5c814c81aecc2b90185d0141e202d3e3276804010869be64e9dbe1cdd90f063759ccb97a1a84229e54a0303be47dd1ea6c7a9048dd7c737a76b97a7356cdb2bf429748f025c2663ce94a2aa4835d8a8d47524de8d498da0103999037d55aa727fa0a2814fb7342e020c839e877900d167dec3450c0a21831122d08b0bdee92775735758bffd8c8234dbb03d9ccbc8b03a9160e2e2b86cde638c32b93bf116b2328f57be8015bd3f16c6c1eca0a43dbed6d600fed581922fbe7a10c483dce0e957b0a4b9c2d402ef75cde557707eb999c58785e1d2e09f1a9013d7b4bd6f2ec5a150828b9f3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
