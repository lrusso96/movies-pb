<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5c4f20682b4128c302cf059e3cc01f66480360cc77fdd295f5ab7116c16180cc8d92c816b51d59b2cff4c0db8d7ccb2ba8038680066bd002c348ccbccaff1c7c5a8d0c365996a58deaba3e43bf92366856d348fa7fa006f43003af17006612d413974dc1cdce23ed9096603d392056cdffe0ba9c9d770dc4d41e117b8a8516468217c8b731e9188c8854e490c7c648d6d62777dea956027b40d193bcac3244135aa84b0cd0d78044c8ead0ff4b051029e57a260926b36ff065e91a6a8d286cd613777963caa253741cb4615d5857dfbaa37cda00ae5aedfded47a40d51a0038299f54b6e20d32348a7b9e1e840fb8b65b8f2b444d98de728d3633e20d59f24bfceb282b44b1ea2a01c8fb7ed2dda787c0ad7606824b46ae6f0b0926448f0ef42cfe8e3c1b86febd8fa500c09a2efefb0fd4d407aac00b4063a81690966e6f7ca75249ca5e29eac09d9fd708ec9e3cb0573340a87785cc2a4f128fb848c41230b94b64aa387a75e53c4be06b39054846a790a62d0f1364deb7e96ac3e4424d9b961834c125b52b10d7b47b149a8692c5d7e4738e4ac863c292dfcdccf4050c910dceba5b16132a0a8293b7eb4fc5aaa9e3e16fa2a90076c87cfc93ad9b4d018c6f57368522ef9f52c7af3dd68310d12a7b4e472d6dba9931b4f2cf940a1d784a72a9e1df00b3588262e9177a7e112c97d18005b96dce617ea6f683072e29d352e61b1545f5903e0a3cdf252ce58dcbf8b137765e5721d00a57c56f8f0589d9e4cef5012a571c8ea89cea31a2e91eb43bff72c644b315cc2ce28edb8275dae2ffce769dd49f926d45e4adaa8ba0dbb3fa0ca8bb019a69dbad0c1eccf5f7ddd70d3cf6734983c33f316908401618929b9997998c2576607107c65c7086d78235991fb1351ea4c153bbd034801cc26b50526b1e9ac5cdc1d8b8a364823890b282c17ccb04edcb1b9f8939b40f5f700504dcd7b4d64a95428267264b4959257cf7b074c5043f673c2276c18002f4d1a5fd6f0d768cd56d4de95dda4882c72297909d7051f9a7f17fa0c012e7c1a01dd4ee3778386a9eeae9be5c9683f6524457c449e5d1fb3b5631ed53243b33dec3cd0f7d2165bcbcbdd3e8a947d6b13ecd9d2a4e16de6fd8749c388a8df7e2a7fad929a50b7221811dee86ef3c036ea9c6c37693777198391754df98102553fd581bcf5244b151d1df43a6ea92f8c06bdbf246ae46574bf33d7bbf726a8a76272bd6083ca7c7d22b737f94293f8103ad66db65037006a59fd7ec872e46091e36806b4b501baa4a8539cb2cd57a24d585709ebb92a03a0cd655ad498ee9664ad98e6401d9e0d4d706f9718803c981c6498a08e4b89fd497fc8f31bf99668d91daae3a8e9acf23702e755fdbf3fd6967a04fe62986eb90b9318f618aa11675d3e32b37ab3706093a1dc21da169a6473965d96c741c2d747ee84f2e297a0e47ffabe73d17465071d23e037945fe1385c596702f6ca661ce738bef75a722b2862318c3c4c1dfc73bb852120d8b40c6c5df3abd368b0cf800d6ab75d936bf8bd1e8fd481b17b05fe4812b6151eada691b4166fdc99ac0a3f4a0fce5dc2f7517b598eccf14ab3ac536b62473ace5b33cdf14d43dcc1abf5ce60ca8bd2dafcfc715f740ed67c2d8c634f35b1488955d19ec62f1ee4a3e58ec0402135fb381f01807ac21e6c8a521b478e3d8bbb1c39d8170c8d5ffbf56b02632577f14ab65e6e4e73fc73d627751f7c28929b28401bffaca912cb266cd86318d435c2e6e1d8ae12fb4b8fc3d1ddd1266bde26390ed9204b1b2e19b88238d33f4035a2ac6c80f8603186e37d8d46cc9fe9dfa851ae289a33fcc2a4ea2925a5fd0189b22baeb91e12f5b2343cb5ea80fe5d3cca21a46841622191378116c85efda9e9a7bf1c3b4ebefd57680e47cdab49565fb80e1c321b7bc1fc1e5d2304b40a87b07b65ddc8e8e3d404dcf1992b0a9f6341d7d70cbe93971842f87f4f8424909b809cea27b2ef485eb8275ed51b021466f1ee478bf853125a589a0875d98d1cf2d648a8c5fa6c272191cd47fc6c52b3660811956a8e31f9eb0da1a1a74e067f8a22a5274397c8d071f81a3c541d0cf63a3f52d633007517bd2c60b404a0561444b875d2f5655ee2b05ba3bab79146f4133dd010799e228850b46cb15ce3bf680ac19cc85373ecbb5117d4285e2028ad186dd4a67a1009948f969647174b4b46c324245828ea7c36645cfc17e60e0328a41fa8310073499fe70e8641c2d1fb9f3627ae636690dd94a0738dbb4f85f8a50eb6309c33d2a88930de4387af16763ca4c7465b40b9f094e5c072025064117e72e3a7c65a4f30b3827cc69a1937ce85007a8d41e0f10177e75b6981498d645250b59c837fc733722117916b0deefc0401c597ccf1533c3f8546da2c95391f3c3c7fc108984681521584f16e5497319615cbfd814158d2b025f92d6a211d825d4cf4352382fc1552d027eea51a231f7b0ce7308c914b2859678d8eb1ecdb79ac363c3d696d6a7a6535fea7055c174fbc337805432caf809b783354beb6973d5ca254d9ac6ec04af9fd0b26c5507c6b8c8347cfb0dc7ba0544fdd07c463341ce3c5bdde2846913421417fa310bb79831119c4aa9fbed11d7c2863b6a8026e52cab05e68d0b2bbacfa28095b7f262147b5352bf57d6a5b72d4556ff7b330dbd1345a41efe2fc921c61410ccd95a3ed99f7b19b08d1eaa4b35f5b7df80a91a6e86443f3a933f08277bdd41d6277619e0409229fb8ecbd46d277d2464f83f4958d9e45b4a1697fe494e3cf2d3b3f663489fc27261cc4c61dce10a2684f51c8efbf46bda3eb033c69d598f332852bf2c9893e9f482019bf1a490b2d780f4ee196b454c0daf01de7c895d7cb47d4f89e72e9ccdbd4e80d8c21c7640ff60acbaea771b85807254f6b2793c32d940dc9f0e4776856dbcab070004a5b51db2a94103a884e30f61d352fccb34c51b3ba9e506944cfc4b28ce371d57444efbc3a88cbfcd3913c9f0859d0d2a823ed7507384e18d912cf5a8830fc4c5527fa67e9092bbbe0bde747239d6754c13ee4bac7778acaba80ac040e16f3f40d25a1efa943d649e3d27e8caec96e7430474e9a38b724302e4c50f3b1664263f33da0bba3dbbf7cfe97d8b9ff6070d8a4a2df030e09be7f7ff46b1ed0a691f5f0e5b254ab677d249172cdc6f266bead099ef1dc1cdef47ddaa6b4c047ad8a7783594d9749c5529b8ec344234dbe0e3f6cf762ce69544a8ff1aa9fb35b4138e91356e001ba14e312a7f30df09ca87d7aa36887d70c41aa32a9a71bc3a3bf27eb0f1168eb2c8b7d0f979b49bca6de73bceb046e9f9aca4ea14530e26d2757bee1ded4c397d79accb51e6a2af70b2bfc3b5c23dfedc2b1eefe0185a4ccc6c895a1324bb3a7ba332f596687e637e416ff1b3cab4fc0e20150a8d0284919eb55848d6d35ae159ffaadac3af96128c65c86a5f77ec359cd867ba18bfde43e9d708410fa2ddfa1bf0e83e66c11f3407420b4f7b43b90273632f5442ba46582264260e52cc815f0bd1b70f707bc20e2fb4371909c49bc2708c3214643b000ff143b8698041f4b9dca46069af05452d1578c24ece5ec5ff1eddafa707cb128b85422e5398d01fce8c4260308fa073780e721a4e3b524a874e77e1c45eb49f6fc847636eac132385599c899f000cd2b2251f3f16a2405592b1380731829002308a8c7620be91c46843addab5ec697aa7b7ad487e8bda2905e16580010f0fcb334f1b007cdd095e5db8dc66366f4f38f0e565a7e2513ca5eb1f5691b98d838bba594acc2caaed360a9b0bbf6b1a59b7752aa35e734a745a593f418e0a83ad6f91579dd8a39e5b31365c14798834b062a78bfa25770460ecc107e3e444ef3566f67cae3bb15deba0d701c4ba54e35547022bd2854056394cd8136d0adf2e96b2d75c2d012b29a57864eb6e95fd8cdd96c9a973308bbdc03a26b57aa77f26c3d2141da574e75ce269fb823a47a4906d2f11c95f098a43714d7887be63348f55736cccdac037de5d3220a29b8f28c9500101f060b90d87469cbcda846400c3d849bd287e88f90d14a8b46e29fdb9d8444554666a5e756dbdfd94801ac97127ac4b129fa694c9e46418fddcca529e3258a1873b82c60d0048e947b4fa663cc2897b6335b79643ec811b086564827bae9d739e799969b19a700395e8267cfc55ba34564124dd2fbafaab81c35bed044dffeec66c4339b4be42caa7042ac738c0c7752f21a8259b38d1dca680088de37aa6e68f0a674cc5ac64720df61b66600ed20df68543e717ecfe5341dfb032d7b7693e5dc0bcd8529b35635c01d5b024d0202f850707a43b5264e5b1dcc3596280bfa6e5488613518548d9a2f69adb8a8594757499344d2b90edeff0e7651647d616a2b4a7ccd8e3bee6c1b99379a828f70c8322f6711e5907feb8baf7332f26d812a83c982f7d8d2e8a551cd3d96c5b60ebb059e94ac657504c542e0b691a129713c51e6b92d391c8b3bf166322a0faa2d87cf2e00047a9af2a7444eb4887088318ab51f49f8fe815db544602128f0eaaaef6d1098d477f467678ad047cedbef26b1f73eec4b0b3cfc2af61abab150f81eefa889f8e9197703710f3a3aae1730a728fe6e0cbd9cc6065c81eb7e4ecdd29041bdb862410882196520094fa883bf7bb385608d9905da239cbd7086c03537d75414bfd0c29ef90a4e76b7dfe07ed59020ca2bb318c62c021d977e6eec98240a7f22eab95d16a441a4e964b2dd41032b0f9e9465b2e6c841bb9854b1becd8c644fe2d0b2f773d81b1246a04b207c61e6f659f18cf034e7708feeaec3b2fc4f3f4caf9f7922a7d104bb9d2c78f535fa7c78b458f394fa92739cb512f47bcad5c76c94986d360f6f9418b8cf8adb00414705a5604dc351ad05d836820131a35e9331a28b229f8f0d003a63764ba072a79b6658c8c7ccc55b475975adada30c6463767a474e5653378785d14c4c48819dc94df3f7b59f4df8bb97178e1283460ec73ddb8cac036a6d4274cf05f1a57df902c4499e5061294269358466521571362fa9709fa02eb7b2bf7cb7fe5d3288d1abd1a31e04601cf462b958d777cfaf0d36bb2fe92468a7cd7fbe9f1fd87d15e4ae3b708539d1d89306a9f8bca0c300172b9dee07dcc1c1d677c8b1204b2c27525e586b7b6866f7bd7e9b5cbbfc3b8ca39343d3c36a6b00e050e3a02a728bbba3249309709634e7124b58de2c824e6aa88abb1d25e58ff7e4fa90c1afcb4769ec5a7e4db1334de2880acdb649eec329e94531099e16c8559281c515fa0febd4abb291869eb6811a734a458060c06910870159d1f78fa5592913b66f23e15acf2a0e5cbd08ccbcefb02eb766b8a6f80c1821dfa424f316752519bd05c079e59d402816eb4fd3c5542df2d99802a90eaca855bfd01c074c92b9b45f90aab44e8773cd993c21814329760c842438f205b30288aa224173428d71c5b3d27e8108de23eed9d96072f0078224f924984c98b7b7856bd398679bfb863318487320b59a9140f6a9f478747b0da5370a83b7b78f973296410ab040576d1218ee439af7c5a8e44f518359bfddd733fc1f5eeb97e0226c7c028455731b0d1e71e3fe3a5fc789ba1a0e1e2a298c9490559171659a9e4d1a5ff130ea19c8080dd25e15963927400f382acde224f7a9ed7e900ae28bf9fc294d45c319842022710b619c689f113a7f951ac0843eca15dfc35993365c0bbe4f3340a96bd66f9de38cac2b6d275ec797c3a5f633719ea09cb76b47188c2f3e49e9da47e904aaed8ec2c8ca02cf04ba513683a18a1d254206d0c53ce0563864f20a49a60a3589f42cb276ef7f5e293a4231422266b49984831caf8c1d09bc4fbe5dc0494c883ec2be6b532a0b3e05a19009707dfb225ce95e15337bd0f7d90242fb2548e2bde40daeb04609be8c9336f7bede871e64be2f6c6173b552dbf605e6b34919057e30792231c58a57a0d81926d7f95d81daedd4da7863ca939802e34f6816c058c207401cabf34b235e9964205770e8dce326a169a222f3d90c8d7fa7d2a892957e33d9056d5f0f95e8a96cb536c499b1dcddece4f394a1d486a5beccb16b27e031144b339140699ec14b2729c109693a453c322eadb06d6b27e22c960f0a7ed293ed3b61ff95475d5a62c0cd0121d01629e4a20ba92d201fcc1afef927bd6881c62c330d95b776e88af0cd38a28912dc5ec57039b384e1580bf0189b529af1663f2cf83366db0ce01e675d141be4ecd095308f400575d504f62aff2a25eb3561718b2518d445a62e8fed8361ab021a4d28f49167f6b8bbbd8172ee35a07de70e7d3023c8532b882041f208633b3b9c8755ad4c33237a44aa24b4a3fdab3e57bff3fddf6b228fad7076b26bb06fed333c01369e463c4ef24c17cf09962d019eeed904312e7974178c3b1c115a95bf6be7367c32d9020b6b3e54bcad0ee7bc7528b7e06fe9b5ecb104e39f9e931ac42c4e6898fe7a4619893a52314a3653db295bbed19645ca280df783dbc9f7f98040d2feeb9416fa84bf34500f7ec8e157513bb925e86530dc08c69fe0c3fec3842d3b310cb786aa3c781040369fb468bada0666af4b08b25ad10ae44299749118c3de17c2a62cdbd65826e08cd7559a2d0c76e6356f2898e911a4afde2b68cee40f9eab1eb8d4f6def11b81faa3d62b87ec74724b86a56cb1d8a3987700ddd1103510e6d1f79215d84b9546c412c1e57e18a915c7f9cf9a51ced98ca3aff3c813cff06a8851f14cf737ab6d527d6255d394ab743c255d712c8e5c3ade9f5677a7315f34e436dd0297416f0a9bcf8da85c141e5d2343215cfe29a2cb7285805244b773ce36c72270199390cc1954bde51a8fb7878c2a66642641c6fc18cf79b72718a074043c840ac593b82c846694f529f745d9262474e0f760d27071878b940666fb14a168c1441a6d7c99231072c93d4e3486b23da79c28791438c50e7a80e73dc2b4df271b085a560edc59c6dd4c09ce21e83733e96e1ea3f3d475781a0cdb9fd5b1359edcf9063fdf59e45e83b8417691a6a03db0b7ec8919728aaa46ac25fdefd8fdd2585c51e8654e291ff50fcd42030359f57f4f644da972f9e3f3a4ab2f9acf813627f6f14c0b69023572e7e6e6d46c71e2276e174fd769dc34aaaba7ca21e8cda8d95bf0329995b6a820c615653e7ad37cd3486d486f61bb04f8f62d77cbb121b40f5263e4f4bfed8f1608e180ac6c05ded3cb62b1bcecd27b29c1a07b6933e6e573f875976cf18a52968c64001d33d19a3495dfd958be03185e14565e60e51809aabf5f50f178ba1031a1ae5d4431c7748ea7a6e7ff04577842cc9588b7345de3ca7c7d47d399bb7eae906d002a96f18f629e00a1d4d15487adabc1d2c20239b597c3081461b3dfd2983b7684ba3a1ea11899d7d741b97d895b28034ead30f22abdcf83767a32588c5f458f0d66a7b66fa035c9fa2d33c4c8c5827fe07e50a9f7f5f105439b0d5c8a097b5ac4328e28ebcae613590b4b1972b8aad096da90a91fbb61b08a866b59e0804cb38eb8b96c510921dd13121983daa6e921831703891853d8f32895fc9080850dc4baca0a330a8d75dda70d4da00f057ea148db3611a1cd487de9060f7c9b30b9d06cf8e562e73a1ba4e65d956e78863bc3e87b78eca14287f5ffc7645db0852f47b1c77ca08121fd9c88d3aff00e622a431f76c7ebd7e3d4dd47439f845747ffff08d834067f10e0166e8d5aea7488d87367933ca795ed50b302a9b21bc84b5c31a588c211c037b7392eb8df5f13a8a14e606fcd49cc5b3fd39acd4772b20c50b5833120a99c333e247558db3ebb4c02ec08a7171cf5d6e016c3a2a8c825b2e80741c7f93cc45903b393022767fda3cde42f56b586a2fb5e4d47e13eda7596d14e8daffdfe5fcedec88c6b735f47f74277078b61c3b5a11357f9350826476cc7c62a57765db113bdd288382367a91c1c58aed761cdd51d49cfa7a7ce5c1f345eaf96db91964d9b473192f15380253f95c9ec761eb12ac2c463b5078ab98cfa675650481732738704572d5bf3cbfac0b9261e8f00fbc77b3a104124436df62b992ca0229605397fbff0c8b2afe836f80143bfb8325ec06ab6ff80a779cabff26a03148987c11a9225a9f109febb1aee541e8aad2f8c555a707dee0b76ddc249c7e53bef3a9da456df9a1e0004c0b021dde63240ab294cf2a16a27207533ad68f3d6cfddd58c322a8c625e6fd476303837c178e88b0758138df1c9f3f7b7665a30ff4706a533d0fb725e5b2bd4c318fa2cccc9ec1cd268ee700b67719c2648eccd8c1e352e76ffbebe4825153a5a43b09acf22e86a7bf0e73fd14b3e0f8bfb1dcc9348625deba41e2aa37bbc8205d148149a56fefbd412f3e3dbdb45e26524475d0c400bd878972019498ec6ac6aeb964a7c3d7c17fb9e6f0b0c0a253b739c6512551fefbbcef5c07d4207a44b59b46bc114699cc4bbc61e6fe604ff2ee703af36ed1aa30af4ee8d8b4f75041657f4dca6f669029be41f2800d70d1d90cb7e8fc150b22c04e511f9384f27bbb29c332181d7e29c27118d0db7b7d56ee696894e1f912e1e1686e85b8c0f29d63e7596f156fd35634f75be4f6cbfec5091bb5af8ba53a9353cc5b9b95238bdf6e67e378b6618c04002717ef31d1c47c54dafcef8e4210388562a3e7762173e6a5514bb1e9544988a7749f4eca85389baf385f12ba55d019a515d5e1f6f6c317d2d20e3b1088fb5e9348b72c62c9a63985f59afbd9a23ad0b901d697b8c8d560c7103688675f4b28e34726428fb8de6475fa9795b4ebb73b13e2f0570c5acf17fc535bb240a7076106e4f70262ec09ffcc09fee698b8d7a4b1e23c493c0663fe71bd24fb15f071d840e0566dfe18588125baf8fb18f8e197dc1c90b9078bf5e61f92b974ec362735776636b97b4288c310e672d4732fc61837a6f087cad1e31009a659ddd093e3a426c4ac4b55d3275514f1895259f000a950bca7cd4f160038a28dd72e9087f61d64a32d83f70ba3a100ed2c7cfbebc51e29ef8ff7f01d8a0538488b99b32a944bfa2e84fb9f536bab8fc9b8968768ce92ef49d353e5e8281476ca5e355e21da0e7104140969657544220311f96c98b6d3badb5f2a79316268be05311efb287778908bdbf028fef06d71ca6e1da7b13b2855aa1640b19e46b26e60a80d06021851683a5895138dc261bc276d2ad36928c9046ee1dd54ff3c741347016f44600ba24662653dfea4bff60e32330bcf3844d388c1f4c05d8652544f88148f7512e30473944a016ace06c08fc7d70e167908c90b49db4438292b30860e41ddece02ec6554df18c16df8491693562c2b2f5477b063595b51b03e42827621938f65beeb1e5dee7c6f0f6a1af6205ccfae11a7a460e7523e38da737ad5c9f3fb41a2c4f032c8fcec5bfd37cc6de9caf8ec5da1acd5aa0225739a0f142e421e014858fb8f8961af9388457effe07718f424d58c8f8397cbc6798e7b453c99757dcd0391f9861fa8497a68181200e5e0c7f2617a9122fed0d8e931761dbc1434b5afbb94699cf6635e74e26c89a2206beee3cc5e646da6b2f12baf7b36edcf47c5bdf2fd9c891fb17a1705000583e0664dc8d658272e4103c04e1e9a8d98dd73771ab2121ad95f719f76ac7280e030009363a826ae132897f9b0cf901823d28f7af2bc8a538ac55f79aa6a6622306fd0e43591e6ee2db155f99b5a6086e7cfa965c1d999b983d167661c544be6b4296ae636c2786f895b28a3975242b95f978a42f1ff146b506aa7fd992d1d4c7f1ecb99456dbdf829e99d7b4e226bf889bce8383ba18abfb05c0ba0f250877c868a270349f409903d949dbc356e189a8f0230098c111c28e85280213b36929534d44fd4c2c95c089c729dc218427651e0c59e97f3df25232a3c41e8bc866c710a599b4a0db0101a7d9e7c31b7217e76af633e005a4e5fc87916b4e13abb1a4ddc0b72d8402a19e069e415a32af53cc04b54e1097ccd233aa99f8b1fccfecf518c53a534dd3de4145d12ceee6fd9e2df2a55d1309587c23dd1eceb77e98ad9d2a526c9d2e2c65bbe0c3ee7d00790b8490a2a670486261057e5548f4117eeec2d506af90b079528665a1d7425d5a820a82194dcb46830cb4640653e303f2e84f5f7ed3f875154dbe91b871d8a299d58140a35f48e3d5a68fc953cb73942adff2fdbe70598a8d2c9a0f7d8286fa35f08be972f84e1ff232964bda077d8f3f0e43bff078ac70eb144b4b6064fda70e44039cfea0fa85b2dcec81b7a4ed35ef5e8d71fa87018049e10df9f4b9cc9abda760066efa44d9a52ce49a33061917d969d04a6287a74d99df5e475aa881bce7611dcee726fdb6c87cc99cd44ff23e2c689ee177a003e6e9e8c4c9411156fdd772979cedc31f928764bd7aa23692ec37a430e8870d5cc3f5fdcd70f92133cc6250f066581733335ffd3694781a1c6719033fe2964f56df8811a1c8dcbd1ba4a0ae36bd0974e78f558eed4575aa7ac16527a789012b0ca2ae1c833d5852b9ad8c3b710bf8b4652c0058b29d0a9f9be42efb3f226ca8695012e76ff071ddba72354f92696c3ac67dcd7def2b5c8d0449418b36dff14abcb4914444ccfb367eb77e58d90e38e1b0f7fa1bd560411b39491fe0086defacde98da54b4298b9088b4a3febfe215f386a9548db43962b8b0b702c6942cf2f3ede1b95c139a9beb952ceef705d3263e3baf995f8774f94e767ea74e8fe7605ed137567b08dc7beda8956f5789db527b43f68f45e4636798d2e53b88a68e6d0c7ad8658077696fa0fa1990714815aaa2a55049d103fee7025134ab0f8d80bb5e6b71e9916a3686237d0adad0ce1814f7d2ff4ab289fc15dcd1032b5e7fd315dcc8d39d54e47f19664ce9ec2906d5491ddd31a08eb21379e737672e777c5625550888f9330349029a82407478554b89ff5b322a0adb9cb9150c814bf86e764b13b140795e28170a1c84cfc9d001ebf3e5adb11d357a5980a7f77ddb904760c1cd5ff86fdba2541eb6ba82756e1ca005a41d2ca59f15ba72ad85116b25c89a3c72f0b775cb0e84c2f5024a79ad3caa11088b56b0d8ac4dd39ddf33bad611417b34652153b9b19924fd44096db0c35f888a378e2d0c1f5f028ed1821b9238c2f2e9f9fa1280c09327ac7d7fa83ec43319c3965822d9944adc4ac270941313d50db6741faf6931f0cf053933501cf7097f9a693c8b64c99630cb78f79da0982a131bdabae5d0838eaad42d9658fc1ccea981e8e73e8993083f50301b25ad66de313b5515696ee5b90765b6de2302eb09817165dccae1f86a63759d6eb7bafb1553cd556da4fc879b6e6b3abaed6e28c6d9329c3012891cd0540b1d7652059faf196b0e0f7f8cc9455d5123c43939bbef03cfdb5e32e4ef223822b5c7cfaa715334f7eb0f47fd86e29ae2bf89b4f12c173f4be79b04914a4151413fb2d6cf23fbbac2ec8fc18fa094788989d43ffd2c850576df726b75c378e2ad80016f33f7cffee5092a7524fb05601c7ff2f4833d9cf346aba18390b312ad62fae489c6460082c12e1f64169e6e72939b64636d1bbc7effb274a06a6dbf8400486bb40e5dcb266946f82b2b39e764a383fdd9828270b1f4cc1690a3cc5cb3ba700e61c4d44e60f0c3264e6370d13ff0483d9164756a3606df7737c596a39b8b06964951bc2a5b98c7354ed279a06b934b6ffb51395d849868ecc8a28f17a450122c009b8719e1972ba34d96cd2a7874bfef0884a34e83c52057b064dfa68d7ecbca868986e5fea4d11e33d5cf993f1f5ce9d2e40789e4c59a0f49adb25df9c4e0a666fba30e819a2db7280d45683f7d6a64711336256584c4372880ef05a938b19e5eb62e292f1736af3632422cefd1b7c02675fa49ddc8ae1c597fad0e96263e945db566f03650801e026e864a47d8abc568a3cb91ed9b634a4f351c0043520d7e1014be900d43df904135e74d2e3cea41413c003d97755d294a9b5ca1e2e55ef1755b90b5d42411dea88cd4b820c121e7f9c99e49c71173b8dae2d9ae628ade291ab52012b73cac367bc49185ab4dc90cc03c596d6cd7e6a922b67c5ee7218bee04c6b611a2a942d8cf8ee6d687da6015281ee6cfd86c6fc9f4c8ac6ff6ea548e80d6bf5e4f6329e13bc6b13506f71f08a1790c131fe86ff5e7eaec0abd220fdb1bcebec681f7ec66fa11113518532b34f330b36f5e2019c71800d11e5b449c0b2d7f18eb36516fb2bc599f3820b86e10b8605aca0a1b788411c48f51dfe92ee82867d477d2d321cf0b3cf861bd27a675bc10262f3bb0ec4c7575e5ed11914dfc51056f85527f33118a071bc8ee1db6e8539f1f286eac34ffc6e7badba952487159125bf3bc3a7682192ed762f08c937cd171f1e8545868bfdd954464430c1c6bf6da78d778a0f1298f5f073c7907cd2884feabcbca89a96067d283260d1dfba76ab7bb3d007311011b94ca9a753561c16755e023fb3b6010b9d4995e700c94308b9d8a53348e297b341afb803fe9eed81753faf1fecb6f318d56a863a6a3e50bab7cdfc05d00ea921de09981c6b81010a7c8883df8fc3412e89954fda82f63d386aa71bce641753b86f0324b4f2edfb45374370ecb751ec5440921c4d7a337fa13a212b55ca96bc634d0fdc801419c96f3ad659a1743ca9775f80e84d5276aa86ab94ba5b195a52d3bcaf84da1dd59543dcf4453d1a7bfbc6260622642bbfcd9c689d88ced80619673f5780c51ccad668bf10b7c672a939a654ecd731b86e618c7d15bd1c075cf2aab8c4a7c73ce3641623a9a9b896ab3919f6d789b538a8dc9b0d59a78a4f855e50e623550ff994eb57c027aa20f06a5dc6eff9e48a6430e9d9ddb9c0b39a087ff056072408c2e9b4667a8667038f68f663031045a9f94e1d48acbcf0648451f57c718e68e80235b7ad5ba7f5328561d1eb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
