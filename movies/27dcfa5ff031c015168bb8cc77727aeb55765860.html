<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"32bbdd435adaa291c38216846679d7fd89ee81068f6ced74a25dd15285af0c3c7c1d97d9a2781bcd77df4d47150ffc093a739e6f9e4748b1b1d8ff73ed54b0e883e9582028131f9388b53bb5a190342112e045ce6360aa823d7b2acca1e6253678d8c3e6212022ac8cab4bdca5f94582670f8043485ef5ff3c60f59ebffbbc5cd700b8ab5f69c7d2b20dbfa79c2f1b89eb283edc6ca979259df4f2964fce42765effc9e42cd3eb64c1671bd257865b1f8f2c8c83f6c01d8dc3f973b876e0a81aaa96c1e312e5c97b13ce4ffd19e492505ef4c0c0516be8fe954ad74a7d35894fe35576409d854ac35e5db58fa116682703c9a3694202598c193740d56542fab86626b83f1e0b534b78f4d1a2e1619eb5598063dd12c07f94b295fe3c9db1a95f08fc79c85e2281cef1466155dff3d400247f83f0801f64d949207d55f9f1b61f795b605852909419cd1941725fe796add33614c3cbeaa24931947aaf8788d4904d409800e6f000d2ce148d36b6f8931b2c8db8ff987555aab76b8da3e64ff207a33007690fd0100f06a9d88fdb71e6d9922b176577b52cdfabd3cfa65cf2a57ef133a9c574656104c1f1dedd59a4ae2a0d279ac1cb969be38d62dbad23e5e1d8045d9ebeff4243aa9de0ed2b330a10d2d77d56b13603a8f1208d91b61a480f7052381af7963f93cb8176ebfe66178f0c4f8d31604a353e1e49b2173df8146a6df997f021b0cdf4fc5621f0637fa32b7524a3f97a6dc7b951f6dc283a7067f9b815dce7c2e1b8ce9228b4a5387887dd30744a7ff39e4e513d6947c9d34aca59393f2b066defcf9e33ee9ae2bcbd3adf471643ca538943470a117dc37ab3f9e73d2bcc13abf15c85c03ded419fbf48b8e889032195acda0d46312c228e628a3de3e6bd8d9ff5a63d690da5664db793740cf94c5b8a3e6529ce3ca8e23781608e6fa51745f4e8562f9ddfc4d87fc8bf6f9a6717c2f6c62a113d4f79adf83c8f499154843710cc9e5ba86319a0be559363d33c9f738d1eb7eb0607cb77ac1b906ba41a0b7782c3db38cf33feb5b1fc18829f729e25616c436f8a7bd27192dfbe0550303996cdb463914558d26d3dfc1e313ad327c8f718ba38013fceef4f68e445217bd0c93e59da6de554983c7e1839a7f2b8714da45132a57d92a7b9c073b47a2a5bd2c15c43f90fd6e5555efe2db7d922e1c449a24aec6fa0c894b1ada6058c52f03340baad3f26dee388985d482940c793cea34eae1bb3a52c4e4625084362e771ed163ca4d2c4d9aa4b57a38b07ced8cdc4095be9958d226e99c2b4741c5bd8e66326acfe7d5a044bbdfafb28a79c4371c9e7234316dbeb5b21acc40dddd1e58f36479721ac5fac248710c0bd4a75e838314e96a59cf736cd0b7cec40d1a2722edabec613c4e7e6e061da8a209ae76f71046ca9d3385b2501108ee90d17164be0556fb95e79ed85c0f8e16a0e07f7b32433a5b127aac1815eedbc88aca4a3ada946b9b99209f7495a1c294b50490ef7e035ef4204a4d2efdfd875f779fd578f49772b14d1b10b278aee6700f4b6a5c0ad14f85a37e42fb6eb6939c9c864acdb91cc4046394a40caca6096bbd771e8e494bcfdf080bc09124575abded63d68cac849ad9a03edb4b58b21c648b85c76a9411edc664a4e1251faa46e7836288bddf39540d9838b19e56f047ae05bcfbcbcf897e9cf5b478b57406d61e0bbf84e1dea21d8bfc301b731a24519bd9638397a0fbbee2b5eda509690401c074ad86df57a73a2c822bc344ce87a3788202567d02d53d9693a3481df1b6954019d0832a50ef2a8495f11f3e11bffe5e7c7e489ce1209cfd5c021dcd6cb9d7be0a035d603db11b1dab8788f360b6b06acf25b5d05080e4a7c69e046c39b06fed2e7221b0d289ad35d53fbd75ad30e3525dedd48d830c3efe6e3deba3fa91e8ef6e128cc49b84f759cdf5e3835141b9882d21285f96ca10e7aa15a09d90ba2f149aa8d45adb1e322a2cf42fb09b8c2b3c4dd5279ccfdbb3a28b3de93d489994ce1105c0711c6f7925e30b170ed804b8676961622505c045fa0a4c9b19d50fc2f6dd399fb79fe7f8893a029042b60e1d4f6d3b295050a45c2aa07986a907238c09bcba66062b9fcf0a2d4df26d822323673995f1c1ccb30e49aa8eb03a9c671d48129901920748b316140708c01e48ff899c7cd76bacd811fc9ae04dcc3bc6c1145e942db941eac0819165a42d6c1b54a4372c743c7b3472814baf3729ff5e737c2e712f4a63d9ee9c9687424e6bf215fc0a990a506813d192e696ac5458f7789f830e813f42087542ec53f5ca97d86de89b087e62553ad6d56f8616d6fcf1aed1485fda0e8f34baeac6725c1ac37278dc93b36acb33d73551accb02f5ffcef95b111054241c2df64625c9faa85494500f8de08e361fa92906c6e46f31d415ca5d041ea0ab4e72826282e6550253cadc6e02cc4f6136f7d76775758d8aafeaf7a375c85f0001588135dbac1448c4d28c281d9c5106353d6c007519813984a11ddd8a0538cabc915a89b5b670e5d7d6bb7579a06221e42ba061f70ff0f034e1305bfb1026f985aaa5971ad0d1d7c3d100ff7da8292eca06d452213df3032a92f31a03ebaf3f092c71b608ebcf0f6b07ec985d6499e522217c4996072c3ec940ee2e36154b36b4d22bb6ce636770ebf6b250593a9b7959fa2ab4507c4a6bcfa1afd87f6d3f37018f8a4e72eef6f645657d986a78fb949ccf5045fbfa569cc2862b3686025b0aaca0581c8cd7689bc6f907f52118cc3acb5b3dcccc8681b6f369ac69624e53b2cecf0e167cddd02a55e0db71ca25a5a08465cc0561640373f5ff844561a5736cc0b365e1e48848afb45c2e7d541aa462eba3265362b0688f3815438d2a39bbfc08195241391f38996478b927a24717f017b2d33914131b22de0b8c91d56c7c15bde960eed62436707456845cf562adee3eb1757b16e077fe0e7f6d809897d06fb80cdc8e458e10e7dade75d8120315ce4f3b12d74bc25af854719564b30174cacf63d66a0e48864c5be67cdd9a1047cbed386b6df67dfa5f3006ee43afff8556d64f36704236def29a8bc6e1e71df4ea02469bbf38378eea66ae776adb66859792641dba1dc2fe9bf799bebab960382bf954a785f01a159600d6def513dce855a3920d091f5988d081c6dc0afd09706aab8340ec07de15447e97114d5c6a1addf9b68dc3e50e375f06e4e3af0deee78290c18aa023d218687698ffb50ea4dbae0444049bfaacd969dc4b2280baf793f3df5e1f06a2686361c258bd2bf869cc1e5a2b912751344d7630cd8ce2471a8c0d4c6d61b72d4b99d6b14fa2c98f692f767c34d893d85db6fcfc27137d2a9d883714677d64e79dbbcc6cb9397e3dbd1a65b598a4cffca55c058d6e8ed8f69e4fc3e1d611b1734383012e862b6021626d7517de564d8976aecae7a3195314235deba66d9bba27e02dc71651561bf16361ea1d9ef79bf2722d2ede8bddaa8338d53b30b3c77ec4defe934a720cc14e30de986d30efe32821e3ce0888bb64013465db86c5c66284c6782b317c5059525af872be933a9499fd4ec81655e9cf2ab670030ede466140b5432959267ddda2497a0e2e16599efd6646182489d6399476a1d285c787ddd835c98ebe62b794207bda5b3b5960e28c59b5a57a5d61f191c487e2b524ccd5fd30f3f1ab055831dcfb03d2c32b51dfd60aa192034749262a18f323ce11d40a3922ccb378865a4bb70e8b6d83e456d01ca045016b16f796059f23f677ccb8194141d33784f260baa59bf338823f722722d14843cbcbc46c147fad515c08576afc9a0d41b89f2d92e38a2b37b6282b889a5bfa406ee4c571826ff4da3fb8ee99e927a69ed5e2dffffccaf6b5288be9780b3f80f591685806c07f6faf67cd6ba3fa2a65378f847a332901e677c26b7360d76143973c656601f4337365b72311cf4a5d8d2995cd3bdd674c033b2b76e2b8aa5ce6c62f2a7c2e6877d4aa0958f18755d5479af2ed1b4e2353bc005a19bc33bfcb1fcce63d4434e96a108c8e6c7647fa990e67dd5ae29554512f74f96c9bad249e55ec8d1735f4cea0c28828023b59a2c7cda516059041a6831796257be566a06391db477d288335fbbd74a2c6e536d14233e9f005715b1b85bf25ad319c9c7e500ac77d22b5cd31bfbfceb20f39f5169e34cec009c567e5d9a9e73da32f2ccc47babce635fe7a32523ebd288916042f2e541f848e56a591834ef414ba8458d547e456346d0539441366204554db23ba035b7783198df1c0bc011b6104774d33db647624449f5be84cfed220222de08ff6d7585fa2d79236063465e040f5b7bdcc8234ca7172b3d2a350d13a0d87e53c35a7f8bec16110908d8f7c68a341ceb967c3ce754affa31ecf7703f1d52a7857ec4997ef48f68290cf638e68606cd4a5f2167e226044761c4c6a61d7785b27f0d4548d6128f12d505a47cb4942f232a857c59d7333a165ada4fd5e8ff6b9bf358d30b4dcecd28b7e2515c1e2f1040e9d140aba7f2b491af73e1e57199353ea1e9e74fbb3bd5c637ef8c7fb4d3529faffd92f13c4b87ad1c9dffa1f249c55b0651b10e8346b5f03159e48f4d00845215e53f750ad4567ae799f3ece1c987c371171afde26eb937407eb471af0a439d8d80fe9ac8c0db241e2c44803db28dcbeaa96b813f4e109cc26ded87daf6e43a7c76dbe5e084ff6f5ab26caa840e1fcdc00fec79061221f2ca8e120385c620ff5e9585231e394cd274196f44b18fa76dcebe27d6bdc3f06b6c97098a35020f57f1963e37f236ad07bd86b360de469688e35e17ab92ef7a55f7a546f969338c53f13e72cc461eaa41351d2c3a525846084f220519f938ed4b06d8664c24c5a264fc7df5ab700bde003d60869a526b107322d77c0e40a449e63c2bb58193057fa5cda908fe1fb07af867ecff3c28ad6093a67d05f6bda5f077f53366de9f7ba09e052ce7d1398a3f31485d37cdc83aa3a2ecfb23a2dbcf3f971a783cfe54c3136ac04b87a351074f2733a52eb2db0a777c5e59215b6c34f9d5574427ea89982973daf69415e11a020f1046ebcd78a3d8c26d04264045cd12f6c6c85f28d5f1169c237116e3390c3f6df8f1bc93e4791a65271db689844cbaf19ce036253de9936e7978129dc00dc2963de052d5e4a3f0911eff4f02a301aa00f1309b8b58b4401ebce4f33bb8fa416a9bf0933228a7569a589b299a1e6a3412755be9cf75bf9a5170222f07b3a9954919cf51e46d1506d5c26f1f5a3ac4f9c5bdc0760cfbde413e31b83ac1143a9668d1283c4ee9b85785c5b0602496a8a4ffc7e2d373201a6bbc2b99843debd2b65ee3d31ac5e1330acc7f4d84bcf15dc71261c42662e68ddc8eebd025f17115444be57f7c8309b08bb8ef7154eabcb352220e2fa1887ab4fd5a91b1396083f24ea05f25ef08892a6563e9bc8159698a1f2bdd829bcd2431def5f5e20091568fd90231fbfee0d02a479237a37b34b4c685cb01f384e4db33d3b4f67c61067fbc8c4b1cf6897fe777bf94fd1b771b5c33eaa9a4fbae4b1b7f79bf158c11507a0cf3613b66a78bb8477970ff7fe5d6bb882e7dbef1cc8c468963d06ca73e8abb4b90ec904cc199ab5872879a2baef56f858067efc464269758812d73d5efa4ca2c186c293bb8f38edf8940b6d5e976e7bf0e282956d35f0cda936aa91fc32891a0c23e2acbef2a593c43706eac24569752df20c8dff9ec5c093ed1920198ecc3432ae0ecf1ea9c70fc10409c63b91937ca789a569eae348ef03023cfa0d8ffcce8663e77592f0c7174d056d84aba3e848ca2c84e3ec97a6685daa9aa0349889c0eede961485ca479ae2671d29c7d3daef3930ea9c234f03a5d16015bbf72b47f665ae7bdccadacb063a3bc440e30aeb0e4e8d5f38a0acacf15d52a7e5ac4f4d04cdbd297c3e2ef110514724c868386c7c46c50707433329dca938840c377b51bc809b622a67c56cb7d5e0e5ef17183eb21bf3492c5174f285a8c123637ad1afb1e6829f60c1f601ab04a44abd2bc59d21d20fbb9cc9a093ae004be04eb9106971d305142cf71fc1372ba986facca071d5f8ddbfabe430b0b1b5835fbc4527e9137a9e5375778ef1bca4ccafce9bf96a0279ad8e3fd56558df02e939159009d1e224d89de16449a98232c4e1b7b03214547e1cb59ef612ea11755b9a1d2a9bb9a49528727ef88b29cfc883fc4607521c2f07961609911d4013c55df1861140bb0c05b3cf7fbd3d12f9f3c3c3d2e473e93227a1f83d366d8639949f851b40585f07aead0641067c7a4bca7568dc499dc73bbc35708e1e5780db61f78e787f2d75493415b1f7871ccbe26a4db212f2e6b30ccef8cc30d753b8faaab670377d9c4971638f84834df82a7d321365bcf988f56a6a43bc3b2b27b81e43e31d76d629a1144e91d5dc306d9d0acec5669dd9d5c595a6ca7e2b070ef26b1a3f55c657708173fd80eba09717d2e11a6bd5871ed0c8292319dd38c91247bbb32d570cca0bff9f1017a833ceded4e0ca4b1b409641beace495209d4cfd168f64a02c1a9e7fbf35f2327bdd4bf94c8997bce3ca1695b000b866e629bacd99b685f70e1883d603548a89dc45a6c65b49dd53777f560728c7199b9422964aa27ad6048bba9fd668a317db70de60e9f1f311e977ffed2d496539f1fb04f08898ab06c88bc103aefefb434e3c426641c2f5a1831d19ec8408591e8f26869bcefcbd3214bcfde53da0f73784e2855a17e2131c3b1ee70f6e3b85c5ecc77b1426e6ad7d5561540f0f4c15a5738308b31a50bae25294b727645b3f0e92fa2ca805e8dc8b4ab01e2fdc14463d22eaa5eb0df0ca932c7af2a195687b38a05097229586cba35d28144ff388716f62ba705ed34abcc9f864f604a95e814c8c85a5011b820bbc4d664a360ecc9f1c391864beb7ff6800ba1970593a9a1b5d34af3dedfaf79ed0bfbfccd8d0b967d05cd3999e5125551e4500325688707483aabb9c85773de20ea8d51bedca1304d77096fc872b308adfc2f6fbf1a1bb6ee083f23ce2c560a97f3803f96be66b0e36847f2866feaa0682f31dbda532b6f41c9929f452540e31816e9e71fec913a200cb67e83b3e8396cf05148aef7578e62f1946d85e5f565ac7eb60d1e3ce2681ab72aff282395c604e981634532e9536105886e94aff33a2d2deb530cbd147a8884af7bbbb7ad29a120fce452f42865815e12b3ff121b0b9045e8ef82cd7dd7b2f76c84a90b279fdf8b6f1a2cc706513113981d4c13d5b96b0b1b17ca4429b80e74e42cdb329cab6536fcfa3173e32b8784a4aeaed36897f6354b7bfd902907098c56161593e3e6d0bd2c01a19cec2dd69af3b42f2c032f44d28248bde00b2ecc7fde74a446f2173d89bcab59ca83a45f8aa440d2fae6d3c4c1710a95e2ed99025461bc87923811da772c463e996c9e479b9e44260a545d46dd900d0e552de4dc8c3cda1bd577887c56610ecfa3ed942d04dcc034dbe3899a5af5f5be89df7b120eafb2c8ec42b298a8af75b2dacd4b756014a118f27c1c9794f41c89502ac2be9cff12eae86e8751d7b50af5513c6dedb6d49e7cdbf1bbe4dfaa813c6bee228c7ba529a25b9426acfcb68552a59953868e9138e19282fef87814c590e074862c5bf01192d35c9bb9fce341cf81e14ee35f0b9328e5196105a1e925ed175514f91f10dbbc9e681cedc5d9d8114aba9864af45ff2147d45a587e4f446e41f47bda612d1b6badbcc12910a162295d040cfb2966e6aea900a319e9beafadd16e711e304e5161dfeb033c473afc083a5c059ad18634943c80c1f3cc0da87c6140bbcdab1d9d618b14e2f788fc6bae343ee7c2f72f368a2293683477c686f55598e77bb68868779c1e86c73a24ec50c7bc4b76908d26838409e99f608eb2cb1b97e66d7f52788fb93e5a67b9fcf9d26028e02ffe19a595b2c21a31fbed8e8686015ce911fab9aeb9bda66ba0c1949db8e5dc4f00c393990a14a20f9fa16c4a7e193d97ac85a8d8151979040143a6c263e8f7c26cf9328d09b284f187ed67144bb1db7c48c606ef7fe42a36d8cd830068e0f7433271b999e5f92ca9d6a65d89479ad8be7decb98f97c4b301aaeea1e160c1620713c96a647076d85c5d179e0a88224e99dd02e9e045a426b9d94ac492ba81f1e0d2e2b4d19cfe77e6351898c7220ea100edcd62750229cb67b9c13f2ac0764c0e8454502b3e7752be52cfed8a6b46c48903a4a5b20346593cf8fff3c4edca50a705ddd007ce86646215d102f06d65d2eab849415034a37dfafb468d78d0d33eb27ff088cdb88774594e6db2e15f00a47f5cdfeae0a63d44af5401223a3acc01ed8f295424a9b484683cb9a850bd787e52f079f4b53e01809ce41119288ac30d8f187dd58c1b814f5ef6b9f03e30e8edea75e0977a2ec885313f5754c13bbf43f81ce8ac5b595d8d9103ec6d0325a5602daf3476f0bd5d8d61276430779a4816b3e8adf1751e98a79b35be56b2ef51ee40877722d419289b99fcc7b814d50508c7b516c47f13f872c571ce6488e4c72421b5b99faf05c7caf92f77f4c29948837556c644e559a5f0638d3aac3ea6577eca3cfd537c03fc265cbd1d66a50f2db90471800901138c832ced432a2056f48d17e35ae42a7b59b1fd3c6f320685c0ea6d668eef120f211b09c8271ed71470d59b0a8a1fd32d880312b4c1bd0c7325ac1842eda3c0aa14c673b25b4a1f780de39a26bbe1616aa96882c1594175a2c5a03e7c26d0dd6a5130222640f79d0ed06d36a21a75b4b82e24e9b867f2f362c2baad8dad191580a86542e49828d74e2352f8c9b60059e9b761569ae9b32b941e6013ab1aaa802410a289d4b540c0121422090f4089fe5cdeed8679a645decfcb5955b0c2423dc4ef18caf70f9ca521927fb72085bda38796cea3823a2e281b2bb8ccb8300d1d7f6f7c6a78615b6e8393231f75e50da4ee74017c3ed2bec2262e97d30a9697c37c279e47fa1771ebc65cd848ceda711fb2ec0dd95648a636a28bae619a049f9fa40f8b4e8b24a8c86c040f4262aeec3348b3d49abea41d683ef80fbbc4f1d348f27e8d9ef9768dbf0e6b34e39e981c07b0fc556df04a4ddb518e3587810ce2a3ea558d191c96edbb269c877e27366fafd2d03d10ef8432f4873772d6b08fbcabd8a73208ec5c1910804938af8778fa8cde4e6db283a9d71cb0588fc09d08c0f4826e0b0ffcda1bf6106d3f1ed4e329db9036a1310d5cc5d756a4af39b7f2c83253c6181c65beea0d50413e29ed4171ec33e419623901f5c016dd033b0ef3823f75fa215e8050e8fe854d5c0fccdd89e06d80eb08bf4b13f8aea5078db3214190fa2c047abc0535932e53828e83abdf862ce04f43121c79bf28c0bc296401f989d524fa1416584fa182278d81e5cd8f5e18ae7611277e8e04cf5f22458901aebcb758a5ffc28da83e106c54f2906394dff3321013c543af5802b5ec8f737aa1de0398988de7f5add39b990e7dd633d96512b3e6cb19967964e025cb2b735ed3c79b442eb64eb04d6705dc128df9e5134d73a2506666a4adc23f594137dd7c70c8d7010766903d5e21b2de16ded685dbbaa21460d8b2c97790c3e1d5dcec9092ae6ca93a95f1c694967e5ae8a2a89e1db0899c112e7c5977b1a0b5bcc947183a5ba323c79a1a8360e3275704d8c7e28178b9c79e7034265f3de7211775b9f01b99871b9eca10f94f6909276c23ac17b8e2ae5c94b992e64f2206b45bebeb3d890afa3fc11a682814150111deb79c7359af4d25912a684ce580c338d8aa64b703d601a924b81b3eaf53c139489f2a1ff870de555296ecc94f81566a117948576050ece12298f9e5fa11067a71bd856bf855a96066e8c8c8f83ca1bf179b4759ad3f508eba6f942038af98dffdae046786d55b2895a77048f402963d3d7c6b998dd680941d8a0968cedc3d86bbc8d551023b01469de6425659e8002f61988e03e853ab64b4c7b8cda889e75e49b6eb57bb51d10aa48f2e2f77179456c8eeb1ac57100a3e99131635ddc53c70fe6e0239458bd0b5ffe710e54aa0727ca80b7ca9a7a934177b5e4730cea22553098a5b2b547aefd2114a6df588423912424ae8ad5394de4df56ac8179657bfcce69924fea741f22aa05489dc5cae197b596b4a7b247f85b5cc32d742206e4ea1e2a28415e8e77ab81e1787999557431081e349fb57f025670d167f11c80dfc5fe29c82d1d69c2c6188b435b2ffded8a9319e1d8db7964e3d8f59decf34e86ff0c835da61f40aea4f67bb7487b25f8df3ba8b9f7f8657200a6b18aeec781b4cdaf1d8acebf33c5f921466fbf0e5f48f9c1da8d0a1caf770dbe07edd86360fa2c4edc5d766ac95cbdc7ba221245122c5af58e83267fc3042344f4d9c404e6e4983e1dbccec1b7c846275bb8278ce1061dfdf91c4b198858d0fd99a9bf9364723db78627f7aafebe6baffae7ea4635f03ed876f0fa567cb29e4f3b5bf63e73e2d694cef9ff7ea6cb61098e10832da5df90a07933fc177bbf26dd1a9731450f29333d68a26c65b3fc844708e5752602658c531069030207ceeed4366eb3198a22ed82c6557e45ce361e83f90373955a69c6c391ca62694530c78a377b7745251dd1b60051cc9f71ac69c75804715dca1502d4788a94ef950d101e79437568c2662a7264290bc3a11ef55069b8be0850a51cf452daaf0407d112cdbebec2c8a4a0b1aa495cd1834e8b091af9238fbe12079da9d8a9f1a11add85921d69478e97d8bcbe094e710e6e9803b7917bacff94e335ed0c356a742378feb75b6cd7400bfca7859e382db477d067a8e273b6f431a3c95c095500250e31708aef6d7cacb3191e725ba70b6b317d1f03e3342ff66a76bc93de243356bc99863823b4610c0194d21aec308795f8f06a0e427a02a12491c24a39b8eae323155dd7d8dd0fddcdf395981749466a44f3866c8257826f86a36f0a80e451a568847cba0073af78657688903cc857dd2ae2ff36283af42ca3449bf1c3205863b2216baf798474bf9f454d4746e6ff2c5605f93da8a02513d1c26a64cad5048be2c8b741e95680bbeb90edd62a21e5b89deb6d682ddf96cffe30bbc5060a82165351143d9b4ebdb567db9f2b555c5a3b2123ce2d304324ce0b3ab1a8333283035b4bff4302b9d80a79bb28ee8b1689c9ab4c869785b06f415516eb1669f5b5f135791bcc17e5cac92809bdb6d63e4f886aef75f6aef97654b55ceae0046420c4fc4b2a9aca3b88a24f22698890c2d9d1bb212e043b650737a719499797fc47a87f4a920a0f33dbdc13f36c123df8e53c5e593d890400ae7c71a08139c2c752be218fb1596160a2382d227220d8f49c8b117eca73d2365794dd3234267a4f5ededceb5f19599af0e8f3b7f359f57d7f3080e9e13eeb1bf70f480895be44897bb96b461e9cefced921520d686b83a9fc0cc41bb9d1c01f4263f0a5ddd255ac2d69a9b3c0c76f8c4e82687e5162f3e7645ebd71a6481fcaecb3bd0f99a28e63774769ca6430bc5484032606a33ffcaf6643158c70ec92f82cc215cb5b93c84462f3250a0047f4642d3ef0cc00a356399c359339a14192fbb42748ca5097fa5fa52e091138f9931132f80fe906944ebf87b8fb4afa4c22de916ac76de12d1599232b1ee386a9b8b671054fc579f955e41e2808c920047aa792833c60defc9ee38d47008145f93c0ed221a50aadf6e6e966974aa1608d82473d5f26450cba7bab09409526fc287915b7e7b4a681b28a2d1944384ea58c4c205d55af14f02c89a2d8b55c0d117b803cf7e53ccc45d8b62876887ebb6e9719daecbf72c18a57876a25cd96e5fac4ef7eff2ba291c42a68b93c474c2e059a75176dd1f292dae1ffe8648af3967933368e6b6544fb4efe275795107b4e1fab25704fc6f3c48b6cb0105829c841b551f9158c531734c719bd387e74e35788a12b914dcae9ebaa26d58f0b4add227a0dcee299fdb8214464ec4c11f6243b0234a97c888b345663d3baf9002a8b7c083a3240e73f2c72aa3c70dc501008341b8c651714e19a6c5939bd1f7349919dac3f8e1c55d1a1a107311a501716ddc3f3ce173f208544fb5eb6b74dc79992eaa03514dec9a42d1e56cd13aef83d84a70f8fa6e0ce5f389f798e3caac7c223342e1a4f5a99d48a40ec8710a2a465f8095453507e1e030195b506a9feefc8af6a61142912397429f6a5da76ac7d337b9f2cda8a2e33438861ffc2281fa100ddbfe9daeee625c6674d12718f8649f0c4ed9bcd2d20bb2dcbdde5470dac3ca483a171eba8b15b99d307423955acea08906a7f41fadd51bddfad402429a48a3d0f7ed0cc3a1e8cbf73632d67ae0e84164cb5f41324f8eb898d22fa2c12dfcb915d8177c9721f7e2aca4475f31dd21296d3b03ba9846c3c4396fe5b77af7289332344ed20a4d0fdf4ed12c56f0af68e7c3a3bf27ef90fb8f59438ccd94e250737ac60b2c31e814442ae58c7495325f805fe0a0037ba91cca38dfd7002234bf0f6c7f4a1f71cbc2d8778de24afd8080af79ce71e2621407a211ef6382b4087515d0a237a3948b3e81539ec139e9a28147dfaf158738a6cc171ad857bb65bff8e4887fbc9bcf11656955de7df72ed8a523307653faccc7d6c6b1514b2d84ec608ca4125f49a8bee4ad15d655ef0651fb9eefc267ef57cb5639f10ace1f4866a584106ca74c9b7d66c0020968c3d164edfdd6e59d55a3fd47dd8fe3b9c2f08632a496c3c60af02e7a1e765f12c39473d23a8effa9a38cd8700cabc751d0e5fd6d54716559f9021acfd9f59e3593b277ced0cf93d4cea632cf42dde8d16b71cf61bc1a6badeebd732b511926b0f6757b97bdde03a9426ff881ad55b60a6fa7e93eea18d2e9b790816909f63856d25948d0ab2d2190add3c056c59c662e0ff65d614dd92d7e73d8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
