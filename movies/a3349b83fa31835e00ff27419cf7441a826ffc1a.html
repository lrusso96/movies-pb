<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cc1f53954b2b9c05765b860ba49f9c31ce671f5e48f69da7f90c449f6169a8aedf66f3152981704d962344db9464d157c2c1272c1ffa02e6812e15d7ed1859ac54a7d4a253afb2304d0ecd53ec0d78bb90ae5c81e50774ce1c7e53fca6760b7c6d934727595b33530715eddf367a7e03f2841c4093b87e38b0c2df0148c2c6f4b3496f5ac649e659d7b935d4499a432ec96990b9cce638cb557a48747b6cb1d988bccd44b1e33b953349ee873a6a91cbc18dee3ea2910ccfa05befae0eb5f08658cb0e4eda6b07b90ffc4c9b9cc8a1f34769bf61e4a9243fb8c2e9eafbcf78f1c21d811827907e43d8d512b97e43d33eba94e6125c5e8ecc0eff6479224a67001d42f486d5cf30df0193bdcd8a220de0de4778e2de77a62dbddabce10d6eb1b716e421b41956d0815094b7e26816cf88a953ff1ac0605ab8eab5217c5a3e675fc89a59bb24ac8814bf6b76a9f7744a506894d952e81ff194d6b7faebfc28cd5e5cd7b5f98516cf0b2fe2e81c7dc3c4df637296dde5f87cc35340f541c2e2fd6c9e251262db83e90294e6ee06ea8315ed0925868776ec4381074b49a4c210d84bb6b96d0bdc3acfdecb67e1572c38c8d91284e2935f4e48e586d708c6905458823f572218c935860cbd59c0332dba1ede3610fe4552c77ce8269890d1e386bf3a1d81dca8b79880a37892dc7895f9119e5d0df22052cd5d63787bfac4c7fd4758f04919944f654fe3265f015f2e6c098d524c4ad76a867c57d85c82973f87b5d0ed285a17f059ea293dcfbc5b69e8c5e04d498020a4f2e017107ac7d40bb674d0a9adc4cc637a0823ea7682b5061a6d63fc6652044531a9147842a27c8b824101e0586eaf99f040793def307b481162647719c3265fe224d0d42a1cd8c3c18c98eb16d2ecbf551bed6b22615b68df950406e20f21186ad625227de73a81722bfcc41e47af47e8e77552c3c253f4e065f5234ec01e184cd612fe8561ab3525270ce6cd45affd08a2459cd6e81416e94468b4820790f56cca166ba166647b0bed3f31eab53b82a97ac31fce744f5b9f0f18551c634cb1571168ee9fa9a9e9d9710d298a2245cdcc8aa3556d9f4560ff6243fd93f778b9ed5eb4f683b142fd5fbe7d5be27308798894fbce243c69e2dbd6cd7d9841d493fee2dbf4a4d5a69947c273427d249906ca3934cd98550465bdd68d56c712751fbd1ff5b240b74aa248d474f5c61ccdbf3db4bd444b0017e312c9d6cd8642cdb0b9fb6ddacb52fe47f10cac110ea0b35a0a6634b33fc2daf37bfc4fb066d79aa0713be1dd25806a8ffc14e48fef1efcbfde7e64967e1a39a6ec2a2b3d01a65952b4965bfa5d5be4362e1cf3de21b45268cb2efc85298de086b2fe3bb20fe34d9db669dcf342a951399351717bbf8592298e4e053e90b358fe8c50634b2968f0c5652db0a4980ad0fa86b1c6bfed2076f89de49456979d35c1c701b6ce84389654f64dab71d2a4be011ba144ec339ad53b507806e8c5f9d61556bca5288df2a0fb36b2c20d839afb30fd252e573b7c5c90731c0017195a3df57c94f59cb4434c1d953461bfb2b5843df7f254d51fe5997675620c645996b7016900980576af8320fccf8275b68646ec43b0c06cdf587aae275719d192272933566b359b5a3be955ddb37c6592afcad191f04d68e82419251bdecc53bdad4c2110cead6aef2b29bd8c5a2fa99eebd957d60ca718fcb0a96b33661373f119b373f0c91b39ae92953f9d8843fc5bd5ec5af1ea93cb2dacae423d47d691e5239248592d377cfad282014ebdf15e9e1fd0b699f1f68784d7f9f845ba19dc38766c1a9622b21ffb04456a49ca803e16330d229442723e750dc2daac393f35cf65496c15a64c639f166196542ac06d8b1877988cf7a03eb70db818c416e204c1f9d807a75501f243702c98cbfe4097b733e6b68529b466b7a59511f7a38741d4c78b6efc3eb309398eb9e614ad3816fe9424674c2e303f3548667530b3a479535c2a0a3699b742e43d696d9db5561047b7b3f3b702516f172a18c27de12b3a561e3d75f4214696e25b688d40ece8efd4b9cf5681a2b3310c7a26168b55cd70b6788c56a79c0c3c622ffe37a6b4b3df791cae4df1ffaaf1569351902891458a366a053fd3826933a9f85d944eaa9b3d9cf4cc54aa7e0c0410d1a03d21252cea30e8e9d62428c3caa5c0f89c057faa9c1fdab56b4bc8f2292f18bb4d31e1d5e9adc5032ef5fcbeddcf39108ce3327824d045daedb77b8747d3b043a9a931d19eb0c9f9bfd8e26ddbfb304889bb8fc8d9b533436dffa49e002d9e0b0c872537942ef637229a6ce7933a858a7403821b735808eeb8c90c71f14f87d01beb5cde6e65505bdbbbdc89b7bcf82ec9b47bd6f61ae9f63016254787c75dcb85ea41196ac7ccef6e885c09ec39568fe96a9baa29e04cc64202b80f265599b7f40b088f676fbe2b9e270fcae26b5a5ec76e827bb3a7eb17946f8cd556fa4c9980acb327af18dd1c50c4e406b36a4fcd4aa04e572d36257ea41d6638e95f69c8e94b1bfeacf0e6e294c845e8dc437c04cfddf943c54c4ff5efe156b632b9759eb446da06e584437bf34d6bdeb6f251a4f41a5667e21c8f8cc26d77e2a63da2c1ffc333610727db2bd2000a4677570d4721ed56db64bd46c281dbd4930371c45dea9b2d1167a00f38436efc1945d7e2ed1884e4b04af91889bc465f5a65f034b9ba101e018fa49d965f08b14ba26cdc5d8d969e60b841282e42f65b6de504b9ba1a11b1b18faa51a9258b2398c81dbb9ac963ddfbbac3096f1b38f1fea4a2048d0ff3b3d48e420bc21353478279e44465f8be9c0f61a4b5c926e23af06d4bf4d688a835ab677088fc58665d84932b5c0b80fcfee03d89d708fc6a052fcdd58e5b371a2493a6c4b8e480e5e6a663a6101c74d69e9061a822e39b80af20aaa3431ad3403e4f0fba202bc63f5093e41f39d29e0f5f7c045053b4f5a7a42a2a88b87abbef3e652f746c78efeda18182d6252dc326ea0382688252c1613e4945f23eb9730dcfa0deafe457c161b89e7096272d0b8b6a3ab3bf65021188bc98aee88196fdc1fa7aff96cf7a09459d3b88acf85460da57f3345419bcc1ca21fde9a3bc4f45c548befbc331219592b03ac19edc299c55f353a64693cabde40c50d5f937a36a944fb629f4052af72a51751136794937797373b7615b72db1416b9720b2002af2239e079835d9e5ad581b143f078dd9ec83320e0179485529d30566c863093204ed73ca368d0451731b74c4ee3021a62461e150464b4a3a2966936fd89d0491cde86ada8f35d9db71a9c43d48527625e4f76799fa5c27f975448e20c0991074ee793f0a81f6ce6de47f004caddbf780d96fdc0a7c5cbef93584f504842ed82cf7207598d51c9fe3cf35136fb76834f4cddeb418d545e28620cca317112923771f974922a344dac117f9d4015cf019d0a7b2751ee5b6ad2d566a2dcaa8785f5946dc29f675d9560e16edac42f11d09d93e3cad8881eb44d4a4d1f17446510cd32306ed14bc5980d07a52cb1b5dff025d92923cd1291f187c88347a7f325727fd00737ec89cc624a28b01066e4b6fdb8993dd6e6a23a37b5a1536dc4a10d114f4559df72051904218a168e6b00470485c89e399c84275ea330450260494375f29270ba4011036b11355087a1e3bbe98f13732b6cfb9254d2a941fcb039170f792b64c8aa1f6d331563e6390bd3ab79efd40157006cc036c56b96f839fa47544cac37f5c00f7a34c609ad77cf23d03b02790b7929887ddc97b2438350a0956b0fd7eebb3bc415d9dd2788e92c65adde82712bd66ed945be103486623ef35f60d35da5c8735a939ccb8fafb3f9378a3d3a2a41c883ed51be5866c87dcf7fea6fba715372b531531d55a7d6b57b8148f74ba015f6145a73a2e9c056d82612a096073359e2a946ae9f169f9ef30ea34d28d0fb40e696dd7483ef20fb53f9f7e46f0bff717cf38c4f133116a2cd8fa7e7c667ed1706f1b2425685a69cdd4928859be40c1c02fa2508038b4889ab8656dc1deff22f9c6ae381a844037b9839b9cba784a11832b9c4531f214682146de9f84931545bcc14d1a18bd2f23cb6e0333f40845eb8261a5009d1331fe6e62a04a121b715ea5d8d661003196ab8ef652743a0dcc7bdc5a7bea60b3ad17c820aa7c686495a0cc1a11366ed29fd06ea844fefb47139f5d9e6a79082b6ab05b888dc80093c48e5a187b86f3b22890d68fcc9732f330870cce099055ff14c84cd2b824bab674563064bea0d873efa3d820657ee6505cc0668e8f34cc2ffd5ab30f7ffb0d6d6cb73faf879df80d85aec04cc38bfae12b4264114112ef83f497ab8955a529e94db694e80e93f2b860617fbf602463a655a6af466f39ff48643b8b9adf23273b71c1285af056c490ff10fff818cd53bbb8130bf48dccce13272f9c2948c3a0a825f7cfff7f3eb94e150d351eeebac0154b7b54a22e68892389196ce03cc44b9d16911cafe98423bbbf458b95241b360cac48d60a36df088fcf6d5daf518bb05ec68f84942072284b6483d064a9343c460d4590963f59619757908d83119d7e82d13ec61794b8934286f5d8cc15436dc90932dec0e7bd47baca5fa8346b1dff398e5f94abec714ffdbb6f80b6efbef822f7f345eb76737765f86e67b2557bd6e074d78f2f62ad2f4301c26c4d9a2d96030ba6233e1d98dfe7a4d725f3e31103b3cf43644be15c318df145066d4ef91985ba7779784aef0455945430bb10d9145dfcfcb6e9e2c098b505dadae4b72576ab3d08c90c80f2a1ee61ba774e5ed6aac1966780d31da7397be6d165d967216cc8bafea86be671a9aa3213249160e5a60f4f84ee66a68c0f5d705816150c5e6c9feeee2ca0b02fe03cc59ff0ba0819a5254bebaa9f20c62bfa257d892f2f5a340ea9fde149141d136faeca7557d63907e5f0a3c1ecbfd2f5e79066bff0f521a7eb60bdd3978e6e5baca435ca16ff3f2380ad58b9d456ee666155103249ed43d81303b2727125e1e2856ed0eff22d9b13c5e3cc849ccbad65933405f7abae94197fe1b066581c696be3bcb8ba2263f0107cb22a5396449bb44be4b684682ecd0830b80c689b35e021ffc89f9d89d1a976defc1fbe0bc3a0f8e2f57feacbae1469e2221665b7049903ba98ef2a8f05cba91ebe71c96bfd8d15fce60b6b66f7877d6875fd276c37bc2152bede467e6776fa50fb32c88993d53a84bd6ce0085ec7dd9892752ada5c761f4df2295fb6cea974f4880a22cbdf0ccd87b4bfbc963f87ccdff55569964dc12654640ca82bdf7a7cf8f98d51c64ffd2ac12788eb8480ce69b1fa5c7282e822513509a6087c4e2a30a9e6fb520fd03634802641a45f4e36c95ed748b19a6214096d8dda66438acb88d77a6905dc2fb6d7d60d49636181eda2b809714cc410e36d168ba5ce06c717bebf3b2d513eba24619a27a68d7e6060d99e5b6654c638e740f45c84ead49c99844a9a3b01c4cdf847e51aab850000febadfae1c5a91d749338160d6433b84ea469f808831e3d9551f347adf44827ec75bb4d5ecc07440f61d2f629f330093e273eb3c464f9b2f4f4ab99da2b532a13023d79b7f3189cd1e772eff9feb21d287931bed23ca06ba303c5c2e5edfbc06f95c907d3d17f2d4250fa2bce91777c10d591be78db90aa139197f4989c4d93ce9359441e2924fa9f4a8864898f47270892dca22f10e8c2e85a6df7ed98974f7ca97c15a94cfa1ad19423c88a8b8c45a8e7b192d6231da384f597ba3d600812167a623ea5fceb7bd0be11f4819879db447ab169d666ac316ab8d0d7256398893605fdae98f7579bde0fcaa35f404eb0cfbe082807a7d50e15ad911d370f519ffa728757690d8162d46a2086fd6858c4ad482eb7c09358c056c9cf625d7f6a2771ca400f01126124a3cc0f643d61cf4d2fbf508e8e6073f69354ec0c4741b140f39198940b4a7415b9cfeff7c27240bd661db6267b982f201c74de601fb48c376d95f6b5f55dfff11836b3585c4f2425478b8802585173ba6eba89e2296ee0ec573b43d851548ee3d3fd1942183b83d2516e47969c8b19f78251b67a465c3850a3f48123482ad14b7b0cec2b80a6985e749ba7f03ec5a04feaccf3a556582cfa8363da42d0e7af39bd12bb4a76f0c43a614b0217de32161bbf003ca02c017017159133c7f04e22ce29af5b4a38aadd70e60eac6cae9b502c3d093af6911566e8948b8191ea6502da6b3a83f2c0b6f485b87e25272ea8e1e61534015d9b7d53639a313a952a6a7fced74e43add5d0894e48262d4fdd63500ddef68decf456b5a1ff42dab20d47afb81de2c104ad1a1dc6acda3430405a6dc2c284f156212c6918b390bebdd1cd98973602f8bff1ea92f0bf4b54bb85bc069ffff6c598286e91011cba2dae25ec8904bcbea0df6220a012335cfb4ef741bf939573bef902ea101ea189c5b1422ee2de83652e01e205be4966cc8eaac1d5c4a8d55cd9260a9b39ece575d16e685ef38ff489aedfc3921b74a15064178b1df805d2cd4b9c4d043a9724cd0e69d8ebf98ae6a943f195b759d1be21530a45a79f565d4fee11f95475f6f2037d0aa009838efd9052046f719fdc01ef163ed3118378ed3b3ae370aea99d54933c34a97568487d8356b6defcdea13e59a6ccbff071908128b72b10262f8b778c7d31e4f7062b25c8d1d87baf9466bd5a3f660a4ca3cf9f0c52178df66af9e0b2f2ddb3ec563a0e77a30dc82f1c3c6551a41f2577d4ff7f1b32efd621ae202e8ca52c35e81133f271635cd257247672784c5a72ac224658d7021188803a829093be26a4ed427dff60ae05918d19c9f3758686c576b1fd3dd3e29335dc89610773a2dba9cc2c02724151b19c262e48d7ada71f3fd34d6e62460c402c3ea5b71ffdae1dd2d2927ade8daaa06e09c076999808be97f254dbde8d3996227afff366ca1ff0551432b5e28ea15a49e4cbb868ec240fb56e0fe710ebf50b5c51ffd5beb9a3660d84680c28d4df09b7c4fcb35af9f38e5f673cd7e6db0b03a5dc0d92a125246bdd461c401ce1b0b852794699bbee4b7db75db7123e570bbc7c3567df424d1bd55b4b5583320a894481556ec2099bb0830fdd049eca2096a79791da9f43c539565e61372a7f949f416932f025080c44dfd5143996a93cfb9156f63ff4a52402549d0691cdfaf31d6eca520a46576fccd3efad4c87dfc78f2d0f367a65b3c1908432bfa403ddfb8f282d3587f1c28c36981df0c8f696cddb4d5e9df22948157bc1cef863a905330cf489fbce1dd69a8be64404756e4024303f93adf682b22b95400518acc19b6acf58d7bc6b569a119036cc83fc10b7df3cedae0abea5843e1591b04b8045cac57a46a068671d0c6921133120af2088c51532e3a9381ee8733a8229d1109fcfcdab62f4d14a1fc48bbbaa629ed0332d597b5424862c21622b6cbd430d64de45eabd5106a1a7f1240126b9c9c4e1ff53542423c9d02f4e4ba7b1d8a073f87337d908fefc9508aaab76d819bd9bae9949c52dc65a833459b1dac50a2a4f866cbd803db0c004a69173c94edd492ac21343a20fb444c955c6dcfa7ddf04d0851f8fb62d084adc85455467bcabec59b4169aeb5730f9c0dc7384b2908517090a898398c4e936575e389889ab4b6cd5774c405ee6272180eef684b315fa79419e0578419171444b1483dad0acc425c0c421d49fc7b8089d72cd1d20c812f8e8440d3ccefc57327efc96a545afb88dba0f2bfe94dadfc2be8a9f59b4466fb637f8b785e31b9a783b9ab777119b8e8e72654f2420122b32b697cdbd5945f0b4782831ea2d0d3278be90a5f3d40f146982066b4e20d9ea26f14091b75c9401fb099bcab011c910037567c2ae3fbb2cdba951d61a7ccea00aad33d5d50f5ea53862373180658323f33da1090360df88d3e945249bf999f290a0dc8f1a255c8280ae146c295c7153e1b45c0fc2bce9855720b1243127b381992d911f239def4d7b362705f6e01427476eeaf139a1294a5efcf6d2ba3ba3993ebfca5b799369319bde9ad8cdd770ca22f01b31f9b637c86e5b8c6aef56283800aefb38feb6568dd6b18ad0c96094fde515c22778261f4d8ac2061920a051b14cd6ee85ea5c5dd09df6d99063bb088d5e62c2d0527cec3955f69ce8670f924d80989957b6dc5dcc9f46d91e7f2750beffab398d746cef929f384f2a7f30a438c1016a03b39397c708e3a2c07cda7ab84c81c3f0c31aa6067f53c4b061dc194839538353ebd2d76170c0a542d1ed6f4ee8a75da5ce8320992035097147df8ea6757ffaa0d342dea4620cc3d49d78249b99c277681f1872586695ce2ca19cad7ecf70379aef5fd907851962963975431ac1e63a22c88574b4a5276f4d263a297665e5fbf0a82f7955d1b11adaaa0034c705452b34219972b46652a3a1979cf6b810e4842d1e60fdb4ee0e7657023e6b904e627c760770494e665dffe6af7f7a831a8bac8f75ff9a5a0f5245383caaa1f20783b67f85e7415066e1f108aa5cc399837f698d7728f17fadc78d34380d6892eb377476976cf665647e58be498c5baf0c5aca81960a7bb0486cb5781e806fa700fdb4267d499f6c0bb45e0def9b99dc5a8304f3ad486b245378b9b57ded301da0c0c0d38a13ef78df0a41c870d3ea50389b9d184a031e4387c4a0724e8080125314ef2fa41d35f68f5e063054fc654addf705701032edea300b706898fff327730e2a653ac3511e16aea31a3b2f8e34d0e2aa8253187854238cfb8c0b5e2185312a175a119ad743f51a98701146ef12670f39bb255e2ce9c291eee177a64c484a250ec593db90cec03ffa65e901a43d1d1f57525fd71a4703bad32d7b7536d71e4482859b4d354b9a0106f0ae5a06eec52a61f047b6a890f9a4538c03d16d92d455f488253bae99b5448598b19e7d4315b187ebdda89a943fb02c6f345b8c950c02144560f1d43c6297533058639575904cc49ade705ddd31ccc0eec71c3228db51ad8a9a51e58ad0c67155aeb3ee22105c1686b34514f95317933a280c8a3ceb8aea8020c10ee2fa282ea1c62a4d7da0f98bd036ab95db9bf0037b2835d5bacc91ea6e2428f03e4331d0e7e42f63c8d1011eeda0f4916c438e33ddc4a4519f55c2cefd820c7dbc37b1a1ac50eb9d5c9b402156d7b89e79c1e0c725a140251de2c000e47d45416f01ab9d190acb0d6eee7adcadc26a1543815badbe50420e035c483d680e9883b99a1e63b6829b3f6e5db3d5d2cf25e80e7a78d6aaa7c7c9bb9b5a01ebea81b9ea8586d1b5c7b14566d13ff5811a2d21473885808476f5ca90e9d624a4269a0a7db453eb8c498763f8d80bd9037f34d2a70ca58e0157a524a229ffb9f0852831bef26025edc6f0ba4c1b1b822d30fef13a3c1f52ab6dd9423db66f90b640929a23c82e0449c43431ce711d77f5788b99a18955214071bd7beb321c17f1e0a2c2f3c6010715ef2af18379734c807c0f3ed5ace7672f3a2264f093cc5193a34a8c9b0748ff8b846cb0f89e6b1d70af6a3e465533d41d2fd3348326eec1493f8a3ecff8973c660f2a307d69696941b6de4e481ad24f6d6ba5a56295ccadb864790e10edd32a712fc34dfebffb4d21c2d5ec700a8ab03d5d317754a1d0bf4234456ef366288610d10377cd6901345a1e56e3d940f1713fc989e390fd50521a01649cea91ba0069f348cbfb50672f7675f6cea61289ce06127e85c26416cd8b7e7e6cb42f4b16dfa998ea4bc104c6665d42f7bbef7e816994deab39c3f918137a4a001f5855760e25bc9ba935d92b278004127b8b4bd1d1a5a4943de91b59d110648892fea76729ab64c57a40944a80b7e160a5ee480878832a183f052c7041f7fc92e8f118a3f01b53869d950fb9768805fa48c678b74022438a62e1629e99d367551e18eb62e09bd680ddb063e5230ba668d22bf5ada54ef19183fae5e3e3fa5b34a8fe98515feac1bf021d1c952438497b8c3c077648cbeaa494c5174242df3a05c0625157e59ef0aff3c0ed283f49e62968e99cfaf48674ca4827807694e2fcb447e2950691b49724e04805d239d568e89b300f4e5695febc854cf7e0c8d0da1232fb8a7706bad8176859c2a53931ed953ddc33b7323f43891973d02067a211119a32bd9cd49bc1a9991f26fa4197ce5f58c49013a8ef3bbe9be029c2df0eb00ff2893d85df53625f24dbdc54ef6a8279b69f43b06690b34dd71b24a3e58e0413b9a2a4beb160f891c6e00f46431784b95b61d026680f85dc83b03bf6bf3f573615c8ac8fcb5bb3b051c4a72da7e8c0fa38cf4fc0d15de0c50ce95b785a6048bc6dd0fd8bdce3f4370e4e443ca79a9702ca82598a740eee36f4b3b917d9ad70b33d79ce0d516da8382065805fc7a02ab3d551a4cc6de64648061910facac14c5ca491586d99b4a61db75756fca3b039604da0325cd066630e7d26a3e682236b413717f6ebfade1554e8483b3e01a970ec984893575c9842b9798674c49ce1e515af1064ee115f322454b8832cd773c601d6a850e8e9c96e818c9f2c84084ff3064020483eb7de9499ee61674452be030d3adcdee822fabb8c75be84cf22666ab897a64fd588f02a7d4f722cbfc9cce0d137551a27e7c2cea7c968c54e67c6d76130be7008a397e2af0d3237c89658e1b5ae3a650f2e379a7003a8c4962bba7eefecf3eb6ced403ed8b879de8e31e7b980724b8b02095c6bd232e489f831a824b7ecd473954af656bb8a43d34e9fe0aaeca6734c035d8fb7a4e5e99fab41aea86aa58b78b88190836f3691b27ad42dedbed690a0f73e46c1965ac879c8b8efaa17fa438544726db4c167308a2bf25474e37abcdf09e575ed27aa480bb943a762cfa9cff228f8a461ec9fb3fa8c7603c2a42d26291561c2847f45fa629b105da5ecd1657799e819e4630033bdd82b4c6e4ddc8a4f5fdb032e535a4217f0e2b236b372c398f093acb6e984f5ecb37af946cf3b63d388bd09a44937072dd96d1801f7f436193463228584186880a4ebb1a7413603ae3fda1c10c9384202fa71bcc82e9cbb097b41f6b445b147b40d47f9b44b88b9158bc2feb719d6c4897b70016d1a5c1d85533543b018cc1fb02b5cf00769300750d13bffcb866573fc66ea6f933d77c316b297eb8ea17bf5c2f50a402124c13e9e5abe831207e96051ffe963b5e904e4d55e17f655a572de17e23985c9c0a618e5cc5956c3b5ab07a7812f08fc5012927590d1a1468fcd94566a32210a6b7fbbd884540dd0d590a4bb7d51fd5c23febede131092541ec3ab965c4a2061b7231f4bc1fca5f6a590b1905b9f64895fd38b60e5ec2742d5b9dcd44ec6e0f9e2da3e827bfed980544b9ab74900cee768dea4587c749c16dfd16985f84d4bde8819094f4803e9d9c15c3b3dc20ff52a0cea0a03e899d775250198be5edce8b43374128326df67f64799adbdc5ab67e6419211d1efa51ebf11624a427662d30d28c9335d0112045f92f89732709101f2827b689ebb78af26a2123fcf5c41db992db1fef48036a28ac69d9570fba9e4766f5b16a97ecbb72a1a9998696fa5badd9b47647aa5d1f573f0a53afa021979d13fa80979cb4f89f2ee5646cf3a6448bc6c0d3fe0c68f1376018dad4326b430eb7a212ca59ccd501b04830c96cd99c090c0589969fe1ec9afe83d7d3f70dffa89f9d85a31e65f2ad01c53ff45c083ca8f4b1c3da5cf5749c5db2812548884cec205b0ff31ddd42ec971e02c685520ab66ccc80227ae62794e9a117551004a52500c78c91eb53936e01ac164f66810d07755be823d3b02193a8c5760a071607a175404b01c6ca6a5e23487acbcfdb1b9640ac640f4d7d20431054d89ddeb14cf8b6c864d42f3cfb7d74753f8095af59ade66ebd7ccdc6873c3b4b8fe17bec11f9a771cd1cd6ff645c23dd3f6a9d4b014e10b330f0c3e85f09de732f280e67510d5e50e1478847b7e8f002a237fc977551158321aff477998fe8f17dbb71081badb0f89f68b13bd184f8f9d377c737ac08e07d6c16d3e7f58bc4c8f77e4414e1c8bb3671f2dd758cc93fa6cbe2b24286714b0a530b3a9193cff04e556030f6f4b2aaa1879482ad1ff8c4d2774bc6d874038c10b3c9ee8b46415a30a2cb7e9b16bda96a582c6faeb237d4e7cfb72e7e3f714c9d4473be4f9b594991eacdbf23d8fdc90d95c2d3209bf9392974a7ee1e38662e48cb6f1a4ec5abb6e12e7ae7367478a5c702e89797947f859afc7cdf293b43c3b4fa4a410a2f0116f1031b660280f0bb57d58f001cd9fad4dc92db7e830d80f205bff7c371f4184ef4f063dccb966e74e1191141ebbc432a5a01f787a0a7582ccfce5145b3378196c9477b373de59ec7b8fc3b43ac9bc43433e10b27cd7afbe8cd434c363125f2b7261bd12115b7b55a5d27de44b6acb76ea338770bdb6b4602457f1a11ce696d3811eaea2f205bf98115040cf342ec4ce9d15ac90aff2164b7d7c5598a517b2d01bd2edb78e97008b6a964db2f730cf1f579505125aec413697a8eefbd9b8964a6841c0c503fe6cfa2d4cd0697706c2db5dcd03ea6f824f2d88db1f0c7d93b7e58763d6ad961b3e58c3a2a9660ed1d95b9c7de48a042bce5e16c413691c38ffaa90d7bed782b4b874306e9a5ed709bd667740a40051882c48c302d04ae57eb378f86ca2687ef5423e4e6b7a27ddcbf44c523ac64786b26343731d99829f7dcfcb1952df8c7b9b40c851e84996464bdd811f830238867253930d29a3e6f5f4b6b7432255ca1408b2153f4dc659ea0d009a2e052038db60e3b98672963474e5091f53ad20412ad147c88f238668cb33f294101e2555513bc82bc1d753b3b46cbac031ee48636dee218719a965ec48a84042bd99bcceaea484739a4967b7956adc999a8cb0f7c286a5d386fb9faa4c7a8f58de92a5600f82","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
