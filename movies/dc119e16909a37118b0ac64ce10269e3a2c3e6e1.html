<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b308369f1b4c3d8e04628a90545fefd0a981c1c4f1077214ec3defebb3d24354b9a89b4c7120c0830a77468b438dd6a1e3c74a0e65dd4b88a3799f04e9245d9659c09ea449593f9a2d5e57007e568763cc995a337c42b93d63ca30cec97806285b7133c22ba86ad29514246d185e2a76d183e21aafc94484adb0871b9c029bbdf963180f530e55ec0451abc3c8b4e4110d684542d99d90bfd77bb513e62b15479c7356c29a7b8a08b6042769feae2fdd3e195456a21095d06a5fc671f11ba18d0e751cdb3488c3fb1d3cc31640dacd5013d07f3ce97eceffd6bbc4eb09a4d1b384106ceb5299fa20217fdd0f300d49747c4f2a53bf5774a349d74989c6b26eb7b5d8519a7a46ddea1bf56ecb1ddb6124f17febf7a83ef6fa16df216ed1d11bc052ef48352532fe0395c2f79019b5f17a5a099885586047bf569e30ec60e48d2f7081bb142d83a8bcf79a05ada450d7b367680031499d84c0032090d58a15be496d718a84f87009ad1747b190c6d9d1b024219454a2a3b227b091a7c974f7ae4c11e863c77fb8dd4da296b5ad71637af02db6ecce299fbf89d5195e9941a529cda3327328e4db3834162d74396a994d143933e6133dc294debc943d81cc1ce37dfccf1a03e0b12cccc3b8fdd04197c53513d1f63195714bab197b5f6378812e66dbbebad22283aa8193f306d7cb329b272e26acdda87b5014a18645efb23c2e8b48d7985c07e7061c85c3e0e4bbbb8a3e0798beaa47f8191c56b1848ddf2e746e0993d25970f7ebc30f24723b870bebd6a01e7c07e8dd389c093a90f4781f2cdcc92f6212608c92b1a33ddd7d79ee63f6834548a5a5f9ad14bd47cb67e98879f404bf1611482979425cd67652cb45be6f9fbe759879ef37b161dd9696c4a889d303b0ca7edca3f373264a9fcd310d0113b9f31409f55db8f15efd3c11765acfdb3df244ad9b7af72eef15b5b0243200235cab494987d14e522e7e9e789609b071aa7cb1e0bd0f7133565b0ed3cb5c8fa029864806f3ecd7d51ff794aee3b606eb1501c01a79578621e598da7953c55269d3780b13156532e30f13d686edb4db5c0edeef167c2ef8612ec89211b8be535076f41d8432cc426238dd46060fec85948dae6f8e58e01a369af1fa8fc69d3fb45ba1477d78011874a82f0ea1d5e842671693cd803d454b369a9dddc9c5d8cebc9981c69839906fc589e59905015189d04029c103921f939e8851fe8d825fb331954cf182497169ef49f52fbc983fe776ae517f058fe6e91367e96f70293762b5d77c6b7364b55a600cf22d2ba140a6139daf46e82c1903d19d34912f9cbce73e497b32f04be6cbe927f4a00332f4920344fb31941536f63e08010e7d0abcf7b2ce8514c33db93f0dc936781b0eeafdcd19a3829f4c50cb12dab36e8987e9c5ee895ebe282726bbe732e0bf5f7cb3ae0cd317c8d38f079d46543810fc64b2fbf6b6850bcf445205a7368b4f3341d4e88d17c20eb94f36cacbd2b8ef9566cbf7a886ac3d9dbb3b787caff0f309d51c0536b6e383c6b7ae7f3c9f4292e774336e6d1c76cc76736156335ad88bc61df05ff6d2e08c6b59bad78cf3d567144ef7706e49c6c7d924b95fc32423ab17fa3aae8a69a9ef73b676290c87201e1479cc7ad96d29da739a8bda91d980028050c80e5313ba8d8c02d69af347b04765226b6175aaa841141e631a5206bb12cddf9503c5c39745d0b84d19a63d767505c8fdd1d40bb297d9e9ce9056273d20e8f95ba0d9cc86cae06ff451969431cc05ea73128e964d044d37257df380642e352d4e43bb5c1672ff3a8c389835e6526c2815299dfacf012addb4f54ec9639dae462ea8b90f30185f5c382ebd75f515c7a9b642905cbe25d169cb2739ad3decbbca95316c20e1539fb97c82baee02102169c2f94034208c8530eb6b86bb9a680dfa17d85cab0e4188045cb7457dd66cbad03fa2668f1a26d066d9d500f7256c189fbede63550fb7e05992fb0b227e40c3ffa5721f89c637ccdb1ad0e7945cb701dfaf9cbeebef80920b7d8cc3cce99b91c85e4257cefc3f63dccc0ea58cc3108a1fe54d8bfa83748cb671b9c8d877514dd46e3684ad9144b5986cc748e186cbff359c03b6f1b94fec7f5e2427349b1fe4d6bbe690d71843ca830b3bad0aecc1b81f8f63f1b56b4dc0066120c6d41dbbb1a3e5260a2b4cd19a26272ac87f08b0c9a0c77b09b8d785ae753f1b2570eda4c77734f634f38837ea5c0ebee22eb3d70d3c0f055f64adeb8bab7213230aa03b715aa35e0eee4f60a5d6b5f4ba1daa1039d670aaf551cf67851776a4242c65d158198e324e969ac97d1c3ed779a1063d1ad329f6e8e0c5666acb2b919be86ef609c2f46d015302492ea341331ac97e7421d675848a118483de809a5e2e8df178fce07fd0ac9eb9330e60d56090e6d8249da4e95b37576290ff16426403547f5418d0a99beae87564a9d064dbe4e7ef4b250e5287539f4e75bd0891afcde11e4ef76be44d3387a75622b1b35c5662154241a8cf5956567e550e9883347b43e5d68c70ef4f1a9340c8d411668d43482204254f5007e3e94753b1167ba03b151f190d4ee56c309f1170454df33929b0d46806a5306c15cc2e07187ca58284e6d147fb847d23a2cc40bf75524419e5d415d23d6ae42ac12c71cd8ddfa7383a3737513b75ce72fb925c0e315cd45aa28939908d6e3bcfb1633fe0fb4af2a47898a8ccf2144eaa16180639426f5270bdb5c22054d5233ec0580804b48c480dc8e64f712507291bf27fdc7fdc416d282edc14071aa6f5dca2c0e405fb1ae8dfef145e594dd9decdb899470203eb09540e3e31faa91b5b30d6b7c4e64ed7c682b7835be58295e08c0e81d718c632e968d1988758eeda3540ff7a58ab8fc1bb1fb285bad4bc70e4d3bdf7c4ffffb000e16eec754d6870e2efd4cd1ae17f14664a8ee536558655dabb500bdb7f6d6f2a86788b7f9144bd5e6d6b003c46d1032e1de922046f96d68766f690d98112035b23f59c71b276ae889ee405c757450384b6456ea58a7e8254dd8abe3cf2a3d6dffdac33b88f580a0b9c9503cce106dd7a3b1d4b52a5846043ba13dc30dc307eadac8fd3871410619f3ec39288a75131c852796f20e2fb4dc423d5e9c6347786a68014d974f69597436accd05e10cecd456d6cf94b4e2faf90bef39cd0f76e4dbfa1b80faf13bdb058811ffea975a3ace79170929361f2b8b7dc0beb47392c9e4c99fb4e972f7b622a415b6c8a42403847b6a8e9e10ac0922aaa40912bc0a876d300058378b86ccfc373410f2209a8e4f83c86330bed77cc97cf9e80e6738a73718684f0d9511e857b16fb80be450c3f930feee8c334e897ad940a87f9cee846e474cbad311b26210de2b22d4a068ed3f8355578c74b4000560db3955960e3360e729166c3c620e8c082986aad1c9c2838dff42b27c88883ac553e8e6f917d4ce59fe6aa9cdc95a092d3a99e774dc7ea38854e3880254d18497bf96ae29c2822609a1f824972609fb44b99b8a61e5e6d705bedf06d4b260321c0959d7bd42838c2e4a0cdce2c08385dfffb103f2f2f08602a036d13cadfd6da85175dd0428448f0ada10e5e33acee0483c4041a7c447fb439321d9c25490398c9b27ed27276dc4d57db1f20d44f4f01a8efbe4a432a982c33d46a21dfa9170e4447caead0cd6a3c7eddbf8b7e0dc1a5751589a81ccbb6f09b8b4b88b576a79677f02f3c467c9eb604d4364e12bd16cfd468363d59a1449222079aac8bfb989849c4a76033eca0dded0121a9f69fb05ea6b86ab54e635b8724b85bd4afddcf8b9cc903b445b830b592d8af708132e8ba5b431fc2b4c39c474525376a0f730ec355bc542c45b8843aa903a300c642016589d04138f3961506025d316c9058474eeb683e054b8802f746bd9b237911fd49b987c697408121a63a3815d7f29b8a9206ff57091bc1f4ddc6cfea6f7d16e9c9d9bb98cba3eebc491ca50066722079ed3aaaf0ab8f14fb099728d81e8d3c117422c1e2b515b71c3b41b8e8d5f7e12b85697c97c23be5233a79813942bd2fd76754d783cb25fa083a7fa142d7224c59f6bf084ee6ca51a531fbc4d0e86996dae56dd0504f11723a1db0dd64674e32557a4bb0fa9a11f972ebaa8a20a166f95f91d6eac15dba9b524d94e8481168714a8e6cffd3c508095f440e395ff426cec81b2cb373f504fd7d60042b15cb4336ae9ce5cf2e3b245ad589d49b3bb9b0cac3a04a8d08e0efcd10d6e2e7068e77e009c0cab825fd1408ddf6a2d3c5b444581c4f846ae2d710deb2880d16a5fd505dc57a4fa0d34616b48b99f802ed636c44145e4d7de93866ba99dbd789697ca2dcff4e6824207abb6e802e3028549a4a6336fe78da8bf24659f3416241c16352fd05e61f69f25422584f9cd3a5806446ec921a4f4ae817b6d8036dd399a771b733de188b06f1fc32eebb38997dabd9b2af54912891865f23138e004a7995c0bc980f920452cc26af13ec347fb42d38695f0b6733418dffff72d26020ed8c51814c45bc34bd04eaf87fdee1408208723d9c0237cd492a04ec398a13a2f8419e2b915d65a74f5f080e0beba0cc5cc4b920059e22ebce6236504e267737e48cb2b1c2781c71dcee68b2b0b0e99dad82a1cace61fff2733b0f268cbb8ba869926295b0b7252c560bf8fd746cc7b02c63d1ea497017e47d259fc3741dbbf878b9faabddc2b47e0d92b8111fe6563f582fe95ddc56d8bc53677a029396a6b42eea038c763a049970554dc613459687a9b55bfb6a7ba5c214dc39f7df25c0a179de3d1f521ecff8cd10a709ca6d32c7cffe5250c06712659a12eeb640bbe9fd1f8da83d5221a25cedec32f1e5136b2cd8aadc6f8013d5eae2ef9f5e420370e80995bada3339a61e6c5ccc6f1c71a64c677edabd251005b71c81c2735e57477cdc2d396313eae373cf696539fc4fbb08244903a993bee391f2b126ec8d93146ebb5eae422e04ff5603a2bb67685407910aa0a08826893e3cd49ff2410fb2b12bee802c957c00240fbdb8c31f2e976b929324e98aef1893e8f93251d2e12ccbf031767dad25e6ac8d26035746767d91534716a49633fee59f6a89615074d917a7349e13caa7b761a8072201fce203761a469c957c2dc0186ff6bc9c5627fde3ba49d35efa08f546398173d5078a6667f82ab52e9b9f2e75d946780a1b29dd8a9609b54ef26c014b42fa6f79cfd068b8a2dc12880b4841be733a233718dfd76aefd694d39bd4b223890a51448b16098cc2c856e9a91ade9f2afcd7a885fef7cb87a55653d9771e8ff8a5cd4c750a9d58db6e3322e1e32ef11a888111c86251e3823b67151d5067cd9a0626c46416078b0c179eced85e16603b4d819bb2475dfd6a4c4326b927eb20a3e80f20b190221158a75ec11e9b21ce21534a8a828ac7511803f9376b29055d559c10113e362e2291e58fd715290ba27d6ede55131808f308770c73171ae1cc8e6994824cc91250304df7d5a37cbd69ff57bae7802cad2807b1670f38dde733e632640220a22dfbf1f9a6d870c35ef0a156d49f0e9a3d9238ee692c5a1be86f3816844461856157699be6bf8ab090e83c50cf78f9f686c492012408e93359941787f9e21b02be1aeaf171a6ec44ccbf505b7594991f439030efbde403abed92ffd773c697c2a37dbc177a80016873ca568dd81dc67d5de294e4404360fc95f214a9923c2cbf4935b69d3b2efe7653c75d6609e15285977ff5dbb0bab499f971f06a65defd8f6bd6f5aa284ff4ded3fd9cf77c9db42cda6065f6f4ad6d6f69f7a47e3de9fc991a98f12f068086f1ef5a9f97d561ce7ec827bee9a561003f6d3c7d84582a2b0af6ae9fa53f0c16e4269085f9ae609a094051389d927cc5e7667ff51ac1a6c32e54b3172fe597ffa21df979e95e71a021b01ba81352a6dc78e73d3e95af02a710affed78569b8ea3a0625ba1f8f39f70dcc1ba95d32cdd5c9137c1b0b0aaf41d59ca4437b0f8b025826918205b97d2e638324b00da58de44f72db47fed6100e707588b61759d93f4bee99a0af3593c0d5eee352bd9db66e8c23b7fb96016829d109308a3d533bae988b68efb83a61e53e458bc5c34574b2f202bd18effa8a5cc2046b34deb10acc1d2721ab40b803096d067e09219edc69872c0cee1585097ab7ac87d15409ca8ae65b277e11799dddb58cefd9031dc8ed73398e17ff0cf83f2db2bb73c2306f33d4ebb0aecfe911316b351959a0cddc80cb90fcfb52212fa607fc5ca0ce371c4158b7e989fbd92c9f8be7d9d1b63c083a743f8213ad7324efae70c45765b99d5852bef0497dc0da405a62d110bed033283b077bda494d4f173f1c7fa568bed211a8d0ff9a94019a882989808b7f95390ab97313900b58df91f2e71463004c63b073ea918b8f85cdc883aa1f3e26cabe316fbbbbe0b5eeaf6450bb37e1e0754a2570b788e67e4a1e68ec32548161cc87e0774affc7fdf2fef99b8aa2cefc3c1a1e204c331b22313be1ca3b8463c42a382601abb89406bd234597de643b1aac6d7c73a7d5422b72343af3e4378f64d467d78b03bd51c9483b8fa1a16acc8032230bd520d379b9d4f31c8223bc5cf420330468dab4605bc8ec7b6b09cf560659aac30f193e64eb4d04023db432597e1cc027ca9cd7170a87dedcba6a0d5db662bfe69ffc52b9feed397673e4013c10e310f7948057c55a1ab85b7988c7dcb95246a585b32846951723462c4e8f881d607adaf12bf5e925a45a915fbcbc550fab9bf5f6954d803ec9a1bf8b94903963cbbc0322a39ce9880785d5d5e10601e9b326d8050dc44e90d9d595c675bdd5b90dfbc41364a852c7658c54152bc55048f50576dce48afddbb7e15ae8c8811694fa0291a5adcb96e548c2a43b9f47a1253daa2e8359d7f401adc9517051b472311b3b1bba6e2a6ae66ae5aefc44bd5cf8d8c6beb9c2e2f43a708bc5cd1000684bddf684c3bd27b8dc05a354a988c74756acab7c35711d473b032ee3c9fc8ffbc95e7ab437a7e3d0fa110e3c7236439d811503b67bc5eb0c1959c9060f3f64df5faf1e8dcff49b768fe91ff1818ea7f976f9494d9538582aa661c4f41fbd9d9a891109091a14535c82355714eabd72d9a45b02e833059bf147c847e7c7cea50713ad43f543ca1bf4dfabc4637f67fe6e761bccd1ac4d65d62ce995b94a545c5f4dc6c7948a3aa1a38d5aeef53e9ef77de3cbbbe13aa13b8733ee76516b3f5ffbd00b9f9c22e16933b866e1cd55c19528c2551e2baea57e14c552eefe03ed9122ca703efeaab8ee024680d73c1cdd1a671b470750aff5ff12f12f628ecbe8f46573044f9fea47f2c87da3de5a02983bb0cc08d83e345cc802de442399c166b80a497a8cddcd74b99989cd8bf2d19f9b8a8bb6a88e43f75c7cddb1d5e5b37b45e47fd0decfd89c7c43bfe631d80008280da0307ba0aa27224ff9d65cc2ef8394af56914a815fcc58c40e42ec79f04e253d75e2ee36744aff5274f0b4c5c70a084d81f590f3553fa6f653b3b68764c98b26f04b82f8934ecbf8d078eb2cf3c4caf39b75515bf89c1fc748a1a9d015a2cc61edaef01a1d91c8ddffd04f184c3b0a7e99abbd36ec381c2e812757774d9abd4195d55bd7410c23389f6c287832c900b906518101d2d57a7de39054a1ab6953addb774cb63f2d7b1c9b45f34822c476a94b7b96cd0833149a670fe04012dbcc2aa38d001b84a82e0c6525d6ca24832f8dbf1cc9fc9d79c01a73595a9746e0c7338e6647806bab684943e1847c0f062c0755fa2975f6c90c11e0462059235b1da43faa4631d68bf343e3efbbcb005099a0b24465c7e6f61c46702b5327b2533414901487c25bc89617173483bfc5abe01f82993b06b69fdaac20fc70bafb7e90a3024bb9d29900d491a368702c0a70bd5100e49205c5d24b3f9ffd1dcdf228a5a5e0f180d241d9679c933eaee3d029612fa1188b05e3d4dd3e880beff5f7780fd21f225dd568fb9996813e31d632743ac449133a1710f95ea0c835184cc690d2ea5f1e5f91e3ff81c79888626144a01e5e1e44761d0cb983070f2bdbd35fb7db4ea17fb7b42b3845f32d7cc3a484904421d65b72c971a1ef1f7b735650a957914dbdafd037ff096496b8e3dba28edf3105b6fc8a654b0f64d0baf5abb02463a4839c7fe019a4155c463f9161ce9acb40af42740cc335266b2b7cad4b5b49c6cbca8bda5ce7bc8da92d1638bf2b1aeb8502ba1cc3ceccaa6e7531bb171f38ee109298434b8525afac2f95c350c1f2e9bd5c22b7f16530aa2307d9da7ec63848a61520a91638628d0a3c1c154bb9c4c1c0331c40331d52c68f9b953e2073f67b9f1ae4f9d4dd978aa7999f24c26bdabfd7e8d496e0c9eec04ec8559ba72612f953ac49acf07e7ef85c161676ce3f9fdb9194c07ea6ae9a6ee44f40dc8fd1526c2b2ca7af06765d56fa9d5ba6c1bb14ceae4591f0b73b22d1af28bc5cf45aacff6a67ec06f72dbd85a6c9677f3ba2e050c53dc61d160b718e44797fa7cf432a21d3d825675cd5f028d339505e7a009e80205b88ad34af8a92ea69ac98f213b22c9c440eff4c18446c7453eae37b2fe93f698d7319ab6aec35acd7e00c00628ba1cc57b78eedd37bae1ea6ce872a3885a759bd029143653febe222ae6d6c0e937a6cb1290c49cbdb692537c3a3e5eedd45c63d70b5ecbf4630a521bf5d356d3e9d1afcde7c158bf7052b2df60d53c22b870d2f06a09d867ccd1bf8e063c513148c84b2c7be8e00ccee4ab5413546a50ec25936d7ee32896d78c02310295ae6b1b061401c3dbf8031b0fcf6d87437d5c083d6745842c1c6f146b0e7cda7e9fe81d430cbb9bff122615ebe2433d257a7e260e5bb7bead3970060b85a2c1012e2923d1d0a7ee179de2511187f6c0631c7c1ae4e192b192aef8340f01ff6a62448dee762cf3e3ba5aa667ae599ee279915c453d33e64670b6f6785131bf71aede160ff780fcd81612c4860667d5b2ac06168cbcd73f84f0bd14fe3eb861cc63d61525ac013e6299ef776777964129b49e66e219029d39f2cd5596d75988631a61fe7196e406e1a83d3a4522cde8fcab2ae4770dd90f8fff76dc71d176dce0e321637a87fec43ba17788d9574bc09f824db63a7cf2779d8c6c229de6e8f4cf5f619284a7507847d33804a61b5147a31a0e31a04eeead84b93fc689397f9b01f3b963831939f365d88af2d7b1967e53f98ceeb770b49e8dccc17f2d3bcd3067b7116fd4315ab70d60e369a2a824532c490ef91b3219583da878c8152ccf352597fe628ddd93878ab3cf88702d663d8bc3416a33246c44e3bba2ea661d86adf12757602b49c36e5c15eeb90ae00702764093dd4efe9645c1b3d9c2b4012316b2a4f31566007d08ef9dfa07d710f7a9d38721c0c35af088751aec2aacb96aa65139bafef15bec3b524a329e45048bcf29b9f56572f29390fc716d94baebe20c27eb4ccc72549e6cf79ab3b51ab21535387a7f3f36ef734149e7ab2dd3ec12d85d7e3b33b979052277e3ffa5489e60b461d12c58c6d3b496e4a49a028f71c3545408d01f8e0d95f0fb503b41ab892e75c1706b14fbbf417214c75a4f2b0410b477a0cdbaa3d3909bca99d30c2429fbd399209485726b251aae8b9de742d88dacae37d1cf1ec2eff276dc02e74d3ba5cb28a12022f2db0a2cc9268918086116f8b0a4ec8f5dd8cbbcb06fe7cf62db9117770dea28c7138c9f6fda5e5001175689905ec45d74627d1b9c2e430113da65d9d4f8176388fb5536fb3b73fd6b0d130d521b52585665bbb55402069b863a2c40211bfb35595fdc352e7891e2cf5246a9298a35532ae5512dad4a329301c4f6152044416f8f02ebf156a543187d7f24aa48fadcd8ea5116ccb2ced93f0c3faf8366ba8f368c3f16c01d643589b5bc88d400ab8dfad31f21dd08dc8f0ddf881e70a5fd3667181a27e6a61759c669434a87d1737b0f0fab88a674ad151d35570f94af3c4acc6848728a2d40c0ebdce74cf464ca194cb4e8f177ebd2b8f38611db997b6f2b614dbe116ec77234d65d245139f03a8e3637075cdc50344f07bddc3ee7cb20c1abaad18b87fe99ce13b0d5443e55a9efe35d3ca2112fef9f0d9db3110ac4a756af1fb51808f10d9298b6fb4987c9600d7f875dae5911f24620fd205e9f36d5ae906accb0e5fbfb4112811b8953e267cc23b7425b56b1c4c716b7283026c1b4867befef4cef91f328305b8f481313e5dae9b93cc7b7526773995a5a680b7a0fc10e75b7ac2a627a42a842b00a7159fee51927a52257bf4a4b13b287b3fb04f8400e778b90df299794d0d9f2f331bac6de643c351c9355cc0dd538e113b3b0cb3001999574dddcac3fe11b0fdd9490181bdcdcffac9769dbe58d9f9dcca031679bd3d55aee9806f98fe7edc769a90882dda1b79885b8b9736f8a15b18026c58696b4a9243e425de45caf1636bc11e4594e90384d4144f62eacb7995a93919ed7bb90b0afa19c59be72b41aaf4d40b39a2fe00ea2aff6d73f10fa449d533471a6abca40ea94774d7bf8e9230473eb68ae65877616de16b8c92de27d152f98ff502455c5503c0812c9bedbe74fb47edba8b1d76745fd03c89d73751428b6daf70b6c332438ccad3c7515e10ade269a99433d2401e7c68fe8d5b219b63820066e335e45b8fa618c12d280704b763ec9d6fa338f88144f4ede62e1bae7bc6559a141115fffed7046c29613940bcdf241d50499dda84f051555b7e659996ea1c849aecb3e742a3e83356ae55d91e1251512f1990d0b6916efe2d07ccbd57c349190aef6dad6faa83cb324ad1540e755273dbf52d12cdfbb1223eede49838307ca33bafc22b60c03672b5c35833c2e677c55731e6def9e119abc63fde71b37ce1667b9a1a39aa8cec5823560df532cb1a230c26a49311392f1076110b0042cd2c2773bc47e07617b824c6651a9f08a58bfeeccffbb8dde66a1df2b2c32e10b99ebcf2a065fb53165ac7f8b6d07343a0a8e2062778e449d2028dde22424d9b6aae4d8cbc2cf0c36df0529fba8e0a85d8b6d440720e05e8c95a970d3afe682cb1d4f7bcf99133e1c69f2acda0e7c483e0c92d2fa05a57e034c76a41efac92ed9d5430919578c669043918f41b77852344e17e89e724ce00dfb678b01b326dbda94f921d64714382e24544a5e0a24012b32c80f3a42302a7d5cbe352790c6e811c31e77aa6338012b4fd50cffac8789ec3f34d67f8e7126a6f2dc7eb6709d1e3b89f58404b79dcb195bf7e8c8223321619655e15c4229fb0986e5a104074ad8358ab63611f0c7ead2c04dd1606be3c1c7b9add1c768f5858035946891ee47e777d3bc756624a4fc969af4e9ddea51b71db83bbdf4513217bfc4f920f084e82999c6d9f009a031ca9d3cdbeeb01ce3e5918255e3a735fbd31a96db565e6107739f9283e8e451a6c2a0fd2022377661aa8e31dc3469258a9adf6b2abcffc9d105f4e806e97c7cfd3f45f39fc363ca3eac0b473d90f8237c629daa19fa9bc262e5084287504e751c56893c4183a45b5929c4fdfa48107bfb64b9befca8f355e1f5193552922843567092d76860fbfb543491e520e6e8de337768e0b815001553eaf807fd462f214cfc2a50d0051f1a75f1487e1ebe39ba6334d55e940c8763ef74f4237040e6250517387103f2c32a648b53516add8e642f8bad6c4ae1f9961632719ab181a65506182cfc3d28276ea3d5d39219c12e20b2a39fba680d5c7dc33b82bd5a6afb7557b14efb878def06385ceae4eb78130b9db01236ee20c2141b910c259b1cd23909f16c35f3ff0ba299432e2842f671394dd8fa0e7ccc3fa219bc7627d12637add75ee0c3cf5d7378e3c5e0e638c1a6367198f66cac80a8aef4d38e98b098c431caba109879c2ab61f90781cc8ff56ada5f0281954c49f69a86b2e0d2ca02fc4aae7e16e858f1c0b1dda498fc96efe0506f51cdd513fac114c222f95941705ffc9e723d461984655471b4cc4c78f8a72dae29beaf0c1bd492f6cd2882114a7289faba1957128819a4f8669aebffad3c1d6a592e37ce21b0074b4f2c4efe40303ac19061665c00106b2c910ace2fb4fd179b317b78bac06be88b9e97461f402368a3c89cca7b16ba154e4fb808847c1bf585cea53882bec9e1811f9ca3740e98d156521415cdc51490a419d83cce7e42265d9662fe88bf777b62397fe1612ee9bc7b34877cbbd9dbff1d29fb193858a798465af19a7a65f89a0ebb532beb155f026fd2a41b7c17f0586c0a315c4eafe1814da2b0725d39f49eaa26df2136e5eef5b1b9d9d92e0fb5d67a4aa13cac71788b3ab0941d0787ab834ce0c6e56c86980ce954fbedc20d2dca5b296f6f81a1cbfb7509d33048c61645e475bceaef33c4545615ea8e19aa83b255bc5cc45a7deb2405811cff8ef9e173d0edad6ee75541587508a89453ab1a558a72bac99acff8d443eb5bafba84038b91f17147f41dd2b3c550392c62f95165e7430838ca10def64aa0d8cea84c8cfd1346eacb811372602593edaf7cef8428445f566d9d6e5df9d12fa1627261b450a7f127fd65eaef4bcf7988e6c49ddea0d1974968f2091d6f0eb5bbbd28362422158fe7627813c9e71a64f396358afefe7ec7fd56564264447fbc38355c0a4c47665532aeb56ff682521f508cf1596938ee52b927dad161adb385c5557e51efae2b431faa333b75edb804bbcf19387a17bb06d9b892b8d9da648e238e307d1e99813eb0c5bc7244382b73783509bcdf1ce134f3762eb7e17916bd0ae244f0558c81a0e65acb7060038462681ff2bc92d31f1092bbf10ca5bb9d9d9133af24987f6641eb1a8c97f0753e4a854a93140d338dab7462df9aa9e2d77fe1703e86c60bb0e9b665b84f8a25c48e95318a2c0900d9684e87696693eaa0ba91299c50ac511950f4128c4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
