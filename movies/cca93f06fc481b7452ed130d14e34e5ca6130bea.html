<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"54fa63126c8b76b86a894aeb29ab38e82db9279f8022df064f21655000e758cf2e659a85f11ae5c8d743667c1cde35d89cf8a51d489949b07b69267041156e24accb249e3030eef1d73513ae10a5d020b8712d662e3293fa27bee77db0f2177034e164213af88d1871e1375c8cac8a4566d7057903443025bceaf7656d79b1e68700a7115995503a47fe368d8bf119c9739b5aa744de8b2a53f7631a48ab7c3ac3ba29444954a6a53fdb033ba1ba8b9012cd12f84bbf748f1648771ee0f1602cfc78a981cfd4396d43283f1ba5ab6524b27e088661d98e732e0a1cb3d74b037d6869d1d18ad62bc22766aa347440e8809a342af3e08485945d2452cf6b0171e6deb55001c823629d0ce90133275a0e8778aadf256ab0d853c5348caba3f023d528bb3cb3abc3b88fbfcea2e511f541fad1df4e9f43ec8b35827601d7493ff4ca9b2092bc3a84bf576551a07d74812211fa23a58589f1ac86a4b79776e33e1ef16073869e2bdbf5a944f0174c7d1958d6adc1d125483a6ec935687b48384f455f01f4a9228f8cbcdab6e7409fd8e5c24142052521c103d75988d4da49f73b51dc67d0eb3fab9d02ff0754b5ff67b17d06e4174cdbded1ed52bde2fe3a3b926fc050c4dd0231f1dbb2b94be43b7affa47eabb2caee0fee2b51cad684786a132a84d8518c8a62f17413cec6eecb0e55fe6ae86c178e5c2a7cbc83a8c7c4004de10602f95a10755432aa4bb1541973f085d8f02d1fbef09f13f1c688bd71e2d7c964057a1e6b559f605c898d318bee69ab7ecabe526868d4bfabc089ce94ecf12f88d0738b74012bfe35b6288c2a10352f5ff89563ff9d1988d9fe6c31e4945253b7e09ad9f76f34c89a5e957e410d2c8b4fe46164b4707c388eee16cfacb1938a5fccdf530a927cf5ca3de2255c2b68a8e65e605a84ad99934c5735916a1f6f99c8743a4f48fa21f1e5fbd7f4f0c49d628c34c55a21201ba2deab7800e4fa6333b3264ab3e5e1452a50207abce645d198423e75d3f9f0135ff06374c459771199af7e347a27c395a2cd4035b35b2ddad764f83897398deb3edae06f3ca4a0cc29d194a6d9b9e52b04ab18c598da7396f8a0376ebfa0faf9be3603abd7e38a423cc8f0b2eae239f7f0fe548a632485ee52540b80dd93f38ceb7da8a9a8a9e24874f80d3cd0e80078e79defb794ada57c65a71680970820098e0d72e4463cd000e06179d98805bf92824f7779a08d1e26f61abb06d27ab4474a3084a0f32138b89935013a37c39ba4552a0c0b5e9dcbac3bdc804e42df1f30ff30860fe8393cbbcea58a0ec3bcce3a594e35f724ca2aaa1485539abcc4769ea942e3cb780f44fecabaf83008f600e40804ef0bb9bff12d858c56356e2c4dceda10b114d0abb6af89264ea5c62f60ad92d0a22d7a50381362a1850277dbc4828aa40d2cecb9287cdc6b6eb42c875cec5ab4c1897b2127755bb51c72c56f93fcc8ad3297539e21789afddc921189d2f6f1f544d5ee5a2810be38e35496c1ab3e01972bbbcf0c03f62f053ea315d3ceeead3cf8fae9b54eca39828ab7df46a61b38bd365a6a145bb875d577371c6998d62cab66b410a07c42d1dd1cf6c7ec0dbeacfce8723b73923b24375300f4125e9654c535b279d293ce97e23c73d1945c4c9d23e97d4daa1da1d972da605f9a0014331dcbb5fafa115921e1e18d6c5137fb1f5ed20883493af82a786b83d720c4f3946199d078e11c68654d04537fffa0ec4cbdcbe6293ac3ff3206b0b04662f592f1f0bd3b2490fe039e15a5de0b3de39fa8a6920d7136399a3d9b544f4d295df444a46f8e4adc561c138b6e10ff8eb9ad3f232ff93b4a667479f5236e8de51f8016a30c33762b08cf8356473b81f7c27ddbfebf7be597a00ae419fb4885993fec92fe3b75f70f7786accc2ff4f7c43c78f2d12cf361635f05bd2b4bf25820a3182e0f91013f48c9769c1f0cede96bed564496d7971dadc8b30cba957245b0723d35c124ac7da6fdcfeb7afb37724c0f0fbee96072ab81f613387a5f7515a6cf307d459aa8db69d16d1f399c90a5cd3d92ea20a149299918adca8140e42d6f4e945b640e1afc622553fb3cc98c448dbae07c79f1cc1cd2334dc2b291a1e3e354f5065dec115b056fb68385d9db070f8fffbb175377e5935a1e6c6b8d2b58d1ea072da7a0fdba29ab99c9d0cbb4650f590bd315f147da1f7d8534411052b98d4e2b8fae38b572b902e36018a6d0a3aaa844746334081913200153667137d7770d3530285e2df8af835f05f3578fddddb6c357d2a8d81896721903bf8e7ae63179a22e7ea1a3f7e8d250e131f899e8ef4dfaf67e785e660c54327d88ccf53f54193244883fdfa1e8d9d1ed7f6791929a30c7a414d242d0b7b4ee9f911b936c15336d1da2c1796e541664e51c120b70a80cb064037578c9cf9d2205f5d643e3971bf9fabe8f878474bd26ae9649e5dfc293f2228c322525db7cf3074d30a32e11a208dd57757cda537207a37163e466543eaea7b894cd1185eb95be0dcd9e38f5596c991f201faffc94980a2f662336e135ae1b6aac1f9ac3bbf08803828d492f5995f4a54358450f6bd85c70aa214eba6784e5a029544f2a228f60114fa1ad9b2cfa67feff0c2cc84d55bce95a814277ef8202c07af3b7a6e9e4fb4c9fb5735ea77c7c7ccd2f61e8c7cee85b9c9a80c2c847a716336942a0af3aee360a588fc4a10cb13ce50b1899e9f776042a736301f6fef8d00e4f971f8f6dbbf8e2fa3c112a599a8b19d6a73ab86ac07ee4435b4b8211991a10a15cf754bad4922afe833dbf1fb342a13ca8437bd16390c9fdd8cb8c1e556784ce044b8b6be463494360844d2b2a98ab1e356f1120894b813026df16ae7b3b2cf30e9b49bfe2a8e4a34f09fe66d001c588c4a617344e2e58c36fd654213247f29b64c3c2c1049c4f0474f8666a553d208e77beb52fb8cd47352cefef0526009d528ef4245e9fe2f66970b01d4b05fefff7574a6a22092c5a111a16affe873b4c36354cf43e4b027de2e48e0d96ea5ace639ec49e28391f96946fbb949624c6e8e8021e5ddc23b4af473fcf8e1035356534befb248ec4ad988055332fe6bcd8c0d5e025b31a92c436bae2c8157f3a0c73279bb2628485dd8f44e44e90e3699e51cad6b3f3d9ca22171ed6b6e550feeb6361b50f4a27909d1763767cfb09e1f2e2bd213adceaa706c50e43bfa49dfe7c6ac51042948db12decb6768510091ae4c2add9d1891e2842d235358ad78d17c49a1b94299ddbd338546f4e646b5902e2948cf2379dab55870bffa722616193e567d2bfa3aa452aaa9646b8a999a4aef596cdf96d2109254f306299ae68cdf4ea7b9c79c6826b1b1c6b2ea82bc83b63e16f5c03a2f109fb45d81a1e983503aab63a587d5a4ee0da90d132113b694b52e5f7a573e73df13ca659c1615015e6a16bc66891bed0430ad76bd1c010e1260b9744b3e499c815e9728bf607f6c386f087afbfed1f6da79718e4ca6070968245b05d489e7d1a2ea63c266a633db846a2a2608c442ce32593bf4d1523e567424c4c1dad5466b2a5dc6dec5b2deae6efd63767451a94bf9db6f29e0c6d45caacd71b9e23aff8bbefec446594e62be89ce5e6db1c87c97bdb396132d3ccd7fae8cf5ac9689b84fc8961d4719099a1a329234946926f120084542351764fdd8198b18048d08ef09e781cb1c08ad67cc8c14ced87b4aa9dcc196588410b08c86845a0677ac00fd12077860cfa0f69d4bab7d42f7f8ed6d08fabc32095019e55466a9b147b9a72d534b0cd07921219a98714028cdb860d6cf36b5638a89ed7d9b79ee5448cc1732abb61dc8d12616104f2cfc3fbd0ee5ce959744d2ec998b167b962ed577bba01052404f76a167679e3ffd51fe30180d44aec7d08f6fd4727edf01aef8590fa8b5161b196badcf0f8596e481b38ca57a8c7275cc157b247fa43b215ad9ebb30fffe2ca20bcc7ad87ce22b96d20bee55667aa0d6fc0f25d5a648093c78db8e83003c0889b39d2dd5011678028a2922f8e3d4843428a987f17dcd79c2f225b4864d7a80a83a37425f48fb3d01807815bd629c3f9442fe07b5ba81cace70a98cfd1b4764438a095dc3bd96d2fbfdf121bcfd16896b911def77e1d115af25d6b26def34bce05c73f06e3065de1a4b237c0b84e6df8773f64b0bdc3152e12971141245a42bd4672e460d1528e0552f93f69d20554c81779ac124765d9ac358deb73a5a04cbd125ab8d8cc0150aa4eff78a162403ac3e363c98471fe0444df3433f3632f0b6ee24ce66695f9db83b9c8a87a4738600b3d51d70c27626388e732f19387c210b85971b5e64a4132a2da48b1e63ac370a7131f0ee3fca27bdecbc278a5f5c6338a8f55f885688aad98be43e70b0204c9e52e9ca5105e32c8b82951e909654e059bbb6a2beb908b8a8f72a6b34f67e9090da6cb784b8e31b0819b46b1ce3b06acbaf74f5cf29bf939f7d5d11fa66c0302b5fb42eb96e1287ad3d0e5869be673d1dc71e294ea78e582416867a5370df73adf3d5ed129e8578596ce977c533113c3815315a20923a68218b5d82e92737b4c30af0b60c7b7446cee56b2e5bec066022a48ed5b8cac7f9d0fe6a24b5a55cd4493dbe6c0241da2526e7d91677f49bdfa0bda89929360fa1fcd314f6e0a5d8a65181155645cb46ee476f95132176229ed4da15558bf780de5c775c4ef84432e9e1de07274aa61867fc0187dd46b16ea0a1cba719649be09fdebd7ff90d10d526a23d4d10ea6422dd2e10c499e269040a7085056150ae55a22c06a86e92bf1be31e90fadd418ffe6f9b1ce062f238169fa871e44a9a61aebb5e164c24a0c170a39a9783d1bdf4d29f99a3f5cb325124149865b6a9c75ec3cf0f0800b3ac2c51125470e8d1cabc4683a8166d1155dfe5f0762af3cd10d3f4da0419720b191f596010bee0c2b4a4252a0d01c4c665762ba4b986aed7d4d5069e966c2b19f4c467b235f3bd779f83deeedb2c0be206077af8216f8cadc6a2a24451a9f9d0cc46824b4dbc5055ab125f28fe43d49ad19fd9e42d2a6bb1e21d8ccb018fa489b210da1b3d8edd00ed9dd52587b2672a42c1db97fc44a189c32e8e1a6aac3cb961541ec91918535b1ad225236836d4fe1217ebc056c87a46f1fe855f4afa52fe780f303efd04eb705fd753bdda11d2942de6f64b8f2672a58b118aee45c4b249ccb16c43af02cec3dceb8d540eeaae0cf1f12ae08956636064551173df789fce0997b0d61a3d7d464567bf363b6e26617303f8603db7edf0a251f2e3acaa3d38a4ac2d2002798ae74a784d0347b9b9354348ebf2524a401ef03ca3fc8f55602a083fb33016292a243b94ed99aa6063104c89708684c5720d94f67e2c3d369f9d4cfce533c21344ec3b2db9c32990f5cc7bd10bbb10f1c8469110827859787d44014b6d14544ee4e11fcd88ba189af353a38677ce6143a049856e859cd4fcadb6d2cab5e9d97697c120269b28eb040b3c73a6d4b804ca11c33fa2f7f12b8457455c81084eee05799bf7a2efe9beaff654ab9a0e46d872defb6b588872f017d42e79e2f73127ab4a11696c2a9eabfc0d3297feaa07d6e5344a7d391ba8bddd54928daf11fb4da548415d580bb575bb2bcda97d08de34289e4c69f846c99a6e03311179455f8f0faa0918ca428eb6df3d8a240cdf025c21d1ebfd43a81df951c7ac4cd8a629b88d1ed9fcb21f6e6c3bee7c94c48494920b3c60a7ec8504cb42bc70fffeadf4b834e2657a8b9d795dd335cd07932c53c4f690a7d730b9b915e29154215de49b6a5712c3b2fc23b0c7b26e3cd5619bf8b368c80db311c5028525bf14041e822053877df17b8287991a4bd45dbf3a2b389a94868ed3e8b33fb8c5061c87ba6ea2466af3cef5380bed7877f2b921d40f1b55e5d34522048d6dc6ed4c6f139c7288e3f120d709d95352392258a8854618fcd3a263ae4a10498aab2f0f652aaae707ab7f125a0db103a1e4375fafeb6319f0cab6a35586b6668ddd45fcf0c65b9c1856266b9ba6133e736173ed7420034e66ea24c29de471b2e6dbb4b68443f34eac8f37813fb100a77b7a974a050e57dd7bbd27314ea0bd8bb72ea0247fa06f11e5ad8cc897ef24116a88a53f858a79b74feebbbf4052664d2845958abb9cf69781eaf58100ca4eaaeb5f4d13cb1b796debe6e1a1f7cf7a9eebc7983c72da81cce724da300066a3ff1d077dc206eb1e7ba3b55ca89da9c9e68c8a6ad403084579e72dc9413d2bba518828337bb07392e5f7826720f9998a33be3f8eb2ece6bce5dc82fd98bc62e091001d790f9be61d33158e344228e5a0029ad12553d33b4e326fa372d1929af1ef23d356c3025d4c9080cf63fe70c4711518f07364b8b7fcb579c7c597a70849985ee9dfc0c1807100f91ca26c4db2e889af2cbc528074a1636f0283adc38aa3edd061577cfd6e0d9dc30d3a7e0e6d18b38de48339f7bea33957a62b75ec841568ce58de66cf3eb92139f8a367bcd7cf36fd0830564a451d31b57d4d4d80ffe3c2dc42eb4d04f54f0631efef68a38199551f6c03c4ed7ef1bf14d908a5474afe8d278031827c0162f958021cd072ddd31cf289e9a8ef731135ce2057f3ec87b5331748233812ba22c5df01890dfa3074cd1183fec236e0b5a0841d85b9841a76fa82eab23d352d73962850f98b525577628d8262558bad81d3ed808f599af6bc3fea246ecc2533e7aebe235e987350114508c8558f44b567327d0161b685158a7df632f39f43b7ca46ec49ba2c797527502526804baa51f13024945b0fc8e991b0cdc5693c9568677505ba755c88ac4f78fc54cd345b7afc4539383a4783a9b7a023d588a91655319d31a01646582cdcd1bd0754ee248e7b7cc6b8cedbda52e08ca2f41ddce16fb816c59f74a3300a52be56999064d4b9e7f9cd3f9736a13ce42fc8e81c9b5010da280e2f3a5962960c78068b263258603c286db6fa22d3823396a62b50f6acc9098c2819eb053b7198ffa5507100bf747f9a153b67c572a25a04d6cb7ba83db3d38e034d0eb5d5dfe423e760a3d1ca68a8ef2d609c9f0ebcea408abba1d6efd337a218f8507bca6dce7588f203b72eadf0f005453bd0f6856d96255baddca546e6d9a152eaab5333065e6ba306d2eab942d2133c8bd8a9a4b21f19fc73bfef46df5b41517c9d8e2098c08ef9fc91155b678f0349a813d6c1cfbfde9b8320feb01b8ec399d2f72e8a2eb092222c9167d49553768df1f3c11fbb392a9ca141db22f9c6ef18deecbf2f82072335e7655053d6225958872f22ef8fa459d60022ab21818d36e46e083dee8f904a1394ed09e1ad886c11f028858a5573bc3bd364aa10e10f96af14f9d45e063f1d489499b667299d43cf4e2480d1022440252b18e35058be8e279b27152399d061d810e641b881d0176bfcc64f89e37cbc3b9d3730a3f996ac104ff5d12ae1564bd58de137a8eefae21f2b5d59f3c516ab211cc40c4aecd2f89d65a4cb49c1b330c56306ea95da4aba1de507fc840780ccf86623fb5d54860e87a3543b4f3fdfd654acf45dc7ba7703cfbbac14e2c48c5d9aaa07447d706c0d5082c40434ec0d0c37f7c2411519b8d2c92f47da9e382ca343f2cb8101b5b934d56d2343d7b6e1a3fd22133a1d2359a72d2a9328ec3dc717ecf5b4fae9970b0dd3a30903345bf661116aa97875c00483295f38f07027c58259d0be987f2c1cc3cd286d3cc3b09793577bf49d4e6fcbc45e4c667292e50252d293f8400d0a308bbba392be82fb806eee458e3c524e595a10c9dc1fbe307791fca13f244063b8e25c7642de903a8abeecffb727dfed015811486fd89a0343c1c1f65384c8e76af6a7b5f94c88d2ecc43585d6d67d23607aaba64affd1cc2b2fae7d8ece621ceecd983d43a793fb932554e7cb72ce6e669587e3176ee507cb2fea31e197eada9987af08c04dbfe5c442e4b386ba2c0b1cf7c1c35187e64c05275528d736059dcd91ecf6b9ded6373bb90672185ac4fab80fe71203e0d0e7016040afc78d761b1b2767ed73da4f64034b962f7f809e859c8c43762ab74ba0d877834a8e9d1d26ea9da71a0e183e02a5f5441912a2915e8d145784faf7020c36942184717d208f4a40ecf40c1295b84752d65b44ab80bf26617fc5b0aed0291d611f1d50a39676e9cb21aa43e537d3b419012a6cd141316c01edb9868ce75d5785cfc2ae4d872e65529711753ea6b049e3ef1724cfffbf1fa0a9a94e2410ba0437ea889713ad702c5314c628d0d2c01549c4540e35a8dfb6426ad710a614eceee2e9cba284500ee4fb69004e700f86990c3bcd4ab05d7deafd35fa5b4c57b8ab098a5c5a6165a8e42d9f50ddbd601bf4d2c72234676d2884f776dd5f7cf9e9b6d0fd053d1151f6563314c856304a0cfb7e531771e2a0b185f01b1e3c68313977448a6403ac2816a41e9130c2af1161723fea5ee45e3317e38149f713d6adeddebed60d8ab15607e700a16395451813fdad90ae6c15a1eccb448579db56d3e00cbf31280669238de78d253c3d61da92cd1e74088e4540da64eefd911ca1b06356b82358a7e6f1316f0da4d85e6781f5d13b449a65dbef776fd037d8d48784e129b9c44c0580ccda141ba686ff1c277640ca5b615ae58f73ee22b1fb2e1cabda450fa04251dc7c9d028bddc27e59f6bd949d28e081862b0caf99f43d3a23760c9161300968e03ae96678baa810cf01c1e72a62d39a870ce190990e8fe0337422c1f414ccc15f27773663a6069d698b1465cdae16c55effd6daa3017a69be83139371dc777efc9e80ad9cb42e285f914c84879a413feb9e190fa75d6ba8766baecab6045c935bf78488e23c6be030bb1bd84d9f14fbacc5cfac544b8adf4c1c3fb1c9ace1a3ccf37c4a28bba5aad0f8e052a127f30ffc9759015d72bd7d40fd78bb765e4d4a74ff685cf5f9d393c3aaa74f6e370d6137577f727ea42a89f642ec818a68093a06c52566bc7f031ce73437d4552d129a2b0f49a4ea6f1fc518c0a8af56df24832eb781c66347d963643281d0015407bdd7392917c9faffc8163015806166eec30128d3b5237fca796bfc5ad935da566ac70db38001dc94ee7a459bf83e7f94de47f808fc959c8dc5045276552163b09008c8e017ca930fd531e7523c1d79067694fb58bc4f91dc8cff6c6f638f78ddb905b2166ff8f197603dd41ecccbcf328aa3010e436ec0e3bb308fb0e636cb3ac8a5b0e5fa67c7dde4410aac5ea367a1a87a39ea55864619f309ffc3a791e163f263f6ff307f2bf2f3341664575842f86f9a7f02bd914373dd6bfed18f7a4907cca7b5393ad6aaacf208f5a2aa6c6ac2cdfce4287c2ce5a581d25338082fa7be14762b415643b056a14b7e53de8305f6b1a5725b1d1c874cc899dbc853ede59a46a8115121e0609ee4f51783e05f590a5e7156bef1179f8d6d08002168d25e5a810b4df0bc5afb1b11f1edc6c7ba27cbc1ff7ac501476cb8139f16746d40582930c82969dbf16cdc81e264134abf5d5da8e9a75eb39e8ae5fbdec636beadf273667d1da011db7235c57da16e94c02a43a5cde92296e0bc6e13ac8acd48c862af75ec6329eb46527179a7005a1044fe36c309568c85b4d9f807ba12e3a6158991ce35b6f6a9e6ac45ea312d7a9eb0c77794e09ee4cfeecd931795194783058b7d132d61336c09da5a1bff003d608f9d654922385a29c9cd5083853a7ccbc71a809e440e0d05bf2f4198e81ec1bbf63e4cad2def8f359f801bb3544af64efec68d29c5ce6f8c0274c1811f0342fb39410361a87dd148567ee53c149bd24f001bcfe7d9fae6fbfaf1f57efb767f95b8245d61f33a53f6b643c0180b45af3c4d2ec18abbb7153ad41c75a40b63f4fbc0c086120157ea01f124898a765df9f639bff788a00e0c2cfa386710c982f234a6d33947db2cd550f3ecf754e26c7052c91488a3f2128ea7fb318b8714b9d8a1bf8a000e310b331c08e94ee501115e6c86f5ac97b3cbd5b9fd4f4ddf90d794e0d628e4792f5b5917d5be2ab7a8dbb9cba79992a6fd7434e4fc3a62c95a21f0379cc5c7611bc5164d025f456bf45b7d15fb2d64276cf5f98c4050fe33801c11173c334f0c347899fcd0a91b89a053770987e766ed1a39e305dbf3a76356814e1417e550f0c7c25c62ce5b5e83cd64d538a3d62f055f49e12bb0ff9d8007ad84446746d1ad16e0ffe786fe72ac0c8efc76759645991035f0e4b70911cbc54b259017763c75bdb99e106b5e1553bf4b99d071311f4892ea7b6248424d2782568becffe669915b8721a4a64d89b57b2359b941acea6fc8e9269accf260d9f44fe9542fcff45416195692d1d8116da3119132ac3b6de43004410906f17f6bc97bc39ec4f28cb40d2f13e6eadd2b3b9186ece59cdf5c944437500eadf09c5e487d3c7b1bf958928b3180b2fbe84ebde0f8be8e5c918e83a1c405d4c3218e5327dbc77f17145e42cf71f9faea3b6cd330bb1024a5d9be9e49aa8f67091b61b64e2d8c07c946617c4a069778956b33a06ff2c93e60b4fdfffd90dbc5d850bc59907923428fcdc2c4c52e3873a11cc453eedf7a277752bf5e31e16b61fe30ca410441d8d02d0a6683821520257ef2257cdb877b47a573e8fd033a40a2ee19ae1c3304d4b2cef0d95d4e3b93e32d40e202ffe8bb52b8968a32f0b3ae61b0d929b33e59d9a66c8d878dc12a603a6b3695318c6dc296096712c5f5d590a647c16c0793d44a140cfd938a6fec78d6a4f46837b3d3d40dfe7a376927c88b277226a32e1f0846c655a9f7f6062699d3c84c8e6283a6a5d4af01063603c251bdd0edaf65f01346b3025e53263ced1a4e48fb6f4b3057ad1f65ba722777adc46932dbc70d25dc7f9b802780a23bee0c0b74f75bf8547a8a1beaed29e4892781283c8936c195958f00fca5f23068082a3252afd5847f2f6e3aa5fe0d06654c8ae09b1264dca00cd08448f7be3d64454185de52f1008b924b153ba8857d651a0477bb7bcd0418bebd5649ac15e9b5eb751212dab80986bce7f65d31ae02f5ad248d723aef3dbde1a4a670cb092f8c368e68e99788fa172dbc4a64a636160cc3058452d695e74a6ed03d3d75d4021bb26f8c378e67943aad692d047814e577b996a1d81ee398761b21553914bfa451c1032e45c95f95ce1f67106041355e0fab5049986115d78df82238df423ec12b8c7b182bc3002999ac080c786328f7f11c1abc948df4f7046e979dba16d3bd8eee2c65e6e6e3ec3acff94864b52a723827f7f5dc1023f7c0f44dc4db9d27dd9b11ffbd38ff25076f6b3658bf067905e8c58f76e67b567b63b5a2481658b10082e622edec5c07e5bf2a1731f4707c685195282c38d69129c108a3f9324af938f03553f2f058b897987f9470aadc56287104319010e26261d7963d9357ddab3290e655dd9e887cc00b0937c8b848b9e96959c6e32e69beeb5ab648b90b40419489ba3db4dab318554247f70aca1d25e11180b075f9ae4d985b5435f779b50a096b765ed681e2511bbb476e11e451d2ba9f6f41ed5b1b669d721f71eb92ba402821d63ba123bdb2d32e63a2221ccaa7470bd264333d765865a9a7692d1470a52fe4470ec7e2d04bebd8c21db592bc99972917049e4b1f02c50bb89cfe0de1c3e8461ae76625bccb726061618122b773104807b13f6cb8a4d33838ca14825c2904de4019d3e86529ba4107e085c7f61bf9d927d03a37f441d3462486953de78e4418ef35a210ed37089dbf779bc5105b2978819d95914972f4262bde6ec03873f6c3baa0253830c7575f21ec9a4c130617b63bcacf4cc12d3fd3640c5ad0499bf849d793c45d7a1548d0c02d4852f8ea5ef03e36e95a96c28f42b26f8321d5b9f19d523f1372436ef4080894777b562375db8ee87acc494e90d4d120564cce1d4bb6c944fa3ee35533989a325057cb7acd5b943f1eeb2d077de99874462491d5bba3acd5af85cd6b3d3adebb782c4ca3a89d149574898036844a40051a933b9fe7cba8c0f4fdf0df9db31a13a63942f8b2d60fd47cbc0f2552d8f591c1a7beeda31b35ef834e90b1b24546e3d3de46b10c226cf63fd1d94a670651b5aa883f51379b35be5f59eac3348f9db7615b2c6fc2a4578109efea7a0c096df98fd252de528baa752235aa978f44e1485f26c1548508d9f026d3e50be3b71c6e5237ccae1dc1e3af4ba7af5bd9b21315ce2dedb0ea881ed88772a15ee720a524888b1d34caaae531e11e7a8ba31b85899808bc02f6f833a317fd03f6e6c375bd34ec93d234f96e7a77182ed11e75e1a2d3ccba56f00a581bf96408f121e2f34adc7e00e8ead3d07b6b7f244ba9004cbc6d12901ebc0e97bb677ca159134ab4c07b39103d9bc3e562bfcdfec0ef6031ce8b2f2da5c9ce60581aac8494a2f500224990509beeb357bc843e72a626fd8eb2a6d23f58ab269f7a9d5062ad8d7c3d3186e4133213f66f96072c2ddf0356d4e53cf272800a87e8cdd9ca849c64de174afbc39e180b564bd7e3760aee4655d6a64bb9a89871be6938b1d130306b23f1c107e036c7e53355d7db1b6eb45b1bd0196f33e6206e132b97553693ecac389afd61c2f0f8a0b2647eabdc0c4a977e91a45469dfdbe2804eec0bcd57c4b054e67d860b982c14d210baf436471162678df08c513217d4b19a2d0f6f4effc8e406450fd7de90625d2183e707bc0f7e995ca9111644ba261b0d6b8d06f95c71478f02e1290067b462234d954c705c7405229a928f729befad668d723f63e09b8190fa496b756f8e9ce0af82266e4d51dce0264ced3697c5f3529690ecacbdca4bc834597171a11bf6497816389983f3200d76136b2475c0b17471457ff0a46df7862ab32ece9f7fa125b3953c3c7e4d48bfd2ae90d7004394d36d81db879e1b52ac20c60d1afb2ddcd67e73b20db77d1018c24c28c5ca78e6cfd3515fa3b5c2b3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
