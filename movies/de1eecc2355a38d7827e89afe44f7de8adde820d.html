<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"de11b48569e56432af5cfcb7c0048473bd0130837d6b2217297c8d9ad89c1bdd546433020e9a30ae041c79e07c7713365b90a81cf3550807cd5139f5ba2657c823d7f77919b23bfb34aeaad652bcfa2e8ebd6e9daab845f4055071f081ea61b897769052d19540eda7914804e755672c624d03269bbbccf04e185e6833ec431ff376cb766297631de6245697b5d71910cadbe48152650d987e8d5bd2c5ebeb7238568d859170895a4fce713affbd53227d10ddea16c45bf87381f5e2e86f28b8b047d1137e93805a868c746bdd09631b09bcf3989db899544377b271cbbaaf4931bb64b2a6cea0632d92dcdff0931dc015fc067c7e9a2e9db69181ba471885df206f8e26e19c45a583e956226cbd97fe9a02607ca8b6850ef8540ee6f1711ac22064d88cf3d968ea5906d01605781c26f035832946e8935b8f3ed7db4d9f0f276de6fc4cf6f75b5c8166fd8ebfb68e27c585a6518fd4de816cf89bba7e697876fbba595882da71566517212416f92671f425088c0496472bf18167eab93b1cd40de8158d695d605c0bfc5646afdc2c502ec1c461827a41ef5346207721e655181f8cbb9e42f7dc05e81d92db298a18174b989f83f6f2a6fe81d80fdb1d4672ae90f60b089a6150c6bf62290051bae2d7e11374da5918af5ac6efe06b6036ec7bc36e9c6642e17e79c9b6a89c503c8ab847005a5b6727a8427e2a1eeaec56e4d9437af31eab443333a6e7700b106ef2aaf4fdf1c5f35c4bc189bd5ed521fcf03d91d0e710f4a627072863c647246e5916b588ea1e6965951a47490fdd0360ecfa603e83ba5f19aad78a228b38efeebf3110a7ecf7610deb2c422f6a41f185dfa113e52bc252aa91e7a15c4e05cbc53804adb62a824d63aa7b0177e34824d2b3b2fa514d9ec5fb14c851754fc2f61db293a5565eaba7f95845461dd2cbdfaf1c5614f557eff527f0d62e0304d896d7ac3b246bd2c6edbb0c33b14ee763a87a813a48c89276728bfa13e41c47b66f47674aac8fcbc991a276e021f3eb912c5833f4af7f944b1f128106c9bcf1c46712f7f97b282b1c8944a270261d245ff1c9eb3634c65c4638ae1d2bdc9290a54f75f8bc9bbafb5107eeecc921c50aee29241d2d7b3f05a65307879518abc378ac11e2b175e2986a3b0778f0f7069a81fd54047b0e5fed9cdd4cea731dec9cc20c42a49eaf17e5874de4b9fa7a033748bc22ea3f98e2279738be2caf351f11fae037d023089699808b3b85c7e2ef1ed90632a259a36e2a1169b0b9dc54ce9acd6f05c487c7ba83bf33bf6b61229ffad33b9fda0370b75362ebb9b117eb098ebe55b90e30775ae56fb6a9a5910b6f5406c4f56eaf958322eb0fbd011f1fb5efdfa22a94c713f1df5dc7294d869bec94812097dd020357edb5cd6da110ffc83c101018483ec203a3388673f0f8b2e25b1a9cbd51062cc15a9dcf781b8d3b0191eb8ea3ba8b06d3b5d7d8015df6fc160076ff6be5f951cc4db9746e05b0b99e07232dabe0f3378dfe96da400052338c49f20c52767da9762760d4c6d4e1da52f3e4c893a0e17874d280fd63676d2005c070e53ee3dbc423ea8e11871e66a4a4f2f1bc39573ffbf3e94828d8a9266bbeb684b0604a4b8a817f61a158889d0da3306bef010d86ec657133b006d676c78d10894b38fb8f618ef89f1b7948257fcd506cbb7f0f05cd3636df05a9f91e32be1cade71fcfa71ecc43987665e83014454d6e13c407a853fe549316fd8f9d89c39a06fbda7cad949d73aefa4893045dee859ee75ed4d8f2b53d397fd10221a7a459ed8490cbf1d69648a92f32fcab23867ac5e2b20885d2991fbe783ddeeac60dddcea9a4e5ce6aac96788266dfa340abcf5a52f5ed17fccb08e4e86fc968e355f207b8d1b5d26faeb023ae48d7192271c412b0fa3d264b2300b7f78ea49d0609e44840999879615124fe6b8a1f4bbc97a6d536d67cb049a052d116e5c7e5848232a841688fa8c1e32276ff9ca89811b5a2e6ec88aa1ec06e584f3ea34533168a214fde6f38db075016c73aa4917c9498b94d472be3aeb378bd7e407cdbaa967650c9db25a1a22845d4c9add24520678bffcd4a06fbfd626ace86ea760b066657f0a382bc0ce8fe1d9ed82c4a9bf85748c7df3e7a251ac5b7a64e5d0066a5315a812ccc95f0a47c60a381579513cb698eb832286721c2ec81f0eed9d3ec03b7e923f57b7870fd85fbf1d38c595a4ba5af2c0717a804f913c922d9efcc45c580044db8e43c7537c2fdbed5109a68643e0d73ba71bd3a14e9ed050c975ae871d113f465f3eb09b6ec2d9ca88c0efb0952babd8eed9b4179acc26d18ce2cb87792100a36b36dc81207da411009dccd2d43751ffc9c10e718e60a69b3485f78d283227fc86ee552dcf9f4a2aeee8e0fd1c01c0c5e6a207847266b509ac04f910869dc5db3d37c9e1fa13930d853627c70bf21fe59b24388f7e40a26f3aeb0bba598eda4b353fdb9b9ff8233bcc2b6650326d2bff11a6242dc70c104158fa3834f7bce853fdaa95d82779ba19a5933e08b1eadb704f2196c900160685cf040bf75ab8185842a3c8b8b12abf13a1da5cfeedcc14d36734f24ead61e76a9ca6950d297423600357dd7e0710f6792196bb651719f11376b83fd006dce51df692edbfa5224003d47767632aea097ae41152daf08ad5355041f875a3a77b2f9f12ff7b5ad0fe36d7d91f2337162eb723545fd2074843c75f2ccf122c859eb91a96d140d292f276c8d7168420a18b3a588d8cb5aabbc57b877d7ebafb0cf80ce3202dcac591724a9190517697361bcf909455471eb8507e4624546ec8fd707eb797d0543c6ff1bc8016f2fe339a1b2ca3b6a984ef38249bb32402ceb374a6fb39412b5e5ff1d0c20f6f933d87221197c47509fbf09bc2b43363bb80109056d690bba56524b460c82e3dcd4f009578158ad1630c95c6ed78160c3f12be0ccc246de147c34b25efb5370d627d660d9d05565bdae12da56c28ed1f28f34dae1991b73fb38a79d868812e68dff6b358eb1b81cc8e2f55b16cfdb55022dab1f4077f091892af451a6b56f75c320fa08176e0efc2ca6e83fb9fb853f85410027789af51f151113453df7f4886b4e80964d5b5b83e16f897a193d0f6b4685ed893f0066e049207b6fa1d9c0f6c6d74c6060e1661ffa781e1d8fcbd1f289ca98a08f7124dc5b565050db4af043d4a32b8b7d18b7492b2e20185fc1c007cea7eaadd3423426945988c903f2ff2befa33d7b46eba954a0b0e47c176ef0e39306401066e0c64253989337baf2b85a4dac7a50e91f61cd887795aba3035b69ba2ba3aee01f3e6aa7be051611c27cfdae7abdb94c38d4eedcc29d41bc298a1ec23d94e2cbf14681c67f786c8916f12c1820260ce6aafcb1500b61ac09847375848594136ff17136d436e5acc0a040d05caae06bea91b6eaee00bb3d945c4914d22a1c4cbd0cb3ff6a258ee032cfe7bbdbd1db75cf4f648570fb44fccd89808a5ef047531abf563b3e36747982823cfc50ed88c1b0618a109579057e99fbaa9f60e4adc6e3735c1be505814f6a0795b8ba78f99590095f0a2bebbbf7063033d5b25859bae8be91e3b47090de71b04ef431093fd1a2f2e82a2925c99740055a42aeaf52b3f7f989144d8585eb5e9275cbaee409e4a049cd8b824f81ce8b13c0559bdfbe1fea882adc252fbe94129da4cc87026c5446e7eb29973192a0498725e5d22930775896e618e0816e625c7366dc3d74b2d13a575db2c14f7d05f0367547fcef2129057564c47d139f31de9dbd0f5f80aa331550579b22b9d781088235c73436ea703fc65e42e7ff5d3b4ba80d3d803914b1ddb3f5280b1bd6a047e868cbaa0e2e16a247cc562c3c1fda62b24d787e9f2d9d8ec0615bb160625f6a9621acf78d801a8f7d5e1509e2f965121b30c88fb7ccafdf2044c1b91df8879d126c15e94b5a6a3a49363824400dc4b69720800fc325b4ecfc7180044c6662ff89528b0177887732eb866069f079d56abd91b257533d279c500331a62ff36d896def0fc53b0c1f5f543d3457d1df011d737679098e94f8e93e91f6ec4c9130cb367568f9b6f4aee36722ae4a80a3770291c95a331ccb75ba679e2c4cb69a150cb6d37471e515055ce1b5abf142f692653c8783828acd977a47aa7ab1d5e929f47b5cfcf209b213b45aa1a63c7b4ad52a4cb0c10630162bba5f09aeb0dbee8a4b0e10d9a22ee27714b52c158826c459ff3ded3db112593f83b4cc7db402be51331465dfee0bb680d2dcdd6cd6a92df4923e976661dbb94d1e729854bec18c9a605d51295dac789e512db25ec8e9271857b312fe7589210563ed9e3ec79e871ece966eae1aabea97d3b8cd9d120e2260f396f34abe9f4d37562bb3cbcdbdc142a1ab04f37d97f0754782a42efc2369f47af63c2a51c5057473d2c982fcb6b4932fcdc8bdbcf9e0a03cc0f92fc32d43cdf3afe6f0d283e6a2b6484223471b52bba6d181557c274f5892a46f7f78e56dc8a7d73858701f43ae3add3b11d1af0628a99b8e074dc5fe4f8d734067a159cf6afa3826b224c545887008ee178ba903e3eb51570c503494899d054002795fd27d41e4edce9757a7d1e395635d2177fc5cf61e963258d80a23b22e6c05d69f4f9b104cd81c8b954070f6e3dbd6284ac0f5208574ff1afdca0eb2f49fb31702f892daec3844e5672892c803f9d81f6320f14ff5ccf300b9a2b11ea654e87fcbdb03f9d18341db019cadaea4988353581065c9f924a2494d4cae088e06648339adba166741a1ba98774bc4c1fb0b5befe93961cefca5cf4131fee6723652285da83420c227e8864c9a58c6508f1837d6793c36da8225fb517535e79bef8593cd5d1cecb644a494ae761168174e399120d40b0903a293bc874f86902b62911e707a80b9a29424ac05db76cca3fd7012a9603ac6eceee03f73051ae966ce30b29b08b77fec59c8a91eb97e06c3343280fb88342d88907a2a92c41e2eda9e20ea5a673bea12be8dc33a312d9baeef94e39558b692a746cd20e061516889a194ebfb25768ecbb995b29ed4402983e28996c3467787fe86f4cc44a52d64f57838dcf184a34b35f6011b271ffca73f08fca9008dd8d09863335e423c226210446b23b78bafea5e073d70b591c743d83a745ae6323ab23f0b6debd41879ea015c8a3ae7348ac26387254176eb15793afa344623cbe9a33c3a5185082673c82ef052018b3380e08dff2d1c9039330dcb6de2582674ba5bcb1d5e2eb07e3a94760a6bc66cd85dfb0766e6ebba74981178177de3952f2187cc5f0ac9d78fc9bf32aad6ad74b12fa471fdb0e528bdf38e81bf8a4ef043e96c25acd2b2ab25b6f2c310cf3ff8e05f32981d82101c9231cabcab27c38f02aa801cfba2e15101b98cc5be81f6d7f00127d41136fb98d1f505838d6cf418fd8bf3e26ca56ed7f2d0d9ea0ba736342008bbc997e0ddd4a54a5d06cc6016a6780371b6723501c03ef4d9e68060febeb78faa04e4b5a95e9a273d9d1453a5625311772840cc8bf2efdaf532b3f0f38559ddbc70aa904834a659a7f172c15a34bbdbbc6afb3c93d09cd9a12c18e4dfe4057ed391c7ab7e3bd00135c1c1181700df2f031862cab27146e9448b86617dc9fe82adedc681dd4f14356b9e3fb12c2b84e8b5b59553a271c62e4dc75be8beaffbdf7443f6008db4449aa7fb46731a1b537836dde2831cd4e0af582c3ee3dbfbb89f37c3f94630e67e9b51dc0c77c4c4a685a05235b57baf457353e586101815308c2662afed4016911900b3c5321c540f1d23cce613ee436787a7756bdea1afd8b3f5240ab362f6ae4fea924e6eaf2e358f23fb13b94b8de18ef2caa4c3a8c12f41619d9815ae1ec5634ee2812bf948c6ca676364b46e92b92e603e73335b194c561f1885be20e1be12cf1eefe0d302bb0e6aa3eda6ece60b68567ddee846932d3effafda9b16d29938700ce260adb26af197c7eeb1aeb738aba32219cf8e83a1a3b9fd05358e7d621af116eb85892c6a0c7335ce676fa1af275425cc816ceabc27ed2dee62adf2406d86c10d3823cfe35b10cccf7f20d428952c8127b7f8d7f0ff7c0296f8c15cc3b0bf62d33679b647a94881ff54f47d7a6169534f754dcb4616b4d7f6fe2e848d75abd53b866927bc78fd940d33b513fa18c8bc02748ecc4a9d44e66785d6e37c1ead02ef4e6773db269048ebef495a02d41c9366683c7ca14292a982575883e457cd1b2590a8564940910cdb62505448a7a58c975e3fa9211fad1b3a9684e80773206ce87be4e6bbdc435368cb4307a772d0196fa7c138f8878baa8cfee1170deb90b22847a664217f32f89b6257965b48088ea382ee0531e027480f0191c1053d3543b6aea1087cd499c5396b605c2479595ca5b68738daa911f60de76199cb49f30fed0a804932c7e7e0c8214506af76425feadc49e919d3ec67442728bb70eaef2e0df84bead41169cc9bb881237ff665b917e2f47c4b31f50deb9876d5efa910da5cb5ebe8e60b370580a4bbc100c4ee48922fa89956ecc9b694e82c4abbdfe9ba5028bac923487bab5b3270860500ec2ed78630e5f72e4eb17135cd7acb184101274c16bcf811877ed584c3a3f4ab3bcd26a6aab5cf76910d956511b2962d147db8fb504878f588107ef65ca25991ee0f97291d3eb5579009308567af73a1df905052fe00cd4dfe0b4342aa44b174bbd4bda017140f01970ea52e2ad1364c47bf11137260fdbdd2153fffc6a47bf1a2f688e9c9d868e01ea981abe22cb38c81060612708705ab55c481b29c8b8187e84676dad173388de08abf256039db4949470b7e4f97e76d0f20f9b7e99c4cb8e542df050b7d9b2bc4666cfa622220a84eb78db0eac763260cfabb2f25155ccb12dc12846f7f2f8faef9ab653b77648dc73e1773ddc1e0f98a4dbd7bafd43e2115a345eaf5afada733fd46d64a8ebc7ebece06c02166a347a38785e1fdec222b8fd6e08a42b552cd1534eae83fd01fbef126c796a214f1a4555b20c4f8399dadb173359ea2f4840c556bf3a39d30dc0ce6dfa223482527727774ad7b42caad0568038cee172e134d261eae20e8e33666ed31d86cdb10d46a07ba8c435d03c6248efa371b9ecc1cad476fe9b3cdfb23f18008421f7cc400495988b0519bef1bbff602e7d173b158b911af661fa845c3572477b3a935efd65b7ac9c7434b812dc3a86d5686a37af4ec801e16b28da29e10d2ff10d323144c33bf77a8bdb9037d18813560e06b5b2afc92cbb773305a8f8dc3e4cf9f2f1af16454b19f27de480dd759c9d6d1e2339e8294f20ed1211a34edb62de199316812d07159646b3502193ef458848a17c91111924568b90b58f21ce349849a9ea008d59115f45548d1a2e9a647d94500e0740cb8c12b8e01b1e1f1c9747eab9a5c9a373bc20aa85b022857e973f984f2179a3a6582055accac1a9a431040bdc1f4cde86339ced133b93d19627dc576e4697edaf4f45fd2cd1fb78fe4550d231884cdbe0bb704e7a158282d5850207b751d180e243313c0ce5e99ef82a386f9c0cc079706a708af0b460826068b6ce52a8337659fea784026a19652f8e71ae49d4bf555c8b36bc6bb5584fd4906f6930dabe74a9c3a5bb424b46b8396df6493977807e94dd4fe623cbd0d0a7bb503c249846fdada534406be4abb7d5d5efc0795b3c3c09e69a5b112095d666a5772a8f08da8e588d8f5f42378244117d1e198bfe40f4b8e6fa75be4e1a52b6a60fc6cdbf0020cdaf6c68c783beaaca2e70e2318b3ac675c7922d176ab02fe5b0d2b64b67b3ae2c2d22fbd63e6ee7d7b6334f52cc5537ae9ff7dd9f01ad940ffb674cab1d2525d8ca4d75fd71a625e90b8c039d5b738e2e1c7f22fc95dd2251fa9fdcca849f86a1c4df38a33dcaed2aebdd54fb2bfcd2950b325f68000bddfbd940734fadabcecc8f3621fa4ce15d9a02cc6273be88bea4ab379a89ea50d209d40748ae85287b7e6b45095d755b869bde14203b6fb3535494eaf1d7ababf37921cc0d74823ac0aa33681a6136cfbc0a2fc2804073691355cd9ce353c050f921017a38d36bd0e6cdcb96bdc6725ad9b92e971bd0167b2acffacdc27ec3bd77ed2689d8661a3032b822b24225d5dfc9f5285ff572532c3859b8aafcad489ffc55ac2f2c723e7502de093c56bf2a921dc29c2735670c436725062cf8fa147b1cde1ab4e169ae88106c9cf4479d981d5b70639654e566e782f04b450d740e9a1d400c88e4269ef5e98614fac38d14e95f83eda2de4648a0b199fbf1a3692268dbffccf4a453580b58ef91d12ce1cc37fc7058fed5e339e8cc87e08ce59f5f8fbfb163850b9c2752e4179655ea5a664d89638ade76875922c6b7b888df3193ca5ca30ac5eb2d838452bf4b4e9f3d332cc7b7f2f725804f4e233f0e77d215729d1d6847019d84c3a6b687e14c1b777c9d8c81ba8aedfd73a5d4f2b1119a62fa381e5366b9cbe4b6239f5f62358a45470be16286a16ffe79b9b161632d6e2d622726bc4d6a5b50d937811f81aca22b05728ec3577ff2370db87e4ca9e0685aabf7b2672d5824ebac47d6fb13d989a4ca9702cdd04ac2fb7e5213e36c6949b8776a82e957e73515bb97a76bbba640fb2aba0a1c00b4d8e25ad0d8d8fbdd2b05da9519f917bca30be3cc9790e31278cab163de641ece5cd331df97074569ff326cff5c46ae099d4941f79fe43931754cf435d74f96c8256d7057e2610e10873f11341fee0471cc2988bef1792d349a5ed2a97e17df4826e5397b644aadc8da0a74242a2c5c9c87d6609361020f5faa0dec41f4929a33183f80ff21560c74f9c16736281549695eec787f16466d62ab6287bec732338a8b14298303921bd5a6b4d53915efd8c5731526a66c0683f5db9f59255bc6d1deb5f83b9ecf1b67318feff4e527d359439f7c32d49a07fde46d7a126e40bbdb8276031591ae32ec95acc0b4d46e551e907e3a4b529551eed7da10bbdc5809ecd6529372f0d3b30708cd0bca765655e5995544a2d9b031c022012b54208e153c8fd7bbd0f8f03bf53067f64721f5ffcc6b9970ec2cc34ba721755314ffa7376818d46f1d4e085d0d94eb435b2c540f4ea4d829ef82775e26cd5366df0318a5a7acde54424a77bafe5eb3d195099141959966c422c02ca9185dffcf3eed96c6c057ffec6e840776b0f277f40b6097b9f4cf38c696c8f597c54b8b4cfcce78c90796b984b1711e73d40a798d1caa40283f5696a14bee5a12b115ae2f780a952d329e9c7e8d80b441800b238c8de8e13534e9f77bbd6ba720063e885f0301145abed3891cbfd2516c6f88bf5f6ce4998fb4a952b264f121cdd23b28e27fb361117aee5af0334f4fb610baccbbbc362696dd39231f61bcc0e179939b58e3a489e320c42c664d331713a27cedd07ecfa74a8de92bba6aec150e388c84c13301b06c577e037533566c0de6cb15fcd9132758e36eac520103cb21f663058413bee6c0065dd55df67618654626b8a764100aa15cf874bc59b910157facb0676e860c0a1d8c0aaab925a34bd3d67e1825d9fb1cc2306761650d1d685789e4dd90a9e8370cd7368d60c196deb6213509b2c9a6cfc09473cc194cf9dbe9f79cae7aaf9de03ec247bf5b5be7815b5a2ad7e41f9e832d194cb3a87de34fe868458f065d8704abde15a74d72dbf9a494f8dcba14233964581eb03dc7affb29e2e3cbd6e99883b8aedb8d44a213b010f837c0f73b4be4ffb71577157667ac80f583eb1770bb625325d8e8700963c4678148f81edc794a532efbd3f0507c3bf7fd1432458abfaab1cc840993e09e015f354fa3e905663af63b2dd4f49df60e709bd7bbcb8de987cae3701d0d308da0d807c5fc0dc0ac49066251b646e23700e88a44491f4d663192e709cdb8c747240103386c3199aafa627152114fa5d70b6f1a48324a4f7e4e9302de9d80f07b38ddcb3c6e32faf26cc45c70fb40414be151ac6ae1a9f0bbab34d1363c76cdf6ff611b1b8fe56a72546afe479af9b3da45845632eacb89f9efd136d3c3f26b5d42bdab4c18dbde8b71c00fe452250f6719e58aeccbc6703f52bd077b0aec8347519c97a8b606cf315c47a6ffeb04f3963ea99c1dc84d633ba07e99744d260621ee1c6a7a95c16d4185e4bee947ba296556c12ff8ded639350e75d0955388e5ee08893869f6542825e1bb1d99dabf896855d2492c9f25adff3925582ef03737719b0337d06ffb477a6588502659e2603f6ccb575a76fd76e9700b39de388f5d4ca46d76667cc974636542ecf6834132c785f2526ca1a9f1e5ac1f69679c0d02dc02ec71a8e873e68c3d00bc2bd1e18c1415c943b8b7b3c0d2c9ac7e9c7b5765aae3645c0c0b706140d243b66b07afbcffd26028a0b0df1b4fe1fadf457cc7a0304ae0fdba9b3f745593f9fb028f4a129b43ec2ba534a6993e9d276eef2beb71dd4b7c2c405830ae871832d3409a48b6ce9bb06f40272614fcf0204fb0d02322a78d399020b1d257d4766c1fe0b227977ef5c86046f8d28d7ccaca2c4d30230d1ed65b1d200acb72d6600445ce308099e62fbeaac87318ff746d5e8414d92ceabbb9be417a2ea93eb977b6120163ae923092b030ddd1e212a55bbad294daf45983d5cd17e60a84e04fde159964cf17248a1c5765942063edad5bfec68c0dbfd5fc49d998eedc2b4ba8a811603135baeb0c723d9019b9609e0a961a36f8b42f3675380979321d231bf467525a26c00a94b7420bdf55c7bf02360a0132fe9bb686cbf7f7172ea85bbd6eaefee35cff80f1b7a8d312509399441405d4562779778d4776ab5e2755bd5d9fa4884337fd7c93129c9acfcf88642253abdf268f4a191dedec5bfb72172dede2d0f56fe93e25df69da7d4d600a74660e9f92b70c5e12c58606d6c5919ecf839131497d4bb8efe5946e5c058ab75d558d8609455c56c425270e2d4e8744fcde4ab147bb4d1125c2fc992cd0fba9bf9c45c03f50cfe93f163163203a0108c41e4d6753aa96f5d341b9742c8b38f4b98a81ff7aeca982a65280ef5a9dd150ac9804cdf7d55f41ec67e08bd704e90d7afbffe3684218f21b267afa63ea85ad0b91a1fef39155b93e6e3f59a69c78facff50b7f3e3b4a0d470c07d0a132dc8c3bf7843a975544a7d21e74657e0865b596f6c069cb0e173e98730076f882ac3e9de2019a2a3b5c06eee363b8c8032e9e425989f48300ef1a2add6a36b1d912b690c8a6ca3a211631765630afedeb5d12f8491971b97c2721544f772574e965f2247e9559ad10127ebdd7dcf606157593ad4903fc6dbcfeb45160a6fc3b81136c9a7951c0085ca60f8f41ebf9283b3e214170a25dccc356d61dae599c707af58ab305708082febe50dcbc60dcfb7827a3a15c6469dc9a4f7adfaaa0068318656d7c6eb5e7fb1f95287d9b59d5f75f3b6315c6d47b801f26e5c824343594ae9f9718438030d3231b21887842994fbd1622bc953c74613e6a80f735a9d0a53097c67d0e0f3297e6e9412a3c958da1fbb3a6ef646db27bc9ed01012f4dccb2bb8d532ab7a4810eab7441316b1faa7dacdf89c7b7a80f012a20f3aecc364f00bc8ff4029e369e7d999c6599bae88bf7600e3f922551a2458f7b2d0d8d9e4e2fde6246aef0239a17a4da4adf355a4188aa68dd35e3e13060a309e7336a5a4fc056a3aefafa961e8ebe7a6a4c65a1083ecd7441999f5bebc997d077be95858063119a698d399887d12fd150b298550e0f94865b34666f1b08c4b4188c54712c4632431bf1434c7e19779a864d45669a31c6ce6c46f942ecc7dead27ec00b14603fb33d8dc1e443b4712dbc4303f78527643576e622df78e8445a348cc207ef731ad138f90409946c80692419feb487a9b3eafdddda35595b60c78f47ee7717f33a70aa336288b048d5268cf7f26cfb63b5f4d6914c0bc64a81b7742b3d93db23d2104e388d798e6952b0c03e5481d51a097e3cef6f2ff2a7a80c3107f89f57fc163172ee09afef01fab3f0d5470c6f33c222058ead9f9218bb50b6b69b3a1782c35c0c614832f4dfec8840b7ce0bbc89ab367e2494f370a88a63b2e1859fb60e8a869a09ba5ebdc624f53dfc0bed7b87417411df844633c94e619ec9f9eee9e2616b41ca4fab4473d4e5f4d588715e0c2ce1368a8dfe920091a64058500b7d63d9f63ec8e910eedabc91dbc6a82ab9a5469e956eda286836ce6e348e3d97aa98f53aa856066feed1973679dc1756eeefd20e186dbf1ad8c6acabf23d6c6ef00e4320b82c59d5dada56ffe351e066983fe6cdf0adf0e6aa0261b5b88bb11b75988281512c18f94ed4e4ccb674d1dd6b2c910741490c5f906ff4c9e08c091cf97e64acd5e731c10cd69acacf38e1409f49d2c497cf07547bf6ac622f9e907d76d8a3584cee315b2c73de1c3ad46941b65f1a266f43d09b5a88b5b4a6b802c1b1ecc2683175cf2f1f4f4052309fcd536218173c85a1fd6b58c33403963fe6e235e3709f901e7e1b1ce1b959afc5127576deaa4f28a1c71dd175f984af9983d48fc0e6e0973cd18c7ed534ad864bb91df4e9d8366f59ab69c89191fa7a0f4a0cefed2ef1ff2a3063bda351da8f4d52bf7379736c00583d249490d5b50ed0b389c0f8759e7fc64c134e88acaf5a1c9bcd85ae8a3e93a686a643058acf6ce25b5058d7b09d7dc1b6cd915d1b5e73b0087e75a4e49b41fb2fcb0ff2fb7e925d1f303a3a386c5c900158486755f2d9cf9f1465cd10cfc3386bded8aaa684648d1069fefa9323499719cb3e017c295d2bcdd9fe9bc8fef8ca7ebb1309f821e29172c048447fb94fd3d0bf541515b49a4721d9e680202a9c5ed724cf4a5d432c96e1bfa7f98c16c191ed4b192eeadc10828435b9e47d887971ab82120910e5de8e6a0a00e27ef61b45e0e3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
