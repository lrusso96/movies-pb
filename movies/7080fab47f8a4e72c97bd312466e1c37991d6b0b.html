<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2e3574369ab110511c75ac8d911473a8e5abbc768653e60867d9be82266a08f7f151599d9c4453ca3b0556d82ff99f08b0e56e093ec3188f4da2be79d5066f59a881ba3f7174596dfaf9ec3bb555af71b918b436cc24d95b477b071358e2ac2debf9fc5f59a0ba568b692857fa141b081651a93af1f2d0a3c16d63a4a47a8cd2947165d0d3b3f9c0c21d6096eb3c223ce9dec8c9b67c14acf968fde953cc04bba9d32da5754a0351d7f1e8879651dc378abaeebc927def21fb20f7aa9cf35735ddbce12daa06b553d51fd4bff533c11858208b8aa6374d2115556d168e95f989b7881d8742d460de6e3979a22bf1eafa71b9052dd24f0aa57e545d669e539258c938ff07f8a54ca41f465b873962e05fbd76345971eea716235a12664f381f04934f640614b11b6b06baa0631abedf1e4213efe3be0bd5a3226123963b8441a110f78b63bdaa11d2a428a9c86d1a7ae481ad852aac7c4c773191c9f0d3f5935cd05041e8beba2a9388222ed773d629b24f4e81c52429fa320448d46cb5581b749c8f7c0fc34da480621606287ba7a8a1f6a4ee3b6a6fcb66dbd7e1238ce8e2f341f12a6ddbc2f266040e7b7d95852eee4e66a9d2c2e9bda466d2d6ab6e982f8eb2b06fe3e40a4dd19dff3ed89ba0dac628b082f2b4eb091af78dcbbf90f14e38935bec904848c433bfb30c6f16911ac5ee851e3c0bb396bf80d407040b0026e4617ca1c74dd623fc25c607ebac2fab0463526d7cb1e059c6507942ce542e11d0c5ec00edd6956e86f0ba7eb3799bd6e3adc2e68bd98bc123de48bf875c9d927198929442a28341a11377762d7bd4fe6711395e47f66b2543061340b6c4f4de0dec4d20805d26b006523bf8d85590b08862539fe3eecc00e3fe4e91a751e369c8678a84009072a9365133bcc7389b7030b55c033529357226180c985a8ae09e5fe57236cd6270ad5b859a4a9f7417e7c8bb77a5ce1a973b193538862cd5753f9bf5109e72028c24dc6d7f79e819de588caa9b7c399680db7378cfbef7072088e7513aee18a038fe9f686e0a8b5400ee6a441835663913fdfbc2ebd3402be917df1200cad26b4e5f2749b2b8bb88f5aa9c04e9490731effc51b51fba8633d82d58865d143e827c23e2d7fe797cbdb087f4190f67ceb279c156bb5083ee925eb7d7e7a2262a76a7b6a0b20d0ab792ad5c096dc4f955d5f62453c06558f29a31b7867190d6df3ea2fd6616396c254b460a35226d58ae00f1dbdb154df50c873025be7f99d756c9e37c7f97038d303340a291be765768b37ea48e1d250da0aa46df6f7faf30f122432f68e5efaed95a929f689139552cf8d19a7996c80e472db5224cac0e3c13bd49d4941b55df16573e5d538d0d3c603874fe8b93f5a6c066d0e3ef18966c69e49826dbd4ba68b940aec5720d70ce24f70d9184f4548e01dea55894560dd1cb8810311238b8ebc03a68f4b595d87cd8284f0d0095e94c53178a8d97bef1cd233464690a06f5bc3cbc14a157c1cfd6bb15ac3bf637bb49fdc4fbc5a733dbb652f539b311f9bb0a408f7774dd131b59b48605cea6d382ea035f6363d101d824d7ab4ba577f3252201023a0c45c39ebfc9d3c08d7ebe017b0638f0f282cf984b3bc9ae0d3a14ba64e4df06141b5da0ef30b56f6ecd7f2050941878a76d272c790525554f9d4c18ea52e49b5a9db1cb933c1280e44450fe3c203729865dfe0073fefef62aef03844e12eda75ad2b1f0581fe61a646d32a3cc645c25841724027ec26ee61ee790a71f0521ed384d3d7ff00024a5e49027003d733b2c146afdf224a91b8fa224d18bb4de9a8bbf32e8be84a691ba1a98ce6e3442c246dd93f678a27771c0ed7afd4269e05a4e037a3a3dfd217872e048f6210a5b8cd5e669d288dcf253ab8022e11bea46cbf3955548a780c416c2f3400243140a0373d4e2fb655beb8e65f48dcbadcdba79af0ac035c7f8d199bf69ee18fd224a12d42a1a2ee706293225f884e7856d0b881294cc21d0840869477ae66768288fba6f59d1485317cfefddcd7b8ce40638d2e77a4daeb595c350790c0ce79ae645489e188d6c8272af59abc9d721b133a907200a625393d151934b87cd09e3baa3e8ca366278f503e840be8a2225a6a8226263d6a156873f0c4d1254bc232c3549d63de67cede1b2b22d289054addae3b1e9568e60c5ffd41a2550bfe492b3ecefd026abcab2e703eb2b26c82287783dca0ec8fa142913899d587786f4b3119c89ca0a9097f9f7bef441ab9b8bcae22624af4f1d9427424b89e496363b8bc73dfdbfdc67328438645ee777fef77e6a428be9daeb5bb9b239e46536299e3dfdd1eb8a4bc07d1bb45936ce794b11c9ec8449eaef21d85a72f58f221061773a607113a34750342d2305133b6f6311f0da366fd3fcc2052471a2837182439ada7720241f05d2caa595468fefcf70fdda74e16b931cf368fd457be7d7481bd47e4eff302a5b1209892f160791f80329ac6cc57cab9d5bd390a2d04150980d0c3fa89e181461c2dfe6c537c6789680f202e35615e9f2daf01da22a826279db4a3bb9f73b0691a57465cfd6a8b2dbd0f1156255f1d90920d837456f075ed54a947027bdfbe687f69e7ddf0f7c10766b42229c556720de3648f597962af9a21988edc8caecc3c8051e69355b9745e9dfbb5cefa79c99ab29077b53b153fc7508aa44a4fab40f24836681bdb584cd1067b7397f1ef933638101f42cbae1036ab28a8852c4d62baa3dee9b7a0e38a84cd30baf7091424d19d2edfa3bbac01e3916b2e1d067a68f54cb173617026dbdce2c732b51bf3670616863963602d67c9ca74a2b3c6f836cf8731748a42640faf5ee5b3b027ecc56e6d7ba244eca085ad64c8fa15611be5066bcf2a59978a2a207e6f5db2e190920ab322894a137de77c9290458c2996748642a2954f518299af63fe0a8a8fd44a87dfb52f1794c5d437609a71a5d4441c1448ebd884ab60062f68a0a6f5daafb531a15c6e21d7877af2fb7b2a6371fefe225feec41806089b04cbf8f69b6c96f5e2d16efb106f1473286ea37ce487911234516994540b60b7f93e5ea4c8ab266d9b04f992b18ca7373d0d38b7a5f6cdcafb4ca7c4659dfdd2f443befde61f1a04342e49d1025d096205027db509f5f881598ebe9d68d935a8374a4874af977b028ab73fdab73889a143790b48258d8b9bc336caf5985c1e57e90f2a362ccef5cc110d63e721398b50a5366448add54578cb7504d561962369e96729825aeca03fb49f712bee601321377c7c24dea3d87b873ba8b57b982e099f2c2e6f02ead69f418624da34d8598bf5be8a6ab30c505160c93da69f0a3f0cb81ba9db7cdceeb5f0766b1c4cc4ab0d85adc61999fb43a86f3c52cde2db43f89b83bfe17288b274e4c4753fceb16fa1e5df89a00b44c772284d0c1ecab65c1f0be21541e7e608093f08fbaa71c39f0b0b9d91fa45a69c143d87ca996a323f2fd3961a849ff3f023e70a732dc1edde191bd2dd1da07d614475a63996580c6f1bfd34739c0378abc1ae67ceee609e474a8b17b0ca03ad0bc3e33da2ca61323b6d7e5c3bf5cc12adb1bf65ed723e28774d68acece86476127a8ba5c2f7fb56c6a0881007285a21df90292d3562153e56a8f96b3ccfd48daf9e424b18b7997084e1c50cdd1dc549bc54b191d299c3b3ddfef2c746cc077267478e89d90dd3196bbb1fd5e1dec0736b853ea1f05095f23f5e71808dc88a2e59a7e2741a115db91379cb9f61c9df3ada095712c87977b14a697d0c1ae339bab43808755da390272c0008aabe83d871e1d5068db8f31029a2a913c780ad773cab175ded6f6673352ea837f7daa1973fe4f325bb999c8cdbdd85000193d9a74e5228fadd2b0de341592bf06602d668a0bc6cb442c58a66a5cbaa1c43aabb68c841032aeb0da6f17755307be21a2d8af3d89c090897df83d6e5e85c86ed08a39d3d3c9fe048ba19f8057b3bc3b03c01c345920ab294d258bf617ef121f6eb0b9a895161a45573c73157093a21e916a23108de169adf72d2cb862ac8ac90526e3651601e2114dd6cf478423742a45fbefbce0283a1dca1debe977e7cefc85aea238967b31d2d1f6c0d4b7608a3d28daf9ceaec90a512df38ffaa73229f61195b8a6c36a4fd51b4e7fd1b9f7037562ca82d5975e837b70146e73f1fe27aec871c573cd5ef60e2abdab84c242764425850a3498170a170df308d477c6d00b0923d182b9302d7586fcd6661fd047e9ee002d270b3d5e9a2ec54cbe462c42a64ba5541a620f87be9bbe78f96710a473eb978cb176bdd6f8065e276a0642c4af62521ae1382fbc55266630876b72b1a591f9a316b53701fa8a56d070f00e3a7a2c02e0394217c5abd80da2b0aeecd84156647c4b4483416a17455b089ee246147b3033630a670a0164b4dcaadca8ab13c2c71cf57468f3fbf9c7089660b7c97cd85628b834546ba0dc2e8d3ed1f33155f6352a870ebbd9b05cb591233671d9c6a875690ce8e2fbaf0ba673355d7c0a7a843012c2a53e12e57c4e1d1ee5103e54aea170a706a229d06e792380d140beba2e5b486fc54a4ca9865e58901422d83c9ce6b046d6f6a4b4b91bdcc631ca69dcc7c65415880643f23834dfbfe79b13069ea70d25be5b5528a067b54b40e4c921208e9cf987738dc3bbe18639045fa3198a9594de85be26f7cc956d09711ab594843621afa76512414aa743b2b73872a99d8b319032ac13c10d66d1c43eba6cfeeaaff78d4f627a76059b4bd636e8472f12ea1f24cb0d0fd0d255dd9d176e3aa79d4b6b7472d6cd5350a945821adc682c78199db11beecbb593511f22684abfb4b400d3db24b610ac362b63e97ea0fa1140a19c59f1cb56f0176c0f2e86b8a5a1565e7532d1a3be672735da4e1030eb826c6731c2f525bc4a52064dd3cff14aeefd02c8dd572edd7007843bcf936acf7b0e6a981545e29465850ea5913702ab5ce10ffcd6a222ae3085da0d052f5a9ea504e21b057cc8b47536adb9491e1202e7c2ed186deb950113485e6d380113f67df14fb3a9bd42183826f479820374c5841b434041cef0263f6a68e1caf0e9baf22cb5a97d997836e96ddca312f511e3273b0637755b0ccc93ec9dbe55eb0bb4af24de66fd92b3187e2b6270efc2324e314573af91a1a5459ea3fb90563f53a420bd1e1b6e8a0b35c770a416403da9f0b9a76bea8436e76824839bb56f56efdb0a88b68eb986e033fcada836530c13daf1aa0ef4510ccfbd773087a99d891f22fab235e65ad1bcf3a982db709b6a63ee222194b4f72ec01a00494a1bca648350378b35454e8218fe006056a975e7898982e8d104247872c0005a150143ac102a75bf0e0998793c590c88d505415a995783a54e339d819858447ab17c248c8b436f295f891daeafcc3eacb0c404a3ab47b67dca561006428499d9710a49606b3c09c551a727dede50045a310e4b09f1edf63aa0e7bbfc7b5f3cdbc704f96058a12917b6aca8366d24895a093c30bcb796545962c3a3e46ac8bfdd5e20903bcfe9cd519f921f9be7d8ed83d4e0c5f397a13bd0d3eb47f9469a8f43568a5e0b93dd66094c63092f63d6135b4f00bc09f39678c58baeb31b3c23500e976edc8b7b050ee1173107c26e850a083dabb315e163940babe23bdcd2f873bbbf25aa4a9e090fa00b6abca9cf00b2559b9737c2c857586937cc12579e229b922001c7989434d7e85b46220f1b98805b0bb0769ce9812f356e665c678d5eeeb6173c550c8e484d58a4be918e4d08a8363e44185b658ec32b3f1337b81c68a5027cf6c3888127ba33db17183290118ac5e7febfb2b9aeafc49ff18229c5f07fa20d340eb3f4c082ece1413e48d2e28c8a91536e333fd689088d2ff138e1ca3068f2074ab4723447af1ff1a2e1f65920883b3701642d69349e45465d35950ee45bbb35cbc105fd453e44a9ab6b96f75704dab9cbe070d3a0e24299fa5de98d4ed7678e587b0c1cb6f2e37b2175638ce0f2ba22b6cfb4649b703fd40174b5020cd9fa3ee6b826d6b989ca41f9dff7bc99e53f9481c8e7c639fac00e687d5b6353042389796eca3b4c7be1fd404fd2db544cb7276de985e089e6bc8e1ddb69c3cd6bb8e1370182d6ac6312ac60425243f37a09c504925947b7a4a081c3da6624ab6be390d4f1e7641aabf5da0e282ca61d69cc335e7e1c57eccdc5cea4d04d664c775dd61481090f53079bcda58e96d8689f8891bc7b03218de91a9e394226a776d092fc769020d31b84684fa42c62e453781fd32695e9c212fe6539dedd0221dc43775a7015ac359c7555d23d9857bc73162e75a95fbf7a8b3b0f52d084d4129b0b52a2ba196d65f64cc3d27474e50482f85f626e452a4f9f780e9ff8d241e90aaa29e560238e60a51f79869ff57a19cf82b9a4109ed4667847b8cd3a70d1bb41bc5e8ed1a555a16a718d7e1ef011229092c3ba64c1069ea603754cd22d12534b03aee4a47e09437788a580ba38a1505b98b2e9ae5a652208a5e525b1bc5cb45e14cc062376832db0bef580c80acb5036afbb8ddb6b0eb399f1c4b223fc21591540e749dc8cfb2cbe44deee0a144314d292ba8a59e82681e59eecbbb7fcc85d735bc656e43d7c214344905b7e9108db0f743716ca6bcaf6554a49a8d230a21d4e9deb3499d5241d734f88787c19993da633fd41ee29845a0c6a70c46f97f6a40ccc0f3fe7fdf5f45f3c49ad4f3c8d08987975d5ef67cb4d5250473db1502c4f11274ef273229e9e93a95ff8157b9632272435dc7ebea63e8a3101a986e1e3c5a76da01f9abda21de14898318b83543464294809362d38f5f642e0f26e043973e384df31393472b498e3e843374269bd92c3927bc124d46625e1aab31f5507f4d3dd192b500d103826f7c68a0116cea639b39839d67e8770689c9273aa073696175799e670996af1e98ec4235489329d9b3949b5f0b3cc8f8b04792ddc977c1987e5b3ded8dfeb794e9adfa4367810f9a74bd532ff7b6549e487be0c6caef9efb4f6a7d4332df171fd2e5edafc1f198dcd00ed927780801d8e10cf1a8342d09868b65889d25f7a2936568ce51cd98edeb8f0cb5d9e00c6c8c81cf5a39209a9958dfbacbfce5ad7191d0d7e85d01122440ecec6dd1100871b00bc24d7eaef98848da35d8264985dc9dac1662b7e1f93626916f72761db61196a9d8963bfeac97be8ceb99edccf2dbc1c7760e13f140d5c4240a486cb9f6372033b8cc508eb19f735538fc6bc457737fc24164adeebae96c2dc9e8d05dbb6df2d8dfc7cc751c5999baa3fa9b8b2279ba130171c49a6a92861bac7ad01a08311c26b6574e95588dfd67a3fecc691aec0152109a642b0174ba8847263b1e2ce99f39a755fe3ef23d77579fa1fe315eb566da9cebe04ca4bd2c5aade91d1d1eee5bf13efdc96f79d65f17c143febd93963a254b5202164fad6e5ca03d3a1a29e2303752799d930b3e61043af38d481369e98584a24674df189801871c51440c1f9cd08681212fb57e8a302c0575987c73d27c8cf36aa0720ce6a8baa611232910c6036298f5bdeb67731d1b35305d32fee788acde62c917c0bee4f31a1614c98288aaedffe6894c186af0915cab8ff5da21ccb922335e6310c7360873895d67b39cfb3c363d0d5b3044d400804e2c52c2e1ae53a35a86977fc990267e9652e4b12e6a61b8810e698d42a17f0d28042efa277e680b87a6f567cbd4485ddd80c5f69137d1121de0a1b208588088d6d9fe318c23c888f04649ce6a129b7a482d3f3d3c61df7e918ade51fbf63a4949fa4e1e77eae203738d9b0a6f43e6baaa70f502f5e1bad225797324b5a169a209ee4d7e526d6a8df5790b2c3d206b9e82a7742dfeeeb04be60aa3d4b6d8bf0ea9178258dea0a78c82a60a1c5a3591cf9c6294e6b1ffe1bc7542a824ba74db998d768720d524fa6c9ddad222c7b503a9f8f95cd9ac5472a666d261c14bd9e7d6d98024632a3cf3ca469e088920b7e289a0493df4f04d2988f826593c28d17754a5841eb79440e6001da25ec5392176fa23b5a4102884bf53eece35b00d9289d94e752a7254e56696ab32b72bb536c863e49cbf0aa224346d5aeecd16065a49f34f877c3eeb9a89742fdb53ee39ea62e92dcf1be7807025e0cb5e9354968ee3afb84924bef1ecb6e1ba5ac77a57562e6cae0c2ff876d8ef2334a5e18f2d7e310dcfe17a89864d35eb28c38dfa1482874294269455d59c307fe355893be55700c08f2f12a4b16ca60c587a2fff00609d8082807356928c32c103f8c61229a6c3f716066c9e5efbffbe75aeea92657160293caf23ac0bf27b5852a9b6a80f731337516cc6a7793bf13b2789b4f9c2cd34d2a297053155e1d90bc30af8bd096b4a8dd6e0b2e3d5048ad2b2569ca3832f89fdedd53883d74a1397c0da41ae5360c7d979cfaa2480458afd10aae854669e9d175245e669a32442c0b9eabb040b4124f1102f453b22a5b56d64960b81c0a98764e72b862290945ee7c8eec15ceabea560160d7eed8fdcd606f89e53161a7b512a17edfff564bc45d5766410a1450d30bcb27c411a0f9d0b2f7f4cb3566c38e2fbb6d1f9874a238b6beb62b88249ca27b6c773841234f545ea44e92d11f67c3399ba5ff1977d494558016aed850b47582d7d6231d3ccfe4d88a9a022c5b4a91bf1076f663ef8cebe4483c6eb7583a6b34551d43071cb3a8435a7d690a63e2617211d5e6634c545e544a2cfcc3987f8ef938c0c8f5bedb1164a24134a3ac13f5ecc21a017b222d3bb6a1c8673f141df36180ab8c7c4916b4145ab2ad9d04da7bfdad72262783b60f3552ce79cb1a7cd693c66aa236a75cfc9b2c3018c5104ddf0f55fabeccc1e245f5406fc95d10049237b9abaa6f2fda696b7eab2ae60f178a36af231c3838f6899d5a975f670c4a8ee3ac48f41f1a14b64f07478c5a8e92862bb96714eff207cdbb1e0a0159693e6e2ee98bd23ef53d8502f2aaea7549a194aa2ccdc3c348c22a5831cb38da397d4ee638b5eea78f04f8e3b0dbdbad0384b399ed275be620a088f9848f3c15ab00c838a8fc71f7f0365566b6a4ff7a122fa423b5860edf97c9349657198c466e990d04533b5808454d7ba6b9d0d52155922414d99ba272d860b304a28993935650d6d61c72360cbefc2edff905fa9f5d3c244e3dcfa1948d266d5c785c1d4c26e8a36fb07598f337ea067eb0d2f355e6d1416365978042b444feb3c6bf3a7ad287f9720e3ac3a4b2d660dd74d08087e305fc005b1286345a6a9510e614bf1a92e1a15e491665490ac34375dc5b47857414a61dfaadb5efb3b9b72fa26ba07433c830d7ce9c215fa4ee650ab96df92812d888c3a219a78195d231590c38326c29630dc2d0f2cba6ec21535d605308f266b6bb31108e01e92d7a6a8f1011b3431a56b0ae2400d6fe995c569ef2b6e3dead69297e5b956dcf4a82d98bf0fb4ce2fe1cd2f37483cec18cbd5530628c7f6d7c518767d4b91e5cb653a8f580c9b9e0f7714b73d0d35c30359c2ae6eeaed3ea3b8c4db0cbb3f783925f0816d15f5917119229b07566e45ba24a129acdbecff76ec1b4a288fc57f55c36b0d51426941eb8be2e54e0492a366ebac87cfa74845705ee5812a3aec85fd1580fe70042ecb65e8d41933cb5dbc424a8be1341549b57817fea028e0a58f075321a37abc8bb4a6b1c065b297eaa02aa8fc5313d88d5dfcb8ef68e8174ab6c8fdb4893d50685306e42eb12bf34609ef4dbcce5adb90f53f04eb8cb11416b8648fd9f369759c4c6d690588c11b797a489a3976ff9aea2fa69473084162682e11e2476b082868d5d24802c2689db0d52da9b048f98ac572348f9607f93d043fd123738a589401653f9bcfd792904b7d79a39d4d5b5386d3a214fea9d48e2e5281ea6f0835649093654e9432e4509415151cd1b5ec8c2cf05f9ffa94007ad1966f62d3d445ffa9b1a2a4818ef61cbf2a10a3eaaa1c714d6bf2d8a05152b98251f1665318896593bde7cccd011391de642a72eee8182008bfc02c115a5de2d9f8cfb38c4987b99e13cf5f6913c9c1c4b481a3080eddf1b6c8eef8263d7d17fe6505e6876877f6b670e384677d51d048e80aa82f68d93a9e383fa320515d70c4a727405f3f7f70db53c138874ff60906fbdf968669f6b6055c4251391c65a2b09b5b29a9212c45946efd5ddf8896ef5ff6cba4503be633bdb7a3ac5a5819f82df809b301507498a2ec9e315e7a53f594bccbe3bab879a7e33998f3b3afaae402fa40215d3446da89522468251e22ca8f6b977920ddd9ddadc694f9fd4382fad6fdcced72adacda44f9ae1c55ecfb2ecd677b3081835e166765d66e5581de28229986390d4386259ecb76211e0bac3eab3ba204cae1bd83227eb71ced92b917521856791076bf50a4fa9c136e050ba8d7d3f108f63c2a6d950d907d8a2d48942e7621694dd3b7455834f76d89938b93c09fedfe4ccade8b76f80406b8090bc9bc88a112d1052c4cab04cdbb1365e1e825bb0823ffcbd54d42b563f57c0ab1cefa61142225d8f4c62c8bbf65f458151e427dd58c5c520346c2cf6821e6c9663c3636747b87f93a550f6016778e6bfa48b6c8fac1d55b68e61ffc6e076ceaec305b53d5177dc80803ff09020d6641a439565f551e8ab750ef50939268a6139387138985973e56fc8a4c8fa6e91df3c8e1ef889d82d98af252998255d6008affff2155969a9e9bd88ebd949dba948d0e85cad3b40cb22479d2a5a64c9fc341aa269c913a13c6255f5dc3fc9f80816e5c3de42eb9a0441a09369031c1f3c989b30ab5f4c98da8060d6847f7aebd8577c04e134a8a6eb463d8b4bf7a653304df959d316570b6aee924451c611f9a555e63b2b6d7d196cdafcff21b8702748373eba796d38a881de9b94e0d4f1bfe6513c117f160a3f83111c6afcbccfa57bc8a4daf8ab850856502a5c084e6dbe653543bd965bc107198a33908f607bd625b9d392b2493ac93b5162eb5435dd127b068612e50be37dc485a39651b9cf34e6507187c39f55db6b31ee9a9664606e3d065b34d7529b4351232c6d1b031bd25a8fbd71af9e23334882f3fcf8288a75727c193d059ebdd2b96334064da7b8af14a87e47b911ad47d7cac2501d34f4ae7c6e3e59139c29319c6badebb3fa1a7ff987eb121e6e8babce21743f3ffebcecec56da4f8f1246037b5addfc9d71f62d4872a9a9a4cd95f142cbbe7d04d7dc36bd0f5f3ffae50dc7df225251b4e1a90eec6817951ec0f80df6e8695eccfc033043cf61bc351a490f03a4b6fe207aaf041a4e3104f812a223f07f81555e04bdf111397a3cc0fb4de45726d5ae95adff803ec88991b25884e2a81d7cdb46250e8a52b4b5b4d7539dce18c7d9d05bbfdcd0c1c3ab77ded8c3996975f15277ba17c42f361d233cdc05c34a196074162c8b735720d721f3a04e09cd804c9ddacf3b627f83be812765066e978f44382bba90d398093f776287e0430f36b829fdca4163aeaa4abcb8340e2c84f66372dd8b60ba085bf3da445a8324f92bbd1968e957aa603abeeb07e33924b50051091b5e67ee80660fb7fa168ff367d877ffe2a8137eb455c83b10d4ec4a761493f6251988ec5ab0120e4dd4613adb7a9b291d06ab37c30be38722f5c9f76f5df67ba0c700dbadee6bce000dcdcf1ebb98c96b2c39a570dbf703f80faca6b15de79a727f69a7fe42c517eb85e3f3d4a902d50ff76f65e9f1b47ec521026d3d583dc52b850be94355736d2af52e9574ac1fa75d1130892d317fe747281bb8e0d71e82f45bfe133b2f4ed2211643bb0e397ad5b33d676dfdbdb6b836ba862edc6fcb5d97e6c414a107934c8e68022f52c95cf9eef94870080fdaa5e728eb375411c4929ead850ed1050743c75f93c76845e3dc07cf55ed659ff5601d1edf331a9eafd783a3a881211cbf655d6c4ba3ac5ae7c62c05779cfbe84a72218313ab0409ddad2548d375f69dfa9248ae2f9a3eeaaf3c44b89a9fb9cd7e039b484ef0443ab389f110e5be87e6284a9f22d388fe73fef55479ede88aca4f1fb9d491a90e296a2e15711f1e8382fc59eb2513d754bf3477ddb35bfd92d9b78a7b70d47b60fad9f8d6d1f5fdcc587f8111dcf5478443cc204a16ff5f2c86f15191e9c7d60a606c8c7feb4b76a8ab89495d3596e4b4828b08fadb029a3b8e027418123697469b56f07f3e0ce2dad3c4749966b459ad34cedd4226e38d7e56ad6ec2a7f54679b1ae3bbe684e1c94065696c0339a1dde3f70fb3baf0bad1214368e9a535497f8c3116de3e639fe9dba51a386dfec5aeb8ed9e91563c3411db7886574d73505f4510f9d008c8d9b5e1d1c9167355e596f374870eca9c8c258d9ea42e8f014bf9b8fa55881f794b7030665b0d6b93104a9c0bdf10dcae575f1ec5e345b7da8a836690c06d7e31e85cf74d1535c27bd958eb921dc61f9921c0caddc226e7bd0a3e9f16744c6b37da7efc3297caefc29333504e52154f039972a8c0a9e0f03f1bc2fa74bab14622be8748ce0edc42e308b8728894ff91f25aca7aebe8e8cc4a9866a6557b3ff571a9f46a0aa9974ae3e8034a7ef3d2fe38112f2281489aa5757357fc7ad4cc4e62bb187abcbfed8527d53af238d74efa1af326955715680dd4368c813287fd5a6882670b93ab98acfe46227eee4e7a94b512c1f435eb64e9a6f5d8524c7b5c215bd1256a67e1bc1cda564a5be73f852b7bf583170ec7ebb82b56ddb754410e12d91df68b9e4cdd1aa16f23be41ecd014fbbcc6962f1772473c6fa7d6e4d49b933bd2061b7aac9020a70e02a3235da2d431ae1a815fee4e3361819a9d7b91c3a5ee416e480b06f017e3545d1e99cb4a0147b42f14b83e5d43a0f89f714c479b50367c8058ba0cfc594f532321dec1ad916f1e647c3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
