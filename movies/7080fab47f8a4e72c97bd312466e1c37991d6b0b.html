<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6642477fd04de441c55ddd80a56421e97c7310e37692fd3acfa25e57650fa4d792dbd33ba33736a329921e7812c696a9102cc93368908353842df181de7fed09bdc076f6ccae2f5c35f7dd0559bb8db034ffd34961f5fda59e6ea22f51792cbfbc1a3a9b7cf2c952d17c9c19b12d322082fa81764e2f67cc7c3b6593bce9e0c1fe5647eaabbda65061b95c6b3d835b57e437116a63a4c287f4e99b3bc74486ce94567c6b3faba0f1e47f72c68c3c67a09a597e5a5658c4a284eb8788e06e700318eb9fecad2bf0e0a37a7f579decd703da0fc531cfa990f7c5a5f05e6c9b3d4f852e28fbdabd726ad3dc3da9b35a9bffb7ee914f43eeb6efc8593688a716a14956f12c173e020152c9289ec0672951321074ca9035cf94dfaabf5c7fc1e87f7e1150a853d41f0fcf7e83048c4f544db625e66605fc2ab240eb71b00b9b30b1b61f6fda2fbddaa9062ff28cd7078120c4c03cf2072b0e1f663d86eb7c07a49b87a9a6f5c67ab357f38b2d41d5e49c8fd8085e719b8232c1ed1d218afee5893b4ed41afb0683ce44b159297c42c28eec91eba99b2d3eeb6b945f6be9d5fa119450ca640bf89d42de7821d2f4b3da7d3b52dded3ca9a7b0bdb854274b91eac2f40fd972a2dcb89cefef8f1e499cd1f0e1b4414285fbfb81219aebe40c8413b95bc243aabfd33e91ea515d1b2b1ae4ddbe138c8e651d2a7367551d090ce4ce52632e7f3fec1c0a4b6e5dc62912526a1f7abf371f65559afb1ac8ba521731f1c1841610197f780244648dceafc531fbd3105888a3b829bab9c6d9164a5e32c436244641b36ceed094072c97141c135498eefa8bd9937c76d49cee03f9d42f74d0eb6a63c4da7feb57bb57878f48b2fc7f712662d35699b00980228e4228faf961ef6b69d18ce18adcd3757401bf9a8237754742d3417f234b5ee4fdcedac806fb1663862070c8996b6b22916db9729764063b9780e26c09a7e36a43b1ef90432c8ea77c6e2a6b9036c8ea6a2898beefcb8d82e968a61cd6e9beb6c509950e17a2a2d9c3e576e6bdbe6cae3da3fb0a9e64e8589f5f2c5d950ad6d2605001761fe3bdad2f7442a958b65282d3c66447c97571924e56da2532904c0d3fff02dfa508ca4f0fe8006e966d93a4cf1419852b89625f4ace70dc53d459899a1dc8394b12482a0269cbe70dea8a50fceb3f3b165149223ae539c98be4c244a84e4b6c00d51acf5abf6d1b9bce454199d3c321aaa50d6234bc4bf3261eb2e1a8a8025d662dde2c326f7ff26e519bc4149e4069a89c3adab85d1c95ae65de0066a1d646dd81f42c029e9287daf549b11814c71ba43ffeed8baff40031d2e5b58e4d57098b612aa64ce725ab1c99f091c34950ca890eabc7a23adccaa0f9583be97f641f6d8649be5a1b1fcab1b15c3c96985b20c7fd4709e9d7e43d1d3cef87c54da85601d1363a7a074122e4f2aadeda35be642b01cdd6886157ce1cfe4682b969bc1398cb2e0fcc1568aa10cd4f425384681d50cdbc817ef4524f31a3ee990c949f8e9d6aee0f9dd8ffa2c552fcca9b9cbd80b0fed2582e87093133a020775c05c3be9d1f95dccd9c5ddd078f7ab278e4a4a905bd492ab1b858a539e9c3038dee030bd364bf99aea40c87775b80998f24c48022a4213560b2eeafe174f8e073ba14195bd583e791ac5a7aa379ef44ea27c6da9edb1f056d7d8800f79681b242eb127575914c39553e5d2bbdec2e5eb3e462c07455d1d241bc01412118236bbf8e9a658f1926809c0b2fb0a412442299fc287981079427760f2ebfae23ff45097792dee681f25c8f4411e3d7f85df8c4e7633d72bb9939dcf2dd871d3053d9a325ecccad8e4749540a330a4eb25d3c7fbe7154c48b7d4c9544f6ba9063f320b4b3c08962be8c55c092ef4733915ef45b52fdfdb5738ebbeabddb340c484a9f0dad2e958e130c52a4e470626a359b6e3857daec15204e92e60153928fa3f00e082a76de774721e2970c4c1d0d5e299e77ff53336e05fac75389222b45f98e0a78afae5ee5d84acac3120c0dfa207e25d95ff534f1350473a39db31adf2d6507445127087569f31829eeba0f4cf5d5bf6f3a59c65d753be7f89a84304e957089eeccc2b398580ed66a908e7990e0990d7496d3f6dc30d2a30fb24e0f360dabdde3f85ac16fc5c61964814a3418a1a4ef2b034af4944598182404e77836fb052318c30ae389c21d56c4b7f72ba055aa3e6a71926207a3cb3996c0e467ef630763d8e35393f14502b9ea34d85635d36dc6bbd036825443698ab56ba85b485e00993b4381f011d5ccf758b34e5500e982077b1645f1929110e669bbbbede299dfd1eab7dda25ec2c57f92d30b1b59ba5785fb8a3743482403ff157aa8f7e326f8df788bdd23d1a927e9624f51771929a14f74104daa772b7c63645dff80b2d6ed0e723b73677a87f75870f73889c342e78e8eb462fb73098d3f9331705d16de5efd38851b499bdbe4949582df883529d840c7ee079c8024755923fd6bcfab0aa02274bf9ed8cbbd8cb3216d4b590e40a7b2d8056ffb023afa525449b05153dc9304528611c9e8852ee6547234c2fee18a412e0c91d28ec2bbd94194e512b2575e3c187833ceed77cfcad4927d4da21f72452fec29e65c0ae720c4a7ab90e13cddfb9e181e23f6c8b4c749f874c61424b2d5dda97091d67cf081fd5f6ddb896954a20c41c654914f663ffbe7c48a9e52b428d51e6d681bd19b28a8bdcd7126ef4798faff1810adbe2556659c566e63368040968f1b07e2b0b27cfd14ab2d97f6dab56014c1d1cca83460cb69abcf2b026e3c593b755a5aa3961548a12144a5e7d3d54a3f278fbfc89e87b3f3ce9b49ad86eba1e9a67c064668c727f7bad6e60a1f8a8c92abd481d49717f1749835f14f68b4b566600c408301711926bf8e9a4576f26750653210e64710b423072ec1c37eafab6ba5fc8f940af735abfc5653d6b94b01d45208d275d85911b7dbce716925d480deac3523a00db8752e239b0c78bf9dc7bbb10f700b4de9f4dc10cdc7d90857238d613fdabfde828fb0ce5ca5900d66933315b4f6afe2057b22c00c02d06e4d6e02f0aae1876cb414c71bb9fe9a74bb492e8a77b8706c010a1f60893e30591dfded8c769bef4ccc5a741e2d55495a46e521ce6e5fd2fdd78b70f6605d761ca7f1e4bcd2456fd92099520ce517080ef5ff00e3cc6cbd98e98c51a522757aea9339366cd255303bc720c6a92ed277ef0d27da84720d43113b90b906fb84c2bea78d4c62f54f89e4753b0b5353661687a2f9cfcd08709248f1b60128801e98fc2e78de0acfb83140fa91ef4ac0996d6b5a37ccb07c13a7a14c8f10ddcb30c695f88d664e6321161918e875119e69f479316b74b8a78ad6505487f182b5bd93f8adb1bd61bd1a794aa8d042f6d7c5907cfe44b5aae5a90c24b84fbeb91296eeb31aa1c3c8e6081b253cd6eb732a188945dc18ea8069100f9aede5b8123b1f015b4c1421948c1a38b1fb1dfba8d55dea915e3101fce0c90eb57265925b92b343ee80bc04fb992b66439dcba187292481b0688e2d63523b2aff3a92e14c8a372f16afe6a1b4b81fadd0fb7d29b17bc729159ec3bf776006946018c59403d9ee2eae734da8bb216dfe9a1c183ea39a2931ccf433c609a9aac07c99caa05dd6819dbdd09aa1c22e70b52563ce450ab7a1492081d12bc2e81d04c8ab289d318e5c51d02c0c8a0c1a09987f26b44f0e06bafa1b1e61c78b0d343a9a54ee812fe2f055cb0e7766368b2359b97470293c0cf47cb4ae73978f93b33dcb0001c0bb7ba30e03c842fdb3f676937d9886591a12da99373be14da9128f48c94a6ab2ae9bdb1f1ec5b2f57ef7eb2493b79705b90d44262b51c6a50e50e0589b4ae29c706c1b11942186c76d5607d17fcead9be9bff08d2823bb904b697e8bc7c61a6d417b321db46269b5cf11e739905e37884209894d84de37c338659eeabf0a5ed8be24d4a6869a1b0039f8ac114c6691c81c11b10dff89893e34e080d22ca4f3464c62bacfe8f2c6b1b346e52d394629b1cbf9c5a7e89077c8b09f5ce44d48b11a9ba5842b7c7e4727325f2b5b9ca80f765b9c5b316a991dffa45e9c589dfdb0763bcb7c947cbfa212925b2ac7f59f73564e52e4fc46530d97498076228e594be6cc1f493a65932df6acd38ca31746095fe3c9b22c761dc0563eff7e192abed7efab60abd077f3f8284d0d2e0c195d380b232f647b8c2c8e760ea85df1fb153a98a776e9af673525a3962de11e13f484b176cea5859658350294c1d06f23c5e5196342235eb5a683cd79c4cb5e7454bd42878e7c13f56f26dcde4cc045f69da8b1d3d99324d4080686da55eead4a5bc59c5445f9a925ced49b64c1100536765e50529d6578450490eb18bbcc65cde2c6af8d0c0dc5139be0c3f79f01fc69dc550aac5764fdb26c1c95ea8a91461594b11f1afb14f5c96aab295b3b2868add064d5163cf6413cd5ddde2f1b295766e8e89c88300856b1899f294fcdd02d86781144be45b4c93917497e786e7d47039bdbcf875397ba2289a2acc62233cc8684c0be91904d6bfa13f55f947ee596269f05e34dacc26797ca28c8ede30cea2fce61608dadaa346ab0d17ff732d3fc38bfeadaf8e13d8bb2f4221b491d409ca4940a9a3a0f44c2823ddec69640c5f037c042027539450e2ea0f6e2186c7cb4b4e492e387c2c1fed2198d88084d09776b4c1229d6e5ee43b5f70a858a77bab917f6e90987591029b2fd7273c8f7dede324c02cb04c3ff76773734a1c9c6993e90a2ca0be08c249c78d76935f682f24aacd14f3315f02aaac6e744710eeff4dfbb61c39060af43f493db6740e5a8a7beb0ba710a6eda36859fb379ab0744c26a60e5e15cc12f8cf5abaada4465251d42147b9f8728032713bbf1ff46729b7b7f64839b993ebd7bea6ca494c377f5499cddc68db854ada265ae9fd623e7b49690d2f3743baf3f1a473957cbca67669db793a956eb1dcafe89982727a979fdc2e303c47ea6c7c6a50f6b8107a5054fbab7b3eca3981fde8aa14e098e89bdd50e63281811e1a918961152472a629527ce41c13cdf309a1e0c7b2abd04f6453b2748fd5d02c6b9fc7042f4510840c0c48776dba794ef5d60dc4dd540c086dddae1a119f5addf46a2952dcc1460154df748af128c5a4473957fdf6cfa021c9fd2e7afa96ae7da470899472733609872a1a489dadea32def1c75e5fc7fffa88a963bb6490e59eaeebbd8f7eca899631f3e9cddd2a2a970885c17351a39a16c90338cf61f19db8ebc459744591df7c22cc6e071f5aba8b23bda1b9a22669df4351cadf1019f8b19346f2b6278ed3a62807a84c5e1414fa4a2cea57f7e0a279cc9d2cb7b56daa9e0ae0cc342ec5701b3724245fdef6ba84b9dd1bbe76f29eb9d19953d7a7dfb6e644d669d65c1218d85ae5379d4ed004d1e5fb2e422550a841bccb053b9f1079910034c0e82589c2f2202eb4fac52e9318f8a7d60ffd9ac5216f1ac72ba633436b0148b6d9aeec97a2ab8c29575599d9774c1edd0cc81b11fc3ed95079f4a78893a7690b6ce41f0e3f6c3aad5f745434e8eea8fa4376f580b7a58aa6cbe9be9ef8b5cb14e8555824e0e2beeb2a4b072134827eda17c7ad6134e545a2fc606e85126628e30e0dd18197f79750e3a489aba946e4d78c8c87aa3b6440712604b87966e276963e780ab7cc5ffbdff90d512c61a22ce2dc43afa8596e022bf92023f8f350b319cc6cb10a748a039dae19186a74a27560d0b3486898f935ffc6b3b17a06354a7b6e0ccb28e843b942a07579b6de9ae683655d3c14f604026fc3cde6e3672d752e25c9aafceaa41f201f5f58bac2381f9ff6df11d0df6bd7347ea6d46e1f08a141a5df7b774df2445a9f9b5a8424f4e8ec80743827c63a0be84c9fb562ecb6f960998f0f7c6568eafb527c8506ae14b53422ef6315708801cb1320e75359c8aabece4b489d67bd6272601fa939dbf9979cf78d557257199f47762bde7d5662ddea597e144946b6b8092aedf1d7023e1fec30098909c8789762d70cfaabd03906d91749085460eb32d96084aca4a35ced0c22bc1587324a4a325b8924097559d84d158ff071d78396e60b4a54e5e43ac37d8818af9413f9f8ff48871197ba463cf49936f8ed2b6df4410d8ddc2e1ab0254f87a2685a012ae55cb94812bde02fd08c20ad22c2476d3251024106087a3abe355ad1173c831debed7485acbf98895afa6fb54725875c104dfe625d48de6dad77ab4968fc2be2feda13afddbb58639932b9747f960af7a92f987e31142f470c5e57b000f657f4f38d7d79eb61bbf72715c2b0e2e81f23d60199f8c9df8e1f49a0d75de7c66dc29d5d70a5355fc51da93904069511aa84e60c2cbecd5825184fdcabbbbdba027c35582472ba4fa98b49216d0e3248a8821d351d86a252005bbae8e53d708ed7486a84e22f6a795ef51b3ee30d61c5814b7e5544b267c200ca299f45c2ca2acabbe38a02c903b3eb3ce810f639e3b1ea8b604b8110eb0b132dd4dfaaf9690add98747e941197331dffa628c721d4fc143a745d33126f8fb974a8d72e2c0a3e6ea15cc1c772c703dee511e28c5a8f75b222b087f9322e7584fdacef7c06b035f66b18cf6480d6b955f3d4a15fe37184e020278fcd69810a466bab388ecaf2fe24e921fad97a99a64b7c6ef67719829385b95513601fa332c661c1d6b610309399210ead3f7d1dc7db296a0b3cefc2d1f71ca3ba1b27e41a3f82e1fdf8e915fb71f45c8d36fdad982e1f839606ed51a847680630092a13ae3cd9218b7ae03e77487f073dc42ab36de2b95803ad68682b094f885a24763d759afc9df3cd573a3d745c76a194a910827b99d7ae71af3ce2d068f36fbeb34d1c61a4612254794ef3337eeb2adc85f670ef85dfddfd331d68a9c8de395b81537ffc7dc7e71adbc5c9a2e1920b1b71aa4543b9e717b6f9096b202050fd3efa9dcb9aa36ca21a7d1cece2cc24ee61fe142494fc4d4ae68acba1cd2bd4c42f6fdbe07ee456ac5faef309a04367814df237d96df6504e56104f34ef17cb5c20ecdef44609d7ebef3949fd3eaaf76881221bf025b7f8382a532a2e0f519ff841e03d281117c263232c14b9a041f1b7d495c0b4d4754439e8738bf1199dc23446bb54534b3d7808920666f88b2bf1b9b5125a36c5906ea94401a5ce4ed0712e07f138e3332d6a58115ce3f6957757dcba699a72ae18333040781577223715a0b74d5f505ec44d48ca51cb8ea5e44422af13609421efeadbec8b3ad23026795dada279a962ddf8dcc502f9ebc46fe874e4f18fed4a0521a0ff9994ec7159841078b65d516db9bf8f69d5fd9622747e19e2bd7197b6d465dcd633dcd14420f81dee4fa1e51095159f9c901223fee823cdbf8974cec3da35749505a6c4c3d9e27ca11b78532ed6c79060dabdeb986e9f9a1f59f14e80a4c88bc528a8d8114e8d4213f8445bc2d980d35e75ef9dd8deafe962a982151141bbbb4d979e85bfaa3c1d5e14e359517643f647ee48d281bc8a90687fc1a18355d8c856fe10d9ca6a2b68bbc35efee960f6714d30558352ecf738ba53feb338a2267ccaabd02074d97f8e2b6ffb5a2dce16a7b1a49d4af17f24119cfad06d388d6240c79614aec6b4e19241195526185263e63f425d8c37572953ee7a8408452ae1d8a3e15cf441cb43106692b8f9a585c0f7a777652ab6f11d2f072c26f4f8dad88bef029223275c3b6800c39c7291f15bd246910ef776fe486c47c933c19eb35afbae5911d1942fb23c55fb8426c9b4caaadab536ec931339eff4716763b5f259581602cb71dbcf669635240c682446a1d27d00f1f5e1ef0f06cb73bbff58de389a1d9cba60cc50a020d54c2c242c1147b40f0e1272ac550c0f601b0fcfb40ae4541e1126cafaf96f2f66088ab067b75aeae6a59f7f1d282b3e2fa13da117f91b40c04bef3157e076702f1bbe32ee5e44036ece024731bae01741cb66d640c4328640d024a57db400fa89bc69ecdc1f19d524d383a7fd786b97db736755a7fcdf0a9a63e82df6135d93300ac63f255bc3e8d459dc20a947fa33e054d93b478df07f10748d4f5e1ab64a59afedbf0dee28ccfde7c8b4abfadab0ff8065f03499407daa92aea75834d6c39c7e691be854fbc28954b74955493b96f207a8cb82d4443f8fbbffb0f7ff6d13b6663249f95d3c0f79813f746f7996a46ac93f063104029cad65b65463a65fadb7a998e2aca6489ae129d1a46c2a1f917c32853c66c409776f0c10d6ed64e470ce550257050575190e77b7c523137c330f4a440e519d900a7e16c9f1c1183d7ca47cbc6aebefdba81ba6421ea13422a84c5c8a9134709bcc642300efd5e43949d75b363d59b72f631e4f35e628185efb1e957e35657ab9266ffd86e6d9540bf7e6558a45eaf7f670ddbd7f23af467290480e0ee26b7f1b90a1865a70083738c1f885ee57e102c4fdf0651636f4d730016d3c029427ef65e7bd94f33129e6032cc4cccee433170e018fa55791b8542dc9d1c47410f7b1d96b667733846cc42dfdade0bb3757dff539bc0306ae98b327293fd4fc99667e41afec12648e767be3c6fc5f28967f13a3a4796cde56da5fc5ec6cdb3956a27762b27a56c90a70cd1c60cfb51f7e1e484feeb767baae87fa3ccddbc66409386f4f76d1a967d34798d4c1b03d387af7812556b63081b8eabc8b0c3e4ea56d954842c98f7e68c2911def0e2a4fcdfc6835e29a1e3ddfb3b4989384eb5d1b9f175cd088793aee49d56357515192186f181dd4d335fbe24ce9d312b1037665ac32baa9b180df1c6556b04ea80ad4a5e2e5c9ddbe3ccbaf501d4dbfcbd41606a12e6c9ac479282d0ac352ca67101bb05b577d5a0bc30ef4d3364e92f5ea6da852ecafdcef793cc9815373c054777458e7584e52f96d7e248b681e56225d40b7f75694ad09f31f7dfb6ff9779bdaa63e59c785d100cb0ea546187a0cb0402deecf153b6eb51a87ad335ce2a7015e36520b2902c8ea043e4270ef13cce406f5b53fbd4d35a74f3db70045be6694bdc360813287371770bc27c2d992262ba1d0af53c0aff914b6cd853cd18aa69401437e0f7f8a0d592521da2228be542066f90e3427c32ffd294989954f5eef61c7279747bcff0ada6f3d1ac973d2ecc3d7645834bef95500e3c4a84970900cb491058746965fd389e9f2bc5118a9529a18181abb6db7260c429983d849d5beff81f2e9617bc2ae95da3d9ccac8133a12120e7e24581f5cd24d87a30a2138357e007ed8ce1420e9e2abf4ee141c2450ded2ceb1551dc14495193db7c66deddeab9b962f00be23cce757e79feff8a60bbb2be0145526a13c02a4223b34aac47b126b60029f36fe477d823444d428811d902ad84f1e1f73e5dcc1ddd4b335924f3336a9555d9e20d2082bce3c57859da9371a259b8dcb10c8612bb26e27ea3b6bb5b0b95f89a3a6d46fb14a5c893c34af59f02c13100a132c8d01d4538aaada1c37aa8fcb7738d0289d847d4815143675bc8f826ff171ac2170d6538b5c8af03bea40c0e4985120ac449110abb9138fb1c401a5b750150ef1d641dd75adb404d3f374632497ca1bba310d0db396b88f3352967c164fc9dc880c8e1e122cca1ef57c4b389fc9786ffc78ddcb3dad9f90052856d5a55541e8e9b2071afbe160e19a2815b16458a4962d73241cfdaf2d7efcc3425dc0e005f650c79bdb0765a291d984c9a33a8381ac973c15cf01f6f3866b39be670300799a83906fd450d8238f5a034a29e4021d7e42e70fff88f6d47a5755bd153b872ac42fec03a83ee62c7c8e10faf8a61eca655c0e26a53f5a0e1913492719a37674b2e89f6288d135b5335a0f36053890978dd3d3572d7f0b259a4393be8e2da3bab1b1fba407f04c850d9e2c432f52ee96183399a48644601b88d40cb5e38e753ba92fbc9b4cb19064cc5daf7c04bd08951e131a7bed1a9183bd0ba1274af44cede06b9a93d3afc03b23134ebd09203c9783ccf4774dd976dc589a93f6f6ea52cc7b81abad10b272424152152618ca48876442b572d1eef4e757437de5d50f76356a6614cf0e820319bfdac05fbdc7747f151255d31cb11fe5dc495586b29b317fa800c83226a6f42b63f07656a9128cbbe192bafee3bc0a8ef628ddc105f6fc496f8e4683262120837ad94e290c78fb790c1ec706bacd1cf1e58b303f68ff5050ae5dd26c3af867a8ce9481cc77a43292b56a6a189e941be8f52ae76f3991cfe0329a0a8a9263c719bf2d9d79934c79a067398884f6f3c59efefa1b8b2926033535e33e17754b28dd7e6e0ef639f4ba9eda9020dcb878e4676525287fe5cc15040022cb01d93c1ba8e16255d5931870747d9e36835fb4a94737959b28afe39c86848f5aa858b4d9a1d1e385c55413dd8edd6b2af123dc4d007303ea2f3219c9ddf35da338bec25d8f32df642ee9595e2a71b41490ab104267e8acc36f8e6b4289492a6459263695d8cc41486da6efbbf5e281035841323938278b128b4f69a75eba5a3b0c65601ca61d9dccc3ac8c387ff086f690e88189c2dbf6b57f1424091d31f625c8db04e494644851641b6670ec1077d0d30e44edec6c049063aca7cc01c808fdb989b89d33c21002b09d4aaa56961b6768baf9464530816b63d914963372e45cf8600f2be62bd0259e5ae2623b6ad55832f70ce61ec6447f948a76cf818c089e46594fce5e2d5613f9162999dbea512b67f3e497f433d29c73b5bd70ba9cedbe5eb05291ee08c309643b3bf2f5ded5a08248ee30fd52a409eaa9e453b6ecb17a7fb921473c1391f56d730e4cffdefd6744b8868c6a2b3251b43d4cef2db09e07e0695adb3f35a5dda92aeaaf7939bc19838aea1ee3954cbae0828f5407ae009247de760341b4cc2ed991c486d22c9f1309996553fd07cc6ecfff96f0afeaf23505123b6bb692612a5fed65166be0e40db255dbea45ceb1a19bf13d57eec4f3194e8941e62c10f557a4a85db9e92ac5dafc796df2f8ea3c5fca998cea99aacc1d7d4627ac3aa4dd5a6c1f65d3278316644e138b00a2a4fbc203d73629ddfca40d5f7ae750a5f4c681ac485f29f0ce3856f5219d68a28ad028df8680cac9869b42495b4727593032eac92f5a76809da524a1a54f466e5c603fa97e5f0046fd51658c4942e0e286347e3b15dce3533b664631b7f54e776dd15a540684cbd438c58ac28c468e09a0c04d27cc26f99b7f29beb0480002846a7dcfed7e1bb96bf5ede1369ea1f01c286ebe933ff4400554288f1c56f59c2aaf6b036102f62274263fb1fa1604863e423625005857465d69ce0d4cb741becdc42492d8529278fc6c0ba7d43f4dd1ad7e11da73980fdd0826309fe8e3ea99a1514dda85c7b0c14caa38f3f2ed6807deb182088e56ab337819b5c5e3b6b3ef76617ebba71ec965337413c0ad853d8d7f0cc54361ba26dac1252259aacd4501f6bf808231f08fd1931a905bc0c03953ea8101b96c5a0e25e725760c5c7d3310f0cf8f4de72fefaa9adc7e26c7c74a28ce5d2780931098047f43118b61ede2950480b0575c3c72ecfd770b856f6f9d7364aaae40a445150fbdcc3a67a6b6d67ce3a5ab07becfdc99f829849f01ad225f184f3d39dab0082e762907c3843b3cc56105ec73d1299a1dc2ab0d478407421aceca60f016d7a2d742bbd2732369c57be8bc90aaf76fc4f3d0f3545b6c9170e492fb2bc66b1a909707491d5340704d3a8805a84b236bd24f99ec23056fe2ec1673caae7609918a17572e665cd5ba808606e54ce32f99196451997b47503a6989eb4cc05432d2d74d4314edd77de54a25bb4d531804f2d8d8a71535f521920d5eb57d6014e7ca112930fe281e5889507953d1c2ca14d9d54f2722fcfe769868a41c3534b5864be153bfa7deb3f4fc497ec0b6e9c8e676ec4d5222ca1d09df22690ea1cde3b4a426b18df161014f3fc565a0f335225711ba6279dfd69d4e1c1f249a9ae83fd5b0a759fa7d1846868b487f75fa90c3898312d335a6ea40cda83c3795fca8e5efd82c40d73816545d22b1aa74b6ea93de540c388c053e6dd9cb8b9f52e4f9fc30c21e1a7f7c7a6cb8a39cd7b8a3796651e3b735a6c805b94d00220d33e3676f7402074d1f498bf750913ead3281e6f1ac4a28f5ef352d1d01cd4535083fe262ff28e2ea6551b73209ef5facfaaca0d1cadabbc35b1bdb82ce87361a763369a25235bcb1ccf9d69a372c1f86fde30300feb06d77f6d904d08266b4242bb930a320d39a9d7e734b6064ba7fb1bb9e631a8242f25f0b652f6a21ad9f434914271058752f2b50aed187c09b92acb6df4a34eb9365c660a10a13ae3ca901d00c32eaee19fd16545321c8b910b35d7a6f24abb8072a40ef4cca0ebaeaedec6ffe33e43e74d980246fbb9ce456fb340ed0a37bc9354ac3557f0fa8f6e3d04c3d43516bbd3f1a4a7ad7a79ff3fb7ebe30e902a040fbf9252be3e2cc112ddbf40f3c8945331a7a31aca07642106e5b08590405d7ff718af82f5345f4ea038ce4755dd91984ed9471988a89b67419c846685ce62bd594edea21b874a6a047c82b25ee2e559579bf64763b1007763fb89f3b1ae3206b35c3a06ead08c172c5d60fc7470963a6ee5898e4e8cd4e1e94ccdc5e9805aa4c9ef5216fd720aa527454171f738a9f045e6a197e96f1c29713a427e7b4f0cbb1a596eb919694f27eee7a8ee0b2e4680144b6cdce24e92f9c1bf646ea33aeb4c74eb0bf0bbba4bcac1d286de144ad7c284ae970eabf12e3ed646230a1ba2cbfe7ad7f6804e638e543f082484d8bcb613f896839c38d06deffbe048f317404cfc8578554caebc14871e8d8b73c1a0de8f7fc6ca595bb2009185ac8df3562d3340a77cb4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
