<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"650ed3a55146d51a73669d7287d968b3ae0335e11ef944247b710b282f392ea567f38a21331221700de2665bb1f65fc074c56353acc1de8dd5cf99b86cd019e34ef2a504a20fec6e41a20f8b45af601510b074f55110a92a27d06346ef9969d97f7edc4d79ad34a6ceb36f69d0f8ce7f7cf2fa0f75268cc7a1b1301d4542a3f3e8c0ecc578c5a73aea69dd966c50ece6d1aedf1a32d7ed50f77d94300f59996c2cf754e13d107d13d76c3bb46717993f96b19ab7d77992340388d1ec69fd25a9561b231fb01302a1524c304b292db6b3b36fa041d9e2eff631eb7ed1b3e2e3a30cbd2cd002669e1f177870a4fd6cded037ea1cb7cafc9a1d58747c437382f1b43a14e21e1a587b8be20b1abd1c00a553eeab08038794933cd318a6366842afe240fccdbdd87c3dc79604a80563f69fe7514ad4eea891ce443c79c02c24bc20329f5533e5fa60a4a185765d19a213546d4feb5a9ebdcaf7c0000feaf6ba5a073ae9d8c72745ac398881926dde2c8b9773d8c3fdd5982ef722c01497a0944ff6c131beeb3be26dec1e2c41c70b03e02ee077450160532e13c9e20eabe469c6690e69d02e96c9c04f876f18592445c9ab595a087b1598fd4787bfdadbf5ebe6755b9c3ebb34c5996296ff95bc96ff2e8d3676b8e649826adf1545a131d32d235020edec53a01dda519faa06206ffb87fddea9a76a91ee63de196c9f246453ddbdc30c167d360b448289f706eb6a76f6481bc77eaaa78fd4e875f1a186352216341487dd109da6e9ca4f8c91e4d9c4bf43ae49a0cf6e5bf7f2c380202ceac57dfdc52386fb318bdc11352bce1b2dc4ac028f3ac7fa6aad9f7b6d3f627c9665b0087b1aedd392041bd27120d3eccf51cc7185c56f1fb7280da7ddf87b34f8f4aad7d47424c72944b5484d505be481b355c32144eb5084123309ff38d11639685e040198a19d91c1ce3697ec5043da83d4e2476a19e736f6bb5c6fde2a74e8070275a2529733fc3bb257ff017eaa114e83b27733f98d605c2ddfaadc76dfb0fa271e307f1b6e2bae922d882cd823328c1a68c2047fe45dccfa2195f43412a433ee6d357ffa887963d4a01e06610bf582581c63b97c6997f7b36890c8fac69c2ce99f6822b9ede809f70728b4feaff7bfb9c69e61e9613e82441cf03bb2d31280e465ec2ec355da94c1a884d9c6bb9c5bb4cc36bd8e7a8c763f2571545e73367d51340dfd0466b99bd57addd9ef7bbacbf6bb909d506b877acaa5f7fc9b5a8da1acb1da1d16393f13448b3e57faadb297021d793dfe690083a948b8a876deeb3e465aef3a2b6794523a35f3facc46426369d9c466eddab5fe2856106a70f8490431777f755df4b3894674c51dcceaf9460e691fa11304d96996540c74cdb8af91b27fcca71ad86fff182bb40502b3d82f9742a950d274c9db91ddc98eab0de5e8135a509651800518c5b706582df9b0f71df43db95dda84202c20afc3cc01e8a5020afcc31bb4f381e65cd31c319d9b4a67da2d0eabcdba5a1aa1b9334874bc52438a0e89d095b9063a304f495a8fbec213c98635557baf4dbfd17dd3267d771348f32205f14b9f36b54cbffa9e2c0f24815c2cd07c748f1ae81618ec5683379707be3cc3e42ea49304c5ab8e75a8c6a5a0135010b3754c1debe9e3d0f6433737aa39e1de0669daae87a1442f2e6a4055849cc7f7265bd7a22aa070434e366f29589f35e9f469dcfb57814287b2b29f980297264416084e37420daa5322e05ebf80339e124dc36d6794aaebc7ddd988132f66560a76f920405d6bc546800ac434bda842af9068a1e12ec96ed5b81c63c8896a6934171cefcbe5ef8bffe54c7e77223239b08286a84512b5dd2d771355a614a33432d48efe44ba471a9836e49dafb0b1000f02b702d3bfacfc83440bae08d2928a950923e0a6d4c379a4c1bf9667afde4599f0c55a252be014557610e31bdff20b5abda405244552a09b3fdb7ed3f98e47cee27c225c15d9290fe299ee06058858183281de6fcba8afe0bd734b834e696af807e3561c67c6f608345661bc4e3d048c62fef5c1ab75d1566fba46bacb5535f752e95e9eb757e4b1ed2f6041c7322e9e1ce97ca14bfb3af935960fb8e41abfe248bfbef035505d3a93f3df093c88fa97c37ceb0c782c4a6aa6fef1b2314a4f410ecc0010de1e8b32bc12c3f40656d883fe28b483350deee906ac56d7208a8fc407197f76474a54a6b0f4c63c60ddb6c7310281a16214db19f667c9971edfaf48b52e39239efe619fd03f9903c5fa46f4282d49885002552efecdbcad355b330bc208d895e25639821661d2447046c903c353c8217a2e954bfa7e7c4422b236386c2b232fdc9a08f7f5dfb4338281d921c02b2ea4a9e56d19c5d30eefa3c47360f21134f466cbe0819a0fa2bc3b9bcfb023d7f0e525aa317fb2fd2629a7883e010a47acdc60ba875be714419ec1939a105f4dbcb0b4667fd7c6d824fe329323be69e205f70a5d5ceff37bcb7480b0ddbde82147b22002e09edba154935f3932b40d77fcf2226f2151227638edaf0862561ae5fcbed5a3bc5089b028e2151c1e9cdb2f9851c295e3e92b642b14a336aaae3adba130048a7dd17731a151a860459cae52249262e574a042414b846f99f35d536811aa3f8eebad9626e96b9739b12a2fdd4244fc712a31621e6e2b7d79ce09cc8299047a18090544e31abe5e7e7c3d9888f40554c0a75e8357c348a8115d5165789e53d4e033e1a38a5c7425e5468f2241e0ce00ab6e5e338cdbc688261b5932f521cea9a94a9fa594024bbc321254dcf8900dc924a2e2a25e6fe346513ab4c8cb6e2df3093174aac77789fe35fd4fb5ecda1950a54079222f1f8a7215816b053645f1afcc0c68a8e8c4605af0954ce37f2886b420d53dc4dc54652a774541f06ac3af58314b288083732bb1d3e187fe3d7c3e687d2aed0163086d6d9fea8a98f0f200f98aeed9b8b15d8420eb4e282101641b62ecc4ea62ef820372ffdb8108b435c7c25c33039f1d62f976f69a37cac4a42a59c23bc35e7404943191c39d1c57c763d073d6d26760a22e0484f46b19524d5af37582d21ee9ad29567c84b4de768b5ea5ed49a6324a6f18999ccd0e031398353a33df6ac06102a8e22675800914e750a18cf98d8e89ae22001b48fe83b75bcf71352119c50ee4ab284ed5b9dc8e5586a49220b6f82586e73d340465089332d3d20e6b3bae70d0d31612fd987f2619259fd2b567d4c734cdb7821ebfbccfd6c33d93cc190ef14f2f77a70d806555689f03800911b9fbab3865d54349f47524d3fd1722c3509d4813620deab5ff9d0bae4e2f2440f73dd5088fac2331d51a0a663a5063ad788d33bd8a19f960d85cbed84328db254166f2bc199d0876390aa3953365ae2057cfb56d007bcb99fd8c8440ce83654ec8f07bf0e86cdb4046967ebb5e00357421b577cafd8c324b6f4014e8a7f687f6329dc8987c981f81431cd5c2b328ed65356c8505c236f98ec7a62831b19321dfd9b60e05eec9a102a31a439b7fe13b80d16031a03cc51b025362c8ab66d13079011c3ddc73a4b390042ce923f67082a09f13d83e2c5bd46b42e0ab89db320d4f4070e87eab402bfbe74bc163d53f1d12a37b4e98bcdddecb9566fa39c51a78353877220c38381dd6a6261f50cf747594e5e6e34800e40104044d4e5d0dc27e952b7284508773200d08e127a66da245cdcf81173cf22d21e7cbab4dd31f711af9278add2e2d723970dd64e064d45fe5d556ac69d669afac6513c1052f377aaeb299124d27b384d4ce44607173b325b1f2fd24d981585b8580a6a7fa13d8d7bb52de55238cae56e31a7f850221820de89051225c102743e64293f3493a235f4c7f41f9070168f43235ca67ef4f4d4b2bb62246b9da3ea92eb45a58943c3d4830237e674670289b6b80ea787f696ef70768c2ea0619ca2c02864756fc8c39a23c711682a0d1688b9a6b2c39e4bd015b68e95d6dfd712be1ba465acad00bcd23cd057134bb2f53665fabcab5a1d5a157f03d76a01b78ae564b9cee94a6d11c2f0856e3020639ffe6d2e718e07a0e5e99c3807c4d41863b23f2c47a49602c301942adf610f42bb0babcc10bce7ec0ddc8c1b8a8aa5c305b760f9e1cb506b0834265e6440a97c3ac9d475c76869d88d58a96db6a35175444b24ad1200280a6fc8331d4b7b19cf06394ebbe9c5f4a1a82c323215c80513f91d46cda1a5b2bb3a98a4c7049a6fe6706e7a5e37eea1c71d4105d9fe2a67592d34351b17653925556ffa25f70b65f81e3cae27828bc17548c1a6e6f91f389686e53b10a6f17c601ac016e182f8e68ddbdd0f6d5b22845d396b44b2c810c3c25ba1cb1d86ba38a17b2b25b52b2eff7e7cde993ea192a60b52baa50446a7ee626e0c36b7725bfa9950f21277ef179751ad7721a4745db56ee4073aa00556e3b2c275e7bc78fad98c4582048e13439bde5e2c11944621b71dc8c5b27ca1baff70a39128e2dc2c3855368a96a8f28d7cd8605e66108b4db5a87fd6ade8c2c0227ec26dc659035567e9f6790c26a4bfd5041689aa1dfd71b8ad3564c1b39ba170e7edc21f48a073bee02b1ace0f4e9ca03f6ddc9293372f9522ed2f942c0cac51f5ecc59988a11a9bd095038b4c7b18bf2b63b6ad4e3304313d8561200a8973d0d297a90af10bf58c229e1a37ac7555532931d883734dad05f52055134905a5a206f4ce24a013ffdbb5ddede5a719e903073c8453125810d2a00919982511bf3e3d03347c7016de248202a6435f22e6222339d7d8eac758058a89274af2965b067c982c341cab13c34a3c8a7324e401c600d0ad3dd1c07d49304d0acbcc903c456c8c3dedaccc43f340efefeb0a059882be24e23d58909401fa701443d3581459893e2140bad21600b62d69758974d65b073fe868dfa67eee340a75024994e244df55ec8674de7e9f82937b0e983591bffdc39a0ff4449a18885e0b166026f5c2a86260c4c6c728d723358149e4f156679a89aca8686ce37e00f023d8d2dba272e8f58b886e150d3aa71f05b617879874562012538f12476653eb0afd3fb25b20d598d0580585c9654bd4722a8763a64bcfa157f7eb12c9ff3b4279ae74ef2ff337e1ed056f0db7b7a8a639d0db6c60050fa132aa0abe01acf2593d030305050373daecc93330410c2740685e40a67191f2bef432ce707bfea703582083266b889e6b0df30e7cf1f76a62eef6d71ffc891b7fde405eeebae403013dc746db3aa713d44afb4a7fd3871cf815c0041724cdee74089d6c4cb6d3b9e0ad17baabdb80a8e0b2ed6ab30f888368e42a6f9c093eb9f6a306f779420f05be82543baa708184f9500e433d43f6a37fb69655a6e4a6c78cdd12f8f3c42f190fd576f1ecff7bc00e3892c7d871bb1043b3986d08bbb9a16e7619149c8c3025fbef7097bbf62a5ee9d9802f569510fd3c1c755e86faab39dcf2dbf94651976081322f27db9c152d37be9b9b411008b1346fac8c2daa5248e98acfa7183555ca0f81ec2f3ecec22c0ffb290064d9acf34e17678c5d718e3a05f8803d1cdb58a5c66e02701be160bb8670cef4bfcaab20c56d195bcbd29dbc728cef0a95c8c3c75ec1f6244621dd90bc4ac5441c50d465030642d36cbd70ebb0296e3a9fd41c2a20a2a98c6e95f1108e1f7e80733634d21a388482061b50ed9c3511661eb87eda9aaf8da74d321d9cc546c53679c7c8ab5604be4e083d591f552207802e5ccdf4b7067a86502b3a517f01fe10c301fe524233afa4d1b127c7680f9dc26719859574bb753e4f4262923d31f7f08d69110ff57a96f0df12a4905c0c2c59a90e71ce02494e4716f8e0c2fdacf168d052fbfae54a50bd3a60361e752d95a972f7279b0ed40563c1dce8cdb2b1e534fc5c153103a03d9b089a17b4f3c3f1bfe8054e0a8a96252e9ec70a9aa7067ec6305cef7248971fa9fab04e2937941bea9655b71ef10f2a97fe780e883ad201c99fce3735fc3c013b6fed0d345a8a7ea3c8df30e0ea3305db3bcd5abdb5e5ba9b4fe5e2c14fd9c6da4c9d7fe72dd2404eaff7cd1f1b43d67fd269135631dab3ff93ef2848675b2abcba2c008240ee5312f18e00ef9fa5df1eda8bb425fbca6397611255125763eb234f1c8335426c9730ef7ca48820ad6d5a076649456f069b153bf44d16868501e663bb32a91221bb0c321b07e4ca7e9215f849abb23b25987d381970a34952b1b1b5bc70879c1296e309e8ccdb3907f6ebee63a3a88955a0e5619dae8e7edd735e0f4450edbbc00c94eb825261b5f46d3ad4660cf78fa8b55ec6a53580e0dd1c7a5cae22167e8d60f006fbd9a881c2668f13d42129ab5b991329f5a3fb5d0ad943bc1167a8399868ee17e0ebfd24a0076d6141a693af8a2e165983c7330c044adf6a414132bf63db6cc3f44d18b655539b69b058c832e1d1ebfa65d643a3f95b887dd6bd54cb3c9b83917b822db52ebc6de0a9058d4bbf0c7274eb699207d0a60baf00a4b2aa9cc673ba8504e9fc460816a38eea7c6e581aa78f1455bce0994a38437a9acebc127649abcf45f6ce72e5e9b294d51a723aa5b5a136cccc4ebae788ba0bd9c4f3b08f76a6b4a029d5d047aa2faabb562bd73daaa0e6c9562540c48a3f32d7ae727f9e99f62d698c5c000c9553a8f8c222c9adfcc311042948dff17b23f05b0dc07e18e6f9f9b3a674c6d3ea054ae740f8eabede22a13b49e439dfc0d221c40dde6a48db0fcbf13abb13a0b64b25404af247b67bd7ee1431c38924b6bdad966259c59e6b95f16e1dc37e540c786a4e3a749de18f719ba273d95dfa8802af47edcbb016c1bb66165fb3e1402fce4852e8b30cc73e794954f70c5e2d490643a50b6d8a12a7a3a6f44089df6aa0f7204b750041feaef883952c55cc79ede9f9c8a595d16021e57d732ce5c093190e31192fd69b03f3b635953980a2e1fe4169a9c63effbcecafc066dfa7e73d2241e260876f55c865b15a1d7c4950241b007758cc1bffeb65a1d4e53caee80b0b08649c9e9771228395a2ab351efae36c3aef8e421c427141b0cc22c3ac05ffa99ec07526a62cd3de426d84f33fd326a119d35ac92da1d63502fcf037e7597d2f664eeb45e70d4d29f50b958319679d71e6f9ebfdbcbebe61034b7c085dce08575988859fe4ebfb206ef2e6908185344ac2d5216beeb97b056140744872951622f88b78f1ab259d15d282def012b70f3ba0e6b1c1afe42fe0f649349726b535725fd78a40d23fa6da5727eddfaf559bb14b0be238c20112d7cad5cb570c29d6dfaead8a0fa22dcd79fdb71e1f3d7d3834d4949fdf0d043f3792870ec83141bafdb97f61beb65b08708ac9127c704284806f6604cede4cad400650ad76cb20dad4cfd2dce7ab878ee638421ec11e328a6ba960ddde26045f2eb4a0983aa3b6ff6850e441f7fbed0956bea7845f148a7f38ee9ab8c7a2318f667133ce7baf829442691afde9820035fcbac3cf01c682f5edaf95df994d44f6c38bf064645edfa4379358b7c4b612e73b4eaa91e0043e92da402a53d46a04ccba7b5839060fee76c65264cb905beae7e63909631acbc1d904d12bc44ca3bcb23b3e1a5cad3b3168e1f48af3eb91210f4ba6c339c1c0060602c5a9fe1aa49221980c85792c2d9a578bfbec238d2e8f4ddf402eb32f253a84cd97410e47daf410abdca23dc2af951c9577bdec6127ae8278cadd30fd9aeab04af2788b834cdacfac7addceca88ed5cc9335d77213b0b1f4dc7e35ce243525f300a6c6f1a519616591e024de4826c39c8d92714f9f849f4070ee6f9c80b0a7472417cc1af80cee9f0df2177d668d59fc22c96500e70faf1b61466a57eb5d7a3d825eea9ab4baeda5e00205dee3bf2448173f7e0bbc1e115ca31f7b05627476bfad72cfdbabf7b8193984b445c6105d1a2e0e468befb943923437dc8d68bddd9d15e532b444e68685e06074b3a49e560490556a64c17d45d3e631050a070db1e31286ef6050e561514a1bf3478898042c30ebcdc600fbf7b82c477584e6b76f62ca65f624b6d50e62378d9b2a89ac9ead98936f3a90709b0b7261c6a7d1690f1c654073397ca8f8bce533ebd51c1e9cc0c8f0da4e5fc5be7ce6b45cec67be0d4a1bfb5e08e946957955136f4c69acaa6d1c1405ade41bce1cfe596090349e4778d3f7d3e130002528119e58160a29bcc26d352b8ad0ef253a6b98d2b8140a6db60f81204b7d3aceec4dce7232cd2a2e0279d2e9bfa5103e749545a66e442f02002e640e90150a995a85c894c11b5123e20f93fc88237d5d3631ea46dd7c569bf59b165ddc1779539c13d79bd806af7626180d2ecce50669408eefda2963b16d35bd7654312e9b4f1dbb7a791a5b2cd93858b33ac58c234f63da37584458c39880f2e9f4d4f55edc983492751ab5d6a4ed3c4762eb564bb81cd5ba0539370e766cf66d25e3c5680ab91140301ea549b1adc8724bc4ee35c0eeda18d73ba8569ad3414e4c18488ee267eae99e318492133e9cab2020e3aff5fdc105f144db77b24b093634e8154feadad9b76ea6601783ee5c4689f02ca9597ff416c7766816c9089c6e2c47894059170ac35de171608fb637d824b9fc0a0d87b275da712c68f82d0aa3e161780f4d760fb5768d748449b769cf3ecfd2d990b03c18df653afe829c17c1c4c06483b5eed66e70793c9cdad237159ac84c5de6b6c5ee843ffea9eab4a6bcb5717096d96533e70e9e090336cb084765af2d859af72d6cd420cfe63838720eaee83640c19ff885a70e6d959d0758821847878c5b653838c362a99f8cb63e403dffff0ad1e680b822ed84a1d10a7544960779e254afdd41f85ee153b2c1ce69eb6419c064dc3722981e60e7315ac9b9783fae9e061fce2f0a093a4e3d36bf8e74d45f61d627ebd1139311401d7d5cbefd3561914a358745870bab4687eb182247899304bff76832606718058aa738392acb61e7da602f9929b0bdc1969b2c21c32bc1245a15321a9544fa470be127e02a20e78ba09c914e63c9ea2c74e4fb42c3bac56722a9fc01b5ec9c6732b69145324731a22793829eea206c5ae5bd4d1fef844064e20ff667b9bf5b777aaa394bc5eb2f8e0ad018ae56eddeb7baea2132166365947c7fc45b1fcccd759dd184e622d490309737a5d1eee25955f19482412c392efff0e412ff3aaa9f04961f83885bfd441feb735a675429ac693615bd73979d946a9c923c7307f022cb36be68a7a97297cbd861c66f1b5038f7720d7ae623f1f53b9ed82eef8bf220335d7928d74fa991cf3523df25cfae30d2b6ee9dc66b90ce7261673f8ee3d005a551eef35cc59d51e08e1e3dc882a7882142b475667d866b04f42834cb99a74b219ba95009eac8cc199b4398ae105c14a5aa8e392c0c0044c0bdbf915fe726bff82af5ca41efd924847604d4abae3fa3d4f90a55239e4eaaa4ddf9c5f5f4c88226e78cac5dbbb4082ec037f295346ced4b1b5d864dde49049d74295142e7dda9ed2b771826de655b61c611f1a6f2d5cf3bb2ce81ebf1445960916c4e5be1b45ed3765a405d9b77943450e96de94e2e3e21f11c773909ac9e659268f99224b1a60ccf9f80be50ec78780797454212c41fb6fef385171e4a683cfcb8a5f0c6034d43e0feb1c71ca1f93bb0adae1c7a0af09c081a0b07a2041a66048d43becda35011c4d769100ab80d9c7bc7fd43fbc05d348b61db6fe9faed7fde5a682830582d9358f1f8af7f21d1b3ecb128a76addb925a2d781375139d7ab6f98b907452e5a3326dbd71ccff9bec873f0caa7d99d05079d8df0fa17d0077a8c5c040f7441f8b5238e4b54b27c2cf9a91a16db3bb1b9ac1d8f750d05fddc13cae7e62802f5e5b2918d834a8c9c30933b708c9b140d87dec7a3cb6b257e654b709f22514b251ca9411d6dc2a58de86ac50b8e6430dcd3dda789f16db81b7aed0a45afc714447bb188c81f8acbd04b214135f9751799d21992511516564afe6cafed62537d0948ad389fd9a3aecf13099e8dc083c71dec656aca1ae1536f6aed2f74e2d014f1e12342a96eedcae1467173e911993f796b61fce9ef1da9034a0e81f198a74995ec7a3becb2725d09a6203a5847a51c904d05afb0b0389fab63b9de1e10f32d8b389850bfc110fccdcca701cc5afb5622cb862b3ba3f4187ba4b0b9cb0a7d741918428a4ecc5ad8456e2d48092d25b0b9345207fb2a3a0dd0893bdd8714dea8576a9f2ad979bf70875e84b2f0e1be777fbfc984169ea6fce11ce5ad82d4704753f43626caca82eb07d047a9d70fcec308c8f056937b35b3c3ca2e82dfbbaf2058f67766b485b1230360d1f1447273238ce86cc3bdbc81e072967142b79f64e33c11765bfb4a2cec1880bf5ff55458fc32c66f4ce6ec73bc21374ae60fd80d6faee2d99c9fd6ff302e393d38d95ee8a41cc4577c9f57ac1a11ea05b72a65fcd988b091a750f635f4b63921223a31f72c120af41b270d243741f79add6995b72cf733e65231e557c7714d991eb4e1a77188abe9e06823c28a8db32a375d8caaac43bed49c83a779ceb43531190c0404bc9f4dc05b047533c4ae8de7dc20ea2ec26ff72448a00157dd142c56786b9049d00d2ab1b4bb8c102063078f1a33a7812f60557f5f7d4d22c0cbc8aee4119918f83dfb57673716d4c9d2fa9989d6c9ae67d177ecb1a97e0fceacc656b67075c08ac971d4a824e5478d1bb4fe9f310bcbfee0a4a8b871418592b7626680dfa8aede5940528ffe03511c28e0a86bfe85f8ccd4f1bcc0af69ce89aaddd6bc1e1da02cb8865da60e7208ae76ddfbf69654fa5af0585c936709a26758d4f5949f1744c1bfb81a2d95569c9741bc3d638f505d34eb01132a843084cda44441e24505de15b2da315b2e8cb583d342e47929fae360e1b733d43cdbca18e20ce07b8c615e24177f24c579e5a0d5afa08d6850f1b635d8707860c149f8db009383b60872724977d36b569dcdfd6e8f0c9ff0e61ece0a41c7b1360fba79fa049f83554eab7fc8137d7143c4a3a1fc3f768d16cec76b1d9cdb322559a8bf571035fbc2823fa31cf8c123883bf63524a597239c151d674d95738e41ba0763d119ebc140ae90b872ea563473fafd6b9d3d41fc8038755aa6cf69b49744afd5a713a0feda3e86c0164f9e6136191adcf2cdddbaf6366e6e23886b3a8c2b791203b28fa1e1c3359b2ff1a83b948c561fc3836207f0723b8784024749801054b4487c44d96abe823330b32f51f3423870ac6991231e30443648c91561af3b8cc16189e8f7881f5b6736abda70773a4be6ad56f519f93d2bac657482fad12d993974e5d29d3cc7b61eec57528e052b63d67d44c71b2d8d81621c19ffec136bf3cd8bde14ce27803a48c71fce1cf1bcc3b2c2450955504219315009a3a7cfbfcd7a4bfd463e6d9c807643478ed7856bcda98a722178d2d13092a91c36957388e2f9aeca8f8601e6555e575552a40c96fd60038d28ab59ade82fc7569555461073e155640ef169cae4b444b9698e5fb5c64e13f0a8ce6b45f0beb37bc209d158062ebfd796f454f66aa09932022d5211e2dfe3ab2bae0b766ddc9b065758d15a9a7fbc542d950aae28d4af5807e44533b2dd04eeac5bd9dce2a47eef2037322513f511e3d7f0beeac0d5f1d1e8db595dc8121b5d9ca4e788be586dfa06a786b9b22b895eff3d1dae88697e32405023f9bc2f1f60e9b9155d6cce9199a4be23c72eb62046d445b429d96a23f5105476729e0fc3d3f4d3e36f78ad5ccf46ce1fcd1e78765f8663e316aaf572788b4f983e760f6c3f6b7445b53475058ff59e935643b18874982db0f6c81e6d246244cc7c5be718d58e0812a68d947327f9dceee7b93bcb03aaddac943e7ac2f782ad17f0c2fa8c39893142076355a25cf1b24ae9bcfa2ba59beefa8174b66d50ad31e05cda74024d74054cbffcbe37f75319384b0489d1f885831fdbbb9b47821c72ca4c968b00ed29c0ee6873a3f31dfdb9d0cf3f875a6a1bf6673bb9897f491214dd684e75f837781843be7019b87b2cc606d9d8d9cc2d565b35359f6ee102aa102bbf6278d522b9863bf0ee9d27689afd90e1fe0df2291bb0c1574e124ed725010150360a8ec34cbec897384e188c6a4ef4172c777f4622f82cd076c3c07efe85a80c91a465fe73ed117eb0984470f39d43ab7b990292bcb6560877cbfa89e7c712cd49cc2732234807cf8e0ad08180568922c3597b6d58e677916e4c36d8bf6dcf965d1dc240aa4d74153f53bfc66a5de29dc1d55f16440845d3a79388d0bfba897354be6c4495af9c68f10fe20c1520f957440c9fdce947f9a7616a0bfa6f9d18fbedbe0830da92f037819597750efa61c48090405eab21403d2b542a30a52c6fe5838b5460e5f31e1f7c463ee033ae1e1a6f593d60dbfbde4a691ffc23273ce381af5b3a71ce37921af01c4ff10b4ba10b84ec8b1d90807c2f99a0f2d0aa39d062abae308bd66cff3628e151aba2e449d0bab3c13a60606fa86f097c6178e338d130d9c17fcf0a8161ef8bb5946d670c1d641cc7e6a9a1ce5e4a80288cd0d752a0f5305fe740a4bfc468c6782c89d5254e88f396e38f0606ac4b5292d19bbd220dfa642368ba33694210d75280cedd241bf5c65894d2c398f32599002c43fa9ef47ab81ddf2ba4435d2722325c96bc3948691166e0addd0eeb420cd33e1dc8f62746a19d5cdd689727942f0e8d2cd14a20f153e2464167f602bdb2373a9bfdb5701e411889624fc077dd0c4073860181150ec8071754904137118a376e59a95ecdedcced130087cb5936594af0987287bd3594e8f4a8981d7bed46ce6761c8c828b1c5d06f539653640277fa20fe7a90892ae95adfc1874fcdb13298650b5cd0283b50c81115ab59d5d14e3f696f4127062fceb65f9fe6008245562673afff9e871a991fdd13d9c0fbcfb35de15300392fb3215f8d46f9fd8e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
