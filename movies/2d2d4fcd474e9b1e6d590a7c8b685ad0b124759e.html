<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b2bdf0a80f1d32776f66b7b414b67a3e528bf5318f9afa23228aa9b16194e79d4c77204e2fda8ba42f1268686d49bde0f6d1689fef182bbf73aba1c87b7af47ba2795777aa2c8ec008f4f04ddd8a00dff241bb316ba18b201d452cdac73c690a16a31899ba266aada53b184e9fd0c89bf2dc34f9084dfb61d01b5208a6f9ab3e157bffc85a4ed0653b411fec72708777e87dbd8b7cebe315d1674131472c5489e869047548bbd1a2f7c9202701084a1ba12c01f9bfd54488dd4d3ae90010f1af94b8a870950a56f2a9f1107b333bfdf90b5e279d1021f267e4ac1b7b95411aaba62c347f2101df993a89c02e934be6816ce1bbf265fee8ee433b0656e44729c5b0bbfd8c2052a652d9f075eb2c1eb6b66c595f3a7cd79ca8e29d82d74021b2e6ed826e6be105616e92b1aedff4e63ea6117c2842fb033d9d1d48bbe2f06b92b20d8c82d9bed43a8fe07caaf505751a964994e0b780d693eb38a4552f120e754eb6c46d0adb185ed0f99905cd879da3306b024ec161d11368fddc6b8dc10639a8d7a4ad08d318b800d803a403b916bb69ce0ea780eaeb8c46e4a6e84d373313cae0c18d130e82ec8bdfbfa944e02e5ed71560389663b519ea753554e23ccf1208ba67f219991c1b85deba632db347cfdf46ae740bebee9030cc87c17649c257e267390ed1f957878097ff59b084a2248459f265852550ecf871212bcda059e444eb38aca61d5a79afb64cce5213f1b0741ec3fbf3580da9dde4f20c4882ad3729fb2fb9b368da1114101eecba9b4124b9389c8d62568d4efe74554b17521ba8fd3108cdd1c6817e86da1e53beaa8df6245a5f388c770311bf4415d8eff8d0af620255304f8a88e7ec15efa434a282532cb73ae7111c1ccba9ffa4351adae077bffe4533e3851abc049eb05f9cf80e1da0e14622bc82172fb227a24716995c480d7d7b5ef0d9e18181c776a4ba0f9524ea23d800e12d71591d7e6a72e1e8171e443580cb4afd4bfa54957686ea570c2a64d4964d94de3cf4a3a70f600d10c914e15cceefd72e2bca9b3b1ced25491f8c902c435d5e271973f4e8404f9fad8438a0bb62220d6151b3a0c9a6462c2fc5a6aa46125185d5aa39584ec877ec72b669306e4121bc2064940fd375554057e1ffd77efab22b12b2160264c9802f915fef231be357d24a8f722cce33b422d23a90919019da71e694e985e8cea5eac95183c64baf687a51bd3447ce17caff8844d781bd8580b9f4d272bc2891fb7f2e6d57b4ec3d0cea24b26a09f3ee6aa9110c1004c31a9fcb804ff2744a9f96b07dc873aaeb9ac3950a0709a2b640f8c05c89da74962df176a11a95927736aefeffd040ffe393be505f9c53509c18d23b47b8908fb4a5ace965d6ee1627323978d7a666db24e461faf0bb459437df2a4c70364ef0d510a3b464e59914f4788b4b6aaddd35633e942b6421b306212a0c161011c4fba2ae5f07449792ea11fb0b33d339a30687d368a714caf4e169d6b1041959084475f1bf316e47c21d6dd81606b95538968f529befe82ac6291e8ee461b6f64ce9c9faeda72a0b56a808c6185a165297d8c414b5776dab87c1a964028ed8c4765b9c69825033b1a6ae29007e476feb3de221f79771d8404b578ee8cf1cc7454d9940cfcdb52c6364d2a2d920b0de995f1e9001df52ecb6790b4716b62bfba05d3342340e0f75471f553fdc6a1f6fe1674376523f0982b207f7683430cbd834d80414e8dfab256968bdf10fbc48f31dc3de5aeebc72cbe966b060b7cadc44ef14f59e1fd1a816fa16e2543bd365a34c9ec81637887eb6ba55b731269a94525a66211ad8bb6d326d0e123ce7597d699a6ccd5a3783fedae401f9ee54314e151ce2dec0f3597c5e07d4844f0387577cd7566ad09156da1d54dce5dbb9228a2baf9ad4b657eed219381b8df08d2b3f73919b013f0d23270aef5f0bb1d46b52e15111be88f73d3eaeaa72a3a7b3c7737257c7b87fc1a3ab2cb562001f8fb99d1f451f1c9decdea7eb420af115c0cfae59e638a86737779acecd3e6fa677ab82cfe096159a18c58598d120cd28f6566ce78d14f74a6ccb16b32c7565671eec223f1c8b2159bf5b3569092f0195bedc37f49ecad55a62cb919f9530cc2d6877e89cf6a80672f883aea79db52884299e2dcfa80c6dc55081c0299350628eb8436ee54deaf5326808e87764c185077b9b260b9e35939e4484617520008c0e19b1ffae7dd5c35fb0f0c6ce9a00a4155b78a22e4e10b22915d66780bb4cd613b0de9568af239de464910d1e76e6a1739f459352365a7da8c7dfa180bbec14007bcbe20d53d9b3a42eaa49ba73d49edc02671ac4d8a70bba00df9ed7e66a1e03ec767da0d71bfde73d095e8bec12c6287f93044e4e171b7a3f619630a381340181d210d78a04429888198e7c54b6f9169dbd46c1f9d30eeb97d0184e9c9b49bf07084aa044eea4859548a353e0566521256f4c550000824c4b6bfa75cb91aa11bfc55496c5b594390a382197d81841dcd7a874592e77d48b6f788f817e073be975beb605afdf11a4691987ab02624b0867edc4c1421f313cbec240e4331342ba6e9e8641c3c43a5840c06844ba9b345c4a8198810fa5c9a3ff93f361ad09ba7d0f3840957b713720251f5f84d69f2a8967bcefa4df9484fcc616f6b0cb0db38909acf00bdb5c34197d6c4d924064b23452384dc5032f0f37d5baadd05a4f42b2f1ab1832c92216832c03a6d441e9c63fda104386b59008b1256ff8c2f56dacd43280f61e0357c4a6805823eb31f0b8425105e08194f458b19b4a81eb72abded156136d498b3ff24d7008667fd5ffeb4276e94cf754b7504ebc7b27ead29b870faa673d5afd4ddec9c3ee6dcbe3fec7a2fdb7b858341634788aa06aaf18178ab58a4eb704db0b8f43bf5e51944bf4e69d35b63ce09c28e7665343fb1b4f628d5bc316f75864259b22583adece22eaf2f0e92459e8ea47e2043d6594f275d321fbad9ef072511e2463a27387d90e8ccb7c124ccc3de9ffb8ae7c50c4828bc0d9a54913ba06a38c0b50dbe29504977f007a21f63d2d85a98538cb3b6785491ab1b5c9a5b050ce09a964b452cb0fa32c534e33cc956d9b51098b417cfae3d9fc74f8a40bc2e887babb1ee0e791044b069901a395c4bd543c2cfad2712c2764516be2c1ddb80400223d9f8dcb86799c6ef356caec76566af8891301b32ea3e06a917af6c95494fe739f19994da8027e4087c775751dd561203e1baccde2f1abbc961fb500609c4f6c60ba18708a94e0b365199c294d4ccad0b2c332005dc6f17fdcbb2faf47285e8660ec88a7ec5a305cd678a319bf2f01898a4f1d8054350795d5926b9cd3d0e4960d7a2d3624315cca5e052480fbaa5ab84257ed1da4ff50e5bec051f3572d3ad1fb9912e150a9315ca68aa760488d62cd23844fec2e9963e225c70bca02815b4f56e0f4e354779248ba8ee80a484677fed59a6664bfe581a73a20eb896c88aee9caefe5fb64316f549731befb6b8994710b318f9ee1ad44f8d8ebe44a88d4e548ea686d90f0914f92b8c94decf6a7745acb8d24cdcdad21e341d73ee7336ee862f4cacaeb5c22d01fbadd97b3f7a29e89ac1619a86eeff1c39f6e9f2c533fb64bd57476e24048c50726c48a97a354e4583fbad3d2f90cb21b7db56aa95a55d582f19d59bebfeb1407a360d3829246438af7d0c57c330ceaa045c26bc89f9c4581604a209a3744c1d6f7de4587a4b1448e5f902c8949312b1cec6328ffed755e1ece585f9b7dd392d9c7bc0c2b1e56698985db3d533acc757f32854185b922f00331406bb8442a770ea48c57be49974208e6383c70c017703b4f07c59c019d7b82d13b8db7bfa1fa207792140b2740356964a79e20170288888f038d47f862e6612888eb43fb5085268b84cdbdcc6ee7e202e018114a67d25a977f046a854940ecd977aa5ad1fc9bf68d8d04327c1410402fbaf963a4adbcad02795eefa09f9fc0341657270d77658a156b31a76840528f07ec7ac1c024ec3302173a06c4c54074c009f2a4562cdc44fe5059233ee32b47ec6b53682fe697213cc0c4b6527dfcc28eb004d5ec527e6df475bba7ff8892aa1bad3234b467d18e9a72859d57bc9e7ae76d8866d68fad8ecd4e2e359188b472f56502c93073575139079cfa9bdebf3cd0f891a313e6f12e8036a8862c15eb24211eaf5e5bcb99228c4fe57e2b9fcdf57c4dfe56cf0a1a809c5573a8af46df1c61145d5bb8a75094cc89cab7ac2105f562966759a6e7380b6b17dae1421b8d373f9ea862de5566aceb85520a95adb6d39476ed161b524447294872e09e8a70d4dedfb2aa48ee4b075a2dbaf85541b8b93f4b902dac360bccd58034c0c522fd092e6dc1d22c0d83e87ba962f5092fdead674a963b161d3c53e838f74c32bce6fd505e5117bb05423ad66202740e215f8bf69683d0a6950bdccba8815e324e4f49323175f556e8062dcbf18790cd5694430987f46e29ed835f46317b0882ac5cb8d7e6de49215549622c6aeaf7a857c549164b35e413a085d8a9282658f3e8ecac76aeada93ee7613c46b89d5ac1bd8bf6ed2290f624d5f5c1d17e4ff8ea642cf9a6e6ba8dce9f51dc0f17ee11d308e4d7f57f13d08472265679617a2b1954fa0579e4d9607f201de2b81a40cd3a6b4ca43b1200fdc7b99fe6e339fcd96fa700d878f5dab64c3396a3f6aec977d937b5a561d7705beefbc50c1f6f008898a00812199d9d0c74a2088c174e215b6f067ab19fa46e7dc133b12cb8ad2ea28828b84f1ff701b36ae6e44984daaac8c7870b46012c4bbb87bb6c5770721bf072e1be683e790897937eda91087f85e38b85896f759dcd2c4f1691e6f95358ab760f889e0c9458128c5d0b57a33ab024b1f08aad1491628c0644962ec2dfa2f97c2d70be6ec25ebb4618ed18c13d84c3b06a7b15bc2bf832bae8839868a2c6a97bd69bc71e314456642b975767ec24c9792acfa23c50864e1e1810eb3a8a0e65d569644dfbd3dba8365f4ad427aa15a7e31fb46c47e5e5d53ea801f99a880752bb66607ec6881b2d2cfcb82f73d3da80908d2139c27c3433c05abcb371a017d573d3d8bc1165e318d4633d9b622d16e9008087a0b17b7bf69d2e361edcbc8c59bdebee6864be001999d05e502f80bb7fadc44b4ea5c048d13427d0f76944a5f50d1554e09e948ac8dfd2d2730866cf7d8f755c003db15edf46b143ced4de9f57c3d2e6691bf0f2f4247b8ee89f3c9d9980618d7499cfda0fd214900e8b57a174b0f5f9bc55da6b9a3c877486fa24cbba6f704304a58816d6ad20ba70b2aa13bc62e579cd0a05fcceb995c827e8ba29c66d88e5e8dd019b5127b9a05d7cde6c53cab7944fbc007c9dccd181c8f85e3ec1a5e1e5f74badb9ddb8948666120e1836b8e1eebcd785024270f028df8939c0fde78221ee16775f4adb5d256e294d4092fbcdf72578e79eab3bf2da4cf4ba38680637e82ce472f35a85f307e442bb819fae977e66daaa98a2d5bd79eb92dc8446d4085b4e741fd6db35fea9b56fb7c14c064ec7a9ad292f6a4bc84a4e2b418ebad0a7815fa678ccc124f4badd5daeb8db1c8ab36ef0c24fb5ed691d125c9d6f723d6f57f55612fd8b6c441c72de5b30176ec4dfbbe0d0a45b959a1aac76cab06e82e8683d3ad1630985f667a8e0dc68be58823b690864c7cd778b918dfa5aeb782879be7863534d6befa3899d40e917fdf9fd45b97a6b3399c75a197de18774eed43fead8291ecb26ce6ee27775049eb7d4be0b1a1b8775dc1f769957249cc09c7248ff903fa030ae3bafec64fafa09b0c7841d9ba465c785f4ee2ef2a799423d17b059d29c1fdb264856027037515965958223407583c4449e77c9e64d984ab1d3aeb6113de8a4a97e432a1526f6cb640af6a0e1e223afa47ba84e8ad536a3328b82f64515d24fe65f2e41999e0b184dc5015f1f43eb01f483f1f18bc854da3888e7bdb49840ec05927029e49104998dfe3874dcac16efa8784c4ce59ff948e0a82f175e28911d78ad04a14dea2c9d8742ee88603ab05e5b3f0b634f2d6f2d8860af694e70c9f9bdc03549b59b7cc5334dbc79a2f77e0e7998530b7f6a0798283ba8902866960635c8c42176d627a9004be300a71d240aede96004dc0088bb1af83631e9557286861e5078562fb33c13f09642bd70ae5b7970a42fdcce17e5926f07914f2f28a1c095a87184d0900c13f31595f279601175a6b0ff683e6c603c2eba98c82bb86dd65efb8fee2ee3cd67051db55f45aa87b900580cbd450a10f809fb70b6c05df65b1ba89950f33ca3bee8a65ce6f30d585d11dfbcdc3b9e3855522280f5c313827f5da0867b28f50266cb51ff2522ef017fe7af3b539caf9348d9c154bf55cac6d9b141b26c942cb56bd45b2066baf93b334558422f0cb834dce5a1e3b806c14e0e50be78d8d99b9e3fc62cd1ed849d42440601c81730c005216c10a16523d4be6b47ab1f7861dd1d3029121de57b9b059f20a2a1d30799408e0ea089089747f80aeac78989677af7157790a68d92beb25fdf9fd1c616cf163490b69b86bd828e684685fb546addbd805d235d958e2c251799612d455a2c38bc3833690af61e1c8411e6e0308158f25e7b3817e04832b1f284ed7d386eb3d648d4a3c35b77839a177018ef65c5fa6a7e3046ff0af52785aa005bdc86be0e1ea8c08e25bea66a46766c1c78082e965e5a443d9c99c08c147fad6963dc32af4dab634c0466412a608d45d9e940022f37e4d3cdef510cdb70792d4728fff0f02b54447f8a516ba4a2876842a98ccca93a0c7427ce73d5276c468d84467db3d85224b236212476335e661fb132446e92646e21e8d2941d3fe53fadb433a0ad7a8b351b05de01992d78ceb43250a3ce080c91d16ee0b5178a8a616b6b85841fc180f2d64c7f6abd1f9ede6f086ce9df8f9896e1f1688b5ae0433067e859c63113662cd2ec83361ee63458102da793383b6db119855a4829c5e8d7c0627d1adda683a2a52afc9efd4e8ab6e40c369e3158723d92c4d09705653ac0c8bf9b9c018ebc325f45e936f4c80bb8e924708684a634a073f8beaa8f53fdebd07ebc6f8a6128a87ac796a888b07b9c69f5d9e2cbcd3ded8be25285411f2f4edaf0eb9eebcf0c8e7f97b8b4feea044be9846b82aa1c182c9b18a63fed28757559051f322854d136c5c91920ec45479820f56b901fd6bc40cfdfb62afb6b60968e6abce8812ffc20c47d9546c794389157621757c696c750259544d724f80628ef7d03b09a48cb78593b8074b08a0968a6e87549b9928a057a40a910b128372e3894a9c48270b9c477299734747c36f72faf8f98b2f75e14d2d0cdc70f291910ed677f70cd107fa4a188ec39e30dd10ff8507b152f25fe3b04259877f656cf13997a00f68007d675782f14929dff1bb5353250638a321c83d83c7c3eacd71ae30388f51be6e09ef207c9f277e938f232d4659766b549902dcbe4095954dc684c9486b5498e462c5e39af16b5521327fd97fc139906c16938b0a1275f265b226a86d260213d345c103fc06f24fbe647f62c9884d32b918dbe07f2fadb36f55bc4fe0777948a44d95aa73745dc9e6a71fe38b287fd2f0e7807fc9d4b8963ce5c562156c0713e311adab983aa8043eb145538afbe5225706b9e687ce8940bcf17a0f7543f8875f07089b3a004599d341fd28cc733f827859ab507946e6bc4a346a3d0dd75f2ad27377df0641d5bef7be6d3929ead5d3907d835f8a858c8263b5c518a94c4acb3502a83e4489d81541d1a331f3d90541b1c7125c0a2ad129e542f48370d76dedc20e53456e36b27fb3cc7f9d1068f545b49f4ce4d8f88282b833f5a6de7b39152415eb9ec8a84ab9446d7412c82f5b41d0eef7e98be0ea67a5d7a71723b07169a43509a3b11d3024a175f41fa5dceef309d39bcf902b1509115a2c39c17e9b02e750ce9e200a272212d51971818ff025a1d75e1ba55acbfb8ad7ee2a741443aa37a07a03de28b23219fcc3c17af549cb6fe005f820df4bebfb9f5e9138dc72df1837c0bb7039e270109768df69c33d10fa6b6b78ebfa7e2e4e4e63004404e1d72dad81dd61e2500286061ee137a9283ca8b4319745e94886b5c52fd8b07d9adea3d64c26bdcd8fcb1ddd23e32222179e487e85acc4ac4c786a6254aa636225507f29ab5defd42ee6952b2c6329366e548320b959cbd4a85a4c73b68f76980844dcb8295bc6e518de18f5037b5d4177673e3a32b657f7616f180f38defa298af25be01d79f0018aa88cb664855e3fcbc375bce86faa5d448d73324a0c61b5d4953ec106a6e40124a0f3fa057bcd92b4f431eeefd5cdc742b9021b10f80c743d10709961c0d8e20bee84e7960cd3154ebc2049ae95afa37a564cf7c2cb6047d592b9a37c909aa3cc3a9aafab396a9f5b285801f54ce8d265a38124cb28e443da1a04782b180395bf368bdbee5edb40f714f15b4437f4361df3a72dc2663b1bd4cf8f0f225c33865c6ba2b3a57328685e66936dfba0b297ac6c21dafb9f658e89a640a0955833bcc71012b83865a51336afbbe7373794403b24f0631ef06fbddab4a64f25b08a4d35bc1ee1a8e7c4e2fe09949a450b4d26f6af0ea49678e48bf85637e3cb9bcf989cdf6e984fff8390fbc983d9d559d9a2a9aaface0f964baf6caf421a8ab151e2e014cc40937d8310d3f97aa6c35785b724fe9a17ced205b0ce370898ad08111a4b2a5b8f9410fb3f591eb3729e8bbdce0ce88ab31b1e3649f6a453c273aaa901bc886d60b59fbff18b0b26c626c8b3000434b6bcc7bc713860bcc7c565b641df3612b81c9915bb30b9d799fc648d8e0e419c65ea28d375436bce926626a49c948859cd351ff71526c31f7c0b38a975ecd176d2bd12f99a452e08757d7bc0fec991498d10667f9b8206cb52bf0d2160cb4385b0b73d2dacd61589bae24e3216b3653ab4c5bfb75f1b65768e65305a9a15bdd0aae3d086b1077587b63a74940c745e637501623364b0c1be523786497d130b554b6c4781fff42a298bc13d9882979cf4b72cc71a805ed28ddb81f6299ac140e497d9b6af540c2d4cb168d02fdcbb66c3d52898e4e832562ef977c834ce5e6700b7bb174d0b971460c4210a9321bdd33bd44bf134e36758252983d72373bab0634543ca2b3e2dbd8422075052f10ba285e7ca1d143f6d6a076d45fa4fe89df6e44af42c6c83ffccbfbdffc8091432f8ffea96abde99fb06c0d9561eec145c2c5053d1460c67d4f9ee24eba7295a65ffcce6b7b9a29112fa58138fe6693c1f2da5bbf06fdabbfa7fe526a40d26158cb16029b52840cb9fa01f50919215d0a1e26062ea80ee65edc1fe22318102da241f75d86e95b6d6fd7b27127e6653f33cbd77ed8ffc789aa09030a58e09a92d56aba740a52135c878be3cf4ce5fd1d606c84dfb52942bf4dd62f2ac2fe79bd47449c3c91b10b13773d1f3409f1c7f399014b7f0a0710140c38ceb39e296bf8c3802bbad35322c0d67007c983b51bb8c382c0380bb4e6187ed624acaa41a1bd6a4e2a6f58cbaad3510ae2194152aa2d706319f2dda83552907e23cd63636a3553a622e0484cdf71fd588eb6bbf60bd0ecd3941a06a25f8bc696b83a93bfb8dea41c4b2672104bd0b3e2b8f606b266da91dafc6bea171f28366453fbbcf17028c1845577ec8e13c3e37458fb5fd24f1c5ed168dfadcf64a866635125e62fbfbc140a778ef5162b4cda2f091e1140ff866deb08cd363b3be4d1c4a10b9ca4ae14a9902b4b4a874d45fb9bad267c3da7cc3037bf1403623cdff62b73436c8b25d13c62c772c0842d91e3e71b7f2420944d74766758d6465936bbede3be6e8fd289fef45f7d12727989717f8e9410fd0ac1056c14e4addce74f26fa98acc1bade9cffc78bd9d324d9d3f17394d3048e396e81c048bd297445d90b16f7ac37d5615925514353bcd4c7c73e22e6b078d71cec411831d51f764acd964cb83b058eb8fe06a579865c7a3f684777ab42f19fcb2b51389fc1c4773155765755c8e81d628e7688f7d4c65b6e5db5d5e8c95eb841d864200ab12f3bc7957180434a9f1974dd76629f42f35694008a1a0f97cfd7087a37b266eb4c20415969b6fe1bb8d63a5f330ab39f714ba8f2a641291832b3560845e630b9d89992d48eeedafcd3b295034930c7788fba9d943cb3cb61365c2d66971cea85c8e7b63f2db2a3729d0d1d9401e95fb2b5d092fa2fc54cf3782927d12b5568556e2a169c2d2d3e7e80fbd54b07a42cca4d78652169d0cba0ffa3b159e54779a7e38d2854454556f352e65b304e709869cd729563f3e76c11be9ee36b1bf070843de4621da7a7cbcba86e2b409cd3c974b41b5daaf0e25fe0a2aa565e4d4e45a52049dfaeb0a6e913ac2d0ca2791245612c138aa5d5fa33d592c681d261fe71ab602e5cf1db973677fe70bb5c5516752158ff2fe67413fc828867fc00fa7e3303fb4a8e2e1402dc9b8b844a42dd57802864233e3db748e88ff941363e8e0f0f510af7ec676512b201a5b14b89898a18c62b267a6b0dde80bf5be653d5980af63d8034849a7c0acffd583b5bc6a872cc7d4168102765e3fa8079b4e53dd1fbdcce6ffacc3917b843e1cfd6db72ca20eea5bf1d0cc3065fe2e7f930d8e37a9b7f8c2ab36a8e0bada4de8c1da46d584fba1dc333bfb9de1d93cb4ab910bad9d8de8eca170668191cc10cf862baf5a4f7559c30a8d99171018145bb555df6876d189c5bfe8dbb3c3ddcc5f6bd42305478e0b37ac8ad3b9fc0d88f3e4a4f6d7754514756e721ea04a42debc8b4a8ee9617fad3e714b88e071568755019a57036e49f642697dff7bbdd567783e227b2fc94378caa785258e3e6237efbbb90bde8e1438f5b24c4f261f2bb795e137a30e81c611dd87b126e106996043df8b7e6013d704e2218f8e544ae87beb5fa936646dba7c8052b6ff43aa4a1d23688a924065a238bc605b4acbecd121cca6b2d7f29a2a1da4e6f92b3a3b9e4c60996d4077e1e3adb759871ad28539aca83aa416c2684dc5768bbb5709563e128f996fd4f52b11233d031e9f3a807895605a2ccf087d6c09296cbbce6353cdec3c5c70deef8be1de1ad06e8b13f862609113b8083b60887bd718a54bc09ef04008fa7b03644187bed849700f1e283514e59a83947dba6bbb9855ededaf5a5e247a8fd3e5d111ccbec08cfb8d8083b3c1cc35ee346ae5a16a3f1b0617c1c315687c5436af74b5b41c54e8b60a4ce59e2dbe566387a29ce955cedc3a70306315cdd2f037ab6c02e39a0964ba8d605ea51c13a6762afc32f5cd44771f6f9dc16dceccb8a9703eded00ccb6037b36ac1928b77c144984457e02d2699c478e7c4a9c2a47ed8e2fe02f3f79832c81c8faf53cae0271b8d342b0ec385e0a1e73a3ec9e37824d1470825dd93fb14cf97ba6b28f8d52231b9e9873512afeed98b3293328d2fc08abf9eb267adff9b3960d608b4e21483b4d97a3efa1656df4fd3eb41ee6b2208bd303ef260fb75aa54e8884eb0f88a9422c6504f8e476144daad221f3eaba893b3cb9062b88cca77100463fda2a67ce34b56d92e9dc5e98d0f3befd6bbf286e8841c8283cd415e810608e0f3f949bfbd0a316f4ed1abcbafe82bbe050ba8edf875e811b9bad5891e09f1f6e3f281125feffde7e59089f81ef57438e14cd519784f3af698debd8c0ca865ac67aa75449e9ca70457fc0c47e86a8348a8b2440ecf168123cfc85d470638790539b947cdd1779f7d8d9296cb6a3044149412d08c6cdb2a960e4ebd46538a092d518b40f7de941d432bcb2b6d2e825e0505ff4ec6e18a7d5783190d629c0e1e03f230850808fce21d604ce7b711e75e7d3f7f40bf9b9be3e3a6a51feb5226eca76e2dbac9009a67539ac8156f840a37b0120d35cd93ded057fff527efb0a687ffdd4b08b62a0b62f870601977d98545fa405040f5220cf609fbd905c37702801b4a283e8997650405f50a8edf40aaec4f6572b41f8c6d8f65d372d32133caafadec0166f5b66370c99b4eccccad6b9e8ccd5a335870f8409d318f8b07cbd4d4cd303594c2200fc6d7ede7bbbe4aca115e0358e234e69df6a20ec1bb41ba273dafdbd67d59569d3313e5262605dac660824ecfea652fb7fbe445b4d2206f0acfa308281208bcb71ffc6eab1809df5d11b82003a781fe0837837e7271a2a7fa1dce8ea3b180e32d8d544764d155dade5e00608aed101cf2df3894f5e2bfdf5817f9c551ff0502ec14d9c5d5adfdfe42e210d376db7402d9411415eeabc386872f58fe6deb7c7a78886fbaee1a3fce9b884023a8a068ba14e693a3c8aaceb4718ea83d585bc3accbb18ee248da749b5f25a1c821af26625390ecdbf52aad869d686c1b9a93e60c920e03740014ac0e3db0fc5c9abcfe84356dc8506994ee768ec586f520587f04e77f4a6a2ec98b145c3065652fd7d69a2164418d1c91f94aa1ccf99c8c10e631dab4f5957b0f98a8c86119004e481d14b345c140fee107dfe648a3f6ee5293c9bc35897356714f8ec3018616c8cb32ed3a82d48b9f58e86c50d9bb36e726039f3b9fff0cb2ee96d7d9c1e78814b520279dda5755df7bb03ce092a32a530c5d28c89d8975e4093947cb663f9df1dd093927a2c5dc176a3991ae0ed4677fe849ca2da4d026a59c85c912e5fb68dd1dee7d868bd2674280455d55fa712024055704c306a18c90a4fdbcf4106fb27a11e15c628eaf9deff695597de8fd73d20f5e8a09a1a21065fa497ca19dbc7b7f60fb0576e0ba832a8b17734eb7bca516b9e0e5110642229e05e5e8576153a18030acaa0b649328e09a8c9b8ff349ffcda14a8796bcde5d743f220fb04d69dfe0d8a4fc8210559ed4fbb51b396f9b9a636d74ca5bd500e6798b1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
