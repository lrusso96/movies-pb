<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4d9158ad4517dd0b5b5bf74deb04d65ca6b208ac2295eedda24a53811783eaa5574c456b325d5ee653b8307a50a210063ab680b00c7abc037cc980e201c8ac9e7498bc2c901f574d06da302a1e681b7f67727598ef29710b7de405091808fcf8a83e8cfea3b0e1e1790a23319ebd4186f6f72147434f538e548c12363574d28a4f21df89ebf941d5dd7e66f16ea8c3639e31425e1c781cb4050810a9f51078406d912808925b2b1fcf03a7a3b82320d810d7b3759bd212cce2a48e1473e24c88e4b5507a936c91bac6b834da7f8daa9682960927e8fdf03dddaa176e7279f4de76434dc54ac486558425e98740b1754b2de0da72a9f2ca82e781447586546df19e979f96e0979d2d53665792fb3e25fcf3ae9357f8a86197da896052f68f75fdcc477335abe2aaf7af9ba1f1e422eb487e47c07068578e980843ff66a1e8fb4827ba6ab712f45a94bc382ef1f7076309ac8142267dc8873631b948610802538f491110041ee23190452be458b26308c1e13acf368176ed5f9ee11185ed6bf44b3334a3093341748a025ce097ca55f22cf9308e98829aaf29ba12d7b262efca23ec3fc4d828559e62f2dbcc5f02d96b6e1884b789b29eddf9aa0ad8f16f8e9acf5c900692e5551a7a818f8b33d5fb396b235b767cdb8e1cee6b7bf7ea5bc06f18c11f54813560a363407f799b0564ee408934bfbeb82dd510579eea2e9c0bcc91585989bb06f02531bfcc494b571657b521583a9ae5f735236d9972634069ce82ac4a5ac0eb746e81b47428927826092e2f1ff0d8a416f2cea427dc03ddac4d8c75e93f3e493c15ee8dab1309abc79921b281c8d67e813f675b80a312c5091b21dc77802cda922d0c6bf10ee5461745c558d370aaab0daef345ea46e45b68ae354a93e963a5f702cdc9f1aecf903a0574b8af92fcbb22676de0e817b6cdd54ba895ef02d1cf032d0ce8f053b62b82f50d29c3399710b304e111ccfc773bffa4e8f957fd6cff6ec4b4af52fd654a69c49258447a0def25d96ee5c8bc6d9b7226a323d47f5e79fab5bd1024744b0e243942736643ac78d80e7c6e39ab9e11118415add4161b6f6be19348a4fd4fbc05c8ec7366f826e42a51fae4bce9ba13734d6f088d548d086d31e120be3791f07611d3f04c3e4a407f08d404a2f1fb2d9b6d91cb53174ef0c4ee5fc3e2d12e353678a496d69ed9df1e61fdf47d35c9aa22af195c27cb8bd6348ead2b7a56feca00b4c3439772dc2ac66e2952d5aa98a5bd758ee3bc926dad98d7a0ed9f228d74c58e4d58cc16906d9cb37e1332a29c3d74505a3b5392d0a93431f66a8524bb52f11e82a71e7a78459d65b720acd44460ee82e1a41d47bf913a695966d4953407850e5facbff44d78e4427a5f9a7f763803fd746e03529d538adc9555f7861f919974947f5bb56c447df54158335f6fd9b157eec645e13601e8e1d7f9a9a8da51ea597647bc72beca95a6d593ce32a6dacb869401be495c129ef858b0524b015a2fa5843be61ec4402bb22dbc20aaeb447e08e45692f300719d71296f3ecdcf3798ecf5d687cab28b347b7e5c311c5cecde8dfd2b80b0bd5aa011f661cebf2fdeb400556ffb27c13c82bcaf142983c5b80f5d59c72a8d3f68ad1b57efc05975a4ea5d6b8c874b484eb4d92b89596a6b19fdb51aa3014eec664b00797813de7b92037bfd01966670c467c66dfdbfcfbb52082a0e10d530fe576ca17b2f4f77a9d92b53ddd2c99e60f42999b3d39421eded007570f062177742558fb60cd6879e602718d02251f90514780db515cdee9d17b9680b234712c886cbccf5a314ed40ef7181c1c2b30670cc5dfe8ff8680804e281b0feeb957e88f6f8d9f9ca9dc0570cc1091f96f970c1ad99b4b3f3efe26d8513709f38c701296587573cbb0d797331954606c1734ac2fc0bb1fa969e35d6cd1853de469f7a4fbc05d1d7dd6f6775d1bc969f2a7e3c079bc5c79aa664a311d7c6771038a436bd8bbcf23775d2109d200f41a56ff3cbaf1ba2f05f2af09fa83b484cd6b84e769a839d9004dbb7c81a5f276804f81e6392464d70f41ca07741187519049e2344c1f15be813dcee94b794044ab4bb7fa648ef62152938218c8924859d85bf78dce9e2a718c4946718ba69b83efc1d27a83cc35bfed40111fb820bb752ce73ee253d1b639de02c2a51c66a66f59f86d97593b0dfc0b1fa770002cd527b6bcfb22bec1a33d6621ad81c1eeb526fe637e30e840eb9d2f00c98f2bb2f2d81568f04c55d226439b2c2557d1d86ce4a9514cd6c6336691de4fdc1d500ef4081f38f92f7fd2d9295791878891914c27d70276afc2ba0e6d17da6aa794d2f5df280035b5bad89f4906a7eed5e66ae69b7cdb18be0be51941d86bb6bd30f6ee5302bcfcbb3de89f06f30e7060a864cd1abe928ea24530b127e017b73a73e56ee4edc4a03394bb49c34c02014667b4d25c463145c42ab9eb933f700888e7f2d74b5480da2477d08384d5c2eb0997794cebc8bc5d9ad089b68f46ec09c26173a47154f68884c97e0f371277fc56fefe80c6b91cb4fcc0340589280e36b7562c62e219439db5880e7132f3072aed6cbfd53c9704234c030e97bde9821898aa4268e338b124ee8bc1a52d999b0ce37f522afed2329435ee6ca5e074ae5ef0c3b83d324fefb7093cd37c4c760a9c056e3b7b1e426384a7b47224135670f8c9af525f4e94cd46b42ab31d26bb75d6ecd7692cf4e7c17db4ffb5b7c94c563b1ce7264707ed3e0d298dc33ff198a0ed82956d1244e8eec376417ae815f96492e1799ac1707c3b9bea5931ceb6f4ddbaa6eb2d6ef0024d9ab69df5dc168c33fb445b92a50d527006f44336326a6717c68609679c40c02f1ad4a67ce5bd34c16050cbd4ad27428c1dc1a3935cefd136e5363bd0dc5927b2f53bb7c86ad929406f8f98574795cce3079fce329015eea1b7b51af00fd9806e3302e70d106ce19f01bbc463abbd4a116363a74ddabbf65725afdac19bb2717419e2814ff3dbdfdcd545b18a95019ac9d3a7157df146a9522297cf71836cb3684d042118141270aaf8300a6e03f85a1315f18636259d1a83c9b61f3765914c0fc729d9b0cb100b45fcda14750392e465e67adf261873552909ed5c0f390bc734a80a1960f761056d48e106f2ccce14ee83a0343d4b2c56c7de909b14e09f4e36c881dd6513e0d3974defcb665d12a1b59538fc9298ec92174c32488fe74cb50d9a2eb8d0e108afce188f20a5b179f8f243e1b8d19cb45bce68588816b81b4d609b55540123c54028a0e3de84051edb44a8abe767fbbd540978c2307c0b119a5848df92d7ab1d63335ae902bf00e46ae4847550f7d0ee32f54d5a26b21044f7bf1de55dd9e4512765e580c8c62a70e1c91cbc621ecade274c3ee102bd6d2fa706861334de0a1b9de451f02358081da6d8fc83f4ace18736ee5b7048f8837625d0b7aa001a7a7c159865933d66bc163ffb5a715a2014f46b7e827ebb77e3131181dc39122a0cd1b642397f7116d5a2f20bb92af4ee26370de850594743d07077109b1e36d9e24bd8d091baa41a47aacda69155e299c8eb8e7ba9e571a0048cca4be7a344b936514094b652f1cb8b30b4693b9e41cf10248647d6a6b4590fc3a2b199fde0a275b32e2465c92ffb62171e34f445591504d9d9db3f400104832dcaaf5d4187c4bf81e27a129d61b79b770421d4bf07366b38f59a2826f0a44419f99bbea7ed0915fa11b528a11a2b7f686665e959cf9f5de22cf15e9f98879451eecc696e486d8222124b9783e912f53f05bd3f3cae9f82c65ef700ae77c70fd940d11e153a586e6146b03d3e8785cd2eda3654da9ccc32eb45d31c6bae45a94c86d82bfa4d27d349bcef950f83471c4487291b6233c7a25dfe84b8e5a65a92a93a4a45811933042d982f435cb4dc8bf9f38b91f4b4d9d3cea0347a8d7709122cd821d0cc26b1df439290f82127b737542e333286f42f9c239efce7709762db61346cf5f9ad8850c63d6e462b4d47ac9d763dcf7e65214150455030f971b81476cdbc7427409b3439bd495c9e93f1fce3f29fdeabe75cafd2aec66916642a628d7e1530ba02f5d141b0b9730c5746d048ee6150a1e5f59a38761a2e836c0991be5dd800a144da6d751bbb141268801f868030e65e7951c9163f5b766a17968588581d86b903c76b91fdb6b9bebe0289baa74d7ee1172dd14ec1342178ee33434baa8c9fa3711625fe2ab5c2bf90b78bb78cc6fafcf6423f58de47d525710848bf1f0fe980e5deacc30d9fdafd88c15ed556c2c1e651549d5cc7025c718ca878a8249ae8ff842de627a5675307fbec0955cb5451e34ac12d17dd511e548ee598da15694eb7e0e85aeca5219ea2cad0ffdb957eecbe2bcd688a06626d0820af5fb06af93a2162d882180d7dc5d36a980fa840c212fa8e3a722c2d704525ceac04516f7989938e17d3f9148c477a0ccd75718ff8ac43c603471bc856816824f7a8520f77055eb657d56ea9c861abbc20fad4f2e5754542a0be7728f342ae523aacdf0b72569a512dadbc086a3faa099c103c0fdf7eacb8627c55a1f6e9de5f1b7aa4b97e1aaf5581ffa6704eb380e63afccb44115d64e0cb2e6ca5b6fc9d54dc1df1c50953c477e3f1ac781bfe7a3ddaf11573c72cc5de78806498bbbf2ea1922837514c7c733d64e0b555ed11e8062273e29e7719c8b670cef60af266512610da46cdcc74b8485a507ce45299139b5903ea80644543083291b05fe956414a0f40d23718b9a78c8289972bd54c8ccc643a0e19ee3800827aa2c6faf666c236f5910c1249a982026a80974f5aa8b3f01fa98be0adb293ff9b78c73d06568adcdc451b26be878f29b690a390e364fab521ad676fc5063aaca265be7582340781813962875143f3ea55f2a6cacab0c212939ff110c8d182a7de5b228cc232cbdb273412518a3b8b420725bd5e6c8ed35e3aa9b0729e2b4cb66540b89e1c8437e034099361993af58b50aac7897cf7ad276d9c87bea842b0b21a78b4d7ceddd5dc0077f668e5a6993f05297f37cf2224550eeac511eabca25a884f8baba11b23c09ba48e9376b38eb52664e5d36ba33374d9795910dc0e36986404e2695947cffb5786ce52c53ad0590348781339b09a5983d89c5cbe84d409b41efd00317995c2b382483cad4705b33ba508cdba7a50887ba184416cb845c7a50423b31d317baca71e0bd628b7b51b3ca6aabfc79349b9ca45051176c890bcf35eb1dd5d7a4b44c9fed697c807119919b7b5c2e45bc527c297bb96027dc7e40cb0dc3cc0421f0cb60a310579db9874599d60e39a52456223bb8a9b62e27b343061a6f020e2784e4d2e4390d815ab93b142f7fc073ea55f2fdd74d798c6e51c13ceb7b2038c874eaa19dd643d1189eb39eeeb8ffe7aec006c85df67e5cd11c15f58adc1b56f79353e5e55af00bd96030cde927d3680e6a1767fba8869c08db82ec62a583e8675301934b3448ee0320bb8ed7d68c1f3dd9b4e308168f4fbffb98b2e101ffc23e62f171feffea0a65b2df51ce825f507a8b83b3f360ccf5a179e35516663ddf9e898dd65aeeb64b7898c75e7fb8ce2c0a37a2612f713ab066a752336b18b81dcc29bce67dc7cdd36d92802e692c8f5c9680794a350e0702213ac257735cc3a0769df1627e879db19d653331d79b820ad0c122674fbc9c176868a5a2d22c485e5e0bdbb72f6e4cd21f7373934a859adf1257ba03ac50e69bff6314a6ea1608cf6c4faf04d6e537d5b5fd18cecfc0be467e7226763d5ba2f22d35fbfd40f447e0c35abaa5b3d5e06f3acdea946f791e22681cc0d9d70575520e5fc2dc710efee746dd421e3ec63e6064c6eaa3baf269dc1220e2a1a5f77619eecb3202b51df7805813467e145ff6bbce83225edd097463e5218f4f0c2ec80641e08dd40ae2a415f6c4355ed82b83c48130622278a7207d724f2a9c5fc1fcc356cefb0fd62824f59620c9afac7ffedf49dbcfd009939fffcc34e1c1bedabcf8510ed4b479ca7fb5ec1fc7214941bb0e42ac2722adcc5480fd3728596b2248d2f4c773fddf959cc6027638f560dad7b52d3359b3c7f813b7ade2cdcf2b9effa6ffead9fbc3fc6eb91954e27179b779e224509be9ea3c1d8981927f521e899f8e82ef9dc58636b90d3b821de8d9401ef543e4931fe776cf11a89171adf396b0b88e431cdc0da3cfeb7610089cbbc89713d43bc8a8af1648eb4f860206990fb20f5d1dd5ba7774bfadf3c43f257256f797dd0dad003ec7a909d10fd34448cbe697170adfbce339f1b838a9a24f1c882559b1cb5a199fb0e854e29961df5e21132d59f9a8399d687310c267191b07a2167daeb970a23c0c0adddb0e0b490362de98b9fcb06081d15e085aa51e26ea511468bf77c622eac44e32793bb2402f174f7778c99167b4c0fecdfd2aa2855300a262a6782461358152493320082fcae807f6ff3e432beee579cb368d94fe5f03b4513bbb719ce7fbe905bbb2e1e3d4ea709b4a7e076bddca2d3eda417a777d4f898908300a4d45f53a6659c22fbc54d04e7687ea2237539b4d63eb19f17fed1e0256ef94120f8c0ce86be3ee3970bca5433cae310cddd156ffe70bb0078c2a4e85ab872f3fb607397e195b15cf288feebac02ccde1a2ed596a2a3c0fc1952e41642d06dbb50cc6ccdecf59e6aa340b3539ed033d92209060946e69909c17181ff986db9013159a6350fecd84987132e7ebbd4c642508043825ee51d0cec34b3f826b5ddcf2bdb69f4c271a5b9287b55d6071764292957042e13766fcd121d01c2ed41e314695179db83e55c771a31bdba96b274b75d234cc19c21bcbfb4ae160f88f6bd755c805b39a6f49edecc13b4354d6b96ab253d2ea4892fa3999d0e6e9072d445c5da91af62e113988f5668399d8b636eb2aee975aeaf811faf743caeb9a1d37968067f835e46ed992f88e814e652a20756aac46fe913ece39c61d80337ebe185698f02eca95d82c06939bdfc928d699f387fcd0bc0688f0f2c4160923906b4a3ebd32e4388f09d3db682b0a9fb6a173fdaba4bb651dbba019af16a27d4d92f01136c4cc1dba63b5a259fede48cc48fbed2527884e53d5adb3663693a8fdad859badc3e2c26e781dbd359aea176a324809de94faf1844592b4e65c8dc0767157dbe74468c270de40ffd18f03602028dc5829d725ef202cfeb5e59c5a6ee1c5902a0e6d2c4c367264af21f48fde665fdbed1e2a2040214338a8eb9c0f6d38c7a1f63dcdea6ed3a5b50033b1c96df2060a6350d09d8ea23e181b1eb06e7d922e720b053960ce415aa74eaa393de8a363e26471abf4d22c2e9f025120a5930cba591fe0dce5c726898392271f99162839d86a91124418fc44031e728ff2214d70fb64ca87c083f6ba25ded15a4284be495daeaaf0fe1436497650ec2f75d76687250c95ab3a79c3eb4d1d068bfc93baf3371dd92ce117ee0e4285df18c35e8c2c9dd91d1e8a4818e2c995223a52d806a3af0f1730a9c01dda09dff403afc4348a97c4b0935be0becdcd4f187dad7e3f09de84eab4678d1953da6c1de47c3aae5fa2217dc30bf2b9eb7e3a57d16cb113f07f27108981d0cb56d8f18d51f419e82d1e3f7cb9c1efe04d4fcdc9a783d9c5c29e341b5e93168f0190f3f245820a6158b019edb814c253c0eb92642caaede58cdbee0339f3cd05927d57e53ecc1d56cf916f9e7cdff501ad20f479c8c16c85442d72b7c777f2e9df25ea65dc64667fd902e4c509677b2a5f6c2fa8cb7a08e857623f4c95d792ed2f4468615297d3dd815327c10ddf0c4db688c0fa52c37270f89ba683732eee9b7cd03aebf42699644405ce93b4b153b12af675f33cb06cc457770e0eaa3581df8866965301f2dd5c4ec694632fb9ebdb3d6dddc8162f53acc7a7f9855b08c5c733e53b25f417187562252aca7314298c7f2bcf7dbfaa0825f97b3b61c1a7962e48a7043792854950a93e4b961e68dab68fef106fa8f55a26729bc5d88ed11a2179f92a6178cdcd03725b8231dea4846481921b9a17e427dab01683e2525df109489d3539dc8e78df9cd4659e8586fb4c829a3be191670d377fbe8143f123883c7b225d54fd2141b0a4bf4a07b046c7362e9440f021cd54643e17e4f022297a22564b9a9b631a065d187c7b9dddb7f33ed0057d919a1ba068df6f08cdc309ea494fbaed037e5d37af4d40e5bb05340ad560e84f8cacc7e00c405cccbfa8f7dbbc4cfc3678e50187504b6c2451902ce075f131c504835448757ed1bc2862b658a003cd8607bd5d3235d74cb40db25f34b4ce513905809b13b12bd48c2c1b7a736db301b9a795890593f75fd9c8ab5fb38305006d70b68cfcc92c825d2c8fc9020df7d1145e2255e18c8444b4b7ae8f77c1c58937d5259609741ff8bebd8ce7958056d9778cb092d18763638389fa5681ec754f5f33b01c2c79fd22f3bae50570cebe0b8c5dbc62a2e574275556edbae964c6bc043e3d1b893acf94fdb6e22df94defcb3465288e1460d32d654f309324aa01456cb8cd704c8c3f922636d7950452d714fff3f0e6d3381013222009c06232e2eacc263fbf407dc992255cafb9c851f4e63661371a08cd31a7a33d67770e6a4a021387499bf959141084ad01dbb1b5e178b19a44556e1c04045e099c004122d8aaf9888b7dfb9ff43bf596509358c67a02efa6003fa91667716a939cfcd10282f0e988625e06c25c1479733450f6f754044da57af9f092d03175b32e58845cde1358b74cf1ebecf8d57d4a3dccbf7ee3eb03e2c4e68bbae1247d40b3db614a56d96a6f8d0f9474943c9a913a568660e10752f440aedc586be2eff55cfc399f414e53913f99845561ebfab9ab351e2a4d01a847f7f5d750da9bf975b5dce2fe105335534fe89ddbcdd832ee37c99833e97fd5d0b34a2b8b579335c4ade3eecbfc2432a35db37284d454d5f7936885dc9b0e32b96f41c06c6f2c6dd38a8c8340c2b47d45c8d3d827963603b9d30f318a6a12cfb594c8c7bb5468c9cae85a8fed30846c478b52e07ffe0c8b526b0a39db15ab7912bc4e91642ba2e880e38a4d675bad66dbddb2f87df9ae6a4b3d745e9a53eba5f673ce584adf51b439ea54161c6aa203fc5d36707eff63740ebbbe8a4767fa4793d95c068611048225c2ef072e634fabe1f8948ef06d001a9b8c87f0cd92f099ef7bd31ba2563dd7a9084a69001e89839f93363e9ab60d19bdab61325d2ebdbdf595e8ad5235b141e4647569480f8f56ae9d4ba842755b001a85103c3db0913c0440bae976ae5837181e3fbb2576849e38be15b13118f334d80164c52fec3ec5739e09fea2f8e7992bebc003ce5d421fa006b5ac5a5d5f42da049717d08086c96ba0664e5634e2f443d14900bb8636004b8935366a0cc84175047f1b34fc52d5e2057a0f2bd58221c01bf47bdfc89e1bc036945921509b412bf1b92bae4753b22cda223950f4e263649c89f4d60e7d8d589c3023d43c12baeb3b93df65a2f3d639898400cea05157e4f57f46c51a56bb33957c0a3e5c9697b2487859856a4b0e5b72c3971896f9b7d5cbee84a934af7828c84cba7d6024399f2a5f4c8286e3b947127bb3c31e4a6d5618bcfb6682dc146568419a1012ee5adadf9b68b8f141b2d4348236152814120331baf3b676e551d0028cf3182df007fb9fae325288fdcfa2c701179ea86e453623afe4c523b63c84bccbc8b50d3cf9e1113a7734ca4c7ef36d8ceecb37d2fbf1c36cb2c706484dd6e329f984c7eb4974a7f12edc2187138e80d6091b5e592622a099cccdb381d9bcd0dcee86999493fbdabf5b68cd0aff77b06fda024ae38b7a4e3a2cb17633c1685db432cc41a8d32db88945f82d8195d2baa2b81c53829c207da20dda9a605c43e823366ef7725d22bf897ef06fbe59f3558a4c3c52fad99505880c68e27979c3811c65d000f5ba555b94a77c56f95a7f4c4941c1d8ca287e08946e6f6d93903766660c86892726013e4270c4a77b71731e6fba08a6deead70668e5cadb080af43d54b4635337ea5253c00546462f48cbd92404c02aa11c3c695f34f9275119285c97f146b241c49c5ed26ad38b1920b55906ccf591a785dcb9aa4194f0df2f5228633b8dcc718a78663d4e51b501c59d2ee26801c3b4c4bfab7f99aca2e2279ba33a0e753817ba8de217185cc7ca4b49877601bd8d618b1045b82ca94687f36ad425a4486e1c920091678378478dea04a66d8d754872b96035a68bd5675934776af2af534fa4ca65530385c03e839e8c58e7b1cfe73b0f6969924d0ace96d4a385a3bcd6db5255da9f32a6ae3e1a71e6738e5018312fbbca8d2da3d2bfe99ac9717232fb12e8f9aa36647d1805008761467f043458442ca5c65c2ea5ecfba895a604bc7e8a3dd11d6acaf676f58270c140cb5c972d87c2f687adbccf502925251aefa69df4e89de16cf55623e70d04b40b5c228c9d2aef08c30045d634cde44a0fdd332f629e7b423fabae54a56dad8c4610e5b6d3cbb4fb50c18498a93e787a16b3c26452aff2ec2ab30a7aaaa2f02dfd82172e4df01fe7493f39688514ae5fd326b7a482246900f90965ddf669ee561e7f4afdb893259c3d6f59997e5d6b754dcfa350dd55b8ac5b7eead0a6085fb83001bfecead4cfc4190fe775bc948c2f39ce2c9ea66d11e5746be1c78e222e834f24ef117e0042a27b76e1a55c33f17edea294d5ac69f244a256f05f8c44680a7eea361adcf9d453acd4ed7bdafc092c93511fb803d48368a19bd1f83ce40ae8189df28b59dbf9a5d03fdf17a99e4cc8db34d61cb6d55ab1b804818cdc1947b6fb78d188be99c2a52cffb26424e86a52f2c1677d5272ca2fab343f330a42f63a19ae6593c8ad8cfa70172135ac9b3bfb76619536d6400193f34e88018e1350c2a606b229ad0a8815fdd2068559174e4a35bf0c314f6ea8478369c2e14cb4fdd7be346938c2093f531249f5c3a4b3869bd51b6d41578d5130f89b2e12cc794110d21933f37976808612cebcd028fe98a249f712e99a49b6d3cec9e9f2cfb7a391107a3f2a60e45b1dc29a2e6dc84053a5e3df1bfec8e6176bbda83767165939bdaa835d2c787ef6559ee78df53502f3dcd59b8e8f7c580e1fcd8b9c72e40ba3d02eede90f4a0f83eee6b794e441225275977ee71ee6aef6b02d56d734f237185809cd6c290bfec7df44d28028e04b1a32621262924f65f7e8aa43feca1dc7a2f52a220a4cdbf6f640dcdf5a105fc1e68ad96b7e7f75f41ce45515436de1f912013ee2a34c781f037625994db9de11bdd3a81b4ef01f41adf01634b75ecaab08e2606a4d9c190b3a336ae3b48ae862e577ace68c2e30654729749cb55d242f96673d06dd6a9cd6015f333cdb9db84cdfdf494d74893f28a2c4a8598737e84447b079f09eba71cdcbad309fd5d5e5a28634be6c269dfac9e9054e203e11324e066130a2d78c17c6ceaba675f036c6c7468e8d2d3ef642f58544c5c84727bd9c04974e11fed33c0a730b97d2be96ff2f6103f776f2d1fd284ac139eccaa9dbe769da105d2c895c335372d11dc81a4f5ac59412dea9bf649d0523cfe75a403670cdaca8bfc5962ba4510432c3dbf3b106681390e869f0635978fb562cc85118b8f933898de6e1f102d51ba1d02335bf81d21ec7d9864acdc038453f47888b7c41059c8272c6fd974ec448467c85a55ffb95e77d9fe20aa9aba0a401241ce00225d283568a595a13502aac0c1f72a9dcbdae6d8b98f278004660d3a39510147cacbc4225f125ae5add6025df7764b746f8059b97725c914b765a9ec4de10c60cb918eac0be29c78180c839885bc5de53aabe8a0ee563f2580bb90464c445c2b125a33ff0fa3bca3b03d63b45a83f3cc8139908abeeff7b221a765e02d0a411568acfc65fa32d7d70df28667f28488b28889679fc256c771b0cafbdd93cb91a2285023d55539629e221d9c78eb2992eaed4a8ffcfce9c2fe43ba364a48767e4099f71f04f7ad98086533a7a1d105ef3fb62d9484c4d804a3d7baa6c012a33dfe96cd6333fc75641d506e4fb1a5b70b98461487f8f9d1dac1344b26d59585728e7f3953640033453e25cc9af684243ec9d8aa8d14657dc318a753a27af17277294748586cf9924ad34ac725146e7f924091a3063d4a549e2c80304fecfe6a6b4a96ed569a6a262f9f733e3f15c9238f220e8efb68d3ab740df7207047bf5fd02d33cda50495b9bf95c6a557185a1a1c6b9c2da9047e02bfe886b7d8ddc43195944dc29c9f019fc2d73aa2b373cfa3020232ac4a68af0b7556a9ff96f69ee5b499622e4fcbf815ce0c5173d0e8bd9e03e9db6eef59945dab6c85a2de6f0044cd2bf37e6f9f37e89ea2d238a1ee88b8c5f3d8d6336f502092c4f1e23348e3742b7decfe7a8752e5f27df473a745cd373b54c8d9858646b8a13c748db9092328de5867d7927f4d654bc35b24971ed6d1b0273d110f957d3a5725c2810b1df1732770527fbb195d14896aea813f569e56132338cb84b582fcc8ae16891f3b6ede5083dec30cccf64fcc08b8973be77e2f6921145dd0ae1bb0d714fb574254c204fc08e31447312f97856bbbede84c045ad1c84bbefbe19f30125a3f67b9da7e844dbbfe436cacae0aad4a9ba17190a3ad1c831d068745fe0b8399605c02188b0fc26e78bceb9cf068ca61d9bfa0b22ddb34f593dc8214d12a9aca0049ff0bb147d7c0601e0736306a06db884d54a5b1b52dd223ab66832e243326f73a43ab84d7cabb375d1cab679893e91f4ae7d4c54af447c36ba3f0c5d55236b563a9e3a2433f5ab4168b0843c293817effc7b79dcab9485ea2bd268579ee6bdec683e7ae41cb9f8e8a381428e63130d602cacbf7c4fd2646699d3e3f88df329f7a1e1c7b1930cce9490a797840cc44424f8832444eca06a58ef5b4ee4e705","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
