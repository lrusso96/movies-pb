<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f53ef2b4d47a151d32bb6ce8de03a399f30dea55833f76ee93e8bd929093adcc90582e78f1eda08f1007101b2ca41c873e84cf97b8c56e7879c6a2f4d99bee17d323fddaee293454de8f6bdc61c78ec674493e8e75f525ea3d9b94c672c3b7d6dde8e509aa7e87abf9d34c4e0844cd147681683ffcc4df1f241f3048d9e8379915394532f79a1c94d5602574b097a8dab83ceae4526ffa96670c7b67bde2c94e3b1b30035d2ae40dc4d22db8876b5c3daaaa7142a139a1a8419066d0c9e14cad54a094f77cdc0118c9ffaf4a6b32ae9618136046d175418fc905bec238242636549c25db0ce4ab3e9accf49247900626f6cbcfc48baf4303258cff0f7a07764728110233ec22a5ccc3024227393710901655ac2cb41346b5107958e4e433bd65fc6db9e5a58f65478e995075c4c9d6f8e8d2798517d0d52c2b46980caeb371d5a54d118982836ecddee38874b970549e8da45bf9f16a313428f6101d61c55810457db65244301d43bab5089845778702775e7829e5740dacc0ae1535caf348bcde8faca37af54205189a22517bc14d7681d9a63fed8797fd221fbce85b61423b6ce58b4a59a0fa396b48c3897c7056a70152f41a03c31a02229909cfe90aebb5d321b10f5216b07edaace742fc50da97825d9abb5311cedd6389c9e611b7d52ffb7b8d0f8b15f3b5db3468bf4327e8152b70cb191ee89238b2101370bce79622b6065dab051226c80082d3695bf0ea9a27c016cbae8f2b49bdd244411788c6a0189092bb7a03c7bac89517a37bbc3d93b6d49ff04da1d5141dbe26a231a38fc0ea4296a5f54442dda05269e3fca6668f043e473115dbd23cc8eccf503bcf474b17904202b974cbc8c473accf0b4f2ae2d1a1f4a5eba9f5d8ed4487a0913c278dcc9c52c290b25d9eb5c842cc67411da33babbd1df3700e735e763a00e2a49f5ff131a81c1f14e08a388a0081370e311de5f877563881a4945c0e73879e22d181b10b3fa6067e2adc0cb99fde333fcde3f3c58012d32f42a19a327123c54e2fa2c2aed4b1d18f61690673450d0cf9a69b366dddd71cd3c12f634420b4126095963ac060ddfa3f67e8a7bac695a4ba14d2ccc5ff9cfb4a0b02428ad87cd870dc766d59a2fb74d6de72b4e7fd5c885e9c894001c97749e161f47807ecb2a37ce358dd2bedda541cf602e3b8af59063af761447b302e79f60c46501e4dfe8446b8115d68e8cf420f2c31b3c3d0261f36b2d4da04b4f2645295e505d97fa7c36f0fae2c5996acc48134e0456b4fb40b59b3b5ddc4c7e570f7f35707f2de2b897a91dee7a3349f7ba739ca83cb136baeb0e699fecb944c4da4b637617e83cb15a697de251a2f7e761d78e7a96538af6ad446fcc918c63a81aad743c2e43989a47d922642c024e05a4182e4d68fd8a1468018fec53f8a25c25c28bab2755ab3bbed6a5ad787d3882e1147b20f6cb1a68fc10a53e6d0fd435e2af42f2473241c6e22b22073c86ba4e3189a120bc28c5e2d3f8a95ae356820cc51520ca512c737b55050b0014c4d7b5b7de851c9516aefbc6405eb9091a87f2c7de56bd87cf1de13ee9681e433d8dc9025a397a3d6261dbe3ab87cf76a5dc82db0b5deab875a582e513a3321e2043ec83fb8ca45b9ca95202e2af28fabd498be645546ced83e604a640c5289565cbba0e52d39d98e79248f1cbedb04dbab18a183ff3c46662fb29342d3c139f7e3227301254615909bacb75f3a8ee14439bc96258ec2f685d4715e4c36b3e96793fbfe2ba2b5aa837ee07fc3749b818c3332b260c8a740be7d2a20d4026b792ab5924609f840f459a59272f62c83b7e8456e5dfc1c16d4672ac082e01704b63246e0893add9b6079f6e33dd936bbfd7ed14ce7bf579733bff558ba46d6632321369e9bc0a33d86168f97e7729fb1e9e5eb68c1bee54b2c445f8d9df5a0317eaf7427781e6902cada18d2fd80542d432a60448345236a345ba68b149d19c232c97197b129a2b483824fbc52d776543dd585f2d81c997790593d50a1250b49c222b402ea545f98fca90421ac6bcf47ad42632a4b064d43c28701ec9b9cd4cdafeb0d98a0777cdbcc97100ddf591f1451362559e75f46540feab370288366fe65c3bc62039dcd5c54881b7223051c4e472b26e4c032e631128bf2668a5af4d1580ce3cbd6cb9474e03215fcf4aaeb5887f3f0f1cc690e21fec905a9d9976c3050eae4930ce674cc0d21b3a3517caa4490d304849d2b25222c55f69fed46bc3d8168469a40ef6c6f6d4ad1e7a9dc1dd4003b7d6e2bc778ae13a4ec738d44d208dda874d94f26261f7069e0ebc35b151548f6b3baaa7d81876e77748a8f5068f8a1c8c13a1a7119aca7f6f65959a094334f68491b94624548b96049bdaac2aaa57327dee0e16e0ce147a082e974796d90f2c0d4654df638a93ef9b642a09105575e3390254a554d206ab22ed1675413e73ec268948f4980dd1cd4c88d8835ed46db58c8b6a66656270c611c19d554b308dac7c8eae3e08342576eaaca54e4e582afb670a53a6f748e2128dee26b7c6f1f37ce625564e18267e81a532df46cb12936deb864808177536b1a0297a844d05fcc209d3178cd48d9c7be817fb0cdeb47e7c4d47ffb4b4e72c9e5159963fd0819ebbc4610936a48eec4900f20b8a301a710c960acc72f440d0883f6d8a205835f280fb5b2688f42505aaad2b14a3176f9c1dc70064dd348b55e0bd1d503f6583c49d49edb87314569362f69db3ef0ffb06e84a45a0f1beca34b78383a559f1daa5e925a2913a84dcf543a12777d5b448345293838b2f3874e11513102aba2e7372e986baa71fcbdb21039ecb62b5f29e65a054fe4254f813ad118debf1de8a8513e8983eac4470d9392b60a5ba437e8d9300cc29dce359bb7d398188aa02658d4f5d38a0b507fdfd5a61d5ba949c410056fddbb60103fecada95d6e9dfed1e8d9f7a621ca8b610e5557205910f24a66d7c1643237ea858336f0cf0478bf875bea3030c92e8f99b7410189c23531f1a6fa4784f7947a759cca5e59b6815341bc1b59cf653d3be6c2cbdae5d5004a625144a3af2a23295f53304a9a88949442a3086ce7422cf29f1df96981b433845207f0040d660bc8faedc36b5aebf8e1b1ef195302023fc4d4b41398cbde341b49aed6ce3e4d8002e1ff2adfaa8590344914e6aa0ee69c1db7298c77721bd77c237bf8fb01283b96937e88e774867aae97d450b373cf1350a9f620fc1bec062d6888191ec22a99fdd5d2e6c951c7d26c5c635b7b48298d194bafce004cad0df3ab3fd40b29d0bb6c3c0777416b2e027c3213a789e0323f9ff975b240497e80015efadca4525fdefd89df2d0f1f3025945df2c689b9455336723ca9af9aa3eaf3e73768509942850882347da8c143c9de4010204be8db900b9aae299c7e4be8e68198e29a0bcd02df0f78afc016b1adabc6e74fab3fcb093c6e2290947a3544c14b0762a6bf42189b2033a3130e4a4c9b74e3c6b8c30b066a6331ac9d2f509097746348a2f72d55f54b86d5f8de9cbd4b16716b7a624441ef3d977be66acaa9a264c3a3b3522ab07eb31002cf902240955f065ec5251a68baed2c3fb90375feb54e654a7eded89372512a8402fa29d5f27e545176a26331465034952a21b3d40173dbac14ea602fca5373056e3763883fec778af3efc690d7a22c18492e35f0ac9427a4072726207d9e449264508be1eee8edcda49d783f90f376e7f00108b4acfc72737eb9cee79a4f60218bacc8bc29fe9cd016fad8876a5fbfb4158b74ea758142cbdd39447aca90e2176d0f596e94e047066ce07debaba233c13b870261702ddfbefd4b1efb4b991f8f62d5d8a0a08ce6bfb28146164f87c4b91aa20108c9424de27185d9968b893e4c79f0bc78f400135a525d82c7d33eac24bcf624bbd32c4d26d2577f0e7583fdf3f3c4df42791b82c05191708ac959507ce247b1245ea852d8c1f39156f03884ff0bc7ca3aed866df8a19bf57679bd11bfeb25700c7771780a4cd098da370c6354df8bbf74d9f825c0688d6caa223c1860dd8d5e5993dcf11f7e2c6ab27625da08132630fd00b3cb4fd86e341480b6bbc72f1688f1d75f3f01375a58752317cfe7dc866a3a502cf1ea75289475fd38b71681b771306f246bce08c5ccc4460e5297c0840bb170dde3e215af20eed7629ebf29f9795d5ceacaee606c81dc96ba32fe489ef9844fd460143092a1d9a3668d60a06a743f4ba326987e015ad57dc68e1c54d8e1d4aa91797c94bec2ab8e2d0c8f7297990cb7b6e97d7fa3629193eb6f535140b6bb7ac6e0fd19e1e19a96b8bb285c94e775f44103b6e3b2b75dc737fe9ea7bf2b4772dad3be17f73e81ff83ab25069a1f84df297331a8a81ac18eca9e2907c2e65543ad557962628c07df7cdb5164d7785b4de0676d37b3a0d3a3bae8c3a861f360de73d249ef6f3024b7e68e1e8f2e869771ecbbb8e775a7c2aa63c49a6696a59fe5001b1623a7cda0bd7182b864fc4f31c3508c4aedc40488f9da955b1af9090554bd3051e8de436b4b4054a307b71a8b3b0b310112da60de28ef0f1dc167c6561956f3e0a7c20243c12494a69032673106f60be073a3b04abe4ec995de8fc8f40206ff82a8e37382e65e3e2c380663072b8e0647a1050c90aeaf152d85a9fbf0a70ea45bf0c6dd38dde3bc1a9d3fe8ed640798a60477328b79108611c05f7a49bb007aec3c57cd92035b83687dd814b48302df26d8a91a811cfeafd218cd55cfe59956e54c35e046f76ab3f9d4e8ffdd7bff5004ae05a79ed2db57a4e026249716b57888ab9c2badb37ff1c1be239eaded9a906ce27be92d24e69182d6ce7182edc1db324d54943c2154a498c2470376de85bb8f990292e7b238f6804f0f1312ea322cce655e8c0140f53c498964355c51426c94ad56faf9593dabbcf0b8803b84a0bfcb0cc887b72f6d59e529abca083b6880394ef2262cd743ef30ec670a6c538b24d4ba348281410f2902009923d5a244197af70975f1d58a6d99213b021acf372d9705e51fcf0bc3224ffb9da4fb1da135669b6a251d5691baf1aa8a0838f7ae126646256b4bdafd04cb32ec05294214feb948eb209296f89327d1f093ba9c784bfea1aeeefe2d808c474221e9c6db5f505d4694d97bed4229c26e7e0fc5c32f20e0ced81ce4e5ab11e733d7000d84292135496e8bc82fa71f71ac67b8e8980eaecc317aca259444da62403fd4d15a91d0eac091f6deb5c0f1976bc7ac8a5869ca00ffa9415f8e59d8b366f3596e8e3823d12e8f130c7f21a0a2ec8b031bc38e628b9545ee1865022cfec5e5fbb613b88d76873963b49d942a7d0072d03da4cc48a7f9584e363f0dec1c8c40d044b589f668d8cfd2c355af527721d8ebe13c7edb3b2ded8c74315e736b57e89b221d3b6bffc2da2e476c43ed8889042562f8c2102aed47716f795e08de852e5174032bbb47490cca6f3cf45294cefdf6b9d729953df365edc4f1509be3ef3c4c04f5eb6fad224c46b30cded5cd60a2d89f89c0f3cd232b462d1574dc41db4bf8ef7547df82aa24e41739f00131d0673364eb22d02216ba3a4d8d566e85fc1af5157270bff46e67d32b35b3f6b121dadb751a567719854039030ce18fa553b06ddee08294ea2d85ed4b49f5c22bfc2de086b40979060c51d3f5dc0642b647091faa1503b146452933c4942d6ef38ba55cede2e90955ef6f521aca373cfe5daf15a090e0273e03f1562f0ef7a169055c54267a986de06e0c3553a25186cb20640077261efc52ecd00b3a84fa0f7ca8b7b5dda9b157395680d5f0592623e9e847e87c6081fbbf86252a57b3fb45c9a338a6d48d9b448c3e24772aa3d602ab9a3dccedd1564e0e72da0cdf4dc2ba583072c8d149decd99bf973a7390b3cf694186bbda95624d19f333d840cf0ec0b0d7260232fb90253fa066252dc2b448f76fd47bf51cce985bf909446ce189b7f9e29e22f9a3e6c24d3d696b78a5c60bdba335ae7fba88030dc87ba9ca22f0cc98f4ab534de2c670577a4afff8a7ef874b746360defe7bcb8cd69ec4874f4b707f02e56ebd8b280f4cb5a7e631385855a7906be93b842a0b16b2a942ad071df91503763bb8a68d45f437d2889eade08ef1ac5750f06ad2e5c306043795d85e59255bedd4c91096b227e4261088bd6bc2be0a6dce4f3aa1c89ae046e7f70fcd27c868cb5187226ed50a5e603c062fa4c89c5304ef9234f83ca13bf1883c12ee40ebd1d8613313d4c8d944a0515dce945723d652f96af630117e6cca873f504198f4c9706c64a0c549d8bc3c3825a5c261ff9a17d28936ef2ab51028fa2cac15b417a8d94c0448e2be4b54bc217e3d50e18dd34e18ebae3d22e7608420301f09c00eddaeaf7800fdaea83542de5bbc5a672d3c6b432c0ad8dc14af83bbcc51409a40317258e35ee883396c1a18527dade11d78d18f1c3f7f04add17a7af37567375ecd84afef58728b67dd07fbc09d9d96f6b17d6bde43cff41118897b6bcc72291116fb73948cc630a8505ca5394d55c30ee451c49ed6627e3fe41452690388be955154c947373c8ba5bddccbc0b9a9897ed6c9ea637f76935742c457f916432f42968daf2e1797cbf72f607ba4098d28ee09cbcbed409c682972dec83dcaf55617b19295b47e788870fef2ba4932ac78d1f6e27d6ad6599cdc53a6c32a51ef0fdb203ac8b32494fe9d41ee67d4b41cc3fab86644a7be609c48419545468e5c32e3048072496d15d155ae30e3d184fc5a7b8accdf7266cdb167b4266f0a40eaa2b3c73051908f6841a330c0612f93f0228adc54d25a501841856e667203abae0426e48c24e9c3bec62eb9e6a6d310f2aaf3914e084256f0efad708d2237146f0f7cc7266484f3673a304e6567f960a3fcdd1dab880dffe06c13a510084926a70d0c11666290a50b1f470eeb4d086acee170931cd714074d7ab1128ad7a848f4a9a00622f2741896b8baea854fd1166a9df1201c6983b204e560101adb738060611d43e8ac50e1ddfc6ec02ec20abf11c98f528366fc513d7d8834930334eae7975d841380738ad0abd6cf59e3d22673b0a8bd91a789f665a7ed2f22ee4e8081da6b13175a0dfe88ec931134abcec895de197eea261eca55d159b615dc30586a328b9b50319271a6b1a2a53cfc866698e186a3c52d57322ac5d6acd79dcc9abb780547b7694f801dca70c1e35c92a561f067c403d23e7b9f9f8a4a8c8b2c779976b34c74cd3f8f1656543afdb6eafa6c9b7a6665883dfbd5b1d617ab1348fea3907949bbe5861adfbe17a2366f597cc44213bd9e439f74e17995736fa6734a9661c536b858c4eb4296a5420624324c92adbbffef741b456e1c817666d2b20a650cf55596712dd05587b42a7b055579003ffbb0c1bdcb0f733def30a02bbab251adf8dc45b78cb9cde3344b6ea046030d0e1ee8fdb25e3c20abd90794bcd861540bdfe5d97454255b2b85bc965bec5a0a9e8599adc671dfbf477e1f4e52a9037e7fd78c85ce2b018288c7c25807a128ec5012fc4772f83dd80cc0dbaa54d712f534c83e213a7ffb6b478fbd69032bfde669cfd5043c429473d0a6b51045dfb1fcd4e0038087d17e05a3a6c04c639bf7df6570a2e61f7dfaed90a941a6c223bb1a6c7e7febe1bfc49255e828512fa21e85375fa65370addc1a37a7a9c5126f2f643a68de8fb02aee788ecbd58794f76e5bb00a66d85ec92c9e75e341bcb4bf960a8e5d8a685360568847e80ae88d8ab0fa1f5b3f7be42bdf5a6cefcea0b63a38859a958c0d160549b463b0d8a8ea33bc51d92e12c129c21ff9644a88304ee50186fbf4139ab2b96dd3637d06dd35d13c27bd019209ea9992d7927936fb12eed5d6dd168e96da085ba37e3632999d9218b5262af935ae9b80a77ff31ca6e8afba98d3ed63317edc855b1aa7bbbd6ef90e240c17488b25781ba14df0874610232cabfb957245e67889ed33318d3d61db9f1fccc1162cd30b9c4e19e96a8a817d0c84eb232a23f399a84306174bedb7d2b15742e8273e09ad8b72d941bfa3e1ebd6759548d25249e5683dac35c2ef881d7ef65c163ec2a061f3e4509a3971de0b3b2adf509ed268c0017467b427d44fd5a069b15efe6f55d28291d66e220908ff9255792de6c487c0c8325e388b478ac7fff7f738ae7c744c4d7603dd5ceaffd7e0b804a4fafbc84381ffbe74584fde99197be7212d8ba0fb6464f2c01fe67d348ec6fc106755958dbf09d4b06e74ea182788c2a216b7fb4c9a2fe5b9d24aadce2be27db1b7fa69af35c716cae7eca28652724325aca3c43b1843225e44bd006df0eae799afff932a0e1215f6fddf752f7d64256f862f047361e7d85310ac14c155afec03e21bc5b8c6fdfc8cdad3719d9cd76d7c40d9b997c9d7247ef4aeaf558f78ff624ac3d7323a20afb4ad4040d05b525ab3e676a6a8807e5ae33c4aa1de3e99a163ab536219cd61e8e03af48b74eaa94e75b19d1a5c1678bddbb8d4919c114229e4632715b99af8836ed0875e11d4ea7d570e155d79292137f06c64256efe2ac9e0689da262035c4bc5ff158cafd6bd12e5c6137c93efc80ef836e25cbba1eb518f14e138c35834cc9c92136a6965640a4d31ec753b347c9bbcfbb947408dce3d051fb8c81c3d945ff4f0df5be1c44b9b85f9472afde79aedf6d8849956aeca12bd24248ebfcaec73c3a7e2efbc1beb33aca0939b6aa53506cce5a098e7e5299a8539be80ed2307c35f05dd71e9944fb251ed825804c6112433576aebcfa275d792c00dd0fdb651d512fcf90aa0e7cedbd8f5e06c11e70ee46cfb3ea3058cd86cf680476a2ac9aa9e134ac60fb37e9633e406408b78a0bad982d15c896033264002d3ba4990e29559e00ba77a2756fba8d747449980cb221e87c45de119a3861796ecd43f1a75e737c107a9953e2acbb28c55dbb8982b08f25d368a8385022fa0454034abfe67c4fbf378b72ff99d7bc51d93ef357bb143fded88b97fdb1e97de22b93d14bcf5abbb53360e086d21ee02e693634a789bc190caa712b9591825c002d5bad0a2a1bf4b7c0c0f89bfc3b36d8c3e328b11becaf50a418a2f8cac01b477603eb50fe6e32f4f21eb522150e8eb540d9ea6735b948e70f91f1a23a3f6834e1723a7e0f77d2345b21efeb1ecd6f44d3a2113717cfc4d7f7c7c81f058cbeca2e4f48b34e6db27b0bd173db6f01ecaa4588c3a48a59708ef38ad20f5663dde32ab26a18cd1ee0d6bf8a0eea0da58c8809b8bbca20b173bf4ed5f24f1bf9fa0e80107fdf46e5e410404ed0df0d643d1fd4b02fe569b24822f6f2f52de1e4c2678dd1134eb136192f41283c8b6aa02c2398e6f62be68f6ab277939aa9994aab20e573f786b2f2320cad128866790f9ee5d4b69e839085bcb416d836df626aff569ab7e6ffaad29559b3b9762ac118cfb08f5cdb97f44b9b5e468b2c2aa2038547ab14817f1af664ae1e3a04d4d4f96bb2565677801edd12d15d5c9a4774a010824e4918f2ec3962bf3a9eec0ea8049300056620d61963f663c838a639ab46d41f5ffae8f619234413521ab8ca91f9eee9a309367a6ca00618fdfc91361f5ced8b1e33010cee7804a6876142ca81fbfab064f1cca111a00295706d2f886a9e915c923fb7fc6fa17825f56cafbaf61d0cb0f38fa4cee0dc92acf683b75c7b5550818748986b85e531f02364b86003339d7fee43ff1876a8f6ca710428ae4cb4ce7190044ae8730f39c002f5964aee9750d798383bd61e927b7c1159b8240af6e7a8d901fe891bf3e28c671eaa37ffa02aadb6a99dc5fea6a718f6a4687d7a4bfd4d2715bbebfe828ffd9ab8639681edb5eaa1ec1fb18d3cf538a28723c2921516bf0157c13ff2794db7f346939b142dc1e6f04d3b537e78d68cc3864a84378ef455c53cb45b1b2ab25a97edb50d609b4fc2c4909b9cb5086a6c4577ee36e724ae01e0fc669d6d93527b27701c6c4dd2a8b4bb7a52737f086e9fe56a75e9929063bc0c3f85a7f098a48c173a0f991f29f7bdf501276b8d912f62233a14ac33a84e5bc3c25477833bf6e3d97b2508c6e2f47a5ab6c9b63b24ec0d849aeb9815c3e566bc5e06e12fefaa6a4b0f1967ce77a60789add4fb58e73a9dceb9a6a2178e6f2dbd7cb0d487a7484b6198b46f37c80554bb602a3ba989ce0dc736bea74478d5212e8e6db1ce514f75ebc6808beb4b4c94a41d9f8010fcb1e6f26af959fd13480ae6e3552b95d7175837fad4c6739b7ac11d82aa6907a479a35d0d10f39038bdc97e1edabddfc10d6c5c1e308175c668c50dde105b957871fe3f394c96e63546d974844b43e6190832c4e5a03a5fcd05d96986c8ab87d6ef70a0eb76b63d3395827f1f9026f583ee7eed6f13d4e7577e69a28d2d8bbe6d159f4aadcc445206cef4419422f2f71f637a2791bd064d2c6d0058e0fac242a16d5ada929a8fbb6ef6784dfff9f74a6557431b11bcd1e3c1c702c37bf9094a9ed273e91e9dda1a3f4e542ad5be78cf6fddd75a4888c965f6a0ca1b9821b617d54672b40c226234f0fbe17b4d75a3afd2aef4057f1dd77794053c392c0446bff6c2e56bee0479cb137833391d172e36af645c3d3988da07960e8b49fefddc1f98c522b5450d1c3a4fb7f8005c9a0f645f1cd370565f5612e905f4291fb26db0daac2af7f6150d52d624c1cabc1909b618636bc43ca311ff7a1ca4862c8c4236fa5e409f383714bf12456b00d994eda860057c5749202b7b39f8b96c9394fc9d8db3f403210701570534863e5477cce33e80b4e62ff55b4e39add6290deb0357a74d8770dd70796a3f036a7b166b851cd706335044b6e9c1604d55362e6d804d7f71a774e65bb39103a5c4d62bf02df118439f4d1fedf682a0f4217fa4e543d1b273cda49fc46b5ab059550f10f9f38be62dbf9f8d9b5089c99e8f74a553f239b5ef9493e9206828940c6890d8985db8f9b2d17b3b7a7e1c7bc18de47e84a7bc6136a238a9b5fe06abf7d9b4677ccf042c993d5f2d3d740ec6a1cd0eceb7a51282afa68107de3b357d5053699c7fa7cc85d1bb1818976c291ed1139534225cf1d0ab87922aac817a55ff2412701ddccbe9488fc9fa1e213b6bff603bd466bbda26ca0a83f92450fb47513f57261c72f3935dd40ffe74869edb76b8411609d3fe76a35b9c415036de47d329388ab11cdb7786b38d889b2a0fafd61a62f25021ffaab1c6bbd710a196f13fa1f3e221f356edca3cc88272b0aef9570d328b3d57e94a21407d733bb49da6a3a13a2e6c15119111b97053b1dec3721276e68521e76148560cc11a9fe385324c94f4976a5f13a6b89acb4acaf58161a25681595f901a9f02609b6f2290480e8cf7d4d09f3563147c17567358bb55672960664fbca64a6d7d6af538273741a856c2d7c36721e568c2a95d9749d7e2090d5d2bbc543b8f1f1f42791fdcdbc2fe868f6e39b8d92e6c3dfe22f373f26e4ef1877e2b5d6c621ba92dbe70983d912f7fe865aca11b3b1e7349b8b83da7022ad5569f4a495e14086b2d5654502aa6291218b81a152e47548eca3a0508e67cdd77573385e56f57856e3b4b8dd2c1f508fd66af1688b521104edf2b81260d09bff7127c74a4a6884d9c62e0fd62d0314a362e0116fdcbf8662ff9e0564fd2cc48bbd4af96ec86c15d6f1361afbb6ba8b7be0d62bb7e0253826223336544a84ec671d6ef23590442d080a631bbbaec98592063e0d500130e7a7ed41d65fbb19b7d634394ded793ec1175344a4c07eb027d77f34aab26f24ef17968f97ea17479cb4dc8ef59a97d7d516057d0ca445b660cb4107f098c84adcc6d05690d1a126f68a441acf7ea84e00711d3e660838828d5a1ee5fd6c8b902c3886470c51f614bd06f9997c16aee94cd8a639f86682574c02568512fc92356f32f71186be195296814ef3e8c628e48e497bf07e97a4e4e76082397d67758b2698199e47c38ea9380ca01f03f001bbd2031d1733c3e6b47c2fab9cb477487266ef91c6ddf23de17d8e74b2d18dae61362bf79b84adcd9166fb178a3595054149b29c09c69f1b5d995d448815e3a68cdeba64ef13fa0f154e7f73d1ac8f7bc52e6613dbe2ea639f00c0b71e0c9662ed02d4f798485e23272166e4bc05d6f72d4f591449cb897a60ae68089608c77492275378ff8eec7c597505273702d99bb3938251bf35fa259d8c8a131bd916bdba17bd7b839a27b9a44fcc6902f40454bde19289107c28c11643bec90ffb84255660ea025d2052118c8bd5ad166cd0dadf64d4407dab0c86b5684c91892f42ea145a7da4dd30e6af2f90ecf3e22d6bee53e6f176a52ae5b8ac5e4af31a782304e59516d1b2be9d928de70cbecda08b888368280ed0b8dc116a2d06dd18275301ba3b17631432460dc42091199f3c439014f0da0ea63e02a3a1e8fbdca1994e2f69565223274429dca7a0bd98e9c849215d2c8f564bab1b43899c858d3f35963fb4ac3b373e210f81e535cef2ff2b20d5ea3d144bf48d000483a12d7678b56732f48d47558025ccda74106bb1bd749340de4dd8a397b921b5d57d6f6b8af63329657fe3a42d027ea1ddb0668eedb4b143de218f2e806ce03e65871e9f6e227bdd36e41f797a51be2dfb51a68a7a96bb3a40735fb9ed6e565f3e4ccb77ab1f476bd0db6d94f16672217c6a53663bd4337e5c65f7e6c6bbbbe7b217264b80bc154121ee3b8cfe6ca33f56dd01701fe4ee5db25a355003cb0e1e07de3a07d1206d976bdd23af5e6547d428760d90528e12abfd2458e6976ef6dafecc2515f6d2647f30664ea50b6df74b6ca76d901decbacc7386f2efba03dadda8b221b96ffadce7a4efb60454639b3b4d4317239e25841755aee27c12320161a2c5c5e04183fc7f720f859b94082e51f98a9261df3d84cc8439288abb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
