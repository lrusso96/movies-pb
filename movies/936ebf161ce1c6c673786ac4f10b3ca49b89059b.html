<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d273318c512f3aab3d7ff61698deabd08a39fd338622ea70a05a222b6dc3ecc0f12d24072dbd3bc11afd1d322d4fabd41888ccfd891935b5cdec7f10a3ffbc875bfbee3ec0e9bba542b6f8d4d1c13caa2fbcb94ec2c1c3f9736f8daa187758f2fcace863d3d6edb4a271e0407c12a0b31e74c0919d61aa3a548e52352d03aca9c886465940d32432b89acc6674aab198ef0610c5a194d1b1c3f0243f346f885e263d420c187f8cff371827676e0dbeb0b2b6e255ae4b9d7232a6c251bcc800e4a9bc58f3b64cbedd2c7d325d4294bf11737b91b67d9225b90a9bc56c83ca3ea0d2e4e10c07d81fed68dfbefd3d2d1f991ce46f17c801fefc87e3f4b417fcf36c1bd44ae592da69015e96d27e81cf15f71f524f9d5b124a73b2430a481068808fb75c9819509ba55f17a5214903b54cd48838f10365a115c02ef7edcbd5dde4f39a34ac6e1623d8808af5c663d89318ee41a47e3de72365ced4eed30ad2065661f64aedaac90b0550914f85159dccb0de25749071384e61c34b570f8c90de88569cc33541c48fc0d78ed1e6c7b03e4463a762646a4e0f7ce981b6ee9e1d0b7c8f1912dc115ff37d186c45394aba6ff2186232f8304fb34471d04af040470be9cece2fe55bdf3b8aaa64054e7206db19ee2974c40eb8c4a246cad28420dc75a208ae680324fbe0868ee912150bc10a93beefcb7e30921d13a9b1c85998728a3079de0d1df3f7d8d587dd9274ad5d9b4373f00a19326fde49d10deabab13a96357ebc56c909d6168b51751badc88241887f8c7f7cfc9f7ece351aeb495d262b551f5e282b3d586b0a2da0675e7222a6ef2963866bd1761f19deb4411da1b37edbcabcc6f0272a6e7324e55d3885cf9bc227bc995c914acdaecd17527f88a9281a10972d6779f320efc023ae1dececce2ea2d261774420ca5ea3bd5119c2d462bbc67bf82783f1c7ed506712f7f82d12353cf2a84328d2dfcba46f34af2d38aba38f4f7419e240b9e780cc823bd912aed957bfe64c17f0acb875eaeb166e674412831b8a5652b4f8f886a9ff4e41435af4dd662cd01d2fcc5a6f031ca16dfe61127feb2ddf7d7b1fef1ad1fe242f0ae987294da1e58b458ae809b4639320dd8cbafb7142a8844d3fd58c7e6139fbf6db623e5487c7e770610d2931127ec07d6a6cdcde33c986e1b928617a192fa2663f58278cac834bc4367620c3851415f1edf99d21280026ef248edda352d5683b060156d4e8d6299017c72a700ee1929a129f0be685d1a05a27d4cc4a49eeae5fcb9ca5281748e891fa6aded7443d723f80cb19a63902f9afc2b22509ad4f979cf8fb75c98d42c82461a54db4fedf0d4cf7c9ae486e732bf4733c214b76e799039547f3173d89f2a63daabd54eaf63193646312b51ca3982062b9bae5395eabd725b5d4d4d907625363e9d9b33887c319d36a29c1780338c74310f8827fae3cf2398d81b8c9626748256eecc6f5e65baafc00d69fbb13c3df37b36fafa728c3249e520036da3de6679f19674af0e27b1e5d8abe4a56041e170d19851439f6c9aa8f0f065b1c69ad77d444056f3de8ce67c7053a0f233cb2ba4d297412b047068f184cde4a99ef90ce3af273ff45e9210a5074423a9f7e1e53db8e23d9688f1b10f1927037cea88b7a2083a7c5c60c1acdec5639d1338e7fdda3868bce8dd939d8c128643144f60341088b75c1d6355363675454481a723b0fc6010d686b4a2a3de4a66b09ed1f04510866fb5dd5dcdef7b1534e9de59241f5450999545306c7be6d1dfb1fc9f12ee1119f38b0cf317c5330eb0ce8f4cba643f640d27b845ce2043ba83612e58e6218cf93e3eb1a4efef27d22ffdffab183d7ae1d7b65656afe6f39bfdd9a825d9a5fa10be1229fb8b3b58f8c35ebef28dfc7a2a8a05d62aefca37c310c61d59ff2735193d33b07e36b8d8729fa9a17cd98b494f3e549af0d99f8b37ae8e21ce8087b2b2a2efc5c10bc086aa0798a703115740772e7c264dc9f91aa3ca67b13fa6abf7e517d57c4cc82837ff365801ca007d1d1e3bc4a75ac1c9b98241cb83bf464354c04dc30f89ac4e51b755c9d8367f120fb841455b5a48919840b10b997fc9b1debb71b1c1d635b172bc2ca1350a19ab77e2947d33a77e8197264c759738d180e8ccc7016305841ce30e6b123bfb4db60510254930fdd6895163b710ba6a2f2d4d7d92b66590bc22317e5d8f23a28a83dcf5aae378d84d7ab5f4de694d1921609ce7b3eb356465172f7f586551d536ba51f046c73ea87c923ecdc6c64654fa7fcc92e6056a2a3c69ac8180cd4a4baca4a19d9f348b3c87506c9910bdb515d51533ad3cdc029df7b5dbc79cd855b8bce10c9305274b6b42f406d82ecb7e922d09eb482fb510351cf6d7a35e386c8850544fdc52489730dbef300c3787bf623e9dda6d1d558c669dc852e75a79cbbb7cd95528c73577398520bd93c8f4216ff6bf5a1ca3d21546ff891f5b41537b54e3a34b1a3f0de5282b8674874a8a8589977322750eb074abde27ae71069c05f2bfb3750a0782f591ebbcf9dc9cc7eb0504b36225e7d6a5392bbbbd636f567126a343da264f34dbf25e2a58eab014468e6a3765dfa545eb92645405817f9330547fad2d97e2f8f29f4f381aa1dfe29187cce2032166c78db4f082fa2a114e0081485a2783854534cfb7335de4157868863a7983fdfc5137e60b268bf8ade6010a64f470e8d592b338fb4b347906552acecd56301ca52e25f8aa220de9b280262250886fd0e4040176880e9de4248ba23b1864ada5d62c4a5ba756cbb6f7d752e71bc46d5f67425c5f6431cc5fe208ff1c259aeb8aca787cb4d605ec1c091d8252d7bc186cede9e1a2b1cfaa945eb0ef663e5d688a0a508df9b22716e7c2b3638f493b4c2366d5b27e2a730f52827a4cdeafe18185bd1838ba4064043831f323e108d1ba6fe4b51252008d574cb932872da2c59c18732a32ffd2d264bc576c4859151d8696604d4d5375584999b96b8abd38159f32fe220c19e4f8266b5b3dabbcaa2e5b3d6d7bac2852dfd0984301011b0d01e822564fddefe011ee3427a85700f63c57b3923aa87cbe569329eadc18a7a2b634e3fb3e763be194669f02c58662da9dd34029fdd97f6f77abee01682b47d7e8aee58f3efdf85f6143f7676151dc3babf77fe4a3a7a5df770012631b297e0efcf9755e343130fbe6200f5c3f8e1035c3142f0ff6ef6036bd052e2c334ed70318518b7ac365b58c51711d1254f67d05bfeb29c289981fcd036543fda56132dfff54e7e3c4353e55164152379d06d05c5395c2b8b9e61cf33a5e245a14ae763f5378fc64eb66b7a3f0ad5566a3c5642377daa468794c4a00828a5da40bc52932a325ef56db34b78c107848bdc4d8d98506405d401735e84befd023849111c9665e89491e76b8ddffbd2e41e2417ed6594b8d2ab068719297d37c76145fb669d2b79db85d37e29d5799c8ae71cb555a3f7aad99e89ad0fed70107001b6afbc448f38b60a5a6b83b28a2ad1fb82b7685616b818019f139584e42026a1b7c4b3ec5390668e56e78fc1b20a507b47565125054d923392e0e3d5856508d15f096f73177066f8319dc10cf79171bd89cd828217f4f87a780670c9939f65ff38578b4b62ab1a76955b6583035a966700eb586ae42494828c98c9a227cd75149b02cc38013e21c1823901814e39fd7ba723820a68fc98903d9987d28001e61029de3054e1c3459ced5e3b6d1a37e4e7de6b0791deab5659e881859b667ab0937bd86103ffe231f9ea5488a1bb1c65d6e1f71e61d0441c945c0e552bd5a2b7d8ed42eb0e77831fbd2ee3246d4b8a042eadd35f6277f3a4840307e80c58918cbe6b3ff10b40e7e796e6829627c481d22821b3b0379a6e42c701411db376b88fc0faa0fe0a684a6d042acd4ca32293b53fa0b055bb52db4daed5e57b6065e4ec0ff3dfaa1d7a61fe9422201cec95607dde89a5d82850aa21b66f10c200879c008f995dac0fe5a2d21df650b0ea0427c0b67dfdbb0bce866e22bde0117962eefeaf8db7ff3a25031828a5ddac77f35ccf5cb02359e26402a8c2254b3d48c560fbf6e092d797ce17d41bd24e649a65d5caf084974e1c48a54e24357ef1945a153f7ef7ebf1a29f63eea49b6828d28dca213d553d0ceb646a1480154bbd318a9e0d091ea8ac964c73ad4c0bf1d218c66ff2a4fcb32f7febff2440e47cd5c2beb07c0782eccea558688f0858487f096a6fd7b3cb63a389cbcd05025e6b1c511bd8b42161e1c5346aa230ce1dc3a931ddd5b0f7b5c2d72993a28b1d84f70c9678f6d4a287b3e90bc98c47fed815b76c7d88d905dec0cb3301f9ce7060ebda595ab3cc441eeb06f70ab3e33c078b911178a34abc576d2156771f52368b70ca17fd9380b67616d674e472c4a8054551f3cad9bf32c137249a9fc1a4349c5f43df98244805fb7dd4493116647ffd706f688b715096c06e4122925aed0e872b4345df952cbe2249c4cbd927774c1bd35fee2fee4b09a131cafcd74923d09e5ae22cc27f928b4411809ed9a79f36f12eeef2aceb8b8bfbbf2fe1308b522013881c86626245af583d9aae93af040cf25aea916231469f81f6c892c641e0e9bca1695a1ea8bf651f7287b8c1ce20e8b8b6d79e05ce3645021710feaf34dac9305d29bfb6966e3242eb5d5e1ed99929cafc0f081a4736cf129cf9a5b7629823274545ac35ceb071ea80349b29d208cf4fb6cc1859e0f246f53abcbdff049273540112e9af332ae98d3d013ef00cec25ba16742440c00ee18c1e7e2c70b505d6541a46531c9b8537fc3d9448d4f4f5b35ab753b4212da4bc08b6f407f4b0325173ef5f74c2c7ab1d2766b9ceee20d59fc37f93a65871fe7db69e5d318f86e847f56b7bf6ab2a643bbe50152aa2c3cf23d9a5d246c515359a8662baa59206e8a6eefcfa73e02f06776befd83c9163093981cd342c01e8e69a10735b3fc051d4013935a190c34e7de7aaf5158c0ae23c13ba791349ad3a03c17fcbbfffb7d92fde5b56644cd4be11665a23667f014f1b404bac7b6d1b1a4d1106feb239108783c7b91eca9312ed92164df15f59374ab248758808fc46456617ceadce2e16e00f62ccd8394850e76bb46fa47bd0a3866464515f5d60c57cd35b7146be8803eea6939cb931b04909b8f2eb9f69211e96ef1165c284444b2def24594fea4d8df88af7d64c8b627277017798e953a923fc3c2d74c14fda9fb21f46b87bb72166f25b8f4730018198378bece66b8d3961af5eceec6ebc29b5864ee170b3c840a6864cd03f439d450ccf64bc2f98a5c7d8c61d092d46e6a90a5fe9aee94881ee182134adcb21198e2f6356074eaf1196d7a041c267b5de26fe6c5cd4c34ed7bf5d9c5a4874457649dde5275e25cf6d018d5744d231ca0ee9f76b43a406671d021a32c9f45d77214234c2c183e9c96509527844956a4b05803ea9a0fdabfec550ed5837df60193fd151c75f695870a0dec8a9d63942bff160146350126ab9c2def7aa2b26a3c976343f9c472ce8f0db7dcfa3fded98dc1c2c2e4939c8176122bd7fd7fdb34b6d185e3169b1148636880ddb5ef6e2f1144f647ab9ce1f656fd8c2f3682fc45f0dc9060c476537b959686e581665cc051d19a2ceaeba571df70cccad967bd3a15e569a51cdd5f12eb504b9ca2823e708dbc2ca220bb5bc61df0d7e96367ceddc33ef471093fac166dc3dcb63adfa6441890001066eb2ac6823d74241879701da4378f7a73361bf48d61ae3dfb3f50725a69301837cfc7bc0308e7be8b3c3d85c78e2447b2f965db2207a2a4e3b82d458a3e0df5a32be081c3dd8d33b6b1778c7e63d236b3ac6607c2c8435c5db91e494216cb2cb0ce92db4cf20e625ba91159dd5961a70f67d3021251438cea0153be478c8f12380f9459b1f7d2ce76c7562d2cec6f43bcaafa089617200ff9b708b01b0e0d036b89eca32c9f4f4e518f4badd65e82470c5bebd571971cb993755a843adc9cd11088837bd068501d7eece558da929e53adb2a784dae49ae67a50ccfa83db657e3cfd0915a556f1d3fd92d0fab268a6f0545458ea29255cfb444fae7a06e6a11a47dd5d533f9872696baf54ba60a9ab0c66f15117bb401fac6cc9eb255e60f40f3ad2e83805b7ee575ff0936bbb48b8b79f8e537da5256daf2b1251b0911a5efef0e7f52d8659a2effdb12b85fca2ee91ab0a38d5b362626f416a06a764ac30328d8e836caef73ab62800a8bfce48e7b78ae9b2c6e07dd205597036f8a26bb48d63eb862f1d6d4ff298f8a564afd267103581aedbf9a3e97aeef1583d93394c333004a434dd32587af12746d7530c35b52ecf5e30004698b6104844dd17b0d511d1d157a459478973e12d4d156ee63fed1c94f8af8000b976db8c1ead0e64438c85e2543f4aa733b2f3d3ef9ad364af6acb44f85b4187a840883c4b03497dfe564c45dd5a1c3769397f5808c816ce82009d9a573e3468f4075e73a1d9fe287318a0688bde5c4dc88fd2d1c6b6a9e17acc053851e9a1ddcb0fa7ce2a3527bba965aab2ee8e3fbcfa7af98c33e3c517775119d153e1a1e4933dca79485fef10c1c1d3d381869091d0e6ba5bb7822b8d289754da9b9b836d958443503e1593c82dde20da609d29cc10232d3bb0ec935d9751d5be67d2a84d22b2014c752c77ec1b9d870768c36a827295fc87cb2ff60f7c58b9d97a4b8b6be9cf4f5fd36a70bf141ac3937f73447776bc0bdcc3328cd115edf29dce21d8738e1b199649e572a5d32d95ff780efed4d40fe36d91fca6f0003de2c5388bed217c8f0bff9fb41bc97927e60ee8970302dc09371f5e7b5dcee47a48db20c6a543049ee0ebec4fcea9350829f6ea5328ea7537f581b2e77821394f6eb8e75b5a981447fee879c9f731fbfce788e20281884992c7d697c8379f02b7c402333328afd71d169a42113489f3f81d642a900bf76a3dd2045b493d4b3363dfcd64b76499ac0ce34846141bfed79a69626a0120e79d45ba27903ad11f90313f61143a5b43f35f97c91efc0de64eebb84de70de9e9d64fc0cc2529be5ed37a83fadd0914bd0fcde84ab859df6e8a57a4d1f329720fb6e247718f7aaad8c57994a9d51ca6edf92565f359a931555dd6f1d1f8ef51e635cebfa4302e04fb964604dea41c48ef917c1eab9776d2dbe6b4c4829bd5fe1642280ef1d0bcee6a4d897866da97eadf7470b15f1ebf4c8a6a77da39a245bccd283fdd1c8624cb3263821d6ba3dd81860c56aaec9188444b3b415147869c6c5fa71529cf087e9404f95242f0d918316aad9b09090a979987cdf1cb5ceb6b640391c9a0eb073e0309799017117b3eb7e5c172cae92f01d26fc1fad02536feb2767453c5c974bc971a9e3bc295ed68ba92eaeaaa7017c8ab65145816608f2b812a9e3a48f9b6ee27f21eac16e1668ddfc30b891d93dfd2c1c23966de3e931c4725be9a0010ff2753c6601b57a3099060ce3e2be04f48d500bb7dd51b0718564b7c5c77fa2ec220ef39e0da6767fd751dfd0506338024e59f32bdd61d340136453c10fa1478c483136fc3d824cec066cf9786245538320ce356f70e1d2b4cc64f591eebbd56c8c71e77cb43bca2b86300bebd14ce0f0b440995a064c4dc83f3b09a6eeb222cc78060740cfd4ded26cd1dac7033635423fde2075bd033cfb6332760455c8603257a3a661866a7229bf99ba583219a72870e2f051b72548981dd968b5c6a57986b9ab6cc3a13a11676fa8cb72a529889a1391a4d773d7f0905a8235c63ff21927a707b2b5b691d20e9182ae37911fec63bf4c7a62f0c7191991c2d7608f091dc21be1215fa307de5974e44f68fa96da110000c22b92462026a194fddc8039a57c037c85e2599326a0514d4eb3ed551585c801ae37befeb3ba3f208d9eaeb11e7fee1a94da3b1f5a514d49570c1c657ac26d1e63fb9120c79a1923cd60e505e45148ef599f7661f371d100a89e6b6b258418dcb15939d6044b6c43d1cf3e90fc2c476c8da2ce2969b18c43bcb3dcda271fd64790f40a3814c2edb02759b8e41c6c577243e98a6bd28ead3baf5e79c2d9ecb512720cd2efb60209770f8c37dad82264f0799d6a857bc2347eaa8e577e9ac1f1f599c34da0b6c40d77769fe00d868d0f042a28688a39b97966eb9d6f20459e2aa09e936aa4ef8817c79f628db9398b02c25ad8d15aa74c0d228afd3305f733fa88f1f26ca347f7bbdabec4fd183b6ab068c90f6724ec4e77b51e1502a9d25017c3d9bd8f4e0d370fa2c319cf620507e6753fe2e4459975884450df1ef07325c705a09e8d060a86b5b05664e8a790c6ed0fce0e6f2656e48d9c8c492771e09b6ff691e7c0c5439d824a0d1558f38b1526252550bf3a74ea2bae6b8216aac1f7b6fc5a8ad46aed7df6c44488117c0447409f0a363e0b8b1d3713eacd8ab7ddaae355afe313bf65ec8d3eaec65300058e35fd81d27e87a1e12d33813e823ea2da403f1a107472fbdb497487447ef37c6f5c110ac2df54bafaad47a4b848fdfbd5a24843b78f3ee892bd4d88170744d255b0f15e69bac7d0bbf1fdba3909ba74f4f77c2bcb9c2846c92188281851dd0a94e35c14eb857ad28caa063e7f8bc4c9a83461a4e4db34e01e6fd6cdc64dc28086dfa3b738e6b94578164f079c77d81879a3d4be5cfdfb46030d56ba5108441fbb8588f16090afb3be2b9a7b311218f90f59f29f156e23e70255eda17bec1913bde6d64dd2a3ef40d12673a16bfe28cbdff12a30b72cf88a012d0349de663383ad9632349abf77f12e8d197c28e64ec091beee4ff1344fb44ae4bcb55e2b56e9503e5db498b979b7f09f6a0587b24380bbdb591152f455f1bdc5b6589aee0fe42f43ce07af9e096f4f133ec0f11f4b5a4a9f9796dbd2e7de1fbc652220aa93eda929f560d4ff39f19da7c716202587292caed8d426a90b697fd0aa780c560986d6d27e273aeac11df62dda836cfdc885ac26f93889a4356fec9f0ef62b825586495034807e2162db349ae71092554eb07b9a0daedf9709a47697fc936f6980bbf9b35f86b9745984cdf47c427d46be0244bc9c18e006e671c48f2169937967faf2d249f629f3773a4f49f94183ba83ec32efd815518d6536898ef383c2d738ed2c0b684d88c3f19258014d30d4a12d282e1f6996288e89d8755c672a4eb1a42449bb2ffe5e78c47c7a0b124a18f8709b2471aef01cb0f843f14efbd1e63b6b4f07671c56da321dd804a562c1833ab38eea25d51ab337fa4e447b6c55d4dcb2fa841eb76e022fe62ba3683570d0c7d5705b0a33ddd6472284cf4cc39b2eac859afcbefbf5033ff23ec9725d34825b2b8e01c5b77947f5fa2ea88ee0dc80a91eb622e805bb1277c6adbdcf99d6e96cfb6b4a748c6183eba8cc691a3e2fe2408140d3e399939f6a15907eb94ef86b3cad1f0b34fb245668b92377ac90fa789e392a1e8d22ca6a8cd7b115af4b986c0d227597559ffdc1102361f67c5e366997df63e59151203b84204bf39cfe0bb8e7b361cc3da5129ad174190cf9179a04079c82c69b3eb0e3d90d4d00f457cdb257c506dcd4b37b56046050834e2256fa2d887fc0e1ed6f56c3f4f6cfa29713384fef6f68a5672ffcbffa3252fa2b59478f7de8ea179aec24eb849391e3f3d932e197f8657096c7e71c0ca103fd0a2421294a613fde0e59356cebd3cf5059187ee2e0ee471a1f0c339378e1d42aae726c9e2c661b6d2b23d32af9d611afa2f295ef0a21e1662fb87f8b05c74fa48beaa1fe53055fcdb4f035b4ec5bd76603203be17c3d28f9454756cf56120b97271eef46545dc80a43002e9e9bacb546e614087cfe6d0a5c1ed5a7564b0839b15f4950d73400e119ba8aae7ad7f8b7cec8f3556f4a819d1f58b38609d6ddfaa4c4122de02d1ac5d0b390fac694b0818b51ee9e5cd5a09e9fa9a274157f5cdfd7bca7fdc9b772e0ec2cafa1da2bc6a0f5e89fa2061cc12e14107bb54c39b6d1ed28b629d6b778689a8da7f0891bb5c342994f786d0b195caddcf37db85ba843e3dec9a562f16a0b87ea96dabdd5dc559f0dfdd4deb5d9f5f6aa0a3dc40e600ac9535df8c9158e1b6d736f8edf6740c65875e7e97ce1d481d9d589c47a735a9e58017fae457b0dbd3d22c32ae610685290c77742b1f1253fa80456a05955cdf0c59515cc8215fdeb8b77421233ac32f9724a2adc92a24f24d4d78ca20fff87ac3f4db1ac051ad224268b305afe8d86de226169b91ce70b5bb5c371f0b694a4ab63c952e02ef31d5dac2b3ad4a1b043877fc250cac40ad682000d8da09513a3ba10f431bbd1c5a75cbf8955851524eabc0ed32540fd417a36399555f1014978359319158bb859ffd09a301bd6986f970a79dc66eda59a680e398eb2f6478b3bcead9969da5051dcb9a39f01809d2be3c4eca07795cb6d07881c11b92b03e603d266e93460e65adcb0b17fbceb13500c29e53621be845a0779e45a80dd2e053a8fe4a7392655e0184589a69562c03145f4952c74d00a79a0dc299d7673eba8ea1a3a8caf8eea4562d96fa36678d4de113d8621b463bfdbe4638293d2b3f634bc1a79c78ddef37bccddd47b1998965581bd1bc4c6668ce7757f98ebf86beffba22e2c588606c0f17634c02951a846a1daef83b63f7a5afc28a483840dba435c8ee853bfd5eef005fab055f0461b2e586be8144c8d95e31c6fda55f7e91c12ce9b46399df29e6fff681200a717900fcabd132be5a649011f0d04d5210e35c6e71eb7b7cb678d7ca169905ec4dbd23c425ea74025911f9b770ac5c2c3abe4fda6c3d7893c786ced63cece1571662e0e103454e7025c65ef9bff53113e7425ef3ef1a8650b621ecd9f0c0e14596ad419f8656af057b7530be515182894f5b5ee874de70e2242ba9ce9dc4783af89fbd38ec189ad8fc6484c68ec2baf04607f0b9ac7d9a83b77649318c58350f77f37629c79791bbe8dba592882bf11168c896506571b3e9f8507b6417be28fc983f4fb21a9d6f9f7eb78f9807b581cd314eb6d267924e2485a6d914be1ff6873a55af3ffd102c67867b5a7dde17727e32c3acb506deaeeb0e6d4f4730198678158f0fd2f50671802d13da4b8cf01c36e3db5aa8d5c8e859f4e44683c101fea49986fd2766ba5a73f2ae469c53aada2eff6a2e0cf483f87115530e7fa1f2d15532eb2519c172ebbb217c6d5d0765985699b35071c58155ade69285b43de2391cd10c9d5d391ad2b934912128f1502e52f9e60a6b5528be1477f17804d09fe748b78f2ddf646f84813023cdd7c4b1bc65ef432403469c94045962e9369d8d8699b05e9c5c7e87d82b73555ab99aaed1524e9c77b357b70fc8639924744840868eb3fa1129199895412c16410545532570caf77d00d0d09720c72c1d6abbe0ad54545b7f90029bf35458f4b897d8f8b687bc04d7cc8f6bd25e1df63cb48f4c487486e888009d40657a07cce8afb36e91f4af6f480fb73f12519a275a6c57695bd5dcbbd44babe269657561e74d3b0478ee6a84267e45d417f0eee4f30b872671ddd393ba93a523404b4dae51a568d16edd67bce113fa27abb428bd618950c44eb5991e53c60f2d20ab84d21c3225b3cfacc6b193647ad697d1228a3a6c777b4895dbb434a09e9891cdcbbd9dc2e4dfa284b513fa6d66a0e44abec943ef7cc1725029e4dd3d0c9aa48d1efcb734b4ad32e9c268b3f8e3d90512ac2cec3395abf1dd10c167512a9351f9433724b0fde3f4fb644304391ec4e0eb1302a8bd347b593e8a30fd8867d39f429bfa6e44cb10565ecc6aa0f90ee03b62c99ed615402fcb757183a57e8632dde5fea04841ca3285b2409c0d54cd6e68604995771c03da4b99dd80f05da434a2c5efc7d8375baa92179014afa2278c8afa5b2705b13b0ef2aa46d5c35deb8084d4e05333ef7406ad4271c35c6587e911c5e09235eadeb03f7240cf2a01e1670deb41103c26022eefbab5327408295162876eaa09114967b60d12d560d2d4bc43d57b014a1c6429c2ff301d974aab2352247eefa2d2521e22c6d67d8f61e403fdc2887ac8488f163f9bc05d50650c39b49bbcfa5f92b89f03cfc3f06342b017451c59ec0d4da456c5e040d3686f863a553ad7361096bf48583c02b6bb68191db85a003d7d301ad4814e6acf03ad2446e1626793b7eb0b3ca00a73e156881d33d82b0d0804c1d494ff27ef05f230f67dd51b5af5af94f60a879b8a7cce4868d8e3d1e94c6efe381773995ab73ea25586f58d534f2ea2c7bc4170eb16c931f353d5b5ef593ad5dd49038224cb2e7803fcf9d38a65041630b87120544ed3908a6a64c38c5a6bd08eb0cb53dc038f77bd2d65a8746fb67c02893983d3df282c291caff71e4207bed8515c4bf74a85a281a3781c8a6a2eecf6e0ba7562bc3915832375ccf3ac1227bf51d0da1d58cb01d3c42872c3f19e08b10875768f61d87bc164cec9574881d47126d26712d689a5d8a889d688a291c8fffb514302aef165cbf5c696d5c294365591cd708e8073f5f2ac1e86aa8ac3e7c90183c45f41a713b2efaa2cf5b42d8669b4f7927653b61e722d034b8033d43491b8eb15e43a26bd6fb180686cfe27ba76a679f86882ba5e629312bd3e083e661ec4d770cb52efd77bd39b1c1efc1487d3551037548b06def648f8da02e04398a17d29817fc8f78cf283a280a5427a6dc703639ec2a8fdc67272d4020121f98295576ea9c8545e3b627b2fcbf47c724d264a3f099fb998ecc1a500ab09b40c686edaf627bad55eef19f5be051bb97fefc0bf91f94abddda2fdee3492c8908eb057e9c41b66b0fc302f189ebe2737ce1e1f39d901fe612aed88bb3fe2e59b59ca4220327e04d250fe97f91ffc8d4f1cb2149dea9ca00495dbb8236ceb236618d08bd494692e349c5de519e6181","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
