<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"821a112494d694bd8209028c555644fe75e9f6d9d404a5517d9383f6d2253ee1bd6109f4667d2a3eb314be497270f46accfcb9caff0b32d02790cdaf072b74f42013d03b8329f517552f7d34aa69f31153c92958671cfda37c61c978f3f3a51abb3b573f5a227c645f218d862952a9e9395f3a29ead99f567cb2a6404cb348928c00dbf573e51e6e08a91765f68c99b7e11b6e2c2921ab850e60e899fa8faf67351f6efdbb86fcc61a864788ff3260b7cb998b934812134cb1db46aa2d07fd73b03b1560f41d0b0d4f1394ac818e34f82b098cecd736bd670c34ad0408e5513ac619481524a18373316e9943902d60b098064fb8df95d606f5741b49d5d39c71b93899973b015a98ecbdf52dc2836ef99498d6e9cf2a7253fc42c8f0640614ad4a22a4373aa757417689ba5b64090bb88fdbc0a77577af0c42d40415c8083e61a15e51125873db6728d4541f161820cf1b2b4c0c7eaa86ff7fd655810ee647593b42568e00bb685926bbc467c5dacda0f200456c39cccf9f0e725dd3f2d5c2f47f425908a352344ec5558b63d76ecc7502ea1a3155227c9cea984d54880016b89339d60973be677331983a8b77f19b964080b75dab894b2cd6e10012ba1d67e283114aec540c468c2baa7e8f2b3719f787fb2e351b307e0fadc23a3af4fe7c960582378f874d8c734e458fbaafee557ea54776fa9cde889424af459035d3e7d5cb59de04334b75b78be3bf06f6797d848f31af6e3f1c3415ab3ff64d386dfce599e1954e35ff5945dbf5a8d24da44686af77cc6bee8363b5439762232700d5d71529016d5f6eae52ff71aa4a59fd0f7cb1ff5d51a29187c75515647f6ea7afe55a3760f61b02e99e326a0e5193f3fec5a47b2680b827bb1e0db5cb7569c5c08c61e6b8f32906729196d637b79c1c176d39df881f076668c5a62317fd79d78a32fa6e7d24a4af94cbde866fadb17121cd11be88983146767136417d6865f5817dcb64ef5f40cabc2c2a78365d7c48f7e6d3f538a1ce753c86f1b8e0ccc6589d0b640ad02aa1329633632bed735e1fb07358387a4d28f6b305efc88e7a3955efdca044f19690a3eeeb4614dd9438e8723820bf0592d1230e4b52365f658dc22363e54a72c04335ebd731d0048566b49d97f41cc396dd96de05811e647333d47464bbf9443ee0d33d5dd94b82aad353f3f7b914dbd6f3f2722ca90001253bd4d3e677fa04728b32fddbadad2682eba4d6bec10686bb0284839d5f924f9fba3398d7b440813bf69c0b7a2ae36772118d2e734c1acc1298f28ac825110c7ed4bf5e8fd56508771dbd8e8572ea285fc15b6229389b7a49c3acf7f3c78330df738700b1fa3f8015e9f480d8debaf28c59ac2a49897381bc53a1ad6e646a4bbd4dfa29f403e3dbe1dc775f20ccba3ffc0cc8071c84d1efdfdba48aff683ef61819df420a103611981b5b246babd86e74d25781509577c45160040910b57e9db43b16e7bee973296437e3e554852a3b12fa0b88a0e04a7e8bf7cd452f5e7f879f80f066c1f08b340d726b70f7d5db8c09d4e9bd3e803feec1b992ef5baccb3e6973a6dbc8062df053d49861f55cf969b2351339d09d48957ee51b6ee503e2296e3015cdd82af638f2d382afae178fde81bec6f305ebbcba02c9274cf6ee9d7755fe313fb84b02b94b32e2f6d19b264a14d1f1a601649466b73e5a6d3ba42af4cae61431041b8e1785aaaf062109c27c3e5bbcc35058cc6541706fb934764c44a3f44d28ee65578c63500ca82672d97885d09ead8b6e9344b104152f104eda80dfed39f255a2e629fd7f9c974593e85fc8a36915949c3bc7a803cc70fe954a131a1ed05cc3fd7cf31fd9f630bbdd20a317e39ead10b4049a9cdf9c08b8bfacc0175d8471a9ab836d07c48e9ab9caf3366ded399822b2214b7efd5a31a2e43b62cd63f36a82051dc2f8bf2043dac875ee50185164294a17898eda84228d2384db0485dad2fd8ed7cabf885f1a56e77ce38ce54bde779a5dddee8dd21dbab2083e5c4006a177ca94d60c74b09cce8c899aafc3969b0fad68cc5caf4c4de28aac113b7eca9467781ab6bcd4beefbea59288134a878b4aaa32369bf7007f4ddb6ad5d82a3afaa398cb49e54e17856d5c929474a1cdf8a724d8d156b013af74ff54c211c0d742536ede36f3de1d47bfd9240d529c709f5c30244f7a96d5be25b18d8822483fd7fe4aca8111b5f123bfd6f53d41e4dc5e9e14b90b67adc4812df5f453abcae6f20c5d59bdb1362c597854fc22b9267d0929a7abdd9d52615fe34903e9fe9fd571c0b9a4e0b4c2946e649eb5d7ad6f29efa22a69b0f98fe25d37ccc38c8c6cb0394ad9e929b20711d84e7068fd52b8611de52b6dc4aefadd86378a0906f27f92dcbfb87e42ace2c370a522341408608dc727a264a79cc1e8530250a6111b3851bc9f3bea7d8a91720c894a7c160703587b2d4cf046be636032a193f1aef38084bbee14e2ce161cb2ddf441d0ffd63095e69bd3993d393e8ecb43fe0192e1873e0634c8a774a1b459bf6c9a1bf8cec1267e6a0c8944aa7a296416fda16596faf7b6d2e1b151b3a446a017eff3e6528fbd1466a7e85e875a89a686d29042cc05dd6e39598f39c05247bc39ea1cdec270f3ab27686f07d1ccbed5acd7200322833ff8c1589f667adbd92988daa9c70b392129c42698265ef9b545e8c79368611ff09da9172bb382b8bc7ed69fa265053c36913a5e4ffc49965b25f5a20727ed580589f0962c4dc4a1ad785b03482219f54799fcededd709db5e51a8f0efb5d51d125ed3338f0d5f7441c29b1b8827e1293c99490e7a9ca6e15a0a00ffeef3d08bf111eba97a9151af64cb6f290c386cc6ac1637d61f30764b4bb160575edbddf06e0b6d477fee08bf83a2e928138b1aa81059696f6f22f131ac4269e7ae58e031e80512eb4fa425bb16a7f8063cc8ca73a019694543e5c3e66448b2c2086abdc1d27072c523fbdf46b946e0f0ba8586d367b6ced4d0426fb7c5ecf3a6dba932b3688ace6dc8d063fdb5330a9eb86cced79cde8e7d7a6390fdf632335eb614cb47c0ac1ef21628545355320ad617e3e4ac82ae8ee6cf7f05939418f262f7b7008fc277432fb1b3c3e86049e10076e4be1d99ac8414fb988974415b00ed5284f97f3fd8132af778b363ce23bd3d5bf62af7a5ffc47f743443097cd2539df7a2b421d424be02dc406b99334ea945fdbb643281332c423f854c3627d19890fca7d2ef9c427120f03109e8c8bccf503c8dc864069b589613bd2bf8b29507b79a5ee0c8c291a6a81ce9cf8ad3e698edea4690171d7b4c7ceaddafccb7916fd8cb7dc5f8bbe10e4746073c58ed8fee0cd09fd6287ba225ebcd3ae966259a43a60d741da1743e78c262b21f4fb5e2d69f733bea3b27ce40e105206bb1b579390d258a6d1c86f22f0d6409720ce2cbdb67132420438ff6fcab45f4538991501884a72c6e84851ae0598ff3c09f2c9f9142a265de0c79c334cf677e86411d1bc9166ec0c48a247fa9063256676a51047fd611aa579d488b3d9a6e5dc5279dcd7063a1d647a4a6561fb0cdb982d3ae61c3e890b22c683e60bf7de9f5182f83caac15e4d77aba9b4ed418ed9a9c2aba7a15f8e25738cb34408179365b46f3f176a47c4f95cf858bbbee3a5550d1fe60205a8ee0196c52047ae7549bb6bfeb1bf644eab36966412853a5f1b39385702f6a6d80e359a8f4a6dea1f74b920ccfe19724c6a2489cdf6f17da7a17b7a8854b0002ba767abf4a700996aed44072b382172c834c1c77c84c80cc21123191d42f049e493f217d0502e90f4a2d039d200c2bf8741c8c0f6384cd201d02f2ef6444b1c4f5c860370d6f0ed3d9a02323122c6e93058135d68bb2c5002e862de7e2738d8150146202cb0ee2ee46979d082646beb9af49109e394b2f6db86f69ca531b2fe2facbc26725c384dbc57b4d563ef2f1cd28cd8c984ebf4bc93aceec8f72f46b4774d73bb34c0716631be00203671368276414874a068254815e54251014469bcf61a1b5e36623ba8a2dde9ea255ffaf1756e1ff8e6541bb55360d28d5e37aea2de65942e31232df660595035fdc44e34e6eb961de3142a60082f0c53f2e0a599c5b4855786458f7f44b1d32c24924ad9ac96aff602b2cc3b6a65518c7c72e87d85aa6fd47c0de2505e134e8e230d23559f7dbe77d8b4e69ce6a9573fb4e63e513fc71f53f9b767cac2da57a5b2c9ebe736fefd25f18e2c098570fab811bb16dbe1745202ef41cd0b8b87ad872c9be8d114b44b62c313f5d778e177e37d6795bd46a7a750ce64b5249e67eeff3b7776876b2766745bcc8e740c7d582f5d3647b2b14e141c9f44e40690684a6618df33722b5e6faec1d810988f2ece16489f7d664b408b9c4e791d968a7eed4de4cc88e859edcebc7ec5dcdcb3298f7c17130882ac526eb9ea15cb0e29dce04ba77ceef5a44811e80dbd335217077d650c4514ad351bb9d0823eef242ec21ddd2542e8413c55ae536780041a57b01da5ec4ec6e80bd6be62f9783c4e20f5f54b667a3beb9eeeab4dc0ebe85822c3d6103a0cef52141c65ff231cd4924e2bef28affed41d12a7be8933713ec75845fe67154dc214d7884c3b7d9fca643d77b6877d02e297f9a11602f718aeb1a353bcc7a14417fec565056383190de69fabf06970729f9bd4192a8ba2a6f3f1beaa378b66ddafcf30328c0a9c7d1f91f7e1b11750cefbba3230ed1e20199edf0c456ace18f12dbbc1df41e3263ee9e8ce414d54398407e8ca007b88b5f4e37c35e0f0253b627e580c95c17826fbfc299dea124ae8ab58abd2d6ca3c66efcc83f8a3dc28de43cfe8794eae0ecfd27ad539fe92c7986473777b7dcd51cbfd42531d5f2b6783d6aa703187d811401268dede933dae2b378a554a35dd20cff3c78c375c5124973266f4696fda978d0126158712bcfbe9f152b54f490eb50dc0be699b1f5e473cb431ab67550d5530e6606056124745a83fa2191eedebc217a834bc51563c122d3281f2251c762cc087f09f27ae28ee454b0d1d596682eae1add9e3c5c322b2b123da1e31cad0dd2f3b0c83ef2e55e025da202d2f1d1d0e25f2a039c9c8f6be8f165332287bd6c56a0e28790da4a30636f1d2bff9ec0a3e7fb5ac01c07b38797a8a9a4d5889fd344c7a6c36e439cef1d5a040dd293665ed17e81812f7a25df5857e0c134c70bb21ea1c40db40a13cf7929250927fe807a2fe184da78fa76516c6fe4c7a1f021a857f8f7c60af5ed769e0de6fb02b5f722e00d440706e34288f9a36fed20c4b14707502956ad5fa12298c2f01f3741ab6ad05e892d42beadb99ba748e8db18a684228798fcbda8c969523f944e6fb1f717c3bd38b926e33e0cafdf8618112bf88e08b9644cd82a54c77019850b91136498bb4c191f5855f6c4d3233513f09b0ef06fa59aeac43198d1ce0b211e50950770dbe6a561a9d5f8a9f9a9cbbfb9482857b940cf01346bdd3f78faf851adc84ceec703d53419ad1a8141b40ee900abbdccc6722bcf59f1e488351df8ac912886f5af1d78c0c9b1f76a33331231ecaded55639000d4c9bf5e1b5440aa50f12525be933ce1ff3b5d1b656cd28348c063090d53f6737336d64c98b75808290a51acf8fd82f39ca16d9fb264a4b90075f79be5311c8d1175912cf6985d88e70b29efb2fafee64a92c1003ad1ba52e0c2c6244fddb6b226e08ec1d1282987e0c11a87c19b567741c913205b66a2c9c555a15c73d117f9e234cd5547823e00f0cf815ac0bf3689463f16bd08db4b6efa5ca487e2743cd399c80bcb0cfd103e76419bf303eaa290c5082ce746fdf1f9afa637ebb061bad3a0ed5070a18edf3cd7608c495119b8213e5d3f7c05fc79eca7e426614a06b9b3eac82c62d90f66ec7d0ed79d53b27b35ac7e53bfcceec4677d85e28b84782c2601a1cf4b0bce519a8a7bc76cea57058e80af78c9a95fb296349652adfc4a8940dbbc3b32f89c2881754da5dc2b41c1457118afd3de6d5576c5f9d19ecdc2c4c64b30409bfc840384312ec36ceaa16fa6baeee9c2c12149cc1ef461f12e9a486bc7c89b6a4ca5d1dc6cfc764b89dcdf211b49d203fd34e2cbb4fb26e51e97fdefcd8030501564464243d9fbd6fc2b2cb54b521b3c1b39a11a6cc6e5b298c07627c1e8a91df95548e926838b7293cbdbc8f895b7c810a7c02fa67f0bf784869bcd7d149cd1ea08df6cd0c2e66670d40aadbfc3e4afcbaa41baf5d25c034a855dd7062281c6c147e15d8bded635a23f189eac2ce6a3359b42d41bb7172ea9fe478cbb152f34b83ed1c60ee65be5e62ee4b2c7d33734f3e8b5e83289539dccb5ec23fd805f9af4e8648319e0bf13f8c4741a8b752b6446ae6f5894ab44ba57fe3cab8bebe98b89006098290dc72354bd2982e46d0885032b42d64f9e387d8f0a1dde078e2b593e816dbcc8b818738886fa362dfcdda204e3e658e2bf5efae8a4ef8891d20a1880966d78556db55a19d7e7b2389fc014b52959fa0b976be8ef4071ab8cfffc617b78e299a8fb35067c5990f6ee702dee7e1963732a6ef4e1d694139a0ae28806c5974222bb6edc336360b5063b5cb1c8328c5f419e29cf19b3e87101bd6c83423614321f96e641d35dda96e74c90864d2950c825b1a1242dc96f6551cd14f0ae885ed4ceada98eb7ff450532d7fe3b8712ffdb5f0fc122fb82b429f1c36bcf59a62960bb3253deab6c3b03ed3772c1e658e2a7b9cd4106bdbda60ef8a4e6b6c2bc9c00713b2d05b31eebc25a9c2577fcdf2c43f0d062c9ee70fcde47477bd993e47c1e2fd56beaa055f488a2b7916c096995e6c9b64d88f3b9cff320947dc8bfe2a814cac768c928b6c1a233012c0a69c57dda6a41efc0f6c885375f42164c1c86580b9054f01de8de58efd8e4f1b137d0b04cb1358dd7c390d8c5b36ee67e08e115967583477fe4368ffed22ff131af69c92c0f340c02237d14020525e3a69a2843f2a9252ae726a6f147540b542d0e25114b4eaf44189a7a0b838cb01e880815d16770f5ec8cb1e438a8d2caabcd66e8b3e397ae64409df8eca99bf3266d8e662fb0bafd30ac96859d758d4e9e62052ba2b67252c24a69b9e6ef959669e4359883da75d14812eb0e2c46e8734f7b01be7068c45712b04a94d323ee49da6643b34be3fac3784a0f7768e94a13921a159eebcc099b6b325bd7759cd698ac6ad87ce2da7bcfba814a665ea92f2a33c5cd158e4db13da3501f189383a096dec6f100d85f2302179e53b7285a28c5a3b1d24b62af036996c00e09bc4ceaa2faf09f7d64c988ac3ffc93552b02906baf5853cc18349ec7b07ae24a94082ba25ec0ab4ecc4494f95c125143ac35bfaa46518d294666e3e6655d4605a619c6a2e871144934d44cec2cdff6686e087670ee63cbfb21f87da1297f320fb5b1865c2a3d0593b3d5e7c8c3f64d88652dfe788e3290dcd251342b43105e6c4a9bc64996c082c8fe222d4860c47222745cb9db0dff86147601c3eaddfb0cc82e06cd063cfb94133083b4ea62ffab9bf82613c938cd3ce4f43ab991940da96cc4335744e4790c84737dc5991f2731c372d9fb7860062f7c37f1b7ad8642d6bf8bcf053c3d2312c521be88ad6c8e296d21eb257d65fd8dd9f57b895852489e56ff62852e6d47d1bc94d9cf23ee399a3eff6692a138328ea71add9cab2bc254ab6815f5efa5c96bd7f17e7a22a2f2c54f5907d8f300716a407eb2c1521031ce5a938f4b5cfb0000683efaf2419ba24e73fa4d9aa9d555d4310bd0fc3450fb4767a21dfd99f6fef87b423dd074018c4842be262644313b2b1674962ec145752cccd861948916b21ac530ec687fd1a7c8addaf1ea38c55fe33bf32b027eb39aa4e951c8bf5ec7fe1a2d2ba15031a5e14708dce4551cb699f7622a4ace0eb2f2e29ad86b5f35c374a9e915f87382858cfee921f7b48014c81d9fe7bf35e09ce0de2696b7ea9daad7e3771467990beada3dd6892a5e32f1d237eecd080b34657b3d89c5faa0899d38a7428dbf35b32cc92c151b637d08a00afd40cb942bcd9b0ff3bda2665b0c0184810c7205914ea27d11b4739094b9543bdb8590abd4365d19ffe376481ca91b21b35b76a5070d7f872781b49c770b3313a3facc84718aa2759510a2ab28bcfdc7d047bad6f17ffb66df5bf79b8fcec823c0afce3c665931732df9def1c992853b8f732adc557461b3e84cb2e16b9c9ea9ce050e117861f5f45a20c69f0a2223af73a1af6592aef3513be58ecace6f2063b088d59a6e88167767d6b51f2e4cd1dde2f8cbe4adc8fa503245000f9bdd9be57ca1961ef7bfd465d95891428bf9ddbcae63b6e58a22976cdcaa96b0ff1cbf4e2759fa4025c7c5d10406e3508130627a4bb8b3fc243b255347264b5c23e6252f1480b0ea775fe5cae5695a9cd101dd669f7a12e419c7c50d40a2d2976c9906f523975ee14915d336db2a8f9246d6e02d75a026d404ed173b6a3b1c47af8939259fe1560ca5ccb037bdc36f2ff42dccb8245dfddcd1e8a0aebda74f15ff8aad73e4ee0a0daa4cbc1378de7ed2e5215edeeb9bc7cc00fd4857177367bd5104cf2d4d808be2b2fd97eba68a49d32d11513b6da9c9c27675b3bc64df35abddd93a826329c89c181d4452bb2b6268d6c65b9382f00f05031a9a7b5dcf37a84ebf87fede951ff2f7ec4a3ec3b628a91891ee42caa0fc891ed736fb453f666e3d686abe6ffbe88504443dddcdc7b0798c856827a6cbc2d747da54f27a8a7301d3b7e1082b93d4035b8aa088464b50717a8f7902da95cbfbe29b76fdc75ed9451e14d6a1c9b4e58b9f44d70402ac2a800cd1ab58dbdb66d229abeedad3a45a76761414f4e40188cea3e98ff8a1431d43395345008fa6901aa0939a680b6afbd7f0d462990733a3362e7e36fc6204b5cca86a8d112787d3a3de1e23b45c3b4fa9aa2e50178193e003327ddc235a251cb3226d5b19bc714c6b35851369ce29f26d9924878ce76df23b4272f0ca800a76ab14b5c4355df261bcf68342c9e9a8aecf0da48342dc44162b59383c55b3c5c7d40b6f89e7466a34c42d6ecdedbf84b4167924c635776c8ccd5cac46eef1b221cc9a3edc27557f25e1b9fa79ec93d1aa6670c55a5b9755709b08111a0841003b7f810060693f1f4641c02fa61f9a032c926e7d650cbf71ee0bffafe826b45acabc1a27bb9788dd01c78d2ed813841055bb1ec15110ec74b5f56bdc8d22942833a7dd4e02c235d5e8d93d2c6ddffe5074b94ca774cb6da8056f6eb34821d1510003fe45a45d47cbef3c6026df08afe162196351e0322b8b056fe78ee62b2dcbb04c1a936b97e5da36488a83d759d58f62bc2877290ac3c0e21a367030e0e2225687bf56e1ec04ee50116b2c46298ea1fa933f27f5777d5f582da171c86829ca21c4f2f8b25407becaec96a1e49927ad07d15ebe222d51befc02e1399c223959a6257500f2100d189ec1088cb8696b71a7b61e4e564840d748eb2798a5fff710bb33a7d6ef892dc37693b5c2cc90898838c5c7fb07726a89084824bee0827e83a267c7f5cd230f76273ac8618ba0417afc5f4ce2c33c442d9422fbbe5ea76a27457ebb53db56b2b2474852b5b7d7cea4b99e33bd90589be8b58a6ce4e90dbf67f7d94cdf8e632ce91109492045975e9ef84c0fd665bb865a4341341e5cada1e550561130a1f041291307b74fa6665d2a5d96cb846b74efb6df4f1932f37cac3641348e50ffbc4dceb3d7521818c439e0737f0ad00bf60b42458b91d2c2a0f9c1d2e1a6ab406a85ea1d02c20ab40e0bf737b5ec83a49421a94d8e7a47172febfce263aa964a5b9e322baa146dad0597ba8767e935f44eeda6460ecbcd6c1782a93881459e68c8df83cd1a40676365d44c659bf68ed506ddbe6873d57cc6e84fea85889217c9fa75fec637940e83a6fcaaeee6986e182c485f75786d49371cdc0da3f294771f3beecfb614fd0c1b1130f4ae2babdd8985f97437d21592c389297d8b65dfbec01491d07995062f6ad025c54b7e38d8e33a340c9ea6ed670cd129ada242cf2f40c7a34331653f355bb5cd04516ae6df75e78a15279b93c4595e88df1e3507a5a501811340273ff6c2fd792fb0e36842a2876fe5082e5b39331f195449e48e2d70be21fe0114ecfc04d866a3d65749dcfb8be2e3a443af75284b6e7859e271b9a832d49860cc64c484adafcb0ee772fe8781b825a2ddd0850910f8d35cfd7f7b9f0f10f00166aa7d9438332a057a453b45f79d1c63880e19a23f111a8d494c0d4f00076433fe11e98b2a7dd614c3eb701edc669c260de0c81e28a56d84238de5c7f2c6382cb7b0e258bc78cb71b4b683e62dbd1958ea280bbd92f8cebe1d1f93c3d32acc0acf5d8ba8b0e1958a247274356313246d876513cf06effc78024fbe464779e05f194d7e12f7d5ad7c97d0ff2c5a32a9d1acd2fd36d07936ccce0d44ad828fbfa1bac01ecddd263c65990eaff69a7b851aa173c2584ac49a7b0d24867c1e6656377e5c86124f7937f8470e59923ead260f656dcad6b60bb5c6890e52ffbae3c33c490798c94ed83b8d0c7b336980e49f84c1ac81bb81e5aad48cb1320e93e974ebacf454cde05edf48f2d40fe5de164de0707a4a189b6e3a2101685eea39474fa7bc9b135dd77e69f4547465d4dce016527a272f0d98e1a9b2640745ceacbc3cd7c14bc7a990d3a19731a47578929405fa695711a86bee0917eb1e615a59e87a5cdb04a3136d6d87826bfd0d8f7e86421fbf2da0de8716bca22a63d65beae933d17594d53a1b8030f61d89a9bd88b9dc5715fa09a11da0c34c43ac3c76a68ff1f5c8afc6ee6f679da89e2031ee9ff59b71c22692d3ab4d5f56b640a269986605645bc4d41c026c4ce9f2cfaf16ed5961db28e3b987483563a2510af8c6a5bf125671135a685d84d3ad53c588628528d9c5fb29bbdb173c8868c62cf52abd161773b8b0c206a927a64b01c2fd2b2ac453a48337aed03adc367b03f02bf889de8ac0f0a38ccb8faab8c5939f5adb57494152736b85d41768da51c0a44851cd0d1a25c5a714ead50ec149dd34bf1cbcaf07f722dcbcc6c1fd724943dfd0d482607e05bc61d1aa1ef5ea6c7e1e4c0a2f4acef23b6c89c15daaeeb112b5e4dc370eae2cd8f7d119d0e6efe7a8f0034caa7f9c69bd3bcdebe68226ad07690e3866a218ca7204b3d23afab1e98e234d0fd214e700535adabf8c4dd1a29394d2f8c69b51b6cba5a3fd158ce55009d105cbd5a9b4bf99db28d197b1a6ef636e690f841f8fb209d0e4624f714e85ce080eb7a6bf898b715d2f1bb0202f32fee119778d6b2a75624659168968c46f4d4698bb50da7a4cb419a7935f4e6b0f82dfce90c89789feab004289f87ae7fea391c99d1dc1af5b4f6dfd438b47acac44a0c1a59f99ed4944a8ebd0617648a0297825ca0a342ec27f24c9d353e019ca6a27eab5e3a0ed3d104024fd7a9b98bb37095ada720888b6cc918c10d1d994bd99fa7f1a0ea98c8463e8a7c0ace6b3562056c001907dffde198d1c0d405d2ebb882b8c0612e33c34bb48d824c75541cea041784dbe5519b4f4c83029f8352c1dee3db212676ba1a06168e9d9415b9116f79144a69e609b56390af2952da680fa6baa7521c96954ed548c9cc7fe67bad63fe137c03595259012ed8b424efa77d4a3e4eaea495a64d49a530fb3c019de86a115463a253cb961d9f12bb73b772c67ec43be526de9653196e722bfb05199581f044dd20183d0e8ff74a53d5ce02902949c264814916527de3726b0831d6733da9792a1023cea6ae062dd007746d9997967bfcdf6865d0b0e11971c90e4083663494bf56f6a8ddfb78d388fb6f780b55c6e33f53450fccdb7b80d77bc0d70b43c1a2e3e4653e79ce65a680121cabc8146a2696406075995085aafd9b09c60cda7328d03f22dac279a44819a88a122364529404e60db277e6317f532b8a6fd052d073f4ceac959316580e8242e6413155896e529d668b25daabcaefdb0759a78d1e83d7722e2d04566fa4a646465b650ccbc8decee0a34bc343cf0a98be33a50ab97869b86b6cb5bd6cc6b6c2d6232b31a1529406aa925aa6584ca05175fe5ab96ed1880f483d2ad631bedc7ee738a7fbb9185420a3ced21e355831147cb880993fcb69974482148ccea38142cdd3a9f881f3e906cc6ce00e6362bff0a9b6723a070a5c4f2c1ae61f859f5e73fa3bdeb090784e5d0cb32d1d2e0194ff419f9783e286d1931ddb71dc1915a0beacf2937467baf76cff4ffeb6fa0276ab0cc0e474dd9e84668b0cc913f31577ae0885dc37b46bae935dabe5dee43fedda65fc6f201c9d195db83d37eacc165613cb97bc43531eeaaa864055e2d8c634bbbeec0018ff579af20fa8bc9396aa05c32cd4fd67b55981bfa8abe7208034837824f5e60799b1fa8b8427d9f77fa9e1479ecd0e8332633e122b9cfccec57b9e13a40a3b1a3fd69bd2e4a76f6a289186a826b9ba69604ba2b8efc5fa669eb4da0eeb2464e6f9a985a243b8d58d668183bdc82c23949c3d8bd96781d33e9f0b4df80edb87b06bc0d6ba1436dd68db141608224cf7411b7269d42b813cca5523f24874745ee70e9f2024eaa6f380f1048a255584b5ff67fed728d70ed123179fc3166ca088f8febb1e48e4f03c106bbb91efdd75821ff947efc93adb50b5f89a5b5c2c0dc3a42ebf273773f982968337db024c38a7354de3f7c124b7ccd217fd1c0d7597da255c15076ab4235635816aab85a3bd0b3bc20443eb2dd2757eb62d83b2d43bc242870812b1928ba12ffd1571ae747e25a6ba04f267ba07cf97f1c6a83959552dc16dc2cd0bb89b4cc53139597f50820e4d624a812c8861c3a3dec425772f3062d3b2eb565eef4879dfb2886387529e65d7768844d3ecdcb557201d06d4b9b8cd273c23e2e9a8227350eba11628033b3843a70b7a2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
