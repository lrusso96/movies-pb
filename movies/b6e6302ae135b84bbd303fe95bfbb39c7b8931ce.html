<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c5a6162c7f6abdae85b3f774ac8432af7011e0a02fb896211fe9f5b5f8b5daa342e2fbd1e6161f684d4d90b4908a6abcc4e319c64dab69ac1a1bdd015983757868809a4a16e0a5eef93f8250df21c94e6a3ef1bff62af955c6b5a67e79188a83e4eda2ad21df2e608e136620007a4b3332b9efc31c012383c6f7cef24885c244748c0f3eef0ee213ab1d8be3302fd2eb9abbfa1d3dccb81da3ea65d7dedccf7b334b9d90eb327b01257de3ead11074f768445c7b9da3ecb02ea59f7b1c416f6f1c80e11a666b707bfa2f365e79c269900d92555ca654795e7d27135dee1315adaee97dc23e502dc69510e8b041d397726525465a5b619101bad7456998a9313b2067bbed3d390c1e469d0dd4bcd7f93d264b3e3e9fd95a27889ba6bee36883969782f2ec365a3295bd180906f7f56213bd6cbc3dca8f7f618fb67a8bbeebc2bb797b78bf57079190f36eb9d6cde74607da717359592435884ec9656a545c9b575a537ca933f5b949dab16c32e33d6b101aaf75489286a76d0e5e8cc302848a480c76f0a18f7e00e33cb8b9d019d778584f17186f6882dd28c285294b61f95bf43c5b84f6e4f3cda4acf94328980b38b26f9a4d3dee827deec01badc778ef1834513e517c5862ef3ef7b4f849fec59bc32fa95b570bf123f4bd21c8cd49e1eac122d86c2e6f427877ab9612949718a46e1aa0423b8e434d648214fca02f7d015b4f03775bf681dd2171c9ef568ff234956857dfa05a73a3684fcd8b7a18d77f087af962e4073023abc7c18425933123ce97fce52fab078733c1328a5a69d6586fb0349e5b91db2aecd749c1c913613a5dfc5663cee00188379da54090348225e9fadefb4d57ea178874301920e56e3b41a66445d23d189cdfee7d157e36c0d214431095d9ec5160d0116d4ce2dad1031574e0061e87209b6a77bb42414d5c0c143bd83fa84184d9f11335dd2e9b6f1d843e3edd6fca5929981079a5c4f9cc08c4e77adadc59fd92c3a31ba09c523333037112736996f5c98893c71d0d39e75b0199d2eea2966ce4d0ce684d9ec134dcbc9edf85eac9b357eb8a2397804ca2b2b1839e1e905971e8053fc809565a8e34618fc48bc22f767566273647396ae69ccf6ef29c78005b9fd99af095b328d4518f4ddac46c1f6ee01b35c976627c1aef7f3e345419f598c8c112d5c47dcf9fc731bd503d265e1117866454e7e46c372965f4e6b0c7684ffb7361cfd39f0f23821eabfc480068e38fd06d48323320b5e4f001485aae9d0c523258d32e25701b263f1620f6d9fb511d2e8129df7e3ca1fd6a1a9f33393bbd13db12e1549094655473eca08e4bff19c7352a91c57941ed94081b3f25511c2a3cd5e79e13cfa070f18e84e119b788d608faffa8ee0ed4499f5813f7d67d7f0651914efad07bed757a34a6f9aa5c1f917fcd40d6a605e1be6507c1e4f4da12176e0f10a92ceaf8165b398156753c9bcb17ae1aea4594e7a83e43fee2819545b7a27b6fe12f625875c06152c69c301f19dc444fd5f542017d949bba26ebe76ec31baec7b1cd0e67570e52e60ba2ad63bb8b0e2b22f8b36f97a6dd27a571a6378309b9bd4b99439da417bd075fd36c68cb9b89d88175457f0e6f00b7acf49f641910dc780e7b8aec8cd31fc9d8439c1d03112e8988d41dac4206b2415e7159efe1528962b72b8c6ba62d79cc405a53a30babc91a12257dbcfcf435b542f527a68883902ce28b385b91696d02cfff97949c34824579e942d34da7e381bba25a399a82717a4549f242c5e0287abfbea491f59fe49b073906cd4497f60eef432edb043d8f62c06c444feaafe4390f78549af504854158e6050c27a0c678e950c407145a2e53d4c0823640242f746163a3c211f97240647b046881fac6b49e0e7c640abe9dbf96ca040e0d938a319f9f1adc423d001353002200a3695cb7e0377459552bcfb12ceec307559e76582e180717e9a349a23c74ff550ea99d72097e104814612661444e6af1cebe7df30946a6d45fc700c9e1b616a7bf9570f18989209fc166bc210920274bddb117a01580a9677d2c1e096b2389cdb617ec56fecf7b6b431d2b3f72af81159dac614a9adb2633d7a3e3c1087493d796cfcaf487f0505de1e7e28a4e5d4c8b10b9356644f2919d9c20f6a58bfbf051b41997a6d0a6aa7e57ce8e6f6497b151087c9b9ab7cd97092ace46dc6489554a2d942ef27b8e7643d3d8fe6afd50a349ff5beb10e3826e956e7cf974d1b4cca236158cbdf927406af2088c5472d2040b5882ca23ede01ca85d6120ae8833885275b443b06f6b3bcacbe48703d47797039386e0fe5f7743869c8e28acd6b67f00067eae79f1972fedb8a758c889d490669deda6ff05caf8b1207624e497cab9fb25ecb3890571aab1d00e494d8ef9428ee6c0a8dafc7f63a75578613ab6aae82aab4afd56caae9da14369200b29e2a24e66cb34b224d184a5497e167e93f00dfde6f3693f06ade1b9df2c7fc4906629cb0ee0fdca2605f868cc805878eb80c55eee0538d7ea6de2b9bea01d5138b2f293edd1c72d6e53ae41f4fea4f488fb57f0b13ad19e2beb14b8976ca3721196a3d6b4b5927f4250c656048bf0d296081c5753d416877f65900c149a9432c8cc3c0cceeed129f31fd6fff3945dc8c24d4fd454933c9040cd122e61a16173c53819879df882d27f7bea007a13f2e4d6b794caf95537025ee659a6e23b12a65255bc67f246fe4609fa628f48c39531eca938ea3cbaa18467670ea03d5e35625437621560716b92b63692186a14836ec4669b43e5e902b76adb4ff3ef1ea117dd822f1ef7f9f53e43e649521c9f25b5bd357bba8946affd87ff797163343509b18f3f8be6e4a4ae2112ff23c9332a979863904eb42d1ddd7908c77cef161fa7fe27a3eb8a77e7c9942d3b469c28ba8b83634204415af4ed2e39d1d14f63fcc1371e080f4e87e0600f3c11aa0953d3299fec6f4ff21d4ee80d6ae2fb6a32094164bfd1353f94a87e84a670a7d2373e79a0701e79adb52eecb1111cfa903a10ba909b344b541ecbeef3c5eb0f247b8d4eeee06a428347c224845360578ad8e2cdf837e7de99def911f096a2794e17f52649d69ee8931c8553a0ef832dd44335a736380ce8c9290c1767a99568d2b22b4074444d8fc9386723167002901a4e6e0b32546705698339bb2fead5c7afe15b2afb6294fae0857cb48df40d083a8a17d8c61f5ce69918ddc5a078465b52ad8cefcd79db3c1bf1761d6f478c3b42e47de65eadc11dae9b6079466b1fba01eed2422f2f7327d65f3576d42efd7575b44ce2f522a3eef02e573b94e8c03a2942e5aef59946628670ec8acdbfd658bdb0e41dc07ec75c5f4ef1f37ec16f05279a2830d21a3b623433e98bf1843b29cf09cf6f715a13b1b4b5cc3357690525bff60686011e7992499c2c9fd1aff0d82c73d7d4830a3ceecf0bd6689be014e7d853e3f8385b5eec2cf2f7be6a899b51f53fe55e6305822fdcb5c60252279ac39a2244c93efc9e629f44688477a8512178cf77cf8725d1eec756666929bb9e1b9d85b3fa795e94788949bac4c7fe39e1443da5676fb9716924b834e026b1d62776c5bf16b8d65f9301b2cd7435a30ea0f3c6e2ef87abf9876a027b55f85afdd5c6b078fa411233b979fb841d9b28a9c6b5b97909f2b2ebb5c70d39f08a5b1b0c21eb342985ab7662fa9ad83fd08ba1a78b770d07a8c320c3983f4cd4828bb06f2506d8bd1c1d9559d306d8ebce3455be0a6a1310e5b2f6cd776a3e40b55543c6f78a0c78ee549e949c3f85bd8aad5bd84d4af26e57731d4db059d5d18497153a4322e08bf67ca0bda11c99d9056f94ec26cd7a24b52fe22a3b480a79bd448e8c281d1bfe15aabdb6b2da91971f3d0763e1ca446d87e9591d45d4d62f242250781f3285736b1c8e458ec03b3e79830c88c1404fe124d999359a0968bd357a9d666c94f206b8fa6b13b9bdc964f72b967d6d3126694f5247c5bb04bcaf62cc112f1220afdaf8a3b4e63b2216b9ed71e10645211c0b84c80570dbf39ec4283d5a675f601724203918b38c7595ac18127e6f22da875d444e45eeed4ffd309665ff7b92b11e1d20be78dbbde3b5610d0e4014f81303e30b749dbcc37ced948315d6b54d8fbf8f530f6d6ab4ccf7df1df232491cca6e4e9842fd99117a0a34c0d8fad2cf2d3db4dcead4391560aaf8f7146aaa77a6ada9dd27dfc1b80299f3006c1bf1dee34f0912cc69135b25f4ed3ddb32b4ff12d8f8ecd43ae0c3253a591a9121e59139f208477aca4a9a94af572eda057cc3725e0e31b6ab9a626116babc42bbae146c09f28906de4bb2b5c2dcc8ed60dfaa5f60aaae480229c173969aed59f77c383f91aec1ae0523866f5e3d95d9ac052af42c7907762c038b6c874a9de12e0d95d259499e033edfb490b97bec95d7d0cd73eaf9f5ea49f02cf4bea6d74a53ceb5a24e3aa9c2d5eda2109864fe41ecc03421c3b5dd7362f7d99c4e65164d44ffa872780ac4b900323090a491969bca81ac76409802bdd43b5c0ffe9fb0c40f926805136331b14970e767a3afa458504575a794a72131d49666c24fa3a303b8bfd3e1d8f768bf160cacb37fca623a4e81b06b6d265d27053c4ed9c548f502042f9168cb99eacb3b7b150481f2bfe02e7d9b5649d982002de59dbb4c2440802a4beb7e40e3c57d55be89ead94cec82793b58d6b792e25573312b7c3f5404907accda3cfd4a7e5a93f886b54c04fc19927be27cd50ba85ecd6a9e4e12fcb14dc112f1a5dc93a3df957dafb36b673cbf4271c3946839f335f7565a0bada870e2b8ec671208997849773e4f56b1ebbd91c15f3ee837c475aaafc6f9bd21ec91cc3e7023a503b8cde6ab5a61c66cced665b767dd0f8c59c9027965b98e3a5d10fce2878fd003f39ae776fdabcf863072adf293d2b91f37620d9e32c3aace668fedcff2b5d3d836911e6f547fbc5be137ef110a0c55a8fa2848454383cd680e08535c4e5070b02e058617a3e34cae60a266ba3bef0ed9b4415d12ae6730cf3c2a06cff3377b391cde3957d38be556155340ecd4d2def5d45d2c491e0c3fcf1baa5095566059281ad410c4840020579934d006a466e0f7e61925b2346430bbdf2d9ad6a452246f1d6b61d1af568969f9e6e2379e3ed2128a522b970186360bf21f3860e5aa5b8796ba08b7a8739276ba8ebd58b3e6ff7d26659fae286ce5e5eba4adffed01ddf93f5541536b7789e054c9774e5aa15c4453c0e9ea6b89704fa1f9e874d9cde324f4832d3d4be268bee410b98169a276f1018e2532d34569bc861a46928019ed7c3e177641a0321d769b1e98a7e5e572d08e0193ac325b6cbe149a2439be37cc472e70d18b553f73f70cd4d608a3fbd7b85c271e808b24bc59f5e9027abda8e1395e78c1f8494cd0bc0710c6303a8347bbdfdbca6c6f66cecd892eceb307112e335af4084f896dcd019b1b45714005096cead29d117b437ffb763a6b270775df31a891133e8dfe72a49bba9ba14a13564da1344ccccde6a469bdf8f0051cf1860189d2a860e2bbade64bce54cb6003eb817ae634fad4bd75bf4cef5f79f11df4cc858ca711166cc14e5a0ff12d8f5c0919ce3f7568cafa2743a0ebd0559aee2add5beaf31e85d17651de71507623b73e37add814391ac8c8f5b35a9fb6a97cc9e806a31eb4b82bd55ef9d1e2ca7539e406f425e7f58246a47687e9c635b04c78ec31132a62c73785bb6fc22df95cdd696a7dc295bfa359e7a1b42a20ba69b12dc65a90596cd1192a2a5f69af70bf0ca454901d589fd608feed2654620439b1b9977691d1965a31ecbf3ce399c55893a682eff41882af34d495193cac48df4ecea9f6e49f835ba44c2205ea299f136a0f56aadcd5f40ab08c2e2fe80eed0040d7f46e242340c477db6133d8f51de458270c1f6536e2e7b8a197a7a365d0d642f038b23eca106c9840cf0c84a2cc2c17268697f8ef9dc5dbee06e7ffca9a4342f199bc6be8b4cf72c160fb7fb751a16a80637bd9ffeb14b8679bee319e82e30ab22b0d219eb4f9b88596495ae9314126ccd8939277cf994fc1097c39328debbf8d9f7684ed796f3dc2cf2a7168bc3cb1737b7cad6b7f30b1efb6e64e70ad78a39587426760b44d2f46bca581f8329a32a2d17067d7b2848ca6665b55197e206616a2b6c464b6e8a6324494d57a9f445baf16309cc69bc2f9006c4eff07d85725b495a1ebfef5ac7fada3573de0d18c2b13f78b440ed68db2575d72f0e2d0df138d328c14acec48eae318034a748c41943044400994285efbd349476e8d77a0b6652e29b52dc4fc9a622f9175aba285f3e0790207bddc2273ac778f1f08ada9380a3c22dd916cc111b743af7594eaa327e35d55e1993e286cb3ee6a12fb5a52a58642385dcbc42c7e0bd637293414df27ca75e763d3fe9ef0f8b417af7a25634749dbbefd516ea2276b6d8d467cd2632524e74adf4010821a65b753da0cc217307085875fb5ff8abda357ab9548f9cfbefb2e67c6d5cbe86002bbb2d361809c231b9b0410a70a0bc34bdc7ccf0ecb66855a06271f1138d6a6e1cc861244a5cc79e4e547435b1daefa6f6115785056895528ce22c77fa30dc48a72a3ad4551234c38ce16bf00b1f2f622b722151297f3cad00846d9457fd2300c254e3cddb74abfa59f6d62314f7b2fa876c4e202efeab994861b36376ad085a7735b947a8c4e85d02a79cd84f379e32aceb1ee7f9357e99021ec26dee97280cb9994d7fa2d1aa949ec4fad2b19ca510758c6d58b62fb756c92811ad8eb2aa1394fe6b843aa2988ec6f3228b2e24d9f9ef299434ced47fe9635be7a78119a106f1f2a06324b459f3ec60dfeb21e0eed01a8c82ecb5a53a49e27bd992f767344735d80b7ce5efe1d2012a6e69849d7d1f836bb9033678d646d63e57ad2f95ef0613e26c8d92e36b5f4f1b566fdf7309ab392651a878f4a4c0eda935d6ceee7c3d4fd6579e4e4c60fa132e283941a24943895c1f63fd32a96afb66b50ecc9cfd1c2d615241847283ed26f69ab62a33a51f25a0967a450328d956d316327470cae863c4fc57c35ea2b15dd045025c8546616f05eee2684d99d2dc73097049b039974fab1ac919ef6efb1338c95396e81b6b89c156632daf76feaa97fff5e3c38b65b85d585a71a260684e4a4ac83a52aa9ffbc36d3cb99c037fe2604035313121846b468f3534910d1d384f817648faa3f1d03ba61790b41f93d528a2a00cd795c6b51b07b89b56cfea43e6b1f86dfbc6b3c1aa6d6adc9ca85822505eab05ae8dfe9487dea94fa5db8bbaf4bb7248d119bd4ca849c305ce393fe4ac8febd37b78fa758926b82ab6fea7568ed2ea27e33683354215fe99d8736e06c56617aa0aeae2aa6c7e19268b1f53ba42dcb66497638a67c42aa58f498cf2aebb9a899bc8805928d5b457512cad83387a84f1dd3fb875c08f67b49d8f4267534643712e2518d4ca268c8e4e2eb1b8aa03473f4225b9426f72f38687bfae882214387d03aa251c79179729a09f666fb2c8604461d6d17e9f7f2b1a5cd01848504291c09928badc5c0ae7864e2d136b79ac037ce27565683b1efb711e08da18be33cd2c3040a78a6ca36561ba36c68c3778876b04422fbdebe616c391ae321f9026861f41e11ae517992a3d9323b23db7e2098bb0910aef6f272d22023ae344f91400dc4b00091e24466c690f46ec734e37a0cf965e5adf9dec94fb6575379bd10bfe2bf334124622a286f4ca523b6ce2b8e83a43df2d5d34f97ceedcbac99336e8a929133851e1730579e4d2b6fcab221585a724f6e716e7cf59ddde8578f8968e6ba60abdc757b8a7ab11c5c89f79b970b67e0b91b8d2581a7329d9716b7b7c881338a948d66d1a56bdc9c049e729f82811322291197f95c94c7b8a1394d63ed58cd82d2ccc5792b5433e2e3688c79910b32d087e018602abf50491d830d4da6ba13b61c5a4eb7e1daaaaeac0130312a862d90ec200fcea6565f8c229a379e3f7d8a466ea46c94e67ce112ccd92ad2956bbaf995bc8b2f18ac93f00a7aa06e630fc6087712a7a2d6e1c36d858563bfd459754a452b22bfb17878b44e8baeefedb665e7ccd37000f6d87ca4dcd14e80ca0032d7231a36f603bf237377c4520448b466571621acb06e5a2ebfb0d64817aff34d7b56ee338dcc569752d19ab75728815eb333c6bade18fc84d29c9df2de70622f5028041ca60e2e72681bdc20132994be97662693f991463801c545766696cd8c53ea6fc9cc47ace2480bb1fa379a587f1f2996d85d6d720c97973a6140f016b0acda089396fe34dc86a8f09ce3fb37806804da05daf0142ba3eb2b7fa989c6fa1418f4997c22f8a38ea3aaa4c24b755d8279eae9799870fa693df63f20f38027fd9051ab90e121744313025326ac4a8528ce18ef9b6bc27b642f94df48b94db6f593a0e309cdc62d3637f11349ca1b708f20d8bc9c6c0437f7d0bf361e87762e92a6256758b8d6a484be576478598a97364416d6d74e7a606324ec15ad848e1be8010ba0f4757e49d5eb7448feb38ffd027babf567b6b0f98c0060965a3968cfee0cad6148ae8b806149c22ae4b5e43f0c0452633865b1ce3c784f4daf3665ba41d4abd4de4206920ed4a0e136a72a0a04bf008c499266281d0098404ffac91cc9f7f6a4e9a700835f546d136890ffa6420cb7f34ad172538a9200171a8148274ffe9b50f13990ea15dd83f2c8104a4a8f3d59fec9e68eeb3243e4f44bd883f953de0a363253a766f8fa1529ac27096f0abc646d74bdcea40c5f701aa7686bdf02cabae92ee32a7e23074822e6ed3c3859dcdc160507445e0ec9386657084e09397f3fca2efd7e448a9eba386df74a8b916599ad8ccb17b60fe0b4418bdb4be9b8baf225bb36623e986d3f5d0885d48e011201f0659b4c1221cc722abd33d3acebed69ebbac84551676093c8b1d5b7db541a13a4cb1dd5aac49aea522b4e60dbb5009b44c88291cf938928fcdfa5d03da12ce6724cad1b3819160946a9df76cc4e88c43f1966d7cb4f1cfb98aba6be5d03d342b14d5ceeec69d3f707e921a6df5c24a570a13fad3387d9f96370c8398073cbd661039ca9a5f5d3d7e02f6413f92b71736200eec8144d876d45d15f694c01916af3c5fe21824655cd5ac2cef922ba0d6c5dd7ca4664a0105622e50a4129a8820743000b6abdeb1ebd3748dc862d62a708ffee16e53a5127f868bc6c939f0ca469820a97eed5909729063850e5c56e0e3fc6e3e03093b120e9b0c70ff8346df86b606b659eda408b2427a981e7bc07c87b09428b3a2c95e3b9bfe7ca6d06d1ee762f3434d102466b2912ed3f6f48f282988c76d0b3dcfd5a395d3f2fa748e688e2f28454e67ee5e431ca684e213b52f165b87c76d4694494c4b7c15405e880de7b6a4c50a5ce30da808ce3b43c63db962e81872315f22bed6d2587467d436d79aa2191259c22d4c3f47c5cb35f483f4f9dd91d7b75dac186bac7f10658ae7fe78a162cb56ded0b58b519139d45d4ec1bd67ba5b0bc319b1390dc4416cb094e6e13ae38a36a1ef69c478634e4b1087f0083e02b1a358a52fedd053d39819ba9c0266b3150a83a9a9064d7e38b80d1cf258011310c21e4a044ac4a89e161e01261216f5ffcf9bc8b53ba6e4a02df48d7fa94516dae0915756ed3ef62ad301dbc10478d42c150fd5e08eb2fb82a1764832774d5f25d5513a6cd7c5d912a7754f0089141d04b0f346e17c84dc4440b2355a7b39823a43aa7ea8e16fde5648cff227abd192254ef6eacb4dd0cd63f9f4901d80ab6b19c2113d96aa335df1229891f8463da491e5b062e63a529d99b323f95c17592d93c3e9604abf9601cb754bd1f6b6b645eaffbd1a4faa92d4f1fd091600612e52529f759421017a107e2b12616495835317e1f27a4032da390891fa3139a657efb5e6100c914ccd9b40bee080f8ebd171c658b1f15296c929c3402d787966aa5189b379f68bbba295df2bf864cf48cf8ef1430b9cbb1cb715cfa1b4feadd8d3da84f7012a5637def1edfdde57a0d4d317f4c205e049f4144a12f23c7699076157ded98491436cea5ed053152f77eaa0d1c0a365ca823a999455fbd51dac28248e848c3f581a477b28d05e75ead7bdcb82c00f87f956ecd55176e0a57e0d2dd240476cbbdcfb6e7839c0fc0938a5394a98e61e743d52009d88631af1f9fdd6dc2669ed91a52b4ec47d98bee6723ef3b4c491af17d2986116e3405982913d678c9fc20d6b7122ce115169aabdbf02e1ab6af38110d8b51fc85a3bdf16e7494416e62a35cf12d26fbf4839811f8d222edbe90391e28494fe1c6563de40e7648d5894072e9a9152906ef84bbac8285d192d41b58f1b1c2359095f7d445de5d2de7d6ac1e932853b5a48c3fd8a0b7832b3bef3b422276f8a2d023128c131b62be50be85b7c5739392e4e7df4b1d1f96eae3977fdbd0c7c4ad8d58ee298f7ffbc3f40e3aa60f72e4db48fc9f2db827bf8d245e96a62fd7d640c0812c80a734c47251010f5155e61c01681821da7f44f472ba1b69bef0364276237f5f2833ce87182a8c0109ca294013ffc658336efaa285be47bcd172912602d2759a32e7d323f9baad0709b6ec3d8e1e7e1dd1463419042f372d51335a4dfa8ac7aaabc4f2bca55b2311381e1ac0bd49f91cdb0f2fd2fb47949298f2e31bd0771e1cdbb99231b4d7e33f7f5a0a19846a088c5acc12bbf9c0aff8b9851bce57adbad75a54721bc27bb873bf02c02e6faf69e8839eda58c3dcd472c1e24e1981a1350147db4368436d404fd1d2a09677ce55d9de7239540ff8728cd010d67ac4ed5f3728889b875c174378ae2174a1c7a7f7f5132fd890c264e0086d5beb3611222704233917583f350ec9745b3c2927f2ae20b32d7f78fa1727f249e78c82e39f219b2bf8cc18402e0106a103ad32ff693ef5bf5a2994a057611b69794b649520cabe31446aebe5354defc533cf94eacbc94030da803b6375c3a4c06dfcdd88e7e7df710ff2ea2bcd20a5987b6cab0ffba48f5b02a85ee4535fb10e2591f0cda2e609512b156dd9410f47f752b2cad6aea77dfb0468c14452beae271ed2cf85103fa6b685efc1e9c1e5aeb2ed93882bc5f270c3526bb45e467d9c9e1e5f40d858d19bec90450d32b1642ec29f73a26b38f8713acb107bab2cadb3fb297ee35ae9780b01708d69c9563264581bb5ccadefe599874abe647beb4a4f0bc2bae9942dd8b9d8feaa889ec8c1da8106dccac94b028ba17fc3cd58136be0763596fb1d50ecf1ab368a7105e201071f5e830e4ecdfefa42741605cde40c7645609155622f34a94c159937f635d1748a6e7a4124db8f0cefc4be6efd86d80084520436db2c773e11130546bacc6773ea825c5bafae60c4edc4ac5da4be602a0e907dee5b1d6609dbc455b49c619ef3de95f5b044108228da87b4e6aa37f7119cd8aceacd7e4dbcdd5ce0ed405b41ceeb69424c0e4f8a04846d1038a2321fcc80b263f17dd81376904436973c802db38e72bd55e57a1df4a85dd67d21ee7c01f23195b68fd5a68059318727411051076f04c02c4137f436675e75a2473b9165940eef3510f212597908754e53db32a5db4f69c693dbe060aa807f3e87e6021309cf16c44dcbb78dbe43b580b0fea5de2320ef88ccc8b7767bcc63f5fd96912299abd8afbd84c106eb43889a9e24daabe0399846e8b8dce9f6cb75aa690a775e07ced056b8f446d9fef2f476ea1fd56d454d4cddaf20c4084a6a6c14b60eea972832fe014634f93dad662f15843e7cfcd0bd18257ebf83cce7ec474bc8e186c04b091073b3ce32683b1148f7307a7d033914f4c7c64679540c115e7dcdbb10e0e39bdd90a5be5558bb3b2fc3731488f816868dd6123d8993977f9b051e289ea28f9a1583670c29d4e01d549e5714f5bfbc1e22f9f9d67609d9f7705a07fedc78fc8aa3dffe452f6281b2830fbb68bd0b028dd37797a3e3c1ddacbf034fab734ee2ce747b886da07da96732a3bb7cc1f16fd5f54fa393b0b64a6fd9b5e157327738043940f1f2ccc51bc18d149aca0ce5c67abb425bc8d8dd78a4390dbb33c0d15cfe150f76cd1804c231ac53bc1bafd666ba5fe588a3f19cd4259196de3a6949f5ea37849cc4a8d54bbd55c7b8180c2ac07d9f1a0acfcde399fd47795b4e50e021c5cab9d2256f990f374b3943d3b6686ba0d3a5cecb314e497be9000606a3ddd89e68a2fba4893979403ddbe1a75ce6d404919d7f85ad7f32a7fee2bba884d7a992c447cb146766c2679488a000782937c75c13a24ce4e4a346e8fbd412b1f53a9f97427973fdc6a44e67923e2ed5d589f3404deaa59e31a2cfda2cc0d8a6a378a170b76de48ae8ee2f5b01488085982b826665ac6688bd9639255063d078b4a1ff256e843bb4cf19f303c82588d1014f28dc024ab5bcc642a46aa177fd99d8a13eff278521ae0c0bb7b7eb71c5907dbb23eaa71ddcb01a0b4ac00e1a3c177e883b11cb0f07244bc5aab81f255bee1b8521600127bc88cbc3ff83a3caca02eedbacd3164ba4d8530088dd520e78ae53e18f0760320b25dce25df35dbbc31ae442faeaf3d1dfb95abc738a7c37edee81aba99cb112e3aa3c706e62e404bad420a292f42004eb92e652e3c912d9625c5c581806f5f3dbe8fb3efddc60acedcc76f4aed0f520b92f05c51acb9fc83221e7dd360c39645b1d82b9740bbbb9ef4f311d61c0b7fd700be883f9c7dfb6ef448a78cc53ae3c5dee878388974d5682e6f66fdf314ce0177321ea68bc940192fb9ed942fd072c692f3dc2d3b662e3ad2a80a3595fda5107cc4bed8a7ab705009ba0cf0552798289903ee073a4f5a16192c49cfc21c1a92bf225d6436913745c00d67871be23fe42153e268ec8a27e47bbaeb6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
