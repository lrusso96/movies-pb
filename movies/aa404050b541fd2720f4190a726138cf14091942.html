<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6f789e1a46e2e0a46724c69ffd2831151c09fee2da8124455c37b571edf1c3af59671627e6b8fd1a35fe517c98f4606e096a9ea5494e1c04242c7b9c110a8a174e95c3f410a6e587bd201a77428531483bb416cf158cd0c4763217a949dd1cca1ad37f9daaa13accf3fd94d27621a87ba116691a02140979221e0f7c003774279c9f448629ea04c79e6849d61eeb7ebf814ad2a59902663231e826aa2ce990e2761bba77c2af1d55559e5e09c9b93e9b75e7c4b2bca1688db54552f9e8ab516e572be27609e834b1ce1296cd722553db6609319cafc693ca39605b85992be20ba38bdd2b53e26d7cf9c521253ce6eb95452366bc8ecb2319f7c7c7a18ca3b78159b54e156b095bb93e27ee39940c85411a57d8b19aca3d36477d31f3449f63d32ece88306432db20fe7143ba0093723b0401619e3e7bce4f1dca41599d3b3560c2f514e1855dd1a74ea4323159afc40b2c4aa5d56c2a2caaaa42f4e76a6f15c77d54820c61a0cd7a4c9ecdab1f4b0ce0f48b3fcefa3a8ac69faeaed461250134c392796ea7e63947c8686ce801f7cc89bc5d7fc5eb5e540756a7e531ecec725a875fbc1b248f8b2bf863dcafe9c2c6e157443fe84209511b99945070b02cf6c74767a36875e9e60cb1a21a4ac3dd5e859c6e4a5ae7a91618955c6031ea5cd93bdcac4b01b9ef476168bf6df2ba0c0327529553862ffb0c1eabf9538b082aa38ad2da3b9bcadc942ab4b1ba29b59d173ef6aea3f917c51e8421a9fed60dfe38de8edfc996f7b1d58e821ff8678374e724614367540834c4ecda60304a1c7080f66309d5e776d3d1e8022c0875da6d4db53f77fb9e20468b47971d25fa635cd902908c1bb87db1dead36795c89afe408ab9bcadf239895d792e22eb8d784ee2297ef4b618f1b5004920987a88f0be37179e0e9f359eda481e2ece11eb0da0cf34b1742a1f3601fb73928ba4543456ef04839f22b07dbb0b4ddf1ffeaad0e32d5109e3fff003d23d4e10f8ef9e6c0f444e8d8d02ca638a911c1f55415ba3e806a536e3a80d53ef9e0d015629a45122b7e8755b73806f1e0a67e865d44db28f347b939d83ce5b2c900bf942bb4e5d7c229639cfd6ed4afa6a5fd4352ee4b49c32dd75dd97329b112ff42005437c8bcaea9d5c761e45ccbd1c7038e86c3acc0932a90a2de82e74714c95b236379a483f668d9d1a630b45aee8a771951ac06bc309b9db955b39fac571578acfc3e13a09042e4b5b57d280e7253fb805c47a2b2d54def053a8a88fbd1906c806d32d60dd758d21b42083405f37b667de895c56d6674324c251731b495f069604db76bdb991f9808889c66d1270e7fb30166872af07d10d5c5ba1c533aa50f1f4c4bab371bb672483b958114e9b4c349bca0019c253cdefce53f2c65651690e2c4735d4f64050a8fd0ebe8d07a5734f0ddbd408854169cbd18e48d4ee1891e78d04b5f44fd55f7b89f4a72e73883538ed2f5e7444600272120d7db4f19f20f2536d1b867fa01f1a8170bdea13d5b94d71cc02013f6f0815b3c93840b6ba87e9fd3017505fb4859cb42dfcc18d15967af4d14a0fe7a1ac5309a1f4324219d2a5e4299b0a8c428614ab42d2d1b7c52dfc2af8f9a7e73c225c35cb3cfc5c009d4bf7308e540732942a947bb7fb0cc3728e918656de07ed67dbf6f2bf7363b772dd94a84a9f7bfb99a0c527fa87eb84b2e8f103259b6d0940c75c2e4323a0319b51198bafba069be56c4084937d778c4d231829289dd91e55bb230d72676fbb6a6906cc76cbab9d2ebe341426f7542dbcb6ea7b9697186ddb1d2be2d33cddedff57164eab8b777c6c9e030808b76ac1117d766f7919f87a51eb55371ac77f77e355f24ba2c72f044d32fd236ecd94a998888e858ecbc7438168296652b50e6345094e5d73498631d92ad8bdca49d42ac05ea70089a27029348d0b1cb81c856c9141b332ae5dce99bb67041e5e9bb168f09d75aa8e6656c5860fa3ce0ef69fb845d3a6250043d48e540a7b7f69a6aee6c1cbe527769c180d13bdb80151e43322145c68665ef4379f1a95b191bdc7821ae392b52e2091046f38767a06276383d15bc7d951d50e226abf9bb97cb9151481f5b642e93cf7fd97df899265222e5110cd1971e9ccc65ce7fe800200d5749d9649b9a9c8972bfd3caa02cc4358e982aa470a1d122f3740982ed6cf9f82ef14309b5c7410b0ad44929381a8b271fd3705c1791ebc08c4df61c3cd7f3edc03df24e5bd5185142c3a8fd8f29a15918dbf374a898f740bfe015ac6aa8577918d2e16a10be82113b3c618eb945b14bd59cd9bbafa24735728fd6d5ee986985b5dfb8800fae287c5a707fce764ee8f01c30182c7ee1e423bd920d6aa078f89c950245aa7d7833bac1768ff91b8613ba2d2de7255c3213e2bba3899ed73d0b0aea4d1956cf337b6d10aa0d2c5898d90fb871be7cf650936abe60ac7862b93d0a9570f750542706fe49af530b0439c0651b5c5bcee6479922b188d86cd5441863de356cd88fdc00e88c968ad56b5803f99696d66779f4292babc64bccd0154664d4feb6a3c6c5d429e05e6a16962ef9817d8b4ff66a67d1401465b28d5f5eb4c9b6e921d8164bb76164892dbf9837bd0982625daa8608b5bdd19a6a5c704f1f4f3c345daa6508979961a8e66fb89a87b7437e1b97a41cd287708316e3209eb8764ada2272b1065a3ac09cec001dd5788fa728403ce096a4e0ec154948bc7261b70ad11f33bcee3123b0801c1612e42013c5e8e4d6df308fd58a4a44de1c17fb180d8d082821e1e53da15467001c8bd71e4c6e4857e9abefee20fdb66bbbc048542bebb9c75da0653980a5bf17ebcdc4c6ea487cd119311d33348854e56e092410f67892928e5ca560fb84fbeaf0ef108756df3fa005bb863d70cf4fa074000b411d7fdd95cef63cfe39342931ec19496985cc69508476cbfbfac423c774ec34d06eb28fd0b062ab7a128dbaa8aa64cb918d0686e80bbdc6392cb2f3668a63f97309692062db28e2d6fa3b91577f38dd4cca503e48657dd39eab798f02ee929abc2be7d80204076c2730ec9ceded27fd4591e72ab414104ce5edff77c3de3bae42955170483e20548ea5d89b9029bb9e29a4e391f991ac3fae5e3a1bb0e33945b3eab423242b694519612ca160a11826ffe3fe63dd006111f780db96774c9bd9c7153ea75f0a0c77d401354de109a385ff29d73c6d47ecb05ba2c25e8150e738672f489fdae40920b8cb0c9ae8fd13e88499d054d2808c269b587eb0faf0057f8f1d2a9947d83be1be9c3ab1f7941b77091212abdae5f0dbe9964cd58aed217716b9004cda34bcf27b5c41e3ac1a5d0b47132b098108f7fc8fd1aff44894266846f5c17fbed2f4b9da09b6feb59c0ea5f7ccaf7efb7996b6445ab4c3297f775f1f08ec1d78ff8c6ed03f42c2289730093432022ed2480971753315e8da8e19eb30ff1fedfead0ab69df3742a5dc284fae823f54b609e9ab3f692ca2e68b45c71b2c62f686407662cccdd3bb1da75610c4f055d24119a6d4fea4868075d6e8dfc8972acfc0ecd13a68dd7065d140446941f42163f2f4234b1216700016125b67f25805ae965b2ed6d113dbad2a2ec7e032c630bba1aac3a2135782692d91d5a1253ca067f8608ae7f89364317c6c31b7a1710fc40ffed686b368f4c1d123c095314ae530e4e26907f5cb99070ae7d88936b3b2ec8f2b7056644727a7db9c95a0fe5031d2bd0970a6819ea2e6394f67fc22938c5be1358adeeba90139b242ade9b3863ad19b0e29ad42c9be06f917c8baadbb0192344d42af30f162e7162161f52445e4a8d9862627cafc11d46e2a03c3f36ac731b8af1b6bdd988edb967727cf10ae37c25160526b079eb7ce2b86efb67679cdae1e1384b3e66da956b2b18d5b5604e0f15a69eae4398bd364082b14d61047682d1a1347e9bb817f15dbc1ef2ea851768b4574229b52f1084622797f4bfe8ff79842b01ff3aba846f24509545a1e42b4599507003a80a3e4bfe0f5d588048dac43cc52ed469ff0bf6513bece3e39b5a4517f5befab44e105a52ea76e1c4eddf9ab72f62467e9006e8349394082ee6feb140c062be8478f738660db66cae0ea0534e1ec8ef802e707d42adc46be7299cf1c629d7ae8865c56d82b79b7ce7976edf8c28d914a193a9b8adf6c7171180561bacc2a92135ca2aed9f15c2fa32eecf794fb6e0e0436c7357dddeec79a045f572f8ff494f9c8f8a89e3a08d3e6aa6da507510aa1034b2bee741522fc2fb07a3bc1cb51ba9b61b0df539526f95e479ed9e998b1ed7aca4e49f27018ab62dfa274e806e6dd06ee271cc4c777b9df5f7de0079091cc914c09e1278a1a4f3f2d20c33fead6074f1bf1275ba2ffc13b20f0b603644f81627f1e9d0e1de7dac1c83cf1ef9c926474c7cb75534548c93b65c5dc8b8756d59c4962dce64a95c8825be310ac2404f058d6facf4aae2a814a43c854d8bfbb6a48aa815a2bb761ff6477aa982085ef07b4099a26164266ee5258c23209ef58aae23c29f77264d39b464ee9481509cb92c1300a9f1ec115360ad8968e8762b81ed8866cc5c3adad3f587f1667f7391acf0e93581c7243a55138af3ee94ea81176c20e9e9f8b70c7e0ee8d5da05b5157f16b125807ff08354f3159bab63e7120e15664cf5ade1a25092ab37aa575673bc7c7e0a5a7bad564dfd3161e1989d6c9eea31dfa5e8c2aaa18645deae6781e7b545295c1f36709808461825c5938453b9813cb700ef18b32bf21947370f5a11549058c7abc8f08b7eb78a46752895784e7bb1144003ff32f509a9ffe51b3bbf190b5e09368bfa49083f52478cd15218fd437f491477f3a53fceb8aa132df0a565963b0914486cda009f1d4ffc94ac9e5ccf29e5015703720760e91df8c00fa5a5d52ca44175c7b0284703891ef8a12e3844fd64c96acea5a515643aca5449db8b93b0332391b3b68bad7ee76e05e7b85d86fbbf83f350554f30add68f2e71c7846086d790d718cbf7be5312cf0a2708cd6542ae650a72be0cbce1562dcbb0f9256625bb1858779c46077108e3296a30220120c6bdfd33b8a248285596dc9f8be78786076a96a2dca73a448c2cd2d6554871c933936840c2268cf7370a57783ae4ed250119b5dd358bd62e5f0a9a4bb7093c4d6dc9b8437a073a3c52f57e448cf7805e22c025787a60812fea5b800588196e6ee72af648fb259a3cbd381ed5efb2128816763f4fbab980e2f7dfcb458df4c0982715b2d836fe53ef5ded565701238a63ee9fdbccbb9e07d90d06bf4485482e004f368775e26e1eed97352ab2968adf10899d59941d7dfbdd3c2ef2a1d67200673f5d1b648ed8114f71798c0d85394e988a5b11f50811273b670834e5e349c178c4aaedf1483e68da0bed97f0d203a534b4017d3b91339b881ca3c568282a9594776a31d613565181cb0dfd3927068852cc86e114c08cb4fe4298c400b87c2bcb051d68dee1f8a86fa61d9715cae10e50de12cec64b4bb519ca2ef6b5db111795ef3bab3b28198b0059224f6d635b734f12bf8fe15f8c69bc602f9c3e4c6c228b86718be276c863e0598cad15e1aa109f16782bd0d05bfed6dde1d0dce05f7c780f6d68604f1879a40c87a098434972e9a3c4eefd5954ab27d5dcc50d7ca3e46364d4556aee36052858fd92aa4bddfad052344720a657e5dd74672eead4a352e67d9dcf69adfe4d8ee31d317d5b0c15fcbfa9f00a30da856324e52d4473f95b10b615b5df4579841ab19161ad89fbd750f8568d158cfe9303f2d614a2085933e666736a0790c277007bba716792665ab60d7a1843c62f5ef341e409a6209906f6b90c94f4cef5c78adf7120017285613bde8cff0f92912d7a50182e67bc561e498f5553fe8741cd4b635593d6031275419bfc3921b3a7f7268d68db11088dfc6b3cb8e40bdc9c055440e3a6b83ab95769885d9f3268fa54a732f425c1aee3d58d202abb180f4fd490615b7bd976a2bb3c3d686a40361143c3fe03306c27616d7be4311b5a76c3a80437b4efeea085d3bc86bed1f01a55dbed996caf8b43a0eb58b1355ef394cc129636e4d1143d21c640ad0441435c2eac40d9df3a253010a40aa5bc11c0cfbc1e1042ce9228faf3288a714faff3d6831a7e7d9be76822c9b250fbe1b39abfe677d511ff8cb8962cdaf05915018e743c1a24aa6501bb3bcba47ab8c00b45d1292c980e98c17be333628ee3f2223f127990cd56e51b410067569e4540a75d207b299879ceb0736a0c104479b6edfaf43208bd6e9e4081e0afb16fb137753e68f589e35f02be7daa67e9b7559475bae6e3bb4aad18b5ab89fd4453b2ed8947427d0b980904f68b424c3b77cd20d99a91da93167d6be7fd19146a92f64d1c41a2702e0fb3ac3fcbcb91a5c4f33b2f1cd2dc830fe61f32741eb3a72487fcf653a1026c90726d7f3f91a2b57a5f13f7a788fe0f161e6bc7ccb0e4513b36f51dc98e055b29dccff22d7f1e09dba523d00f61422a25046adadb90e03343470cbbbe8e0adf8ba13ef564a134ade3a03b7aed8884724e392f9b3f948670f49140e846815939a2bebab4bc91e28ca0ee8bf454bf32c348dfbef9aa9e84a12d8a5a3a62507a3820138591bc6fad1291e0f68d8e492183998744a3540c4d3b27e134403ba3e7c37c7bbc79e5381e62a8c8323db46a6f066b6a9eac56f0e348a9b55ec858dadfcea95334eaa13069666ea94da67ca7f2dad08e945adc366d54bf40692cda8bfbf6ab883d5904902cbb25941e57aa11abb5a530f05eabba41fcd120348f61d79d0208c98184ab1cdba6bc4d5e8af796e4722c784ac86fe117541e77ca6bdfc74acdc75fda05bdcc64d1844fbb5b89a6373bcbe0c363d2efe7e613637405ee2a0a1bb51f2c8bbf6e1be80a577deda6895b2873bb5f6da706d42e363d29ef7e12f1dd832910011c69234fa2328cd9b197c436207f14402d99c781d0c90c2a0d17a5462c9f019a7f321c530f55e4658f1cb904b168d64275c9261c5b6eaf81549f5d2180862dbdec45253fc0fc9cf2939f798e3a2f03a2e1c7388280beece0bb6e2ed1f0fc2cbcab8c3c5c76a49af3427622e6dad05c87453aabdd226d78cf91b52ecfe3f6a8412adbb59c83bcdfba1b6f37595ce532ecee1baebc578a4256e15b0ff28404811e9bd88b48bea24bbd58edb101f57b01187909c6fff47832c52e2f64304e7189ee5ee477cf23c193eb4ef048d243c332e99a7b5db208fea1be39db3761e1bf6c893147860a1716125c1508b3ee9fa5646992544aa7670f8e97451cfe52c9eb86b0eafe875df25a08b49b77a9c3e3a2c43b0e0fa72313fdb44f0e502d4f96011d8ee7d20598515e24d23c28d5f200cc44fa15599e0d86825d00f14c657577eaee73f1e17f8ab61bcdf3e6b8d0ca5412c61aef4e09f43df8858b993a62046f99212162266aee34a1d8eb36847fa3b26ef449570165510055fa57367077592860431108d3127f4c16ec29140adb63c064738be19586ec26ff7e61a0348347453142820c911dc1851fb089e34472a5d54d6af0a8e9aed8a0e380e112f03b7432b1f174af7abe6822cf2304170507e2de73c5bc667aeb1f2c4bdcc5070d7897fda3a5b5486a32093e6f2dd399eac180414048c3fc14c4bf7b549f99d03581eeb397d026eb48d4000b63d9558887b2583d92aa986f4a6d438f58c22711bbbf813c71f62fd203845c4910a24d67869d827e4accd71a734b78b92aded771bffef9bb21038e32e3aa747c37d6b99d876a09a658e8aa37f12189c2ef15f8b28ca348c5df7355b5b48e5bcfbcef1ee848c1a910c060995d760c9dbb95d84a6d039664ec0e483c66ea8f67bcb8a973d83aa4bfd69a8420a49b6ba4e5bffa24634f01087069ddb2c39a941a10bfff52eaf286039d87fe3fe2060ba37441faeb887b1f79b348c3c95652545d98d17c297e3fcd153015cb0a3d557689508af57ddaf862fa36a2e61659e417968910a73e264fbcd7835e801eb1322d2cd7b95e0219c68ef25bc82f16dfef07ecca24ea537448efcf8149c50348f71bc2cc5d251c51452630ea22eb016f0acd8ff2929d7fca635e90ea3cb25d57afae61751bfd77fb037b7b415bf594e69fc6a08f722fa0adf9ea60e7560ed477b6a422eb3a0a467fbd486f09008bfa583dc855ceae9a48c789cabb959a03df97b34b491a1c4131849871b788cfcd9bd5e0aeba78a76a2730338b80dff38d22eab85b4111ce8619805828dec92330d71ecb1e313fa037a4eb1cda68d485f9446c85e48809e51b9e409f8c9d7dd191c2b88e7196d5c5708e9aa2faaad69640c2652956577271eb87c11113061556392bab0b01172aecdcbd0cd119f85b783748e1456a4f26b5a5ba952517bc2a28336e2b00b0f0013f0c69c00e257b771489f4bef8788076eacb0a809a078b0b232308f4f868fcb6ce4680c1c2d00de2a6573f1e3972c09e06290379619e8997bef72ab42866de132f1cf6fd3a330a9ea6a150db3fc7e694b21bf0ac7493f3c5120a6cbda2044f140322fea8bb9b9a4108b3b09a47107d96734bcfbf44607937298a20a6d3c4053db496c3dfc77f9ca6a6da41309a31ad280c41b724b71a06891e82837a5f5d9f2c057260c12be28b19cf55a01b29c383c8dd5ff1a5872a5539eb9f285e9c859f495f07b662bb886a15a2eac93ad0374bba69811f5b676e581d2d8d4cba8c91be23bafba6c83406982b9c57a1bd260910ad1758fbe853e5d27dbfb72897d7acdeb251fb3c62cf3354f6a0457d8c8cafaf76bd9527981c5e454be140dd5512345b19e53a32ec3b8a84185ec416d83a4f90eace7cc6990d9c4ec97e324b218218b76255be80b5498f5e2365413c983cd89256f09da6b81f238e24da921b8f074151e327a0aa2d657859a10fd924d4a997be6fced93dbf5805e16652dad42b59e0b3ec50a72377d6c8c9a274f3185597d230bc4a2c6d3f799703f33773f54e103e163fba4389bc038ccc7b8e4a9468230bb119e2245279d013327fc0eac806afde6daf7d933d904666d896bbb3924457dadc3b9b510a58972b12ae8c60aa9f5d3c3785a013b95798b5dc340af00710b59b21319e5552fc33093b90599b2e2116b12432cecbadff3eb05e8e1e9571dfaa4c6253622244b91f204196da3c62f84c181deadc26281c5c57d32705c460edad2b0ad140da3b9cf7944656c1bf5fb0b89f8ddba7220b1eb8a869432a7d33865b3ada5e4e651215300670c724e0d8403fbbffbf34bf23d4d1349f95ef6393581b1f64db9c757d4ebffcc2f50d03cf6762d12f2b5adefe1a173317e6e03d40ba3fca47bb1fbb032cb6c0885bb036e4a0b41ac357e578df1cc4eba0b918b0add88c445cee8531c17bd28d851127c25712761439d0a0cffe1671264d93c8032d021181624ee97b9e4e77fbe163a72cb9038a749212c3b58b26bfac748354b25e81ab9e64fd67e15efed29ddf6a792fa9efaea4c5cc6d21acdd7869f53520561997c25e64bfbdfe2d8dbfb5f327ff29cdc6379f7cf83c69ee791442ec654fa2d36111a157cf9e576215a860a735a39921661e5423a7e83d94cbca8fff65cd614bcdfd6fb89587ae4a4ab5857d62e696f91f5880333cf8f8f51f50b6b62cde40154de15c2df3edf3f4f964d456282a42af9113bda4ff6690cd7d97c5ce37e73a378b1fa5e278689fe78b5eb5aa2b51f244a2064017c37c0a8c9875af6772e457081621336858c40b7990f1a43a5a21fd3c717761085ab372679fcaa85f0b6e0d3f8f3d203ce7908a24b36aeabe6c268f253184c2e08ca77fffd74c050bd8cbdf4701c5ea4ed7b6fcfacd520fd854cfa1865504dd3e74c78fb48b690f82592c9342451ec79e7ecadd50fdd114807fbe4d2df5ccd79e7135ee50fbf64fb3a8177da8c1dd434488adc261588a37d485a65f87c154fb9ea31e2c7bff8cd3cc677d4a5e8231786c43edfc66641ed6852dbf0ea610962df14263d9c266274464fc630e4784184ee6d5aa71a5cdee37fd40db950eff9a905f34b62c84f24671a9aac1d0faeb39129d3f84be1970388c74ad25d50da73541ccc8ea2506cf308255a4d913b468c9b992bf91cbf60c30f33a2ab0ec16d161921feefef0a76708d6be6ec19bc465bbb62f7c7c2df440884c84434140652c9b40d748ef6a448c42f3c54da655764e3eb2b2f967cfabe7225ef91d47685124b4f6a37fcbe67f33e608f69eb0d29d7a9f9d342ecbf39deb219aa124e09d578c7d2aa169351516214f16b76638b0bfb5dac10085912a969e7e2b6686f75b70dd8d79c2f1213148ac8a075e21808b7e09ca1ac35a83c8deba5b2fdbbb994b0ea098a01fedd4efba420897a97ce1139f3fb28b1b74041760bc1a4d87b444dbb8bade701622ef513ff4b269fe8be8479a359ab1c5ce3a7c7aa1f2c212b744dd996e6f7e13bde49a68b928c61a7c8bad343558169114fb90df92d1abe9765883874ecf2153c70b389d62de142f9e09b5c908f7a3c626dd3cce49037e4c3b98b10a238deb2cdb57ae60ed00c77a2f5f47f4118df8c7b3df2f33a74b56a03d5e6c27edc9971ce23c6f38519e5a534d96f8d595bfbacd3fbe8f1a65839797ed4e8d5a35eb22b1ca004a1b02129bcf89a75bf6ffbcc6c3ba9bfc3a01ffda5f792ea273c69ba60f69a94747496324a63444aa2218d11f94d43d2af9d73fa6e8865ded1f8f3faafa0d88accc63e58fc9bc93663fe475a1fa6ba89e027328b4133a99413f9f7e503eefea1a7f91cc25cd8f6303a2a0225e73a3b9435e9f7e581eea1e968281b429beea35ebb28e1a4778a6f50f76f8e428ae5e4cc8552d8a90ac60c9af2574970b35093129f848be06c5032ef7f995923ee6c22338a3361a5037eb6e224f991a4f6c913323ff3ccda486c4423ab7716ffd033607cb80bdce75752093f65956ba23a3bb171839652c5c98deb7d2bba5fade78ba15e71140e874dd7a019cb8ec49f7a293d84cb046a2ea52abd16613d687cd2f28a2ba29d30f60a24b92b0df340bdaf6c655297ce0391fe1c2abf4e1d10147826570f0fdd6c59e7734a2a7b4480937bd41498da4bbb9820077a6ac5cc1a65640c53dc12da9dc0f692a284f639ab6ccdd735ecd7d2bd04a8d2458e3f9398e4424ba5e2ac6072c73e874a5b97d8448c2e203ad0bcfd514b1fa7c8e3bfd00671847eb522c74653aca21e31c75d030ce3c3879a11ea578e3d57236047b9ab42a5ef8bd7ab0f6d6b8941063b60f89088f6ffba1a4d78ec3923054fa95cd554878c91678432238d2f78b4552b3e715461b5b04de53a933e3633adf6feb1d84f434639a4966f3fc65026720012f5fa4aec8742f3fb0a1639c1a8d4b0eee369bce0e8f7fe9fcc5414c43809dceaa67f254e22558623fadf21aff63a1cf68808b600a331517520b1a8a624b0a98d3c3f6ce7cddcd288c3d08d4bbf43b6b5e2148f20717c0ae48de071a75aa07f5623ecf67f67f1a8717d7fb3ce16792403901caf02a6e766de4a1fd8f8709b05694f26519d13e3904f86227ac9a196ba9113e84923a4579c6fbe8c0b923295629c5516448c3dc833fbf38317bc108d01fa9649a9c9c371d87b16f587d55a6f4674cb43032a4af52fdff7cf498910237e2ea016554a95180f3db02ca87d2152087c6d8a5964765f8741b232bb051e6836902f6aabf91e59129a53494c1a8aa63d9de8203d184a1e11a769023355f399b6dba473d54df390fffd6d10b4c9f428fe6dce7672c955742c96ad8180a8c1809900493222454eb40ca31dc76da260166fd09f14cba840c6906a19e469ac5daeb1583975784b98adfdc6c8bbdbc6bf2d0b3f5e0cffaf4ff04e4e6db8fd723050198ac0f618ad13da3260d338520d4c52260f2927e379a879cc3cc117356f8489b6f8b3f823b25bb183158eb55f1aeaa15e2c6d868a435e8942eacebb4d972054738c7c7bca98caa5399aec0556e6de21e03c740b14ddc67f570f6b266e1ec2a3b756396e8d265e3b4f77b53fedf69257eb18bfacb473498187a3c02f464ad268d018576e48cd7fc1467c8b900fa521f05a003dd69dcb2dc4bfd3d1175458ade31c09eed39ecd95fe792c5acd8e975d16b502c7c67268d71e5f16f651766a9a581e650590a7c482dc40a5f1ccf0cc27df1809e81e30c07ddd0bd3ac0390bcb2dd3c46dd03dc9f88bc3d49da49ea26a572c1932fb4fef31546ada16f9a9155d0aa2a1d4c9dad8a2d2863bf313c47c7aa6db6372427ca3a19ff8b081608d32e84f38516f3bd78692e424c93e78770e655400103b941f60d68d712044c77616abea0583637691482b1dc4a431e2128fe3ac0ae01cf438f644cf09ba6a63c8e12f69539c912f6dc8f6ff02435b25a64155356068a5ed77e4d3f891f9e6ab7ef29ea8c1df861f780e5eab59884b553ad982a12c96d543d747d27f19937fe2a3ea6660c9ea58a7e046dfa10dbd32b78df4b86f2dc71c85d8274ed55ec02de1d21065643682359b3720c492dca2e3d9e26ad80d06aba6538de6a19c0dbee34faa7e3cedd3e5472fc06bdbe7e44e52fbccdf32a1b162a5d3e6a00e39a226b8047819f490663e2121fac00b24fc09df58ae1bd7182798d5e9eccf97d0dfb407a5b9a7426aaadeda0f44f46219c55204641b3234b3fb369270c36ee3695dc7db3bd5f439d038dd358f434f4cdde6a5c3095ea557a46d356b0fa5c7a6d37e165831709a852ef13e1e4028b92731a473bc04428b9acdefad3157ece10c438f48baf5436a79361941eb5ad8160d44009d8761c93ed0474af0810abce086ca87b9449fb32bcd091a117492babf13c8b25a90a2341ecd207f37d857a22a21d41ffffc94b0a1cdfeba45114e089b07c0db4be09152ad12f8d2c2301c5e4529c7a4647da99f1e12e3ba16fe4f19700aa7e34ee6651bc3ba2b32e460856c45d6abf3528def977a6851","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
