<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"907ea702d0389017c013bcb17c7ec3778baf7976939a46e01679be1dc18d085a971a3c012b77247371115c462c58a4ee0de1643aaba970ab5d792e8213749c8e43872a953217a37164f25bd3e9e0837bf527733787700fe19424b7d92ac41c537427c409eaec692781615e0b2eb053ec853310071ddb1cf7fcb436199e9c9dbd2c78e60bdf2e8dddfab4db9fed3bfc9ed1b004f70cc8d73d373e12950b1914e2e67de05633b009aa60c22a4e52fa31a62527eb4e1c215edf80329cbcca34414f059fa23e7e634e328ff79aca111ae06edebd99e1c9e0b1de869c07c8e01795c0d69e7cae59a6773ebbecfc937dab8f935f3a631b8772dc0847de944ea671546c1fecdcad62bf654572aef86108f5eb951575983b9dec52e0655459aada4cd67f5fcb4052925e4a24568536d39df56ce6537b26ce6ca42fa12100ab7d5ae665ce4e02b6aa63aa526f09d58b9f4a0a6e361b07325b8a36876902c5f4a807efffe53a0a9ea6faa08241e2e23b3c094734d81c58df9e493d9887b092fa7c4c1bbc1363bc36841d922bcea84cd5880048696aa671bf46ff849adf7d67d92b7ec88faccbcf6b6790135d5d38657aef2ef85b6139585924c138e4caaabe0d830b3b3a2c19db3de4cbe8bcb01f3187bddee8ab927d568fac4ceab76fd6d2fc41e9565593708e3d1f0c281cbc5f4179d6cf1c5458f367ab16550f6ade6491939f4171493311a16974ef6521bd52e2e7dd9c2b838fdb76e659bf16d511632e310a2d93276d2597b097e6270ba59fe6927ddd55c9815ebfb89d113eba7449e01e06616254739368666d1d8c4c6a172d7dd27c5812eaf10e924b2cf2ab349ea4dc0c522a4f2d8869de4e98170cb50daedf57839b06722e33f2d29333b124b5f371bdbf4bb606d0c0d34e8dae2d6c1d3f0997c710696c143f1a30ce30bea7201862d7c7f81c61accab6173b931a2c90b769c94efaf7df0cd7bb5bdbf2e45f57bf806a8e17059c5c8ee1d762298ba494ae55aad1053e5de850a875007f4a351d4442db414ec8e07d8930441f81cd8eff4526be75eb31d01217396565ab295b84300212cab58566d3a368f785cd80b157a13490af5fecba1a08084a9ca5088d7833fe9c05261230351e1b421d587bde7995c3ecd79d56865f6c70561cab1ced32103e8650730b38311980553b08d9fa43ccfc401cdfee62836a74c2ca56186a20715a4d5839b7d41c9e13c1b4eb718f8af84a11c0727ca99bd18e461255ea228e3b31bed223c18a27471f941c21f9810e53169d92f105726cbba2ccfedb1021c1fcb36bdb24c5bb317ec364924a8030603acdd9a82207676be5a1b3c253d0c9588e246e5115ccf9a6897b0bcd30a476b310ce979edb60fa35dc40c36fd90294646b420ac52d4d6255fc2b19d18345bd231efb24b96ecaf1d9dd573ce1eda37bc86cfebc2c2fd3f4535ac540ec9dfb4b68e1a783681c9add6eb297da6e2b62feed358d5010be1fbff8dd0fccc481ba33d00363dfffc9a6fd84eafd1c9c6135f49f7983b7fa9702e1ec99f8adc3d6155121bce85037a3dc7eefd7acb7440891b3153ffacf5f571e5767076dc52e115797d32e3c10477abe99cabce47a4df98de381d0b3835ffc128e1c05f5d4327b2d13bf82524a184236811f01216c03c8deccb07fbd9b285b17af759e1801a43173d5b8abd037ac4861753b93476f819bec34c1e9b947b424a9cacb2dc7ae29af938654c91b9249620bc69298df18fd6e68fdc56be89975841f82c720a1351b910453b5cf03d66225c1cf0f66a7127cf363c1a75272240c067b751798dbcb4c75f3e64eca623d43efe6dbf9bb34b9733a97e3789588c0ff45c1ec1355005fa0a12a9c6aeb71afb015e63f700815956ad0657a4ca86d7771407b2928cc42c0cd17ca5d7a63440346ce8567d485c227c130d1676b973bfad290dd3f8dba072ea9a7425aba4fbbda28f03b6c7a4fdf4423e89aee4eb33920fab40a05ae781784a96a9b9b7c7c8efa1df84fe195b24600e6b0ac29cdb5d693c617450e021a524a22a1e54cf72f68d227d46cf0f0a8f09db5736d9a84f41e208f979d910764c8f70a7c315d7b9ca608de1535f45494e82219fa7d9c0805e926adccf100f8bd92d2ce625940d168dd7a1b8b7d0d57ea0b57a78d6b78c2ca8ea0ee2c255203d0fdf078dccecabfb1eaf2905851e7737f34a3121a5f7bec81f742d2b62eb544b9be9e42490bbe2df1cb5e504163a34c97363b80c7d689f1684a364fde750f9ad97fd88dc94f0d30c776fa98e2537411ca738796cc31cc3425c15e58a4607c02656527d7b905404a8a2d0cae397f3bda40753bd85a6e565419a8154a9fc815cf19975dbdb06e965479e0af8e88c613beb43bd1663a8fc48af0c69a592bf68a45ddf6dc063f1dda0070d6041c9acf056b4ca4507910da1ba0dd07f1a38b7c9de28c646f9506c0b42d8f071a8afcfd59c511567718db327f325d70ad1259241be9008c53983d832ea08cba8e5bbc566c565289bd5c43a381144842db6daa922eb9ed0ea642952b333eff4012af0fae6c78bf179b65c67ddeff1f2f27b7eb5571a9d08d2544accc27dec9f2b692828b8429a1ab93e85b1f5b272899c9058a7d97a6c771be032aa86f8e475644d9d022b216db4ef54f638c30af5c2c4a7e8255ecb4792cbb3f8b6f55cef94399615a5a35711d10c3162e488851bfccaf157a13f7747c41c869e5ace44814e6d6b255becf1478d8f76d1072bc2d64238b8ce6e6adb4b5f8b6c00148de6c004a2865a5b1ea7137d42264503da6a22c263a633ee47c0b0906a53da19547641ec4181eba8a239ef47ace84d79826669d0628700cf96a19ddcff5c60b819aa92efa7563941a19b6a1681c0f45811674ad1f472732ba25052969d8c4787a6cd8d27cf8f99ca90a33cf35a1872078c6addb631c62f473724988981ca9368e8380d91b4d4c531ea9832bf7439904cabe99dda9ada1e2af04206c3d0e5a3c8ebb0df7b6f468fd87288e9f3056824f214c6a5ed0e1fa9c9d139217a4616378f8dd408e82c8e1cdb4a203bb1c62cd30c2a266c4d8926b9d4c376c6521b0d7166ced6fc511ee8629ff94d76f195a4a76a67cb90c4c839928a13639b86ebc1bf79df6be24642789468db5888acf21994aefabc338a55726efe75aa390f9695887584ea20e55063458bc1119b56095fb6ce3202862b11b40c0e6831d46f5bf4bc73bb5ece2826c44dbc9455a225ab66243af51d7c876fe5c518cea7d7aa02e22ad3260188faa91d9bd4040281373313d3cd0ce3e390c2e04eeaad1ffe372beaa60da09ab823c756159fcef5143575b36156ead5092b4a775895fe0566a08c688a929c2bfccda8264e2f68db131f703986a75f1bd5f66f94752d13d8364753c946fae840072b80a18d75be649c14fc1b7e00749268c8cf94efe2110da18fd06701c936a394b23f047a1dd551f14d7a6f767404b52fdb7689c54368b3234ba01eabb1d4c38918da8f7ace351fefe2cd2c8d3536c09a4580c5d6b21f3695ec1d0b716c6ac9d24e855659b5d63e3f660bfb03efd65ac1078accd99633df90f655d7c06fe975550ba74f5611b6616b0af7771d8376334fff1e3c1d4eb79358ea6f598bd7ce7a27be57d2ebfc2989ac39bb10fe73af98e84fbc405e0baefdc58ecfea004bf33a99a04a966a171dd2eda8bf4be96c43b7cd4e688fcefa4883a775ee1272b8bbeee8ab3ded2d564b0a252cae6bee72b02fc50837849a172b99ba922d4285bf20155a78481fb50f16ee5950f1315546faa8cbada9d3bb4bd8bdafcb6695ac5c7a5ff5c9286a9e58d5d7e3be593d9b6fdbc7f2c56843751e4b9c15047138a67d8f2c80caa7abf32f6938c1c0bfaec092c879fa75a1f2dd7ab933112357293ff28819136a2aea60efe56393dbe46f8db043417e218f54d2141056841052677b5849b4751eefd688f092edeef2f0cd391eb59d00cf560d19f90f72b7055afce298b5bfc17e0de16fab404b55b8fe6289a98d001983f51cf7e944a3e86c7fbbfb2636a9b3dba96586d72b2005256a823eeda4f260f56eb1841cc2f1541acb65142f3cd3b60fc36413610d413454c1ba6858615279835a6a95e59dc45296fcf0cc0fc08ec297044e4e71250adbcdd1d63726c9ce041f4b2b5363b7c3442c933150430b34eb2a800bc7d68be4a588e148f0815c2bceea3239c7ee5185ed6ea21828ab1c655767f663a34f21833b10c1a7a4a2e13c40eec0c229c3f8f5a9634d792dee99d6d03d08933d222e8725dc29c1d6d9480907ff9c5abb06cb337fc20c394e81520dfbf58c5509049d403e86c87a5d680e3eed7cb08b46973246b6c024f3594776a753025c9f1bbd95ff38977d379876a3cef80f4c5e89546d83cccd8d212fc4fb3e2858998641b4f65f214ae58b830fbbf427d895eb068be8810091545b8212c5b03d389ee4b0be1b0a557924a344488a2e2bcbb2d007e739e61eee8a71e0fb9b00f40300ba344c26fcb752e3b0997261cc156c7f66d2b991be0607287dea397c9ed68e6d2a213e099d6c4d22fca886dcc1c04a9f1b7fa3135e71c7dc50b33e07d5703ca7c6dc5d2461f82013206020065db1f48f0663f27bc2e166702d5358cfb05c43156cc761cae741f2c9b2b41d592dd104623a45aa7eb3c5a88d2a7ebd36cf10647a378cb16ff4cf4078a9adba858fb1ed7cfd8dcf4f242e37976d580f763f5d037997f7503f91924b6e8fdc2d19a267026546faf66412366ae7d975f1c42d492a8f751f5da274d1c055e4e3441008fe272cf1b0c7748ac58fa4d31ead62a93a173ab79b12700d6dc7106fb541b8d1be2f6cd24a8d72592125cd86a1a783f2a01b9de4684476332cc705d73379dbec0aec26b9cfc6aa0223b50397b39681b5d0731fee321efbbd8a8152a2f68779c0decb30a4b65a73a899887a45a37b1becc691e286025972090445a75b23c56d9eb011f2b286bbca69374e35577131f2f39c3f124780e4a6b60344b4d5de98499ca8469173ee56a13c83f14dcefd59fde728e2d2f05d1c417d0d70b653a080a36ce1b8877863962cc933c20fc8c17512d1ab34d024ca97e97d3cb0e8a529689954d4ecdf41669cfdf47d0f281ff5cbf6b47201d13035a8db515984858ec0a9f6ae13503eee323f0c0cb5e05c74f61c7162c91248f3f8a8fda60c404b97f58e61e7207432fe2e580df90ab7cef3864e862a359d0da64f13d8fcaef9d8b416c2d16a05b883b12424cdf0ad76d4b5b7af272c91410e009f884bc728d97d0d1f05527c39edad05c236c7f43a0a657e7eef60d6b74c0ae993cf762aae703145afc8401cd9de0bd00a4973c1468590438578b7804664d2e4a200b793b5340284eb50a7cbfe5c36c3117e1ee3baf9cd46f6bfcf3a24d62274ab6ec3f02f304346e9053366736d855f16b0ba5cf1ca824a0274387c41ec03d30b03f40c2c9c18d0abaf0600379b94b93eb364d7f47757f4fc749576a24a8e8c991eb33e1f8a21611bffa10bbe41d047dbf40928c5f2b5aaa6115fa12fa9e9473931041a102b9f411fbbae4e73cd523c15dd1501c8fb107e9a4500dcf3b40697987ac1d6a62928eae0e09e7091a288a7d70b838f02afe7f71efcbff0b7b452627497ff8894fe667ad7b94c57df7c604f262c03c5a6f37ff370e80d1ad27bc441f6b2d642c9fbf81e3cb9025b6174853d522fb8228ab36e144cb1377ea10bd962652184d988f6abb5e6a0ab3528732c75bf19202da876fe66dec5db27dfa6c5113d70bb49466bdbbda665261f07d2b5b0ddf4d5f5afe7360d9dea0bbafbc31af4213e6b7f3e775a28ffafefe2e4175cc05c94fcee5a1bc92b7bdde9140504939a9c13570aa47a19594c837c5c3bc9203b42ca9003bf6e8b8f79b75f6005ddc405683edbddedb745de81fa1ddc259f5aea6658f9e45e738ea9a74a39209ae546b2d7514e896a13d022f510571fd12f960bcd8377aea56ee4578a2e75a7ebe3edf9f7fca07f74dfdac57d4843a5f0c94eb5d428c368504d55d589516c526ba1ca4f0c6f81d2d72855340063eb57dc4f71c59bbd19ce7335fc8623ad1e50405283306ed9f02494ed67bc0c8358b32076b62a1d73d0120ba09129e43d685fb2ec5da2b1b913ad11a9254b434a3152c6ec02a66b440ed5951de59973a802a5ba6227dde78bf30d98117ebc6066626f5e6dce902ae86c2dd89d5b9f8364d11124afdcc3409ab2377d0100c4400bf3bb7580948b2c6495ab2f3189a16d75a3955fa52053c0c3193b1041179155f196e2809bbd0c7ee9d9e2c9403b5139538a50a14e85ee1ef278a2c0ba89f247aff50a580a865ce1c65625ff4e6ec684c5f4be4a99148aff6c752b53018a1105cb3b866c42d7ef98ea0ffe56c8d82232ad64eb1e5ad0b92b856d4973dda22028f7e41f8ab9f1c836f93c9ff6f163e4e7551ab21aa9341dd17ce263977ac5c22834b33f9ff657c67001bf234d581ab797ed5060017317b44852ac97bf32dad068028917ce3fe14689f90b2fdea4d5b228b675b9f0babae113a6ef56b51a2f17a006449f2852cd25d97aa8cb2d5652307dc393f4747e42ba62dd247b3372615e5cab549d5e36410610b1dcfd64373882c2138b776db53650a02e6b052636ed53462fa16e9c4a8849f5500cd9941dc1bb6a2a786226d00f068359dc05b6b98674e601b0d20730df492b308e92df5b99627dfc81c581c683a4734cb8ea4ae6e116dd870d9b5fbcf67c608fa72a85053b13532308a65d489af408661b71ca9b23b639351bafa66716728b6aa789cf57469f2a6950346f4a8b47d9034c013d792f30f76487506ec4feaf6b547b9c7f9c6cd9a6a16b32ca2bcfecd843662b902b4689b056fd7d118fd43a760060d05f63ecbbf000d5c9946cdaabba21f8a775ac666b30d72173d940985f14713cd678670fe03542186fefa12095b5d19a5b494ee4d726dac10a9d46bfcd7ef1876ebc66a6724a09e76d45746a64453feb19e95ded38d004cdb2e591f6ccda155eae69670ad14e67a907674b225bc5eb797082f464d8ea41181436cb7e06b5381413c7501077d8b8fa0584e4b1d5212414da0bfc0d5b8190cc4285f0a578d5bf24b211d32539d325fa520cced1a1fab314c6e3e42d074b51153e355dd771010d0322421b5aca6543299dfa1e1a2e982ec4748257d2111276565b5076865c52d52f3fec54caed5debf40cc06277a4c73a8a959a5094129476d65f9399ee7f5ca32791f0d4e04b4c42d2f9a5330466e1fcad5c121afb192f12e978101cfa83df0573101122d977414590f08b896dfa9e64ec1513e46a383291475879a67f1a76a3dc302450215197161781f73d8e5a4b6652e3c6c1086e113cc5287647f32a47fb1639a792d14f7ee6866c86c2b0bc259b493846cffc30cc367312a74954b5a2ba7177b70176a2b390ab92c12517ffcad3ac6fff5e25b69b836fd55e0e038847151fdab71606a2e17012dcff39dec99d52520b25a48be94f38b35a94b5e286e56185398b8ec4e39805b52e47d0e17ba18b99ab188001b49e82437a9984e90076cde74ccd1c85ba50b4558f996f123a068cb4af9cde3ba385e15635220dfd1eea396680ea1bcc80df326c1a1848589279bc3b0abb6dadfc6c9195240470bae99b511176210ae6c434856cb9b9f808f01a5d101bf4c7988ba9f1f21ffc4cc50b1ad7cbfb16424f1e0ffd66873a490a49a538343a3850fbd214f59653c966d4a7bef594e1d9640c99fe35953c315c226e1627fef2ea4696bc9e917cf1c2767e8ff83c188225a0079487399721a3ff640a4169a26d54cbadb8bc32947e16b8e215369dacb17e28d148e31d59d1dd50b851a240548ef69a5db6085ebbfacd4cc21d8251996d3d5e17537e7105469e976f3d91773074166d81bbaa09b4549317cf1bd9ddaafe5866959a3b7c7a3c5396c030cb1993c62e94dda598f9c103216338a1d29e8d49353e9f10849d807784a8dacd4e3fdab701b0287e0fd0c414ca6b3abf734f31700ae4c6809aefe3d7ef204de6ecdc2e87cdf1fca811a64e789062f26d96ab7bc72ca29d8c2032397bfe19ee44207e98cf3d8ba0feb5f4621a9dbefc06079eb8e6e8e4867a677f18e447bee86e6fc961d55107d984be34f57f885284ec7dbeaf49c90d68e38cf5a2eaa0b5832419fb53d11361194949eac6c6ab85b1b4c39fa234234d041cc510bb3d81286dece357928a4d52e277f883e38fdd80201617df74c9c8e0360f3e67d2049ebcc96a48e31c882266a5bb71f3a5affc364902bff9dfa0fbe9c2c33c374790503135304b26fa739d59e3b4e598b41e8781e8fb2d975c9cc23c3427b3cb2a14f05614af08719a5aebfa941d01ed395e51c51dd7b0f32c071f10da5cd1255b9068f0d3946c3b6416b18266261f1e5fb16c22b4a12dddcc20cd5048b13a2071719c3b33f906c8f6b01fc64e887c2edd7fbf7e5d2fcc3de1ab26b5a5282fc8250f27cac31ace8e9974ab11b4ad74f2061a8d815e58ea3e7df469bcd902e203fa336b74a6d9c47cc355d9d15be25a4f70102fb6140226f3213080e6af38ac5f86d376f79d5f14f5efc0ef28328dc032a3f74a119fc6d4614e34f9f40e2be7465166bfbf43e41b9968fec4331c172e3d3feda50bffd9c0fe3bc3f3a67bb153786e87435ab8e0924eb6a6f2351572cdc1052cd621fcf44c57cf1260be390863ad311e4f75d5a3d1e9d0eb258f006cf2fc36c86bede397ad71cc5fadeaba7daa0147f1c5438ef6e1366bc0fa2081f259d88c7d1cd1e50e3b540c5d1f9b348a7e25b7069268a95c4610fd9c84fecce0b2a62a6c027826841a91e9da508504a6d2d2e31cf9104b1c9e1e0baaaf3d7f173dfb40b5cb74087d2ad11199d716fd8c8c7a59567bc0c4c12cfaf700d11f0828523c959abadec2b27219e5a9399a054b74d71de04745786390aa3878b0713441e210b156f046297448362f4670e041f678fe98b590aa61e4b04574f050321e7807251da5fad62bddcafe7322aea2580b757f270b5de2c97d8590ba134252a4e9e03bbf682de0cb2ebb7c1b377ea1a6cb6c502f91a521c1d288a64a5234daddecf7ce68ca894f959da766d7b0da979abcad898136564863c2ee8574dfd2e560ca14e05b2925c6b149206215e512c3b353e9aa4d40dc9ca5691a076289eeed5082d048487c6fa238c1274e844c79b5bc7fabb3b8a79b3d30251e1503647400ec9a68cb5c9ba1a615a2fee56b0800ad217410c49914943e2b0acfda4a66f1e1c8ec27a61b2242b23bfbfc2b6868c20dff3f69b9b945acaa209b6069cc3e44e63051a097d3aab2bb92b0f51dfdf9b9673da5f0aaeb9182e6bbfccc87d993007a70ca2884d5917b3e9a425e65718af202df8e1646ef24ad3fa766e6891a624ce8f90a100fdfc5fea9fdbd9e2dc131817cfcb0ace97a2b859a14e0c9c7d4aab6c25b68ece9b4ea350164178a8afb974f42880722b3fdd66be97972153f595a62e9d9a6f2d8d18b3843bb66e952bc1607a201a0ae5ca75847c8ad22f1aeb4a9dd4e8109fe7607f3d36ef6e70a4506cde84ccbb8717059fb5d66ff9b8e005cfaadea056c7f089038b5ca4b76291a995c2d7783fc5d219fca87ebaba94e9df635490457f1b950be2a69d1753e3059f54a0acdee5ca14194c9eb9653434163ff0ba7411f9f9b18deb34f2661377aba70b8582b990cca4252133ae4685381b32431f6e1a94bfeaa7cc3fadda50f16bda20f9143798ac36b956a4f2b7cc0799609ffbf5e6f15e6cf271e9596fc220ac525060ab9ae72bb5031a020b2db2a832981f32077c77ad858a32f2ef9a8627aabc143c69684e94dfeec062a439ca2a1b7200b54f345ee476e291fbe35f833f058af05b8086696ee4abd8ca383a6c5c645a4cb336aeaae54cda359a39c744bea1f5677f88a81d5668bfaf2f1c903e67ed0e17f896f0bb731f5887af8ba4338d482123e2e835f6537c30e4082de87779b5cefc7086fa94048642ee034e35e40d313a0f45b300c88c6513cd01c5cb47c6da765c96e813de7ffef0bc36795c812eabfd09131e19da094df71c7f941905f19c44c59a3aae729937a1abbd397376e66bcd79d42fdcb01e2c64f7d5f02a0753ff9b64901564800ae62a77356a1f92d07a0aec093eb00cc5bae695b29b570562c433201859a6a575061690767cba068c560110e6d6d72520039649055e9bc1b9bc03f9b4993f7714607ea36c03f00ff4ef426977559ae8e7357abf2eb9ba99fbb9189d27ab744a78a4e93dae1fd4b68a65b078447d6c24011ddbe7c344e1aedbccf5a417a571d2bd125a90b3c8ae555da58b76be2892007f059c96dd0fa61735ce89503d381ef60c7363a7c1ee1d48cb06ffefd1891039080fb2bf73d86734be54933e2282362092490eef233f813b81c7d63f7d136e582e6ce2e875fe37e7d65351e7af219a69b3cf62734bfb3125318734320ceecf2ddd914e2d5e866f7a43f711936a1fd87e3fd1ea2b2029eb214a01cb7cbd51c115b8394bc2d3125cb4efd5aff273b2328a6a57510e73c8110820cb992546ce1760d2f476d62ad2475bcf84b1dfe0589e881c9c27b01989cba7c9b003c6ad76bcd2f3e95cc5847ef7a0ae66c7a8210150cf26b8966f1d9782cbb445204882234f1cf3445fdf400ecea679b48a1f53c6072effdabca7d803527678d4a015933338198859499303d9a7421963050702f1c4a6d8ef9d551bb5e25d8a9c7862146b7436c5982d1e13598ccea079985558480c61824518bf92c3427ca5433d927a6d09da1eaa08e7f30fd64d246bbe051e085ef8a72bee73dac2dd45e2bb248a3915310d082917dcfb390eadfb6a3c7cc8a32d064c2e00ede55d52f3b590822c6451060186731db13a7da7186cdd83d3ca5493dc1dcd0b6795b449c864b009abe3695f83507d543009ffbdd11577820d5d7fe9ced0934f084d87ad0127e1097c5ac93a6123c37882a52145901ba02e975b26b6f9c77026cbd08384ce80f996216d11b897639fe162b2a70ddab08ce764e0d56a86e9bc65d5ba8254bbd9dbc66c4bed293d000e55ff48a2b12a4709c1860e1f89d6baa3c2f3deb34ff887acf5f92bf4cce41bf95f552d18b6e062fa41f09246a18075fa32c7dc325cc1555742d1f070f6e1573d19dcb41229de62bc8cf2d468db54670a37b359d0b80b9e9924a66748a96af815f0892b3583b13a6a225854d430ca1e84ecf3f85552e83b8493c44cf7f64da6c1da3a6c3a39d0440a365da921a294a6c5ebed0c337bc651f6a0fcdb90b206f89bf9f2e303a2112eca4739eb32542c401bfac785c52b86622d37b1e5e5514a568c1b064cd21144a612b9824d3e23cfee69e9719f62d9e55bf244ca97ab86a1e27c6198e7a1d216401af545a2bd0d0ab1f4d0f02b4b407b0a8deacc0f8246fd1c93b788f6aadad109688afdf4f2fa5965bf52819cdb95d092b0b600dc43967ca3dd6f0cce7d9977f19b9b92e8b393194e46548b47835c0ef9f5707fca560a2f4f8be6499565d068bab464a459edcf711e1986f0234021ad8987dd3c78f789b7a37f144fc1cae6d51c48a238fd6231c57365da73e26fcd0726166a5ecc15afb3287560ec94f5de0de0ee01dafd07921274b34336090593d0d7309a2b0e7b556fc404eff1e91e3da93759d40fbfdc4368fe991aaf1091283d744c768013f81ebb95e4f48b1d411f9695431b0f29ca7dc40854e6b6d6837de6a7cf5aaab574f272c86642e6084d445614dc1dae5453e6b5a1ed5724834c08a547176ac10cc8c1d5f58f45a9a1ed65ef36015184e7cc1392cecfba712c667f29e3e4c478254ad6abdb7d5272a65055079252526d0813576a34d1195bcc6c510b277563b0c233bbc1895e4de56e79c1813f62e6e4cfdebd19ab5eb4aaa928a9615aef2883d9af24471a8675d2e9799e3ae540222d0e9f5d6f468c69eaf1e32a5f467521ecf509b5b202bb1879eb27293fc19a68dbe5db29a6db427368f351d40d5518f0b243038385d4a7bf11ccc233379a787f12b804d33c9b47edf2dbce4f3d3f10a13c0d9fa9b80c3a11519769f741d1978c820c9bdddfcb61c156490184991fbbfe1a7b4b80186dbb0ed52afb0b71b8172493c9a4b2d3c8cf81e7b5a116f4f276dc20075966bae251924a960c16ae6c67b52a5d1ff526c7fa8dfd7151012c780b5471a030b1b0500b789e926a549fa63735b667efec1c542bc74875ec81a57e9dd5d8824d0c1b99fadeb8434e5bb05f815fe3f188cfc40e613e6507c5797464f7550ad2e04a4949505d390f1f916eebe36ddb9020e4f3680fdb08cdcae9a0ba37ee602fcc1e55dd2bb393559f011289e3640c1f4b8fc10b9ff5e3ddf6176d88fad77e6e0aa6e66b07c179820745c67638da677fe57bd6c7c8f940ab436c8f4922de280b5b5cb5605480e9d7c38294e91b6e911b5a0d3535302d241744f12233aadfcee65e342a5579287202e1ec2f867c1c4ac2ec111841a7ff0cbf50212b0f6bd399d7fb12244fcc9e917b26a34de023c64dc0ddce92eec6b4f4f06073e5b13b3e5ffa61b4abdf1aced3c7465f3d000817f3c0084603c71ce0b07a5030b9337d629151811b8d59080e5fed2c3b85891e1dd72016e71e46647f70304ddcbd73ecf36ee323d0cd2a628b03b00ba1f720f3907b684ba63954179dcf1c542770e333750a6fa515e7d02178079c6b13fd5666a34296feae8919aed160d0a06a9b104ea03a14de42e73d1fed74ac97fa42f7f9f8ca09117c1445a5f76caa9101e4f5fee511c1b592fc96e5ce6c679d3c5cfe01a49af13987e959a164435ebad9e330e6afdd7797c5bf5a6b9b63456c9d8be71709a18788ce5a4549f443d7241e542a39f6bdf530804d384b4d4e12597769a298f88bebb3d0bb6b477cd14450586ff2b3502e7ce977e6424f22712a97d1c4d04cc967","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
