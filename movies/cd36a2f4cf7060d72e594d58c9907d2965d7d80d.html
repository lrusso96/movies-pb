<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fad9909d1a61ff173d4f80b1de5aaad6f81eb2acfa0d01168ff7a2c17ec610dbe58f45bddc98df27ac3dc28bdf66e5478e15ed2aab2300d89837467967ff9637aa976969e4c22bbddcf3d607907e95eea3147525d0d9200b9dab12e37e8a9f70c31c92f810b5ed9ff1c0d74f28bbaf75de592c6f89dd20306f89137a2cc1d8b01c3b046ac3cfc57e538a8567e4227796d29013d68d9848b307c3a0a23fd1c0101a331df6357337ed5b419529813ec8263fa9e05f8688917a3824ec4346829571f7dbf18dc5737a7f295bb89a305715ca382d39ba6108ee3fa059b7a5efd139420eae4eb79f94a71607e7fb49f849b7f81c0f13c71d334606d11ba9a0cc317fcf3e2eb42b08708408f71273e7a856dbf524d625ed79aefae129cc46ed6d6dcaa9ba60c647a16a9b84bed347dbb09caf1ef0cf45339bfe6502e67694fa987d23c06b41a658d1d1b02796bfbb5191b3817d5f7d5267045bc4ea29c8304ff06ebc5f7ee60b988032ed7de0d7e908fbaa338ea5da3a7e168de8e718778060feed6dc3b09f790bb6ba7ff8c3326f21a8aa83d4fd711f6b24720973cdc3e35e2a11baa42181a33b45509990ea94b5356fd375f0973d7f434f47dda3fca7472f73bbee62879f1909a5233a0f7a35c7acbab3a41103ad0d3ebadd6405c918c553490324fa5de5f926da1bc73279ba8945d4f9372ed076a1735398620f0008d67ef1f8139527127e9e43fb2de60c30f2672b1f236671e6bb13cedbbcbabb145c3a6af761737b96106e3e75f437a0638e52da34756db834fd3b0e3a6048902f969ab27d90d9e39818bb032cdb72cde7d93e394050bc27f72da799a7a75c3d1cc3cf31f8000d3c5d5aa015fec226f4a837611aed908962926a7658cb59d37ff8fc8227fcf98652865b23c2c941229ade940b1d4c67e45c178d79b6d5adcd2e1e95a4db219b9c59ee4f2c35d0f0e49c4dd0bb944aed30c2288588933be163d2097eb5fdfbddf28d5e3823c81be2286a34dc39cd9d04575db4db59a5102c15cc8f84e7aa997c8b92e62e8a07c06dbf2c044a31a392e193cff3095844d0b51bab50336320f6c4c2f733668f74ca226dbe44d8e9b05620ec126b333da563dab36c824b3a5a956f97cb034c1333cbf34c08d8938de1b3b805a1bbae01d44ec1ff091358c2af01d4c276b9d0d2da32e413d53beb3ee777dfc9120de0bc91124acdda5e5753a630ec9acb2bedab14526fa403c80e7e3c959d855f4a2d85964d427ac79d069effaef1dd6b31f3ae28bec1d264590b39f7e7b5d17b5b371029fed3d23a76c6502a9a4e26abaa9984d8f9f73ed88cbde7c2e0f116828921d7aedb411e080c8623154e7afb26f71c5762ae51bda0acab61bec41a69fce8cc4f1feef912546906b08ec1921e56d3be3dfe3389d80956cfa5f4c00e0a9f6f2a4f990390079e661ee90767af73f2ebbbf7ed9bd0a566415b42a125491389e7c54b0736fc3269d3a4b8ed5089094408af14e4558bf306522a5eb6bb063539ce29acc8679ac40da4bf4f048b9ac0867ca820c3f2907965aebd509cf6151081dccd5f1f02f5c814cf9edc48ce84fbeeb773946f04c7fe6c8d44c997c1b13d02b8a8fe69485188b02f33ff291be4696be85310144c422ea6e35ac99f6f7aa0ad2da3ea451f706df11c3013bc56115cb9a366bf4c839092b76502d5bf14e92698660da3e436ea7ff8e8c0b763b6e37edc36aff485d2e1b78e997e036fd678189623e8ab79842f8f78023aef7fe475b2be0fb4ed3248fa46932dd81922db9cdb4250a80450d3cc903f0a66764c82b36853f01227e765bc66757bef8309830d875aeb374e8cf8aad5ec782d1f1df8ed12213b323a5e03a77e5ab45141da088c9c9ba838e74337b5eb5510ba8328084f7d567351fdc3b7e60ad7757c31b1087bd79f699aee7449f492a93356e581e1c69664db04364c10f8b56b69645013ad9f38cf6a215af7ba3b9dce7c7671eafe5336ffaec89949b0161c2efe61260af479930a72708d0063e75d84d8e32fd45d9e56316f1b163973c0d882825b439517e022cf953fad05ec146f22749df2e39ada252a3b19b81c58a1185783e1ef76455909776b02038e5a1ea8602181e64137f707350b6090a04f79def2ef0a592592545680437d4b90402d07e702fa55fa9fe16634be007825de8e664b26627b531054ab3b77a342bdad9c2e5597c58f7cb3a21e5de7e0d2eeee6883e59e2290e834ea4b24c41afb59568d51cb78071a64a28c97ed6688f3373d28748a87cfb9aec90aa418603e94712de1cc873eff1a12f9a3176d2aff3c1fa246e0bed1254be6ad6f7b1514e288a6b5287d4b9a0e4411dda42ed591f17c1ec4b55995ac9ab41127b594c1d3fd4db200b227a764b064f1fa38c4b746fe9fbb3415b5a2907acd0d021b8a8fd8cb8b5436363c81ce626f7b8565270be50c5dc9059b5e31ea3ebcd81734789fbcd2f2d7023573032bff2a4c060618bcb4d9da896fa63e829927743772977e4c566849ad23b03d4d6d4b8a3a53393f3da36cc48936d6cc494c39e496b5f960008081def75dbc3f2013b19d4d8599a6465717f2436e88e42136bd7bad1665f839c336a7c0b72e6436eb08d774e091d9e59d0ed7b8f6aebb35e63b42392bcbb5471028a8afad1dfbb846d14fcfcbaf8ad3642376cf9d2a7710143540a22041c038cb8329c663fc0c673ac3ccd9d6827b9137f36769ad8cdddd0f564e581f4a04fd1b77525875b567cf77d62cd84ea4276e35706b30ceabcd00283b0ae6dab00dfef4e7f3ed8e0d2230759fd27ffd57846830650b6011799326da08493e2fc2aaee49d76cac99a5d9a1afb51851d839155b9e7436c2b1c446ecf193e587bd44557aba7fcfa42a58766460c3b84bc50cd14351ec924b17b99f5394bc4f41517f0b51bab622805fd8659d99f435467f7a738a0e1bad6f0c14263b275340a8f801ede6e76dc4350a272c04703b858372115f92983a98f3f3e9fa553bb3b21aa3880074c6ebd0fe2b014c543c1266b879ef69d7efed541675612329a6cc5408ff286f689687cea62c27ee83d3f3f18434f25375521f015e42647cb5df5363bef850e3fa86a059aa3e8b98ed3b0b457927444e164942d5f1922ed4e50fbd9e91129250e9f4447f0d6fee118bf8a774c28adc0d9e0848e9b279042907d3f8a4a40a25e76a6127eb10bd59b2b4f3e15032735f64ba4afcaa6abc2a98bff30bde8ff9f4e7eb1e36fd8691adaba58542691ed9d63c7ecb718a57f45ee0e95c41e003d7313e054363a03884c309674b4bf81c2f2a94d471b234fd72cc17d86b6cb7d490a851489060cd795720d9fdfacbc24ca1589b795cfb791c9bb6f4176c99da336448e659a30bbb9b40d68a039386576b0164ea3fb2b0a7bdd3ee076ad779f2a0807a773033a2a37d1ac607aa1ce8d1526490772589340605525c9738bd0383efe96730249cfde4c076c337c66e341513f2274a41888f3f1e97ab41faeffd01ad6725f3fe2e854af9033aab7c28d7c50d8dd1ade11c47979968fa86c50dff2ace4457c6075cc03e5bb971240e1f5342432192839bbbfd65a3aee6cb93c887c3e4f9fdc2a4691bcee3fc9657e762d0e01da8cf4473b71dadf929b47457ec3c482f050010b833c4362a7c84b512088d1f8b50b40437baecacb9e11f23d390073daa9333181c08e100ac6ca70d3739655ee1426e68ef103f739c2f58fc9e1edeab5200dc873e7ecde7bfb31aaa45c8300806991039f1362dc26c11d6fec2defb3e6eec06f9f1e91d0006a47f05b8df76a78d0ab77a10840235349d476ae54d5c66440060100a51d6f27c61393394401848014d4f2bf28773d74456c8727acc7303f822769224d01e6fbf54c8ae5e86d8c7d997a10c5ee0ae954825aa66ebdc1fc9d3ec35b17616ea963691022aa2ffa3a80f8df8ced84194e28775b84b2c738d4837e4e2db3ba4c016a07d33b20bb014eacaa600975097aad2d717676496505d35201ab32cad0239c00ba1aa297693022a6e98e12fa6db83879a877d94416bd7a670c03c0914a1b87d8a643a46bcc9e760278f79298909424cec369087e7e26cd1bb7def35430542207ea3f4690128c2319d7dc1ae8a9a498ec41615528994d53ff3fe7921a5e0d0d4bf6388b568bab5d21963f5732563cf383cac7af78c034bd736229db86ac2e05306b25c23596758963a77c422b30dd357e081418fa7eb758a31068eee0607049895692378e3952be82dd51527817ef58850c4149da34cfb896b755ad416ff4ebed3f5619d3dad9fe68eb0a2300408ea1fabd55c6f4e9b38057d6568fda8a210f7323f982aeaee4b5a70d4bbcbf182a640f98f32c272225a2f05cf495f59c53a74ce57df21630c7cab37d369a191b1e1db1a5a84ee34d8dda31cc1ce8192818b1216b5a9073aafa6f7c2a26a3739ebafc2642f5c1e829d5707ae38c64fc04cc0ad478dc42dc8c302b43e93e9ecee7cd3e91263f612661e36b495413e9b790d69e11cc046cdaa246885aa69941fe3182d1363d68f0f97e4f86482348a6937df0c8de9d35ad61856a74d3c4bbf6e325ccd798cdb6d3efe0f942a73fe6dfae9ec377921755296f0f59d091904de4f45edb325214831dedb05597bd1ccb07b8ac35b23f99cba6335a7c14f1365633b577efd5411c5f234ea72e851f58ac65daa46da46d63a5a38d949a82437dea72ebb5a852833b0af20e11032902fbb50bd5e2e4762b4fe60f80b41fdfef5143c8817799469de2eda87090270396d6b101ab4e7c5faabf6ba167240b572e5983d0e94619e2920577508c908367a494fbea11f6eb8207d6bfc631aeeea594cd0c57a7b9941f7660c63e8f5dbf3240b3e98a3ff994748af2fe09a072dc0201c0e4e038464a165bea1bab0aff4bf6b821f5890f1b63f00baef486308f834576b0cbd689d6db6873da99bf2313506067571f34e46a5aed825a587632a54826c6f9ee914107a6d1c23885f4c4647bd05c17c0a317ef8d129636ed789d3a913325b0857c58d9f2aa082a36b71fc8b775750728d2e9bf10da2d8fe097fd22310fc5b9581a16351c74a9fd4a46966d29fa33a5e5a3645b48751ff5a75972929fd440b3f13cca84f9ee0d257db5f7edd447c2678045e27cd97f1dc03982b1f1d02ef6979785f391c4b8ecdf422722bd71099db1d76ec19514cffa70fbd73abd1f8c19e76bf79c8f8e612ab33e8b5c6130114d3ccf690266014d9cf406b4b91ba8a5a56b0b95530abee7f0cf6bbf672b21ed7c14258fa9cc401a6d977fe88c56015dfad14bb0f2a8193ea1cdb19555cabf4ecf5139e6fa9d58f0011c99e4db888dc0efbc451148fd4968a62a38e82a0632fcf212ea062f39eac8ce1ec756e0a17d4546df64759aa058b40b9da03ab3054afca16add59754e6bbc4e5b25a124bdca164990f2449cc635cc5c3cb96b5c06b88e167e7368b95d9ce1812601f4a17b3f4746e8f7ed1e277eb665b69f3515598a1c1f1c53e9e4559bad14adca492891a41ede36ffd3047e2b9ef1f28915083565927a9ca395cffac87d7b9ec067f73933f51f0123e6f13611bd29ff506ecb2c663e6c8aefdb7a04e50d4787076048345ca1ab57bf5e47501678dd7234d97a4f7e3fa3f798b311130fc14f5c68e9e888ecc09935d20409c580fc2735ce2149a9dc8a6c128ce72aad83529b523b48c09ed121ef59c969797cd0e83be0872b3ff017dc4b4a83aed1910311c55e86fbbe8326c4dcae22f685a6f9e6e3e6fa37bb6b41400333edea9ef08e7c29471798db832e23d81d0d9aff1cad425a52b3978194a427cdc1e31676807fa88e7e18f91f83c85c9755d2a55ba4d6ba09b20c3f8d232973f41af0aa420d2c33812eb8c886c739796325e3293b339258ddbaed9ced8c273b004481dfbf954f6c509b13490fc81a5ad5f8ebb859f142c23cd5a96f6e1e8ba31f8efae3523c2dcc8641542ed4600a54ed12c5db40541e20ccae260d4f0620bb81bb0b7d5b90346e310d7bef00b4e9ca0c30ace0f6f19b7995abfb7c74fc4d325c4827726085388e0038439be0e4b12425becd5ef92445bcd1649f31c38d01371d67eb5a970c60b2b2ea4e8e1c2f7a8116e3df8a14fe9b8692d5f1f639e6a2e7ffabff069c87788779e56438260f81a7e891720b69c76730829f7e6ec5aef87eb10d6d82f8e2ea38af071b36bc53a2a99a9a47d7cfc0c078ae3b2fa4ffe0106f4a719ccb95c3231201dd905675322aa1b2108aaee28d9c35b5d465fb63c782b16cda41b109212c5962b988de288ac02655ce4847dd41878753bd9a7b415582770e62e63e70a3ac75ac24aa103faa1cd7b6ddc76a8e8c29014722039daa8d2ab3a6bfeae42c280871d703fe6e2e02713fc4888293bb990c03821c1aa1625e5289e021d23bffbba4581ed64484b262de9d5576de93524aece019c1d3d34f281e928747c14931e69110cae6dcea50389c9b0ab98a6d1d6e54ee9f75f92ad61f68c5363fb478562aeabd03e7dfc062231d3a636c68ef5419eef856cbd8c691c4c234829206c8522f82df598e0c73b1d6b83c87a959a36a4bf12ba759dc691285bb23bd3866cc30fe429b96463264aa84f140ce6e901497296d1239fd2b0d39f5cf9bdc5ba8e16f49aa65d07f7102e4653fe9e418bfce61f5cb36c357ad93bb7bcb6e0ddca3796a087050ab29bf844366cb2700ec66e7ee0a49a539ea5cbd44b469ad7482e63ccb71b30e6fc1cc75cf510a2ac36aa14d5dc4e38a9beca9817d38518cb302391a28b3deeecab09f8fe69385d977523487b7400303e3026e824d14a22cab1117dd4ef5e8b4d6212253e958404437b455284761254227c03aa11e95a624ede6d1857242ea99802c250652776578a1f701c72f897058b27dfb40cf5ca2befa00bcae5b96238835a6807c4cd38347507aae3c8afb194d858cd898d88bda15a8f6e41b31e6dd0bdac3a2cc3f9d97a29edc91a3402021b1cf7486fd9109a830df2850910fd28fd1541d8c23600f329f1e4047a0df352b3f405d5d9b1c1735fff0ee0b4a26de416d4b2db53b3dcb5673ae202642a195570fd27004e87d14a2ccaa55cba73a4a76d1d2eddde59cf98312796abe80111ef3a23aae95e7936130e6d66a2b41baf567d410d14789a6f4e47b243223c37ab5440ab18f9f30ad4e8ab8aade8d86e38cb4de6290f8cab3adf3e127fd76163a81c7571550ac48aee3486a62912ddd6513fa6832e120fb68040fd3dc86a2cab435e1556f7286c41b5a965085dae9c26a2b32a5e8bfff1f4ca294db0426d96e96ea5ea7f2db006c42332a210524dc9dabab77523d3ff6fc86d69c71826ba9231eb3ad4b6fa38d4b72bd0bbc7e3e13d9e867d17aee167ea1289442e558cf32fb39f04db10a000fc87d2f6eb1c270b7bea5d82cedeaee855f09a40144631629ed33b8fc40f98e372e39047c4cc48500f9a252fd35ed69a1f786283d8ac902d507023386c77f937d08ad6e9fd396fdf6b480d3a74a941ed71269da4473a47e90596d0fedd7856a141814c4560f6f61212d736c0d4d511049af557d79628384c3ec87387bd4f4e032e6b4adf758413169fb973c2f83d0aab4c9c4fd3e87aa7546e8e0cb59003a6d5324d0b8a7b544b1efc2572ec6041e0dedc8da214623cf241f28d91e9800675fce9fda652c702de72441e12ef96ed1525cac5d73940ccc74d0b9dccf373dcd623a4f654584544eb088d69a49212c3b561487e6a61bfd44d920483e5b82501227860bdd7ece5dc42d30516518e6e8156f3e72fd8a880d24b5ada2f7bb5fc83da66c45681ffaca0f690ca02492fcea06052a9a07e00bfea08c5f383ea8c1bfc6da1ce0909d2d79b0e2f4803980c9c763e980d7b646bd36cfef1069c649e7e750ebb9fa617624cd6da65155420dcb2e03c29c0b3bf7bfe5e23c61d83a0cc720cb27cd93f50808524cb44da79b89685a7fa3a6205436110ff226ec9d9622c7d72945c9f818e238c89e3e83742652b1f1a24514d56b532426b6a157a6b2162cacb8ef24972e542db54e698711714dde2d6337cd0af79850aa172886097afd8e68beb6262acc3abf5b461e447816bbc1e5e216e5ef147552ed1ff87c3a56654ad82119ef99a48b5094c208a227e92e4a02d7591d8d61fe3b4ec790fe9acfff50afbf19691cbfcd684b816593f5a794b0dd457af030dfcde6782f5d264971f415fdaf1b93264be988fed71d01742694936a488181df659ae88aab45f4fa310c38398768cb623691c7df5271b7415274c764252f963b0f699fad1491ba35f1c94ae4bcdb3198a517cfbf9962b85e2ed5ed991c195595bfc7d5cb53f6678a1b4cef812bd3a05cc6603405b209b259e476ca272ac2538ab71adf809eb00a1fe1d5d2f5d2ea4a0c53d139e6c725cc45cc8a05d720eb87df3d15c10477c81aaf45989eeae112004a6d29f9b4d1a1e42db6a28e662447a8bded514ea20b24c61efe857f10e4f144689fcc0a5a7bd9b76165b625c51fe61654b566f2c711033ce803f2f9179f665f9b8e429e4940d190e5d56651245ae1e5f6e3bf4ea24b6404f63ffde5d7e0095625d604e95e07e18fd67239b0be51d9e5ee14c240f766b2cab381d6fbd49cdf5bae4aaaa47771b3b4f7eba3bc0cf6125806f8d12e7d43b6b915fdc6180b838f6bb4a371829af94bbe984493b6aeca5db001df65a7f75bc233bb9b15c1f28706568e5dfa0c7f17c48536fb710907ccdaeaa45bd75384d9368f4e9ab6c49d54818d0a33833848e542eb62fe2bf189fcf4a5bdac42cde226f7b27df8d41c24c4776b32d9f74f0a3a70b0da89f7fcf08ec780e93e083611ddd2f0cd13cfa9b436e032f267436d3233ec77ef3f0d306a7b5ca33d1e7ab9fa57470b556b1258c1802471a4c1514c9f42de282bfa5a2ff6089c3c90ee84ce52e7780ab394e0d6cfa238f5ac2d2a5fb8d1ce81e376ee8e321e28529b3a7e8610f4089c104b840c656e19023080e591f195332bd2aefcfb1d774a977c376687fb91b375a5ecf106074270e5c4b61dd0f019e2b703421c7e9de5dae292c423a06e4e9265db7cad14886a218be288506d27e864021f8a57c19652c468f9d1441afc80d17a6cf388154b838bcf2cb801feb1639b48dc254cd6bc8e241ec223f9523a7cc83dc22fb09e230a5cba87eb946a74c2d1341cf557393950f7a5862419221ce2b72450d80194f5f9a5251af94a77c787ba8e3d0bfc12e4606c21826101f8c0df4cb62cbc3651d4719dc19324bf73d0a2d6763517b4d582709cec2731d5bba096a33d10d8c5ce903c6f082463460195e7da43987cdfc8ceba179eb397ae82e1c3887f5818a5068c1987f19b9affada51b81e956f13c3bbdc045a446a356b65d792123c6bc8dac9aac469a5feff888c84937cb091b1e796026d47f5852283076a559831bd97f3bebe5ce31fc69b7430273eac46741e8d42759a3cf601924134c90bf3eb31417e5d1ff29c4c89e5d034722482f38cc6d0d9667e9a75be178f52809278fdd7c72cfb66241f55e4632d490052ce36b5115601581bbc3d7ade1abc62e2c1b454c4f6a94bab4c486dfeaa5ed34219748345cf621a815affbe5796a1931257e7feef62817810211756ead2648a6bdbe5a46625e4cee23d0836c600dbdd9c87e7db41a77f4e07d420936ccb911b365bc0bee8169b47f14288c62d2e5cc497d1319a688a2bcaf7acd13226c3401be81b44ee73d61ae7635434f09409549ead5cead4d68cea9d60cf0d98b3fd2f07cb47fc025d838c7314c1fe31771ee352d529e701dd87b5574da5428e3b961062673c46fdc9b80f12ddae595282e74a4f9545bc75c8a1ad3b581a6d7a636063adcf37460ba6c515ecfdcab7c2a0e67a20b5511455a1c3d2af6622d161b108e564170a88d2cf6c05406e02da35b2e43d69169a98d2c15e9c762de7dd37851ed6a4e36087a4137f19264c118327f995c513b6dbbf534e10196f3d9be1c85db36764eafa0b915665fad0b8e46644658a984afed4fe43931e853dcb0310d48053c7358535a2a98ffbbc89ef628bfb0688f48ee6145789023c5b100ab21e354a7d439bcfb4e2c2279292b28b1a7a2bbb6d5ad1d63f0e378dcd23575abd4cc4392f9017ffdfa4735d3beb35467b2383ca572ce9160ba206d540cac6d38b041a3a01ae84fcc7b19fcf746f867bd34494337ea01b1930a084e70e897de9f0ae1d245f7fa10a0040ab2d428aa5a7baf3dc61e5b42b52fe47e989143dccab2e36cb22d245af74b02eca7e31eaf9fb83afe2df947070b922865e8c9cf9e4e9e254ad99f67e8eaf059ae3d18689432273fc8c139ebcb1b5317535e12588f6b0c12cebc47415d3dae0019cf6ca465f64f73439bf0956d2abe8d1b89f4327a564c80113aa5974834a352113db04e4c64e1a2f713ac7d2ab6d8e1852755c65db419391c4bbefafb7d9a069de1fd8b30a1aaea657dccac42ba40762966fec335ec2a1c39fc95e6fda47e4c2188326366f780b1018b4d405b73f28f0209cbf0357098742e0c22cf228a3eeb9efd604ab510f7803929c75127386033722771df878dbf4dfaa3c9f8f503b827b066807a774028434d62f7b021429772962cc44a732a3821f78a20fa92323996478372f638cc162ec5ec985a364ad8fb5acb69b2f204d2f5b5c7f6ace391b1dab24dec4e621170a5415b700750b1caf4790b14c6eba374a8db73a27e22a294603bd3d21e654a5975795d0e438111d33ef781fac996db6565db4c8dc5294fbd1d43a65c860afd75dd266d858131b89f3d69b7128fa1e1f84b73272737f68a172d53b6da1285aab73e7ffe3fc4b546f845e2b63e71a9a3b4a4264c2698e97eb4def7a2cb284221af47a0373cdb15b2b6dbf7505c3c3ce7972cc4efc8c8527e3b23d45fd3e267c860cf4fe84c03233aa11e4a3bbf07ab166f72f3fdcd535c38e8b0cd63ed6754632423aee07cd848e72c89f6ff89366e7b2f4a008e427907a45971cf494420007736fa5cae1ca240b8e0e78a0c1983433990057c2d28252a014b9199fcf5b30528725cc59fcb179ba7b7cc87ba8f3276b3fca5f552e1d607c52ec0dcc145065cf0fab89c57b22724417ea24a04aca49b88beae430b9c2cf95b86a25af339d6c4f1934485bf0a4e4abf1e0a454d5e8f852c932cd08de808dbdd4f9520d0b4bca541621859b1e13579723f917d7ee3cde250a50d1fa871923ee14d2dca7a73294b146b26c5b613e18afc148f1fe11439e41c9087aa8afd34ca4ca446c074f371269257f0a9d4e0267a4bdd7da3a0301319e164ac70ea297e4bd5c2843fd8f8214f34748c4192c7004ee4a5f11021e54d45778accb2a299b3108cc91fe11a9e83e5d0081b5028981e57af1e351767589d4746a9e131a1aafc0c339e867f4f34bc82e44ed33828aaa223460edcf8c8c75b65dc5b6e4fb5ab59c0f89005eee9dc026e941cfba55bdec05633a056296c0f9b3da2478cad3160bc3f9d127ec2006f6210a7caca70112ed013e0bb19372df620ae95d3bd979f8b8e7bc75998e08cc3a74e2e62d2d33d0bb9dad7c38f3c30bf12092c445d4a62feadcec882f07155919b38eafc36b269132c2abf769f759c7811a73c598acc945ae9b64d125e0389b4df9f3500e5507596f63ccc3ba5b5a2930bf09f5c2f152b9b564f3051dd4c56f87dfdcca728e1325ffd39da17d1f82fe16c681b60d561baf00adc544d39fb61e87f2bea733b3f2e9f9b80b934326a9df5c56b84178ce813b09585e85d90b907f17cce6e1378bffaabf4a5cbd3babca9ea3d4881f80f6adaa28cdf32ad654690973e8d67548ca3619dcf0af210c4381ae5c14a4ae746147c9a80079d5209dd93d9a237e443bd87259121e7e1b96e4c88d59a90c209038c642c7e8dca98acaedde667b1743c66518eb5a7029a106c63ad6e56543d6d09ee30960d75ecf8034e2a01e5287d51b49a07a0db845a96fc156dd9736ee29a37e555dcee2c9d86565c17c4195706a858f8f75009d8ba9238fc58a76cc1063279fa1a6d8712887f1d9946a4f0aa26754c004bc012b37aff22ef3ab089e04e8e7c7a6c28d65a7f51a7066dc7ff3204b6b5ef3c976ae4bc583f9dc5c241fdc64c8bf9f5e046ab1d945577353fd3ec818199c65d8d538c2ae0b13fb5c778aa03296bbffb8aeaed134cc98e7f02a77c40cacdca9a771122ada665770bfd8620138cce099dc424968e9f8176dd5dd8824fd192a8b6f9cae7f9b93f94f86dd5931b75f84dce0b4b845357fdec05d3b6cab7b1ad07eb5aa21a6edfc04d19979d6558b2c5485272fd609958ed3e5589c79a0adc984382a352be92a9c4a8b3208c4cdabe08a224a7713e0389731ca4ec49c04c997aa04f5c7b3ba6c8aa714a2b474aeb151f3899cf078ec6cbd722181a2d9bdf4c3fa0b97049538dabeca9a7ab3fb5f94625908e76aebfbe4939b233454053980579371e78f67fc90674e81061aaa6c1fda94dd9ee1d58205238ce7028ae81cd8b81e054016ea99770e3b46bc5a30ab8cff5dcdb08d809959268cc5651346b128d1aadba577ff1b040ab2a18b313375ae7adcf4540e002c09c91fc33204b7b811695a9f92aeb1482b305db0844be11ea5e17d3d434b3e12b0b6910e5d3a6603bc3283d76890ba4391db50fdf879489646ee41022226aaf49c437fc1d42f396da5d0ef473d84f440d2dbdaba4c6678d5a9e9b653a5707facb4cf98d0ec3f93b2d62acffe150737677694334a7b9f37326e14ca9db4089e8e7194d62c37b0bff24132e6fcf52cad9d50c26a0be7818f15ee3cdb8ee89991e18a8dc7d5e7b115c6da985146c463164777834e32df794cb77a476c6cac67189d7827a310c215d516aebbc6f0ffa25cf11d929a66ff54f1f1ae1049938fc8f29c76040cbf264dd7eae881a93d80f66f25f14bba060e99382a0d8c5a176aba2d89716ac2d795bd2a36ed215806e5fedc06669852642881a587f1d048783b08a05d83c3760a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
