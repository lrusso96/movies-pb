<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"918997c9aae6a197bcc7c78df5b2a158775be8a21b7f661e3188c23a526eb49ac98f1032ddbabb872181666f8474d0f5a3eb431414959f572398f4b3e59d5e0470004e1445b73f25e934c6870715a002463a076080a4d027371a4f7f8aff768463b9bb8a980d0aaf004e144f76dd8a209e5027eaa8298bdeb9bf1b6ad9b695f241da3a401c4f8210ec5a2fd936ac17bd02ffb5687400a74583337a54aac1ab5b7ea3615fc01c2cc72608b7c7273bb49c734e6ed6da5889d8743df9cad3f523d876c80b23b8edbc3aa30913a74c5c6a3baddbee7795241a4a30bb3181c48c0767ef7ec639cfd85347f60cfbcfc635562a61ef83ddd993e05a9071ec6467649aeccf6105b025c02fd4fddfbd55da4531354a37d3604df767a7a6cb0a858a337cc4f2a1af90f239e4230fc863311bfc79dfa3f8c77421fbf7bbeabcff6e4a17cf36868c7b091f999fa53e78f9d0b37f9d05345283521f3bc2b39ea1a5b4c6a6f381851e1c16576cf0f19fac40c129d1806ed43bc4246222e12b77c4659dfe0f101930e20fd948568c5197140f48235840ec0d8528de22f375ba35c340cc49db8e33dac8b9af46dfb7f3aa1e18c8c10154bc74c66a36badadb6caced045b64c563e3af28e943c5436879e03043f76345d53660220580bf2abef00373e5632516fdf0b22f28cbd1b49a457274768da507f442018d2c381e263c6cdd5c6975d7db2ec8c74923a85ed09a52544dd6c7866bd00d09719968c3b45b3b0fff398463a4d457e43956578d672850696a6e2632ccfb7b6f104b843c7f75e89f01ab0dfcaf86782d985f4a2843b71e4428d4eecb10963b6bf9dc417a72a60d6c19af0112ea59c3eb410c161cfe8b98fd9cb49d48b10163adc39dc4dc127d20ae5d7153ee6351abcbb58ccdacecf3e986fcdf153df86aa718944c8f16b59795e50712a14e3d867aa8269b7c3e691e1ffb85d70cc51cd8b704cc32343d989c3b5e5e4000f9f1b4e8c142eb8470560d7142498b27091074227a6ca5ff31308765f160e158e46e9681ce9f10c1e74bc463ee3ef7b4c0f1fe8d938382ad5729fd135f2963c53aa7cb51d184c1f6feee19aaa1184739726e1d3e03fbe23e30816c200f00aff88577cd108a0aa22d55e20dffa0de3a93c7e21b55a2a004a268e481b9de6212631b20d01b71850f4dcf0af1bdef003fafd1a8d2a74943ccd731729c819592f6dce6466c303c93079b6aefb19b84f035787ba1c03fe2de152af7d582da0b594f48ae3bdf656a37d26a63f69b40f06847899b7f973fd80c487c5abbe26084651e1d427e12d95f413b24af6d5d650f3e19e97e02585a6985ec693cd3e3057e7cea8812dd8b2ac7536a9714bcc2659fe555c26572bfeda952423f3d2ea6bb59ad74752a8084f896bd07daffacab41a7eca852d11872a07c403c15f36e619ddc4ebeb58cdf284b0c9b7b831646991c119a34e32627009e2c1b5f1b93700dcb209d0935527dcec24666cd990def496442fba70ee70d00fa178d0ad41ba0e1c7dacd00e0e9ed2a1d40bd4dedc2aec2a37bf49de903ace272e6385619019720fe20fd40d2ada3aa0f1adc99d5ef311b7d304783d891db8cb108241b3f750a96eccfc5b60218870da797321c60dfa3787fded90d2961e36d5b426215f5e2c2a35ce3f2dec64d4e4c961938830dd055db0a5503e581503adc55b8bdba212840f887968d2e4d405d08ed808e2906edf5d7f865d1168361fed366fbc743293604dddc5594fc7c6fe2a4d5e19183f0bd99243520d0be0962334782a4a9d7b775a01f99eabb8f0f252af7a7f18f524a8e27005e03b8fdac2d96b6e9fca9c6f8504338dc473098e6991654ebdb4c14ef755ad8ca9f5eee2472fc8945d467de1bc6c258f2a0bf87ddb02300cd0067800640aa57504796f0341a21799c18fa5085616e9946980c6163e06f78ba3f9385658f544fe9f8b892991cffe309135dc3b61b86f1183f2dc8841ad7c407ce7d04205cb88aebec635e20a0ec0d01f5c61f11e2608590873aae59300cb80747c51388233a70cfcde4351c5ce1399dc272fc7f322f7e003eba44940849b47a6545c6f040e6926d3535483242a9943dd5029336e8a6306ec59897d9f68beed7d5228ca2e3183221ebd777168ea516724709f653da0a8fb4a3fabb6da20d3aed74a23d5102b70fa16f4ab9329f47befbf17b9ca5ed7cdaa7846bf003f94663a45722d77baaccb4a44723fe871e212860e9ca7d4eb30e89a1651ae27599285a3f85258e75b7b471bdc1c8af3dc70773a863cf3b482cead727558abe01390e841342314433a612f40a6b53fccc1bfd482b273d0da78136ae25ed0349b19703096da711b82f653e41db2a8bca8faf4de55425f46773d077a432a933132c52c64ce194927d8dfde014045bf119de3f2f0a5aa1da108abed194f67104b4808047cc87456ff387cb733306038009e464f19010ab9df814677e1cf42b345c607b0b2e1da40529b1338d1c14c42293cb10224be47da000c9345d3800f60465e95acb3bdb6ad5830ca37b88dc2a02995a8ac3fffdfaaf308a5766fa3e6ba699faded4f96d6cdeedf96a171b745d34b6831a5a2e7f080d8ee881b0985ab73adc9f6ac8876ebd553727c5bd358a16a3455a2354be528c0a2f96e85fa4ed967dc474a2177cf540d62afa7dd6769f803d971ea176e1844be5dfc81798a1783c74e2c0b940119cde164207a9e6a7f11e8528869a4adbff6aa195d56eb9e40f5ec95f11e1e33796a2ea763b6e60e179875f4b2446ac87f0e9453c6bf421594576ca5792b5d5e816f94c50d56bbdf1c58d13e5ab98ce5b934a9f8904a4ee3af7255b5a012c8ef792652f4d718d248ce8cce2f8d33c21aa4e38f15b865037e6dba81abda040df5bd14eca57de4821c18b5b33e41718e21f5bf738cbaf39d8af66466b9e320c3793673b8a4eb52ca1b6892be1233dfa11e2e096405f7f467491806caa44e49dd8b552acbc953440bdd159bbe9a96fec20472897b72b88efa568692b72ded3e570d50092d61fed3eb49dba01650c8b3a743209c74167126131d3f5de9752a30eada97cc74673d7f237523684e353b9b130d3dec0a14eeade1a6875fe888d6d54cba8dcead339f2191eb0ca9bef9269a63c6b586aa4940bddcae0a2baedd7ee38322d7b2a962edd7ce465d21e606838d63d8a188a48c744b2e07a67872be6cdbdf040e8b2c63b8913eecb3768ecc247120a7ced58bbf97fc0a1f79a8941ca6cb8ea16e0d948b9e581baad76c1cd286d4a03c79f89a9e03c2628d61bd79bb2193535851fa9f96d9e837266a40dbd9a2d879eff09dda1869cb648f30e0bc1288bbdf9d202e459f29fb0af1498962eb12c1ab19d4900cc033b4292985cbe25b738ea9740a88e762c4d51ba01754a960f1e828db5b566450b73963132fa68b94ae037d1f3407c3a3795301519be0985378b3e8129e4994cb12dc310f074e8e1c7d4e411a4862f488ecd831033f290e2ea2535f59d19d3ba3f44e294f6633e34bba74ac7092d4fde6724375c6d143983ee3a71003da16d9d7636c35c10b940ec8f5e08e9d80dc719c317c15ae24404dcf2efc2348bbbd09935bb61c1615fcd51f95228d0127077530de47a08a9f376b7fa84a4904dd2e94f59b518ed827c23499d4c1d308efda778c30eed834a852105c61e6123b4a8131bf30da45ce58f998fe553fdb1b3f46615d7430b740dbce277c5007105cd30cdb6edb0e0faf0e750855082c5cd19475acc80e310d657335657b96097b3f2d24299430aa3db38b9e3174207f8cceb1d4a73b239886185296d02a2f5c32b0d01d7fb85df4f3fa3b2638cf676810226cc6b8800b2d499acb80405e20f9cd7876ee8ba0b82c184ee99d711e07550ece36e352969748b470b3bbb21e06961946efcded10859c55b66000036b72a81b201e865d51de5e9b916723d038408b777c26c96be564442759ef4159cf0933ff81de807a0beac4c547a7a5a75cacdcb19d7613ab2be8882f30d0bedc03ebbfd36a9914502f9624e83c4976a008a9717aa30a2b44c0ab7f4b1595e550913fe7470f1dbfd8f711467b57ab2f1c1cca0a7a940b4ffc5af9405a062e96bee6f8ac8f6cb004c42a258e8ec8cc7eeefd2a761271111f5299f4a4857e97dba054b0df67d33fa1a3f54da82511105b44085853c5c962e5efcd56925ba7f4c45ff39bab61ec25516c32971e68217609bc45527c8e3e1ff9149a8ea497963ba36dc6abf983549d94fffeab74a87e0d515be3cd23cdd5273baf6add47001069a358764018931f5bedadc0f7fce881217411829c6b5d34c519b03f00660a1dd1f9f50d72270a1f77d4d89c41ca80bef2e082d910fad6eebc44ba8cb317fcaeb733a4d1f38339e7c32a5319cbb52bba738f336dcf0ed5f4383e33710829bd83f5a58b73aa54947f47525afe03ba15917ffc8e89021d33ad23860c4b960e91300591c539af32cf90da8d923c74bfd3ae88ea5e553bedcae72bf68b82b94a380c7eedf4b8f3c6bec89d2a75e37cef650a93e74738a33e3edb669fe66c5ecec07c59fe1ee7c6cac16ab3f0e057ae862fa6151dab40282c5ea43cfe5739a6b300c75960dda86538ff8e045d3c9e93b063638571f41c2a98a1cb6e2bdc4f6fcdf23df7185478846fd11c0cb255722d73f3745ac86519864a60a294936ab7542f618eb7b7cda227aa866cf27debaf3fb53304391b1f47577c92e1cee29a37a4615b06abf366a9a4c2f25d4930cc883c258d6637084f1c5033cf94a7d7c5fa173a27b347e3885a460b58c940e26483338c602c0a20d831092dfb12f7741a5591fab81c4120deec0c00bb17f007788287eb9aea50db5f6ae6765236be8f724620638232fb54cce27652740447329ca415e6612879659ea49ea588375d7dc136819d0be4bef6ef78caf4c98612ee9b5798ffe54363f7eb1899330e004758d06b0155ad3297c7ffb99eda8d813b9b886bf4f19c9977fe2a065532a8b8d1a28205c340b7f1e334b0cef89070b611c5e6c41e38ad6c6426c7844112360be9e7d04c4fd38c7432387311b4427d2dd50be54725521c308cd20987e7e0c5d74b9e685a3b021d93442ccd4a3ca4c9e2a2b5e69453aef60da4dc720e27a41e1de3f6f461df0160517798fe3d21ee8a3a3e9f96333b09af4f8b69d198689c2ff98910294dedeb3ccb3f17c2530f289a4d5331bbabad98cd1583834a98bdb5fe3b42a445a510338b4bb85d3737c8200a47ae81f4b28184b902424f5c299c54fd7065a90cd71f9a16846e4bbfa5d5b87861a5f5c587af0f6452ad40af79aff557b2387fc54c4f9c0a12f65c6674c3e625e0e225978b2001e467c1fb1587710769d05e635eb130e3f9883b0c42fc2698e4de8fac2d3bb66889b9753a17b53381423e93bc6ec695122d22571683f9357efc0e45b8238e0da60b065af77a71784675a9f546d71eb0ccd2b5e8028b338e2411804d2ac5535585e459cc2710282af7cfe44809f113a1b7b0064edf39e8d131c11f233fc2225674158b1f4b7c4cd8c5bcf2600be1eae8552ea977d73f7c13df79c46f44277f3b8c83d8abdb873395805c2ced27f889366513709291cd9a1fa4ad177eb2e2627c599ff09459f54de61a51293cbbc2b07341fd729b8618f44e7422545d104338a7c3b9eda4e9609b2575e111e3c40339648378c0a3377d256d293d2c7e5ed5d8834cb6b59419a5390dca8233a2e0f3722de87c503737847540ad1ce47c8941171bc6a0aec9869fa45481b489e8f850a429e7b45ed2b8eb98baba73b7a3ffbea6ff5e862e9cc99a9dbcda4552c5970a845a427429a6bf1eecf0ccc04c5c8caf887f20cfe35bc22381a478f54a81b3f5320d97cb601dbdfd42cb4bec3a80f487c97a47202f25f628434b069806ad8144878d0aa034be8f2395923b4ae71b5227c9b6e09673ea1c8fe6809183c900ee916022316805db5711236ab9bb2b0b1ddebd90545bcf2adc0073b689d50e87d4441a83238c3dcd07133571bb180a38807ad9b6ba4f597c18393cf7cd86e6e62b974eba8b65dcb2254c70b85ababcc67afff3334ac0aed61743d9ebb7d9ea9318bfd93fb34700be19256462b010ab012c68132f3b2e60bd8250902c98a573c9229fd8d46937539a4e75466aff0ba6affe4f733ce51b2b90d5a36daff71ec3b2abec106dd6587737d53a918c7829cfeff0b90e34893b800ed9f809d43d24b93c4d7b69c67f0a97c7156a151b251b83c89cfa69b390415abac9278ad8a735d7ccae6f6f8fe276e7a5b6124d236f7409fbdceebb21784c83895ccbc99328c4eaac3cf6f8722040d76ad0679d9ffccb031e078330375c7fd52a9a9c7a93f6fa4ec8d3c834a31e8486ac3aaae099f8742ad1f6b592cb14411cd2b91985efff19f4c405743977ea1f67d2f4c5d9b9900f3605a97a66539ee33a5fb6059d58f714ad4514319707d95241c9542f7309e2604a8a25c90626ef46827d121a023233b11987dc8c0573f9fa2b70256a2ad57d96d10df87ecbd17a0be949787d214da9bd5f22683a0af0a78f84186e6f0d879ea63468ee6bf2049d5379b2e3fa9856ca820dd54fa806875582e1ba928c086b0581ffb5734799442da6dd301ebb87d0712dac6cdfe40715e9269f9ab131468fbfe13bb0d06194c114ccd744d6ef321fd9d8239c450779a2626bbe59de83a50b8a76e362a91be8212e296863ea27e735a98214d6a48176959c9dbbb0fd39cc36cf60fbf16f04661d65b6174c0e3e1f90d9c57a6a68765a1ebc7addef7c04dd41de538d0f192697d631a0f49853593d8adb82ffa444fe4c4c10ca2b2efe1cfcc05a668ce244b79f61d2a359b459edeb859fab0243b91dd6e0d9eb1f9a5a3a5c84da9a878af241f5fe54f09362dc8efdcd1b22be1ac0a469ec421cde6fe8a171a052d1c8ee534d77284bae88aa79653a6e478be057b1c5ea772bca08e67dea881d25ce9bb2536a7d3e16cad9e112f7bd7d96cb1779a9a1e7a014a154db14b643d48ff5361e05b4b0a9deaf4edd1dc94c8b663d58fe13e130a6f55f31df3cea7f6d057d68abd85058594a12cf477b07d52a2a0373431a5d47a94862df769617e9fd9fbf9b5ec63189438cc4d0c1bec105217757d643da7a68eb06e265223b3462e3339e9eebc5d6c6c146f75e87ee0ac4a9737e4e78641016823df0ae03bfae38fdc3c7e6cd87a64ea5afdb1c6b736dc8084886082cadcb7756b8a97ce5ad7b607ddb9cd582eafbde946cc318d367778a661de15c368c489c516525fcbc5faa976ba6af6e33097b28381c999aa23822a931ae19402ac2e8b449414290a03cd71ab4ee649caf7e3e870f2740fda3445e2a649dc707e2a01778a9348c2b9a7b7a101414cd69247c81f5d748cb7315f1ade23fc3af635c71535225d3e26ae21453e532e2e087b9431462ee4981849404448622c1452e2ba820d9b6138482eb21a3fb955033d55bcd0b4d949e5bc91031307c671e10c5b72782da7de7e26de2a0d401c1b54bba6d8c0b905958d4cf01f6edfe745b7ad1aa69d65e0bed924a7bdc7e48d79a27ba7909530290558a7251b36c20f53b4246586747af6bed3a8c21ea6f84a8cbf066ba56f7782ce86a431b6a286f45c37f2b8b03d55144410f934ea26f8378ca411f8720b2f6b68d6aa96ab863cb2d60519bbf5df8231d3cb0f377336c480c04faff45af53a4acf0cb19c26173869badd6108449600164ade7d421be9f7a14903ff362c5f7dbc904effdcdd1253fab980442e9afe14fe2c83a42fc12a1c0df8f80d06b2713f1fc1f340eb2824947f9abd96959250c2246cb5b71bae909b7bdf0d796ea4f986f94824ac713c7626179452d001d29c014398b6ea97fae4f8264e64fcb433ed2c75f8ae3cf470779d06a3cbb1ee7fcd75f337b974a18431a89175c060fab582807ab1ef6ab3d0a0983fa006cedbc713ad2cf66fac1dea7d8b276f0204cab532864b8c582daba46d4ff91c5e2e6008e50d763f7d49ee6b273cb0822d2dc42229736b2cab9e408c61175b48d8a51a1e69d92aaf247d9c5dae7ac8ae7e5b5d8e364eb634dc487da9044d7e4872a7bbb73de8e937cdf060e33cdb0c1b13730afca754e56253af85127b671ae18af6766fb1d41ea273b7a870708a2e616b4f64a61940740b97c7c2ee918c01eb99e1da2227605c18bc6575e1ae1f390f4e46995622a81bcfad0a67c04019c622ddccb603ee13704f7b2df68d44bcd4f4ce01fbd3e48e52fea637ba1d7658634ebcd2bac177d34c907a4339b3b2c64e65b8a73462eb72b442b1ae0d6b18f2cf402e481a7df7e19fec29fdaafabb9bca1129e273b31b1e31d0fdcfd9385a667d32022d5927538e41922a03900ee27960ac6b6cf7fa4ff78f20c3bb2f0350c51e40ede587fd8e981ce8e5f3015dd9dbcd4c153b6f2aa379cbead6146e9fa7492e138b272962614054ca892b5a2aa693d929e5b0edf584626d45fa5d9471e5c0597159668bfd743726b647dcc5d5b357aafd537ba64a69f77d553d9764a8e70d7a9bfb30f9d579d146968466d81826bc36d35bfd37103384950698890e754e0c929df139d61103851e833fcab82bd78ea3ec70dcddf5bbabb15403a66620a72f877cf175596ed39ee5a15a974e02aae026a2115c0816e30cfbece67e7c104897b4e5d0669ff5a44f89f47fb91dba2fbdae19a8d72e0d935a300f05718283a9a1963dd10dded0d79eb4bff7b9acb5b73f517d583822fdaa4335bfd74969bda41a5fafb745369076d2e3972bf98870a32eae6745bf6b44166c3d87160a970b5acb31e82443296dce63c7fed3990f8f1dbc20eaef483248935c7b12ec463494d0b2a8b7820487be3a86f0c5d3c70745f91f4b2a470a80b95d82de1fbf5b7f11a38e43b2d5cadb1cf71d1ac0f9af3ada4463752dbca779b87b5833ee87de4c32110758afa9b810c61c93e299c1c20608d3b29ac47c0c0253a3a4c81130e10c379c6cbcc47ee6c9348d4d53f839ffe8936e6a6bf364f19d77f4499dcf239b9c85d8978cac8c39b243dab6ef4fbb21c6a15d0aa075323f05448a2846870ec6c8963f8ae42c2955c4f62a5029fcf4842342833700a1c5665eb1fd215b7308b37b290f5e680c086a0a4559bd1f94329e50feac0c1672f15ae8230284cbeea8bfe51c6b7daefb05896eb835a90c405400426e8baeb2a816df3d839c3c9f863aab7e485a1bb518be680001adc6a3a22907f9dc821ea88d11421c05ea55aebeb7cbb7956baa46fa2e186ba57142d1eba3d64bd82baffed724fc828cdee8b3e9ae8ddda8cc39a37115bea71a68482bcd719499b15e8fb739c5a33efa1c694218b40fa08fea1c0ad2ad6c98fd5ebec47c08cc0a9ac83a913145eff0a1dbc744855172ada9c5be5ea8e9aaf435332487250ab720406b848eeea0521fd0949392880eea630cdb2be28663328e47b3daa2b0d23825f4b52026b172e4e303f97518edec63986100c9880769e5e1371ffb0bb7f20f87bb09d6a18b7f4a556b7b7385532e92d99d3e2f0d4f176e29703ff04ab00df672870a0f9fefb5af1151f780d3bad1a6662195b563b58b68f1266ed83e26917b5a6d31e6a642f13129a58d96f86a0661912cbf29a60b9528a26d5eda4e677daf1348cc0f3cb7eb3b959397f03be09149de080c46d9e8ce6856248121f0f88d284be3cddf24a631e4d9f57288902e233b504c9e215ee1ffd40ade1e8fc1d347fd4f96a1114169ff303e4e8a618bfbb876ab49dceb1fbcd6d4c6430f6b61d933a005253eac544eaca5e195967f17368033be594eac02ff4d9fd8d3704b5f60bad91e41d7845a25cad8fc3023580dc4c9d0b312163327cad8a0b4a469a4e010a23ab872d7c51a2f0069f92b31aac3834465320f04245677352dfa3973cf13c9145365894db114a33bba80fd967b2433469d7e5f660e295dec3318b8e4560496d3bc7d4fc7f84c56004baad73b00575f68acb21938e1dea0819e53421f63bc5c3b9a5003177277b007687ce69c6bbc58e801e7ca895ad86ecb9fe7a2c1dbddd60a5edb2c3d247a59186fe4359423943a219a2a5fc14136ae3d8df363783d2c0a2ff412158ab5bd3fdbb9ff17bec7af22275acdedecf9cd218e1a2123d2e4526903f329a44affa29e9726136ce440c74d38d904f4daa5d9c271c5fac3107834e2b4801e97bd2ab1b09834791eef3faafb63c77d656c18bafa5cb9540199ffbc964f00594ccbe3e7e3cd209cf360d07901b3fcc84a1134bb098c6411be64c496167e00e3500620aec6cbe1de2bfbbd121c2633788ed2b2d492d503de3650a6033846d0ff19a81b58b8a6007eed6987d1d30d4e024f20a658a9f2f5427d5d0f308bf70ec3ffe512c7eae703b05e28f706945e6434934d725475d60a5ba579fc551d2e700e99aba0fd0d04f1762f0d4bacf62422fd7eb7ec7412c16a4c970919827a24d5543e34156d25f665bcc5dbf92f52796611f7c9df88703863a5e462ff74abd5ad4d33613903f521e5881425ed49e557ae1010c726add8eff8bd3fd8dd463350f7edc2d002e55dd3927efb1356f3848e294b50269032cedc63ac501cca3d4be33f6c659627c3badbdb3adf1e0d4b4f7e74f887c2b15f555cef8526093a150e77daa5646973a3145a8466f4689988905a2dcd77fb7f0992f29991a13272336801a75bb229a91fd29a5ebd3a70287e9c9593fdf9896b6594266c23a613eebf959cb018dd0626f28d8d07a70cf9aad49dcb47b23defe817c8ecec2451c5fc0b7e5bc35288fb91f6ad4b8dcdc0faf7b40a12b8ccd2fedd29f7522fd84bca15a5d230777f8e639f4ad7ecbd81e82f710880dabc0c837297c8aaab1aa1618f5d78d37a56f7d96ca5378e9dda36ed2c97120ab7c372e8e069e2a6d8fbb80dd549e6350f464d06ee7490de203d558a29d4d4c7fc428e8ff77a716f27c62fbcd39065c6f6e138d6593c81579974274a5c7c52cc4a566b1ea81193e80dff86fcb1f833ef83eefd7791daab524695ae7f109129cab385f75b0651d0eadc090b49e2d4d9b384f49200c6fbe7d33681405cc2c8979898f4b31eda72020a423dcf905983e8ede67f11af6285cb9262876222cac18ba46a7b545fc19415776ae1ae5d2c1ea505dd9e09e58ccc484ed12c8866ddbc581cc15964586d249bc5d9af7ed4257d2eec27d6e5d5b3d6129f758cc566639b1119b0e40076db4e4dd1587fb471751d261701e5271fdacd48f316356c1bd4dbce9b1e63040ea4b9cc4bc29549d8e0123ddc805cc7b1e19d6a20f92c53f3785178dcb77740ce89dc64da52edbfa3c20e7db3eeab872a882c03c0dfe27da354e04819017ab9388351154bb984419f4a67cd4f778f35053b9299a6964fdbd84167a088f6f9b5aef2e741b8df382a9a495557a7746a7af70aabe8879f384cc5eb2033389569ef9e6b4639aef375e7f06ce90d97bc2d7c1e1ea1ee09a03c72780139a043e4cb7fd214357868caf31cc69505fcab51251fc43f85119bf908175ab8f830f9cf73e67ca321df5e822fdf13acffc7c4df17182ceca22ae982c28eb749ad279a8fc4bbd5e5194ac5e784797b5a93b0c7cf3e880a76f4b8a51b935a65865cf5c607a5508ee6bc4d7bd091442c5da1cd37a5e36416f5b7b177d01f78c629d4c83d9f6bf8476ef233491d699048b1ea176bb21675b0b7b31f4ad1a1f74ad479aa8d6ca51ea6c30cfe07f3edafe8e0535a25a42d0708461441eae38518418c4d88718f4a8cd07d05d4e57113a0b9a44b52a0016edb6b1380e7fa39e883cbadcdf72f3c5c1c19aea0216ab39711885f9b75dbf399c534983d8b298dd01687ad1b43cf7bf4bdce9bc0bdeed27815c62c875ec72670d4b28b692607925216dff46978f9e30ab6f6df24c69bc723b57be19d162f473c6864d06496073b6c776683b9ded2340dae07f3f83f7c5da71d9e5577a59dda87e68ba5aff97c3341362bd544192daf0bc613ce78f3601d5f27a259e5122ca4d80ba564752e066298f1209efb21a7f14423c48a154b7e350d79cf64c6d7044c8e9409d0327e3b41be6e0cec81ec968dffa1ee4f1e93a11fa47d3c3402a10a39997774561f22f4dcfaa9d1f4f4024142e40e6939237f8d209cf6ed932a26e7f8cc2dde2bd42d817be3130635c6c531f57481aafce5ce85b440c4eb2ff9369f1778689ef2fe787174b2f56ef083a27fb1dacdc8bda63e99469e15502ac9a400e239705f61961adc1647b3d92c7e1bbfd1e0243a64376d5c066c0458901227bab8504a327007d2e2bc0608012f48c4d112426f941ef70a1114ee44eda518b7f217f58ea498f8cc1494975aae12a51f9da0dfa7ba21fa1149cd86a8e134d5e86f531afa6a6c27d72f9fd011272f88f35c9680b6ad21238c6d67a77b321245fda279a3eb18d005713538a56a30b27e15d4c0c787883d3fcbae756dfc974eb960c0ab8fb039f7711d49ba1d5c23b884a0ff143c63e767550d97ccadd3b940050dfbf692907bcc6af6404c4572a560902d20340866f865417f9a91a0afa83283fe9a5e1414b101ed26e2a7e69900955152593c150e8423bf8f26b41537a3965b2d291dc0d63e2e54bc08282d4c02843de553051fdba4b46a7734ea47a6bdbee0827933eb27afa9923a4254b0708615171edb11d12bf1eef94386750109bc95a61d5394d55c92768460b5266e7ceb0cdcfed8eb1a79e0bc8450b0798b18fd7fbdff6d1cda6df1b196c0ae7dfada4f0827c8801f88a55f900aaff8e191323de3622e314778825cd1203f6fc198cd345dcda70a83bc45b0716257d65ff9fb1a6d20714341c7e35a151411b4471b0af2f1570c325cf063e276ff6f3303ef88e79a4dfed8ab7b0c2f271d4bc3738bd81967f8d2b4eac6f2d0d689eebb8eb4c8f8129673ad053c290878c08888e8a8f2c16f24ddb6fa7dcc2ae4165ffe27b4c50be2fc00410a3042affbc4bdb8f91b5252ff310f151036f903b715947cc6a02ff3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
