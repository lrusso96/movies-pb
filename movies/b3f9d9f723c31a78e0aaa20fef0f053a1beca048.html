<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7c62e68c04e3ced229f1464177c1625b30b6eca4f3ddd43e467681ba032b3a6000deb1f6b8fa1a8bf7f88fbd6927da8ae5682f1084519b732b3a528f4422f2e15c9f5965e97be9aed0171341e5ee56daa3796f42158c6d421aa24ae6a96dabacf0901198de2f6c3714c365a4300a011ce3771eca17e60f9de10f57c86a756b0a9fa325d03b32835ff35db1f39b0ea815c749645adb99358a1ad184b3e15131a47658c992e3e962ff422ac4e7fe9ad53fdd586aeb6adca02b08885706c59345420192215d04d58fd8a22a924943f9f4f96effa6854a2a3e8e5408e9ed1e5cc1dcd100f71e152da01323dab1c2a01b4936ff14632d6cd2d8a5b4fe1b6c4536c7fedbdb7e025c2d92272980d9dbf631bf2ebae3637ceec5f0c5495195490d22ebc3c683c52a0c5d3158c908be3b67aeed45e204169868e51f6d2ddc85343044a3216d0ff19f07fed3e6824e094edcb3190377cfb3fd17512524d3074f666b074527395f18acef0dd84afa9e2926ff8f6906d633f74f2a995dd56a394cf307493c5a5dd135456dee807dc2bd635f17105f75255297c3e1b42d21450919369af56e5fc7076fc7ac5e9a49e06792431d5e47e5a57d73222920423cacedd5eb9f23272631f6c5a51f0a9a625809a3f371c7a17817c8c245f624a81624d42c79488921f0e0ca3fdf53cafa3bd0e42ba8cb05c3f6af1e51b5e6948a5899241275596ba9cf603dd4e826e91c1f35b246b793039d07683cecc5a09d689cebd61ad8cd449e93dc441e1961d4a3029993bd810d06f652a806cd0fb60914b0c5fdb64d0c820fec6b406da36fe61116bcb85e43728461b55ab2c86c293a5bd8e139b21b3e3fcd784e24b26d09552fe47c029a72204aec5805457f949e23671d37886860d2e9ac83478a46abca44206ad87582f24eeb5507417b5154edf7b16ceace426cc864eb1e0fcf6a4830a157318fe47ebff95120e3582100ca2a65ac4eab85ec98dcbcbbc5a063b7cae8515a1a74f65bb371a5cb44a08c11510f43720de19f4ba7457bd3dcbf9990b89e585f150b551b002e9f2d50a50b460c20e7920e53d58499db5f78aebdd08d53deac8b0a5919377aaf878fd9f8db2cc24af892f286d24b0b929a7e243f29615631c44e429717f9c78598a7624c9c033d5399c90e4d4e03caaea8f93fb891534c9b80e1eafbc3e4af3d3b1bd1804e2585c93cd5c6de13b7c1e2bfb9ea77859667247317c0d0905974597abad88a4f1f0f3c3d8195a6d93f8b1bfd82f21ecf840257054f6bf9807ab865d7516c529421039ecf184ee49932e3c2ef526d1738a53fff11bb9e9a90b561a4bfd7a1c6062ff59d65499fa9338b46345ae459793bf10749fc10ba08b1d09ca3c2405831b1d8e967f6a6e02c71ff847a8f5e0e5eaa4f2dea798669320fc439bebbc5952e46322a847fef1c13c3131c38e5667b4983390fd47e89147f0e64d68cddd73a1710417e9a4ed45fd9d5a57f0d1fd35aee0c568e680896a3030430dd83f430919b8680aded356a135a72e26135ee1adfa43837eaedb026818f4dbb295ea0dc6a20f5eea8500cb8c5e948c2004a738b118ebdafc1824893667751e1f513163d4d14053d1060806c3be1ae69a44129153b9440761d612242d860fe1c2f4e5debee181856646ed2f3373cdabd67b7e1c2423d9604572f6d2ac764faba8da181ce8bda7d2d9e63177ce06158b26b7139fd2c060e6abac27c3d237fd719fc36b5fe7c4b880a46785b37bb564b712be1e88a56ff9330efb09d3fa97500abd00528c2b377c03cf15054363825a3c37266cf434fa2e93d5da9b53a061bd443f57a04784a9f5056b5fd78c175c2b1873880f5f15e7af7bc6ffe600ac9061ccd2d6a3e743ac0cf0619c3a210bf67682192498cbbc1d1a44ab819334878cefc2bcc90fe9fc99dad983d0411089e8a258f5656c33ff0567275ef81d6145e81a77c853f7a23e1c6b891581e68d00ba937ec753fef7f9f9de8243164ed699c505bb850f6ac1185e7090490a0242afdcfc5898c07d27e125a79eb2c7b356a00e0d60fd558019b5386f6a2ac20634c597ba9b275f3b5479f70fc784bca3c1020b080ede922abeb03c4ae24551be0c615fb6d8d2dad8dc04a3578274a020dd5e834808b524aff54ee8bdaab052c19d025603c1f5d869115442399c5e16e5cc188734d70e23796b9101a8a2062cd0b492d0a97fb9ddb7c1cca17b707572413f66a2a52f5d394c3defdc546ab9b44140b698f0268ed7e6c3e7d7655060d229bfedc61887b457df18679f3473adc78327f41c9963198e33364bf168d921c8b3dfc6f7d7ed9fc85be57bf87812d7c036295cfb08c312746161be9c3025475d697cb74169e55ea48220b5a55270e116527912ba3799dd97001173d0eb8914493a4fcfe3c11d9a9be7ccf8b3b8d36f7f8ce99ba8586600b5d615eac08bdcaa76b35d3d4d5d494125a69fa67ce2a1eca9d4dae6d523ca43adf2b78e51208e49b555f8da93f1c118893cc51965ca1be6a9d4653f444b3775694d181cb246515ccbfa38edd3adb024610a246bda32ea74b64db32d08e8e350f398f0c8707726cbc25d1299557689fe03336a0bbf9e5dd90716144ed4eeca28b203b018e9486fea61e57d6d61d412434d9491c4eee44bdb01360140fc618c8de2fbb3fcc826e0dea3ea084942f75369f1fe4aba6584297b2209cbf0f964f64566a4722f42a8aa7f1ad16d9bbeca83d559bc646dfad2c2de40433c90ed62acee5f101ee07377f1b9ce22daed2f0b2c8d63cf284fac6c89c52d6f23e0d9579eb1dfa55b97598e34c38aa757b89d20055241798620efc7e332c694cf69af91b562232b7eb8bb1279ad5f036db4e719fee835ba61c8f48dd416140580b207a6873e7ced8a25c3fca1cc4c44659a0df776ac6684452ac7d416279aae9d65ff740c94c07f3681fe56264c462f689d380f8cddc02c02aea0b7d8ce10b3dc4ce6fd60f63f4f9270274366f32627d995d5c1b27e5637d80a79833e6abb5df8681f779b31d747e9b6447ad2d366d9425fd398e87195a86e7b0ecfac5150ad63ee0ffa33d5aab7090f2796c5e2e3e1523d9e51bd9f5e2555bd83f72030dc39eb17afa0aec9244468a875930b338174f1f46d55a22a75cb5c4b283dfae14a74672aafdbee1cf27aed83a3cde887f62c56328e7e685c7a5d374017473db638432495a76cf1be9f59133b022d72e3244c0ab7e20bc7d557fe420e4fcce18abd11a541d748e7653442479e3f3b4ec74dde40b0c4b88e1b0ba2fba0b3f259824ad135098f5b0b0647f82f9c289fab4ae38711367674e97199884182c4570315b95a0b7d189da604bc0d04d999978085f8b153a5fd3fa84b117853e973bf2c657c57202cd4b062d66fda078c1dc80bc0c1831783aa301ef2e46a39657366b233fe0eb647653a5e99e2e5d3c8c1e30905e8281d91547f3661d865eb8f06c570df4c1a4f390159b67b20a0c54bfb1cab5b707674d4489a554708bf602c35d173641b374d353e6a0ecdf0a107ce51518d7643017b6e338fcdc767a12bae15a9538f442ed888e19d5d999d4380aef23ba37200fc8da6b1713fb9572bb0052ac711475c7aca5bf51e643a60703120610b0d6a13d3385ea0bec6eb8a7ff0f9de82b755f4e2ea5766d028843ea5ffcb21098314498ef3f3df58af47ad73167e352d5de6461dc842d209ede443f3dbe265e9cdbcc42fe47872e13401b300144343415b288354e0ae5316064df0ec343e8d821e0ad2459b54dc566a1b51b6ef1e9b0a01abe7f600370c156389a5eeb463d5675274f62f4d845af0ebb15b458df9cb99de90bf3ba17d7ba1eb8209785c1e0c06104139b91fc39cd37ce04e74b188469862883fca069a61e1208b42504882e5de0ee01931f143759ed60012cff1243e2f17afae5858ed3a0952d1f11e218e7a2b22fe96293fa4ab7bb8fe3366b7d3abbf6f88eae44270c9a6a2e5e958a29170a52c8bb9f74f403ad91caece16f600d66b0a4791e066a01200d1c1f7eec895d99804e89f02b4d0ad11282980789dd934692554353886e6527fbb674ae37ddb6409cbf4aba69d2af93c550dc70d813b0c05da9cbffbdf4b01125a6df75893ba259d921b2f7cb24eca040182095853d5aee92d9b083e170a680796e38ed79df0afb2e70f5e92ab4a1d3a24cec88195d9ac2460ef81bf964c4fcd9cbe70c32e2cb4423edba1b02e4d85d9727fc2f3bdefc720db7b9dbf833023a731cbd48f0e676fc53683d7a11ea54f3ecc8c866195482d902fbe987489ffd5b542ce0cccb755aad9278126fd069daaf917e82ce3d5bda90c699ce4ea38f464651589bf82de9789cf84783b48906d93259136e38e635c4f6d66450c62fd21fc42b6f46034a8ce21c40c5d8dc2aeed50ca4cf762f54764f006c3ba98acce7f02d1f0accbab1906af81322c176ff7d34db003da0a29ebf67e0e917f46087bde2bdaee3483a6cc10990dfe8025d58409acba439c68ac982748ed91909f3700359e71cc5858a4da6ecf440573a66eefb6b0b54193539c84cfb2188f84eac30c7bbd8a584745aa9765816353cf3f8380af6780679a376d6b8f81b27fa0ea856dd5641ed42690b56ecb43f71bd31b3aa3447045e9a737ee4c33ea3af8cc41fb13580969e3764962a24ea9015589628b4b3bdf55fe2ff6ae89a7df38f150a9102cb93ecc2259e35f4e53d6cc2a7f1e72636c785e866dd96e2ba07d1de5e1903d0ea6b0333c71cedbbe1a79304815670a923cd99f7d5ef925016c0251e062cf97e53054de894cdad95f08e9eabc45af79c915fbce04a6a136f4e5d136ff1ea927a16b09d69c1cf1bfd21c9d9785562288070cf8d157a6a6824076fd8e463019d945ec61d50154f9b36fd0d34c81308984e070a90b7afedcc28ca06c3f37c89014bf1c438508d7f870bc66bed0fd7b3fd6f0f8b4a2320615909f39cdebf7b098294e4947fa17768a4e0785ff59d202bf55d3a46fdfc520b88ac0869248aaa3b9bec9ff634302df5136035798dad4fb556f4b99807e2cc42d842a1b84e7582ea98ab6ce0426bfe024da9f4dab5377baefc92013ff99e890d28bb7d430633db03fa1a5806e27a7523ece6e6a7ffa61267a22d95c895359ca414954774c722b451167348931c35a297abfbfa60a3d1f821f445e503285cb992e5ff24f93e8dcc5c4d4ac79d6885c2d5e146e12a1a601440d5951a98d73072eaf7c3fe15159a7a071af0a2bd53498f91a17ee86e7126963eccfb4070dcd9fbc75032504625aa3f8fee69f1eb5cd780ae2ede9adbe89360d99c1a6d756acd894bf719ec3d96423398169d1d0aebf19edade6915321200e4f911cb44dc7829c34603e83ec32b63ebcbc520c0aeaeed24b85670e0fc07499c00874ce19f29209a9a07e40baee6230a197cd8eb1c72a8d5ed0d460b72da7e6d5606342b412a8a96bc1858eb4a33a05cdc56d25a957211d88c16a2316cfac40da69ff794ddafda099f9aba70b3d7e513eb3a9971aa80aed18b7d57ee0a26b9e02432235fbb8c59b7fec9ce7dd1260445c766aca2185af0a44b55ce6fdb08d281cf39d49beb585bd10bdfb871224b8040910f15c66d419beadf7803b871ea009d9e21f6ddc9c7ef0c04c1c403d0fa79830f9ddce3dabfd9eb91e00ddaca72a6a4a21d047e8b80ee481c1c33480585674c1c9d003b4ae8387c42101e2d6ce73a7d5ce446e92c353d80e893ee9df6b172d4c431cc711625a8001f466c4e8dd6800e63b471c23ed80c2ef35737bdd73a8aa269dd88b3546484c4ecba9f4cd9bc8370c5902b21f266dc89d6ca96af54868d456e3169b28e227e0a376af22b2e354568283569d19e6118b70e7d42e9cec9d0b70bd0c0416d067d701d0535147271f6c4320a09ae28db8c458d761c577e0bd49bb7b05833cb93fb691c23f7f7040db80744fc85c5482c91b34fad92d7b77418916f1b02adad9c4d5d1d890281b509d037e1e9015f19ff767d0c5de4cdadeba63770a0a7b7ff203103b554e716b6535557a42f67e7045e780373eb3959c7fec7f4b717c91d672ac64d3209227283e4b94737501ad34ddd882683479342aadf17affe5e125edfdcaae9b927c7f1df0f615f90c94cbc46d5ef81c2bd4e91254dc99a308a5933ca3286328ddb8aec995707a8a66d091248383b5da281c02ba2d13383a0a8a1236845fb6154654d182bd23373a525d65cda63ce15e1cfa22e65d0154b6c32b7eb5173a73119ab5c4837b3073178f93eaff1fdf85e0ab5c87a2098ec96778f1542984d676c947f96f01077ac7f7e370f749c4a740c93e4a821dd49f62323f31b71c40e5afb3f72aa8fa691c479bbced9721b7d1a4bead0cdd8d150d58a662e82d5219cfbf9210024276dc66d6ed87fc71b1f340304ba4cd849476ec386912a7bccfb74197f9d40a18c96d1724905ee29eae3c278b1837db027c86684730b54a50a6517c78f2e759488f9e2ce5156ec3ef45a27b08c2bf3818b0686a26e5e539f740df76195fb84cb31951f9b4a4a92f19a253ace3c6d235664f9c7276e181d68e46f2644eaa6c9c7c6a406add18b32623fc571c96468cf54e05ff2d42bc118575cc726ad32500a5e92cc314ecdabe534178401422973854469daf5cc87ebf196bb3d6512c0e16aecd27f0446fc06327edb927f6c30d6ea9ba47f5bcdb9bee51f2e5295d74c6a469292622fcbdcafe8c83f9c285b488b408020542ab3a4f71e78b7a04812614c33661b5293861b93038f7a088e0f6e58ad3a06d2974395f766d0594dba32d748d9994429dc89ae873d189e50c92c0db4d7a6ee8da4036e0d1cd98c34f087b2c4817f3dc61084b567641213936ef79698a2767b58b39f012a9846ae123436bbd989648daddf5606a694f1cef3192457d2fbab4fdeef4be2012d84d3c83d499bc59b2ef4558a5de4517055a1ad45c5d94dfe3554ed8e04313556bef1aa5b247a473c2564dfe10e50c1f9963db304d81cbfaaeb94f2f0f5ff40e9d9a7f665c5f85ad8e5d30d0cdf86375bd06cf21f0ec94c4bd9225543f501de6d20fabc48029d727b7a9972f2633d57d7ec0c2374fc5bd5c90e0faa254ae92d9967463c8d08fc4c5ca0ba82ab234b373a6014bbac47e0b7f6ed93f647e83a6ab04ed100760de0852f932537e5e1b313008b5e4ded59960afd89479e085a7cdc3bc07a36ba0d689a7c81d6b13a154b9186e8175d4ee865be8660d573390ef1efb56b9ed2906c7bcc7efcb37e0fcfb99b8f3295a9a29f70320297e68c6002dd48ddf27aca12254ddd56dc6bf30c7a0ea826607c3d257d5e5d2249695905da64fa4ec6bf434957ca4ee86bc3c5a1146f86198c30b8e091159bf60490a897a045b47d5d78dbef110f90c5b813defea180fef0443891abeb421ddc9f8aaaed67cb03f9a31b44b10d8296201acef156a916bdd9e969f6c661d059db6008f084cd25380f10dbb684005d976624bfc26af2d37b98bd884a01943c6c78ca9c4ec55702fed0d57857bed28f1eb32de498a382db858310597ae50ded4825ab63bd402e43d9f0a167c4e7e887ce29a3499e2db19aa15c113a14c1fd83c679d59a67843aff149883847ca9292d6c744fdbadc3ea9fe059c0fa23f9caa7b9a86583797da7c88b8b05051032b535f1978389ec6d8dd292e16583a49c883365daabfa4151adf95c2e6502e7e4e4be685533ce8462831d3e4c37bfccb37587875433e493a3216baee537e5704b3f676749cf0568ccfae34bd0445fd5de49b37639b9a911991efb65fb3d97615c1d7b2e8d966afe1b093fbab4dcbb73f4fdd38024afb3b55e65e245113080933ee6a23507c304d1fdf1b68c388e18a8cc2c89b3ee7290a078d0dccbe479d4c9ba7db7678cacc91f891d27b9a13cac78139019d56611f4cb3ea7d562139ac9f5b5880757004af5da8684b6975e6ac9ef39e6ee50a7d75cd0f82fd35829e06131b27542bfb75f556140ae734426afd5f9e515f0a60be671df4bc5fe9e9ea48b051f6d7833c99b8f78c80853bac8553c77eea77ac1ab80093473dda5b0b1dc59172d7fb64124d3f9a7e9106f1c1d31c4c1cee17e909f2299eea2024f19c4acebc5d612a8a9fb548c23f30bcfe669dcbe9df729d9b67b7dd492208f49111050d83ae05bb970cfb8e4b754e60f73c6ffe5abfd55d40f6dde70a22f887ffd80da7462514cb9b1effe29a56a002596383fb68c6c22c68440bc3724b7ee2473d441bc88fad559d652c24fda05171eb1d19f6a74f29a73b335d5546422b1772346bfa6ded3a36ed7dcaf493135813260bd729b236a48db15de122d56daa5fa6d09f70d939c72bfca1f1140301c1ef6b37ae458df085671e13b79f3b04e5df353b41065802c987120b87aa5f43ad6535e5019873ca3b37397a899ddd22f3cf1bc5e473c77a35d7036a35833e3bcecb1f6ba28997408d59fd5f7bbbf87a4851c46406d09bc349091bf48fb8d71ed75fae24d4b61d9da69b3184f0d739436345b93f400b9dace6e18a124961f40e9a1bb2c9ae9e6df881c53d720c7cb249a17d686f27e9ae1b7cdb262356a6a3dee1699bf531f0af250c2b46f06b0bf8e6cf75d95995808a6118cc94452d5db40af1736f55547653e1b36e02d42be0eff57f5b65ceafab0bbe4e58a7b81cab33aa219e6c123fa26d0bd1a218c2a40c349da05226696c5e125e00e76b4a6931cc9f30c97bcf9cebea323638dd6c95a9c5280bb84756edec31f346ef03bd263c0056aa23edd4947a5c2ac0e26d3f0d95ae193b1a751f7e446e60a5b03d512196f2efee52d696f2762818f7bb426424f3ee3a8920febc9b8a78b731b128e6d6b65d7f047750b03b2f106b7d123c81c1ee0e831404349840eb949ed2543a3cb0b520e28f6bdbf6543d2a0d19db8482c6ca7445c566b49262c27e838deb4c00e306001116830dc30afda28cbf04ad7e0d7711eab49233eaae8155852360865912e3a456bbece40aeb890bbfb871d63ce180b3b4122653a7c0101ee48e3ed6051f3856ca9b2b80ab6be72784f992d4178ded2677e0487be37d0378786aa32e4d63b36524ac257c5022dd37dc795be7207e19c5920e0dbcba01d9110f9421a2f0e1cfcc2b99f2aac634d43ffcf75fdc022c317701c688bb51e2d3841a9395e6133e21f8b15bf9a3d97efa5f42d1432745358d4b999c18d2dc25f6638e2516b14bd437ded323ae9a2b14932fe90967fda8e42868835f5b776e10232b4f8d66b553329e1e70b6e0c59c69485610653df39a610866a532bcf56e16c259a23b96c1908fab70adb4d787eb3152a533b301b7d5ebbdd2974ee54e55cf3afbbda8e87298aec680542c32985a23ce93354d795dfb65911b7cfb59e0957639b7287f9cc4f47b732aa9da9bdde6acf86c9104f468b222eb687dfe26e2a110be59ba84db46c4f70a3c062d5383fff872ac4b66a9b7ef6b6970ceba72d73bfd9f99b21ffbf6a694384d04ee7efb8018bd0ea70c84173bd5715ac501e50d216321b74281941431768730f8e18a70cddfe1793979f86c60ea22f8c1c5aafce11065f6acab552ac2459c8811fb68621fafc07034ec21f77b2bc6829c6d95adebf31c58fd55e7ba72c7e0019c1b85d59f6bcc1cc67dc7bbc58482cd7952dd2d7ae9a977181be94f5bc39269f337391e2b5d906a9b732eb839d1ffd2ee6c9cc09c1ebad07987e5b12a75621000788314c7bd3bcbbff770492851eb3f5fffef60eaaf9ad63c26e1fe8316363643f15e83ecb0fdca97236cf7d295e687e455915517e3769bb01d975bb3a6e69e07da14b01e17fc253e4fe2ea798768e33de53acb4c5e5729f24704c86f6f4145f58e5d9ec4db094e7fbefebe89ce337e0693b9a238eeb128ba6df68d8ceb7c244f12511fe2eaa213cc50ff2d8426134b25717dc5ca7350031fec4cfbeb6d79fc9300547b9f80ac336f1ed2dab50efdf9bf680bee79be0f3ebaac7fbc7f0f805c2258bead23bd2397bd0d5cd4ae5b0eaaa7f9511071331f7a3a8bc209d6155245389066406614bb3cdfc1884a71fa6fcea37690c29750938f7b6f939021eabc5c6ffa595766ee1722b7ee22ab8bd96d1905aafb01458cb3a447952d0a07dc313107d5e39db69cdc4f374ac67364716612724a9abd55b52c4c7ae0c59a6de8cf3f0360f629a731645a52a02d1181c61ebc3d6640a40dfbb5deab9e811a3baa689f3d0e5e3e60031022de8b104f000655a196f13059bb9d80bfc2f1a002c14940c8268543d075fb3a08fde459debeb4c4baf5a4b7bf6f3e6ed37f8d69603d0d0bdaa09e08d95cc0e1c5183be763c81e8fbeadae81286079a520fcf173d4a6a83a910f0a65869adbeae9217deeeb5432017e94ebf2ef5952d64aacad6e498f997d6c098eaadbbc464b82dad09061ad43c30f52d28a7de62ec897683254233f4035b39760d7a24be7734f0e160b257b08be51982146f7363804f14e915936b6dbe7ea0904c1bd4d3de1dadf72f6c76f2ef50868a27231824ad050416b2ef50d67004ff24b103ce0158f9048f0e3e6419582b752fcf469556a5134aba2c68fa64c0602dfceed1bf723eba3e564a87a594508dde4279cdbba85016b169895852ef82a1c52bccd92eda5e37f9f3aec54d8663953040a85513a4f31f3c808fde3c53ba94fe6509ed0d4837be048a03230686dd47c4aa059132c27ffb8cbb57e3ca25169c026d8cde696bd298e5c57bdd5e2deb4f7fb19fa0d4faed7f3d55e6f9844fec69fb15a3329257151de64506c4670f3d842267fee418117611eb058fec675d0687f78a32e5c9c106f661987192cae64ca363d2573e100c8dca60ece698dcfb9e6e92fa939afa04d3e10fcae6447f849845273ffe28dc5daef43162400edb28b010e76b2f6ee43255d8102e09a775ecd27df7b84228f728539d7379168156c2d459eb98dbf75669beefdb318c2df802e0a8829af14940cfa281f2e68419cf3b8e6dc2d7cc8ebc7485f738d7821d7b55270172c5691894a0599a056f7639290483f2adef3c39699755f5f940037d77ebfbaf67ce4dab75955cf08647e656bcd34e5d86c0f386f6a409049cafdbd33a93c14333dfdba44a323af0d7aec5622aa230bd54f6cbfbfe3370a0e085793ce7c14f1a6a4aeda6923e2b8cfa9d2f0e42c37dc9b3aa4a676f1908107b2ca98bcaf13e2e3d5d834a52df479772cd5162031b320b9aa8ea10279114b742ec602f82376bc8ae2bf1001d117bee1e2c2cb9dff1886de33614c6178132f6929b6cbdabc14751dcb95dc799944e19195e3d5055c67ac537a417f02cac3550ef12007e12e2fbdd9f9eacf371948a82dc1bb56b7b215c74419bfef1aed9e491ea17c084db2c76594b51f00358029d80db3059ec3b794afce87033d7e2e6259348621e784bca6923e738cb688043b3002b29c6051b3b09a0e1b0da93246e31774250407d7e95bba986bebe98227b7b490bd1e4a61b556da388788842dc601371b50f96676d943bd89841a5dcab6f523bb412704f1f30360efe55d06c1548148895bdf6ce3b1ba82e2d1f157c3fdf222f18fb63c859412b6861c3414b265f1fee85962cc726c62b0e0d4527891ebe8279d9ca5c86ab7ce77872760161964d2b573de86daa6c2e3728f7e316f73d02f6fa4bba50920059c0971c086088afa7f2e2ffa09967f2aad3e16181fad626946076b83681e55f9c6c98f1f5d9b643c8f25b3705e0120de001c9cc5dd43a8c529629960d5abda9b04951156a6e8f5c65b0702f335a7e76b0de76d830c10f58c57f06270dccbd556cf6747d17590a39986e683b42814b337c6759d2bca3f121732f7fdc40e9c863632e5ee3c66cc2b40a229befd4b414d39092d99126720d6050da5e293a84adee6a82ab58d57432b49c1d1d939da8e7e712bd34b3f4da914a044f093a16c43ee09afd9d28d26a909c50775f0b578694b1123fa501b311e61dd7ef78286848a7335eba5168649111074366865551b5a491826d3dcdacc4685f8f18e21f416c1758edb38ac08751a6948942cb02ca92d79017b4395af327b367505c3975c236f1f3f9910a81032122e5e89c8859e6f0c42abbdf85ba2fde60358f12d1d3401d05d96845cf689027510dce1e3431c29d5a965c150ce78028d87c8dc6cbc8933d4a65ffffb85c26ac2c5638ca0c6d65bedd765de49ddc3af53c2589724860aa3af8c105f57896ad0d778323022503dcd3181c4652418e7897c943aa4779f8efb29c71377ca7cf263aee631fed07c886eedecdf3295d78dc473dc9cdeab699c1c6a6ab6275269fab142e1c884bc1b8fbfebb1614f58c0441e5caf3e920975413909c5cc97b45cb8c8c741af234c606037725e41a1dc83ded129f0e086335e586a5ddd66e7a12041261bd2db88990f1a45102022efd94442deb4c2d68919c1e66da5cfb2cf7261046390489c66972d8e609bd573a5f474affcec9fd7d98230e30532067fe61906478a1dc973f2cf4c47020557cde780fa82d79af402520279bc5c79aa31e9d45ab81ca4d38d866adfe9f60b25d57b1f5d3e427b343ba6f0ae91a7975c5fab4ee0c7c2efbfdcc7d5a905dd9361219506ee4cefbcf6c3924a0a1fef18062fa876cc29f952d5d42172f139d66934373a3803872205e4a7c95cd0a8613629208f309d359eb9973bf63945cf7f79d7eba58ee198ca1ce831a8adecac646afe6f72a99718609848981dbd19fc363dfef3b3e1c4bcecd09c40f64e48f4a2c297aeb47f0d39e6e1a924644030e825edc296f0549e89e176fd43cada3c391420757d8c28aea48d74808b110f253101925758fb4a113a65b2f70e75b98df7a57057647c55f4a34945592d0506917a4bff732949348165f11b4541246def3d3b7b472020f1b8e8f9e4df13fce0e32334b0b71e30b5b913ce5ef2fe84b4d17789faefeacce95f4f2df7e6234d2f30c1088519fd82c03f76b6735a1b6e065d21f15a12855b6fe2621b6c8c3f8075f608110ecdbed2b3d78","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
