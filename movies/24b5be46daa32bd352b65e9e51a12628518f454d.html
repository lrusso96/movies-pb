<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9aa3097c6b99617a6824122a8845eb32c5d8f3661a4dd501b2258eb7db9cc8547ac52b8f33e3e62ff01baea4a85733cfd18ce0d3a818fbc19a3404fe9e3dc1bf83afbcc7be4e77d0a31a144b22d993bee081f1df8d0938242ac9c53d8416a8806795525d535fb2103421c07d542eebe3dae8fb9b195e0cbda8fca9b76832b4e2e981647a5b3240c41a96444bf38c28bff11e8a55fcabe1926251a880ffb10aa11c1b8c558ee3de11d3dca524b81c616ea4e2300a689e42692c1e788ad90a42c95a1198a09465fdd09502b6fb4422474329de1fb0da7301cbd910c9c794259a06cddd6351cb9b0a6c42e65e888b402839bb993b4cf7c0caf2df62aa4d99ecc80c795608e1ba95e027f223fadafdf06c0119c0fe17d9b4004ac012620704b46cb6227f6652fe9582873ad8863e2d23ab6d03be5b45e9bd75ce89685be3d484f9aba5b1fe727f8fa370e4911b24068889659c028d904f30536c26746540c1fd679ceb480e14e28905bab8c779b67fb42881333f1ad2546c853a81bd6d711050ef5ab5359e34713c34759c6a06648bd0ab0add9236498cf3e7a88d21d3f9a3db41f85502e2cb876c36d726c369d9700e30b9bcb1ed32fadcb21aa30087f49decef34e8bbd11cb298ce9a80ef8e3b41bef0ee7cb4fbbc41e74e7f69473ab1394ef5e583877eb91872a9106fbfa1fb0bc46ac9824b301c5418606aadafaca173dbcf539f2f50b6b0a89a8c834c34377a97f67e48b675e378d681571e9bf0a31c886c2305328a5a384afaa3ad2da6361f8169ab8cd0745b9777b08e809b881a98a0bf27cf1ad2facec9e6df759bbebb6f18b27533e56bb87bdcc82b5759ae4971ecfcaa05f15260753b8371307ab874eef7c88bd498ca96935b0502b59b11e5d7905f16a6fa488e400b5a319a60d25b939f5a05abc65e6b8a050fa0aed6a2b32c599959c148efad2ef8e147fbdae2d05dcd81133b59504f75c98a395803f5337b70b298af7d63df0854c96f17576b0ae477440e655a5b11c043f221417d334fb012b09d2e95435a6753b5305335e53e43cc68a756bf074fbf88167795c8dc53677cdf1d85d7180e4f206bc021e9e36f4af102b3d136845b6482ee1b5e4554db25f14a0d7ce8e8818489d9a43626ac5da376e9408a997589c2f6348f7c6f5cee816f1b622ae078d91378b3bfe6cf4e581c06b1a5888fd0dd5b444f4bbf6a57afa9c8369fe1f2abac64c2e9f0e6d026298076db04500e207ba58c50aab55c05205b700c48d86ae543d64c31a238eeb95298621a100103defc05d90fdbbc0f843fc7fc717b6d80666fb32a26dcca2100f62e56e8f782e591bb63816696d6c13d1b8f30d81cca662d7de336c1b1529dcbfa059087bb34a32cb5162e66b54cbfeb548619f49dabb3cdd533bd14f61140b6785fca977cdfe3d4ec1e1b925a512e78889d7d7918761e2baab0b8ced4d17f6d26ae14526efba0e603c112218c529d738ffc03da9c7afd94cadfe16d7b3f4ccef49c9834fa34539729c8b32e8e5e7f795b856c314190be3dd13a69c22292b4b71a1609889c9538a086f4c56ef5f2b54bbecebd5e7b695102d73b4c68d54509a7335a174b4a12bc5f6a329331ab04a1e4ab462fafee21ff2d74fe3f7060d82f9a26bb1bed03e638a9cd5978dc007c63f631e3dc521db26a0e28be4b48351641068e1884b9a03290b984dfad616613c261fa1ea595f124a7fdb95cb4ec98c765ed843a45cc913b519163558a630d3f4968f76010c52dc234bf034241ae95be77ef54fbda7fead7b582ee949fd865de1cca665f7363618c123d59ccd6d48d6d06dc3f6251e1fb2c14565382320969d542ff4215a8abe0b822df35d77457208cfb21bf3aac3a08f3a5971f2892467c813986abdc27a7277546babf0ce17a3f3515def4356e8c941b7fd20305f15e349bd78a6e66c8399348d7a7216547ee27ea1b864a320d839c1bab398978f9bb79af68236eaf76a2c452e580ad68334d353dc7ad22223bef49a578e3f95cdb87233fecc17f98829a566169f11757821a4b2df99926e49758cbf5e4ca8b221d3a2b8fed756a709da93a96219e640dd187781d9b6e7946c0aa50357062a51792b80adcee44bcd0e4fb89f26e939ea1faedc17409836b740d9ad88f351640ccc4bdb566373da383cdbe36185269246965a02dd73c77196d8b20e7a0cb36a43824f8093fd3df018e5528a0b463f8ae04ef00b3177da0d884ba588dc6a8110bce5ae7a26b11f4f39504ee000faa9aa40ef2fc5ac881f0c4472387151806de613e1164285e0556ab5c411f6b2cf7d6f4d454a5236ad67f3a5e85d2a877e350ef2f64a8e5faeb1e559642f05484827127dbd3d0e51095ecfb2bcd8a286c1556689d5e6f7938ed15a8b511ca6505ae223edb9052cd75f0528e8aa9cbb58b2669f87c16f2e45383c12bf6278a6fd2f4ffddc1eef3b0684034783ac40e8db22422a836b525ca2375949945f8950eb32adbc42fb18abd27489bdaba963e7f0bc017c24ee8e299052c49409fd40a822ebb6c0b820c23d8891ebb406b421ab7811fffe9e3c1c3a6f0115bef72e9353b128bad460e5723c5100cf748b823d2f0f3db57543a55c85bde3bb41b7947dfe22e82f5ad645a9df46a5ec28ba21a893bc2621e2128cb5fda603f0e5c084e5d658e4413289d60b084e7dd2b28a0e4d1ceb2a9c13151b5a7e6ee90a259e9979538bdce208fe4d9a1ffc42814d26ffe35b31aafdbdf62d70275470344b830600523fb1fbfebd3007d31f9531756076bbc5e89e3d059458653e7381b8b5c5786838c25778bacafe9dcd238bcffb3d628adf88b88cd1348aa9d24cfd06f936963b7cee18ee8e59b12d126e99d920c3cb89c1a9a95176fbd0b50628925d3d5c1a2e7225f778f95972807ce499ef8d52c85f39978c68f272bea8beb660477ad69443016a35a8e22ab8bfc0388984410a88b913ce18808fbc5ecc2a107d03d9a93177c18abea1a7756755edb1081e9bd49ec6a7aba4de6e9de77dcbc46e2386628272346ebd80e7371e4a8d638e88a1a7a2bde1448d2c759e6079923ff1de0d05098c70deeb45de0e496d39943650e41fb936e930e007f6586e79ddb447d7f26baa64dbe83dfd0f720855ab0493d4b9d239a914a1487f4a5300154d541d52b99516c3db708387ae65f3db0d5427e54469aec769c520d4488ae1c219b3504b688dcd4262aea29f9da178bf280526b356da8fc8e61917503096cb86d484458058a4abdaab6ffee58cd8b715e2f58487db8efbf383a7239a2e79ed58fde152f9c8df6a6320cb3430579d3d2b6e19d8c103cbd9826fe5bca24c707d1eee5b1daa0940f78d51c5074269d231d965e885bbd5673612a2c9dbfa16d51175f482570d99bc29156c429e3e7897dd159841b0b3a35665d02c704de747ca90bf950ec85a815f588b33e8e9528a9b52285d0339b0f59f2ee6013db4dd5df14dc1abd420b9433c2b0ba32452fe1debc1e728418e1ddf10704bdc76f7334eeded5a01c3ccc13c72e5f057c19700b79ed17ecb5f0732476fc3852d05f67af15855a7beba9265138cc7315207c4f8178571d699614892c51df7862e03943186565ea588a36b302d064da5907f43f4f3efbd661b652c3fafe2bd2722a4068b9b18472ef98166847628e791d99c08cacc1ed0be4652759b2bdcd12bd93f470c8a4d5bccd1060f4c060fd69a88de419210e4d8fbcdd4386b7a61d037d0a42df640c3314bdb96de333235f5f4a512a3080fe43e230d87d4d3c4ddcf6979c5d5705fa087ba6b27443a0eb0f9fb90c4ff13c6238c537f5d1567cf18b87d206b9afaeaae23ccfd0a3454905e1492409d140c00c1eccae1ea9fa78c2d28b6074ee1b08fdbbd6026406d06f3ea324dc6554a8ff828e778de1d735bff51b5a9a1985fc9429dc82f932e2a47de4d86798676c872f7d64eaafdf62a045c284e739560b7ecce5a41ed80793a8592e3fa82237021f7d0ba1a97a55fdbdce38e5a98bfc39843c71a4e900fcb8ef45ce399061d70630ca480daf183b8d4355415cceb8016fb930d97836f789e722c4c5e647ed13f3a51a68dca09e7c6ccb49f9062b631968c571107d0abf4b6634b8026a1b6fbd5da1ede84c8cc7a63b10bdd498c71aaeffd6689f5066326208e63bcf0bb2f0f05a871178792447a1e80b8b36551bca103295cf806e8d4c96e0ff4d56d8184d7073bc414266db4e95b757add7142cdf2de44ab814c7897869670b56e841202b9e51ace03856182f8c2f75cf1849ab8c5aa4f29961504f81091b16c5cd080eca19aca9fad84a0690e0691b09af2a3a4574ccc4da83c5ed59f26dd9f27f737b74ddefa05497ff3138a905a844b3020878df41e77de3f37bd1e1bf4e96425b892bca9c743e5f1172a1126d9c95dc4d505284270da22085b58dc63d3d91ededa9ba31f5ea3c4e2ccf31c2e2dfce98bb1fd4fd9b6a5c5516d2119effaf541427cad3e47b7ea27aa2caba7a6c3e63b4f1f59170b22e3533843e04ce8ee44d5e09b94814c4e10c7135ba1ac86ee21f6c95b72f2c3c6d8725692125ffac56b0c437b76a1ad15e0b4b6daef93543db48c5dc956c82590c4c4a6cb4afd21161e1c464e34a3e231278dc9fd423d8dc5f9ec95e772510d39a1096268c9adadf5efbaec8779e97c6da5b3a1cc14e6a5d70d8065e87170bd44b3fa3d490f3c2c497d21796ac96bc00c5330e915b592e2ce33195748b3a8839288c6200888a495f7aa9449eb6f9459ce50510290e3163f8aa93d4b61778c247e92cf11c1b01b9580e1436e5c7047f37996462dba4a4eece9b7c7697790a57ae655cfe939cef2bbc3e5adec61e88c701a94dd2f006e598f1a14dd0aeb761908de92b15338dc0cbc7d17f457f84cc92b7bc779d4f006d0a203e9fdb70f8b136f4a8b667411dc10f3e126571c4e4e4556ebae9acdb14668567772c2e2502ac78b73886220365e10c004a6303b7a65d55214c15e4b41af2fbbe1d09bca1b178234ecb70d61f3021201b908c8b7b02b31ec36b336bc381e34031794bad6e701bbedab4fb8a0a7060c25a5d58581ed1222ddfbcbee3f124c1c6ad1ccd219e6b04721e952bdfd0c4a6511ae30a29022dbc9152255470d2201104c14f80c50a83a7d5b53713c9b28b4606710d6035ab9d076f17873b27063bac32d7b575d1e4cc1ab57df62ae5b4b2dab975dc8b583649ced257ec1469458e1237005e0bcf679e67cd2f1dd7e9e708994fb60fa4ec91fc496039b47ae62ee80430007fb72632618c1ef8815079d9c11429b179412fde676b4364be6c808983a8925d91304e2e40c4b6c070fd536e70e44df61a6cf339cab053c3d748dbc54e76b3fcc412795867809c99641c1999b7d488dd0f0d2baf4224711865518861945e10e8d422cc111431d16a8386440eee35fbc662da6b587464b90d8ddd9e4bd843b636ef0289f28fd91128ddcb56328aa1ed9237328ab1f408097bb4ffb0e37ad68f6f8e65e85f14696d657f55ee174ec17c4c1f15ad24c70bafe7dfcc9cb0831fe0398a3a316475983025a9c365862a2db2db4a5e2a410904b8f87542c953712920492ca0ab784b2ff467de91fed459d8ac78c100d2ddb7079f555ffe2e4ac7be4b8acddc093f86e4e1b07761ba57b70552a4feb39f903893a31f087ccf4b9659ade283bad8636cac77e6c5df0b7fd17c41835c53023a3a4f9ecb789646a60bc7b5c5764ecc0d5677cd8516d696ce29c20aa82d3b1b3b5f7b8f0972feadadc3a15588eeedf3b9537ef9f8fae61ca0b19ae75fea972c3023b00c05ce53c15681d4cd355186aeae4737fcf4daaf94b4ee7ef6c9789d41eb58b014167072199ebd9d281c155a5832b17af447f120419e3ccbe133e6aab458a10d7a019baccf0cb5097da48ce95054da82d7741c2f44f013f7be77088294dc8f267f182d483b7200055eeed4af87cb816712fa0ade1506ed0e13b409df7b935af6462cf87a71ad9898b52f347bce5d8ccabfa44134d519b9f114ca07ca862e8cfdf515ea89dfe5f01d4ed4b7aa71d16a8320c9f11f4e859996798eeda6e212dd2e1482ca14254d8ceb1678629dd41c6762a59e8d26a87a9bdb1615b086c7a7e6aab303e949eb1209b06020367d494fae2cc51d4bd3c507e366af5d04b1bdd0fdba99c8a3baa6ddfcec80fdf07f201bb1028c46b320a5d7e3640d3d102f658ecc29896fd7a9d2c366c7e79a27f278f4ffc3df58bd638e36e1d95eaf925723bdd45276a8f589269b8a6409a4466a4f9a6e371c1ca17d759d980d99052c359595519d730f36d7efcffbf1ff1af7cb25bd396b6aa2c969774c4ea3380d2c459c924a464ea92bc86b3294974e7016adc4ad20b5a85e775580d3f6d24aa06c8a97a2bb02c8aa2e17417b84da16514175cee5d9095d62746916c264fa43bbc487695bb32884c4c151513f660dcb1992ab414b85aa991af1d344197caf4295d0784931b07a47a2b18d2f4df5a27d9147a50a124cc2ea979f0ba3193c8bd28e1d119dab61be99c5306814aab524991be0519642f8700c65a24938f8f03f72dbdafa28079b52fb4b2978587da486f5c59ddc6c9d8a33075fa446403583fb5cc34ccf032b064146262507ab5eec0c67e7554680f02b17a675b5e786261b4819ec39ca8f7d5ddacbb40e638c37de4dfdbe2afa3b8e15f144f0d3b90eb68417dfe56148c82abde893eb7e5f0ab536ada941d8e5afcc40415e1361ba5874a5a2c5e0718a783f2f684d6d8879e9374c51c45a40a704bbe3d39262ea5834826dd8f956419dff7c4cb6d865ecbf298917e37a9c1780e0bf7c53223076f25b78608dabc8f8924b11339586339704be119bd7b2edc008a6c0a5141694bcce88a3ee65f9d4814e909b1430f9aac7763ae75e1c919d99dff908e91ac2867b1da656acbecca1d51b1ad05712be2ac26803dfd3a484339b029b0442edd7e2e0d0e81bc0574dfb5f1b358f340e40c035887ba7844e022646e3f0e6f99e19ea575092217a1eddb91b91ea71e7d9a704d900e57e8654dc8c0ea6503c9cfd0a0e286bc573b877ffe7ccfbd73492d6560f56468d475745397af585d1d04461a598c1ca13bc44988e72e5b104851efbf36e186d29ee48dcf457c6e67c8088d15e5618b81675fd990f5a796e635c30ff41c820197648a1c6bb30d0758197453bfccfe70e920283e30a32c82033df008788c3544e996fce49b288f06517452b5d308d42bab509ccfa7ea20ea3da210ced855d6c5b1799d9c95e0a43cc7a125f578cc57d769667b3d72ccc08e3497e7062250278cc1f1929209834b1f2463a372306ccee7d1b30571051f1fe43053cb2283ff1d1dcf06532085966e8ced40725dfa57820ebbb332f2f022de4632fc219504c8d9283e657a0e2a7a8cff805d7ca8c32efa340a72218006add1a12f1aeaceb9a196657fd463787b5437df387ae925660c4e12c86a8bc8c2f6aaf985289972e5994848da1898ef6cf208d032275ad39a62b780dc1fdca5526bb3010d2178a28688d99645f77e71e86f5c2bdf8c48f0532bfd29538e8ca61ce629799811b9f5260fdc3227072664b7adcd2c18e9e04d4f53bf1fa3d00b5b8f7095ffc1928ebc35ec32a89dbad3ce67efe370612fb7f241224a84fcaa928aced28ab59963d9eee0bbe588bd45b8d343d55e98c7c666d3e39cd43cb659a6e2ac99bcf44179fa9ded386ef8d51ff1a628f0cf7b05c6c2a27ea8dbe76ddd3b21df4add7bb3646faa3d6ace41ebda9063869b54d110fbae4f0018607aee0688b5db7601029e8c85a3267488bf4eeb37c8150348876e03ab8f7be667cc4369ada50d739537e988eaf8322dfbb33c4e7e87673713fd1b38bdb2ac123f35e130f8dba19d4ba729b89a8c5ae1fce55a4a131d4df76afbca0a25b02c28492249629d2d0b4322a79a6cecff4106c0e4ef2686d7d3a51372e92f07ab0b64c6a77cbf895bd15dab97823ff18028e8802843c87df84864c396b72f84ddbbb302c0650abdc9c00f8fcd5cfbfdc42031c97150c842c228641556fc94c63bf136094dee6b50a29277ff9683773ebffcfb1736f0ef79ce6bc87bcca84c0480e4583b59163954116d9322d1a6afd5be77dbfe0d3536f1eafd5f1a70ec35f756b02360adf7a8c3ff32ebe1e2a083df104462ac74ce20c093d4be92f5695e02cfbf3e6cde1cb08287542072acb4d3db2136c0e225c15afe8e6d6b1a5097fe6cc0e7cf1b82422e54843594f4cc9dd6c9d053a6912bca708dee883775167ee57ca530ac52b01768cc4fbd20a797ea04706688143824ab1c677afe9278dc9b2e844f84e75870eeb692295c1e74535cb14935fe1c88b2f92157804d5e111babd0c7725784c4ad9ff0577cb5d7906f154a42432f30668527c88cf72458f03c6961ebcb0b6ba3b377eb0183dd82db4e22ea187fa098c0a8eb719de206f799992e6f28e693d763f7fdda00cac4298b33b037d6fb50851e2d5657995a1be6e3d05ae8e290710d15d1030b351a14042d7cc8cea228bf793ddb7c8d96d3baa96c2aa96f18433185a415bb2da056d0306502353cab5fe8a3af4f011d576d94b35a06d742e37a50ca932425b079a66cbe2b849f3f123a468c31f67d3a2e90c7ead1b62ffefbf6f1f77a93f34667f19e179a607f4d4d160f35fce2ae89fb5809d981c30ebe4a0793707b0d56b717fd809db149c491edad0bf56669f5e576f4149c2a1d921c4a02b22b64da0922607eeb6342d0ac15ca408ec43143328986ec6831130772e22bc9d34d3847865dcf567241df36e4c8a63fd540ef9a358ed0b89141e74446da16b35987a73085c04f6edc99fc299ac075746c07b147db70dc2bdf1dc075c2eddcd613ce8d61276563f98fb25d7edbb6ee4559d8d9a07192b4a5cca6b0a6d24e90169c5f6c4bc22f3c7401e6e725545340d2a4d907a108dfc4741afb2bee1aa2526ffbe8129072238ad3281d3d4e1747cbbf04b89deee08cc95d87229662dc3088479697555fe47a3e1b55e347766431d48db938ec5e3a690d0ef56e074cbdd9e3e57553de5209ebcc7e791623c177b429b54809f0bafbbc815a00fd634416111305ce86d8e72b8e8931cf3859bcb4f9f0f99aade199a18342963288d89a42bd584b8f9f649f142110e942960d464717756da50f5c769646192d68013cb69d688fc8c03e24090224f116cdba5e0426a74eae6b773a858e2b3276f4cda238aaecc4c144c73f389ba8748b06c50791cfb834b931dacfecc879acf30b76f9df72d60e6f5656e6614280cdbd9eda51c446515c1fe52841d2f8723d1cb1eea9126ade3fc57c22d7bb21f9a64ed33d52f7faf944275d9595feb55cec82869e9d06cb9469dc854c39fc4b861315ecf0a1417b988102eb497b5fa258a2cd4c653f0b206045875ade22eb128728b4554fcc62a9d48968dce34d77fcff5cb1b95bcfd469d386e2f0aa31284aeb56138902984d85735bbe9fc093b78f2404ee0740ead70575f4517db93bedd48561746f4a3e42457231b2be9ff455cd5282c142ba1750495c842e9340e56a37d1612edbfd9c6380141e3934cc65d1374f2cb0423e1d0958e99e37d02868bf1672a9b884f7be010151fbd8668f56ed44c7fbd03c54813331bdf414233edf6d1db321fb0b96e235c6dacb38f53845effdc470c273259fe37f44701177ec2c4934b496100aaeaad59f9d2ca2b8197dc019d81f9a0769258a225994dda37a66eaf538ace47033071e77ebab5119cd19a2120d6eb20b4891b957e378cadd9acda86ae58e5c8e8539a0529f0ea6e0fb1f84b21a92bdb083f8f1e570bb28e1ee694e8912fdbb0e6f9afbf8fe2eb9356bf5375477a6cd19791cd6b16db9f01e9129059a6c66a98ad5bee7220fcbfbec133a3c1f830dabba3054c15563cdded0c671b2b8dd508afb23e37518a04c2787ddf4cd720cfbd470512eaa56ccfe1dd63f0f4c793215e61a0ce44e9e0494b25ebb77b73d742d1bd2aa7546db373bb6474819bcbcf5a47503215b46d6a9b0f234a78e784e51329d81f7e08802c28cc0411adce24d0877e12334631bc272debd83bdd26d42ec5af8dc571323b9c015220ff9063069652a4ce27c5b3b61f60529a34310b1de3ac9f31815b9b0f91a95716beb83686439a18d39b3ff5bcbaf70740f2c46a1e891e53b637e54341eb198c8c8648304eeb8d3cfb834b8fa15e705b9aaf47e3ba3d905426a3189a0ccd9bdfa6a4803a5afd22372760c641f0bbcb5f7664a4f7c337b5708e5a14c0e3290b32c7b130af6981af2f080d0e25fb415659f5ecebb8fe513ed4d524004a92e3f72683436da266d5d4281607caf13057fd3dae5afd725c2ad91441bb24971db61d5e30dfbeb4b36cb890e6e7ddccdc4bf521289a22451bf55b1b3ad319ed3a8dd2d4ad83188f3cb34a2f67b6b1109e112356bc2f3fbe914e81bdabfc4aa35fda347a8e8398727b727dd34fb2d2f1747751ffdaa37f2e80902448874b3906cb3e9d3d9f7a4e65411ebbf300cc38851aa15fbbde32ab6ba40c89bcae1b840a6eff6d870937510a82a7d0bf58f647dbc2fe5a0fdb202d31420acb9b73d121e665ef5acbe016da4a0aaab9e2fc0ecb6f11113cb3360bb3694e7b405809085adad56516faee9805d0b70d824b69a8c4ec8544c3ddc2aa774e6eb87c2304ec2dcd8ec4308bb29381ca6f8577059515d40db1719cae0ef7a1c5e915676e6213de77007016c4f2cb720770ea8635db21f222759609858ca44a6b595d99bf6b98625bd44bd40a535b8d3afd0d8f54d93f3c17955ab91d134693de5e34637ee8abedbfabd731fd8ba7c945fd7246ea1728a3c74effd2be43b3c3224fdbe66252b077dfa3573881463fb18d8b2a1a6a2afae876ec0708cc4f49c0c45d81bd847299e4e84951730749544186dab0202a30ea110a0523d48186390de1ccd36f78db843cf6d336e8ba7e7b776b410d5ef74589c5f022f7215c5e227f5d8d833c4ba3612e8df3d2c94fc11d989abc26e8daf6f1b26383a9ad6726c18a2ee392f0bea1150960659c9d731c651d871f6cebd5f4a0e29739438aceba42d786f489b6c509c4e2d8002e51aa3e479895b9deced89d1908cf3cdee7c5ed5f8ffaf660417c804fc8c3d1fcfa78fa5e1c2b70d53c3f660719a5e8f8e2daa075fd235bfef165e2ada17fc3e47b84dce29c024971c7bc4a0c9e36885a1355f06d81a8c91ff3d62ab70ca28881870dd55c6a393c4df76b5475592f08b62f1b39ccfa7becca1bf00c4e57eb6d7e9f5940e38c3d726bd2ba5b56d43fa8f12b4397b4d1ff78c2a2b657d4cec9be4b2e3ab7b25e4ed9e726f24439b8fe1a8db04d05ea4cd457ca8b0f47c54f9932f68866b0818a6025d55656d92c6d45972cda4e2621542de0cdfd28f3b83fe34b4bd5139efd055a8f223b72c9085ac28f6b1f84028d95fa573a745ceda6f6a9e941b381dfe4530567019e55feedee19b84a4f90b0f16c6cf98c3a73be83dc134c8e577e117b8a5cdc5e7603b621a0bb7fecad9c55355b5156fde5d2e55702e35fd7fa5a641e70b6769bc6acff71ff013f4b48f3f23135a4ac5f11d7570b209d88e26522f1ecf728a3362eb230c4961a2400d95a44f4fe585b48053b911964559edc102fd5eeb9f86cdce33054ccd1de5854c49db01f342e01dcfa5881037b144a1ac1931296044fcebe631591316d5171372b113cdb5f0866f4cc9a175b7319761bb22af6dcb823f7ab6ce704bacca33dd582072c6c198e397790fc2bcf1f82f076ba6a742a4533da8eea69016934a3171af525452877cdc688ddf6ea38f194ec5106fe52930d4ce1937c91971a879fbe56b4e451e56f7851bd9a6b0b79cbba99f96ee144bfa51ed0273911c288f1293c4800d147ce15508c22d135765890f45e13820a4a470f29e07db2f44dbb95ec0c9d7d41d3046c2f23e7df06114d2beebdca6508035283498d2ebc7fb7fe2a7278ef7141cbeb94ab4275f2cf3074502864ba1aa47313da58ff2dcc8c3210f3d8e1247d2a804505103065545f37addf7bfdfcbe28162004084add15081b3534cefafd11213270a9fc60347e302a8b6c4826c8ad1bc27c82b527c5ed88957533bdf7a6545ec145251ac1580edd85fcb93305070069dba4ce7278f981492074b0e81c9fcbe2ab684264e0c329034f3efb600203671c1fec578ef6eecb4fc0cabab7cf3679e0571efd0d5f761d3d0a5daa868f98d10df63178ba1e74a7177f5e7c550dd6c5862738d22453acc0f29016ba185ad4db347480ece252cc72241a13d43dd805572ee024b30737d1a1ce96b90f7128a9017e518d7fd79bd01e9542778515f6ad87fdbca86593e405ead0c3505d52690495546a56b3fd6bf91eccd68ae345e56650ba6bfb54fcf4b0d8cc62fc0920006d14f9772b127d0578dbf4cd8d1c3c5e773d9de9e03b324e166c69fe3d5daf7562f52888b73c49246f5e382c9eeee9b0411c7537c703905983a2560d1b4ca194392c41ec7454e00dd57c59456a1c7349a1783b95d8804a2ed7b743f81a68c58084aa7059a7377322d7e4e5df69dc313fd62e5e93b27710d9d245a8c62722c8d752b2df90db8ab83f8ee3eeee9e49047697de07bde600bdd12f272ca9f5fa45ff08468e63adb455e3d38b363ac34219062588aab49e5bd81b1dc72698b5d78ba0ec9ef6b9113cad6bfc5701851c3cbfd417abb1469f0cab48483fe7106e67de16f8f58c4849477b61ab7c60f5d314aae1f1d3b165090508b15909c150c2ea7f4edb1a8ef84ee03c6f1bd8faa83da984d8b2ca195ca9c4b44e146ee9d213238c9e13f411ad65c22efea26be01a3edeed982b493acbe3b1d7c8705bef740247da0def8f9f0c07ce16056c0f70cd5f82833004c8bf7d6778f86075a36c303e71075279429e025202652c688aac00c5fe69c456bea2275c2cd7f2a03b27556462ecbdd4ab17c63b7faea2eab3a1982d3ee98ddd6d6030202999a8c207ea9979f0c3b6318f6a7c41061b89a2969f62be02f3d10771ad7e69","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
