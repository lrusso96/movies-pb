<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"aa4352a41e24aac953cd7b7f1e389cd92b1647628051c0012dab95d144874dc72bc5861d96882fd354c639e6b7c3f72e1110d7377a63c02cece5e0dded8384f935f3c8aa5d35a26b36911ff3a5070edbf764ab629b31645a7c300004da8dfb0965f9d6ec3b4ccec20989d014c52ff6961d296b29b57d2d0432489794f4dd9e25eec26a76eddde33e62284e6ab300d6a22fb679ff967b01566ef25797f91da210701800c03823198ac63bda21b407029a68efc6b03191d0eab404639847ba9fc1a3577ff2f33a97897aff728ccd02ab3d3841e0a69508f1241ebb28c51cde8dff052e33d53f621f7342c56043afc44849348b91f37e374f15e4bcf47d15789b919784041c27911c7fd59f434c5e55974666fc73c54fdd7221c04680c5d852f9385966074b5392a59c8121b556b8ba64fe0595d8bebaeac461e4b4b7b62986c6bcbc51cacfc2195c973965da7bd6b15ef63665e2b05c5b0bd7d8e7b641566211734e84ffec900f60c9e83fa13996eb40994607aabc64df88f94312a804591cf44ffb4d338af541d28ac56f9d9709323c530fce8316e52fa8fa5cb130febefde0c7d9b92b36f585455ba5e8a2d3a4d00e1aba5bb404dfbad60aa753494e8845d52eba38cd48213f89f96f0bcc003ae2578b9f61507b72daa781b564d87fab644c433ead86f7d1eaa628edcbaf0d9d9c40c554b0044b814b3801ff8d955e8a63062d030e419eeea60340fc9413eaa28740d9f124eadf39adec01e873289af568414dd8665cf41492ca4614d919bd1f5511e6ccad9ffab7237dca96110b5bcb1337ef4b9dc2968ae836ee50df2c152ff2d6f7c68f285a2a2aa7470c1ebb7c1e90cdc144b73346bc987319d8c4dfae0540680c77418bf0bdc86fd088dd60de019ff620aafb1da6df8a5ed9633e69fe7677918f81f0551941fb31a4add35935d29b7ab05c6ebf0215cc332a0049f12c3493a478f40fce6bad9c4df7ad2aa47276bd38ffba4f0077ad5d9baa16d1aa49599541e87159ea1591a29fca3456154662df663c272b1fcaea4d3b3d5090421eb1adf743485ecbcbb478a4e55afd0f9e03f06e724e74b0b0bc8482d9f5654d19489dfd7d7b1770091810fc31e0cdce8f0dcd796790fd7c5d05611a25e22ab2f43f73ff69d6d7d4a1e1d28b1741ad69f8b889a7555a8100053b4bcf0f7731e79049107c4ba02ccc68c6794cf9bdcf4f8f91d7bb9826426d757c1702b92daf95493eb6d9c49602f6c2e713f48c6f5561a9365c8a5e77bfcc270951eb7e0eec1001d8a4d376dcf1d716e572d50e36020d9a1d56594473e36e7fe799cc856bca6777a6b0fa02303b0dfa56b2dfd12333bec87521157f07821c70ea45d079a16c1d2df68f6cf8f090c81796903d183fb7c5425797f7bb8ac5703306f0d891867cd8de2b0335b3b6bcb3c72312a9749252b64dcb45e844c7cbcf4e50ce61c1cee14b85f340db6760eeb05605100b9f5106b9d62b7b0fd1c77448ea1ebe5084ae88f7cb71aeaa7a60767a634c109ad7bfe14e811b04e22f73643fceeef6947ba8fab382739f1aa8a8b0fafcf43f540814591e2a750e0feeb966770cc63b8cd94352f81e58fa76f7ef7aee8a723efdf469735a52db7aed491163c0ccc2cc5f1a51020786f0f99d85c502abf5f9d8a78fe575d62702a3b1376d7674563e87aebf56877f39046f2092b0da690cc231c5e0e9d319ef28d4abfc38e791ddff4a1f8557ac4a8dfce1b1170f547ac1901f33fa4de6518867eb7cb59d8870889330bd09216e93aa8a63d8b8762600614431376dc5c422c1bcfa31a7be92afd17b9f947e7b43b6872508f218c53872a13603f0bb268a28ee4babda955531b89bf4333628c2fcdcd6a8c4349c0668bf8e71a4212a6ffc31f8101cbf24542cb5991d98f8c53b0257dae86eba70c29bdedcb69d0ada5e488588d072bc8f3354433ff0274bd3efe6d3c2ece26576f46f00b11bde6d0fcbb14dacdc5624fda4688b8d41395217740351fa5fbbc6d8c35fdb55386fda7dc590fe63d4938cc46aca389718e56688dd4b4afbea570e4bff2f9f577a0d644e623f65af7397ce1afeb1843b7b0ac21b7b28fd24d54f3da8585fc7268391447815744877102124c69759c9f27b539db47a652ac55d77b73606d5a0125c0380dbd845d0e629324193ede692905d6f136ade2e91ef6574419f8e4db2ccec2c3264b7f2a4b62e50337f8222059c33c7d1c10fed5110c32d694f6d6f3cb259a5defb0ea2ffb5bd65c184eaf9fff64fc0c8715c5620a655f39411791df4078108b500ba495e586cdb813e3a0a2ba71d899d699c850ab6d13b73349f172e8a3b1a977d006e753b0df3e86e99779a49e9db67330ff45f59935cb11a353222aea2e9b519f6b71e9bb8e2ff5a9379091cbd78eb39ee75d93370fe8911530b665f76a4c8e693d7fca77ed95bca4bef00adcf0b958fa8382f9bbbf08a93f0d75c2212e1759d258dc230a3f8baba9aba8caa02370a36bfa886b63ccf5c63900eb601e2fc626ae9db86bce6cf02207f8ce943165aea8c064cfea3c847ac19b112dc1d753676efda8bee593122e9bb2ccc66e5728d6c0aa3669ba62d51399f5f307d347cfb1be9ecdf9a03586852b5ea06aeaf5b69bb70fa63382e396713695a338b17674fbdd9458e1b44f5f9fc7ec6bdf5384563f10d6132713b2a59e7830a26fbd25fdc45c0aac0387dcfc346ba5b0a151d6430e1f839c3390edb6fbfe6db694d8e913b096d7dcf6235878768cdb5e63b1bf55481836125bf15996e62ec02d6876a9b5a962e911c7dc75b530b8a721796751c496fbef4b25443c576836a8cfa615139748f6366cdb9b8728cdab247f6fc4886165d5e3c1dbcf579680b72816721b8b39eb9dfcb63924bb3a2b5e74394abc3dc121359c10952658ab094b24ebf428200bcba5c00157dbd41f5effc1429b29893e332b31c182de90009889b75bba3ca37043388417070b9346bebff38197b5564f4115e0e587ba503e47f8e9fbe4eb6ec48e3545af4343ef501dd0ef1a8997a281ea2138751d80b3aa8f1fc48bf8d84c59f7b9857c7687add2ceeb7c07dd900df21872f2c35aed36e810982bfdf4ae7b9d01c67405a49613d84ea25b123a0e43360690e11a59529bf989799eee015738457f6bad8f3979a405ee451ba07ec9c264858fee338ccf20360e95ea978154c168abe5eca0d32e78529ba6037b9bb488dc165d7bd6246eac0c5a3930c5886644a932c0db2f84cec57078dbbc82dd197d4f6bb23f72fb8323e08d1c65f2497f17557647c754d411d67e53fc1132671eefe1f2435259455cdc741dfcde7e3d6e3631f87be5654ea84d28c7b3bae51737a66351800af3695d9682dc301e5955d8e95f1ac9377c7e3b6cff35d67f7c89f59df7420a904f91fe24127cf1983747c807d01a293219ab4f985f2929d85852a072c79b92ed3d260242cc8f22f8834105d5c05d1f1fcd8d468db6455d52f270cbcd4860c6c992d897097ee6480f9b2f6bc3f73156c88cf9c392d38e95524cfe99a77b30d9126c109115d40425da600bac3bd7a1a79aaa601d68fc528bae230bca50f1b81d7ff0c5bf37e77c35fcfb40e6f6f5d21ec555d1e72edc67f3ea5fde48681ef80a5866bbef0cc1c42ce05907777fba71fc22a71b68668e97a1ba2d993ca663813dd390c482c1fc322ad92df56f6fea7160ef93be7c3fec6279c8b869ab7544ae5b72c65fd0b3f7abbb313dce8e69a64be1b346033c998c529b77f4b11420e9ca767e11b6201cc9ae541a995f6432c6ade5371aae897cc9f9c176aa487595cf9eff4fd928ba65d5594618549c112c9b0f5ccd643dc0afe8c5ffeced5bd8cc5883f67db141d6c17fafae764cd3b4a4404f18cf7c21ce079526345276774adcd8bc74a7a15a987f966b8faf5795de357b5c8be4109a80cd4e34f900743c8b3ef3b0e410f724072c5e9f953129c0d42f95e0e3118d6f18636a06ca2103bb35d7dbad6844ecc06c2b32b69be2782cb6fe205428aae77c6ba42294f35d82afd801787daf528d9ac402c4200e63d1ccf883e23b81374e7fe87b1aacec2510f03fbf9e130e351614d636893e13e67ffe73e54e1702a3538cf12ab38cf1cf6d4b5a7ec595ab3de1bf67ba5ee885a3c83d5aafd2279d306bcf230fe44000bb1f40d5678389ec9d53488e8279c7a7b78bf0d48bd9e64ffa99dd71f0b32acb1234a20559cd69f117f42b5e056a5a2feeff4cf87218d19f89fd2bfcb21b6088b21947feae02bde1a122a30b7279e7af42cc11df712f2dc5de56fb473acb6dc5807ba230c31ffd6eb733b5be9dda838ff26cba2e803ed8912dc9ff844cbb1882e0e33e86ac5630d9f2e12c541dc651819869bb1177f16fb471c430a3353a7e6b43f90b23d2fe410339072adfc41600a6978f991e47e7764c6238638b53c3d202d41817d7cb3a734107f91166bdd5c30830e6ad0f081ffd2fa91c409eec099106834fa6367fe6b39cf60489831c559604edb35121dbf2d920d504b95ecfe6e074c06f98c0ba2576fb945fe4bc3ba1b38eb2c80573d4b7a919ce76a6fad9775d6919ffdb2afdbe924da1297521c153afca072f67c49ba5cd11c511a76154956bce12c4bf3ffb49e79fc1a5412ae4838d1aa3f7d232637311a55e41604fbf37138ff7945bb3078f295fe4f65dc61eeb8fe0e486b06c50b22cc38160aab6de2bd5b2eea405ba58873a15a03d5d650e00c20a6796749b4861217f1630e04d43baf04e0bf2b4ab2bd869480bd15c85658e923f08dccf2ded17aef8018925c34495a2ad987be9f3e0a53414d0aabd7f328d0825697299f66363c919e07dae5db89f613e02d3953ef3870dae3e05ec6aff0126273cc9417e23d8d8477acc0204df2c2d5b65717c8df2ff198326fbed74f603d081c328fde24a82dbe953d9be56d93b9f2f2099389b25618b14f318dc76f463c747dfca6cc470b99869387264286894b196903aa9f0ad5164483817a1e84a8d17e5e1f3d0186a7d3baf10e3a343544950b6a5260eb025d8e49acd4bef0c51a0bb68d706cf9f00700d47bdeb6679bea8a9035adacff7c41b8f14c4f4e548690412eb68c1795f8f7af23ac17024ded47ca14e2130f0721470d6bcbb812210e92782f5b0e3639dc29118640a12e74f9ede7eeb5d7c729b5feaeb096376ed39ea17ee8ff4e9d27066e72bc5b1b759258465dd3ea0e01ba5e5216f464311e7570200b513f910fc1f696c049b91f662e1d6e872f014bf364f97ebffc3ec40ac7d8c9468b0c0c885278493eb87baac53fb5d4253d629a1dfd979bee2f41f57ebe7aba4a75d8ee092ae99a715e6f57d792c88a7a1537649402c62ac5b09c652d82aba8093d60e3ee92ed66342d144858321e71292f82581ec985fc5b192251f3fc19acc88d946eeea335663c03193d7f20c526bbec4d14db441701874c37d1ec13c888f10a24a7c0a6a05619ca2ae35dd130e0a943052d772bc8fc149eaaf295ed8e51dcf5d394d5c8b87b04eaa4f9740376371c340f76329ddba7982878b15bbfeb049fb751ad561efa50792fd40da300d41c9ad74837fdf91ae0710e263fb8974ef5e426b10cee856a67cba7f3f5094325914e23416bb1fdaf0644dbdaf47ab545e4d085fb4c6078a6f592dcb16a814df03a2495d778929076ef33fe51990cfac8f7dce774b08ce720865fc128481d3d6a0c32644710c8f5b013b60ecad0b8b9abad5f3c1b76f253f0840962abe0ff7e2fa78f7d3ba2046587097dff5fa7950522ac64c4bdee57fbd710cdc8a18d812c27854bac288046db907f3b600cd561199e0b8c8cfe2a6588bb89719086cb008086f32a34ba741c5bde98f2546c30ff04892666a716c585805c0f34f69364c11541e2bd9a7719c918fa8ef2bd104411a79d5756c882887cb405e43c7f195aba196c40e09a981c2cae99e327270c64f1154996bb3820b19ec74adc4ab8e30b278f093b2396920509c3e772dd8ffcead5bf6791d7c4204cac023bfed0a820deac7027797e96e491a6401e614603d5e8f6a303e529272cb269e7adb45a6cf3aac46ed5c43df760387cad9d7aa949ee87cb86d6c9a74ad862b6258613b20a8b7f8e4045ef8e54eb9d249cbd0ece8a13042dae9534248735bedc993f6fbde0ef89b12e1166ae0825b39f9ae11d842296ff2c054976b7ecb86c48154166fbf39894f4d1308d478c42908826b9f0e65e943e619a52b935b3e7a759b3b29053164f853e599f2bc3938a2da67cd3594d4894fbb4e67a7df3664129a04491549f8b2a8865c20a53b88f0f2ffd7946f77cb165238f32fbfb62d2b2b655bb45d72756042eeddacb5e3c415d7762e51d7c65bb5e116968dfd6d1d6711eb44bdff7a3e98bc97234db16af4745fb445f4e7519f2cca471c8e3c2a0a9f1028383b002d5412325ebcfee4f15837b93bde46f9b0765245977094d1a04ef589f0659e1188d39b8667dbe09f105d6d87681fd9643ae1cfdd365e9e2c7efab32dc5b653b783ec4ce1d96437b0500bbb37f95d9a04d5f7819dfa1e6933184b0e95323e93882a54eabbb12090f2770e88f79af9b32bd3f57216c949277c8050bfccf5fe30d278310f688073f0fc7575da0f7ceb79c5e35b7b7e5b720b124389c772d3c74d0c8d63b7d224b5ed4e4d2b80b36c42dce89f86fede7689c8f60c8e4a09a4fac2fa0443d294c99271b3504b51a2a74e955ee34c0b39f3bea81b57eadbe55a5ca259e1e4652925fa22e8cd60dc496d66b1fedb717213bbf97cc708ee5a046d7052fd866d155045971e483cf6b0fb51419c53dd27113e1ec5cef504e76b15f4ac210243b004ec81f81e86f966e956cda588f34f1ad27db22e4e55bf71c9dd1c98774283d3c2df8722a7a7124e053bd4438df704e1c401af1a2a4ab0142a75c8dd9ee2de503973263bf180c7924ac12f50fcfed20781e95c8293cc71a0b79a599fd11258779cdf6187209dd6266d608bd6cb692155069429288618275dc7bb596a0f0e137ed9961787373f9a4534ed33245e007bca0c0ae3c140a75792999e2ec4050f17c32ee50fa54698c639c388ea4f60f284816dd3bf575faf725dad35e64a530451beae89d2c17131ba369a9e81461882181360cbe3ac3792eeea6a653bf133352bac2329cfa0409a4ca1f33ba93421b7046958be34fbd107b84c8e4140cd34da72c66386b8d58413a74e3c37a3bacff36539cc8aee9f13ffa04c53980391a2b371a913602fb8a55f15fbaab976c7ea01d06a05cdab0395b0921e5b6706fbd8ff116fc92b92c86307a99f538afec77976fafc223a86f8e83f145b3476b6c032440dbb85c25a5f41ad3b4b76d12396ee97c01c8459a559e58de0bc4928f9745c78f0a8629f7209be91de51d5ee999d63d9ce29be7ebe53ac4e9e42e0767d5625842f200b91b89a0d5b781e7689762d01ccb60a2572323ed5ca034ee8e10f7194d908c0a36efbd5c9f6e4b7aa4249a478dff73a71665680af68d30f36314db976e560ccfea8a645595c41c38756b0a48ea807bbd60fdbbd439f88103634c0a2edf8ec88b8d4319ab0282843d34bb38646039b9bc8442fbe3c2d856f4f7f29d262935b30e9af3beae14775e660ecfda45f469413fce1601c766c3ad55a501b5eeb05295f11b8a935d9e22dd12fdd2e34f4dc1c07d6f42f0d03dfbb100715124d40fd98a1dbaf9b2401da0f0e8404bd72a195c6a6192da52f8cf47d6b68c76a64456eb7841ca7000853692150ef13081ce68c3b2b6504c626da76a4f83f57cbb0308b8a3fd8f69bea3532739adbd46e8d580bfdd8e8a895a430a56167b93d1795df025dfbf7d8bc584409493cea240cc96f6dabdae48261f6a2181517a695c702183a067a3a418284f8d3a8721de665e0b506c4af05c77c1909198bf059602620c99f638c72e9da5aaa7e7e0d61d496b7654452f25d3cef65ee51538651731f063bf560393a8d6f5355977827f27ea1427aba97c7d307f5d2548b12848a5644cc48654ab344b9de6895c43edf0a62d6e25ddd0097e27c2c7e76dd3d7062949ce8d83b937eac56f54293671f3ca5ed6ead856c7b80963b0d9a8b0bea42c91a2c563c1bfc1a60a116bf0236a9b317feff75d7b3621958b73b0c1335144a182e384b9a26220af5274bdee64a318bbe64856505ff57effbd9d281c584a2a42046bcb11bd44f137721abc975847056b86974e33d2a3ed2c4dce51ea895ec7e6534856c3c443ee3827685a375e294259948e7963edf268b126f698f75c688f12d1f17fe9a2cd0f7b5460fb491234a40e29c68136376db6a0e09823a1dc0d5aef6ffa94a7063285823c47b7838571e3bf79e42b94343c9d164a267f4363f7bd1999e94ba2ebc8ba43e3040d8e7a562baa69dc8c8638beb510bd91ada268dc4c9b82feff66fe4adec34a486f1fa564dd9ce9fcd2eb4a758102b1b9000fd34013aa7f5648a257587ba42dd627d2b7a18b345248c105b7c9da98479aac32b2076513bfa78ec3274888b2671c51bf681cbcedd7c85fec07ea576a64355363677713c801f47f10379e0c0b2f051472844044518164525a68c0d96a3a959c5a2a6eabe81d703aa01aed9d0f25b68a994cb0a7c18fbb963716fe4153fb0158c1b070fd1d3156a5fb9a9eade1812d2196a3e3e6588ca0ab1b153fa33ca28da56aa4ac0887ca50c68b498afe597cd4be987ac95c54fad343148b1378fbe366020f2eb5ceeb360b206a375aceba7e3ae325a43229ea889ab8a8479d8ae01c0a0a9445fb4e704cddf9becdb1d11093f3354e8aa003a85ba2b22ad90ac769970efdc001d460e00a06cb632abbd6f569844c3c0ec1955dc7a1b4df35a632bf70e23faec9fcb3bf487859dbe20a8bbf4c4517db0d8e9fbcbb60e9d3458474af0c3b1d68797a523da9eed7b7b0ec15b2735cad1d0140c72659525fc89e63ede2bc9b3953cad4c0e76f6fd496d5911dc07c32f474ec4aa91eeb0ed649233940c404181d23ea90764e7ea527ee8c36c2c30a90ecb9f2b34e92d1785739047add9d80bca474bb007e937d492436e070ec40be680df8ecfd577da2297f7bc6816f89d03b90e6950fda140858c42db7618689e6c92ccb63b000381099ff35f9907f2ebfa7dde88ee0fcff928a16bd4fe879f68540f6017cc11f755a89792cc11d601bd60006e9e3c2bb79192659ab06f71a22f29c29c423c3a2f769676eda92c2df18592f6d519af9a30d26837cb66f617020899658a76cd97ae9924c4a3e26603042232ffffd883bd8a1eda86c83517bd465c7c456a4bef251066d2567fa25431e6de98954f77d925b86bdb3942cf6093d45892f27445b12359962b86f2d714f98037f7d1a1956e5f242c902b0b99d53ed8ea5cae8e21c62bd660e27c93ed13183316f891b03310ba6eae1c8bddea137d7c12aa96a91f5bdfe2c7393a2c6634d0ebc11a8f2bde3558efbf38722e6b8e5b2486ef55acecb64350c255f3e9bb013fa128c814f50402a1c76710af0f93b72095c9e659f5672734f2f3ec100a04a00b4312ccff6e614f3b46570941ef5056d3fe23612ffa2a459eea2f23f954c22c6e9856fa489a7b678e4d717563b152026fcb7c45c82315c444d8adc5735e8fa89895971ba0e81fb4c44de46bafa08b7ed4ccbadba44e123b1faf15f9c4d75de3e6dae27a356998ba0bb7b55e8cc43a541fde45f46697e62cd66cdf6983f54408f8d829bc6cbffa43b79c1a7df905c52212338d995bd9f0a383d6c854fc78e9904bd2feceed7deb80196fafdedfe5e22470009e3dea353c9deaf48b1a299f132f12264daf1c363d8e07b9f19bbb15bdf4533ba22ab25bf9f6f809fd510721e9a499bed766c946053bca67496069eafae952855b576f71ff100a878bef37a69bb2316f54878b8fd5efb4621502588c90cf8edbf64c1c8bae5e7d54db7efe9cd958eb760f75742237e4aebbf349cb4c66128761c12b4458217a335f6027d2103b17877cca9dfdd941391d09f166cc2b26f3e784b0df0730d2f4e4773bfe4aa8a769cf404387957d4058b0cd381ca627e25b1df56f1d2fd7f7ece30023917006c85d2e1e6e17d6c1dff192ada0c94835b706bf321e03dd6eddc8a29639fd0fcad08e0f5b48240c5ffe672a052a12d360614a17a8e5b7fe976e029fedfd689d791efe6f023f48ad4e1d0d8e437b52f32883134c93e3c8cc94be87cf568fa58693b9a5d4bae2f98eff55960a644443acb47e27930b53ce35160f936f55a5cbbc6abd032f85fe9e664fff5813ab75b96de9e18034416639a93b967a54ad176c2d13b4e95791535c85f70c569471b725848a8214abd292980e8331f06bde4c35f0ac280ded6c4239c9dc3b6a58ee3322f79e2c48048e2f2867079231403cda2be8fa5826f1b5e69342b69a5deaae5acefe7f0755e0fce5ac77fef6557f7f198cde11ca15902777508db75e25bdfb53e9cdf835d6bc9d53c9a8447ae4fe42deaf0cbe7660e9875eafdb0e4af44df39ff724dd154d55f8f74dc00bc860a60665116b7772d9809ba0a23afa7190fe4cbb96d41322dbd25fdc07b01150b0c2fd463c1b07f100dd8409d4fd78336cc6b707b5f1eaa0fd617ec826e62685ab59a279af235493819a1729a4c8cec5c24499ccc2d829dfce85dcab16a41cb59bb0b8afef5b9e9634ebe813cb45c217cf3fa0f3c48447636a3537b9c4ea95bade0aeff09788f7325c8b9531621f6342e879b6e37bc960798f460bc4b30de07603f79d983272239312ff7afd33eb5c413c1b8d46476660baa700568c6564d74c7244f3970af9754a2e4a967491177927117255755a8e0e68b750899e830fa6fba4d93ec0319868bbf41a9afb32afe5ef67e14508326731cfcff2da054710546f959b1ab56c0ff4c555c63cec5c9bf34f3bc07ae44dfc53aef456e413d38adbf899a4f717c97231075ec707351bad1b35f8a8746727daba981e612e8f03f5bf64f0020d66cde14fca2bb577d08970f5bbeb1772bc62ab2edc6a8af364e48bd030f8ee05d4a0a335cd7cd9b6c69e55b08a71b618b10894ddad2ca1e9498c45d1076a3806fd75023c59158345735b7fc6f1de4a7155a059b30c449080bd44d965291301f74479d8255fd59118973d153673dad925b15ee5042d69e2120c3aacd9bd8ac663f5afd43241e69d507488ba9aa04abc9c3ef19f2080a8ac0f9d5e3a6f646b8f652f7e9593a06e95d15aebbc6ee261a57fd43d8ac86c56f8bf5f092c033625197240c157ef315dd42b5c09c0c1e83101d786fb5313a71586156831996e6db95f365fa65057f8a2a1491467e184a13d9a5af7b50461329f8fda30ed19a2612e833553a3b0a74ee5853e6e090cb150321fe3159b0edc0eed0139386fde57716d8443618ad528e2bc5b097265b274b90081a73c401c975844b7932e4f8246cb3acdc2d6245b553702e25d5418246b500dc820f1d287d68f77ff9ba789ad7af42fc24470a302b36b19df11d791e089b8e522186a4e4905b97d427fd195960b303bfa9f04227cbc2c2b81e96910731772dbcf121e5d42570465b1f2bad2a306a68b07013d47dbca69bdaf2325d8e8a3a667a85eabdcc104c9438c72adba0360e06a9f4b715818962503ea1d2101145910d08d7ec78b4b40724f271fc5bf64591b064449a5962ef82fc52babe48205c8716931f1593e3b925dca2716abf68fe6b2ed6d71b3eabe9f214718081d54651b012c8a456288f448d77fb7156a8d14aa96585dc33050d407205b13c315b26dbf1befff89a2cd2adb8ce90672431988e7c3ca3fe8b2b111a33f3a4698e937909aba6554c50de5d37c5ddecd7ce7a233467eb818550750b1b1d965f53fc04f7cbd5171b5996c3e4d3352d1b1ed05c23789000796c772cbda333047985c45f4a99b40e9085838393d1b1f3f842bc602baa554731c3bcbd3085d254e3165d9c7f6335dc8746775d8f90991d79a7b04017a2395a6fcb8bdce9d34c5a1cb8ff92f845081398e17fb5d2d37f4bdf7b555206e7a09121b0dd5ed8f515fa5674830ad9f4136a42b0be79d02487f933f613f3714d64e2eb288b173912158274b81f38102927493f489ed64f961fa5656a5f609c3d6d747f984689fcff6e014baa311bf7bfd85354ae7a85e6c7d6dbeaa2ddacfb1ebb3ff05b76ff4d7eba272971bafff191cf217534f52edbec87ccb7219325e552065ed36263ea55b733788c4e00c1aa3f9a1d3c1c77196efd7a5fb784051bf4f550102e59aa775e7f8e1037c7e5d10c01b5acb7743caa44b5e2e153422194426072db93ff592365606875e264c39ffff8bef939257ce8802bf71016475168e4fa36dcc1307c60d301ec86727a06d232f3b9d646fbc8a13f2039f564deb4e476814c8b43eaa2bacaffb61e0fa06a29444521d75327ac38a3ff0958684795eb022e262c17cb56cbb9b1d14497e34aff7331d7fca68dcc6b3f8e75a99ab71ad645c506120b8cee7a26e36ba7b721fdf9b583e34b23351b5ef396fe933cc01c78bf65539bf19dc39d11295dcde38162725cc28ec866479efe0ca15d3abc7a18ee6c98e4562430dba2f2becb1a8f686cae79726f617c272d2534ea861249b1e10f321dacf2c823287916e43746557c1e4975fed1b624095e1e8d2425dbc46d60507c1ffbfac5aac48445249fa2da3b1c09c49805fedce42d103d80ad99458cb285b2c017c6a4622417f2e146405ae3bff86efd3ea9fdeeb5479c01c4b5ab87f1c4d6d96696517d81da31716c7fdb81be32db7bfb69c06df97392332954d48c10107f9c602dbe3e7cf0e7ef8e15001ff4cbeb4957ed6b54850be3ec7951869023e2146f973fd0b163dcc27b75863282632b63209cff457469bb9ffd6a01f9a09249c9ac3caf01a42b83e803400bdcf9bf8437e65d1c057ed2894d240a3c1f255f2a0ba9697b39270c9bfd185c86a0fe29c77504764d1cc9bd61","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
