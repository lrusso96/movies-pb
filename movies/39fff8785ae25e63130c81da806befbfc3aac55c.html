<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"74c3625c5f5b7c66f6a898acfb1c8bef5aa0118cdde20c12369b64dc5fcfa31e6593f04546467c14ae963880bf1a80b28b0dd54eb514a113097f4bdf37b473daa9a1fbfa7aea15db8c4c1997b7dbfaa2a4c46a9de2e30e00ece9e8a5796db475932dc1a89748959e858d0aa7faffc813d7e6f0e05e2fa7332437ec608e6ee20bd4c1c0d60d6cfcbeb13f77127f30cdf45dbeb7a027505433043269dc2bb0ab0b15a8544803582e26dfbf051b1eb9a59af741f3a36682d5bc5a758f4ce25362fe7e434192d48a39b966e1db42aa2e068fcdb9bdd22a25e23cd2640e68690f68febf2c17614093682a689e4e46230d7e3eb93e7c727c297c4146e411ea5b590d22e69538a826aae094b8168edbc73cd7cdacb2607e19900763044b7ffc0eab2bb744f14aacf441075fc6abb11fa393f9de9e1997fe9bed951ba48cb72fc33bbfba60fae30ecf1ec90c00bc11599d15615d1ee3b345cd4e6868c000026a5e120e1525c58adb40fc087cfe09203efd8f910f98b2cb2ba3782428f8743519811f65b24766c82804a6203c4501514dbf747cdaf76a0e3a50736910ed1c3b67d92d9f6401d4f4012c4f9dcdcfa5f5f2f5a2231a6902d7c16869b8c24626b6b9ee609e63e23319f2ca238a597a2340dd05511f941a3b09acc644470299af5a8292b1d3ad730422e2c8b2fd36e40e7e1389b248991e66cc0b996abcf42b053c0a531c5e36eb7c56d8a935ae528b449f51864de7f77a036a5f353911b989659a7e56dee18bfd77524ec44560b19bdd7337001d42db9187056a3016f4c312bc8b2b48871881682d77ec937a3441851fa3791ef3943576e9b42ede1c01d6052f69a8ce0cef9da0e285214e4ef404b7628e8e4cf8af4ad91b185ca6109b3c0465f63255f6a0ab6807fe2cc35da39680dea4c1478b8838ba41e067adaddf9981d6986dd06c84847a75ffc984d403e480120a0abcc2cb7ef0f10e1a7c0c979d605af0c87e953c8f158a8ddf978d24541d07a6343260f850b61bf42ec5ca8c2323f44c9ae8ae4cc15c303757e49f82cc621000e9a55272cfd81f1c3d2337cfb8b30212b2b02e98824bfb67f93932f8c67d8948a1330928c4b27baa605e0f45c226c2d854d29b8f48d30c5e1488bdc59e5dc275c4a7746dd4536ef71806d3ca63eb1a14e55856ba53d0cd95d6e2571d045b1dafcd83b3561bfadf5866588a0686f6c0e279454332e75dfae1c32086ff13949fb8bbf3b353136b4d4707c17a18831caf521ffb7ca952b99644e3128f89e2e4a0b06d73d10a7607406e48c0a6957a92df1184e1c3cb613b80f3d0db8dfc2cfef0acfa9143834a3c5c8f5a0ac96c074f13581bb842b979987107f4c77bdc461969bd3ac883c0f769d72cc7fd3dc7b28c683f2d5078d2957e64e3155951ad664ce1eea098eace7435a621b9f84b5049c3b000795b978516abb79fb4dbe8a52515a8d0abbd68ceddd84c55827a801a1bc2a73b106bd3f0753d956e59f40d25eba3d509cbff19fff68c1f69411993c0aeb1d295834d85a7f32f912aa88f294207c133aa000d8c4f2e88b4c89cc3f5c60f8e89f6285b575a2ed86983410d70e6c7e18b6a27f2abff4eda0ce7b7eda5a1c46ccdf48c7bc5ccdd422e8b53c9030ad21c39976e375d284e0e9421d50f4f1e9113ecc519fd2ade92b4b257174b41b992067378a3963cf06cfef252742a63999f664b8c5cb00e2e463463fa9494bfd84904995e8242f6c16642ec39ef12163ab8067ec88e5ca3d53ca927ba126732e0f20f85ba227c062f4ab658fd1e36b21f9ba62a9ea7c1a416538a42c3b4fcf9547e05d9e03e20cdc934a7986447cd19888e1c017fc5ca60fca0abe875f942fd1c62966fdbb4e7331ebae5bef96524b2cd0ab2d04da5be59b3c947cb1e78525a342df4a6350f1ff836c06934cd81b4baa3c6083ab27c81ad156936461daee840114db21b54f8c8825c1286b0041a0b32e52fa51810cb0b2bda41d505d71769eab3588e0fce354335bd173acd0139aef0ab1c5cfcb4b3220f9c3043cad2b5200b669bb3371aa9138265ccaeaedea837e2043416d87630c5b73587d48f741036af6b5b43e588d4e412844bd0d63d8bc83a3f2ad15818408cf0a1fd8f298e5808c4f83b26d5b87fb3cce6da3725b0c9469f9af69b4513399eaa07eb2be53177ea86a8790a54b90b64d8b9bf0382d5373298e45009c02fde31f4fdd79d615395d070dd0c34a100a06105f14a6864237afb4205e958bb1fcb2a26526da5ce6c225c3230bfd46b31059106bbcf630121699d365c74bebf75f4e9c1caa05f483b2725bb35f1c816f8d03d94e97ee9577adf0febafed603662dfc846c84efcfc59b05600a3c11b056f6e6b8e5a671ac9c7d905a68d1c6291e8a4a3777e35ff1b7062cbfccf875df7568b37d4ae40c24e109e60ddd55acadf62e82ead6a4bd3d634641fc12ee07a1dfe26fd5358861410a117bfe151119a4c9eb1948bc3a925ea6b1a59c7a0444c8e5190a21675971e2066e9443428cd06ccc8479b2dc041f285ec79fbd55fc2eb9e21bd8ecc748a41e9289a2a6ab9520dc6f50d5ec71bdf153372c390dfc949a070a0c566803173fd19120d167ea6760b90b7ce727ae1531783f84ac73f1522de0f7a37d49d1ee1f705b1051ab49edd51939621f3d60c5842f2373d7617c5308fa9a46b396943b28c7fe9cf1320128e93a4f905fd48f9e276b8c12a80f59db1fa71a498eb650738f237fc318725ed37638ef650eb348608ea579c091f3fb54befa8f97dbf3049a8bc33dad89efb4054a5c96164ebcbd8dd7d227344e68005a4fd6f8305393aac9663b18f2d1a9b874c4db7da565e6889be9ce4e6097fe87d517bc5208c5452c2b1656269032775ae09c9ebc1c27126fa86c94dbb5c24c0a91d0a0d69f1128ae4f86087e9c07bc82d72f2b2cf14c16a5e00bc9c7a1d97f382ed54b2c64ec3fc145ccfc155a239138617a5efc9f7334880b3b6328568e4a0b6e921b0b2ef16b8feef11058e81e1118281ff22d213f467503d4f698365e298a505abd9eac3cd9cdae6fdb75640b99c2ef17cefc1d6a4f56be6801b6039d6161a836cc1ed8c06439ddd33ee0d02fdc6bae3c08c812e5a88729af933aa08cf7bfadc2b34c74ef949e2f0ed893d6304fed36219143484920b69eb35fe974ef594f78af98c1d0c50187a05775da2e6406b74fb7a0d38eec733e5d8922f28060f20f3bfcebcd33079d795f171f0d26eb461caf96313b5f18e8293aafcd970e0ea038b867dc604288b3b491f5aa1d49ae24261c0f92911bf2dc5253afc74bc560dcd1cf7ecfaa9cebbde1ba7f69deb0226d2b7c43ba6143aa935feea094230310c5faf11f632f5a96132105a6fbc2d8389dd58ab5bbc36ab95a7d3225b5e915fb73a807253b2f8c66c29633575d0e3ea029116eb45913ceb6255288c8173b47332b5edf813e706a14a5988d772076465cef7c537a7b53015439e227215f903a7660f92d42ce033bfbc49884aae6985bfe2f7782a30b87752ca81ee35586c20e690f39b4e4fc5cb46fd8c6da81787c9e93aff5a6ad22b78d528590c46affac14e4317c622667dc5f3f963921a338b76a3dcbd45d7a9640eea78277d29c697d08cdef7c5c3ab8adadbdb21ee4156835bda01735f2c42250f625953974e26a4331d45e4409f362a6f374feffb56314351926453362b476e71d3e061f6f5063c7f5209a91f14f518a8c4d3e786e01e9f2a9683ba725b5f1e8c92fc57440287bd91fab98a5bd42d3ed9ee806bfe4bf5ccb21509e49c68f82de586e42ec0fe00037c8f080f57e5b94ad840713b2c10d310f0e6f75dd505f2237f225bf002fc7f56941b0a2f6f82886e3d22eae732c3c704ec84d869f78c36a6a83664767edc98d0b6ee40047a9fe136c4c96430a449da16c32b3f23d7000ee4731af314b93203c2d5c50abe71faeafba9c9680a47a5630a74f45f75c4e8c3eaf579d9e396a797c94de031ef40d02d5d1c508e975472771b156602cffea5e8c20372af693f2ccda922a40f486c3306aebf6fdefb0929a1a8e304e540c7dadddb7c486b39830472b6d3ef659265cb02c2ad4122871c9033f474e78678012b348c4c164d8763f111762471b624c81d054a5078e710745ccfe50a2528cb3190ef3c679f9554aca3105055e7a633dce45ab1c54b4d5bbb9aa39743e147a112300903b32173baad6d1438d34b02e885a908e4ae5a1349295f8d44abce082980098c0f8efb600fd3db3492b0e15038479f54c0716526eae34fbc6535c9db5d36b6ed86495af5cab6a57131238f3f0f9d1b47f1e0c309fcbf63234e7f093c7b777714a23dd8f3250bc9b9ebbb8775021c739d58bdf98b11f08aede7b588fa618f1cf39d73004252cbf5dd69fb402b19cb5eb29b107210e68431da34c89801738aead68a9388d0a78398ce2e5a91c7db9f6301a3e9174e918f3bf0083aa55824eb9a3f1f68ec0ecde888283a0be736bf695a9e10dd145df6915439bb9c5f2fd2457b372ae1a23b48d8dc02c3ae6a0b6bd5f28e8a6caf13fbb0b7a742b6a1419e87577fb59b53947c655d8f3d40d31cc822a5f0c2769ee5bdb74641b277de555a4d25757af4d3791cea7f2786287cff84d30ac831a93d627c6917e4c887a2d155532973c56f2147020a739549b6ae180af7ccdbeba2c0b953423675960f14cd69261522927334397b27faf17178646616377f9f39d9138e1bfc90266763df7dfa84ae9854f1dfc808187394b5a9bd07e7c0faf8018e86db9c5bd44db7d2dc11419aa556fb5ddb9006689ecde9045d9e1fafb0092cd41e6f28883c0df540ddbe50817aa1001327859fff681d23b14b5580ecc93b4793ee8cdf24c9b63982bab29ee23aaa1528766721ef6e0d54e3991a1a241d4cd114183693ac407bfb046cccd4a71db9b0ea93db8c0d940351fd84f1c461b9d69980ef0292f335620bcca8b953639755bc3647c90e3119c0b79ede7be9c02d4c8a30766c4c6d40989b06f08c1a0183576de3daa26b629d1c446fca76d7a692b850ff1657ea673b51dfedb02c673aa3bab72da511f729e98ab41a163375d702caca0de2cebe1a98e404571186b413809fa6ebcddb0b230c41f28b6dfbabe1771097279db2b549c6a36bee93c567928f869e724c8c951b67cbb410e15ed2d75ca73eb9dc7d5227bf02fdbe3ebe62b0299209f131b86f517e7a01320b4ebe9cbe1cbef8bb1030eb84b8795dd865c91140dbe07fad4a384d2f3d86366d8c83f701588e6f3f08de28277d87f4cae502a2ebc11a044569bd7b1cf8ef96bbe4922c27816ec7d41739fdad5a3e78f26a3fe6eb272af79266a41b0b349723d9bc5137f74e409fd1b94ff7c5789abde5c3ced9af9d903417f08636828d17980468b1ccc2bb2ee5a4906a172ec44fb001f5baccc81ac2b812de9d4d74ce3419993855a023d41c15385a4df9dec9e778987fa8701727c966a69b4d8b4649b99b1abc0ffa359be45f857ce9b96c433e2d2b184a099272821f403fbfbbef6cce2e94093885da9a066e9cc51c7bb3ce598ecc787c49110e9f573395214f4a3d4c8c08109e1614fb435d3478e7c67cd05a8e509d0e22a181e7a7b8c12c1a10780151d4e080874586a1cb20f4f15e6e58f0eb5a349e5b773f723221cabfa3dad316360027ee1da53320c38ddfbd236e3d47909e4b0b5ed0e5491f596f618bde3582514c42a352b371b0e96d266d8d73fc43c55b377ac757525eb9a968e82f0cc7854367416f841a309bdfb16d1259fb9a31ed41d029879551e46c15158d354574e5363f099218dd851314bf8a568ea67de8904ae0902a15bbff70f64798f9ff56636cfab4cf10e496a8d9ad74785335791177cd9097809e6f63a418a1b370b3befc0defbb72d30df531d3727101356f70c1e2bf54e8a19fd87f7f617afdaf5bda7bf555d149beeda606bfb52e53cbb0e1ba70cd0d7f8d17edfc9741af6389514f673700b423280d5b0a0bfdb807f29e13178f1f582345d6cc672bcad8892034d84dd06810f1cc21d563c7c690433e5e94e214b53bfe6aee3d79a0e224c3a8ab26f7c0afae0ecb04be93720c35491e621992e18b694f9b3ead6398626f819a413818aa9485350422e8671e935a81f3ace8e975a2ded94e7cfd53ce27dd8af20369b4698abea335e34f83d60ec18f307b90d227c8195b4e94e935c27c79f3031084d3baf8a1f95f4e2e11e20e5a1829645f8bd40d1513fa8f74a692521275a82ea2a76c3e222a5d7e845cb9aa793967b34fc5ca3aed04214d0021fe93908d446660168690fd67763f0f91882da27c4ce5e6809a65753cd5ccf28602d1c35adacffbc7e92ca9b603fcf2ad4b9c7984ee89039192c6d1c80092a4438f155e28c486661a1b36d49ee85c15002db69a7d4b9f2ba19aac0163286e33b33b183da5b56941305b8bd3089d0cd5ef9d6cb5547e756dec86e36be9556ef1143cf054a02e6575b23a27ae6721c31d95fad983645f3d8f51f4d2a4c4c96ca886c8aaaad63988acb56aac25c37a7143537cfaa8724f5ddda68b98e19fc6d38960ea29c46b749de138ca9a2a9d61b92c530b8b900ceccfe174d0881a0659838e5b46e9f023cc9c79226269222d833cc2a2834496c42521ff13324086b11eb05b12bdf7bdbc320517fb4c6e33f64f1bebeb3e607ead95b864b6c312a33c8b47faecc4bdcdb71374a4d924b8e1b50fba9164b49ef3a3a5f1e791e7b702931019e08e4119d8dbf7a12cadab41db02793858059f5df82109b7fac7b9885263f6de9715147b3f9982125550a1a65a9309765afaa01fe5f7c76c97d4ca146bf25a1b7ed04b67099d22bdad0937e0b5e61ce54f145298e4c43d2262db9dd30087a0c05462da371efc87575685f51123a78375a873c5d2581b2133f3bf35f9e11964c36d8d2c4eb7b070d99f29de99e5113d29b777db3a4f5a1b89ef044c2ddca6aa17c1c1945d8c550ccd1ca7b8d90ff9a4a202b059b71ac636b588ff2a4d31331a220ae34b7e81d227098615c95aa4c84c726cb3cfe100039f8944a62cd66656244184c6c39d1861bad6f7ca527476b41b324c1fd6b71f84d95ac4055211fafbde30c6ee2b0a282a42034a9fd3a1abc8605ebe90a0e39f49a384e3b31f677351ecdabad6abfcd1a2cabc37b8ea7bc14f4ea48d088f005ed5fe064b80f67f36520ae9f886bc7fc698965dd8699d6ed8621fedd36b73ebf93c00a7875c85372dcc3e55a6a10ae0dc4e61093c10dd2178f0503e3b60762b9a71eb11afd5742f26bb1616164037b4f2db446fe0224791fbaf5fb40af1a51e19a944b6bea04a52e7ce76217794f4e3a009044e871e96e859f9e6fb20cfe3eda15867bca96d185a73961775b18634aa941754645ac09606d61c84e157d2d3640d8e56c235b25c6c57fed78e404773b82448d55246882cfa5d2b3b2e266ece9925c6dead9e74912593fe4f3b46169964267e7ea03c16944fedf21097b38d5f34bc4cd95709a735cc499daf08a9ba05b59bc62dda3c0f1f503a9e883f68f730f8bf1b30b1e650a846176b927a520491a201664c199f7c6c8145a89759252dda8a372c10a755687c00b34a825dd91b425da7e3347356ddb33660dd572876a8a8f141e7ac782d7d3837911cd9402246848223940f64910b67189f3c2446e12ad0a90ffc57c95d0c9b0fe81005260f66c5c1c1c8b5c1b510188a609a52f6d7df370623214f81bfebc8b016c892cfab00d66d84424f715723f489f631f50110f4fa12855b62d3d79c498e98dac5bc98bef3fc7a7120fed924e4e1c58992513948c4509205b75c4498f3442e1a77877f0235f79324fa628f967446414fdac881cbcfeea279ae3f4a0b77248edbb175e13730add3b73804cdc187aa1a4c7783da7e7ac71749d77dcae9b8849a70b69fc66e3790e649e8202029dfeb88ccc9af540e0bcaea4b223ca4da846fde5f3f460b1da2e805a704418e348bc37c3527b9aedf1ebb5e9787852341a4d2c22a4e6634e01e1a7d3bc7164726152b9b898602813bdd33256d7e68472062fdde4c0cb47937cdd468d807be9a761f92a61a5d1d758ef314702b51223440ab98f4c9eae1292b054ed9c2cee592e6859065aa970e626919f7a5240cfefbf3efc57af305c51621ecf4041076aff73beb3ede183fe949420bbaa3b2272cefdb51261c63798f66e9e047963d0b95b6ba00f7f3f9ed01331eee9eed798b7378d6e802669fd9d1896a8b12677dbf27ef8dfc690c3cec6b41c8e1c4057eaddb2f01fb4c4631c6a9920299acc4f5014e784322b99e7ecdc681dcbfa3f18639227ba7847a450438844ed9e8d67a1c8e1e198fbae4c43086b754460bb0440f8549bf59bab249840b1572ea4aa1f904f4b5be201b7de4b882f88738dc93395342399d7b7b3130193f0aa6d1df1559b93de1e0a2b19d66d9252f98665ddaad574254429dfeab420a1e50605fdd7ce2778ba97558f3e47dfc08e7a312bccd0795577c69943feca3dc8b86faf131408d64a6bf01104b76cec07e8679925eb799d7b62dd2135035dcbc27d573c8442365433ce4d4de16f742556d18dc89c29ad9a4a49685be7af5e58ce9678a8bf8cb8eeafabde3e26cee5e595f431b909d4901ccaac150f5f411245c1f4f1b5054114bed28000004ce5c53d8a46d78b9adad04fc46d1865b76693037ab4f9e989c9b19ab87a7a997ef0117f52da2592ca9b355e91ff5698a91e979ec6e8c98d3194001b67f31922721370a178c7675aee8c41fa33eb84a7b2cdbb10a094b2ba6ba90a62dbaec4b39a98ba84489dfd404ade373dc29e7a58ba05eecff77834993a9e23dff0a95c3cd4a0029a7271d228b20d34e2057e1cdd28e5ef82468dc766fae81a2a816f53126f80587646378a3a0da6b2b9dc89d27e579884d467005d90e714729bd55c883b95bbbb43b849a42b8ebc3b4bc2cb5920655f58975a39ecd389ea09a176cdbcf8eed517bf2d10951643aae8c546b3f13753b2c02d3f26da1d3569766e5207b6f1498407dc2e10c7769498f55421b9f60747636ddb6dc866240981475f06a6f9c656efb55c005f9f1044068eb94931e901a3a5edc36c07b44b8d5970174ab306c0aa7f27c292783e816e30df11630158b614e91775c768ea9ca6b5da2c03b9c47131fdfcbd9d2022903633fd8fec2aa84d39a48b8b698252603e3d4e0b0d69b74357de4c678865b552231b58f33be516fd8fada1b94c2e6a517c1538f3f6e484b576b01410e3ead2aa31c340963c35dbad993973facdc6e6b2fb29229819a8a5e54be172f0b779a90acc53f2794690f8415569bed1d21a793c2473fe55c4ccfe15b2fd26565f2c2724627775b2ad50ff01b5bc0ef3cb4f4824cac5329884e06fa221c92a73f516b1227855c617c36a0a0a15b03bd6d1498868e8b589ec35dd43d518520bbb6d0eb37d40938f11899b2f65fb0bbdaec2565da5c0dc6394d96dea534575840c6b9b983ec39b87212eb7efbe648b3d6358b17350c32b8b6494c2af5c7c531a53e382d4147e19df12a1a66300a47ba868f83841a885a996401e04d7e0340856db03181c5cff9e292baddbccb6639e39d3c846da195929608599426c719d3d1a35c290ed5b8d5c44be81bbad70db604fca26bd5fb1a98d404ad146a1e3599207ae3472caa29a053a94342ce375f202961ff981e8039326f582d00ff6fba6c6eb55cd63507498b5d1c8872ff3f485cb16b413868649798d673d763c077859d3d8a84a7ec53af4a3bb84e9a3b4caec24508d60ca95aa3e71a6c3d3f3d470608c170752319a9f9996682fdafbe6a0971844283d87cde80305a633a183a6e6c9674aa9f1d8e057c6fd82136bae989718d6434692360da69aa480fa74c5dcefd2ac0b16e352829f1325b7d51538fd8029b2a5932e232e47f87b89020d865f3e5262439cf906ff04d89219769e91ebc09a84b00f3a2bf5c5bc8cc28ed645af863455e2a76e6f9abdf32fe8b4ee8c09497a056e7228aa3f3ff14b8cac36873945c4157217c023bfbc6fa83a687121200bd826b652e6903b87056645ad2231b43854565e86e5852c8c2f6906ceef8ea28c4c0138ebc4218d792e24c4439d5b32f84d66df1910fed73d15d4f71e8ce53be1c8aeac7a235c3d5431f35a8b9420cd1acb65b53951cef1fe1e7d160747595f21c51361de4325e8a26ffac55f59ca4199dc957d3d41fb0f72091f767d0d9ca200859ed28590bd7059d8c94b27b80e0f118f8ab67a61ff56cf7568425756931875087f8032673cbfe923242cf1b05499631c22382eb2d35ba7a7d1b5238af7659eae27a81b6efa5ff6258bc08faf11ddf49f470f26ad10d4aab390783c02a195b1f97c9d4bc64c5edb4b287f3155794bf4d7a2127026fbbc89778f7a7f902ec0ff5003c89f57017002ea0b21857a1f05962a2158f3fc7bf933fb73031a15abea6008b4f829b7f9a3e59d547688a2b8fc69ab0d4632d52850b34d716b2c71fa253929169c686d55c512f1fa6641d002e3d9650d59e2750afaae106682c9b41bef1b0d85f948b9af6787218ef240cd26dcc9d3ac39b1215d62d78beadf289e658669e8b7f6592483a30e3a590981592fc377712b68bf2c6ea85b23c48e75cd3c91378d78eb164dd4697b9e7e1335451065ead051679bef0714807969b2fcea813350b466f915a17dbe801a901b494a4bcdf32d4f5a7368df1e63d8f2350d1b5a491cd364825224db646dabfc255730f2ef0770dd87f08e130433c07cc56fe5517177f48ab680a51ec47e994c16f1d6d2618d36ff13fedb0c67aca2517df635924f665cb6acd20bf201c98edbfe9d5b4e06424dd3f572a4ecefceb3cdbb425fc53c6a905980edefb0e048bb6d4c0cbebb3df1cd5d55e7531936f39d950b80b97ef9c4ebd9391c8a7f1e9448d2bfb073292c61ebb8eb5d6e0df9c8c7bc21b5822f5d356a3b8844ebb6f8328ae8d39b5f07f8d44dbe6c6a411681a9bf33f044ea8acaee2bed22093e36fed023ea7a39a1c35e1fc3f6aebd9f47d9b8374a0ad357ddbfaef5520d8dbaf429e9fbd295e4c9d83ceec4d485c7abef846733b59b44a48147022c39e1a22bed1a898cf9ad20295331f1089c35cdf6055007507bb7448060a7137287a8474071db0160e07d8a826ee162c508ec1f5fedd36248ba550600ec9e497d00b4e7c7716f24353614bedf3841631af0429ff2eb9cf4ad886b50a35c929b07679ca6a64f6b89a9770c5e33e0aab6fc32c3e5eea6aeb4386115867e2409fc1193d81ca60852fb80293b631e7952bd8ef91c3d7f36889e553570ec528a242e7fb5841e7e80af32c6a738f3e62dfd53babb8d6c98c2480dd46243fcfd668f27d6fa47535677f667fdf7673ef048606daf8483a35e355958de565b03ec3da45641399c273a8e65a578c587670ce5eb07091ff911eb7020103d9f1396483cdc989036dfabce56d8b473c20f5cd480bc18b437c65634307c7f9ee97362a282b2761012db656b1e9dc277f3de5c613ff72e49065aaae8d5a7e5583d7339da4f2a75b945607fbc1e8495c5a7c1f8178bd725edc7dfdd9327aa9a3832fe0603c445895ab3537f45786cca848c561eba01f439d53054cf0e7720dc349b0fac03e59f1b74af79cef8fd6f2d88c770fef0f5fe1cb8bf11e839c646d95171827e510281e4b57c3fa682c30762f310c7809f7dec0bdeaf12f2712975c7a116c944e2e1a3fc4eb2e7f12b0b2a2486391bdc31057764da15b214b6b3738059b3abdc9450d51a58fefba7261dd28412f97e0d4c68865cddd23e2986586a1e95f9b357fa75a960d510a9de9d8aca997426984d8b4cca16fb7fa1b68d733e1af8f2251d86c14b64bb33c25c09ab8aebb646016ce141b0dfa3d39e2a8ca29275537247f4572196b12a54b44b9ef033d48d48f2a9b2eca08637498a68cd3b5772441718c4d0275e9e967a39487e9a59d346e364064611b4902855f36de2da1b1f890877a4f31e9c97630a6e26cb17d3436d6daa65ed465390992b2bc2b7f649556a6c7358f595b3c946df5c12070e1117229647c899aeed7b12f23d9d0ffef70ea936f25d837a09f3c40856978712045c282e7903ec83ae41c77a410b1235f76c747f56a14d5441ce90e525d508b1f0f9eaec63b32ad4f28761e3cee7db37e8e4a9d2adf764426c623b82e5dc3cdaeccfe9c545ac0ea55cf39755652b26ce68461d0a9aa7dc443c795f1831af5c6a8821bed1c5b0f877767be3eb42a634fed3d055e3554995e140314c669b345d8f226cec28025465bdfc63ee60c9a50b99b19f9cab64370a118d1c05bd0059c8cf9d5d85bd9183df1b2c7141531aa2d2e0083eabeeeecba8c37d8f871320500230779f44a76b7eb5581fa6b6c7f1dafaab69db1da705bfd5d09b383f4752fbc73310b8aa3a4b9f3a98f2d8b229ddddcbe7836f03b4fa40f1500dae3dd775732d5dc621e419741588acc1aa3d0dce766f327f9bc005005fe7cacedec9c69f05d1374ddae662a1504038d626206b08bb8c07cde51b9d2c047fe5cc2b1ff90aaa65744e6f18c3b502fb728cec4311f2b8e0fc94302a0ea46602171f771e8952d1e4aef9d0fe92ae1038333f3bc33edb7af02a1f7fe7d155ef0c66f221dbdba5da5eef05724ff48eacdf0aaf67c4b142d89669dba80609a79f8176545fc4a89952fb97ddc8a0c671d02f7114eaf5d742f7ebe95b61aef4845959a49730e13541747279c8f6fb9065c66ba699092e1b2fdc215306b0620767c06967183909954e2a06b0ba54ff9c9c79bcec697b12cf06f53011684fe6e20879a29392af3b339425368e1021196f1cb1f2acd8a33eaca5d5b86f6ef365f00e820dcd8ab54e1bbf7743c86e4d11a78ab3337b05a73ba2b9649108124842348d32d3eeba842acf552ef8ebe662cc5b7d1a5491c9c37bcd3b3a0b87fa6aa15c94ccbb2858372bc768c638ec1c3e9c7289ca5ea41","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
