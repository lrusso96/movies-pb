<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9203f086123d232314a03f8d1fe3ebb161d8c3a38bc465cadcb39d51aeb4836a0ce7c8936af682de484fd8584971d768c171d2e83bff16eac798feb0bbb53207180e2ebe3adc03d90e72b99f089646ad636300f87233822f80f77c0d80bbe1367c1090a4eb4f9554e378db9f4756e6a5345e6a0609ca0e0533de2dbd89f167779fe6ea3766e4a9dc66f92947f71813a3fb602886b8f3fb9e8baf0eed890b7132fdb701f273b875c46b44dbc9e45120d443cb4c52e5f4fcd73712f8ece5107f169478ad3ab05efc07fbb673d319b2c32506b4289ae7b4e9a72c267eded457fbc70034af787db533d0a3383dc410bf66d348c53c109009740590177383ebfa347cfeaba054d11f8b3a2a9ba8f62158124eff7f706022fb913b29c3f76a6d262bb89723d7b6e246acaa3ef38a9046aa121a877712b74aea731ca82b0cb5395f5469acbc3110119dd67adc3b82f884b5d5acd2657240134ba6f48fd180605f738e7de9bc72fdf2a2002dbb403b96d920e1c746da2ec67c7af9f7bf25f20a54cb98c9d9286bb472f79140b3d90e81dd8fcf5a922521310205422c52ade42fc9c4f4737954790179aa54c6188ed0f968575da0aa38f8353032b0d66a66dd25daefda7308b13cfc540114c6a90af6d2dc96788335f0407229f6ab622401cbf3b55430cf9462bc1b72f5af993c6d7696192b3fb81cbcb2da1110602574cc102976d8d916c18aff6dfc45409d8804fbe71e061d1a8823eec061f47c7126163b82fbac149020473b617a52045d1d11f56fd0bfc75cd2b0c1c7d030c53818198b1e892684da9505bf5f2f4b6646a6e412f4745f60eb65f1d0e58bd7a949490f538bc846d70cac3c05403d3a0f177c313ba1190bdbd6c086f1edc051ad9fdf238dc8890344584ec4f4909efba1f29a923d618d4d689842ef7569cda3ba13a687bbe844ff70531d645820c4cb7e3ee076237b9213893d531d70256e42fc1261b9ca3898eb3665595faa4846842529a736a7fe10ac5b4b1a60118f3a679143ec42f5e7cb2c43068134a5c9cb6c8f87d5539108a3614a723891b8e4d63967e48cf635441f3e7759f49c68a8c55f13cafecf80f4e53229f5bd1767fdc4050781589cfaf4e4beeb34c960bacf8fa2b94be109fcd76662459572e9969a649d25137c871cc0dd3791048364193dfb89de48844f021d2219b3367ad3bd046d7daaa3d69abb9582bafc9910a8759efa38d61b06652e8e63b7313328c6cfa674b1fa4c03fdde62ee2d36be02887b0d445815e59fe6cb9af5bc07af14ad6c7615da05626e05975ea0c9e51124237d2ad52721728009bb46b4080b38df01eaffafd812286d9572f5a7a98176a93b9a57d6c68f0e7616d08877c730370fff2c4f0deffd5d97a18d7fec519bcb9d7572128d46071491f91415f3eb1948aa5182478bcccfe65b9058ffff5a9f3869409ad56fac862c387365f4572d73187a66a125ae348c5ca9dc511cab99c16c5a22ba5145f40bd24c081c0802ecfee634cbe03c81a5a2e798d1fa966ab5f7181235cd5ed9e1252158eb410827eee66eae9f4ac44acd4f211513dc6000a90838e0d1282adff7830f8602d922dc7dceefac7372785721d20c741e66aaec68d8765410e3fdcc91c3023b87c5c00ec529100fe3d6ebd237873aa28ff3b520dd03adcef948ac84982039b7c3f9405e8e40ca6cc2390d966db457fd7aa91ddcff717f27770dc19f7c473f48b7248c58b6974153ae1358bf289f515890f68d498dcc3470c86f7aab99950741f55a096934bd27fd5ba0f27281a2e631a8f5287a64649a2f655f5bdead10e3cb15184b76cfa685e0e710c44548b237efb57df2f27d29193731216266fb3f46128313cb512a08aa04adbb95088b99dac93453345dc7825d1acded533a28f1df537ef9f2f474669b4639897b263e5449c7abdd574b39c2b3f8b25a2edf11e9586560b4e92a7b2d911b5688843ec3b6e443023a38328f76cd448fc6b445accbde9bc23e02b2ada559ceda0220ac082defa3a96838adf9102d8ead5274677553277071bca323e2e1ae67e5ca37ce02f74fee2cf604bb4d2397309154cfe851e742868792669b90bbdab03837782ee386088e71d76d7ff9b1bb3c177065481976ad14c485b0945896fbfa349e151625074f34560b0858557731d47d61b27c641b6b752488586071d1a87cb9314554080b8d8e186eb193be785813e010ed4a146f3ca892b8f4265157873ce7668ee4908a5875545702940ac33c7b6580535967063e057fe6d0c71d63566646613954566dbcf52c0d912faa72c112a6f2b0404ab4cb5be02399361648ce630267e3359a197b43159aa0493f906cb2c7b84caa3b50026dea5f67c870c0ba92e0deb2af21ccb99698c937621e615418aab466761b39af5b9ba10ad7fa8512ac954271a2c1a8073f862be0d8d7500cd24436259dea0e56ae6e787df9051ef69969017e3c0e76bf30a88c424680dc1683135043cc9a8e66ea650956daa62272dcf97a0db8ad3ee7be61f208e693a995697383bb47c213499625b093950b3720d5b5322426a5abee511f5fef24749e139e4ba6e9da23e30a2167d990d9c053e8f281c6e540df23adf875f9df905fbcddb2e5a329e331d82cac6aaff5bf2bafe2e55d3eb99701adc9f916ba7d0d283f50d9ef08c669aeebeba84d0c05877b94e3670f63ec654cd002a154608ac16a3612327313f073eaab9da42936f2413d34c8e48b82bc09fd0811e1df3f1cea1c8888ce4d1123506e29cbab8c6828ac79440d797a346621e3c5987f524e9d36c059c6427ed36824c443d0e84bde217c5ac44238060e4f0251697fa0556e405798546e2304bb34a676d57188dddf3a57f158d4498ddc7ab8a179ff8cbaca9cf5fe42195a8a745694bac584f571dfb4aae4309a56f8a3293e9a69aaf8ef3205a83fbf97106eb2017173b8f0d4913ce109b3dd34aa84d5426d7159111e4b18b9ee2b69f6b11429037a195adfcd507d24f12b49be08739e3f3f455c23b1ef62a8e9962f9487b3e58828658ae9a5af03cd93028d6d8588d58e6e9e4933058ed0096987be04f8bb8351a5c87bb943bf4c193cc41d40306121c1ea458365942e34ae738a6820f783a541fad3103e01cdaafdaf074f71f45c977f55f9eb435ecee6034991dbcbcb04cc448281d9d511f4ea3d316e3ca6817d5362349ab94406f8feb3ae15c74e732fecaeecb2c6d3fe209981abf66f23d805b18aa027c683f764810046fcb3da8e5536782ba3d5487d8f2a20d6875cc3341d714ce54baf2633c647eb20fb863a0d1c535cf69fa82ba3829a62478331b37b9a04434311cbd72aa2e2b1833aa1d702423d20e60be17505c32ed80d2715c09acb5ad4471873963e8667927dac2add3b97610927797acd072af9ae6f58e046dd6e068a5899da8b7e760bbb396cba62022eacfeb15200ee7b6a2a6659e9fdafc6f1fe309ea183f930679d2a33b8cb5d82614386e37657fc43e7a958c895bb464ff156a4867b1c31586f3c9e5cdd043e4eadcf4d98a30ac799d8581485415f1c6b4d7fefcfe9dffe1cbd6b49fe2155d3e5c31e2949e4105d0858d2f6dfae0a28798e7086073eaf9ead8cc0822e71b4caca8ad218d2e6896e478c4a2f3e2bdbd4ea308fe870d59a1087d338557a55ed2f009a50d21c739962b1fd32da3b1c9ffbdac7ca92c2c7e79272597c8865a87c78fc14e39863e5369000aa23b57e1b2b06371000f0ed83a95aeb261a170b97b3dbd9ea68932ba6e12aac310a72dbb5664839c0bde34857ea74e09add7e7fd2794329ea897a4668768d2bbfd4b181165b193acffcb1c639d4541a7844b58185dd6b88f2a8c59b13f79d458aab9f67d922bf8c6d727af6f622bf06c488e40108bd170b9211f8fe0504d04a63f9226ca9de0cb9ac07da11962b5b82c4a1b9f272f6111456c889fdeb4917d066fc60fe9400c32296145e13d957c0bad084a9132ae78b1746679d21afed97450201c7642cd7b79a0a010bcb1d5640ebb996b3192428efcb4fadf27dd15ff0bd6f88ec4ffd9d0e3c797a95dcfd9cc99c5e17853892442ae031b449de88c4afc7971dac558b80a8818b339e710716293d12b34438231ecbf2904be7be565918257bf523fff578bf10817716b0c4cf2b0781cbbe4a313e140aa5c5dad663d87dcf3f09c661cc53bdd062f2107afd71c720be255bb509d8272d3b3264c4647fd58e175f3adab9d85f4368c92e283810eb6c381aaee0584909becc766c159a94b5ff63b3e1eafd778a970cfdbeb40d58daa0424738cddc8948a5973dbfcc39e869d752fc5212ffc1454ce2a1a941d1c2b32090d9159ff621173acc01073e7e37efdc0e3a6d73d076da46bec5b799aae9f1390ce9436d42d88588d12ff13f7722180b5022e4210134b931075add513065d119796c3bb064e00498a0784a3996d47ebcc381c9e954b5d9e3fbd3e625661596885c15b7c75294d1a6973949d30fd4738d7d0d23eb41c4b67ff332c43523cc50c2d3f9f4033343da52c669113b4c7240cfbf53f1fdc887855b81d5ec117031cb4d206fe1c7ca07bf0119883dd4e1c36f313a7f81b00d920f9a8848e7249df802b2c3e773a6981ee0c7cb091df57b28fb6a1957b3fc83c5615abffbd815d624b9c3e791f2b192b0784767c50e7df0160af75ca550fcd060f317c7991bea2bc8e85f7aa69a3fcca558146ff759ea1d804a4854c30c62ef74d18f22f3431991c9b391c9f4b5371a0bee311b4e20fbfd635e5c552e838dd7f5b96445d46c03e6d622be903428a895a63b39af53fc1ac971c7ee9d475811cdc9fafbe64ad513043c7d092d5c0e37a320e7be949a2295f587313c1f430076d8fac54fca672bd4d90afc0898397dbe8fdab43994a160f6f7b080084ed5678bdca268e907411b1faab019076fe0bab0016777005a67faaf4a51f4dda979066639d943f0afdf0c8472b2fa05424987ccf2be2028f263061b62f93b2047097c50432bf9e4c4ea463260ca790aa3e39d376b63071f329b010c7fd099747ec93b0a8663f7ef5cf8f69fe3c3201a129907995ac1e08bb6a483089d6c30b15913c7311f1ecc53afb9b3434704a5d3a7736e4b3c47d42a53a6d0ea7be7049618455579e281f57da54eaecb1aaed4a7a51385fae1e4447494fd24b82d3a9b729fafba9038bb250e9954194b7478031a55e498c91a544717748c7befd15b059dee1ace30b988698267e82cf943980c13c323a23bc5247ec1a56722003e2e725f2e9be66d3daf5aaa3560ab4d1d11d10bc14ff63571312a069ecd4d7e1e2d144863db2d88bf98abb989f637862485b6b0763f85b29b8f4bf45e0c90492bf76011961afd9524303644a992404cf11ccddbf1abb337f8d5e3ca3a17273e5085eca9b749531f55911b48371b3ebe7a10132e85e4efe929c54213792fbb7cb98938dd8a1f81f5d7226e1983878aec39f7a156b9e2cc38c01d4fcd0f02da6bbab06934c86a299de13540e4c78aa82385015e453da0e72727c2c1758b0726f2a54ff0d78bcff027a1b060d0a430800789dc5e584d02510281fc7633b37214affbcea06e47f264128ff27643c63dd81748fac64c0faa9ae4a2dec60b8341238efcef099a5aa151dc6651de48d3b037cda5dbc05d18dc231cc0ded9e0e2dee5210dd5a89d8804ceeab5f5b5f0cd63a04ed8cb07cb15c8329823fa0aaa6a40c40529f4360afd3a4484bee7b13099180f4451fe711e4b563bf8316809a1bb2b79e41a4355828790d148c8a1f31775e87ac81d7b9c105a05f3e3444f85f4e9851ecd38c7781d20aaef7c4a5d464d832fa9bbaeef3286b53561ca123b5cd919b665a4c3a5c9453ea5014973df131fe36a16a83d8bfbdc885943ab04008511dfbe1eab1fab2b22d689b762dfd7256d73ad4b1a8f3d6581794c37e2ef8864912265a9e049ead16a8195fa2a9c7554aec0dbba8e7e24895250372d12f950b015f62811bc73229ba4275a62a8651eaa39620f70e7642d28fc787078e8aaf10f49c3ee66d6743d2e52cbd66227d36fb41a76e9b840fbd17df65f64f537c9b24576180bd1e7bf10e6b98783a621372cbc8ec1e2ebb6eb550a3a2f375b2e79c1a843f442c3a87e914e9e7422a5700846bab2f25272bcb7c36cc313586130a856dc1e76bab5fd381791b5a0c60a95dbf48042c45a855a336241da0be8f0703137de7bf5c72e44c2cc49445663145716745895138dd97924e6488d9049520d1db90bbb7561678d498c95cfd29d01d691d0fad69b5a273093e7f2295bffa03a2284b4dbc9c134fb2c7210e2245dfaf1f91f400b2e9ba4f5b756ebecbe6186906a91a59648a21c82d94eaae65ab15abbd1853fbd496bf67cbf1f559be70ef335dbcc127742cf64bd892ad6de0f494ed6be7cb79ecf4a95b9050ee149ba3d9789e3f81ad5e36bf5c0ddaf512106cd78bbfd884db18599a862ffe96af61d927b1f28e2e3415d61265de20626c93e56e2c6c1c19ab4fa1dca9fd85c14134262c3684b922f82604c80db29e068ebafcfb8658580ec7e8d8ea069b7003c6489932dbfcc7453d0e33b1ddd7af087c02c0d7e7ac8e461bceae93a3bf785e3e977a24c9fa6f4c53a29e70495d804a047eddf0a30ecc54738e00829677b45b15e0e9cb4b1aabd533a528be824d880d5d0f03f6f91f4f4381c505dd221c292889a69d180d8e896bd951ca59114fcb14d3b2de2d76c67a66ce8c1d9bd2de5797cb7e0e4acc40e4621ddda650f55e64eb3af2cd3eac03af5ba5b7b8ede032d9ba0299124ad2fc4f2210d320da94c244e7e8b2dae0c604bcffaccb8ddd9d419f3ead1c58d22de9f93cfc13c5040bba78257ea2d80635882e9ebd9fe0395f038cf2a91023fce9715ea80c18467429147d249d32ee9c16a21e688d9f29647e405ec100f44f0bb3c78a972859f2aa6cc1f1ed5f6d0ceeb103d938cac5e80bb1e15555a7c43b0ed52d905cc29b08dced8dd4ac60a3f37b7271aa97316ab9782643270b70dfb52fc8735955604d4ed4dc8d02c576d6e6d8758a68a9995902f7204a377bb32f159b3b31001112b34afe4b6329ebca55fdc3a22ecf78ed258978dd59d4dc016751c24f9051a8c1ab928fe9c77f58a56ad9d6d5cdb87b9024d83c85a4024fcff2adde2efbba3e483e43e5ce39ab2b3a5a48160303b5250c4caf6966824e19a79bdfe3e1ec529d34631592b6bf468e7e5fbcc37de50b1861be083e51ac33cb39428d21545db7259f3870d8c071f18618e1bd36499d9bdfa88ec40ab626cb4fa4d7085f73c675a303cd320a12affe95df79e110ebd33094bb3f6d58ac1879a52a78a2fcdc829118bf5bc6432f1486c5f0fba7ca4dad53d55f165cceacee656ac986e772c19b00b8f7e006383c7f302505f3da6814c41c1493607a215bc624f1ff0d3d2948a935c0813f5a78da6e0f6822c5a6a71c098235a36e0708f7d254ef94b6137b48add68482d2b3a5d4f27d2c0eb46471a21373df6f130a1a78984033c0148db4a8c82279da5c3688923c6a46811c8607acb8caf1e621a553f94983aadb8cb1a7347d0b8bf900ec66c48ea59617de6f25f0fb3981f970fd9a5364599739f286d002a61d0844760af72b6e677441f5feed8b802f575900264a5717933ffea4d4a452b241639809b1aaca477da40687ca2ebbcf2b734fb2b8e111a8f43ff6012b5ad3616d276000c27364b05db9969fb859968e3949a589414a03d2d46a98519a801c9eabc28211c8fbfe82ffcf779bc0c98d2460a720af308ae964f174aee30b698bd5d25dc2e77c7c6dd908427483fa3018f50521952fad0bd000970ddad34733fc8a3e83b87bfe1d89c0a36a26233b54209836b77a9cab7be8f3a6306586a318ef5dba6e7b28b6544c69eecdcde71b51b9b86306e8dfdd6f1187b609eacb665cd5d990fcc9e44c7c642b5a748614aca2cb85eae45c4f3d49fd2befba6728341bc4b054f2725d4dcf0e7876532b1c3128307d810eb16e966e14cbc7484f88719c3e939a856a836236c12c0895228d57b5cd9e49a16abf58f7f42132257f94e53572e16005a2217477d560335f7db4d0c29a55d4b1e426acc1a7226906c3e39472793af6ab4cb3b81336a33feb0aad55c72c80727e9e7c55903a13e695215bbbd9bd966bcfc5ef5539e5ea69817c57c884ce7e52194cbb58129eece132b7fd156365ba6247bc80e3a14f897df91757b51b2033975dca3c90828c982fa947a00c1d3bb8723944a9ef7e82b9f1b4e47147f447233e1d6d62e824d1e53fc45733ab5a64d4ec2efc4f975d7b4720c05a7d25085adbd0bd6e25d81f99141c9c5acb6bd15667105a6c3d3840c7db7191255fb386b9b0ebcb33187410c465ca04c5bced1595944aaf9ef149bff889d0d1eb008e46b92741eaef38a5576deec5a961b0c04eaca1aa9e023f45b6351997766b86cd400581022877d1aea333af685409f455fb6944534268a5e0665347c47ffa883e37563433ea7170ddfd5f33c4808ec49e7948627d8a0f1e1b1ed52f890897c4a53c12e73af320563676f6ba8553625461695a84c14e127cd62aab944c80af3a69600bfd34384d46f5cdea39e277098056d0bf11eec04da961d9e56af23c5f804d564408fea929a91a87c4c9a161ba1f125b00aa1ee20d935d70f8f199dff2ca1208f97d24da60ce3104c45435baaf42a4d956686335d39562257af504221b49605690d2bc3ad742a883793efafe2526c859393a4ae8a1c28f97f8f164bacf860dc6ef5425dfb6dbc87ff36470661f2c4d2109cdddf61cd2e62ecb41ca4f971cfc07a2bdcc6ae3e6f698e7b4a636640a06545ef745a7d44a3f0d65218dbb8347d4551598c86c01d0acbbd697162ae90c6c18f6a057256f67dc3d568e8c6692f5b3758edfa980f535af00361a37c17ca9ee03a3545e0d39fc931fba752c75bbf32e5c35b31cfe5b6dcbb7181aad8ee1410244d6f1b4cd751191734659ba27cbdd3e60c8b5eae0748f97cb1ab7646073c0ff27b634f8ba68e9c47432a182c4ef95670a5fb158087e79539ddec302801faa2ce66f52e6b3a68b1e320ff96d4b39aa8319e57727ea0a57ba8ea139941f1119e81df3f9e2bc6505c5c26d61bf691a82c12b4db1a436f4e50354f897a18d460b6148cbd075d24ce003c0719ca96d6f141dc759f1460bd43c5eac5edb11586a7ce814b69904a840e41b15364d208bf8d42daf7ef15fa344f0c844c2c4a485b258a66a5a78dbcb6d08d4609997f082911a0dfe857b032de2cec04712de415ad70f2880011b4caf8706ad7aec57049ffc934278fdb04e3a5be7ecf31b3d337f06d1f63d5d78d8376d21d679d9ce83526343b051bbaa4529396738585196ab4879631f8894bfd91d60f4109653b0897ecc5e99c5344f0aba378e57be1b17494fe93cdf7b41afd115836f07c68e91ff88de41d8498fe5facfa1fefd63ea1855e9a1d0dca265f11849fcae2f2cb7251a850124f41e58cb73885af177ead8c4d754adf02af5b20383b1c858629041af940bc669b5b9c2d49789eb5e8c97ed37dc0540b230b647b82a552a2fe791405620b56698fcaf574c780044bcf3071ac7b4f92e47ba6cd7637189f19803286197f890a7f634ac4059d87e7f6b1200c263e559a99880b9caef9ab392f24d207dcd6f77195936f3683fafc006f4b3a1b1d17a0820979b0f1a965946ceadd9ff401fabc59356351c7db65cf3ab03dc9b25a9d71fe749dfad391ea72d396fc04e16cc9582520788cac10333ff1b7b0a156cef65263c793be56e54db91049a5266c92809548ec0e9b0b5d495fb17045b0bccb96df42a27f53e8ab33207bf74be8cd3e0b445828d14eee0d3c977a90fe2165283a7e6bf882f53ac0b6d924cc5343fe43ffb39b2cfb78409d3c7b33d4f8c74fa93a90fde8f5eff721dd77a48626af7da23e7015a9e84154407dfde434f3622b91aa2ef7c8d5e65f96c7af0dd55b3e161adc919d68453ce8e15ba550478080f763a347a98027ae612cbc11e8dd432ca1f02b3faff0b67783a7ffdf9e7eee67e9d98687abc4018c50a2872924f4a2ec75287b7c229717ff9415b5302bdae0965dc0f43f19bb477c5da71c457ad564adb441a827c53310bee97fbc2f32e4cf9c150cb70a4c5d675e73fb939dfc563b8311e53bea4a578d777285a2b0c31f69ce078cb77039ee6e92445a705a0b99de68e9beb14f3df61361175ce77fc59278d82e137e7fcf3560081fd79354ce3ee820c68bd793021674a550c0b8cf9c2cd948f6359003afeed401c5268a335d1179e15a41adfa595163cda80c9a9e023821d597b84410a4cbc209c4382055da3b031fa82e815367253f21d90272cdf5055b34d3638d5f26edc5191a61181cc490ce2a521c12b7943ac362debb1559eb8190440e8a46ba6c678d1b1b903425a849f9dcce4a07575e663caaead500c29000aff17b6385bf751d7c7f4b4b0b673a2a9613006655892beab090aea172ea1ef3a2dbddd6a45f1a1b159054783712881c08f742be628f00c3948eefb435285ae630a2559eff7444b44e278326e1fb4011a6d4ac09518b2fc40ee480630aeb5dab1d86d163bd38d687a37e43416cca284f0e6175ebdbc77bb6397260e32ffc7763dce08baa5883e4703438fd53f7fa7f10eb6e9287872a07beff7661df07f24ca54c7345fab7342907e3df1ee64dc546706443df63bc320c24c34af656f4029659b668ae2c6d98cb9ab0291a84f4515e9635d8aeb8a9fce246fd503f823c843b5aac476ead67aaeb5c172eb0df5986c6e788addf21c698ff387b8af2ef285fb13b19187c9d9e9e0d4e15df8d068aff66adcdf2da2ad7a72077eca99a63eb11ee5ff02eb411454da8e534f2442cc8f3bb7ed5a9016a14d9d07545d337a0e16c96c95e6b3f7340e71280095b007ab1cd04e2f75cd1df1a6c496bc760d83cb2c08d6c610ce1f0f954cb3f3421fa7b9a857c9c480f170e4d092fc8b993015dab824c8d90ceb27c037aebf708cb659f2b84ac04d05d71d0d4cbeb3fe85ce3303015cd651b071173b4669f22d599ec86d1d4aeea5c6af766cb2d8f39b3aa3416d6cf000cdd5ce98587f2cfdd6469952837fc0ce796efab6e5c4f9106fd0bed96df4484e6627975c3c4e4c0abe2948f425329c41262e779d8883f496b244ad8b3a3af06c32281d31e713ad45d74ef0d49a14ac1287eefc3032b206b5fb81bb762a2e059528481335730b1efd61aec7662aeab0817045ac3807f775a446fba35bbea90854e73c4e06e9cbb2e1133f6c5b6bd4b70ded3015744268bda19438e435bd47e80361ea397ce31c7d5c53ea25915949e71137f1ec8d766b1009f95d4234de8085508f91ed0448e6e96abeaf0103b67af6db071fbbd20459fc575fc2101b37ac33cc591547ce3bee124c2569f614130d0a921efee880336f1c7599577e5fa9feb6930f45cee8eb2eee84d833648cff4f0405c75fd9269296cbf1f1628507e8bdd9b6c07a9fdfa4207855127936f86d54521662c5512a077a442326f9e6b85ed46ab117a46e2920d7ea1be71fa1f5eada1d229a3c85898b4e8500f130350336e677c2fbab534fd072c3a9772f2da7a89c080f9d1b74dc14413ef13bfc65a5ddcc236b4e1ba0775f620f37551cc757f688f4f155dd94b2afac8cbc5726993ca565cb40d2b1889e5cebe065f020000c91be6c20ed65b418b1909a29f591b379a75124d71bc82c6d3e89e0bf7002271b974a767a6668533a43d268b6d07e6803a804cd94356430ef7c03c19dd2e186c82bfd7c01af406bef79bd817ba86151c96d71dc52cbc685103e9c249aef06269251977bad931e6bae3f6dca161a08b8cfed364101bb9616626b9627882803c8c3cf29f534fa2bffeefb4cdf69918b996a61621b8404da8251574ac9945deb782229086f0fbb6f443f0fc61acdf74f3180e7c909a9609b7b52924c4ad19255dff13e19dffa0e495da22294e4601cfcaafee48019f6626825b99e037bcda046e3d88e23f1f9e0149b65eb1e792b8a1de87f2b48e7b4fb5edf5462c4002cf22a0ca8dc28acfdb33dcea6e5a65a50a2a8ce128a11964c2ab0df4c8e38adaae75acf65a585ecc60ccf41b23d6bd3e3769a0e7fd13854b0adadbc8de91dae0792e6c116bdd746d3b80bf2eeba173bb8b31d8aa3710e23425b82ebc8f54ef5f4c31a12f50284eddf4d860c68fae0a7ea5026555b07fb616116766895006c6078b0f5edf3174fb00be94afd798f18e69bdb801f26cdea9b3bdfdff53b65fbd3c63599c3d7353e226857d2e69b89d18b1675b55172f8eabd3a1a26cdb824f4b0109ef9893bd6e603018e4409757ef8bea8e789709c2fa3d181f4a6297176535660b07b8f0849beab120da20eebcb7ae2dee565bc343da42b4920c6c55484ef16b3802d8fd488c35f77ad55f7d3493c4826532e5c29dbdcc2ff22333ba3c51a532efae69efc6fb990337bf5e42c17d49b6cc3bdbd7c57ed38afc7e46b88b0f190bb91d9ce6e8fe8d2a672683b4bf1ec2e0af7b7d37b0b37e16dcd01ead33d1d7e03ceea2f6f4ee783ebbad8db0a40dac42bfe1bd2fab499af5f366856e4190d1f2adbea5ef31bb97366479a5839569e40495dd14c0b3927836b82b103f20db5f4a4cd0816c4f63adf867ee621bb50fb438d42b188fb1f18bf1478551fd7457c342399acd3ed73d36e1adb97932994bd736f15be11d7c5b80f0bffc51494ba122fdc4ed2bbd5d9d1b01653dbaddb921770c743988f3fd03753285a916956390fec3dd276d39255bdd5169826b1d240ec5c10d04a7ed6a6f22aae64130aeb0228ec2a679ce47207b3cbe9c6296a98250f2829ec9871ca4ac390aba65de64155cb798055ca734e995c8376c30a2f9b9de4673f485e67ff61ee033e82fe912e268f12b2655c67578c9a1953c66afc52ec205859ef9b73f43087229a641f57dcde7b4f623cb66d71e9b53e736891b922a6e7f2c92c4ea790fc5a25ba9a7cfecbb979f5a7c04b6cbf25fb935","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
