<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f52319756ab1645c71b7e93cf343b87a1820f25687af16cf92ea12eb93f11232bbb2f397c11d430d117e5b55833989d9a5cf7feea36a2ede2bb5bd70d3995042c3e7a7fac2b07edc4927bbf46c3852db6cb894d8c7ce292c67f091026ce7e8d8a7045d09095a5f6e6aa11cfcb0169261765a54f82ecd5bb5e716ef69fd32dfb19e39dd8f839c05b50305ec666b77692c36d15183b41b8155525f008175cafcccd185b79e9b86365d4b2a32a46293ec581b0f50ff65a4c17b6b7bc2e9ecca27b2e3cb0f30e53761794b87dc29bc0504420f085a87ca3aa8aa45bce2bc2db8e9c2184998e9811205098e85931be5f395df08bf8a7bb679ba79b8eb55502c901c57ae5bd6e24ea3f446c5e57cd6cbbe6d51744a3dd567c97c61508688fafdc9fb99fb459092fe74b31e50a6e3823d7ec9c0f99158682ac522f0a55922b7bde78f62902df04b7cd2b123d1f9e42d9977cae0c242278ff6aa457d5bc091c7236a5906c6a7427dd8b28ce426061f13f46deb92e7dfdc2acc1268a70f1c81dd2ad8819fd59aebf748b2a2fe4a41a3c46104b1872c5dec8f6fc38de5a82a930766b7db7cf4d0b7f4062f6ffefced203750db4ff79e99d25e27979dd76505a91f611c8e4bd1acdb0c74da913bbd54dcb82116a200434dda26681d180618d2a61bd9c571bd3462539318605c4a1cd993f3dce99b182f5fd32cfb3364a7f0ee89055203f5aac68bd5a212c2922b84bfba88f7167ce40f603a2f8dee5b07c2fbe6337da6d549c789f026c206d508054353936cb5a76b757801ce5bffeb6c5342be8c7b9a47a72399e285db627f40050d8a231c29995b9efaf40c1eef82202f1325b333be260ee0142b7208b4fb1b07ae615b0bfa6510e03e4fd20c08b00f8a7042a86938a2164847eb78027cdf6ed8eaf94406a4e0262f1ee21b9676d9455e6a8ac5359061413db74394a41d29f2415f68f3dace63e3327bb05340a0c67d4a5945fce1da00fa464e5a93f6ad0657124304988d213b0bc32cee705275b26425e3e03c22833fae427ce3b2ed676917ad39fd83fded72d026ef97a771424dc63199f104dad0336190757499a0dce6b56a8bb03fca0172c4703fa7b660edddd53827d9d8980a59273af2c0d0f1fcbfe80241f78a70271697ebd87545e64d385498e83b668f2a202e92f37f7712e563ecfa64bddff3d747abb09e11e209f21d8ec5508ebf454e796bfab700357b3c8d4ada87c77965255c1da7d0c2dc7bba8cb89adcda8387cd560b5f9a5fc2f5b66c2bb655e46998cc4963562c7e3b4d66745e91af9e01aee9716205fd269c5ae95e23f98ca3383de36ede3781e3873fb9ac3a4593e9fa2e103feb6915c76f118521194df61258d90b02bb9adae058625e783bed9154c9222056981d8e0cf892669196471d7f05e6629fab9885f6d1b4f5c4d7b0074f8353d6d2768628fa79f22c9ad581cde1a3e4962fbe0140fbd7f545bd4d794fbd16e475e61f51fbf604f4ebd35a295383f28ebe0cae09e40d8b7b743dbd177c6a487010437de33b3e4c4de60604976551b4fb74d2086cfad77956c7c5b9633e1abd2f3c41240ec0d45fbf0c44b6aa1937a1f133b08af3e230ecea2d2e361de9c7d119539c71bb2f1e226ec6038e0b246fa0410b2532570f8f17f7d6795db8306b6a56ff596633133471aa29cab1a13367535af11370a9319cafc81c3a7d5c6f3f38c0b8a982434bfa5ba07701cc22195e29f01ebfa96eb9e1be88e56b46602ae2293e11dfd07a16c863d67800e579fdbf2cf4d23b882da016e76d9b5f138a1b4a92ee50d88a9ff479123dc21d318cef19b3374e839fb6a0d1fcad25396c6ea798a23f24651f83e2c60f34e2e9cbe82f32af46ec24a2e816efc5ea339fc15e7d9b5dea69704f95fcc0cad788557e720562661a6539ce9fe9bfde78174b51921d7a206ce41250b7d6df3c5b85d0d917de5524812eba2068268dfc99bfa1aef332ecc13684feabd84377ecf102b1c7bf25ebbc270510aecdd7befdaf05cac43224e3ea0d626260ffb856e08fede298dc2c732025e536878a75619f4f6b19a0d6805ff5efe9d0c916619d23e8fb4367059fd3c38816b9d463b26186bd17969523c5ba2946d9d7e4ebc9f61f004007fb52d7e85329979cfb94adfd715cce015ede7b687d39f7c08b251a59a85cf18f790e66770b2091742faee874e25e293f30df120477168dfa533d456cf588b4e1c187b7033a9bff3963adcb1934fb0c704ae6fb9481f0d9ac74e658db4a810fdcbb390f8ae5763ed3cd258fbaf54a0d8370c5e9ed1e5a956817582bea0e2cc5102ac3a70ff9ee98dafb89efee01b7af59efd1120bf6d15b1c94de98b00824d04cfafa3de1b87259079d3a58774223d3d68a54d6ef39ada0910cf079adc37101573cca277fc05d6c588961c989e01416d8ac0b0a163405bca6af2af75b57f199bf516a4c2ead995f8ad36d6a2cdefa06450087ebb07b20ccdd46ad1cb28c4d482a1130e35e9dc91841b48f36349f8c34a4e79c0b8fdeeffcabc6e1ecf0c2da87854086a56b05861d551214aa8d925321c1d9ba1432e1d8d6e13e9a2df6b72893f5f628a622208728822b0f292473937100b1c3bbe9a80b1e2b284517e2fd4c653c2e39f61847b07edb14a18699f8c609e4d0fb708df4ba10376c8ace0393b41a51371c14c5c54c6e961caa2ad81a40fab13f7998dfd222ab02dd1ee65cf4b4e4f378c1061b76b6c4851fb68d091db6099087cdcdd2bc1fda42a5050719ade5c5f1ce4e1c3d4178e4da8a154fd288e95afc731143764568b675e98a21c80b7cc1a36b9b6d21c067e4255146cec7501f3118d78ed43b29099a273f8c1b4114e11d52a884d1255359b42af2839bd0a2c16ef78e961ace595f3c26309a3d1377ac741d838ae3c31a4a22f8dbce6a456cd3a11ad5fdfdbe4f4d4e90a29ef9b2d0880a27373a3e1fe3f92b12012f31263194039d6ad5afbc57973c37bdb2b9931e39208317ffbd005ddb6f5035a9bb34a0a425b5b3c12b7dda007fdab69532e32651aea5c94aa82a4c3e2e142aa25efed83dd53ec91b6d1335ef8627abd105e6852d42e1666665eb545f55ddacc1cfc9abed3697f277429684de7fe0ff198317a6e89e5d2bdca06e364d304f95ae54433524571c7140a525f1613617ed0f8231fa15eed7db1b05d7b6c78f333297785d76fe8a4bd3fd574ecbcb46ac9c58de92f10b2885025fde09b2ec6d85a006bc74c7af5dd42b4e0bc44e538d58aef8a4843f10db97553d340fe9d579dc7b2a26860541e6c3c3ce2fed0cf406da1cbd12b696ae44999751dea6981db8eafee9936d71e54b60a9dc324f0ca3343e2ee253f12f987a32ac40e30f47652e129fdaee958bae3eb89e5bfdb366d882e1a347b77c09ab60d4b957664e3cdbc063eec6e7f26b45eeee938866f75229a2be2be1e0b85242f1dbfc62487fb3fa00df95541ed22a44aa6336299df2e577a0c7507e56237a240ea505db3e703464c22ec1269af59fadcb1ee877be20421b08d6aff7541ba239bfc15a14d2d9dbe75b312c8c7332c7b34db46aeb4b250983499c27e34d00e25ec4cc97138ac3d87ffbd54af99a316bb200a79f03ac2968b046ec6e05668a9d96b6d46c8c462899b5d4b40ffed56f0004997e71d55f88787ad4093c15d0be67a8068897a26a1fc0fb5199b5304dd20eccbf72d6f2d10cf3576905ebed3bf64f86b530eb77386069cdf0fa2fa82b08ffb36454899856b65571207d694d747978b36002cf31632ca5851ef71db791ea909721f36973bb5121437db72b94c49c945ef50dc52d5e165367a7682cbb5743fdd69c98b449f5f6b4cd217cead6b152fe760527c7c3120756273e706f6399b63e25bddc03f127ac6a7d854377c7be7d0efb820c3f9ebfd67a39b84e350d122a65d7fe3e27cfd37fa43666446d5054615a814f413988e679a3d2c7902fbd16652087df6121892023d9f37f9ee73cdfc343d7e5cc366be82907f1f8ae87c98464c2471576a0f5c1767850a6c796f23885c0cd7be2074c2f2e9811c09afa56bcf3949c7c21178d194154aadfe481572b6947887d3d24b6532ccf79c6ccabdcb4426849a8f25b99236cd670f93bcf807d3702b201642b7b85bbf656ce2a2b85f2c34d38cf983fe6eebdb0e9c0f350654d793341ef1fbc412c6841ae6fcaaa8214a1b4e2da03a556f9ac786760775a2465d6cd9e3c0e6df23c4b43d6ffdc343b939f0c7fdcc4d2e4f080e477a4bc2813ea5be95c0eaa35522d2d3b7e5a40d8e707103f5b254387f08e0b016988dfe8bbc1e39b78d5c3a44f92365d3eeb5fdebfb0e39b54cbfb62d2c769e9149feb0e7584491e3953a739cc0d3aeac6e3e8ff776802923d26f3be02c0040a6fbd01bef8780528f5f341c9f797092111d865a69ca3809e1cedbd02a8199a31437788a91fef91cd3fe9553aa054f4b53b1daa9d6f94510d7027e29acebd62e1d9a291fac808194df3e1a2346dfa7a8023f7bce63b64ecc0a0afc012a09b98dafbd9766235c5ab9f7e76fe4f7a43ff578ddceb4af134deff3d8bd3c26ef5bfa6d1776b786736d52c38bb20f104781a745a8ce6614b6b56cbe2384927bb9d3523213dba334666b2c3c23b3d5af690e257c04c01909935d5af2671b48c62fd13d96a80142ea7048e855bf4fd76798e591eb6a6a07782edfcb989f7b2ab435fec0d4dd84595883b542966f8334a0f6f1496fad72470c4ea3a1a8febc7b8d75ae6c628b1b474813e095009dc92b87e952d5c02e878de82d9320b78f29977c2a691cb876944f5e7a2e20ac4bb9705fb9724d070c097e66af8efd25f0901e372d3d3e01afad3693ea7a569d785b7af4b0347e174558ea1aa68c6074b3d7dda346531d95a7a5a8547cf19f5850a63154875fee2ca44fb9df6e6fe9762a56d755f6c4046cdf16910d0e70bf2f308414355b166e7552cc25d7da7bc6a46d88ccd50a82be597c692d7e990e1e9e51fcd70b4c5ace02719b2f35fbe06f5f35f6c6eb4b5c648e36fa1e9e9345b6b16896a06308931714ace4626b03f8d108f4b371c9c72145d2663d96d9497e22c8635968e0713c014dbcf93b120aeaf2b48eecedcc99a4b3791a4e5238eaad109ce653898773c05e01b18db95115c3fd74774c0e9536ebbffe040b3bc05ec9d135c56a9ddcd446d4e9e35bb85f7e77ff0522042b536f58873b84e383b0e544686a69ec9b7323fe8587de74795d01b39504f3f6d869fe530b3f40c0798a7722d8eb4bab60fcc88ca56092522a251819bb857dc1fbfa4cf783ce3c42d51cc374946240e89280921761c7ad6167d4c522bffc9861a1c4f41f1766fd8f315d117fbc6dc78069be3fb8f4990d934b36f99c998172ffa73a6a00afe764f1403f089d6dfc21f881eec9ebdd8b0801d8f5f305c65e31315249cb5906477b53af666ae0b59c5be3a51aeb5e0e9d8d405be6e925052c117e1166a678c5dbad3eb563b194707c505d49413d9cc235ddf71c8dfe88e9cdd1d57c3286be7bed152e627086c5e2037dcc3ce1c36cdf2e5b0f12da683fcb047c0ead87ad6242042f7b767608a675359e35dc08136a82a25f6d84b97b6cafae0f54bdd8efdd7c4162c0a4fa3e0082cbea1401b8bef0d666a5e628a2ed38134ea945f0490b39ae18510628b0e2a14f5b09667077f8fd9aeeaa02aca9f6c093b642284a1a70deaf8977351a0483425e76ac1a2a110355f283d43e7c46efb0abb8ea8521073cf07fd1ff2c0c0500d47330d79d349ea01cb7762c5eb575a23d881380760e33c446fc573b167c31c4ae644d72330bacc86b70405f5af0caff91dfbb9adc6ccc4ae679f1ea8e3649ce0980ebf9e51c039b322af7d75bd7e309108052e0bdf959703cd319dc392199ac75180734c20c9d9813e8f193a15578fbf1547b9c2dd496edadfc51521ec3945b6d3fb7ccb667de72bd369fee09b4a684f9b22b9dbb6c59f7e5169a7dbb41aff8dc1b3a991ffaf4a082e0c86b09c4133d6ae9c059944f8f8a2104829835f6310b3b9cab04ebc03f9058a193c161034e3e7028a7b1e232ddfe9eec8d237ecb8c867e34d93b340892c4ed97050d1cb81c2581e7edb149d5fcad8ad2dff42b4162ef6bd40f9a7435d747035fbbe7bd9aeb4ba2f101f72c8a080ecdabb867526c8c053bfae723db703100420bdfc975437185beb2c0bddfae19e0bc3e63af67096268f2149f5a84e1688bd6077472a1b9f38b275bed152ad6b7a80fe8ae085141c02ab0e312fafcde9e00162a11444a9248116f33794f393857a3c9c9cf2a9c449abae2ab32a9fdc5ff30a4a9fdba952c81e70639e89ae93e9580ef13745121fbd3f4b36d88065d8d7242dc82f2f03f3cc9e33fb58be2dc14aeff89e4e37ee06e0f1552679cc3e87eff8be78d6cd671bf6cc90c7d798dbf9017d94ec8b71e078d36b49386fe120650527fd2bf6a0c4e9a1bdeb211fc17d06c059fa5295d3fb0e729d9f3139064eb168d19656722aa5631bd40228028e3d161c2d84e02e265605d02cecaf52d6c93d91a52c17befe4bef42eca40dc4a0308c3bd81166af85e9a3e090828996438c4525ca8df0c4d84dada8785084603da3cb2bada93f037fb9223bd843d04d831e6d3a6aec4e1e87d2e57c8aa231230c7da154bcb45c13d37a028fc825fd2acebec81501695631c6e06ae2c12a4a23cb760aabf4cd01c036ed6d075d64385430e13fb6703ca89da46a175645fc0baaf1e3ab64e1099db65ad06fa399d2fd8b042078b5c7b1c7217394a9f0046dff40ac385304e817681185b0caadf8ae772820980e5be2ae4338792d0393e81a8482401ae65a61bb50fdeeaf15c8b88b8f8e3066e83c10feffd912cae89c4f26a9255694d7e80f9f014648cbdc83aef5ee0039c87250361a46fc912f1f04eb6fd8e3e0dee9d9f19bccf87f90494dd2e292bc5f95454a31818a354072b49c56e7c4e4e77b95920cca335e074828843f65a93125355ce5b7ba7bed86befc80044e64793dacc659a1368d4bbc0f4bf077b07beccc53a8cf9c9cd1762183965a81df1286aa27f8f23db97129507be854ad093d953ca50a92f6bdb77384e0aafb4ebebd3a8153a91f362f637ba92ed23124b89c2fec4456e01cfc1ec5d5bb8f484130a2b90647e8672f41d936f678efa48ed62b717276aba45dd34cdc3440c552d2f3e340426d275ae006d5af4b27779c9e0bb10171db4d3869cbdcb4e1e2bed43dde79c5e6c5625179a1f94b06718a039e55b033dea9ed413f29febe11e14bcc3a5d0fcf23388451795a6bb87383e24addd41e5b8ee8a1a80694527fb0cf2e9d826aefaed5f5ddd6584dbd29ae2e1dc363b1ff44dc379bba0ae23745b10002add41e8622bce6685238d86ed33619a60d1c5d028b263c0213deeb74b202eb70efffd82f33ce79edbec88a70e03ebef9439a588a0283850c9bc61d530d924377bf143c96531793bd9ae109deb7b2df96a78447017c9d5e6ddfce4328b5341839578b3cc14152e69e78089474f6c327123438d43c445a6c8a85250d3a4c270f47dd2561d1c5cd4135320caa9e9562cd052f520b207ea19d89d65baeae83da168c69f296f8bc4dc6946ec712974a469e36a0acdf3f85c8abb6463bd262e01930deeb30eea468e27e3e425f19341f57904292f3fae1b82806bab016e2c97db4ac500736772523bf4b33977a2cca565bb564586c7ffc6a1d3792cae31410676dcc930b455cea8c7f243a31819516100ceb3215b6d1630c961f45a1428bb21a86d7c859a2e52555ccf96c26d9de3c7ed4670c2f876ae3a036ac09b09d58b48954cf5182334e66e1785cad717d636cd4e0f566f2473e1a64ea9e5fc8f38437dd24587c32e46beec63422c429f2c23249dc90cfd3539d4570a5335db9b20531897f76e0960dd0d0aafb3d7c1734e361f41aeab52ec7e3c0167df5c19a48eff826d70ea69dc4680a7b280a00e7ed4cb95bdf339754add14fd3c5b3f962c6e5b71aa114d8c668acdfddc69a7cb060b722d4664147ff36a8ff63215c2eef785144d0356a92b0af97d2ff9dfbff7a852d6a513eb683f79bdd3ec3275ae88ab8c2ee3a61c0fd9718d8f20b4f10a3bcd3b3a44c0471dc6cdc60a6baf3c83ec92d4fc91da8bfc3f89f0227e891a908a1cfe2dbf7450b049511aa852def7a9025b0c63ece8e2f37d2557beee1655a9bfe850cc390b321b56e9bfe38fe6937fd308bde18ae01deb45afd0251f74ed640723f4a6ba7b6a09cbbb8fa2d1089ca6efa7a81917d5e319b43aeb0d4873d6e7c6e9a4c1ecde47fecc7088e96be53cc2b0ec57fbe083b57bedecdc5dff982b0a16ff1e64392d4da8375f96471ca1bed1d5ec12f8e489b6195e940742879645e3acdd4e986d6dd3ae21cbd8941d621f0c3a5f224c6f6f810f30d042a9b2d83400709132b8c686615b1b53248a8d4a44bc1058337ebc880c18ee1b7017eb54bfb924b08adeb9f140af52c78a793feb2393eeff95aa05157ce98499191e65e9edd824cec25e9f22a41a227b47c7c1933a71bc4a06ec44aa2c6741430dd01c1c2eba784c5dc17994e73ed39ede1499c417d11316b12a65ef77cb0a4d5438bbaf55b1f46930b2cbc2ddb0ff49b9922d65f13ef054a67f243253e470f2d013eda2b837249a48e5c35857b57aa240d99e0311ce563c5deb453cd453cb9b99c5e5d36ab5421135b53c32ee8d91531e6b7f1725b245dc33c1fc854e1a7efb0fd52645b9c049ac6a8a7fc04b2f5a6a79c4a0b347bd3a98946792eec38de5aa8b605586ab5a640a47ecf4acb7ffb5b0a9abe9dcf730891df56465aed343741ad78f3715a8d6abc3a3975f1e55b348e17d4db9310fd7e29003eda3a403debd3b6974cd4e4e52cb14fdf63fa9a9b069ddef2b33599c07fff6962871d2011cc5b720c966e4f400a3210d994e8dd9c174dd49270d7bf7d2f8bc91ac0484d9afc08a9c1b11f759d21b1b31d57822aee013cd25588d2566224105b6387bd583cd6ef18996fd5a3fc416e6e0f37d337de76681bc8bb206b9bbb68d3de19463e298db1963604b07b85a0363a2b2d2b8bda60e835b90a430f0dc8bd9a4b0154b01d588ef353978469ee8143f2cc69539d24270dc76a1bfce848a248f7d7911e3a9a8e5cde862ee7627f7d35e5d0627320173918e23be39100ee552df74f26ca0ebf1d4bcd75734f8017f4cf269350303e66e3b8d79732affa63f3a34d49b638c46498a1733a1850ffbf057979ddb6f2d3e34a852cf6de72e9bcf5b1c43b70e6628663e72e0435922dcc2af61e9aab90a2c277a445dcd893cb2760612365d1c5880484c32f199be0d66d60a370ed42672bbebdcdcd62d76e5b6f78a519db64de63c7955a4649c3b984632df73f756f4bba356222c817cfeef84f582d60bb8990df7cc12cec1a841293d6cfba531e682fe3f6d3d908b9280a81be1d99ee713dae04bfbc3637f3d04c7e07b50c35486de33a2157518e40f4c40aed5c382b95d34addfb62b6260d683a713d40c7391153023b159f553e767526402e790d364528509d24ce5981602137264ab0a3b325f0dd11e4453c30f1a8acd16fefe779efceab7b995ea71c274ab7e8b5a9d4351ef3ef9e921c5c748a478f32aff10b9d55752c152b7638ff3272e11747c72e4bb12b1b8f961688d044d3c797c2ef1b2010c2909e81f7e423698e11a94eb6a4948efabcf636fd09792286a9e9ef3a0f207a7ddda549a5545ef675375a63e4f94498d2cd4dd3b3321f9b360b8da05fef99ecb69e99f34b62248bf49a276c8738bc7dbb4a2986d58a440c513f5ba3c0d12bb05590da2b4faf75b1aee41a4f4cbf45c061610ce65b8cc91746f5aceb2b4722fed3addf6e2e7eb903a2e9c701ceb3e8fb1925ce2bdc4060befbbb93b00ab709370c904f82dd0965acc4295bf50efc8f7f5c63dd0792da3cd84cb58e7b3a1bd63330d0787727885bac7e3162040e33e3ad02034e7ab9365a26cabc72aee9eaa0295b8cd653bf7940596f5c9521e1459986258f0eddb45364154120fa355dd6f55ba0d03c45f05ed6e12c13c1a587edcdbd2933db1ada83579ae529e4fbf19cc809d02028c47b2f52407679d16ca4b93b6fe2aa5671f1fa77dbde4d6aac80f1112875b2794009b2aef7bf822bd4a8bbcb4d02764d7d900867e5da9bc5d9f4f3492088d25d82a0a6b3613ed6c914d071177a48ba2e96c2c1f887a921d696d1864695ecbb7bfa4748b923d0871359ed95cc4ad061bdce317e3373c778ab3c407a22656571d8ece7baca957d299c19c3258a288b8c1e13a65e304718a3e707e997c511764a60e0af8689bc687d622505727bbfd18ef70d7bbd77ae496b8ca579afce19834da84ff8a4668b3a76b7667087241068171221e5dfaafe8c9fba03d160c98e6ab58749623592da7b613878fcc833a80cc4ddf732ad9cdc55fb95189d7f604f63a5e370cfd8d400ece6f5b38c687d6b3cd06d87b7c260a944abd37a33f92321d75e980aa691e3facaf524f71ea33e4fd3c2b59b13d62931e02dc0ee0129197c7660074d41407f13ff17f211a62bf577870f9a37890ee46d8dcc10a3fd320c2b9262600d137a0c0fba401325c60ff88d15089bd7b43216f7ba76e10f77cbd710dd8180ba5fddc62e932a8fd898456d02a45e740f03bbec567233af4fdc910a2ac106012a30328abba4c741065bb32eab23b17eb3c6d09485b7f78a84dad53185c3fd94cbbbd9bbe091485f4f7118bcc79d4e7760a9d2443402fff255682c58dd4ce9896023135be39627872e4a36e0d26651c52a040c5392795c1de897f72efe7672a92391f9b6a607c862636df413fbd9f36effb3bdc966b8ca49e3f3db3f15b0f5e962edf3bc67e5f2cd29b24779441a27805c508f0dfc17fcf10724ae373b0fd95539ea823fdc2133564def1fbcddf8e92ad0011fd605642b8438044d2d01500749ac90bd529e2d35f78771e31bc44229e44259d54c8d61768724fcc374ffadf396a7b791e5f870451d1f05768d32de1ac97deae1b96c663f387b59d9880c63b0084f997ed84b5c46425dfa0af60dd031e92935381312ee91e89e64c721d55c0d2a9d5409a41aeda2460072116714b7d243586ff973d7bb27aa0bec5d98244c0ac2ed3de65635836b7e3a825e475231684e8d453c339531623599521a879107384841224e752300a816931cd2f8d5adb6452c9a91fbae96eb46f1b7dd4d2881e2e9c918ced19badb21674932b57f433747723a2acd1577b5b7cbabd626d9e8fc1f2dfbec2f132499b61478c0bff76c14ca1cdbe1cf247e05d85037c315cdbd3e3bf3cd5a06595e99202c9f7799dc44ea21b096c1e50af40f93ae9cd4026ba154f6eef07b343b58958cb3528fe70f16f6e5c3546a5cba715b006d0970a4760fe63a181890eb82397ab17e27ea7ecf1fe7f6a72d6474c170fa33b15c7d625ae87cb8cb8986e8d8a81961dfe7339f389bd75d991c3313862e6dbacbe560820e75a12b726797bba8610d45d7b657fd4a7432d43485ac193e5459755af9658021611b9f2e0c6bf1e302fefc58521a173ff6438d6cec763b5af269a8079876318df4ef603e8602d576d086b362d5de8667f82d52658bfd6c79127c9d58de8e18bb88914dd791af72705fc8f9a7cc1f34449b34b77889d2e518df1c159d1c8fb454ef5f00cb1e8ca3ab544a6bce8e07f14d77e3644f56caaf87b9a5e61b2a91162cc726c03d841f659330b6650f613066c840d6a593f3480e6349e3ffed3e6e0a1dde34c092ae9d2f2d756ee30f313a301d19e4d95debfbaf443ddca1f3f6036034f126d6f5e5397cc45cff52bc880a68e7bfdd4d328c3ad43d34426cbf8c1d9582e264d04f15cfc586153612f4b1d9da85d45b219a4f17ca42bef774dfe4de5b23b564d34eabadcd36b6aff3ff8cd0dc69c0d0c2a7885a4eef827f8b4d82fed41e120610b3273caaa43cc6c4bbdf70b434eab7e80090c44f4cf0c20dbda04585bbab5dc019e860ff61ae5ef78e7045d62230f8944f74c7e499bb32687e194f5ed3343943d98bc604a62e5aff1c4dc52276bcc5755b864c6d9c7c1310d5ce9b4cb5765b27b298c5e72d6a1585611d71dee3617c59bb7253889a7034d85378eac5267dd3265f81e2bcfc3c24b0b08caab45774c22a4ffec52cca87967224769b5432442476b5d367f025d6e81971bb497ef2c3854fe6688ddbe325bf409ad7c4c002230b83057233a0a8c561202d17b6f051e83cd134c21407a9bad22895129158679dda4264da74b7bf79909e81144e937a6ba67d664279b0486ac9a7fa03cd9dceeadd834d004de327209c47e5e0d58658acda5e27094c9e3ab5bb0868d9a1015eb9056bdafe538d382e707edc2c5285d78e6ef47269efe0438148b34579f133b5771c75b274aec78a5fc81cfb035b2ac5299512557d4b51182730551527e2261e34a81432aa3a0fbd5f9e32bfae1beb1feac8fde2a80ee09d9fc81f68dbfd0da886a4a3f5da37ced8cd96171f1a677c452ba8efecdf5de51588a20d4d66489c70703e48f44600dac697d90462b6072ff755f7567074b44544cb262bb853d911e1312d8aad2ddbaaa85d128f9dbf4caca0f10e25ca1924db5ba8e797615c259664b26e830bc8506ce0efc754ae52d4f86ca45c49fc762ea252651cfdf7b2402ae7e39071d84904c153a189e0a6fb759060aa3cca13c107ba3649712e43657b444ea722594fea657503573750d3d7d6ebe52380d9b372a230ba31adbfb5adc647c55b7fe570e3714f332c25889dd2f42ec6c1f49c0adc10760264789a162628741f4080790dcb13f4d1666468b8c6758d25f7fb108727491bf420056ef920248fa81cb3f508e113acbe69a85ea3025ba3468ea83db37cca69f68f2f2d60557249231c1488d5de8c5ed3249388162b0d0bb1e9f60f1ec071b52a0486389645b586fff64afb4db6b0665b757ff3b19b8abb2613707af9dc0ea5e0375d42954079c8843f05e0f83d17f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
