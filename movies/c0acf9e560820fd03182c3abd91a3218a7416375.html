<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8ab986a6f910b8c66ccc4f42751d505896bad1e527a99813eb0e00fefaab7e08544ef380955c24f10f739b03f0e9e9aa1a24bbada3fab98547637d22dd0f43ead56dcf7b723eb9920a5354d6022ec8dbb835a27684bd1c59858c3d477dd027096bdae18a4c0069a6b24c70368dd2aa7607d87f11aa67af00303950c271472bed66e2eb976ac60a10d9e751d257627c95a61224590370e6c2db64f845a513ff2650655a2728ac42799432bade2e5eeed8357dda46ffd6da5dfb4d00d1c6b5ff05eecd07f0674722ed418e2fdb77d32439cce285d1d1fc60f2f045e428f5dfc7d2ffa20bb15cd7037b3400b10fb7a48e3de814a58f2a2a5b4721c1f543b2517b3a5684bdd3cc147a204f987066b18419d82d3252fe3ecc8f3efe37042d02eb9eeb7f2a17894e3a513cbc88715a481b21fc935873435d61316cfc1f3270cf99b99f0d54dcfa96e42f42a272c752bffadd58411e23de36c04337fb36917d074cca462c1f2f094dc621727b8280fcad6c766454f270719902183a91dafa0c79bbd30fd339807e7a470d5c47ffb92f0384ba36e265414660a647474ce676ac6050223284bf532eb050bba06b7fc4e67a61b6dab1f4c8fcedf7ea9723b15a0dc061484eec2b82022c8bf774726c826f10568695ce6f315f5a3798b12b941b66ee973a7f8c5223fb7c7169f9658f28afdb1ec8e3b214cdfe9deea8027c170a3b7622fc55af39c464cac7c5de24b5cc1d9765ee6bec5e35c8019acc344c198fd9d3db5a92901c53292d291f1991d9aff44db275d73801c179c87360cd749c91b2e993e5ccdc3f5ad8d93d5d1951b3d3fcf1774deeb90faf10fd7915ed8d2cde2b46a43f35f0b3afb731049c557fc90d874dd176dc54acd632101dbae511463897c45796b554088aaa881c4c2c435314af596857fd2a8c811fb934f513d0a30c165a6a431aa9a33c313497590e6b4f415f5148ea1e8acb43cb6b4d039ec742ea3a7d8c1005e8b6584dd8cfe911b7c423bbf469b4691c08c9e99be444a04f843c003842a1e50f1418ef4aeac53015aa3443846eaaf04fe3665afb6b79c72e9c716cb65741413a0ac4a245c916edd7c92761bd43b283047e002f570d03fbdd24c77bac8a884d1c678e7945f93ebba600b6e169686f083e8619e97ec92fdd964bc0ec290832bd5e3870448351f7b0fa527de616596876788c56049e2be155cace91f7a37f7eca76e8bbc1fbb345eda355aecb9cb089176a18123d272cc61f71f7b0a556cdc9721fc6a75318e6b859ccb58d24b2eb11b87e9c1b91a37b38511dc0515083c86a96bc500022dba50d18d9ce5315f42149c81ca22764e214b36016b4a35c0e1cffb975f9f0c7afe2b2400c4865a809ae5d3ee442167d06e9eba9e12db90ac537d450b2fe150ba13304d6af4253f260b796de478f4499df5746bac8712281d9d8e064a37e4438ce6a034608fd252f685c8d3a4b5b2bfaf34664ed7a17464d87b2f0fb15c58d5f47442cea26a3b45e5ed1b31a39cb41ae4438f72c6d21fe9d25e3c2ce28c19846ba3ac22c9ad176dd4f81a02e472c9b2348dd68184d358705650b1f952d9ebb27d1e95fea097d7a7d6e9d0a1de3552daec66a41f0c4f8ca69157909bdaf8926e863847bb50530af3ea6bcce96be16649ac1130c7b35383ff3bbd693ced237ad771e68494a8d8c599b1d4d84a3af5cb9aa66a36637b22f6c5d80242730cae2123ce9ee38587af121c025d614991fd6620a69adae684e11fc6333a3d553e19d4ac8c6b4c5efd44fab499480bad1274f73093a19a3fea1215adcef772c7465f78e71f7c5e4bbf9896bb114fb75e2f8ff32ff5b633195dcb5705b4c772f4fdb94c6b77d1b180c27d5865f8744decc47b883921459b536545059b347e3f6153637cddd564684648446f7bbe8d81c72858f98c1715eaa479903b12da9b527dc064cbd29877028dbb5bc538baf916fa82447e59c3d221f991cb165c73f3769a86dc366eae93aeb033635204986761fb317f1d296d561345c7027a35a1f492ab3c958c9525b149c10344e0eb29088019769a49807d3a6ab8fe2faf88d7fa6af707f64d800e6bcdcfc5c9041b20587f4c0e07806f7b447737be57bd090c64687e36460aa239be4353318da706e4a5576916c5ab390377c55b8a59e38e7a828edadf38c630d44ec2f39c79e12b2a1f7a5948f64d9ae34a316fa9d3a2fe57ffc6aadaed099f82539ee2ccc4ae2b4282d1ed173be253860f6dd3ed650751cf2e274badf5acaedcb584c9fd488fa71aaf25408fb024822d1e1567bbcdfde3e1073f2360ad6bd6e56bf0da84395129e34b1dcc09a0d9a7a1f798d61a9e97815fe15a8d73debd5875ac016a58425c9c595b11cf42e8aeea31af059a1e2f125124e62b4cfaf6894a85d5773307133cb906cb6dd9db6d21483703960eda0c2a339e1ea80e9977487c67dcf7789dbab23c3c87b2a9cd8066af374e22d9b57cde0bb0ce2393043bce967915c85ba91fdc4ecd48561aa2b53d6b69dd68e023b1216f196d1f8e3ff31aabc95094961483f169258c8d3edd002a2339c21905d0521102875b29a97f3d101f140e3046f0167cf9f0322bf06e4d93bf77c850ac2e25c814fdd7d2e42416feb369d68b825cacbf29d052b35f98709bf2bbb9391826374c169010a6cf5fe1174350e6cc170892de79a06fec3c7b7f298f8a58a94f72039d4c238f3c4f2734fdbdd485f47d4b5a8186b9d7647a2c7a1aa14b80880b7de5c068a98d75d2d1f9f5283c191b7db5981c1b9dc4f42a1639f5a4687cb1e9bc9d69d0576bab5a09e786119fc2d2ef108cedd9dad722b0e54f767dbe7098a4cfa5710bfa5564f3492b19cd771a338ae4616601af76f53582b92b112d0b0205d5072af187411b6f3b20061d2e1b89fe026833838fe9fd69dad37db99909eb4d5d7a10e2ecaa382850be1c4a32c8da796692c59c2dd04774d4c33bdddc489b2a0738037cb1d743ab5eaff13ea692137636bdae072c8c2300a84f2113868971dd51ad089c4d768b1b9c69372d80d0b1bd8e256612756a11f0c1995624f44485e52eaa27a6ec041074d2289fe6bdb62a8c4b03e9e2f68d114815effbc092aa9edfdae3cc3496f7ba1109d7fda05b1c604be95b56bb4fc054eb7948c4351bed5be3d2051d21820ece7f686b408ea7475daf7ad9ab2ed5b81f2e6d8300d9f3dbfa8a3f10aa5fcd2042db9932857d07a469aba0c9219d84cd130bbfd14a02621b6402c5ec6e133f6c89924cd0754a8e230f564014aa57ca80417a942e5679b247c56d458a735208aa16e0834a4220a48ed985fa53aa7cf234cb5f310e34f297e95df95344bf6bfedde6982eeaf818bc077367af7881a24b8038b93924371b5c7edc48b947e59253b6da42fd1c0a0ae51def574c33b149bf5591d2d4a4de830ae75f89278935efc86c18edf92238b051eeee82d5dfd93916f5b380f43d03d39ea08b235afa95d787dd9cca6f20d8440bc2036d5f2c65134e7db9825863ca5f955619132b8aeeb629501d81b7b6abff4db69208b7fcfec2754dafa438330289b8ffdebd8924ecf60523e16fb0c40a7a57c9e87e5f9360c7b12c475225f97ea50feb76a25fab2a0ff86952cb05a04b99115d35bd11022f5bf08147992eba147ba1c250a91e35e9bca9bbd67ffd721e12ccc23954c95c3f93dccceb05117f6022ace0d51a3487149f9eeb674cfaffd22765d826feaba14212701c7e29942e0caf65ab78db392a4c7683738738af51155822c5853720a80eebfc6e736905eeea10f96991e72cae25f5e4fcee26c8829506d9f0652f89733c408d16a3689857e21beb95b6459f5403612dbed0e838afc29bce6d404a09eb06256dc642be6605395085cae2558fe276d2a1c4a279b1fe936cba1b2e8a55fecdf35451125987932be97a7759fb7077f3112814a09bb2bd9dd4f99fde020a893739837f48eede1f8937941a21e99cd814ad10dc796b40905c6d4eddefaab497ab06d372094a06e04fc89e6f156359959d2ec904cecf20b796b0f1d6a601094f86f2a5ef6791c71ee4b50ebf3133ec4d0d2c3fb50d4f6caeb66691e6c63bfb0b1361a423b23d4d51c2a8bc5c67deb9a89785379197b812f3147900563cce0ea61687caffff20ec03fcf925fb43e35c08446a26ecdb2b8c71220c1e08a92911a24096c4aa924470ed3acb3389e6b266b5218f871fbf1d509dc4255da4f3b810e454897298fb30dbf090afec7c338ae1f29d4ca3abd6b11b98ebd8f4b7e71778afe4b148263795cffadc8089d85afc18cf3909ab840deb03814b01fcbf6c559d9e8ab80af42e8d27620c7ea4a3afb4fab490625a0beeb847738aa99ffb00466631edf10d5c0d2874afdaf6588e1118e7bb2f77e37dd63616c18ab497aa4968f7bc743211d0ea18d868c36ae346af448d02e3fa4f221163a180d40f22a0cfe5c67e62b903ecd59c01e8f5790fcea090296b982a075c1f26d2ab31217526d90d3a403c0ee7673548336b073f07487d473c9804657f01cd6c0415b4eadb1bb9d64bee286e52cf07ad831b8404858e7961b56170750c27274426523ac317767d732c414bf0288e9797d684b7769beab81481d5e3603fb638fe351ad6cb975915a4139db6c9c01be0f9601ffda2fc3b740ae83609026a75f36dcc07668481313257f828f0af2fb1411825319bebeaf030cd4b4813b752faa9b45cb2d236f98b47845720901ba572961501af3336fe9e951d3ce851bbbeaf91283361905a2c8cd8bc6f62c99a693bf04692ea67c18df41afff62c40f009bfd5e700322ef04f6678d07715f168a30ce5a5cf29aca9f6f3ba305385225fb715d020474c6e88b4d1d8f7a933a91ee36d26817995685ce102bcf5f5db068f1d318e1e6f9a45847a821f9e0eed0eaa2647028325eba1016c8845c1877b697c3dbf4a6a6fe738497c4e441699efa65172ebd4fdef592cad4450c424adcc88ba7f8d9a9435a193e3878eacdca1fab5fb044409215c951e5195971a17624fe9a3a33a621ff6d9f717e61b54e70cdc9c17a29d48b4eb26069d0d63c4186d4acfcd70f1ddb6902bdfd83ba3ca3d9342ed12b9d7e3273d6818463d2db4c5d490600281d8afa2b545bb52b433948401c73e16e577efb7b8c1e386b1bb01f67456dd5a94e8a23e52f79ceaadcfb2e403f82ea4200fe0277e895e9b38f1e25b26803ddb4610ac4b4a3cfbf003a0efb639967bc32cbf278de69c4983f5f7de606d576ddcb3c20006f36035ac70bf76672a5c6b5ca14e74da7bdceb586e689471ef04091bbaa2a624bdfa9243771db14074f64bdc79dca67c265f6ed727198ee277191214c3ccc278740ae57941d062cd19331ce221ff57ad7ecaab83f21eab495724e8a967b2bd9382d4ab9628db4986290e2ac1eda7995541f68c584f97ad884b1873cc9699c363e2d98e538609199b69578d92bedda136dc68bd19aa2676c4b8f9767fbebdd869c6614dbbca96fcec6d0861c5e3d679dcb7d855003ebdaeb9c2373fa176d04608f030dc3ab4f78ca9196d23a1cf6756713b60e8bcd167f616b8d56af44480a83423ecbf54f6ff754b28786dff22a2750eb36651422b1acb95418f18e3a2942a7c5576492b3740e4e25c7bb81c8965767dc9354e4420b103c860cafdc899688624019b6c8a116313bc0fca9cdb5b2257362f4ccb09d1cfc1b6db349ef54a233f75dea9ea1aa04a612effb0bf7706960b6aecca24f2bc48b9080216c7cd20d9e554969a15d4a140786c45166726a66ced3772fbb6fa7608eebc2ef9f88de319b5c0486fae1b9d3710e35b81d667b82117d2e8ad3ad809210662c99bb3854874d2af0ddef4eeefd5a21ff4337c4e3b27009d8bc84d7b8e54b7f63ea6a98e1da55ff7f88411293b442c8e83206339dbdfe2955d31b6c75d3ac70629eeb5fa32737552e3a421d25de9a47c6ae7888fa9857690e2e58f193ed60507694afaa0dd04f28414a5a2e9d8d7cff279e3601624f7ddf56b81d714c64c66961444ba5936d09419ecd1bbd8280891f831c4e051f022c2e70d15994966bd51e837218c26ae1cd0afd38e40810655aeb6c5da5abbd51c22a674f9ae59230a5024b5cacd43e79ecc8802491371de9cdd9cac4eca125803cc1eb1e3ebd23e7c25278da757ca8121aa639a223e9796b14fb0b22a64d8e1cdf9afbc89567c6ece066a74981bab37c6a2e75d33c691d898984b242062c35dc830c00727648c38617f1bb895ef13ebd0cdbc4995b55b9a9196086ac96dadeaafcbee4af2fae24a4b7792d531c12682b116a8f149ba6c46d1f858e53f425ddcac21a1806b77e6d22e113f2da1ff5de150ace5f196a38a73223cd141ddc950d472d0f9e06e002d29da4e7933040f1a3897161adb3898aea42230b82e64c77789ee9a8c0e723b735a90874d50aad4df3eb791daca86eb8daa2d6f28f2fcadd527f2acd3f64785b53d3797e08f9100ef95e3523bf156e1827e02e8d8f7e82026ce6b91c457592b5639b3fdb41f9fc32ebc5f18fcb447997bc48b52a84c1d6225beecc016c4543d727197a83df4e983aa6f8cc85818108e25cba8902d54f3f7f6fba1e13edd7ece2dadc0dba2ac7aec46c50ef30926ba6d627302436559bdbf6876c3254534a4a93af660645fd94eaffef8c16071043aadf84ca467cc7c73ba346f2dfa8ba8163caed24a728781a6dc14294711f2cde21b2b44e5873c1e5ff9f97f472d26b9d7b449ebd5c122a882f4fd0bab5c6baca8a3721e417289db83ecfb8436821c7f1ea4457f23d98f77d1f85d5cf031da94d86721f792209164e3b45a891ae70ec0bd8dd6e2fc61cfe0cf680bb99d2bfcda2a864ce9e4965f62e72714d388dda1ee3b44dbf63d17cfdea786f08082f8ac0b1f5550177f563bfec565027b5c20e5a5d111a8253d628c49d74fce41836ec55db6706ebf5cb679ea986e562943de45d0c7fe70791ba1e4d33e91a46e39da352a0286f7541ae562f4fa7009c50df32f6c707562c06651ea1242da6be8c03e3f3188ccedda53b93be16afcf79ce3cdceea2ec4ca48e0c6f63a90c2aeebb83187af6f132f62d37e800febb14c8a75c68317f563b9cd054b65c5c1ee74d2bffe08486aa026f90e5079d6a503eef7e5d270838652f4d8b668a5372c0a6969ab10be5e1526326d7004778ee0c4a02d783a8bc28f82d84e501003651294db61553ca04188c3703ab841d78169fcd4d80ebd5fb5a0c4cb9069624fe008965b449dc07cb9734f0ec4d082ad7924b44d7d67ef13a2b853050f5882bab14780dc0574860fde7fb0b936ea4113d76312533efd5cbd4ec72a6d936cb7ad08f3943936d0e2c7a581404f6aa688502630fd5b53bfd5bbf8ad861571f2824ca35d92616674ee4a3be6eb30b77690c0cdb338d9096e1f42500c861b38a0a8ec5e79e4fd1b1cf9868481b58f81595fac6fa6b4753711a732ca7ef3143552c6360568b248d614b72fb7fe454f1da743a789191a961385779b0fbe3bc4dbe0f32ea592b0f61a664c3b7f277c67aeeec38df3cd3828424c4701d56ee838a4b8a24c7611cd95e866a49e889194c8ba8deaa91a00280d9daefb36118935bbedea98158cca48162234747c8eb708cb0d6803de886b160254286be4a2215affb08ea5843215867da6a046821a9e0c64e023f26987c522bd5944dc56dd6c09d9b59c0ae2631efe1d5d872c814bafbec96eae4a22f81732e4153842be34cf91351bbc75441357de08409406646f4000bb6a2273600b2e9cca267327da1a6ebbfb729d6b37eb292d5a347f58d03fcd62288190d6f8f43b652f1cea5e5e736b3b8c1f694eb6fc70301fcaee69c69f077bc285bca8b48a47d50016795939e94cd41998fc9068eff8f384661db3617c3e5482fd460f5f157eaeaa1431854e7836f4d6160aa0eb2d41c3059c8e8a08e77fdbf1f54e880ead0a906c293a165ce667b908cd61a696dc70ac31e3e44833c08dc7c75370445bcf958a0e056eafe9b1c5e77f856ef86f103ac4bbcacb04b84eb488f816a16d424d3527492b5acb93509042097d44f60b5cf134aed858f5c977058233bc3914d30e602664cd0f53d34a18ce0cdd6b265d0d27d97b9ff0217096274159e9c89ddcc686009807b614a68d149ddd0bac28b38a46e659f0ba40f8ce5e1dcbe84796dea1b185743be109d27292c1ecde8cd24efe63c28f93a7154a7de77f204dc664e5c15e18fa453d989bda55b74d26e57ec52ae1b663e84652dff63856cf840b27f44a2bda02edb69e9226fbd6eff2a333deae15fb038da44c5b1bfb4e1a670dbeadf717f436f1bf4b5fae56c8cb7f36db1e598ac2bc7c2fa56cfd50d130d4fd1c39784dc5d5359e5920f77c9b5d6bbede717e1fac3b5b7eb1ab812302fcbc879f1390fbcd612ab5d219986b8e5af5ce53b61c8a84b25845f6754af682eb9d4f74d9615896408977bc52d9e8100c00ea4c33513e590557d036264cbd50af5f6bd86d5bf3e5aa316931bdb75f40deabc2d705c1e36047dd31a362063a086a9cf2c24e3140e1a57550a25f198fe85e628bef6f74ac11601a4d0dd2fd42168a5b344597485ec5c314d52f2600970e3acf672dfb83d17e974879270f86b78b9b8f08839083a5a4e54c7dbce241e51dfb32b8fa851bc0c0a99dae641d65e79cf9a010532aea842b451dac0c94ed618a9b0bc32338160299c8d6dff73a2611602133a7018a22353f78fa50c730ec68cd63dda83193f651cb6f5e3a753908c27d49a108d5b07494605415eedad483449541e8d08f57190a0bb8762d86234a984e20d6b2d4ed9fac8ba80ee63505722718e408c8422ec07b230de51f50c20a03facf744971a37ef0b0bed1fb17f7ef43e3930d7ffe3429571d4d05399bf08c200785c8953d420ee7465cb2036eac5f3d8d985a8282e3418b62caf6c5af7cfa14fcdc3ce78cc085bba6956aaa2a2a0428a8aa5d989c470e5074df1113d6f5a0b8ffb1b6e99e7da17587b94e49551622c2b1cc94103a4f4305bffc8b209f762a32eb65583351499932fe999dcea0be6b3b8c7870bddde58585833670d02b7ed83c90e9ef1d572405f9032b5ecadea8bb3ced016bb3295f30e9e9ed2f720e1f5c365fa523e85b41a5bb61d29e487c4204c72bcd53cd26371a64fa8eb427c7e9b3116b90d7bedb062e6f3191d484a306df9bc36dbe608d146964bbc964cd41366af5af46d4edbdcaae104c00b4ab214f15db561907d9acee4e5f44034cad6b6a39c2cf7956a343a4e7c3c609fc514cb9c7ace32f3b898cfb9719abde1cd890e10869f2710b7671641d7d4ceb4aeff439df91d7f2dd02a100eafc9b1f525ffb60b24b8969caa13c322864a7a2eacbb9d6da25c4fbd50fa9c8b9cc3fa6d6a81ed021552186591571dfe18641573a52d3f4c7e3cad4af0ea798a52a3fedc4b37c0afc51e1f23f5aea2ae9e8f899e2769e66beb7591fc94390f39561f910ce42aba37578b7143daf47fa5d26f5bda74bbdc8d1e951714024e7ee03dd99271dadca794e8eb3de9fbb4ec835dcd0018de829d1e40e739fa998bec3e69f337aaf3b1ee037c63e50800ff8a842e0badcb1b50ac32d0568e89bfdc7596ffe891b98c39bae29f81f3ab2c500be257d34fe32f18dba1dfa05765bccc6b84370cf5e03bd5ef1df67fbaf5d78869d5296d97e31ef52f1ffcb63ae071919d40146c5dc22ed6402131c2e9144573542d0af0149be6c504e30532fef5180fa8c37018407a6b1e237dbcbcd4ac434bac4d95e2fc1e5959e5d13bb0bd7e08cdbab4b2d726ffa58af4562e176b59d13c97e19860f45bcdaecb4b51f0011cd143952e01b5047aac9cfbb40e05b9bb01e897a1c03d33edc4ec0253bd3d72a2e1ba2523feed2072b820c2ae4de46805be80a32a7d2d5e724ec01413f2a15e8eb140fe11fd41c097889d036f33ca92433ab393ab75733a0079eed5b7fb0bd84f431f83f45e8ec22bb4eb010e00a82ee3b11f4d1269117a64778a56e170a5b8fa454cdb05a4521066bb52704eadce88c74df22247f96fb4fa7071042c69636bd70053753de21a551e36c784044b60c5b509c9348f0a38aa50bd807ad00a5025a372ee347eed1618229b0184983b57ca41f3fad2c0f66d1b21790cad8c26a7e5b5c8feb489678a3e57214b3012493e3f5b2ffc50825902a93b2bbb31edd2b8ed1a10f9d7003bba33017b1a2957d58c26322279b9973d6d3b9871b42e9d9f91bb9f668da874e6764f9bd6aa32b012d523c9d1936aeed3e8363266cd345a19d7b34cb10cebaa7af24a4747a6181b46a684980e7e99b0f8d4238f6d36dde1068311c36156a779acef5279de7e2b0bc7a5ea4e76b26910a9665f7147f352a7b94ec6f107193c0fd23a6d8779f10af35c52de49934989c21c7fb702a674f0b6088fba11fcae43b62691ba8fc71efc28fb3ecd74d924aace26fc7abc827e1c1ab139f98b378999fb3f93edd107004434fe9d9652fc969732e4ef65db571d2a5c9c427595aef0b597a0f13cf932c9f3bdfed226f0bf3597707ce9d7654b1c71f2bc07e10de8f2e17e691202dad4f13088b829d810e97d703d8fd5753da43c76a3cca849a64599ae05ba09af20476733c623d7b82b7238b33f731518f23d705c057e7b97fcbe0887d7df53c872d443cfa5051b9765b7f3282a0840770c3518b3a3e76b71160c6ff5979453b94c3fc0a7e8713c9b611603a8d923ec39274e869401e3513284c74e9a509de1854c3d132883c924fb06a7db590f9d75f896669fc68d5f10b949cb690b867259aed02b274a56a0732a72e133ce739c7b996a015bc29d86aaa14101f582cc4f070af85a2b45fc091904eb631c614e12d4d2d11fbea1d8a42ef111c595b89109fc89be6eadb91ce2a89ac4197d9f2073d1c87174866c4f80f0ddc0264d3aabc846b6f1f88f909a33d62448874b60e9eb4a97b5ea71b3e376fd1b020643b5f9fd7ab5fd578eedfdac4b20e673d8ca21eb02ad68b87e9028d637ecba7f08acc8a9bf4aad8db6e5bbbe7ab101d7d4bb3bad31e62ccdd23479d494bc32c71ba31b34a7514159a50665e15fdd54812a154da957b2abff3292cc863ef81d9c7488d52ca6d28b4fabe129dd23706c8871c5f46a1a5b8f6b6178c1bf614bdd472fe83e51a3a820fab664a19bd0d2f5e7ccd7f1a5f6bfecd4d6de1a60e52856d25d35dc82788f2d38e31fd60c5da2199417e0316fa612f88c7a79c6f2328a375232674a22cb4e00b4460fe8e4d5c4e77d8e4c95bc22e10ab5085def9ee3b9165c197f1d89a787cd000774c7c5685d82fe258daf1df34df4b575f4d1d355e0063c096eb90733b33a53de97d821c79b4bad4d92c1b5ce8b2786531d339d659f52b72f5b8f44651bf8075b9b84834d8a6cc3f5e27ecd6969b7722ad9471d99a92f1b33ebcd9c4bc3d4566963a0bf3fc5c03626ef6134244fb22aba8ed92b6603daf8a72c628b9c53deed64f7224d56b7ce4425c82b0e758f4cb85afbdf10b628a62352dad38dd20deab2212a096d38f738eac03426e2ddbf0c3342903f5b09858dec197096c219aea3f109677edfefa7e2266bb55b699da39542212fcfc8bc85c75ada7c1f5d8af02523a220763fffe2035ef3a41711c08bbc8afcbc37a1a51670a88f7814f7f2e33396d0614a72917ea8e29bff3f59a922fe13ed165ec06a90bc5a629d9ec2c53aa15e6e5bc5c6c610bea5acd03604afd57016d86c181f0e2b615cb26feff4871f947c269a069f549328cd308fc686336c3e5365957c90e318a1ed467cdd65851f7fad606d9a759acadb39292543d947a99d8d37ecb43d7f000c78513a406a407f93c595e6b7538f036b9fb759d29f3df6134c12aa9276eba9b7f932244e124a8f09b989ca93e588ac1e3537ca6a1124faa3455063254c40075858ca48ed2e194ef782927b3024ae18bfb95023bd86bbf1242debd0d561dc4bccfa953c0421dd6672177ad09c134f734cefdca28fe2f387730a66e8480912829f91cc368ad7e3e1be47b11c7a344380984ce7f26c79eeaac4b5de26f88c5928ad6c8b3a43a4b864a499a4ff0d7ac77bbdcfdc3596d410288708e6ec26f12a5d836b068df75c04a3b2c6d6769c0686b1ec0b0e6079e6e491d0db124874b3ab60c87820033261d5fd4e1e6045e9be0ab2ac485749a61eb2a01332f3be8ab340c939a1d91d075cb3613e13e461520941473e66d16accbc491b7817cc245009db4a895424e5c93854c7a023f3424f08cb8983985b83ffa2da5d700fe16303b9daa30364ac60cad69b21f9d58ba42893365eff648829efd83bbfd4efc5d6edb03364558501c4cd0d35809f15a043a9258cc489ba716a4487a7951b824355a769d73d932e7a35e038540e461565e9090b904a406992892bcd6f7a377e7718aa635cff5798eb4aae460900d2880dd9de531c128eaaa880508e4f452089612aad41f1a99ec3c4c00a87a0f028e98f37d4c11bbc80262e76f1f29fe32ffc7ff0d8bd608bb00159421345b11fddfa0c795529d35064f498f91726163268d8fba1a3d408dc5348f71d7317715b28690434e6e984be3e30005a7d181ab1965f222fe31c04632a72657981c030a271bb187c87c5207851345e4206257f10b8f94f3b22148f3220f2e2336040040f8854f2035deac45ef3f031c57c6ace14e35f36bfb6ba0ed23cb164f6c11339c0ae7a5e7c16ef7468e7da3c659ee270cd2d872bba692af945dfe2c7990f209cf843b01d9e65671149ff14630656f39e3fded964ca7125a3ac8fc9bfa3337f2a21baacead69a09367cab67666c2b0f14b5ac91a8e5511f13b58d49c10c8eec0a530b9377b798e5a7ea939522064994e42af573e5ebc6dca06cbc7f675fc6502fdfcaac681cbccaa0230443d75488a910ed142deaa5f19b875386cd66c409b1f9dc24218eae13","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
