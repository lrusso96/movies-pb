<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9be4954f82cb1a3de5084c0df0d835685e394695b424bee33f7b674e4ccd61d542c744211d603855628d7e346151aba07df05557c0c5a026d84db497b65b15f48c0657cfae832feae35339a2cf878316f007e93144fe926379ea4afc4cb51efa09389441a4b335cafd09e336c31536ba3a2b1198899b8460847d566ea0a19b999a5263d154d9805f2caf1e375529a1b5e6f10654427eb6b0ff2ce67af564fca6a2e0d221255994738f45da50511c367db307c61f33abb7a55c62ae1e54d47d51f80b2b00a2c4931c15f7b8651450c9a1540ded87969f0d08401ae2441215634af1050cef7d2f7b231f1cf9805782c212dc31ce216d7b79d1fdf8be4d8f11000bc4b03f02e16e31d95c701acbef3b43b5678af3b791cdd923187fa46223b235fb00d9b83f4de51ea3c9e8f290503c2ffb7259dc8f3c15ac463e909700fcc0d0c9e3b3271bce1233d16d88ed95dee76069136cd85e1b0d98533af0460cdb32206de4455b234524bca68bfad5f676cd707a889a4f8bee5bf7179caeb60762e744567173f1ac3f2a972e3cf9d4e915a211eecd11d7ee24882cd72370ac839b73baa7b06060f93be04b8453a0d88169ba821fc29faf4c89b0364056cf38a9573bcf9dea99c04b22a343a42c9e15feef0643002d3de64757de8ab3575256a2095d66f0d90c1ad536af0fdf107ab5b0002b72c0ac92efa340fc8e3ebae110894c7d54408e6e5df390ffd4dd69c76ca9ab5ae2aeca1ed131de5f3f3b263a7a21e575730f6c8415b9b4f9e24dec9aa270f7755d35eb48a5f610b8bc0f7b63fa8021a9cb6152fadd182732f0d4a38403716cb1347b8253520f23f101bd174d0e115de2950eb8a5c9c157547d3be1a9f746c9cebe40978d3b70d86d17adb430f6ec8f574dbf44ed3bd9123c0491f3ecdb5dbe58373a9ca9d5c938e705a765a07194ef623c1fc799b66961dc6892bba2a54b7957ea97f20de3933efaaa20ab2594158cb23dd43749644ff64e04faebb60310eb447b641f4c552e0fd8e4c1f615ad182f001c22acd6e04d7c0454ab2026cb3bdefd9ec06c87545ce1f9d7ed3b3e812d0f7e71c4cb204107e1f6cb51e66a4bcece049bb06c6f092f0f661a4bfc9360a6d5ba2df92d5a677affa83f776d9cf3e4bae0a016c861f8ae6fc0b719233d5b4a228be1d296282fd6633aeee231505960a63102d351fc9a3eafb5330b18d7ff82d8360ebaac98011f8eb0274b3a35d9cdad96186fa03873b0dec2bbd678e2c277da503510e528eaee782c8cda2ccdeba59890a8945937ece629bb02db800f1792e2e552232d6cd56a1a9095c7609d94efb6f0496b6315e242e057e635c1f568218ebe5eaed9bc9fcac913cfa612733f7ba457f1f54892f04c27a98d5afb1c1e4c54ffccbbfbe8135aca480394f0beb173e22015b61d53a679f35f8bbb49efd5a421b00a8c94de876a4fa16231a58b430df0f6b05c14fbbaec4057d16a38bd34dae483f83d521e0cf2eb6acba28b8d3b349ebf03ae469d7552781f40146e19bbe79a284cb2064edca9f5e837e4f4433b1077b72e3eac74e0780823764fd702572c9d2cbc3f9e6a81c9ff13e19ae1b04a349b12bef67648020334f68362790565397aeaf1cce160b2974543cd842a6a96abcbaac96e16ced59c7f6a0aec71a8b2a4db87cfa0c48be34c97a8c748167dfcf7f95c7f059f9738832e8ca7bb320e147da6f9feaca48979675a618fc1f1c221ab91258b5b45fcd43d8a80d2b4bf0a17d38f9ec9020b4fe16ac0fd014c8490b36cb5480b320dba9a59e9e92233ded04a6dfd97470c1824a81d9d68ecaefb2b99fc63a8f7599a6fe5e0c6813cc72a759ecc2bcad8cd1afedbe8b477ca827f72bc18f9f38cf5837b1a445a0e5e9042b73f86e83a657bb90ada2a3b81d6c46545c2fdef40acd6110721435c6e4492d662dfe6e3182bb35a2a2bb2977b0b641d0453ef9a572718fb4e16eec18b1ecbf1800289eb105754200d5c05acc14e738bc509fd0221fe8c4607346b3b36a733660b9d27ea0ba21d0ae8ce5258a771a3f126867486962572a2d5b6166733dcf843bd001cd2a4013ee9b710102a0e76e66a169adb09f2d39131b55dcfadd77c01ee4845213ba80ca3da133c288de56a02d398d7032f4c9d039c9492423f3b66ca96eb6843b2af72011c2d793e41c70fa178976e0ddc9338717f6e23b6096361a054fd97ca2231e6918bcb9faee79a48d1f8f37989af19adcd69e74e570473ac7f2e61e6cb276d7a6c893d80b76d2466912af36023edb45bce0003088b95d23f45351eaf86dbe80f4c69c4e4dd0f97dace1bbe4f809e89eed57739d415ca77a3a67c3b3578a6d80d6a10f05730c4d744b7fea8a03b71c9e6348d09bc73c88b286e56889aff6d5123b06306dc6c764bf4093b17022343cc35c0202f2371511d9cb55ca16dd9b7d4ac75b7450ce43d682e121a8935258170af14b68b5e571612ab0b428e9e3047022c2f779ff702f15b6c0d608968891e2ebf8d319b0950280ddcf0d203e0841c6fe6c5c470ce29eda6aff20983501ef2b9dd65d036607b77b33b5357a3475f0c5e5b340bae053e41cf591d73a7d9a18e2e0467ac1552fd57bf1008e6fb5f8098eb6ed1b6622e9bb64ca0a5d942be87d728760f72b4361ebf9690b988a018134c5d89e4126dfc52838ba44332d1be598444a04ef6c469585c2e67ff6867a421a9bc933e7ea385535f7c1878ac8b22cada031c70823ed0e58c17eb67b4bf801f0967dfc333d7270d44d8228ed3f8b51fef77e736d3248769f586016f8767f09c4457789b1230b649b31498caeb553b86549affaab507232b036b6a40e7a7236416877ad8472d87b903909c3186b9bf8270d380320f93bf5f32c71ab5056d4d8884878b4128f41248e061f70f6fa2ee83611139afe51a445e7172e70806351d2b5614ed6129ac20086f7cf7627c06ecb74970c5d8cc5022acf19ccfb3245dc1036e355b0b2a2db6bd9e4f4b9d5e674aeaadc14c14e050fe450032fddf298832423951e471ea0d00e8302cea5bd4e3468ada7e2e4b0274d54dd808e6a60f14162e39a5c5eff3e99e39df90b0fcea62726ec0815ab2f17341bf1ab2afbb047d359fda2bf649f6277b19371f53343c525f6a378660c2d72513c4a7d42da428334eebd118c59f7fdcd9fe9a8e9a26e91fc0aa2f68011e474b90fb3754b48993d00436db654656279babb25c84aa1a8a23559470e5fc1c88267ca5cc15d3faa18fd7a417193d22176ba7cd7749d8396fa7cbf00475d4731ce4291d53aee9f0c3cd8186aaafac8c55d74b7abf7446069b477af928a5dab09cc9827bc4f3807e0841841f42241601fd88f77314c52cb5df03934cc53c514a96396d8ecf92913b5983280663925910f0b7889db4ad9e9d06b9658e040ee289d1a614c1be5b8a943b31ca102eadf68e9fefe836128d7811654398066eec98c68ea3df1cdf92104db7183f89fc34c35eb5e065dcbd774279a8005152e1e3d243895ac7f61a40d28607d0d841650022bebb4eb873a132cfa613c2899c7d15b0669ce20b435c0897004e7764a65abff0e008ada3d5b5096f49e7b51503d6b69051c8a334e88ba1231a36efd0d4203a9c3fa26c83b0e9b09e750155f7b2f19d917eb4e0be6c9c01a98d3822c3da4569a8fb127e62c7749336c0cf3350d80beec2c1c40a5ab1eaad5e7fccd96726e0f26aff4750948a4534204c86447cf9a7745a69e92964e14d4f2c472e5116908e0edb68faf6034365820ce557b2590a40c2293b40dfd8bcd7d77f52004b4e3a8e386488c110aff1f90fde0810dbcef8d6ef3109221c39aedbcea75685f599421dd313f581a9a2dd4e633ff15055ae50a7276ba9d99e83026d871f7af27f3f76dd62701e2bd050c284fe23dcd5637950935f2aa64dc6677a1a563fff3cefd92d5c736a50f40318ccac508ac9076f122cf8b7dc787039c0cc6ed603318c88f3fd373b3085f06c3c5a56b5ba724b656022eb4f6c7739af28b7d331fccb40f7bcee0311b27bc7e4093f9db41825e62f457c7b29e9cc5575c225bdcbc910a6e0922099d9236416a775aa0b8c8d14c4a838988c62f8bbe5aa074c416f00fdb81af3f3a010aa724a0379fe9448eb7589983f1b18fd6a64a6efe98d80ef8eea574ddf2663f0a00a7a633b727c19cb3333708c5e6fbf1a01f8dd466e7fc86730a46ace9a38c00ca8591d9f110fe69ff3903e21697f0c2abe9c95d09856c7a9a35a09d256b82ca032412afa49e79060a64cb50192fee042c9a80674db86216d3e46a7ccc155a5454314b55c7979ce12bd9588138c7ef3f98df9b40ee4a152b08214975a405d66c1fc2e6210fadfe3122a49a4c59fa464561446d96e7d5e19a44bebfda6d96dba3a8ddd1ec51b4f8f79d2115bdcf2e51e3df2e6933f4973ab259cee02a0fa15dde76e25b1428e66cd000488acedc881fa3be3f05fbe016ff9e9a03482d397fd1c7e7938819fa1b7276871afa1db77954eae202dd88206700cdb7ece281ae542879e0d598fef47ce1504511362c41b803f94ea72ecbf0fc5460211a23aefa8f59b04e1d2dc2137111446582c4329373038a9ee2953248de739c5400ca010edeca438084c1e41cfa78c1cd6399df25db5e7604aecff94c55a4f59f9a72bb617f0077d7ee1ccc098fbb45b74adaf98d9b6fdf4d2994f6449d3ea39bc13efd43c38e97f8781757d5c428694ff325ea8ff09f2a97987c81aa5692a6ad307331688ac25f5e4eb21290f270b339ad32e8aedb491b96d3cf65db9eae6f4573ccfd4b831bfdcf0cd985e8c539acdae1a8eb97b47e865068f0941e8cf4447efa9071b716689f9e8856c3ce8a0b9db32e0655dc2d24715401e3f623a3acf37af2d900dece2df791989ad99c96acc56680ae2e77fdff4be6351be1d04c2c8e5d64b0f5e51f2861d8800cc2fd06be532dbc02081e5d1a556e1881b45ac6be451a055ab70879d254805c3a6d51393b66ec540c67c0ca2a4da1e5f9395827a58d31fe4fb11654bd60c950d2e6522cf8c6ef6231cd40e37e1c35657eefba4fe1dcb5be8fc1a0b4c60042c703f2196313414ae79e14a80ee0ef373493c568469d91b4afedf4a606f069e07837a68ae0100db2a12e21e7394401cb5beb04ef67abbe62a438505f88f669cc4b38660a769151f0cbb07cc1bb0a456ed5bcdf7e2f408c98e4a23fe3bc6195cd569bc615a39a3260121ab3f60077c21b92358786e058ac5e479afb12b5904b8ae4a3be8238d6d09d1c9ea8db6c37afd39a43fa4737468e468b4e0299c58169e0523f1adb2f6b08734b0dd96dd3b757f6ee4203dd26dcaac51b73c4040cc57bb2f47ab62604ba7fa024d827947520d1e8734c8b764ee82bed2df1a13060abf30300a4387aa64413fa3688ebe29e43c49aae0513f92f636ff5576c39679169e94ff019c8b9360ac787c4fc73accf75772e57fd07b5fef21e9fa99e00299019d378eecf7dee6d81cdeea3646a3913b508dae1c947df58b7913ca7ada36eff83a785218279d3f95e5cbdc3fecde1dc2cc9503f400e9abe6646d9e4a995c231c1cc895dbe552b600406aff9867eb4419c1505888a7ab0ba59be7d11801d80f937a790e37e0df1aa54b2bb5218783b4ea383777d1b764ef04df94c442475b707693fa308616b506546537dfc6fcf520667f77f45dd039960c4c25cf7804d36a97586082f4873beba956bf9b72c72488ccd9343a846c0ba160976c64966e51dfe1a861eccea764eacb33aff37858d4fedb6a9e831ea78894f7b844ae121b4dfc75abaa2ce2ffaa22ce2731c9f1dc8b2a5ed6a93f6ef476ad2fdb7285049857e4fd536fd372da4dc12faa842a33066d2c1661fde62c57ab04bf59d1b0c848b41b733c58e32c8f186512dacbb9c5ba1fae49268ebdca489c28044e3d54e5983b3611222de1f2b7a37792c0240cd14e2a3a790e63076def2ca7d315751a11a3ecb2a40ea26746b007c28522bc1f745be882ec2c3e54d23081e0c178a575c70722b69a20d2473543bf781b6b859696fea51d5ec4cd9b66a27a6d653a582bcf94a707b29e6a8c615b62d7b94369fa80deaadedc6c4ad4b71054ee897f4a679eb32394bbd6eb4de3ad05e7045049d6716da164617c706c9b465ee59801cb433427e2850694c1c82b71c811431d61a984765ce6e5132aa08cf8b39a2abd5f7e322f22de0a74035939fe1910acf6eb295576c9d10e3249e44cd7e336704df9b9410356ed8868f7bc42a7df9288492be788022e86ab2df0c3d149eac74b1ca17fa0e9ffc50d8de6c013e94550293a9f8c9e593427597c41970b2914ec4411513b2e031ec68d681b3a5df728a81f19c0177531011e2212ad64bdf71b9a06974759666daa9531e0781f97828e30d1433617aaf6bce155a6b60dd9cbb291a3f0f54da972089518bc6ac2f94132c3fc8b2772bc6343c908f8998e49810703f8947a328591cecdff78b08857593ab117cf0b8425309df11a74c5705197205144c7241ac24c9572f457f3a48b988cf866e3e96670b89c0a5d580ccd24bb733249424988f33acece56bf3ed366534708e70bf8adc549c09929d3f6cc9f16476a17cf17a83db25c724233b7c96d70a0ac72903dc2266acdb2932b2aeb49cfbb0e9cf569b926a807d95e02677dd396e56f4cf94ad5f1163818790416773e472a148b30d03d40d55b1c93742583c265909d545eec2f331bc328effe9ed39d0f5ba6954f71338626ff0895f6469f09dcc55a8d0b965833e0e7d201ca7944b850111e6a317b1dead6fa1940d67d11110c7152348d7edb899eb577bc605be48080def6a6fd0d6e70198c832adde94b193b36083487e1284ae0c96968800286d967b7643e04d184fd2f5ce83c798139cf2a7c5828a00b90a27eca258962d467f438498fd7a6d56fd6ff15bb34e1d1ddf24115d594a418f0715802ba2e639820d2c7ddbe613117155624b8ae24f0615d7cf71011c8b59e34f7da7863f8124917baa093280c6c762fefa30e6094a02f20e35568e45f701c938c6fd2b2b2a57f3047142b7561f240e7923cfd7d485541aaebec50121a1bd85d9621a7a48141d7eba3f46d6d8f894d11dce2c6c530aee59020940feed0f0626eefe074d931c2485938db9caf00b14c2d2eaecf288675ffaa0ba5886c8154d516ecf8d0d3aed45234a64c4a5af718658b571ef0f30cceb11d712aa9d12bb815daa54c61037344369b1462a70d3f1d06ee5b253a498407596d84f6167b572e72cd4500f7ec538aea5c4643c33bf6284300adbf33d35597aae5c503e26ad461555107fe00fdc41781b410d252e7755ad03e106776e2042ff39ceeaa906220a24fbc414711e1d460d48e26dc431a6ce7d017380a14efb2a59b6f8ae8fb2725158b4a49d9d1436ba5323e23fe47f6daf07df71c848956d75b473ef6823032110b1780cbf0e1ad173af8d98bcd37b54a8c440eb8cd08ec22f035e45f711c15dc6af6ca479bff110bc6db47930f9b44c59ce2f4106f4ec1fd7875634210c6f903c00e0efff77f79f673d8966f6a20a443d82d5ec17ebd5908ffb4dad1ef0c3621848d3a97e1d94811c032f568496c15a8ed4731b8b952b0b421d48ae6a283202a6c765a54e7fcbe39c3c1c83193c231bc0b67b57474946b52ecf2cd3e898e141e871429997ece9ea69f95ee1f2d7c0590ff405ba12295e8f22c5f545a34463e1c98fdf475d86b2d2005858ca50f5bdd1b73644ab314638e6b92127411fb72528df535e2d074d379240897129082a1d25b036282bfc9d14142d3bee18ac92a03e4ea09ab5a8e4bffb0ecdd21f36da09c40b0e6f48fead6b2acc16bca1b6320a7ce7d52e4f9747fbde8d236e4c9265b51010fd8e0d097421a752b4372f7bbb5c13d40e64bc7547c3eecc4ab2091a795e1b89d32be536a6be9750dde63225e557199040a4c9535359cab87fd1cd1df65900f69be802a3f2fb41ad6fc799b07403b501ba9ee8f89f7b101550b206c90e011c0f610de1b8058130b81d1bc5b3c918f66e69dcfb10b35c0dbc230225699b161da0f00ef5fec684c5996691ec47a63497659f51b31a563273b0fb5b00554d20fb0b2fc8ae8932189f2bf92947a15b2b3701cec1125448393a2f6dd1afd2cb4a4b2d521a5489aae99a5ace3361b8c156bcb48a73c52efbe3b54ee9e4f5d7c09f7bc521beaff45a37c238a838e4a86104391e3612e00d853026bba0b20477d144cb6f28f5d13cc42101cefe494764d234cae60a150bb7a407503d31c3d202571c3939e24653a6d6e4a8774f7e724a9129a00a17376a3c6f1787cd032d318a7c4488b589a7011fd345553dc68e37668b7b201688e8740ef420a9200879722a3aa7eb7424fb16060b5ffe36f2f57627ef4faf827b08a2c6fa90fc984da4a8a15fc624ba1658522f4fccfdb9222e32f74b8810fd43ac8147e80a13af8fda644f00a24e32081f4c92527bc318c0c2dde206a8ba0fb9c83cae8f095d90292f29a6d80d75288664baf2fd0d2d5d02ef24ed388d7b5cbd1a1497de77ecd3317f8c60b180718e2733ae3214429628e348e5e916d411f2aa629f792dea47a2f42fbc1b49fd53c88b5d5c11803a408a7f343107bbb730c7dbe97480c46947a9cd03b82289778ef763a18adc948c47174fb25efc8d200f4db3ab64f5508c8e09d88e99fd72bfd57d2afe629b023e07fa9887a7975f02ecadb85251c6b48cc075ffe2f7fbecc94e7ed7c88e7d5e606352838df46ef67716aa407e20c556ea04edd14c70a9b5417c5daaf17256cf0e15460705a4c4e94dbac8259d9129f558b23d048fbc671162a2d6675865a18bfceed2e5467efcdcb83d93259289e7ab19f250e0d25e8f7eb910bff989d95431957bcbf91d369c3b429667b97cc2114ef38cadefdf4923062021bc48841d507de080003c481fbec59c3e2287d6d5bc468e410525d725497a38fb0be70f843fba4fc6ed2b00536c5cd0af104725ab9281d9ced3a229ad4536bcf6ac2746854c23d937af1119f5ac6265e9b491e7cb5925b0faf32d8a2acb14b0a0e90ab114f940914a9ad69b9c1ef3366f3d94a925898a53e9823488012ecc9cc2d6db21739694eb8ba5b5794d26ddffce14709b6ec30edf1750e7d667f278d7ba9e10490b1ac6561c077e037bd5e1d873f471dcec00e5ed37e6758a1da6042061fa719b5224377816ae58affae6192e644eb67a8437eb0ba22d4eb30b2390efce1c266784b3de0c295f122621618de1b656d7875806646f316b20ecfc9b4d339c89cfc77504701067f3ec0001b2615c8842ef8852a96e2ce7c3192e15a107e697b02941ce30405907fda364abead7e0d0c944cc540e421b9d918aab7c42413ab6839cb39c7ded65c91bd78d3e543dd54f235a2e50562ccb2d2fdb7a9dd443ffb605ba0325ce3121c7929712b3b47d5cbb66ab162654a0ade711f8cd73143198cec84664ad567129749ce9022a06f8ef6ddb381ac7c13b0c00d48898c429c76d60ff7f615f88dbfef2bfd23a52eabc801e4a73cd4ce386fe647e499fcb7fec16747ed19f1bb647f1ecc4259da46b8b62fcdd8f2848bb05831ae3bc21ca990fbda687363618fed9b7101230ee8669da212b41a32c06542bd2e2563ac208a8aeb9e12a010e7d4d79963b53ce281b2f395268ec59352a788f235f68e7d1e48854492f8338472c6901a76934c020a941d54b870734372ceb8da6c7241dd42e159431ab427479d8f5c7b3be9f2fb02afe10d2dc7e2372200d73b92a7a96225d456166a9e1f85b45ba83a8418ba17b183bcdc031c6f47beef70aeb2a7fdbcacee1cc92d1ac847ee82b879badebabc23d69f1983dbcaeeb41601d930816aa292ca5a5224c4efe3204754fb722030df5222a1b54d19cf1fbe51f554f5361365d563e1efb66d201f9633c12cb64eb2f4023c5ebf407301117c5b775457e237c2d03594c6c98cbc01b6f1bdeb6de8e781a6b8d0b231f34002f1852fdbc4ddad47f8df8d59224f06e846d03843179e083da3a90215321a4c61fda89f20aea9a59b5073d296f652b83f3522f97b6654c77cc548c9638e89af1512c895d77f77020adc038a5ce067618587a0e2b60ac5fb009f1378858ac670604ecc56873145a3b423c5adb9dc521dff93dafc65c7a69fedd7b2711e00468da1fd045a89b7ab455ef5f32a4b775941dd3581dd6e282de9f882a5cbe416099bacd140dc2fae07e241d5fffeda8d53a3d55a1842fd96a57ba38c095c1e2ca6cef293a546d2fb633f92a5bf3846b37642ad5ea8e86a0a419bb9a9e3d5608a1945384220ba171980331d5960f133bd950a9182bfb740fa72883cd96e2fdf1695e9c1ef5786ed8971d855f862b4d5afa6852e577d109fd246eafc292fb8b17ebf77c992b3530df8724362aff6271668f1b88e417c019f7db7728395bd5eebc0ac202795016975e558df9558bcad92f630f5e610d8e9dcc47112118aa4a446e6046d377a742fcb64a88d661797e6d700b4efb8dbb53b723a8ce245ccfd34f47f70b0647457d629c6b96785eab782731a30e409dae48c688f8b74d9a7be882ee1406bffd8f84febfc31fc1ca8fdf5e553e5caac9fb8713f3b107f3a002deb85bfe49a1a619ac41d9d499629f169c50d2273692119e6c401a7291121a555c44793d3f8e8a0588e7ff9a90edc7037fbe0ae2a111d937883faca59bbf4b74cb6e085f4e7b2f3d1476b02c43898f2aa9b674ad7ea0e9c24b143db0629c2cd31aba16d9206f096a125d3c8f013a9545e3941a292dd363858b9a462ca7def3a8d7eb6d4353a14571cb39ca58aa69fa138c36830172c808ecc99a7c9e176aff92b7f3484593580da34d79ba95cf7b7952cd6fe63234a9faa69b724ca6f97dcc0f75a211927e62f8e099c12291046386378d713d94764a0e0fdc3aede8f74833bdcc876da1de2d232788920ad691926cddc3923c4ea477e46fd8f878625a730d93e3320c8ba866115b32829d73706f32f9d7eea639d5e5cea80487460cdf523f91acb9dcf927346e21f14788ec90cb2da149f1a6d8871389e2b5649b28dd7c30db813d3415f379538bfeeeb4c013c06dea0fa990ab102880d8127aeba7e8c88cf94d6f2262987a6ae174b0c7c5ef31cd436bb6a1301a71515f4a713e068810466e5462c57952a034b27749d29cc574e404ae46a000dc20f6798ef52cedf066f69814f85d9e43bd5b89846bc229217f49d1d94d6a50e9014840dc63377aaf1cf666d573bf3629b4b35c27b1f7a74a9eceec4a7e16de2b8f90d6fc6f4f5dc0f57211e6aaa382ac46d4e7ce7e5572f31ac806c3e7c7f838e07002a98cf1d41b4e1d932ef73ba536d88054b6bc3f721839d5d4b91839447aef28b4d4376cf70a5e3a2b61f2ddca25c412580f5e6899a4e44f9cd3929dfc9ff81bb04c9d332b5298987bc8ea36aad66122af80256df459ad8acc218863cf610e8efb64aaaf600e8d4641a5d31bc5c5237d40746be3a5270e6dd633481699e8a9966d9bb04fa5499d9544b7a0af97c180b3a6be5a46b1b2ad68af0c1333df78c29d3d4c3523c8b0f980f79ebe12f1b6e178ebcf3880b7374aa677c9969b02da6b91a46662fff9e835cf45eaebc4ea5b785411461d46834273fa3d51172990b8faf2737a5a3333dc42bc43eef7702e5fe78045f9dce05fdd2eb6382a8f4e07dc91324a85c29c47748857e9f2317b5408357193d5ab025ce14961b0109f1fb08565248e61e86b68a988b3fdeb49051728d1300e0a6b5465a9e93698970b031104b056d6a43f3e80bdc3fe2c3ca697e4b4ee970b116b85860dbae380d1f0cfce20134523dde9a707367fcef880e821d4bc37e5d9720131db494a6b7d575eda530d1006b56188cc8308ce6bcb8b893e5bbf3e36709da13ceefdfcf37ca919e4ba2a204b34067fcdd37ec8cfbdcfec450b5ca88053306e651607a38fdcb237e224aaf26ac603973c586c69ce761bd9b4146448e5162220f28c7b0792696f60788bdc68a05267de8e70f73098ac0213bd36609ae7b14e841597f0ec62a813b77abe8f04190cd5d9afb320cc7ad131cc0e955a45d4b1cf9096e3767dc97f2fac0d8255df52c41b3ff2c9e8a30e257b6669f2a6faadcc219c0dbbdd07e16aadfb1f8f0005312edf2066ac14a3ed46b7c0fe86b00d2fa31c4bf8d3a13e82146c8231fde16bca639a35f86853acafefc214529937e36045d312de89199d570669d6fd366a48b1dbe5fd39f86a983df91904be5607663883b2f56bd4d029b3d5269ad82ea521a3be2d0f8da763e62b774da23c3f705c77ad2957943534a51431b1f69008198ab905ab10cc1edb3c1260b0727e239842cb0460d404f29e6048fa90d544433077560e92dd0e403197a113396211243d1c5d66aba404dd2b8bae3c9653471b1f5a1db32df31e6c8fba22e34990457b88ebc1d548051c174e64a4775b59b6d38a349d8c40cafdc6f64c1375b000bdcb0fcfba5ca983cb53fbcb3a7b6c3fbd8f5c1b4663e3a046b430e6171b06a09d21012afc17de9ef80d2bfccd7b70751d26ff39107ed59c85ee5b06ae61c795ebf69d7914ea234c73808f5b09fd914cde0a30370962276e85f1aeb9d668df712b4297b886d62376029c306c232a531284ca2fe4ed539633ebee6d7ea27e22bdad0ae374e7a5a60bb4f8021e2b81a903230ede39bc9f95b98bad7c3c0196b94a2942a9370a650d4ea6e8b00b21147cff8d5f4168deea28dc714ebf27f4c479094d2b50b91e1560d001e2e4bd47608af41fb40a83c4479fedc8676941b31bad3e3490c14d25fda6fbfe2c8a156df99e8956a045bea3d9491ca729dcfdf48325a779c16070d76eb9fd32d23aa9b3ab0b6ed3f66744bd0c1556685b8f6e2d2cffa8a9d56eabdc64796e50952e8a04b3492f67bac8349f186834032a62df1856dcc1e3ddf25aad3c891f949c458dad374fc190ecefa1b3225acba8eb9b6a528","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
