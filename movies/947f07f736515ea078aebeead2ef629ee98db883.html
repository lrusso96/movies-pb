<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"11ea155a14006412f6dd35c423557f155c0985343bb7fdbc3f64091ee62767aa4141d286d2bd5a7a496a7afd1fe72c7646fcc7eee356bc025c43b55181d2aa3dbfe05d120b9c919c9e70ba309293bf5a492e5dbd2d0ea9de0c6ee392bd348fe3ce642dd3ac0842c11544bf4df76206aabb9dfb1799893ff38c66dd91571db6c80155a25671e22b29e0afef99b7ecbce408c56b80a076aba0527918302f494179b7b65a2d28b948c3a707e7827bcbcccdc3e398e05d47f71a163361c2d4bd6e976a6d1d7a336f2ec4fb197ff7b3a6ed319266bd111d53677d1586043b7536a5034733ec5129390567fc168994f2575c496593fbe9b20a7c7cbd7b0813ff650b4e72f7c15ca5da8329b1a2cffb594732954925a4370b15b05074e35c537c9354defa1d54c546cefe398cec3cdca5a2aa4694c17ae652e64e5461ba170b6117a88d3279bb7ec2ec6089effd4ba2d5e847e715b34d9dbca6351d0c7033bf26c85514bd8eb9f589300ea073d3a82a90c111537bb90d3082919ec2127ad809681a03c017e5039cb292b9486f348cb2263040422226e578ae1a0636025d40c77e1bd287bdab445292132f50201ef5b7394ff42514c40fba34ec2df8645da749bcb837aac295e9b30875ab2798c15c1108c0f4cde948710e89327e43449a8eebbfd5af3a8a468504238a3f05729ed75319e3e22209232604bbb08a8e34ca7197c9ab14a41c8cf7a445b56e41e5baa6e15e9befb7cd7c30c35b3c7cde990aab500569d2c085b7c2df76030bc0432f915d89568e761e9d440a9f911426154d3d90160b793fb4574e51e8f7537b2ba38faf7a8d6dd1b3574a3181c9280d29d9ad6d7a385c87bd804bd8e327d1aa10ebe2d8435d778317efe99e298d9860ff17039a6bee412c6cdbb5db8fc665e136e989a1dd2866960c72170768f860dbe507e2d095f67f46fa1d39c8d8b9673412e5740c010b356b0e1ab0c6beb4fb617e9088c7f17cbac15d404e0437b03c27679f9d0058c86e0da6225ccec4722281490e99eff05c1bbfbb9a0313f2bd93121dca5962bb743dbf45a6bef8bead4ea3c040ad65de1a1a534f8d5094e13c59209f9e0f888ed3680d63eb1017785808c957cb6e4610e0fd0fcc8c1af730f3526261fe874af1d046412dec72c831c1ef8ec833fc872c5be1aff0620c3c84002aacb9c20dc8efb54284da1d80f1771bff428e887ef13a558636d2abbfa5021e204019210ec816c704d2c8025d9f5bdfcb0d9171216d1f9b5a3f8c15c86ef0eae7af24996dbd37c5a42395be7aba922f9b33767207b1dbc5a46798309c3010c5fa24fa0c5f827defc446ca0af84eb291fd899c66401a90a9e78a805d3a2bbb0d61c161fbf44c3e008b31f6651bd5bec3025bcd6c64dafea893d58ce4e3c0e4e95366bbb59c1f550a3740099e475f39a71ef5c0502532afbfe63422b37b632877c3c2e71538146d0cf8097690f5b39d483f662028edf5c76917ecb69116ea6e379d579507ca9e2a3724b377b16f8c13e2bd0aed4f84f843c17c13802fac4038dbb4374b7613a911a5ed05f47d7b54b51756bab5d0b509b105f216d4e5e457741a8026a02a2efc605a68c2120a02c65865b447a154cd301c81b3cffb592f6f056ac9e8abbaf0767c7a0fc06263c8bb98b373e197a45499577a8702c5349719543974849e3832c465f2c70ff02b3174b9f6635ac84bd1863193f9c9c5e405b57a8f79f2d94b3d7b1f853823e649dd6f0490e42fc767089690c18d676fa877f4fafadd6ee9251e7f6a1721c4e704bed377423176f76e232c4849d2e6c8939415e41e451241abdc00ce9f058164403be40fc1b1314ea5bfb071af97cfa78f264ba080626b258dfee53036aa22d3b32730432c96affea266b8deed6dd6c2ab3692b8850fcf97741bb2ba386d4d3ed14f0fa418c1155163816f9e60481a3ce41c909311de82d237806720b55b8a586173287dc07f6756b4e9fd7049e4e2cf259109e30f3741c3ea9ca5688c8588031c0df2f2b8e51083d30fda42f2eb149f6f96a01709a8d49b3328c2779be1d4a62ff60bbc756e28023cce4299958767d88aa21d03604c4a684358b41f265686cd1014817fca4d9d1503d1d7fd67df9bc025c6a1fd84f17ae535d61b39d29e929d7dec678626729a57da4fcf7afef437969219296e1ee432a345277ef059a702af4c6dc196e2778e1bf13abcd4632d263e694c0aba474a9c6a6a2d7151ca76ea468523f6aa092b078f75b4f9e7a6ad3b064e63ee283dc86aad0991bdc1ff0cee612506afceaceddc5bedca4835f5cc1072e9337c199ab0b8b7cd99d136c35e598672bc78a125e7f5aaef5e14994b20f636b9a5a66a7d712f8ccecd4060f11c6c4df3c5717f8a0a1a0dbcda85d6991db342c0bee249e49ad46b332d1ab112f989d9cf3c1d661fcfaeac33649da98cfbbec7f8e29b1e83ffa1c8e88f781543e14491d611d583d849009ff5fafe278b7e3a353e3d389b0d3a9324e3729d56555a1aaee933f9c8957c4198d699b5b8d721ceb48833a7a292e66813ad85de98e630eadf64335e059ea96f8afbb9f9ccf06d3a26280d9837e4c56d7cfb60d798eb1b198c11f5f8781914fe2992c48c4e5ebce8796490cfede8992c61a85830ce80b14cfe0632f5a2fb86921e9f70a48dbc74c38fd2dfac25b3f3b4ce52d11960c2c1ad3868359c6fe2b4f699ecb9201a8258ea9f2ac2b5e9bf9a38c8b9ab288a44d36a81f9e7a8f20195e422419598e30e0160911c4c4ac2830910239e13b3f8ce8fc65e71489f100fcf148ddabf3f4ea74fb1ad3901fa33ecf32ef5b1f600b7a054a9599d53f0ff9e4514d9e8b73ffd323340c23b13cd1775be0ed956dba3a4fa04a13e10c7a6b25d423a354e6eff89a380bbc16682705d53209aa0c6edfb2091796bfc5182b56b20f7c69c391eb0c35bd1aa723279b1ade1830ee78f18d6df979ebe89c95604e17bc8e13dc9732f303e0e9a527c6b2d75010ff8e44bb21ca762f0ea3b890b39bdcd85eae64b20c36591259379257ebf6dd308adababf3f9f49ccb272e3c41cfa506ad409e96b2453d611c91e92efd77b7d425fc3194f529d42e26a904fb1e7a81d9a1da5a45bc534f7ef4e6cf66bd535bb5d15e59973d30c2ad766e47ac02403cf23cdfd7b85517e24804db317a291225585a99097acbd56289ffccac4c3712dd9bb212a8caa46716af7e3b0556798670f396a61885a6583c9183869539529421351c43c58546678a9046b3fa583ba593ae05ef9397ff3ad5d2243d7410dc324f1d97b16640a6e1f8184158cabee3f29feafe96dab34052098c694bb4ad6cb4fffa0402f9d2b8afce7c2c976f1a7c9a7640df0293cf752d9562bbb696e9532a882cc9056c2e335d3a9bf59a5efca516bfe5c8467158ff39276883e0f431e22d18da89016b92145dfbceb0c455dfeff8712a0b9e1f310290b26ef9a2efed709eee177571fa2da960e4f5e9dcad0b338bc37e436790a7eeab8815d7559d9487ec699ea772b9a02f354d70d4605f44a8b3957918dcd12715f0438b3d6d7f524eb29e9da23eea96e733fa815b56fb0f2c7857cbb55289feb2621b40b479820e7845194a8597ef6a56442597dce3bd3d6cc2427066a2dd841982c17dffb7a03ff56164ba61fb27b5c1cdb2634bc1a9cd0c5c74d1f9ee6003e087a083250437b4490c7cf98b4d6c0bc841a035dcba9f23c8fa3f7c2c5d15c0cd827103fb6cafc96cc19fdfe480f14e034df0358bc9f576613fac807c74c488b574066e5d1af687a53c069fcf09e50f344270744f86adac084db9e3d3b6d023913f017f5e01c8200f043ef36582e827705f51f9a5a559bfdd1b1e9c29dad5a325423dbfffdcb159893b6100225029f66dd5696b757344bf632016769fb2c04178a560ef0ff1218b517deea5abf32b6f6d0cea362e941ec8141c5f5b1df4ddad93944418ac2507bf39273a773272029b1e6682a8215a475bbb6905262757bbbe37927e8350a29b3e4bef30b34ecd3ddc1dc25631ec74057c2c3e89bf67f3db886f4ff56267cc30bcb98ad5d817b94b783e79ff17f34979e8753fcf6d4acb5ee009ac810a269db573c8782856f107204acab2c0695a8beddf93f32f4923d4c723462d73e8d07a6cb804e6230f383e175b1e5a44dcd0a01f63b58b85311ab1a93b915211911e3ba7ae0ceb5c6fdb1bad6f713feea83b429070b3752f565cb0187779f08ef8eb8e706636ef4a3a7c9ce9f18c5614c35b4e0319f7b6f49bf127dfc5dafd620a382d5c4efe1964bfd0fa6e19de33940d8d35e83fffbd7a78e0445c0eb73569be93e1beff823cd52472eabc90506d51bcec1834de439ab2e610b797a1091fb98d5dcd70e159e589c8b74e3c35422eea361944afb316889adb00e1e8cc5f9fde3f3a6a35bcdb13595ad09172fe98e6a9f837f3d0b8c9c88646744cbb8629c22cf003759ae4da2c2b90ae9901900196c9aa122662d1f617adff8617cdf0c896ac42d591ade42ccd86498f8c2899258323faaa33f93172aa9afeb54f3519ff18bf20627493908de0909566a5690e9c86e6eb98d453a5a81400d97e1a6506f88ad69226a5e0f2c292dce970f049c9421c5c641501fd2bdcfc6432375095310370b50b1e49029e88f4a8a072c9e601b576fe3a8358bfe77abb40298aa70b5cecbff8e8261105967a3aed0994ade66c09749cbaf650af38945dc0db77cad0029d83fdd956341022d91dab43c0c65d2ade0bf2555a41530ddcd35d300f4c6e6e8431a2b9b5064a3a110e49247c9e348f795f0e2a1219998a43eebb0c00a5922fc576232baef50d87bcc5a37e44a0ab519658f4c2c74c61c9f37377291488fef659e82bde1d7fda1dab52499d8ed038bdecea393d35287e3d2b6fa20b9753e1925f45aeee19ad430199739045bc75a7cd2f7b5a4faeb7bc2b08f4c33e9ff692bb51b610f0ee2bd99efad4d173d3149db6fbdfc219bc4ee208f20f41e48edc50b421bb241d435e93bb4eda7333cfa0741d792616924533c06fc67a406e4b57d40e2575b3db3318e54fb50b6385e2ee07b790c9dd2ddb75e0890132a26404000315a2b823d06eed997f9ee76d8d9db2958f94f0ff27b41e1f047da7735c47866e88360d79a416b8bbba5b36a531b9f5996bdc41e36d1583efbf721fba54549dd00b87c6f3d20d877a773cdcceda40b45e91b5d87bdb365ad28baf7d9bff3363f3b249f5174ef05715ae34e402bb54b359aaa79c2f70fc566f8d2dbd547af55725daadb5a7ed13ffec2eb87ad850fe565f03b19781b6cc076ca18826615171153087e7a538192fc50791cfebe5e1a2d9114779766e2440037c62c9b1d4b55de1556ae4ca69b789d74c4e2170e5021938e6bd96a3b4f34187b02881108f159c0cb3d4efc0cda95dd2ab744cc0b40e3e5bff266143acbd49dd67e04a374080862be81efe9bdebe539d7eb9219f03e27f9ae95fb4e598bd9f567494ab8bd3df4117bab58beb412af6ff594cf6b38cdee4bfc0e00c7eeeb9b1ac099f9c83c57084a25523787a11ef0400937f052dbcd5e5b70db944ff9007c4ba55c6371e8b97d596eef26799102d7acd4bf40a51c68ebdd012ed60a9d433a9a3cd1524d53da253cf1d731f5b246f079f459dd904b2440a957c275b71989751405f1864186c04980146130eb060984f448b9d35059da646fcc36311baad61cedc8d99ea64cc820708eb0bd50ae3e7843c2bff0b11b41d6fb63e215d79810ed189e31421c58e4437f321d9fac8ef2dfa220bf79373f3f86b19b1227534e52c7a63a327e2bc46605a6663047dd7af2bbc3e694238d53781edba41d0991120fb4d2be12c51420a788cc8c3429b1a86446f5c9494dc39239d4e8ea92741f4d2c7e44ab7a7993e4ea795091f0aa3d09f4c9e2dab622e887ba9bc143796bca9cc7c65605777f7526766dd0af51ab2ed0ab7b9afe44d418fd2f424d3ce11872dd3f3991775a76713d2e8f7bc376e0f8254fafe6adca00839c25720dd829cb241e86acdb2a7cc5801d141c880483351ceabc780ccea95caebe294ee4b3db936aa5b7883f6cefe40658385580de779c2a0d97e8a3f634c32a7eb886643275cee6c05f20a0d6a7f2108c077a3a2b6100b4d923a89c44bd7731e067ee3e2a948b2c59d764f53d34c86c20683d556b9b062b91f900df7c9fdf2c469fc07161b3cf40c5875f74522f16c167cb206875841fca908a6114efd72248e4b3d53cef55243c6fb32c19ba19e0213ed5529c5abe342d3bd4339e1887400d9652b1c356168a3cbdb52c822349faa0340b43a56555e65d43585527b153bd65ebaff43acab4eef4b0b8b58a162abb77888ec1337a5cb11b654fc906bb9c205cdd31bb71237631be6cf183905b6d5373ce5c0d188890eeae6b071267689e10106b20a399221946d474364a56ecd8a073d7fb6aa4acc27debfa91e6e8a5e5f1a591b963641a8cb57fffba2f8a810b5b36a6550b49b37efbca1242a013509d4bb765b781d9d7a0144fec8f632876e11807808dc33f86dd2035018f07bf20361ca8291eda45744087bdd7ac208d7105d7fa580c8591f5a312dee46e312223f7379460bba2201b3f45b4ad1ff3110e85ab8c116840bc2a0541a87e43f3241d84105b8b4efc62a7c399873bf89b459901fa001f0937b9c591f5a36748cac138c7fbe3a4ce86fd6ec02a0e6e6fed8475eade1300d7df21a0f8b856d2a3bfe324c69e3fd983b809fc914b5f0f2703cbfac46e13bd22e4d806fd667ea0f6a78b2a2d79f03a251863d1b56275cb9c6f251f8d82a1416810ce0ab26e6e7827746ae701b7a203138a21c3c1868691620691fe3bbcad3fed3a221166dd9bd39c1d7b64e7031d194cae4796d60e535d6dc94940322bcec1d5c7401a99ecab378786174b9dd615569b19145381153031364791ba50a8126cfc12290a82b87c24f4e17349ec74c27125b95add9e95942906f493e0d29d066b0931b64ca75c1a8ea66d55c4b83c5a33814b13b7ee11f1bca19b8b439a2175e5625ce3d1e8116470156f191bd53373d86dc24940bd98fac9959db766015859ab0c6ba65605dba7ee49bd2c408463f15d9b9bd078a4329187e70f7780426aa201305535c01594cde134d504d8f8aa60cb7ffd8bf5a23bef74a3169d31d752396044cfeec858b36f692561ce27579d0a3aba3b1788b312cd2f9819b22867c9d092286ccea2beb8cde469b923a7eea5ebacbeeb50f8c56e7c034438a1ba138e4d298dc3b90682054f2be284b279dc9f8df205465c7fb6958874206144417e266ff8ccb15f91542ccfd0d88f1b5ec1dc4e97f313480d1d4e4f1346693c5c3eee12dae353b0fb838bf968683f47613717caea3ef34a3f3f4f108e28ac6fbbc7ef6400a4deab9e1f54dbfcc31c8119e17c6388d9c937523199f3af3740283daf9bc8369b7661a220c7929979aea893a83a78bdd14cbbec61eeeed7e5fb811057bf064e0adbce260515966c11b44549a37a621cb540072f3883284f96c50df7248532d0423ce8d9cf4fe2a14f195ebca42e8fceb5d7db3b7a36e9ab537a52d32dff35f421ee9cb21e8f91e20276b6992f1995d9b05dfdb0f8b8fbcc3e1ad49dd2e06f1efd3d5887a5a843416be55d7bbe176a86cc540c11b44a35d8d959cefe945e3a8cfab2b7f0934cdd0ff4c57735b1e48ea89de14698a581bb6bf5d85b89a5a31f1128fd2fcd641d8967a3447454832caea65720b58b5feafa75ba906279e6db43375d62867ccb26ab5cb7ced2a5c5a3fd8c81aaeb1389b68c3c9b8f3db81734cd57597dcc8c5b8f44e6129b61f1e58f7176d25d5b282b4ab1987f2022b5725bc92bf37852963803efc7dc946dd16da2c069dcaf9064a27daa450fb86f0bd06bcdae9753b1fee22419edb8baee627f81ef11ceb8778d9affcd74fc1413a303379e2bf9ef1094452573cf25a9e144bbcd9a6e4e04f8112bc2312b65faa9f01fdb5e3a64b6cf91984615ee889e1318cf8169de49d5da2eabdbbad3dc4fcb4fd12306745385090c023698dc63376409bdac7cd102bd01635d9edac62d2ab8f036f10682ee4e565b7b83c5a14e929a8edd17e2bdb094c4dbf362853175f47a55f790d5f3f0e77be3bb93ee9f3a2040a015417adb98a7c335984f68da079b85617cd0f9a13a729b2cddab8747b58c4f168d94d2e6260ba9711456ae6c98e60907f333370a9836c94b981ea181d23a9073887fa59274ed53c40a2ba27002f278591cb6dbe60ffe5d7a52bccefaabbd34f41cff752dd378e6c53c3d81dd5e621d15fab3af3ed6347246d02e359afc241f54470207fe7aa49fe70ee1ef52a6e5ce78818696d30a6262e84a01d7b230539b0ee49b6085a4ffb27fdfd322eec7f750bb60e752421432e3c4b7a6b6dc2b428ad0b945664af7696927217f3f2ecfb006ecf6f292a37a65405deddf63019380fa2e8a872bc77a9d508f40041ee4706208eb757f27b1d7f8955e77d6b334df4450a18c0dd3965ff468c408bb6ab060f7e643199d6a1d2cd6dd00ee6f81825c7847e04186a1503d085dcb4c52140b901761a76c643ed2cee5ef6cd4df42cdff4bafe52a7bbd9c6c449b9008ebe0df57d22a57b5e83957418fbdc0d502ca5775da05c0a4ac90e667575dd413875010a34dc45b831a4ba64a51ceb989d56628461f040e4dacfbc469eebc7dddf0da67c44d91a876396c860a2347b3f847a3ba111add138ccddf86b6a2706dde09d9f900e7277f35a6683d23b1f6b63de4f58eded0a31415f6f8e7d2a511f63e021b4313dc799e58f04b05f80893f5fcf938386e8218b11e8c15304d959a69476aa9354b6192f774e24d5829c6286e417ff9d00182b94cae2d99d63977781d2fcea4ff4f3309fa251aa3a4079db48c91c5ddfa6e737b6980a172dec67821ef0fd6dc707f181f86fd0a7d7ba9260a62ade721bb477bfd96af0471cb212852e35faf6e962d6919d3ea7daa079895400b10dc51087645c339c26047c01eeae74305070a3bc01e6da8c4b83d34fb90ca088a2ed4342c291046b265dae7cb290da9b116242bc21e01da88b199f2ed95cf8991968de0ad7de3caffea319d3360660a32a90c7f726c7b3a79fc584cd2563d20a03491ef34921800b120ca4c92929a7d743b1679a724cdaf069dd381c648a5e8652eeb33adafd94c6d9bb3cd3b131fa0a098fa2c0e2682f076fe34dccd0671046d60d0df278909994dba2fe7a71b9b04724ea32e8f60e1fff88506cfba02383842a05779e5a398b90021920baf003ec3355a711cb2c147226171caa2ff91dc2af1942d6a8c505a218a82ff90382fb74ce4fa031257a5873addbb6d179a6304fbbedc933bbf3f16121551de55507bc2b72e331b85c512746dc88a60a75a159036c199289625e6799f5103c77353926f1d5055e8ef436c3008750d8b426a92c71a78472a422b6f30998d7106225ac73b363ad5fe3e9cf2c423e5c62c34e221a67e66a17f155cc1d0d77049d325982b7586c6d7f39d69b70337ac08585e505a2429414285415ceb0ce0916765ce0e1c13358c458c3a2d488275205348d7db1d1e71f4e104534e87fdbc415394e871de5b384597d35c879e75f59fdfa0d1e1557d3c48be89f4d69c5fa0dc4223f0cae60629e43d6e02841db2caa3c0220e950ca73cf3bc34d0f81bd43e90fb5a09f7109bafd2abd5516d4e5e9e222aebc8effe597b147f72447744e0794db14f0a96e0622f6b02bf9afe0e40f2ae53f8848bd88d91a322315ccb881c328226f3768c3b1a811cd16b426f0c6c8f36842631bddcb08fbd56eac2e76e3788452bc8f82fd4d90a6b5be59d49cea49bbfa4c94d3047661e776215fe3f63f66c18b0615a33fae1c9cb558236232e6f4ba56e82a506529d54e965dc6e3b559df1a6d4232a6a77f709fbccdc1dc79ff4171cfc7b9d8ca3c3c2299c4410a3ee12294042879fd94b8da86b6aff0f821f760f1808972db59fbfe2acdf5a903d19bf47c75b8409e3a93a35e29f320de769effc6bfdb40ca963c86e3a7ef370a463d2690937b774faa504a8c167b08fa7d0ea0707ed980abc144a079dae64d1e2ad58108106b58aad66cf3b66b5e2ca2fe7473c10b06153f719217c48193ea1adc171febe45518ec5177ddceefc8fd544ebfb8f922cec3273406dab5f6c2a024eb7ca05ced3e2103357244ef3bf08ead956ede38813c3d8515b54c24361d8d0fbb39ead4527f533974f34cbc71b8f2caeffb7839406e9ed9f6d6b067385dd456964f15d5c62421582a85e77024a3836682cfd81096ff25ab515a8aad154a8bc6c58660c41e7c62374eab950050fe22c466769213852b6d52d1b5d2c5ba2c7198e45ca98b657c805245b6cf563f5cbb477148cca0dcabdfd5f22c6718ab4f6b35457ba82f3288972dac87008f5ae72615ff93fa960cfa4b0eef8e179e75fd9c5c45b7dbf358aba50934ebdde22da789c89402eff8da7508e7184c202f4b75a55e47ece942457ef33e6e9d3e2734f2a5248cdfb6df5453fcf1f479685d2a3d872b8ae8c2f79d3346ed61bc0c1f3454e69a28423fef30c70152b3fae41973e91b5473b190f3aa076a7ceeb76d335814fc910a36a8318a16f7450bdbb2794cfdc79667e3c80ab6a892b5fd8b2df6cea31e4068d2372d6ffa65cea064696c1d41ff41a883b2c1ae96e9ba84024f832170a32a7fb7f049f187aa800ef25b3b5ed65e10b8f310fbe328b050efc5c1f05a970439ee815cb39d4392d0ba6f2239778c783ed063d0e2a3c43857edc378f63254b27782a10365512820815100097a7ad2705280cdc2f90ba4abb45e5d06d8331d0090380c7efa2fb4271bd728492691eee3af74f93b68c3b1b9b644e9b0d1cbba6e1665e27e6c3dc70ac9e684de5ea38150fdf13ca4cb4f48e424eac795bfba56257a39f47ed7c89484ca86de4ddf21733c12cc4eadab93aa57ffd45241cc828035f21e453958c7e4c5070d5eff6c73ec526e3e60281c42a47c956e265421eebaa859595142fd5ea3148c18dd4f7aa574aed73b4424b248345f1f83313afd7a7a439db0b916f9c4987130eb60d18c0388b44d2b272a971067d8c723893c45506ca9b3632e908ae610eda54b86918c1574677cf1b999d4d41c45ff521edb3a2fc0fb0a29526e774c2386f576d88f72d223a1c3eed9198cca059739e2bfcd77b1cf67a06507c5ddff60b6a61e97db534f5f4d6bb05694d7d8f7f10cb31cbe841e8ad1085bcf8e20e3cccad6b955195331eb91141e6fd586bf8157fe05e03cf65de6bae4a37c57b07dd3236ae0bfe557e2fee4ef70efd358d4b9f195e9fa1ae11c2ca0e48367c41af581fc77f4e7c52da08a1f188fb3995b7369e52a33e55e7b2fcb3002c79eff6c78c84a8af4ad8560fdb5997f4a9b291f184298663c3d1e2d16699624fd0a571f0a8feec005e034184361428cb79e9987bf25f344a41407b22dd3e05453fb74f026377b63099bc26771a645ca044e8e49501942c57473ea67dd6fa5437ca7b5b8aeb78efc7215e446d4b9f82e78666165175f6f8ecc19fb5ac6d012faa06337b70d3c3b23b00b95ed4149abc557ca89200b602c126b2fc92b45044c7b66b7dd9f99e8428ed1f87fc4979cfca529140418c41f16eebdb05c5b4430182bfda5b7960df683e500b7218b6518e97315c0f7ca73c6b5315e2ba0a6e09dac3f0173d9470bc79545cc8aa9db1fbf7d61c624e65a43605ede23cf29719d2f8bd085a4b75ba65d1a951a3611410406a6f4e2d7b6dff66abb7fb35f9d607363e9bf2588fe231e02b4e118ca93e56b6b5ca06a942e94f4c133c6e704b0e106ed5f3034eaab15cbf856674a2c88026764f6b75eaeb633ef8431998bc08519f2d203f96fc0ff404fb0236a05e98bc557e8056dc612e21061f4e01af4bcce146c8a802f5339e7583463de0123445e854f2dbe3024fe78573d791906e86aab5b572a41f4bcdc4e12aa6120c8a0cc3a0f42a07cc52f230c1a3ba4a4bf4eec3c8fe32093b2fe35afaa6022eb1f7bdaceab4cd7b20172806e9d02f822bf4f898c0c14cb7c42c0a509f097c605e0b25034b145ac59eb658bb5d2a1a54f9189d99d7227f398c2345bf504fd4c673e18e32fe6805f32ec9bb3d15226daab1271e5f50d6b3d02e98be3bcfc40f6c21847de0875f7f96dd692d22c6a578e7d92917bdab8006547bda35c3caa8017fbf05d1dc1d5ff195869cecb9bd742a0631b3751beb87e23d63cbd417fd96963d23f12e648ce7d0c781e0db0a82d70800dc8a243b0173e20c2f08d99eafb2d963b37ffaeb76fe06738b85954482fe7b0d2ad2a2cf08a186922746b899497b08e007a84197780311e575c6aeac15f2efb0f9dabbbde72e1bf0b4d646bd8eef3a6fe7c1708bb9d1663d994c968692a1b4187bf8ea0bb9fa4ddefe3130832a24cf47259b76a0aaa0e447903608cb3d6b8183543953be821c992dbad670facb7eb3316dfd120a083886541eb0c0bcd44f43fd4ca077d1fc257854ba9a440f1c561d428751e4dfe255ecee53dd6543f3622c568f804ba8ec838da1cd0890ddfaa1cf2e4fc186cbd85d8bb3c6db78084213fe114b5f5b072fe20bcd7972029a17fa24ab69f1e62cb69e3edba277566724c36b7d2e38a348e42748dd5a1867021d270427734c9dfea5f28a01a1f49f5d092a8a21995473faf13de40ab557492d1365ab09090d5149eaa2c9a40021785b49a065d3483bdb8a99cd6fdcb04a420b024dee80190e3a4eae49c446935276759860c6de9b85334bdbefba0945a330a8df7b31609b90669f64906078bd06a1ab3c9e81327453a8d00bf916d8d97097f35007e8f08c47acacf8913347ee833d97c5543775a202a9b0a0ea602f7754811af8b740e359602a836cf11cd4f58f3945e189e536505966275c618909c1c6b36b835513a3ea28117d85ceae502b32fa3c321455a4565304bfded44f5edfc2f9b7508d32527a9eeaf59f0bf46b6884e6976e83432544f3b68009d2acc76d445fb48","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
