<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e724a2ed2d4bca9508b8c29e92d6bdd2baceabf641187162e253dab8ec4817ffb2ef4606a4481412c148b5e7cb32633dd7636996c00467395b24f4f86365503ccfb3dc886c58a75338e9b18b6a95341da1f725fd91fd4b1812e01f2138ad2fca0266060048dee5a147bae2b2f375d4762bc7c53c9220d5b31e5f41db1626c101a07865ed1d94483f845a2f9c35844ea9e869612544e1ce74a151b883cd973615ab1fae269ec5a266053ab5c0d4b368d6b72893982f4226bbd204b180e95242df64e43536b470a84c2eacce482240e19029e7bd312b2c1fa3e4575397a4d665b1aaffbb7b2650dbb9f66df1de357e9c9e937bafe4af39c28f3c3e77df51198dae9651866a9af1c4de1508c1df5e47469f48fb92c953699c8f7e6cdba2fe26056aea6fda723da25f173c9dc0f8079dec49c0553435e5b4bdabdc8d8d922c0875962da79fa492e94f9cd3727daad3c87e4dd8663e4a3fd4d2587dbaa8f449ef95988d37f331ecbac8c17504f54dc9b625a5628e02046763f608dd1faea450debaeefc24347a883b409e074bf5b41572e7d2eb85465c4fb942ceb0412af0aadc6796dc53f15639c5b4324137e296cec5ff2482f65118dc542de542fca39b7aa56101d49ac31d6b35f67dc98bf963f1c0dd45f712f03ddf437792675448d30d79a28724153715fbf60d1470afe7e0eb7e909f10ea8c0c26a219dc39927c95f0d2291b4aa02035b2734b4326a19e2b9b01686440ee651ec9afc02c5875023c97112a32c3b8ccea17e9fafcaa0bc65ebce361e9bea7dbcab38ae824cee9c389542687fdd493b6f55e323ecd583c1fcd8135c8967cd95adca892ad6d838a479273b7a8441aeb1758eead69bd2e792975201cedbb465f9dd4b452a5b1cff1de6c7ddc2f62b457f88b95c86df2d315c301cd60edfc362be2ae8d1c7019a8345ecac3f48705d011dec774dc26e64b85a69a1271c5159dfb363e7e2579dcfeaff2093beb82456e57ce796f8f3287bf244608d44ce3795b0ce7dc7e167e57bc977dbb63b2d1dcf273cb53fff3d3c67a10e364f5b9e67344d1744f1c3ff25910873ad6357c81898efc29b08c9f466bd90c534c9f57925f4187345ea8820e4cb411cfeb6da43d1fdf3cd4360a169963e085d78bffa8c4ce77f0b475f43bc29214f51506056f565475711ece3a55e3ffa187e01396955dcebbff1c81c9f1634f807f98372f39a6ee51eaf6058c14b7c4e61dc95ae2d07c26ec9fe23c40f02f70260e4447a693415e4f58cee5740275ef5ce1cd1530fb7cbc67c936b507188e295a5670c0fea79a600587af667ad047ef83dc3bee006e0490faaba35262290a57f0b7c2160357e710e5d758c6e40019fd2853838185046534254218eb18d315e9046c6731dafa6e78b90486e8989da13ee9a8dfd3fb098c23d6ccd581946fda68787ee1c3d4ac0768a2c514dfa01261ea4eb0a42802a92b1b54b4019242e9100a384e9b07cc97bf5e65cb0e73aaac25b3d84ec21acf2a3c6a73fc5ebf0c846c3e91c6217ffea9486ff390bb4e61a21c95dd621d26f4a5fd15acc804466f40323a3c1554952a3c84715e46631c7adf2b8c9f94682897c15333826acf8fcef806a655974f0704cf1c91acd8dde6603e3dfdefd301065ea0f6d0b46b66bd07769f738bfa94cc057062bc845cf28176a7c03b001d0f9ba2bb8590f641ba05f6f9fc50c2ed1b154ebcbfde233f876b8696bd0f2ab25aa7ce2e7e0939fd38db9afaeed912348d4cd3745dfe4cb5708a96d41604d2d4b0ccb9c51aae771bb3d9108b190a92e496dda0c1211f9bd0452322ad00802a3ea05a5852e175306ab9d9bebe4fb8eafdfe8c217ec7e7fc71e8a9768f838f5d26019d0185324bb23c9863ef1f7b35c1d594e9c038f69c03946906ba09921fbdbde20017121fab72061fc2907bd3e8c3f0a9fe0c2c4c365bd2b304f82b32f09717172ce4d032576b0013e53c4a5a8cff5d8596a96070c1b8605a61e1c72e4da52108c4d46b0571efb1bddd33a7196d0dd8740e972aaeb819c96503990b2b7f71a2fe02df66e62b6aec1abe49eb7c1dd6152663952343fef26f172d1aa242d86bc9ce8e9a416af4d908c9431bc0b61a7615ee7cc988c8cac3b835dab60cb42f2ebd672f72611e00aa7ec0214b745a37c6f13012e3626ff7357ccc5a30c6b43a6484f87a3a8b3f8291a0cbdadb6f00922190833df4e5b89c8301c9f79e77ee3f2185a6de284c173155cdc6ae50a79ef8d26988db946c58b017a26dfbd3b7b507b107e50af523237c5ed8258a76324af6b39738ed780c0af5df0928dc57c9dc60755d4020594d2bbf94cdcdf6653f8ec76fa6fa76ec523a0df26631b153bc19341741f9afb98e8698651ddf21d3f106ac7a35064f252b73e6ce457842aab06ab48138918d2704c341bbc2392425036e2847bab86f8cd39d6ab6564ab791c914e5af530dcaf4fb29b51bb68ea55f93630d1420989e0d6244cd1a5c205c5460ca146d053c7a5444cff41627299285ae1f89ef8f1e259325f61c4bf4793e000e6e61e8c9aa2291a122a9025e4f13fd5ab888641951d5cd8dcfca1b4d0ea344f926b1bea53ebf2a6904b42040685a6f509c7d3dcf61b8ab3285a819d44b9545d5607889b0727c65b024b0e5c1e0b1ecffe8d7feaadde9e33501d1cc736c39aa15e7460e84fb1d23bc8b71ed67e2843f447519375877f6e833db24a4474057a06615d3b65b2cc3f5aa0dd67bd27def54a659786547cb5b9603df1663064e07efc30daa768c6300dfbb5bf6b97a18396dda4feeb445ae90d7d04c0d926f837a50300f41eb256427eab011f0b1a893cf678df81c0e16c7692d2cce4ecdd1dcba661abd8ddcbe2e3342a5a8ab3acfc43cfdf5269bb26585a243396d07d25793ead55f0f345c2ff63146c97b0d9434cab838be31028f80544af1726d6f89004adb50be49fe39b951ec727c046cc530fcd4c8cc5fb78efd39c8f4404ba5bd9735b44b35a1ffe8b5c89a62c0c805edd669f3b9618659b7606bcee7acbdd49b77de6be5a469f3eab5e6800b92cad5faad1b4824fe687c038b798f0c2d65213b7aa832a0e8ad636b6fcd873781c3ca948d0ef25511f85ff88b38989d76a0871dd49ca804183f7b81865b371f8d573e725ba0ed420476b7ad4dd2b90079b5be654d68da6b94e669a4bdf7dc57f859b7fb0e312614ab014ea94e60c88121161d68280c8c9d75cebd39173350d1702d2c15d6480fb3fbe81e063271f3d85d4d24d8154b846b722b5a0eba53bf480b0e6c9cb1ca1f3ceff480b0ba63682af80db794a736d4dd8d6e27fa037c678bce6179928da3fce65924a59c14256ed3e59f29cf0c331ac4676678a44e4c3031baa5dd5c226c38e400a0f854049227b3f8d976957ec1ce2f827e570ec5004b06ec9658d56337ccd4048e58444135020da35248510104189c0c914fa2c48a2c4d0eef4f3355cc3aa6bb1e3d17418f721587ee734de87ae7e44049b2a241bc9c2511849c03d3c7751f76f52611f17fe5a234919c05e5cd61ae28c5517e1d31a6b43346ff60856d60558d59a5d2f3ada2e89ac477b7bdeb9a51a22d23098d04957bb6d3c441343436bf22f6b0674fe0c13fe3ca1d3019aa73793b0b5110cd18c6a054813745f424769c67c537c15273b85cde31b7480a6c834c68333ead44927d2dfd56c3e91f3cd76094191168674eb2a95c7214af1677348131fd17e9ec8155a2795845e6190d29231504485be318b4496a15acef789b22635d4d9cb595ba426d7fd5ac9122b7d33c483e289ba3c111c67b84f492f96ed94f9389b64a203135250b6a818acebb8deb483d2fb634ce96d8f634d36ae555191a8fb978370c17350221eaa91d3fc150312d84ce38bf6ca79a6d715cff626b1c055ad8aa416586ceaeb8671a84912d7987e5b036bd2d6da4bc29870065571000060deb1ce4e932df3ebe1e521224eba468063b9c87f76bfb83e8dc65fa1c014fd9fb656dd8c6cc3d4443ce86e0cc4431ae802da48560c79b8e2554e01eaf0d9221258ba545e8cdc80676889b7c3f69b2ff8ae9d4d4c3781e7126c67eb3119f15a9c30a0d566b36af26308540930066744b8375792ce34fd97a455c0c607a3f0a0862eb6275fb3540d90a0947ef1e983e4f0f53f0a4fb88c94c844660c8d759ec385be83e8a9957fed08e892132f1cc355b5001304b98190e6b1ed8403773b2ae5d675f0f4722b91735dd6e23614b126b421bf92e24e936f95cb0f42e6972caacd8d5398b4f55986b7713fb33c409419fe7ea0d3813414ef83249c56cc3cacdda762dc04b8037b59816cc9461753ea9555795845f6a05a87ac6fc9ba4b801d09bcdd4c37c27aa868b8cfd8baca86c89bec4add5eaf5c670e45f8725e2ec5769ffb584d3eca65aa9b361d3f6fb48829fc687162c3516d9a05d793faed3c6b78b28189cec3d90d35b65a79ab6b699e0caf68ebd6472f86939f6cc7768d028d0ca3e7717ef48586623f5b53d19ba62d9465523e815984b717007df29f7d062d888574e6bed13e6b999a0a03eaa147580f92af5f09117d96fbb199f17c660fd225a421060e41d60129fc734cd71b04299c117fb2c89832867892b70e892724cc22b7fb7746c08f48052a8e400603d678b4d6a1aeb1677c64901b8a026f5ad83fa92c18d46839eec98187376c393961e042d697362a9a55229b4bd1af8bfd30cdb947e01d43413d7c06faec076d10c1896fa249fff181bb7a9b640491cd799d90fd4cc0dbcf91ecd366ffc436bd2283852843e45ac5dba662363f07d49bc3cf2c145f063483e193f6041a4b6cbf4446d014598c9997bcbdfbe025c45a058347921002433cfb0146fc93126f6c9c093a9869e77c4823779b9425ce84060141a69b9d592db4194e093cb744db1ee7d0fd4d551eb3172d58c6da375098264cbd25d7386786ff7d251141a72ca1582fe47578136377a3235613ecccce708a3cd3ea050e9cd2d7bef058600d8b90425efd95a3f7f05fc06736e9d05595b729e977e011252c881a1d86afd6d2346d282b40de0db0d1821d0d1c933e74c0dd7e5b61236bca60bc644adc7320dadd0e49f23bc8605be5e93adaa5d3c48f2dad4d009d11d32917271524efd3e988c0a15a81717744661160eb4ebb972add00625c985766f36fb774ae798d2cf0231379861c065264997539eb61a47cb269606f8b3376e7d79b3a082621791fd142c302bdd6af63cdda943097196ec0610ec72cab9c8e6a6dc4d1421e85853d1799dc3e3ccc222df78ddd4a09ee5e434df83ecba518f11feda52b346651bcdefbbc61dc8bfb0a48d14177ceaf1443d9665ee9783218491cd3fd437808e53e0af8f68cabd9ef8011cc4bdb9e8ca93f45226246f813eb3dca23d08d9bb71664e6f2953db33253426c032e23bc5a7bd0114684e162b63d1f0b282d5fca78bf916dc39322109aa951c0082daa06f98c744b32aa7b30cef080c10f19ce79dcd63062e146105628edd4f9d370bdfe92a38ed18d7ddcdde859c24d81ba97154698279a0ae964f7f9f03304ac2048aa13ffbf8cd9e717a1dd80936b4222210e473ec3d2ad3b82a7376cfea075072f7f2165f6e7afbd2a3ab7614e843872139a97f8d1bfc8971084c5bf79d57b59ad33458b150b3aa53a8bc080a4b0443798069ec4d57a01d264e43b7b195e80ff3a8ca587200e853a3ec2f8bb7cb55247f9950e07fc3b03fdbd9320c726a0c5bcc87d89e56672e835ab74870ff759bb3c9e6aa6f4cbcd47e2c31a96b0f7ce398b8893a14a250152677655603ab87811d8f921fd1d9d4b8c9b732773fcb6007e3dd62fd273967aa04683178e1c471d12279c15eba4d6882eb4dacb12346aeb833373c0970a6f365b9b328915ab99b69177296de8fd588434edc8c811c7829aeebdefc110102b02e458d3fec645b01f5909298ec83515ac158ad56b2bda2d9d3bc0c7c0048249c404b0ea16c3cafa7e8725dd81439c366f890be93f23142489d1888a2d5719d5dbd06f16589116ec9643dd8f865aa13c9cb408496eeb9ff8775d10fecde2231ff2784e662f87df882e707cd818b21cd7e2c2bd755694852e3c420c735a24c9c312c8fefc3183371ece325e4673b555811657d3fea89e1dad6426f581f8d8b76bca7b63382278109e75797d8feeb8f90446b7adc59e998f0e7b91ddce9d8ca3e8e2472cae971648c1b89f2f90ba44e740bcc2bb9f4046b92a9c47e14ad5063601decb25a79373d6d8748126fcb542d35317e9ca17eca40a8757160946af897219bf9dc76079a3940c69e37d54c0c19861b9eaedfcd3ff98ae6a2f8261924f66fb6a4b8f912bcaed388edff4062411e179d84fdeeacc477a9b3c4ba7c06639651368df26abb05f1b2b5d38282992dca028f4ba5fd1fe058d4351b2fad2df402ccc9bb5219f2dc59d37ddf147afc714d79e1141c67e54395440a87e36fb9ae0ddb8214d55e7208f497c29b400bc67971f836d106ee5e8263c4c82fcf8d2b9fd8a538a5f773dd61820c4bff311447e0008567ed9fc3fb2fecb7ad9a54a20e2aefdd89a98679f273df332649547a8e5d62158899e2332c7e59dedc70f04ebf9e5c084fd91e089dc2244dd25efc921e40f55cdb736babcd61f9e2a4d1f0bec17e184286547286551ba9c760b97f4ebc6ea3fe512aeeeca4085ea5942b720514b0de8cfa1563b251d1b8854c23b4fe86e061859b2f15b87df862922ba99a8a7e715908db3e3ca78900d514b699bef6cdbee8d54fec24e15003c792f244e79d4a6bcc570ad54745730c339559883739e5beddd8b690067e152a101046ddf67b8fef3eaac7bdce6a18c3f714ec07b5e17f8c63faf4f22e5ce3613c8e4321b2925f3dc4171205c5b88c39d0c3da542657132239ac060f9e3bcbe2a140aff2e1cc28c6731a3d2587c4e9c6d267f5fd957d57278f875b7bf7e189ffa5527380289452e24380dd61622695ce97d3ae81b016d72fa8e20c5bd2de3075c1cbe9388d1b737ed19a213cf84fdfe7952bce67b23e601940c8a952b7cfe985771cbc98e632cc2fb232e48bf2cb71b72cb7b2f36e2ac76435c704ad27c1888aa01d3e92f8904dac2c24684daa3126d8c20003a3edae7dfe2dce844e267b4ae5134781d295fec36c514bb1f81a8a06e4401a5428d010fe8d8f4035caaa4972968b04bb176d6025cf7adb65bec4a677c9fa0d0689871c8a65501711f044d1f271bd7be95237fd802cb52b072094dc25e969dbb1d889baee29a52bf3826dc4030ed71aa18bdbe71f4959a30fdd9572d8972321f7d511988e6b1b1404d4dc6278fbaaee6f812b63601c95f1e7073de88401e197bdced454ececcffbbf79593b7fcd53c99426c8d10246158aece8c45dc6280647a6b6d56679259361c02add8fae23e6894d082480d6441403b60e461df97334510f9270eeea52d82c421fe087e0f4b88d8824f7377343bd0c4f13f259feef6a85f82d7b34bc7f88451db2b8f8f3a44140099ec6445a00aa7c9761f58b24b94ae858b63976236b38558cee3a53ff05c9a745881630a8d6ecd0903302c95946c825294015629baa4167dc37955e418abd6673a301cae63dacf703602eb468acd1aa831c1045f97eb6dbaaba38c78258a1a2b31c3b75397818f6cf610a5d91ea82eb29cb07bd098bc522251f54850707d2cc07a78871ae1ef52923492228de58fd543fe8f59afa8b6864771223fa1b0c84e4754ac1393e856332a749f73e8398eb216698ccfac63b0f9afe0c1fa0decb436b5b2bf83f31cc0f47ef11de41b25039641572c87cbdc620c631f47cff93d0ce9eca8838dd526d312e163bf96b480833919a1b4944acc1b2db9fb81e0aff4ecc454f3368591aa1d8b054bbe566f0095b2ecdec6e234cfeaeade91a718f03f24593a504e479cfcbd05a1278d43cb9868b3baa6cfd4e717b1b95a9940ea85585a9317341c97fb331f0b35ac976bc2182b67adf14647d03c529050c43f6d09995ae30554fe32a0aeabbb43afa9473a861c1de8a1a3541fe80a5a49213e25afc2b6650834721f5062c9fa77aa776d8a3946c74e02fb6af8bfcdcaa47cef3af165d24d883bff156072256b2794cd92e34eab6ba407c444bf0fa9286a366c2bc44395ca2ae902c79a4605db72638c093859d10169d01005e61b00dae43f8312dd0766e4b13c0b1d54986c28afd45af538ea1f7fabe1aa5d335174ccc72f213748f9b860085e626699099c51c6e0704a5d3bc284f7ff281a2ca69b0682c73a9cecf871d4dd5d3c2f3f647935354d3982bf9bc0040c2d309afea42b907b0c43b4cda47ebd88c2b5f9e172240ab510347293aa1aeae601ac8b915bb91deb4cd9872a14b18c48f3feee65eaa23ecf60edc7d851400ca5b760859650fe656b16c1295b78b73e4c6dfd4698071d9820f7e524f2f969f06a4849907466d3d8dea428e405bb1e771e954a16f67f394920e883f5308a8c605f80e2f76f6c307ea9b04d3f1c0028a16e147d2ec2e7ed47cbd200ef6a40a5931da83d2a0eef9fd20ca5d2c1a3ad1e2735d00a1d1686fdf934c3c1d8c62eb8682071fa9fd915ad21873dc5f03247d59bbdec096f5b08905e9fdb5ec5d9229f6f276e14f0594594d0f35e416a4e9a4f9c821a517e0533a85b6852925dda3b6aecf0e36f9ed16610f5300ecaa1177f56e0de8acd456605284bc42918af74d1a0b32288c734c8f85106d25a3dd6da56ed82f63e7605efd97f680a2e22fcf0025c1db7007ddb17dbd5316d05fdc9de03890c5c772b5187b2c012563cb89b95875ef6f75d66578aa0dbda6539cbca0d6f4331d45b2ccbfb8af091324f9c5e7af7ec23210293605f1f5b8a82c1325a25cdd25048c0dce539586e013938001a12570c67ed41d50f03cbb59104ceccd59aa725a917e58f50599694410b9b7aaa87dcc09814bb5bb9a7ec2ebba1a65479218ce50066550b909fdb707df2c0d0469b76f70c7b8c02c4f69c8640a26af2b357ab1a8668816711361e161fc052bd5d17c008d1edee1df70026161ad4825df6a24c9786445cf64f2198c23c9866d4a91d8842a79f6c7e9ea4d1840914c0da68cf85a84264a848343aac69e80f0ab5fcf7ecee17fd7a79d7f18abf383909547814efe1463c86e553afc4b7bcc7522069e1355834cf1031076ae53ac61ef51208cbd9c4e9f2ca334f4043eeabf0b974a385cada3fb35adc95b0466013dc4016b581ad92542ae4eca637e0fdeedd9a7b3ab6dd3f0971d9ac3bc9b0b64b1287a9c9fadf18c88d27f2d8b50677314f52959e87a47c09cc21cf94b140c2008d8d2c7a42d27f8d14a7d1c1848b3a30b2f58783668b7a2012a67e35cb4265b5f5a877c3ff417f03538ebd2c28b13638b046f31bc0c1e28e40cea1144b839cce70956a0e6f06a4d598730a9caad30102a4437f30d9e3cfd7a5d05fd60a6ee6071f3eedfaaaefa908cd9ec9a9d95df5a632ca64eb400391e179ef92315aec7dcbcdf149208e183b1167e209ba35e9dae1ac178be4e06fcfac758acb519c397bba2f9a1e6351cc9e5e81f815ee8cd1701c9647699e4cdb89c3577634152ae24ab7fc53b60f3030288ce3f99cdfb9de52b6b42c6debaba57065b673fa1b28b3770c0836c65375b3f784b4e1eed40feda391688d99239735c677c3cd88a20f8445848c4c89d41cbefee9149405dcc303059d709c45128b23716d97814c73a1b9704835d7ce8b1220edc08eb99608021d666dd6a166cc5a318d1e4b4895fdcd8c383e4b11dc150a98d7f1527fd657aa2546a138820bafe6f53d7aa8bafe733807cc02707010cd15471a426b94e28b9857e8724bc0d7b86ef947934e35186555eec9a7cc7f59c44c140a0ec249fbee1be49b91c4447c706183d8edb4815d3c3dfee1b7fddc8d1f889174cfe34d60202aa709ac27a2d3bb20ba427969876cea283bc5bf66ab9ae83250fb1b355ef5cf08383bcdf53b4d658f9a205f6a70c82267d320ef2bd454df58a7e2de915015959baa5e5b5207dd77677bcd85814b72c2c5c1c70cc9c2a5b483cead3caaa65a0b0f517c57776383a762a2254ed175a116cb99eda1ca1962a12bb7bb83fe26e73824d46e167728a17e6bbef3df81682b8c4cd12aaba4a16de6a961bffaf37feef5195219f758b72eaf23a791fc349337f8414e48bc1a57bc1248af099bd5a5f6adf3ca3dab5820e5326da363f3db90fb3f3c7ae55e03a55e09cc7f15a709f3b2ac03a17a32020bcece5be125e22b49541a3538efccc94b83cd15c73092fbcfb9999dbfe89e95beda5d77e59e0edab549ebeb5211823dfdc04e2a3661262d21b193474b5ab30138a1ccd3b9737bbb6204617b1c60f0f28ce355d25d2f4fac18a4d9398b4f5b577b211978bebb17d46958ea8eea8df85a3a35910fbf227a10d5f00df2a202da3662b008d0f5a19be300b736e8aaff75980ec09e4047764b1624270d25ef750896a5a8104152e3ec763e61cacbad27b88f40d4ba17d4109077e26b5f6fb0393c8e9e0fba60d0617df4356f1a09cfc1ebd22ce620a0eee698a00995aa9db96dc3833450b3ec306621d63164abc33077c71691a7a2376ef33eb11763093f0a6a1b21271504d4ea1f77eab1b647244cf8a3ebea0a11e49df1b8ec418db5bf802945b8d9258059c2648f851643db0ed02921c85d1abc419e1f5816c32b799a5189ac6e32aa9dd77c1f18dd0161745f48fd4d5c84d5ffec96cfbed865e065d0340ef110a5b8bab965beb5e0557f1868ad00e2cc47757dea08a96cbfb88e110ce9ec564cafe91033b88261e9ad7af777af622c84faf5064c662e8fe8d76700e0527167fc713245ca66a376328faeca9c0dbd670bcc57a1e3901d7dd6c20f3b784fb3969d95929612cbdc466883c92ef2e67abbc6a813423003aa8593861ba59a7d7d255159203baa7abb2b8a00ffefab10e0f093b2f921877c49f37a5733768de8879bc4b13c6db7e397f4d66040d716be34364fa322ae64396e7a0f62d950dc6408f186cb65147371d160393308eaae0c81c5b70b20a58d0302159fb3a9d4d8b0b64b9c685b32de6192f01109aaed58f093dc31a7c31cd26dd78dc74e7790b3a137750730407c70c4b497142e8f68f40f514b8f30f48e2e0bbab38d03bb739f0216a55422bb1087f1fa807a6381ce9255bf2f577723047f13290aca30a0d0c2d61a2130c9ed176fab58d1500014a4208ad47aed1717f5f6bb3cd4ad6ac1783893cbd1a6def617a1dee59d11eb715f65185843a3ab0812e5044a1e26ad9edfdbaf41e95d5e8865a130f57cdd760e9f4035b8c465a3784ca0af289e361ec716d7032568de83a5d067c3f51867cc806b931cd5338f4612a152e08d979ba57d6820e3ad86f719a4c7e3f64c5575a648046a22209458d3cd2c336b05f5ce48f672a97fad47b7a9a515a4b1d269a2f0978033a28d2d92d6fe0c07770a7e575e210ce666e24473c9cd8d33d91e6cc6983694e5468ba18bf876a7f9cfb5aede025b7ef59f409f1c05d78da4e8904d2ca9af21455bcd8a361655a536e53b186575908a35a1df8b940f3b1f413975054a0587b59406f92b90b7c57c99c1ed0b2d91fb298ededafa70bb193aa2dd166b71bbc603cbc3c0f4de90b4cce8c1a2dff509b833000f826815a3f8de6fd4622ab2f99d437a903b9756b31e63c7ff6882da46b75743a56a53106d533b1061ed8616ba7f929596f91c03361d711a6e190f2843ea00b216b86f51ecae40a9c90f02fbd6d86d4f21e28b48f12e2ed261df90612a7b98ad8e608ca4be46f19524cba402601deb807a0097bdb08448ff9a1797b742022a4762cb87b5736b4adae4eb853a6882239111726968feea29c477e75d9e4fe6ce4a56e2af4600a4e6a519bf6cf71348c23f9c679293a9afbe0d311538efc839976a0bf168eb4e0fe6057689c44aef4020f075b80cfc4d202caeb658bd47094fa36bb512db9290d09e9b97891a86360d5ccb84d385f2d09024a3490d0e037da17225742f7e51833cb2529080e043b4aa879db3e9b2521664c690bdbca16b89ed917616844b9af39e010714a95840d24132fa08f90461d70532751588c6d3046a3441952ae6fe0aebd78aa35e6a28364bf13d61ccbd5412568a4093b7154b231c8cdec2dbb4c86789e25f43a197912b0f8b1286c481c75e480ffcb014ec3252dc61b2f0f172d3877cb320bf86ea3009b29c280e15972f02dabef1f5027980e6e173e78a4dbf3f1c96c4f66cb3f5246476336098e8578fbad67c94db65faba823422054a5c66e2455908e2c6cdccfb7cb113f512770254c536f62293e33d7b6d84348278b0367b1e5bc38e9f5980b7679b33bd7dd28e31071b87366a985b2012bbfc2a0a35d08624bc7e7a42134796903ae294e5b9df095dbd4877af4dd46284323d4e2300395245f9f2af3d8e59a1c43ccd7db4cb3d82e107f43a988257a66407a2fc51c18d690f2b1f7a0c4eca0ad1d4a02826892bb68674f19e9d800da08e053050b12a33e9455a8fb383aa2fe5076e39e1c5cf2e9829f3b80fe9816fae6a6b0caa9ba9833762432ee91b49942e1a8d206f20b6631a771f0adb97ac846d7bc28dc06f9351aaa5c1b7cebb10a1a6489bca98e4c32e7bcbfdd1618892335eb4e9a82668a0fabfd66ab470a20fd71dba22f7d2bbfe55d832bb233f29f2be3e5d27a2ccdce80e45b76235d8e9224ca7d461a6086a229d490310da8387d40748724918cde25939063b2077ee67b2755fcf2a06df40c2cebb47db0bc8bc15186b9003fc9e6a00548e9a9a21e90d04a574dc47dac6e48f77df2ba153b69b352450de35db3f4b2167a262e69bd8505974c0bd3082e888dc9358f5c0b8db8d51d155efa818b524bd87ca04711c38c9def92f263df4d463b689ad4151859d510e7d9c0b5fb52c38df0040ff2ce1ade9909a0b06451f2d5bb11a86cd98f06cbbdedaf60","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
