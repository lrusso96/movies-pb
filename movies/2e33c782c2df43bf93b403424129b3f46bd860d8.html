<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"74b1f57d4633fbb19d90da1e59a864681580477ebf65841fb8a2aa0d5fb4f54b9c686284851f17c010885683c64dc5dc897a6712328454e14d81d752c53b42b06066c2936b2133f5c569d94d5f8d829fbf75a2139e0d7d092b0b740432333adc8c4ddab5a507a2e4a6b4b59c16c64705799ea24c077954422fcbd2da275cb423b9215b5ab17374351111575deadb90c51939c986eddc1fcb3e2e45238320c230873bb48034bf56399a1656bb2c37a7bb0216ca60c35654f807992acc7f83367d5b6054bf98d984a6a9300319dc01e0785cb99deab11b39a5c54c9ef5aa5160d8912314021b5e2e4808cd405c641a5038f93240a3c8cc3c0a64ae4088daf31c9c8d3f441d9e39e0f326e94510da43368e1225f50fd6c533370919bbff1dce8721a7315b5686e9137f075e20c9d92b4c64af1a10136f58817c6526bfda919099c29b5664ff3c8617d1c44a03da7bf67a33484a8634b2fcd4531552ae7ab5ea41edc82e7df80fa0528cc8387e3171ceb2ac2626f735391b9c7d7ae306a3f28f61159bd1b77fe6990e4eb4f45011398908f7cfb0c14d24569548fd2fefb48b8e0380df91c545438c839bc319138341f45419012a448b6f2f8a6455ccbcfc9808075c9c3941a317f66f4c2943b3596fbe3016940d52294946178eb1c358be01716134a2d19d53acdf84059609a745d10a04f6cefa5a2931554dc9ec4faecff76231426c46cd37f5a26ae7f8e3b8a3f17055392789d48327a73ca4a0bdc0390ad60b0631b1b3980715f94d67a7490fbdd307599c3bbe9062349f1b70effd47a14e5ac94309a0f63de07a0b18d106ae47a7610909e4f56f5bc89d17aa0ca338839f59113b9a249cb7d93b783a54ab29e2eacaf18b98c8fd587097b397854e480060dd8337966c5c9b671cb39fe5738813c1bc044d93f7b650f0bf87409d892a6aef0d14f87597e4e6b463a3df61342f6b8dfae6fc53ebe003a7381a3779bce2c20c282d96369591fdbe0f82604066aa6faaa5a1bc9e04d9d8f9ec1131c1f4c056c7bf051083d97b94c111cf1884db1dbf0e4cce88924dfe9068d8b2b2e812a163f3861816e6320ca546243a36e34c8b826698cdf075344af95df88e4cf5c06a0951728c8f70af0ba2339e9e7f3b1303598017c2e7e633b2ed257f77879804607ea5a9334c385c3ff377384934ba68ce8b1e8c074a19c35671a0b4923b600266cf8fbe00ef5d3a466361a7b9d73ac3b6564846b3fa3ad4b4d6e2a5b65f9b889543a426fd6c02ad7443d395f85173f7fc3c01caada401bec65beeb35589f37ca59b42ef1e56243d11ba51481655227b4d0b39824ca8ba007b7680078e8582555eefa634de10d19cb95dc56a17a10e7b0dcb4cee97a7cc11fb9916cc715fa62b49b8d645248cc2a8ef4e56adead5c97fb7e7e9b1c5bec76739c58978a60c3fffaec4fcab65f28018d43389e056912e3b1f8e9a00d54e6d96d2f3a910334ce2f464ba83490256e2f534c15652998147094619376f9f995eabe83a97b3ae97326463fa95d9b7117ad4d2f0ee5591db1679f15a9da43bf6dd18e26dd36e86b59291b2370a389f5a36e55376d0df70f5417366c26dcfb5a9a0e66a82f85f74d7c08e92b3ea869cec7b9cf06ef450aec5298f3a6b3600819618007f0dfb7d6f581db93a52332d23ceb8fd7b6486377ccec1db46e9564997f87ccb884b17d1038c4ac88e66efea328e9b53c5b571c95fed0569fb305aae443f7501f0af49cd266021021f395443d4941e176c2872f5b454109e2c93690bad41df6f588fa4dbb5a242dfb02453ee5d6cac609d6df54f2280ed719807ffb6ce9e7e4c81336a322a61b0d2b4814e184c0b97c0f0665693e5669fb2fe978af1e54173467e699e3283b642bf35708f17fa1c4380c65048945d2fc411f0f56f8ebecd91ac88b9014ca34de58cf338ab6dcb517a4df5a3162b4453ecb0bcba2b60621af41be897a2f053bb9c06022e3aced05dfbb3b580febb8985bfbcc7d326018d2ea5ad9370ad83e07436a6086e168b5b1ba937d82238faf3350051f801bb33aab513bf0fa8ccbae4dc656246b5bc7c8d8e6b0f63c0f85aef3486ca352a1648fd6bfa5681d0ed3c63f67c6e4fc8036f2ed639e8465366175f955a796ab1fd68ec9a65032a5fa5a4d1b766e0ea827ebf84e764fdb7e2bf3078f05dce07f4aec4903eea4716123d9255f93613202ab6fa242bf4e1666a508cd34ea8f37dd456d5b3fc5cdbac3eb7c8da54515f34ce26a2aed0a173135c805727759b9df809ca8edcd7a523498558282f51f2fdd02e0d8453d91f4b7583fd18e06e7f4ca058eee60f54cde30c31d43df76a3b0af66e344eaa4982f668d771a62d6c3fd564485482662bb956439797516d76c3a4a61947d5861894799c7c1aaf3cfcd763a844da73b5215e1e3c4b9f59fd9d3250c15646b39f88a92414827a6786c188b28f0d38ec8f527c4601f99e6254ab01f0a5c92969809ff4fc39371738e003a81bb174192b61d4fe428e873877e953645fefaa12789eaa24f4a61661d03bf00b7789457124707ea9ec351f950c7010731b717f7decf9d93f22bc4e837a89b63c06aa7216db478d79f07a393fefe5e8387deaedf6a0237da87c07c326fb1c73a9e99e7bb42d958877ea0095cc43967fe6a6ba94ed1401c8a14180664c420e117d9655319e167392885d34cb6c95870e14d4f2e796eb12b5a0f0667a7866feab48522185cf4f46810ef2b9744974d8725536a20cf06c91f22eb93506456bd89662e617b06f0b7854945832982a3543ee3c6cb5bad2d81876bde09f8150f00b2d31e2ad6345f4164c0bf122a2ec86d5fd2a12de07a83c3155327d082010cb94ac326aca1307e6fa836646e75e04f0f13e4c2e906de5ab1542d7ab742a3413116a67ee2d089ed489e3de816dc952c252b3b12d9709a313b03e69e7a2c426c8be5bf49b73ed3e5568174382827e8839f4aec1b77e6e79eae9b1ddc0d0bce5d6aa060658ca0dfbc5ad677ba0b2a26b86f97b3fb73a6eb5c4a9be8f48f154cd64aaee35d977485f7911c513adb04c8a746a3d5f21f6bac2befb36c3ff3409caa978a6ee5ea7c73dc6803d990fe4874fd71f59c199e0b1806708ce62dbccafd0a48b2d24ba4d5f384bb786a14ba852c602cafac1a7968513f9f75a5d3aeb9949f1bee8b5762ab8d921555c8a1114555bec5f336847953a43f3a51b8756fdfb2ba3f9b73833c63fec134aeaf4b1de3f65881ba6c51b49e6d1c7f4e3a6d015a997fcf15415e211f2610f3b0c962d20f3df405953838319452f4f6ccdeb5c78d63278f9a375dd34ffde8fdc621a50caa238de964f23515700c8a061e2d29f95729fdfbe1fab9c5187bec5c497688fd33b38d8875676cd28b57eb203916b347532a862cb97fea416182413c93c9c6ba2a3db05d1d3870da1d02db8e3df286fc83bff47ae0f3953fe2dc9eaea7098623bb56cbb38cebfb9339dfacf08649cc438b9fc17224f686150e04836e9b1cb39e2da3cc15d47e8aa45b646ebff156c7c585f9f0ebb9518b7d92160604d1ae2b1f08243a17bea1baa6b6680c6251596a323913bad0ae15650d76cd7da0c4030edb97f3d834aca9aa72c9549ca0e8d48738a6d911e899e361265f3d2a2edc71cfb71979ed55ae44c9af4d0d141ea992acae413e418c251c2641463a6c4afb355c5f094f926d05ad8bcdbca91045c3ac11db76d3160e89312e1d3a9042eb7b25ff9e6a6f61c06943095de669627323911005097aef9b7993de0139e70e230cd73ff113fca4a957625a98206a58bbf44449e380841d426692243980248b6f96ee779b2550eb12053bb8f6e3cdb1ada88688902ee1f18463cc075713d867ce7ea5edf421247e2083257d302176464728d75517ef0d43bb19d491645e415a0c9e22f0fedb1f70344006535a94f594648c8eed7f25fbcc3d65ca7fda73652e13dbc00e97d7230a1955c588fe0901e179234d079688abba88915b51a652e1c714663f8024d612d77f91e6c77dce43f33a5294d730f89850bf8fb2cf8d6b3ac8f15dff8155305e345b837ca0df498223beebf462946665828beccfbe82e970687a713295c9e16f12a9912100f0c1b17ac877f0ecc8655d92bf0e2af39f60caa9ea64ef282228f3d84ca08ba8c7f9bcefe30bf1773c6c57f407109087196f84dcc97bae2848c6ead4f0a7b3864ff3ab99d0e3c5a61a31ee29cb735da7439b15d89378d1b50ad66b237e0d4309c0ab3728b109b782965374a66f876de4e63f92f2f1eaa878ab9640fa1dde77686c319c2659ebcf1d8381a367ba238818e0cacc505bb4e7132818882731dd14fc5fa6172c65767bca4bf850b8dd0a9f9a67bedc8e7a74cb587e6ec2db5258c78645f69b35b52b4d829a31855bbfa0474390ab037bce9e3db2d953806c8363464e3fd8b04729fa019f13aed52f8d76d6eb2e530e74fd1271e1787fea83d55fc149ac7916dfce8add2044a49edb24c658a6417a4251fbdee6033be6d005dce05d196d34cf45c0c3f64fa994b512f137253377fd02f98282ba414f9cac033cfcbeadb1d1a293be40a65d3aa2a2424508cb38184611307b494d4a7aacca4bc2e5e2744f6da1b8205be17f3f769f7aa3fd9534b5748bc7d325293f2e692657194e387d8135caa41f66ecee1fcefa6af524b8b7bcbf058bf01d2b51e34bdd679f936d3dc118a3b9341cb989f3459236f48c59bffc279f87c3a49fa64fd45201c1c15d7142c77be4c2b24a68cc0693cc628e47d86b32ecd85e0e098ad434a90b927b053b627713068489a9240dd022c3038550816df4919e6314b8b33943ed7685a14fd39652b5deeb02190c268b59e226a2d2faabc42bf0c5e1d92ae06e39b12630bd165d94fb22e9e8e4b295e9d59cc9470214a78b2c13db264df4beafe94f6644d408c35e4b6d048de3e87f691dfbb14e89f5635549d02ceabdacac1f00245fc776a81c0f62e44852d276b415991efdb6cd9adea4026780394e39e0e8c19380d325e87d05131eb6cb22bcc2ad8b7d1f93de9639c05dc4248b178582ac9a50ef536fb6b49500b9c999a714cad9ad0122e9477214f5dfdada150d73dc96d915ef912a25ed3221dd7aa019b184dfa8744d537c7ad287f72fe841f9e2ed73dcbe4cb05650d88eb3b7b453c00b4b21b503edd363d3b4e286031634795b9efd76450d90846ff28837d7cc3235db790fed147adff592cc10e6c7aeac1641218b8d5e23881b953547482bea2680c5cf662b06c88f7c88986d78f4aa582a6040d86b3d31a9028d2ef56ab29445aee4907b423158adfc55ed086a3b3b17212881a2733b2111464b9e7a8291b3ea2e2d18f754285e0cd37a843e7580b47280625c28c342ab2c14f2cd446fe0c0300a18a7162023dc27ce611f21f395ac15e0e320099785a6853ea21a7c8bbf403080f53be87bc8e24672c8f1e939640600f71b341cc7b66dd13ac9a2b88c69f793f40036026b5223cc1ae481ce8bd7b7526e5218b91da57b49fd1f5909b194b77b06c8fad6b68d47cb04e4b8b4e934094d2a871bb4f13b121615b06a848fcc635f514a7c19dd90974fbd407341c8dcad71d4dcdd751b5fcd630e284a9ed5a46e0690ad2484a700c5329aa4cd407cc29ee3dde65d6dd5961179db8a883845b1f3117a2721fa54a6d26a418b7187aca49c562f3754e8880c87de27de8f29694312e73de354a2bc9ecc9ad46755bc962a43fdac1b4eef17053a47687d8f0c2df699d23bbe35f03b45ca76ee311ad0b042e5a81f0cec2f02379276febbd621b3f73379a360eae710f8bf7f11790f2a2d9b9580f988dbe34f990630819135ecb643f3c350a309c78ef3e8f35067205ccbc134ab638f17e29ef7d7715e15f63cc1d8acdcb5792823670e048ed3ebd271b55c0a366787d29229c2235970dfee4ada359af53cc9589b5d20a4ea3863dc64b5b4f75bf49b22d6e3376aa27962e1bd8797732993e4cf55f4a72c778bd94a5a72be818adbb9f5ca019d18fb5f08eb37e23941ee000aff6a926d28e615b4082a283011d6122a435bb8625b01a06d58cdfdbaac9b5a3fefd02da4abfd27297befdde6ff0a12a7b1f886c5ec691d35efa2fc9c19e48d922411087aab1c9c1aa7c2a71444e2d9bee8a96b4b69a3854b0396761e6399dc478a55956cd86d9fd19422e690c2cb9bf55d53bd657712a170ac9c5d40a924ceb67ee2b30f2ff1e76a220e3b6ec750182c130cda7ed3e2561c845b96c80ea0325e4f3f84bc5c06d368cbccbb9ef84e41694f88d740831be16c0fa59d05d112863a975e808382c2773c4cc768420201a6223f643c4eb7aeecd4699c4552770b6f5d27c056394ef3536b58febee6158df0a88ae7b7b5a3cb18c3b9270f6939921301a79dfb65667d935536ec420bc4bdaa85d0114e35949b6ba745270eba6aaf1f8f14b48cb75170b487c8430ece346cefe386fd7be5ec5902e4a2bf47b6dced70f38f4878b3c88c8482b345c06955b236308e2742def765d1116ffa12b7040609530ed1dc34e5b9afaba8fcac41765680dd47ee11d403be2909b5714b27a318bf7eb26a10fd746681cba5f496abc32bda1f09620e474087f5ef7e6c0ea9b0556c612cc21d28cc1b1863be9ce011d3ddcd78cc0d2e6007f883ecba0bd8e8f3d967597c6b0f7f192563ebc59a8e99fe909cd62eee9339b2b283d9201e8c2a4b02ff70127ff6a8357f274e1841ed4926b1fc4b72ea5969c640a6bfe1fd526c343c31762f503ef1e15452c5b868d2f53f5acae5068af17364fe243f8ed44dd74d03b7e1c3f90b422f456f6ed04de9ec306d5d880bec60af515cd5dd7fe3870efac6e493df3ab5a0b4b0f761e72f1e3a525bfe395c174766e87cc546fe0ff155ab1bfdf1037db7006bcfe9475c8c9e6cf6536d67ac83a1fe7f88d4bc42328ba5ed706ba0f6fe7b43d419f94e247825d21d9674ce337265dc2bdafe29995f3372f10f89fbd8b497a19f8f595806a71fa1e1a47ca818f2d46f848edf424b8e5ccc913f1c1eaba7289be0053029d131b91f992d593b5b528136d6ed25ae4da74d1aa4c8e99bb6b3d7b31cc83ecd31d656b0324af035f36dce642a54b0ac659ac666beb2022f123a0ffdd956cedcfd9902668227e9bfca8dcf44c468c9da5f22d900206b0329e29c292b35a1a718db957a7d9707dbaf6caae83d4cd05cf3d75b19e8fae547d3b55a1f4fb555730ee62393c67c9aefa30038b2f1c86032b195ea9a86f729b8fc7a6cc2b15bbb9af806ebe0a42dcb2321e49b747739f26c01d84bf7046960c33391f069e2afc1f5296a62982ddb898c13ac146ba5b4c7d24016db07617c5ff9497bf5518adc1f15b41a7641199637a5b719d3f14f325ccbcce4e89e985f7978a16821cbc69690ae58703e6b8b13df298b863592872e28850efd0f263433e3a240476b2f5250c68abb9fa4808b9afeaf90375fd6767f5e1b97c77b4b3b13cea9f5cb96ac39dc5ad3d656d7db615bd0f4ef99e96b4db0e8d3209113756b8ca3aeb87624e95518e2035352fa51de63f3877706f755b97dd5dae1dd428279303798f467cae0ee6cfa13916fa4d807d84b2634bf9b31fcabd6ae044f43f4ab96f32b5c14e77bc8c722ef7364f2fb87fcfda1263f9153f43e2a83fd36fe5e5e9aa059e5938b4daf061a0a86ba04439084a11d257533132bb96683f7ac9ec50268676a826f24cd097381f7717e5d1a181ac51423054c01bde547e4f2d584414148d292b517b276a8a726e1c35f9b15d678ed707a5d76077325968606bdd11fff5bb39abbeb41760781d38093d5971a6834f0cfc3ce4a7bdf9c01ddae8fe69969d5ec0c8971a3720abb5aed410f64b9fddb3daf6bb6960c2e726ac54fba17b703aa46165650a7a0b0ae0eb184e1c339d01576c32ace769b6271a14e4236f69da3c6d9a4bbd3c5a662c307eb1ad0e661852027f11b00752275cb32cd3d3488120cfab167f3a379aa8543b7431a507f15352371819f8394ada2f2073c7fd3993653dacdc0ff9399698a71745e4468c3f271c14be609f22db3cd1004e63322fac674c2c49decf76202ba6fc5b55905571f15a970ea6c2b7920f789ed4ac121be953f6aa1036b9312ebe7c0919182ce8e21ee9da00d3db17bb6413afb9067637f5d0f4bae7b3e86ef433de3db37a8d9562a0e41a45d022dc7d674211dcae044f9b5cf0cac062192fa7db6d9a4a26f5ff0ab948585487379be0b163b04e63b941d7acb085b270c6705b115aff4aeb9c4f6aa8c32fad906f62cfa99f5ff7b58e9d3374b6527e22532eafad7db7c08d748baebbd6fd2a4898f99c181ad0e38fbfb1fec290e2a3f99149b317c025c9f6b31d6661751b30918859a1012981f3387064ac4556f6d6adbf7c720ae0f51bf567b22437784b1ae710495fb0bf598850f9e8a13bbaa2dc2ef00ecb7f2bff6d394351f82d24bc4b8966df452af81273124a523ad835b2643dbef215d316f1106d60802e57db469b733644443186f652d19fe8618a995994eb646a5aac3e9d2d5c43679b25f085b42fce1fd0aae0469a12423820ca1ac13874bcb7fb7fe7f644f40aa1c95f0654813e8bfc5511943c0012bfabbfe4ac588cafd8de6f9534442318fea4d113c0febd26c080a7104fb8a6da346386818b0f6f9b80ae2f641303a4a645ad48f210d97373970822a1d3d1f19cde9d87ead01720416a5a50d832dd7dd829faf7f89c43d814084debebbb7de880dbef52f353a812a66afbca9260f042d69dc57de3d69c0e9aec06236dc7e7b796d07fb546899fc738902d6abe01fef098fa53208b37b82dedff7d4056fc47e64fe595686b751d96657fa665231795a062c23adf50551168dabeaa5af59595a9cad2a7fe4cf0b9c19e9ae6a9c45c866fd5425483d93624b256197de818a011507975e806229a94327653ab5ead26a746b01fe1b3f70db56fa0fe6dcc4ba9f12db7587ae73c7a263e80b6809b6b386fb603423be06e143504325913b80cbfadd27f346199d8e34229b378483af6a9be54f6645580542d82ea22a9aa19e876b50f9a65b0329e02cc470bc12bbc9376aa4621a2095c4eb8f77746e9837f1953c3f45633cdb8ae12e2adb02f2eeb33e0666c8da7847a4074f9d79267918eb77ad8af1fd56727d7116568eae086c28f9df4d071854ba4dd3e9b128ecd352b6a4f6d848015399a6d20daa8e4ee6738ef8d070c6369f4905497b924dfa2c8189c74d855c2d250b14c88fbe385aa9ad0d5e29b5cbdbbbef45f3be7d9bb6bc0e2db16e044534b871c53e78df95c2853fd4ce4290dc62d804d5b0b70ef11c4b7110288f676c04fcf27b6af28fb57f5ddd0c72850aaf96326b70c17de554dcb4515e1091217939b31a5e86ecaf849367fad916039550e179965edf63c8cc0ed7d069fc5ba0994156823be720d74bc843582601aad7f4403f021ce8f2d581c62717b70bb4aa23b1ac8a5d1a8c744dcb4fbf179a29e9301f8733c0d05d5c480bf703e9824e9d601485286f3a45c65122cc2c2a21b6c1c0f1a6c1bf710e63cb9f49c879efb4259bbeb64c872e0ce7e0dae66f08d390c5932fe2eaf742301bfa1a1d26ab53a4efc71d2316d1e812308dcd1d2923f99363fde49d71b228ad6ebdb294f0314a2d294e033fca938d7248d6fcb8a8d3a7f7523a00498a94ef1f11df45717cd46ab62c3c6ac3bef31a358a397dfce690fd69aede84b5790cb79e0f46edbdb471ee6a1f9c1250a86392828f8da5eab3c46995916cb46e91f7a54eb6255815e62ff8eb3f19ce45ebd496613e49d3b3ff6a3bedcf62c1c8ecf57f1630ac109c866b2bfdc3a55373a7b1ad6c10e837f6c8758d002e1179ba747d5906990cb813b0cf980ae0204f7884e726ef23407d6cbcb603d07e5c06377bec3564fed3113a399864f32f7e914e64d022b908952bf16c03a2c37d4500359ceb6780504b2af88dd5134fbef7149e5f71527c904d3aeb9f6e7936b1bdf8446e2a1b4b7adb1300e4e89dcaa82d63bcd64aed59315967d2ae7e9ef2ef09d9e58e12662c3b54144a1e85c0f0c0a99019a27bcd2616392acfc27d62af887d6e8d505c7fc0d3f8e9561340dc3983075d07d3ba3b04d81b4c9fa5bdaca775167e18167d65db6045433c662cd3f9328381cb68605b4a12e5ba123a5b9d0876c0b375af220fa90a61ea21fb8679f9ec15edfc24d0b3b7d9e15d45ec8befbd7682568454bca3692b848e3a393a2c1bb99f8f1e5e07a25d5598f87f3048e93d98d74ac94d07507eecd8141cfb41ef2818f2d56b648139e8fe3adf0e46204e35cf0d8b65ffa70edc4f41aabd0758c8ffed2b5424a0c51eb8a81f282da0a364bbf7c9a63b94216446aaee05cda5788afedcbc3f6fde37a64e7171c37b94ed4c95748aa3c87dc6486364fa68e131c6d4a6455b68241d42bc4d67cc069378ee7631ba9e1e33b904472d440d80be10f1ee44007f0c6ba36cae67a8c1d0f7e495ae031779bac39553351c6a9fa01872a3a50c2d1c8b21cf7fa8bacb9e8ac7f6b3ed3bc6b969e77fabd0ebec60b92d63382a1074a73d4eda2eb598e37fa7a60601b75ead622aee0d6c6aac196b5f7582fc8701cdf5ff0af436e01394b63c57f08d365647f07d55059e2bbe57d68fd1e0857fcf2c2613b7963645c3c036cd58c995745058b8d0e7e63a36bfa77bd998e749bd4b098aef1fbc740070ffedfcf397fc3dd7186a9c40b96d8e092ca1f5e644b73a48356d012ae1de9e96a50a4f8b30cd7b73458a55edabeaa5371bd5bd853408ca6f6b1d0299201fbed853e20eaf761397a1d650bcb95eae5654c95fc5c0ea1b3927b5eb5d855ab193b42cd5a7ae872d69135546749ddd515e7790cacee909d553a5c0ad38ebb32ed0bb408d4d5efa448e88b09cf4175b8f17827dcb21abe41e1e6f7bba50af6137360e733b2f7c4ba55df7fef2301768d0e4d9a20228afa7c77c87909e4dc5c63f5beb34dae54433d2b39945d9b4bf254cb5a14dc05615e2d1b6d7bd3487f87242da36d9ccd50f2642b4b818e858295d62d12971861c9acb20b2e90504a30caa3f40179fdfe906cd311e846d70bc7b870fb880423e259ff750014130f0894357207a1f7dfdf58dae90eb571afcc2abd2b88505a8803e028f4ed675150cf0da7fe1b1e227f264f26b38788fb189b8945fea94c8280c3727888e19eda6a70d89d26a7f760903b2ca78820b89b2c00b345f7b061660fd046ccc6461f90bf58d50a30650da41f259fb8dec64f8199034a8543f995022a45c32379fe07bff0deef7682af4ff66b3cfb4c7b6ffb32bd667940e96c6fa0471a380a5d9b25927b248e57e532107636a95f85314f19258d6aa9001226c689b9cf1a532a0e76580cbe1535a3e14b8c2d6bb559d281711c253eecdece910999454cbed32365c6cdb3737f0adeac6de2f9b668692ebf802746fc6b3f0da2f0ed4121585ffade11418d336ba923a3eb325c03070f08d09fe29395559aa29f01d2359ababe273d4153de394168ae6b14c5c0b35780ade33ac9db875ad1dd23cd3f8332551697416a71807837d926f6960fd146243071234f3be8eb62190260a8b4c1e6f5c75a82887a8c47b50b1e061471cba2b4e3ad51f958af651967e97ee3312bf06eef2aa51b093a16162dc5c424e04e77bf22ca1aba769ef857b3e7b26c79b9ce13aaa295ed7d9ee2256fbb9f8f8dd2824f893408663e9f711be6c521e928433dcf92b072715fca469013641f8f653721d874f7cc410d7f99aa4ef72ec58b1bc13445fa2ee114df4aea4e9225da67e25a6f274c5691fee7e3d55648ffe64981e0865623815d57d76bbe6f5415866202a99991efd8bb3bc074bbf6f64d3eb74b40737fe97b7c0a8ff32b5f71000e1127e124f32da80fc955875dc2b79ea8d0477149f6d4f8a12d37f1ab85721d885570ae71c76ac08f20356c8c52d6c552ef895b4803f31b9ec67af436938a2fb77b187893481648cf4124208d87a5a20f7b0e28509dcb13a02440a392e981235db427e0690f329ce5e6db21809bab51c964e3fa0aec56918e7f47fda87dac21ac2b5598bf6db803f8d6a87ddee9e4a6e47e0894230607976ccdc1dba1e3ce22c19b23b4013315759dcbbf9eea59656e29f5e891f971fecbdc0e9c2799258df18ec920aaa0af56ab26ae106552a419ee77ed33c894854b4641c95e30387c329a2f62dfa0eb2b8dafd9cf9b1a78da0353974b1abbe86e43d6fe1d4b7ab21c98ab0d349f565b3f957d5d2c5b96628a145dab93510981b887a44ffded8fd9bb23619770fd0acd2e312194b5231b75265e7dda215ca6806d91e009fc012ab5a0d0dc9a694905cee8fc14396bac37d49795167f1b37815b359835f3f71693534e487b3b4cf5d033c3bf0c25c76c090b515aa1ce2cc2aff0cc3c96d29a9f3bdfadfd2dadae2b6552b5c8a3f85b2c4442934d616d97a025a7d54bfbe1555ac9d42243d40c97966646be02d4d19cbfdcafa3fbd62a673ef4fabb70fcdb52a224030c83d214ea8ef2cdde0b8a5d3ad33c0f53b68193a75095297c434e6103a5a76098d9476468bfe658cba72919bcd340640c2bfd711d98b5c71352b31dafcf0a16a466b69bd4e606165a8a7c2d25939b58584330efa98b1bcb0762cd8b6a820b3ab1e1552b854f57b7aea82199af509655d35bcb9a6a38f82f87350edd07f61da0d2bdd4e808a60fd1c8c452678e7c38e5c3d826a612bb928c3461128374d069425b9f2fd30ce41608f20f1acb82890969d14ed46a530674e7d92777d642876a7bc8fda1ccaebbed150083469b58f94658111e9ff328d1f4810bfc42e9b54aae2eec1d662fc6e26bfac8b4e06053eb751388d4024ce28bf2004bded68ebb2b677d634ba876bd10ccb17ae8366e2bab4348043d53e23bd664040fe9fbde5a8ba25db7a01b89832d409392b3b581fd1b58bf2650b502d4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
