<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f1beab8b4af87b829347287f2566bcac119811f7127a41ea31b004e60d8f7d9ab944d1941ef42a05451c1a3e896729cf298f0f096c0fe424c8c7f9cc24ca1be5ec65080ea6f8706623cc49cddf9bd866fc8b95ebb0b7ad23b6e0360e0cd59fe5d5735aae37b6cb8b7cb4c525b0f2ceb8453d3d5a98a595bcba3da620ea0549a94a20833e0f1f8838b7ac8e506fb8fd23d1401864b4a84a1b0c0a01d125f7cd821d19ef28ffdbbbcaaeeb081c3d01d54cd6ebacee1a7d236de24fbb8bedd3d901b9a945d95bae2297ebe0f6faebf2c496134f39993e8f3f02a137af6b64864117d421d5a852a2d51ce416ec0f3761f3d49d6325ac6a4543002e68f526292d0cb5e7ee50a518c74d166eb83dc2d2e9b71ce34a27b816ca54ca47cdf7460206e63ce92bcfa8ec5b3aa81beab04e11adf9b302bc70ca00faf06594c45e8f6ab6a3dc5d8271cbc3cda1adbc26c608777f6f7ed19249799b35fbd2e14504b1aa9934bdaf80d28201d200f238192d0b76d13a20d226d53da7aa0ce11cb9dc2120ede49a70e760093c54e827b485e4d2f7639224db99101889247d949d56f67762fbcfbf83e02688fe0a2c8717ce2cf388e4c766c270405def5b0310d87602c049f7cbe6e7e735bc3d770708d5841328eb383b8613bc853d785521236b92f20f042ecb0a96074e7155835c9793672a5355718b07220dc486571ca292371fb16937e10898d685dde34863ab0488daaa7450a50232cdbe92a274b9fd8d4bfcac88eb53a10972fc88fa281e786e4bf73311bf942a270c78a25c45988a4e9ff4e23873a8534ad8e60df80ed1db1cf43657667acfe7b2f1d399bdb99400c4db18fbcdc0de59f03dc906a30c8bbf38cd6cfce1ae3708bc2cc849924df0a084c3a7cd8f13da610c807d6301405a6fed7f5ffa28ac37d947c84f767a287f64869b984e48a70d4274afd6b9d9e95b3b63d3a5bffc588730c2aa07da10799d67f825981f9d835ad6eb538432ee3ad080f30d4df44b09b058d9a7462b089df39489eaa4d37e0fd1c766f6e3aba7e0a794778904109459ec66e71c6c319900a4037d1701da03a78916a882ba2b2c98c9ade274adf8342b9fe169c0824076449c9f0a3a466763ff2a39617d5cf6dded210c196396ab89a2b316228afa613b11b5f67f12e4655272a5d300bdc5e854e5a22cd13313c62d5d65f56f4599a460a8f7d4cd26790643c003e7b58f5d2f81390f75c5e8a39ae11208db947f80d7637f939b4a25cf2979310d30e1d7f779a02c716266cba7001c3cc01dbca6140676fb189f57fcfd5e75c379f65cc8f79859c1e278ebccf21685420640a6720244ce225aab616652e93b11c96b4c0c413e8c0e9be6c89bdb21a441a9fb5326956b6ff2eb778b0b6b27d76963423b2b118c4141802ca08c7ae7428b5be97ad887f9df7d1127b066d53526a40e6a3b6feee86c4d8f2759ee55de84d6d31c7dc6f4bb549bdb613dca2504aa1de8b360a3d65ba3860fbcae7600fc0204ce5743a5e335e2303d628479cde7ab28cb6dacde939d11f5d2c2b4db8d08f7ea2530b48312673884b01c6d3b4b38d963798d97974d76fe66c2dadbbd192343fd5fc3589e222ecdbfe939637603b98a11127fccfb63996d4f43d20ff4e471d79df112c8f8eaa981cb32db26a2ae15bfb7fb0ff69f060864472b7fcf50b1777f67604a29fc8c59fe849defadeb2df435bffbcc24b731aadb253f17099322e5f9540bd238933b11b62617661580b4976efe15c98499f3493b536426a023e9d5887bc404eae50e2f0cf436f1cb1738367234acc0ccdbe461b41180b150cb878f0feb3c614399a7cd9680d4f89ba15664eaaa2d4f049a35e905ae9589632f3d455dfcee45715d13bec5a3d9b38aa06554f8f72ffcc1aa69df01672a771da54038267ff051305d794e4b64d870b4a0e44c3f020fc68aa6c7ccbc85656823ce962c1c1db43b29a4fa446984d0d42f33c05e7a3ea069fd949b13a1b2739d9695df8dd476f12cf3159dd70207f6b857dec3f4cb119058bdb9cdd1836e2b0bcb8ec2b7c359dc11e590586c4f12d86afeff86562931e932df23c3b846ad8be8770ec187384ae8efb34126fdb51d35463119c6c59d760f24dd6b8496f3faf37bbbeda53d6a1dbd4befdf336448084ef15c8cc8ec4d9b736c4e015ce3a0bb98441577900918f195d085b26b7159bd32d3f023b76dd6486a2b78058933a0a8afce49b94e4849e3e930b75220805d83a4602d0385dbce3a5d362de84d05090cd492886f1614bab6b5ce2a70f381c9672c345be7e1f91175d164e279678686dd431ce08af04297562470bc08f5a7f21eda029709e28b1f5d75362acdae4438976841119baaac9c9130c3cf6af0ea53aecf8daa68c5797ed7056a928ca37acb892dd510ed4b578c4c92cdc6fa74a613943fd694975c7f2de44ed48b0fb3c910eecf0125a10fedd06c4ff8c2a5ba33bb9b463d14af10050b61ec92312af8eaa24b0b0640d89e08b2d40c4f78c77460fbbc4b127d71dbf2395805075e4f2ca939f12df1b2fe9c0344565445af1fd7338b01f6fd6424f7101ec16f020445b2ad89008f62808258df1464fb2fca6a0b7e77f3852b276135024bea0cf9f9007773bf60a22bd72adc5b3ff0361010f7dd5de51e2264b6130f7e271ef066317d20da059e031194536b15e8c316a8c4687ae7fa28ebc6dd610b3aaee9934aea4e546e7ae8b5838dbf6700425893649276db9d87c22f36861491eaaad637e3411de2e3e63e57b0b79fb171dd83ab83da2ecb85f7b90565e38b00111b70aab233c2cf27f6973e3ee6a448ed16e7aecb31d9bf3af7f461520225e40845f57c4a8d02dfa8249d6a3881fd09e6b37b8bc9b6a610ba4e7ac5aadf661957b8780a814b5747fec53e3324a554aff11fe91222d0b60f9e70a79364812b0e97cbe804e3ce958b6c3cd884a164309447556fcd35e1dc354bd6809f71c798a223588c30629110de012eec567c8ca1c78023082837bd1aecba0676b82f6c919e037a441400d5e66d29249bb3ac6a7fd6a1e367dad9aaaf5bf49e287ed5e31212d4588e7dfff401c7448558a2543e73d2719e4dd9bf1c226e253690eb53b07cc729cd6d26683234a1ec6fe48fd48f5c37e7dbc6d99639912a81d486fe81f15132abdcbf125d7be9820c943eba12315475f73aa31faa4a631fdf4d4cdfa4f71dbe8396e468b47591c2d7a69673a812881e90155996ffbfd14a10a8acb1c5aa8aa2de0f38c79e2806be2cd4197cb876562bef996d3a9239c430ef56a6cbe6b67a1c7970032ed12c070a825202aed4d0254418824fbbf0054f4011cc933c71a972ebe515cf03781f86faf096929ba0b58128c5d506e9ba2b1b9888ed44867e957325d365ae3335acaf3675511911b34d8e1b42e247d4ce7ff9b7f107aae7f0a3c1b7dbf2c95cee4578b54995ba6fe3a550476dc39873967555c78b86d2bc53fc27b656ee1132f92bba9b2da1898b30e665984609cd979ba502f499816a3a8afbe26af416f1a9d3580b8a7db807204b73275070dc30109019a3b70b7e45ae68b7e8068b5f4bd41e7965e327a64bb2290f86db1a8e8721b1576e860abc0d658e9f3f41880aa74cef79bc7fe72b627091bdc3c40dcc67820c63dcd917088545bddd7d02a7a99a74925703e88b5e9ccc1760b46ebe721323ac84b903aa023785f448a848c7c584bec96ec7bbbbfe5a1644d7df57773082957a289d6f8c94656d816be3a9e273eabe2e5fb1b7e81263a213a03243cf3ae8d90e0fc8bc0aa828e51bac653706305f7b839c2b9cba97c1dd28beafe49d5b0a1c6635edadf3598c194446ec0ba0ed7100bd623f9e2833a1aa0757112e7dc50cf04f618526fbc214b544c155c1cb23abd9d442f7f9b98941910d32893d11bb6ab73bcd8720089d2f29103e2cf44e65e4e04e3df9e090d696a045c6869b8be0ef77253fb73cf27f93cc38bf215e950c48fcac4f1ed30666290a23e1d85ce6dd1a806973addc3f66c04c57ba225fe5f7588c3a7eaa0c6fee34c563573dfa7913947dedbde000c1c4b1742de99965f54bf7f3a59d60e4acaa82c7f7c176d4101a31be7ed0a422d6b6ac8d75dba974bf44cf26daece348e1aaaab374c73c80cb140924351df502e591f3274983034377771ef9d5120bd4fa4e0cfa6925c2b88ed5fc0049544732da5671cf64b8a6f4688004ffba94ca07be08ff480fbec6c2e137eea1a554f5ebe9c8b8a142d6d3f4414410d68b87160f051ef227c3f0312608226ad63ac6038e8b3ac1bd8c2efe630f4fa6dff1330e7263301002fc859d79c7e4ac3cce47b5057c3c7243bd08ff1fb50acd058c8d65df757f4ac94e812343a825b0bf83cf01df2b4779d482c7a40e6ad6b86c4f8133d9d215820d857001ae7f73638b817e68e6f9d7e4d924c11cbdb693bd15866b104e32138b5697dcefb90090ae6efe58cf7a62209d4b0a027a7ddc20b82bc4afcedc24d52c525ec2c4798d32b1ab6c053a90b23b9d751a02e2c3aaa46c4938d4fb38392037ec4f95431d1f7045ad6769f6c039197d28a0ded6aad05903908d3bbed4714298e019473b6f48ad142d4c3821d3ce53cff63432618b21f65a925280f4779efacfc912778a2d2019256ec3cc59db6d311acf902ad45516a1736dc5f06546fc95ff7a2d4b70b6dafc2a55c1b4a994591306e23670a1e650a9fdab88dd67a49b233094d9272fd59f0231588b289276403a87b109b1a8d2ca58616f7a5d38939facdc669d69beee2e40c9b75aaae98b32f0c253ebeb397035d008a850cd25da6d1a98df55a01b431434ce8c14c9465402bd6b10218616fb1e85db298f2a08d397ee6119723b9ba0d0d2f4d3923520d827d62cf84c4e1f8979a4b698d5880babd1fa98413b76d787eab8b7bdee75ebf521b2aa32a6551faa9350c27ec6aa6380c635aded7a746ae48c34384323f9b28171f68bd31fb63f73cf78d1094ea3323f3d31fa0c88ce224b5594e116ed7729abf2e91f38d072ba88d5a048d766c7b476dfdfac697472ad60738d6742bda4bded27c5e440c517297dc666da3f2376a2aedf26f8f0e46ed9521e2b68d1db95b3187d24684a35a4a457c6b0815e6f3202e5b29b9d21a2aa75d978596fa93d1a50f5b45d95a40f59c47efac30294826166f00a12ee821ea8595a90b23238addad85ee71817150803adab10c6d09dba6f66a96536d0a62cbbdf52b1b025449b2a20d60c0a8506fce8c8019b9a14cd3967e826d1166199465796dc088fba716b3319ea419c9da860c03626e9f46930293e4c9be591d7ef85fd97d6b7c895da9c5d5a65a3d175346f0afbdb0082b5bd253e03f28b8a006568e40448efe8e7e6e1982968d416a30d5907b848a254e178b2e355a08ff16c4e71e8646a7a752cc4b1d71c4ff25b5ba4454d54bf865794a65788c65de5643a23b058f967f4086046ad26f9ba17a7275e6cff652c8abbe003225a2bbb9bd54b8fbda3c88cb503501039975d1c1a5a0fc932648f5cee3f9974c9dbc5ba593a2f3aada2782525fcea0a200606eca55677764ee31aeae2d50860bf2d0dfe462c4158f7315dabfcd0362a1753dc2734cdefde4dde8f5d4586439356d6e61fa5b0e4246d7fdec7fbcb567902d3785165306437949b27d9513c2b0c9e18a3a709b7273d131287dcfa08e6301082a1b37eb566486ec0896bd247e2b2dad996d3300dccdb07c58b2f2369a2e6aa4b32dc2caa8b4444584773a7474f26327369a8b15c07129a094e8cd5fd4d045764f9e5bc9b67a8b6d6c80dceac868228f575c47f04aaf5f2a57fa4eba4ecc77d4e204b4b22e344893e9e42923b4a45ad1f64188febf5c7165cea44bd3f8f947cde20ce758a6a386988b888c961300836fe5830e8ba851b8ed836474cf572808e041d32d7ab171782a6f541859672611d9932f30c5d1ede0f2824065f2c3cd0f4c101f6d1260e28c548a9749a4f514fc3399580aaf61918a77d37f5df0467ddc560d142a3ba4669b7d795acf13d2d8b87a2c2bd92a239e101fdb3068d2dd28be0db29bd7abf82bcfd60773e831f2fd1551a1a5babd676b5c6fc1fe477100d1c82a02d9c129f36ac10cdc8928bb7f872c18b220da0c1c1de668a0b255b35390972a5e0fbe92a9735b9253ae712ea6db4722c0682c8945df37698ec6aaeb6a8a31fc6ff0be395443b7f3714425248a90cdfbd82cc5ef881a4762c899749ffe7ceccee5294b4797a97a8f7ba105f1589c2f592b3a82565f7b8cc6b6958e05c565753719b2ae5a80416970a3b496900441be59065f893579e480831049b9b1a631bbac443520a1bdc8df6144713eafa8de7e3fc937d6597456ef47239b0a00ef65b7178c6e5dec15771c870a10a3750cf8aec8747cf5f13ac123d2886638aa5ada143984b71193d42ac0c087fceb41c4e813a94d5f62ab9b03495139e0f5dcd132f9eb96a84a2cb162e64a42b1e12d9096b7e3d825bdcf0c930326e7602bd0c104786c5abced4639da5c1f9a30fafa3d9af4ea88fd1fdedb7b032308c4326115588f9d44d3f817fd1c4bcf1a00536b41e670d5a640d21a6740cc356046108db26d508933881bf261bc0a12ff35cd03e4bb5039b7ef7149cebd907e8a07b0fd8a907b55624ba1b93bced96153d09162d8ceaeadb215a90d9b6d0c9bc9bdfa315c6f1529a1bd6dc519797b4c28eb57ff4ee3baba73bbbce129b40f96304e521c3805fa9b7cef0aed6da1daf2e813a191bfb5734019aa268d6d589ab2e14e9b7312c97ed427f78595b012722c485ebfa2c9a50b25bb07bd3a66785a5435d3ef246f4662dedb5ff4ff185dd3ec0e147d94aa922582494ce469d32aa4b1505d8286fcef8bcf7c63046a9998bf2f54985dce6cc632ffd89219461a3647f081a0cf48e52eb1baf82dc9243869b7312396c305723e6a1cd2c0daaba3e315084f434c30891b94d0798342443361fcd10d905b8591ad487c1710577e438eb302694b1d957f64c6d82b854bfb6c5746e6bc9c375790b976f7a12139496ea108ca513cf744f640cc798d0f2274ed7837caee28eb8a57057bfd81f5b8b4ff90748766544a6715f6196d1a9d3e1f79c8e2c5fe3c16952554d9045247edcb52cb4d5611b47e9e6885328a14d29f55cb2f3f98fe5126ac4aeaf579931430d9694587bcd8ee95629fb7be9a1b6faed2ebe1cba089e574cfd9b31456677c01a6ba8622166f231aafda6eb23727a17f6e59f3ca70c52780a4472ea44552592cfef34c6fbd861f0de7f9886426e476919d0d0ff2190cfe00c9b48c9a8cf3806ac847cc953fbebff382ec8c45905ac5414f7c9fe6e4b57cc16b300a71db8e67f77e976bc472361e5acbf73fab5de6150309c4df6adf94f1539f4884156ad272315acbf412a6f80ce6301ef4142c82f1486ee2c6c141bead18d27254db116fd4084648cd3354721d55e39a928294e3102918abf5a107bef55fa287c7c4d830166e33846ff15ce98a8f6cae6ee5e360d293d7047ab51f82007b86fe82b2f5cbaf5709947211eca9442ee21a826464b4a93cf4cfc6817b5ebdb196bc15c101cbdf69c95cc2aaa950593cfc0d500603021117ac390bd630c51a708532221cbf260ecd55774620c59734691a43d757f60e1cb3ae9cf4061afdf809a37ac7d768daed2e5202ef01d4aa4b469337c893f50a69fd47bfa5ebb434f71bc5cb424d094e7b68f91685dda9e947d20a8de3cb0d0519b0f485434d9715784291ffef119e2206effb59e243db379dfd75778107988b6f96eb7c76147c02a2fed85b6c0579ede835102834ac38230b2174d09a1e8437ef05cfee61fe7eedb985d2e50079f797e6960b404da3583c92123d8b72842fca9018982fd3180c9a320ebc12c63bbe0c413566a288ff885cf5c65869af64ed37ef582cbc96e4a9080504cf5c643b5fc3c08e60431a35b829021aea16ccb9c6df6ba10cfaadcabec79b32395b0fb8aa15881b91a82ac94bb02bae55a67444d2d2416c4686cb42aeeacd0493ee75f79cf562e295722ffa9e141d8a63dcc2764e0e08233c34e919a9c30f1bbf5e8e9eb41a2a95304c04bb743a2eb8319915a958590acbba9eae84b2c7ccb3c2165192167261fbeb4b35ccf5e72343810312e0104d22e339077cd5c550ecabbd72f9cbf27332e17aa80d185d9d5da085d5a76f7773d97952809ffe633c4bcce70ec53a2c3738ef034ed9634832b9db44157150dc9e5cc08b8a8596315f13422469de97e641318d14e6f59fff67eef1d29e595bf9602a63fff7fed87264c3608eb0c9678cc78350e93fec21edd6d4485e8deb11a08e47ebaed383ce552c01eae282a74bbb84e986333df8ebf893069693e1de801a784125ec70e7e0ea936398e84b7605cdfd3b1b668e98e97e58df14a9d9d24bd9a96f2d696fbedc8b22ef8add4ccc0662b54658442473d883cafeb55428a0be87b37e32c8ebeaec58c718f9da600b027818700668f780fb78572be4afccde0e823bc9b4013a7d2d7024a9567adfca4fb9b4578bdc02381ede6675edec1f2dc78b7506bd539665c0fdf65e5de68376fade4efeba29ddfe248e1e5a1ea2206840d2d3e4cc89a65fe7e4e6476055787d148bb045a1b7ab133b3bcaa56ce6df9054aca45ec595252c587bac91cea8896e6b2f66ed8bd36f5083e7030050a6f437e6b3c655b9618c37beb3e93160ca99376536b5e2f90ea16fcca1d01b48453de4bbe549d69958648011e11183c3eeae53fda539b75a990d705ee4332eaeee5cdba81e306bcd98539268e54068e692ccf28ca6e631104e4229b40efc48cf3b68149efab1d91d6b4f37d324d2feb57c1d55a9efb666f2007affc37644065213b778ca015b15ad0e629b0e6e4b4861ea38371f76678daacf45cdfabbc0485311d8d07e405572cf4f4583171d95e0bf6361b41c618d13eaa80fbdc24bf92ed9aa0ed7df4d75631e9f88b7f89dfd662dbb528b1ea684f9ecb7c49b6a734e6c567d5e65499be28340d4b9e90e44528947c0c964a35923888a0d0795a60a9af3799666f07186589c58afc2f390a32c4a9389595a5a1d135cee265213ed4e89b4d97e12d7b4653ed821bf3bb234ab421f1f2a3606ea7d2ec7252dbf8b29d8126f6276975dbd3da591096e572f4ebe7d8e28a756cc48d94588fe4cfc88bec5d3969ba41098462dfcff7cd550ffd7080e08bc95af934950ceeca6885925bb8c4e139333979116759c93ce6dcc8f8b97ebc266074a163497d48442e1a5c3cb47e62c68b018190b86fd33e9e9e716b6863b9f8958ae569c2fdf386759a6394645c5e3a7bae1eb2ff29d2d76c46e99d29cca6a180472287152027249f0d5d4e4765ab0d4981eff90e650f501dbe5ae1012588c88775a24cbbf4e65d306cc3426262b76ecb7b5ab928d600a4860b0dd0e011be9c15e62106f7e6fda759832ced07ed83885fbe1b9e0bb6a6e5dfe9a1150611a6ba7043c0512fe910bb7860f3b5972459c4ff2e391df5bca6f6f84a8a79d76670b207ad4e8ea706d6ba93afdf1ec7f9804a62f12e36d83439f58c3aeb6fa5e67952bb3ac6b369ec6ea4d3c940c00883060210cc3a4f54640c499b2654560b8e48b27baf8aad70665a6effa0f1f1ce581022c2c791bdeeb6d29fbd3cb6afb573e7c548e3c39c380984070f96341c259730619996be77c57553ebb9f0e2535e6486b1633181119f885868af025309f5c28cd074b09b83a27b62e599290343f5da1436ccb81fd1b359d9e6dbf30d03c82183a232184c317194c3649abf93f933a54a09b50ad2fe82ded7178634844fc1ee8674a33c8368ef7e3f84375247dc0cb6403a333c893cbdcdc11ddeeebcb874eec112767dcc92ba1085338e586879391b7b2ddee1102c55b7491d80b184b5b1dd9813ce829ecb5e4287d1a157fb43521fd0454391f380bda5af477cbffa2280449de7f77a3ee7aec3a5b521e51b5cdeb39f40a297ef4fc0bf2609171e2e31ab584a4682d606d2fc7bccbc34e436a9236c1691bf69b422635625169f5a89c764bb760e72a658ded2d630a3f4ac80508e8a39065adfe23c3cdd35594698c65d6ba826e98d231aa151440185a5663b5148c22060f2e3c85c38b252e08ccd98d628da42ff29454757673fc1a7d1396ff83a178bcd43db12a8ed69719ef5bd48295a6fbabc3e052f1e3849cc27aa6ac6d2b027be8b55898501127e8f7806235d7b8529932a6bbfb1b299c5d481d1b3200e70482d0b11d57a0de2dbeee570bd8d3e6717287fed2f05810289c9716733ce89538f7ae2f06ac2c47cf29d528dbb0bbf2a899a016c5c0e6e3f9160e262fb79cab09d3c25a39634eedd15456f4cf1e9dc2a05b950e4fec49365fdc7db1207cbf8a943dd5a2605fb83e8de9ce2790b010671accf5639a4c9bd21d9830e3aa081ebf8f9fa1c723c0826a7f84133af8c17ac351348a08ecd8523e4835c08e773e300aec32ee5f0b54ba97f4bd8b5e10ff9de9367a93c195b72290566117d53ca4c766727b65200e2812148b4bb05811c2540a6a480431318570951db08c9e68e7c367b629e9a91bf533257276aa46775e24627543f2609aff8cac8abb3a72d077db30b4668c3d9d3d83a4ea0e9bc96fdd6fa23b82a4f437c21a5c462559a1c3d7c5dae2472e75b9c0121c626020f43da1af4fc6b7875549e787160f51f77866c4e353193704c0c0c0e8195c33ec523360611c4c79ab6f87a902d607bc40150a88a963354dd94981744c5e7863b1b132bc527ac601488185b65aaee0015c8365974632ddf71334e930cb1abb57e58a073baca84e301b0e8c893935860cca3b9200d9e64a09de6799c1c46a66ccec32b31909301f8fd94154b0785cbc4e08f274d1b84b099802ccc1d04f24eab97a2e59f6b9891b0b67f8799941b06bcbbc530ff061212c7db145230b921ef9d157fbba4ba818a809b25e9cb15caa04e0445ae11c11ac18acfae46823e4a13f29439fb45205dbb8762b78e291ac9ebfa6b4fd29e3c53c663a8db35b7c55a08918f64e782837e1f6dca0701ce985f0d083d25636ba1d33a3096df7f52293520d56cf0ace6fd4a713a47081bf637f9496c775b39f08b2c8b507c5215d218d9eb9f8cf4eaf6e32dcd8bba30233236f08b2a2281733e5af1951efec98c7eb1c55e7b7dfe3df2209f89c2af54688abce84cdac59632db8f4cf73bd1c01bcaf66757a3634384c9102c261ee395cf999e3b23560cb88fb56d24d9d7caac3849a14b360d6d20050906b8acdedf86d13a742e748868519cea85e698dfa54a008e58ce392f858edf3be40c81a610c3bbc873bfdd9bf0f4cd949531b90468ffee09caa00af41a0c24d7c8b0d82e54f535d0e79fec9cf2452da16ecccc09205146dae46b66f96492e330b4c9afb14970e0d9ed54dae8a1eac340db413a9db9845fe397b7d2a9e2b9dc26cea25be8baf8f6bddf51f23363e0cee2e2107500c6b4e7ccc181ffd903015cdf06229a3f94f92393a7142fdf48e4bc3653f901e527bb6a480cc11169e5883854d2a3c7cc9e58e6af5d116b93c3c094db183118d4cfb38f934e63cf80f0dd902d2833bb087feb1dd59bd4b9ac91b95cfce474d6601082abd5134baa02ea30193be64d993ed1a63a06a3e74f9c91c0c935e6fda331c9fd963f08afe7c48a849384897f8a99bdcbdfcb3c1980a61bc3bd13beeeb04e1f05bf67fd7f65709f6ce49680440dc8a92922d05743519a0efa516a818a31e8c5ab5169234855e05fbfc7f0a7e07baf70a9e79dc0d9c9b814026d6070484b8376edbf7f18b2abca4645657605f1c75902ec4df88d33aa50d5dc380f25b3cc1d6a11ad07a18563b5a81320c76decd346455542cf847a708601fc758c83fce4966e40a2f488c5a4846ce8e7e002eaaf511a615c425dee99151c5b5c5e83261bccca5de436692f56a3a3ac660d56e7ab25ba7b18a80acbe09382782bb23350599f8bb381a523eadfef8145fe14358c955de6df842980711b2938d2732bbdc717f28b81d34a0b99ca3ecd72329367739e8ef4df2a5fa79c2539ec053aa01c78196b8d0f94304761f88937f56fe168bc7bef149bba4b48c40852dc0edb27e90d1129ca7bc42fa10371aba724289a438d247738b1acc7e72500b7b334fead48a05b768c6509e3649b836bf03cd7c1af95b59f1bf41de07e92dcf80876f13ddba7fcd17e2e7de5c9a9f3f8fdfbf2cbc1fe47d61a92269e40900d66228d38281e5da477c6e6252deda08dfae548c38a4820f6a102c0f133e126da1a89ca999d537d167de92406b3be38ab5b311f85ae80b75336bffc36cee626e29d9e2ff39256fa13f0ccf8ef91acd81f66b7eaa9f984bf4f1b2597bbdeab2b2e02261761b218ad6fdf2c6ed8d955f5faed34b15955aeae48a9545b17d5d98d7b2c4d49286a738f1e9a2bb09401ceeeec4adb2acafdfafebd3ec58b2f80d1618004dc9af1185b4465f2c1e7be7573a4323945f9e856d31ed1392ab54abbce33026f75d70e963d2e8858d445cdac15dd2a0f33159b07c97f890a3e9941c04311ae456627332540443dc8ba0e7285946f5d8d38d36feb776d3c64d42d96c36a892dc2f64388e0bc6184b353bf487990d7c46461c401d215c1457e770479307ed01dac2c434ad3c2753ad1659fa4674346741a325d4fbd91e328d52c1f4ed8e79f86c899cc07813bcc08d7c461b663b4912ec96ecd772b7c4f9241e17d33426955b1e5cbaa8d183327d73af9e7b725fc9d5cb22b5fbef8bcea03b22df774750a68dcfa472a8f885a334e0d705d7bac9ede803219bbbbcd699bfa81b900ae2ec852b7749412982d4c4c93e1b52f77446f5cc50167db38e7e3843d16d06f6b7b66588293eb7903496190cd462e6b891bc5f458636c2d54271c7c4c91cd32cd887f5316d1bfcb99fc75359543ab1fd387ae433e854e6515848fe923e095af564122299fe6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
