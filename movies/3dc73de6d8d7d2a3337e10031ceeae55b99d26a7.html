<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e47ac2e6ef70693d9d753551652f2c9ee5816d819ef3b4e9b16a3042da3504be83476c3188e9130a0d849351b57adf4d6b6bf1fa08d3e223bf6594a11b1c029d7215548a52bf60086ce01f3a769b03226f16b1ba60846b8a375cd01b2174cd8c2c14b3146ccdf97c9c48a5082880f399a6813827cab29c595d89969838b8e77d820dee99c3b4ed8929d6b607a9159461b8e3dfbb8f3f95b835ea5f3d8fab988d93564c6de1493bf27602de219a8995c98810d03c4a6e8e7c3e5f3e692aa61cb70e707af8eab376dadcc297abc739a2f93151d622c6b9e5c8e891082f24b991fd3d86961a06d29364f4817426b785ae47ebd16551f69668f2fbabfc9a0a39c22e52bb824a5286188b76d1e124bc216fe3180a081b6e9fc1982e7ab103f0c64d0b83146e78d78ad3e9e6df20771718c1e715218e4ea2cf2f2609d4ede5f86c7ab48199629e5ef7cea0eeead102cdf5b9794566339c0275b6aaffbee84e919ba2ceb10eb77e5a8b55952762219ca24bc91804d733ec685f03754146541ae4b0a232855ecaa95d8ac401d30728e5ac81e79b632be2f5e29f834494ad783a9c7b73f5dc41b6d7b4760f7ed8a56a9e6cec787a67090b68eea452aef54b3b0ffdc541ece3b8582f89522cc8acc2065b987a1f8c5a9b6e4d206b42504bc1c04680e342c231b99e0d61778a63e9e93834d7f36c9354d61953f58bc73b4972c26bbb3a58c12d5164a3914cbfb58779e0480b503c1e840cc3dd474042947baa59f9c27b5f712f88a3e94c9e9faa51494e0cb5792d540b2135be38a647651b4d3d0127f97f25966a917d4a0acaf247fa3b493f3dccd57e8a1cb60bcd5aee6e2523af96b6519a5cb7ace9308352cb9c5b5dc1c82a82e75573f38677bad98602da5eacbee47bd434e1d78c6d1ea850a33c1205e5fa66a0db64d52101d7b86c96b4f27dc05883b9bfd5dedbcbd8eec5e80b81316382c8e29d5ab044929bf94564934d9bdf021ea29cd031114149175c6e98e37b3536d55a3e318a3624d717616bb3333c9a07b84fd9daaeeb75788e399b99b9aa3fdc159ebb592e6eb26349e553571b4ede055ab1bcac08458f21e46bd4136e80b973337581fc2a7fd3c16fd4f9933619b31964382726ab4e56ed5bfe9dafdbf1d675c34e86a663e624420f7876f0235223be5d809ba9c661f625b255d024ec439792878d42ccace254e40d026f5775ea405a8344c0201007798fedca2eedebada4c6a015d59e9e077203057d8ecf33fac793c554275aefc192e0934f1a184718f789426d5dfb5bce30e25fd41c4629bf0625f0ea9f30d3e394b11e577758c9667f2109cc5e01dd2ece6a2c6dc1e4f496342cb23f02444141cef8cd094ffdfaef9608638a1869ec5b91a2786e0d141bc3403697b3da91aa2229aba32608a2cded814de74ffcea3431b6b811980487e4e3cb23f398f96c8c75813eb839234859fe818bfaa831344e52427efa1b8864d3f239db6df6a2f119a7af427fab1b8cf8c3b710940a79a79a275db3f18c70ad6e89340c4116a1150c047180cd9f1364aacefdab52b6aef235e6aadf3ee8e2498fc36dc65fa68a77bc304f3b2573ec80ed8d70433e6d77cd27cccc467d7b7ad81b1b0422d322f9cc8363d71eafd5281b90ffb99f11d8e4b1fc1d97580e72f65fb3faa60b1cd66bc42087df2431a66caba747ec24357c0e97b45c018e0291bf6e6902d9e1c9f3bc68a33842d9f39bae64647fb0ce32e2306f2cd39f9a5c05db8b381ec7aedc3394d5fccb71f656d97a6e0e9428f6cd3b331e09bee33e9cb1266d92d6422ff5164fac81c6120d91100b90f75abfed54d1ed36c51396b28639628ec8db9a6c1389cdc18a712a25c96ebcca11e09b07a1aed0001e567a9f1ca8d5c8186db41640910ccc4b51e4f5887a9ac22bc650e4dac723f00e6f0aa48409aab4be01f031feb213dc750c5ddf5ed9ffae56f75ca2af611ed278cff74dd6c889415051cf1ab1fd948e5cad9c9deb87ffe5d50869717360ce1772a9239639935121d623452bacd2aa9d19c88e9d4daf146389ce1835594d6232c929c9b4f5b8a6e361c12176e6dbe6d7e1e98e15123923cea68867e96d6e9940a9d66b161ce47d4fc5c44f223097ebbf89b23b7d560085838d3cb0be4ee1ef35349d93b9cfbfca8db8d49cbf4a9617e0a6351e568270fe81663e4e95e3e922122486fcd1e4279b2a845838ab432b78624f9ffb7b08680e70bad69802a8209bb7a724065fde20e71c37d3de404cbe32be9c896f5108285feb61cedb27b8162345cd0f89a092df4c19bbf7789f1704a94bc8c12a8b7b19a036446e2e224f3d7de38bf43536368c09e5f470e2f6fd2b14cebadf6974029d0cfb9d390c27b0cf544b88e613f75fa9551e8b9a4475ff8b03473c42ff7e2a12cd296025b75d7c83890ccb9089bdde43b3e2b089b472da3b5ec6d8d807a177f1467d52fd965651750262eaff8ea52d4af631a2657677120466d273f9488e78a8a7c3154b5421a11b292e4f82740800b61c6c39bcde937232df05b66f1457e4b54bfcbf212993f1b3aaf9fed6f1834449fc5f7d14e8fad076a3d9914e4a04e519f139200e20ec7f5ee28e85f9d3e91a992dadde2fccf2a54531bdb08f85ae54cf5c3ab0fbd7814be563e5c63465f982924cc990700a6a0c35b26b73728abae02ffd74ed4f3ca0a2c66576a4cc3515d35ee015ba98f6e858feaa13d425ba0c8b36bbbc93bd19c429c6f4193ed85aa1e0cccb2c7e8a61001b087ab7e188ee3c24f7eafbb9e4c55f44ecf3878ba89b6fbc22b4a3ea5ffb06579737bdbb49b304764f523d709a60eef507fc5ccd35af58e1fa263d67a8c5602c0df243839ba8d33ae731489fdace9bbc599b152798d9d6f193315e50f2f2c60e702de5f3664050d9efc3552d365b6b8b52d3f228640b42054c984912ce6a8257fd937fdc40468c78a4344d7fb7d263ea2ff047f76d96f06b84c6c4f43b9f25e1356892f4f45d2c5733670097804acd36d1071e30813b12a1c337e36e6f04adbaaf3f41c5e5bd42a98748a6947b93d8720470757f8fb25e54716f9f54dc5b34d843a1551f0d4579c379cb6c3ee6b122b3390c7d6537009593fae71cf4b3c142c652a8fe40d376f8f2b4819de34c3df609d3eb752b183715cf996f0f1c820d095f578d483d77030d3225063e543906ca7ff928e01a1a30865e6e899e6409864a88c036aad3ce8e97467d79b5e8566714650c2bf47680028fa97df10c6959247d63d3eeacdf838bcbfa1b70a0837e339253cbb301b2562948adc24f21f3cce8e3028b536c4bdbf4ec68efe86fb71bf7434f9f00a12bd8a23038e050d8cb4ff88801914f7a094bdec7e22afbe5ab5bbd3b76ded0782732a823ae351580c8d6abaf049b94527a718b1291071ba9b8e1ed4b5153765d69e6f6e1a0dd500e21fb145753a115c033e5e1b2a5cc8134cf97091995d669c3f370d6e37b7b6f23b357e133fb52ae64deb883c684d70c761eac11d60b15e4c81af8bcac26dd6442b229f3ed53301580864bf10532536eca63078847c2d83cb7715469fb006ef12a13dc9d232221c6d68b5569e0d84ddc9f45d4e51e135a0a80e2e271daa0a5a4410355e11f6a898c626f83d70de6eef0b9310b12fa22fe5f55f2120fc9e3d9a5ffdad20b9849d588c88711dd8d46e58321987f11c3fd459da2202d0961fbc57412f75336bb0d308bf09d186332bae03d2fe5570762b5998e95da01beacc4e99d892e4a2804aa2b438a1e0b9fee7773d0136bbaff0cce96f73218cd45b537ca37bd5f2a1f75df55d40695da5f94185f995565c8bae09262824fc043b02ba930d0c2c3c562ef6e0151f29cf3c5fc2625c21fdddac8c5e05c1328d54f8ba61395f77e407404696c11d1813fe095fc9cafdd4ec4ee9d287dd22541edea3de735042acab6f713c625d29a9f83ef4d32d370c868780c81bcf70b44f3c6db5c119c8b3909b19ba14c0f70ae49a88626761557559b1c8eecd16040086814ce4ec04226c971999b5e48aea9fe6a24191743458bb770e0ab3d615dc02f656fae9ec513c0842bff86cd8517dfe330f20d4aace4d1c941d94af88c55d8a03d6f0ad4b7b174a91284bee5e4185e7c2527f954290d888e75ae4ede148e26051617710d22a79e750abb3b0dfd605283874054eb79e8042da309753d51b0242215a8374fcbe9d1589d833759a8f311ee239740fb115a86d808a7704e8e827ae3f1aa03001beb1156d2626fa37609e94ec1532c8401bfe1c0e6ed8229044e512ee1cb41003ed1b89ccaf2bb8e6095b09dda7d1e17c27bb707e8e3cc8cb3420942fd68b15c5786918c6981f77592aa26e9a39d49bb0c6f70baa1b6566b8deea41475f23a3e3bb9f7efd2cc99b4b8f881032a177a183519b321127bd994aeeb3bba15e720f93277d44b725bbfa37b513bfe0a418d6e86cc066fc5fdf2e180604af2275f02faec914f9b81b531fda85e63fcc51c3c678635e697aa76801fd80eff37400ffa4e708f1c0757fd6fc680e72de3703c192417d8dc359da1da29884062a3920045cbc97c39e03b7a367a5c67b42c356a6f2990087229c99e338070bed1092ed4ce6860479023adebc69928dc3be129e0a2e39c893b8aa9a3f698f8df93a7f86fccdf5d7eda25a471e12822c7bffce61518053964e127158dfc0927bc258d6224cde40ad18411fed9ee3ba3a51e286b72cf3935dded5a37f2607f57779660934d58ee6744575a269ef7a013311d250102089cad574daa79f230d0137b7911376e4ce5c1e779007427926a014522ca1f6fd7ed7be115f701cd97f489a3624b8235b5dc5da4e5ee4c5837a4980c1a8d17ad7efe4ce2937b9f1179d404eea080683d687365a4ef33148fc2a05d9fd7989bae6bca00388b6de9244f09aa124e092e3e79adcda1e73f41078d782b3263aad7d72fd60cf86a1594837ed9f29704ce067fbd434c26f3e0e6653265fe56fd0b66b49a832b106dd2fd8b3757dd0027dadbbd3b93071fcb089f173e93f1dcc85eeb234421d9d336a8cfe34dfeafb36a2b65a89d7a0dd575df5aa840de86864c8422575aa6606f4777dc8c693382b40f738f1f5288c104d3ae1321bf1831a848a5166c1fed30e68cbfb952ba33989fc9db2a034f1a6050b7d2b3e47abf45de622dda26b857113a1792d80757526f476763c1d6994148bc40727db4d91d9bc5a843e2bbcea47c3b0468f72a8a4e4983007670b0e50d8a449d1ef76f2d70fac3cf888892692669eef4e08edcd08f7c281e89bf7ac90afa6c82d345012384eb361c0442899d2e7cb2f68a99b75fb6999091d7ba08d35ecf766c646291061bbd90f9ea211ecaafa7d75940ff169518fb25f4ce0d52c5578871c08cc431a20c1f14680f0edd6ab46d56c08de23790877df70bb111248d4ae653c3c6f55c6eb0ad6fb08c4b4f66fdc98b9eb176b9173de55a8e1ca7bc0a9b92b9f13739d8ac0d1dfff5e678402fce5e0848002adf0788b7e603df59b4b919e936d57791991ff44513d34073bc14a4b08b50a5a8f765c06ddbce87e8b73cc461772663564105a791d85347df3affdaefaf1c92f41c1536ed598dd5bc33ce1ff43619beda85b655a446a3d953e7f97cd4b5af5b0cd7fc20254369c6c76c9d2e84511da079a28a0d0412f59bcf2a1203ac38fd48c0f1c4fea8de555f8e7fb07e55e81a4a9bcf182bf7970e60f6e9190ce56d8a6953420f468b5794cc806c604f9fe568785cf8092194a62df9e150d8b786fc7d6455b4e039223d7873003fe3ae27ce7e94a8ff40b21dde185a9db5f740a25a93ecf3b24f4e41f21498e6db6808119fd4ab2855871a4b70072204cef6dee71fd4ce4fab404d181d78009b5fb34626b4eb9138cd432264d4704e784a9e96f51d2ab9ce0a05fb3aa8e576fb6e95a08c1820b0a9caef41580cc1f424b1a026b6bb5d71c8f202bdf849723968e8178810023ef9c9c211ec291f48c54dc86bc618f62bd56b0d41fddc4bd57d5fbfeee61034e9d69ad212639d972c956e65f26de6064ec46268e630a3722766dc8de4ec0c09d6f9c4659a372617cf99764843afc409b6209b4c8a7287c9ccd48c00fd0f1f4227d802afbcd0902eeb4fa56ffdaefcb6df8d382f6f419446f89606d8788aa6aa7fc98dc37231348e5de5073e9aa6ad1ca2ecb4139832b667642dede717ca7de669e232d827b02ff3131c29cf99a53dc0c10c73e19f6ad6326038b7acfe73f76300f5b2a22a33127ade9b6dbe5bc3b9a2f2b6b3e908133586be1cd8cdc7554c63d6465997e4fc50da79dec62726c1d33869ec1c7ea5c7e08b1a2376699df848ecd0c82381b23eab0400a76e1f32e79919447797e5125703248a31e89cd37361d571ea552704577d63370ab5b21708d774dc8919aec39d1130ff75260ce0fa236c02b7c2584dd5752624e855cc12ef6dbdd6de0dde1a9fd3865fcdc4798395160abaa110fc4663729a859c5551235b82486868abcea2e638bfa0194ae1307846d1069589f39f20755a2ba528b054eadfa1a681f5f47fd963b5aeeddf87e3fc185e3e54296a65d396692b8f575cfd021d06e2e7428f558b0bd33cd1f5ed6f4cf9085d0b01cc6df5566a61a8e8e30c18e042e31e3f1952e9f493ff84f8db1b631ea0f447bd48ac8540ba62f6a2b9cf444c5c3e1fc606897423edef370f6cb19d19723f4d097751e141b7aceb848bfb61718db3f58eb019c971f0bde23b8c2e405558ed48764123710dd7b13690c1fa8a3392c45475b67d75a10dd75790106cb415523a3518e83b87d7f6d61ed26107b3fb3e49438c7e65f0a65bc90afba667f394a03e9ded4c5fb63f53e7b8b05e1862b3cadbd0ded6ce51919f16b53719e01521ac01be0173e7ceb5293cc85f70f27ad81d2124555277a036cfcf7d6146d02fedf339a854dc9b0a1c87b3af15f61fe1adf23a69d80975f617e07a3c339962fe92c9ac33da3089fe63d0c46a83cad22874cbdcf04df3f64dc7b0f6fb6c00eca69c30f254dbf632ade4c4d332d71b6ca97369b203ffd0981dcb73a0232267c52c5f99d03c79c47ee45fd4bcf951ba1d88cadc97764ecaeadc6e446615b46f18068e0cde51009e82343ba4a9b0f49ba8217213ea407780382ced6fde8955a0c18858e9d6f16548824e4225b2bb88d9b16a5e787e47df83c5f9dc0c8310da061792510d851eb09a2adfcadea1aaf8f66407978737c54fb7fef07b6c4ed6090c99d0cef154deb6d7a672a178bf111a685eafce3adba2fe03a03a8362930a8f2dacf3c013c44d822f9d7f438718bf9dec07fbd42b14cec708f7e036be590fbe6972aa42a69fb0f0fc92b85cf315c7c772f371bd0674413246157f69a293a77c65a330be98e24a50ad3e7ddfd353cfd0338ff6a852a4c54adbabd4fdd887915196f61523557558814ed48875bb258e877b3688afa80750a8a5cd4db9b5e368e9abc6b74298af553c9c43375a242849c5b6c5dc45dd78517be681f48b9ff9b345d7a8285a1dc4c6b9a63dba717c26b2b496a535d04247544e9bf245fd2f0cb764cd890307d38026d2d8f1920ebd0859326ce8bd5a6a4b0a1bcb75d313a4259630a78936de36fc7509c329762ce96650dc2af89e174ef2d7cb102c56c4919cf988e99d8515125b4e7f7cecda85df3b8b275923d96f2b4a94f7ec61faa013ba6ad536cd7e47d21ad1a36871a454464683cef61a0fc5cf60bff4f52aa509708d04af0cb21c4fa800e71530e10df8545b9bcb7f12c28dd6bd1f9051da8220d3b4f84e8505dc693dcc35a2d656e72f781ea58a14ef5f8cee58d5a9cbf197f62568c7dc13f9345ca70ef23232c271b0fd8cc24d9a13cf76efad2887d6a9794fcfa93cd8f9d015e7d456a19656a8c13106ca417f0f11debe12c454dba48bf3ec16b8143b64ed4f457dfc6fcc95d80f3738d7a1d506ee68299d5eae77386251e8536acc625ca4039fe8168925a686ef0e8994bd51c8ff4b6855237508d339f7ddb866e97d257b1ea0a94ddfd695014519b4126df20299270ffbfa201d1e25cdb291b1b4e750126c5b76aba74902a5b0d554a1aca74df518c4f97162f4fe8c306ebdf2468e3e6920a38cbdac8db221dff04cacc82a01eb348ad6a2b070c67013b4a9b16bae76e306c5a1b3a0c23156f3e2f19287771b73598ad8e49415533e3545f4b7e64f2e4770c377ba6dab5a6d02687cdce8f282e6860f8da21652b1f6178da7feb03e919a8fc63f1583078c8175d10faf434da31939a44810f1d0858e1126b3087ec5eb658e989aacc532f4a20e694e9caefdd78dfa86eed9ef55241524dae0c65dd4827dec46da0fbaf8aa3bceada8519beb6105514428c762b9c3a9578f0c54517945eda187a2a9588365e6a72947ceb55f1b3018ed118692b7819e602306de349289e7cbda4586e0a361401cf2265421c0ee01179764f7e026c5ad0c33ee7009bdb296dda66ae8cd705120b72b48a83a2658e045c89fc5accb4396e648f0eacffd93bb1069954ef6f0b7dcec270c92bbaf8230edf30119d97cee63e26965e4faa60c96d7920c514ac5daf011526e2ba9c755e1af7aec115e1f166c07aa793d50efd8e98da4dda5ba339a9729151a1ba1ca6213bf98226b93d8ba1cd18504c8633c67efd60eb916bda9f400553e5c618b84bf093756ec7015d7fac1d8b68600db4c6f68e2b9c7e3201177d872ddaf345ec2df2a9e8230e702ae64afc5cfe57a022be168a1f58d05681215597ca617ad69dcefde3db550a4ec60938885fad5fea3884b567d6dedae118e48e477467670ee196591ad51874a70f680134498e597c7dfed2a737919a75fae0b057d4366dce2fb9d81228903a655550b60c539f06f18a36e17d88e30d3f1e11768f8075b0c73bff91e0bddd67a08de8e782ac8513caf695a9fa2f8bc9d564fcc9391d37515aab3b4591bf200ef1d74811c79d2cff631b3b893f57d027046156a21872585f8df51262018a79a868e0374691eb0a823d7dc85ddffdbf49edb315d690129a0d04b70ff5762a6bc480357cde56c963b200b1f70d6af4f3e269e96aef0031cd4c410edf0e14187713806a386cb1f569f6402d7285a346f1811bf0ca8171a05daa02952b9bed521e292201fcf9c0a6ddbb7f52af0a442c4e3edb262da8d98ad8594309f31fd82c60a32e6aba626514835ee401ebe61f6aaafc2e6b063f189205da2c37947d7c7febc3ca7222395da756138e763cd1dd22fa4aa39f4fa7408f8a3fe6f6be021d6e6309bb7ddc815fc9752262ab8928b22ea89f9a9815637d9ffa87461594e4469a0539c5b56e6063e82476a29b90befc75addd61c7a0edf5e3a7d09a76a6ed7b74b768d7188a8e13c54f784aa106336639b6bd34d39f3b72a533ee9c96d9b27aeb143e078523196766f347f991584a6fa3b7dcf69b25546b862667c3c845df21d7c49a42fdbb787d6b0c16a46f02ffd0d50fce1720e6555da535ad682c80fe5f7fbc857d0a716bacf4465138b2cf8ef90bb62ac0d1b80d00503fe40c15e3704c425531dc720a56acc2a5c8bc7815753559211b239681348bc556dfa13b94228d73b7b690d465599eb1df74763b6b6368a64230f42e5ba8f159f12f746a43b9098e4b54a8541d302fab4df8a678a56b6b711f976595d0c80a347bf29c3c484bc2dd1360f92a3df4d41e96e50a710d8bf1dc7810b380268f18aa74c137273f75c60b4f5baf1a62c41421ff6e86cf4ff727525ac804b61c1e0cfe922e7e71d7e37f1fc77190aaeb90529b22a8f960ac3ea45153da3cc95a06573ac0417217e431f7be7ff656571b32e668087faca85cb76494089ffe9d7ea49d884baae6af5884c917b18b0f10184b5f17ed7a67284f7b37914220cfe30731441cbbd94fc1009c1391b2181774e11f24916667ba53b1f35cedb5bc05712dbf04a283ace4adc01b414ad8dd5436f551c7cdede2df3f9949e712dacde803a7a8b3a60668f4c7d0239bc725569385fbe263cff79eda2e6270ee498d62b47ab32e00603e8ee25a2e8130bb0ac707bb16d3231f318c69eba7099cd867097e6a24c5fb96ebc99da1ce0a97467d89a5ae14084e8f0d78a859e5f49e54dfccaf7be018c541c51cca62579cde63a9b2d02eeb2325a702565dd4cdc67117ecdd63b54069445db4c63fa48a00c3ad8a14d357711f055220babeaacca03715209ccf726730f2eda401b4f12b5abc20b486333b0202c8c5386fb589dc9e1619ab3b5a005f91158da49f6cc15fc6895e7d696f06d9e6f2b7054777fda2db10e9e6f790fd49b22b7d0c37ea4160e14b3856dd8321afbae4a1f549d8749169b7d61d7691ce56ba0a51ebc9854f3ec24df628f4a19c63a7e2b4f406292b2434c677f191b9287c4a09649b7e870ef67658662dc74f0e17f1909891e0d7ace78e4477b8e792e087acd7bc91413a663c9dfa7f46414eb4137a9d8d27d99936984b49875795547b48e5eed3019594314683c1608e0e1366daeae16f062834f3bfdc6849a6632f1d114540f970db608455fe22cbc45e4de841349bf583ae6b25749e956738e1a4aa9844068875f8d2ca2ff0f9dd8bbccd954d711901494bc226be4616ee9c5db1e226964b0192e1e6f00efd3a85561105e90b5312d3eefa934211e0571a558de81d04f6c4c6546ac9a69f634bec29593609e7521069007527c5590dd6374e38139b40da75099119f386f439a4dbf181b382b73dbeb452d7d0e8f0f11cff17d18ebf80fcebdb4555daa654d7c7c99a983b8b405e2caf7039c060faef3d3d870b9f5caf80b6fd5b1ab555400653d8dfe07113f38a98955610cc5901fb5ba75d8e7e8b5b0eace31a40ccff7be65bf93ae2f23ed46ed902130eb603cd53b5be686ff5d1c8b75540ee383bf8418781c913335c555d493564e418ada81e00852e58bede323a23deda21ce8aaf69292566b93ea13f2e2d1dcd6f436cc6b346c98ff653ff2229e01751e50cba2cf2c80747ca6145f606ae836912436a0bc2a590f2f8ec450d3f6db8044dc383074650c473c7007ec3d242b3b69f5755eaed1f7f8f58aa53c7d74810bdcf2dead951e184ef6dd34ce071f8e08bf0ea4c6a98dd6c64e56b1f7ce81f855b7587ad56daa91005400811b0145ad61c76d0561f180bc0464d45d5c7b2cd164e18098e1b1a63121008634fec1512ddbb181891d91b62701061809676174348dc426a9f2c0456e8ef9f3f36ac42a31d3e277595eb36df283720aa613aafb71214ae167f5015b59f98f8f0fa83b2cb374a2d9f97a2b96c8856793f2b904df1923c4654783cd5e3975496d2fdcb9309a7623d3e4036a706b65a7a37d9a6420a7eb3f678f49f5edaca6efdf78438f72918263253b65a67c60d3550f10ae39bd0038f6b3a003f01de7ad97fc8a975307186ece2ccac9be5f4b38b5257f20503671eba2f0ec7c9c33c9682e6948171bbb286bb63b91e16c095d8ea9dd414f6c10447e8384567b192b7da8ccb8c5eaedd213a604cd80e2a9069a06ca6be41c833d0b6254f4fff95fd90ca6399a351b6af0f0abd4074213872ad7210a244011c1aa918c9d7c6dddd2d4a57ecce041b490fb75413e798cd7b6860c23db7f2191e476f05bfd4e53d00ef7577b7ae6577cbba1ec87feb78cebe7a11faddb0bbc04aa4d10c3dadc86bf8b10c5af51f5a621f9c2256d27f9a168266a5fcfe3705e2ced984bd84741d3e0df54ed80302c6a18c4a0140b6b5b65b776ce5ef41e72f84faf26621cc9774fef5f01762e04a02cb8563c3f852f115af5f6cb7e045c78cf2984920c1289a6af2abb6f0954c3891cae376bc0aab47a2b5e9c41f23b78b6f859cb487c5069571cfedd002f4e8db468a86591d5961196ed866c4192d1a13064447c2e06b2180880ee26d5cd01415987694182f5e33ff1c92562e1cb8eb7c42ed36ad8f05a5ee1f20a2ff335bafe61bcfd8f928f546683bd1ab0e87180d221061868baebadd0fdf971238c6003b483f1a285a60b411ebf017c8075e890331bdac64e0c66a165fdfd7d3c13f61a001465e7573b07a40b65a3bfac9ba3e34e6057ce8bba14d9d33e5a783d3263001daad204734e1a263eaee53e2881240cab71b2a23d0533324668b945d1624acf1e38a364d97cd00995cebe8436f66f6a540ba4266045d22a74299408afe32a72f1b09053097ef289102c3e96f2da04f3bcafa9b6c5cbea0e3f26eba8aef4442c5c20236c8a8d21d5f18431ec887f467664afbc507139a83a7f45c36c444b059b61be62f30df32126a596f1ad7e95fb27901e93dc063bc75e39d457d49f9ce1f18a059153ca5ea9aee1d388a3c65ea6861c1c6fea4c4437fbc500760d2cf5ee4d05a23a40836335ea2d50448738d831eed00ef50b910c47dc0f254ca85b226555449a40d8c3a75517f763cd8a7b039b2770716ff26074d1321ef9d33f2e8b6b5d42739654a3f507f7e6f3ea0438c746945eb73cb4bb599868a38e9010af20ab986054f592fb69b7710a9d255a6f7bb84a7f031e74cdcd9d5a9c0222d02e67f50c5848c7dee336a029ca262536011d0d9b583471b6063ec5b4b7921fd76ebf6028f714b1f1a0bd17cf20f372cfa19f16403a867ca564699387b1252fb397a7058e1a27c1725978582cfc3ef99816ef5353acdf18d898940360afbe6c71577191fc26a5c0964f90f8da89448cf110f0d540c6146321f27e0ad7f2bb685b06dc3a64ff8a794e5c12ca090457b295e71d8b10fbc621550c817ecea7422b31a6eaee0eaf185800b76da871505f375529e89e803c33ef0d25c7bb51ad73830e649adc765ec1726c1ae919a585077462729cbaba599b3cc1119dfacd781bc7a438434f5bd7990d0b022bc9707bd7889c8e622777b4903c92b5b75e71022f6ec3ecce51ff123dcfe366c904d4cd76c04f41ac722452ebb4a2b5bda0c2185028779bd7b880abe85cf4a33773f0c220c0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
