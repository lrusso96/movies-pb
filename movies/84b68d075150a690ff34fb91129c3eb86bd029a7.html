<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0cdf0c753a489f596aaf0db4dc972dd37beb9548fcd36054026299a77fce7361175da1d0808dfd2c44b7d04cbf44181b4117d5d81b43d4302cfc32512938fd54f37c7a5ea8498030ec31fa3d3cb3432113bb7158b367c69433c932c612bc1c7b756f6717dafd9e62b9656a8597bbc05b360a439af0ee3b59926b88498cae04b97fac2a9a6a04f717ff63e3e5b80cd00e11f403e47b7cae96f16e069c5dc53f61bbf9675bd469c6231bf0a36d7e7c96f171e571f0c2c91de60b1630f78402e8ed1ddf8ef2c0d0966137241d681953c6355679e5a846fa7c996f40faf508c3d14c8f6afd042555b52de98e31995c697b66ef8309bc852aee8db8d5328b6618a007b6e5e3245295a697941be443c10e6fb3ad022e7801878d2447db7a0ff39f1fc39b43ab9b7f20afc7ed463224ba7d5653c05757a5df2e27b1e8d1583a58fb6439ee1cd88d1bf49b872630d038d877105022c51301ef58c265354848bbb720e065f98b229d75a671dc8e9283e58012ac37d94eac707d88d3188eb57219a53af931a91789c548dde64f983b9a9d19cfde9dc639fc1156f1648c17ce296a391b353d39e721e15a4ead69de1a7cb33ffc570cec94d340306d289add05e563fb73e1f91ff4f1104bb44ce056839a5a59605ee3e279b21bc74cb0e9bef5e85c163a8be28ed20d2580c0a2e038b3287c89fc2743d4f35ea29ee4679f7dbf1f84ba4e6b95d37d17b4f1f9d347bc3c82dfd4435066b3c367bf00a2f1e0707f5967af18239a5c171d594d4d023cbac0774de2c0fc8a9a4c239f819e97591bdd1a321b17365f7d3775f8dade1ecb6ef5db6a468afec790206aac2e450460dd980b70b1dba17750c8097f7ed897a6c31b450f632302bd7c6a89571bc79b5e83fbc4b1ec5ee464e491bdd5272c72b56b3ed50abf0b8cf2753ba24a05ba516af11598cd425a6e2f87ea6f6129ca59db866c77fbf3a8be96c5cd1a0920ee4acdb85f146b36dc24505cdfa18ef899a8e514c67dfaaeeca81bb059bbf34824768299c7223c046bfc79a878503939c99b9ebb67032c3a660e0de7b4639cd06ab49ae788cc83cd72dc3257a60be04a0d01ebfe561cb16b93c8a28431062fbe63f2306236d2ae2153030d02bb75cf3fee5e1613b02f62ab01f6b9aaef94c780295486c30e94ca35c37f8c8c84e037634fcdf53c21856fcf811b16bcef3df510ee81b61ffe62bda991a33cd9e5bfc979d5b5751972e15496b7cb6dc816896cb22f524be2ea91dd114ef1c7a64a222e896c3688fc4d8914d67dfd6be4a5739e9b6d79b6e6eaccf42bc8678fa6918b4e25b03d91b239e7e58f46dead56817bdec914bd17126a5f27f99af6dae899fa0e9e1370c2dc67064799adfe96c04476be025ca36ffa6965ef17b09d44e339f8edc2513ff65477c490c1f715d4834ead081cc2f7cc8de4525743dcfebe7b885646eed1f2f129a2bccc32738a397c8fa278da169993b74f629eeb41351313c79529639ddc1b7e3eb3d6dab2d25b39fe7e9e70df4f45acbebf5532343fa161b229b242766d708a615b1ead181c7d18662eda59fffb5510b7199fc1b42e55363657c2f0c9e5eb2a23dc6789536715f5c39f70b1396d1b32797ffac7fe532a29e84c6bf5034b146ef1f3b6a8c178d37fe74b71793a237699704178771e7c01f6beb9e9b303b3a58a6272912fdf731a02cbaa3cd459af1fa1860f834f3173a43331bfdeec1b75a04d9637f99310b89431a707b393a81f6f5fc563e7cb3c7a49b89064f0b18a53eabdbb92c2a5c94c29c302439eadcb15449603b2269fb7b4ceecb2d68d6597b5fd390e07c68958f1b8a2df96f3757183c847bdf2ca73105c5536b6a3ba86ebc17e8e0e124e396ca17a07b6c7a98f81045df5a877b9f0888f4408dc65e88fb8916b84e4f6dfebeafb085e1bc2813e90280b13a7429dcdbd323d85801ab12edc8a602c6cbbedd97e44c6bf920d0da8af4c2efefd7a0859a3bb6006842b9aa7fd67b61d8a6e2f44a4cd801f991b33ff8240b6108898fa94e1351b1ab54a2d2da1d3faf2136571af75d6f6c4109f887f03f3aa29f2c8ba7564ad0af01db66c4621634a42b3da7f050b2e259ef9fd8c07ad06a3f36dba5ef97a7c68a659988fb82c3e28ecc5059ca7cfe296b54b212316fc597820399d23d78ffda8bf583788beba0c4fd4cbeef64811d9bff1dac21cde23ecb7e6ed26c4467819746346d7eeb06766d9db33be60fec8b03fab1fe2c74e1e9c549c27147bbe90504eb4a23b00464fb825b3f5921a4178195f2254e7728a1a13ccc4f96797820109d677d7866bb78aa1b45e522b5322d72f40dba19fd9ad44cc71227604540810f6f449d8e36b2628dbbb0ecb6818c0d91d8eaa9a4a970d196de84195f48f72109054f1d5b0494fd7c5a1c8cf718f283dfc6fc3449cdf17ef4b4d06688e45c9836776019f447e0cf11c572e8eab5c90fa9c5403d2d9a43d68ffdb1661c03fb67fe4456eba3977b7f8983d8ca6bf7182ff2df48c5247688c1f4ee45d80779180c51334c298b5c25714d43bc090e72f3f172a094255efd11f1bba09a4365dfbffa2e7cf8e27bc868876c90ab7ba8ca5a1243bc3e129da36675738cbd64602632e9c44e7f41cd6ad67edd0cb3d97acedaec2579d33b9278eee059bf29dc8bac7576ba28da9c2b8fb7f03e7827f855436a3b31542be142f0b8a9619af8cf09940915326e018bad086c4260142d96e565f3a7fa87e30623342951473437bec1218b811ba93c860896ee7d4b3e66cac9d18fc32c2a891a6a121b9732bc51c9a1bdbc081cee199532fc8a6004ffe82e1a3604df7c3366a76cb2d85db8bff39c9c84ede36abe13c196ad18d5381d8edd08368c825297edf46aed56a6b105609e413d0b85d99471ef4fe02ff5d3ce77cf9f99b916c01a96a5ff5f6c751d5e0e3c41cc98eba36a05a4876403f84a489f824da9ed0144277ce37d4ab42d1691322d520099b8ddd11c4653017c619c613ec2c2fc9ce7d9f207af27c2dac6e4b3cf10f12e60ae4c64a7b3c2947f6279f76ea5e20456e525f9295d6976a0a9d6427aa5ec38ee44df87e52751ffbfcfb9f1b218f3717ffb5412a4320270a4ddb4a5e35669fc1193d5d20c405d5556c910fd035ad49d49849ee2f0b1ad69f10d5a01b55646b28200d3c58b10a6c505e5096b58a71e6ee26418a94be7bbdb9603ecc850e951377a9790b7a4af4dfad707d4c4079f35b716bdcb21269971d76fae9ba19934382a58aaffdd739ee05b3e856406557f3473394e06f1ec645fcedfd0db4b0e18023845713066a06a78558129d86fb2d23abc360949707231be001957991996b8a6761df30dce05fdc27a96b5057039d9ca0272e7a9a2e59b36c5c286d57b018c7ee931d784268acaa872aba0060cf493f4c003fa4dc633425aa5e5f1c3697ca1f7f7b12cc9d2f872e79d919a310e571d9407407e241e0900c2f2425cac6bab3f1264fac04ed0802192035d5b6f92cd6847c2b1a3b49ae25bacb7147be5f22248c489786e590f233dd3c68c8306787d2ddbb3319100c631c0efe12bb4bbdfdf42f43e00b54f6d83d245c270f4b6ec3f44c9e0f4f7ff6d51a3aafd4860902c108aa83ae9f7f9671a2f6814a5d37e1ab26f4915298cc3ec04c3feea67ddd44d0f3f4fe0ef1eff468df9b6c4d59d1d62611baddf2a4f76e200faf6d8e252244b92f7e9a2689906b89f443fe9eaeb9a6f53b3751f98ebd0ce5e8d731d0391b491a1efc4a83e7faf6ea6a30cc7c5905f4d74f4cec732c721a5601351362c026225ba07d69b5a6c72162a213330718c5290676c49820631b04dbc78924823ef3f4e7721b56c59e364addf53a12b39e71566c5719e308db4ffabba4d1ad4435fd8df4d840a1bf714ad1629f7f6b4a12ae17e0c7910fcc4a47288fe43b6b4b4e43937d68f21152c2676ee06d0ed552b34c90dcc1916eeda99c2236e14b7c43e0358dd906036fe54d3553dced937dabb379d1afa3a284fa07e68192f8b9a01d9af746a8eefe5350bc2f3b9562f71734ae93b11bfcd465e5e59d8444cf037b9512251f0c8a24d5baa81046740caafbf500839bc8e28b5a3cd9d51a752408a597805ae6fb039ec898a383fc0f85fd798087d3ea66de324bbcb1e1aef50faac66f0a8a15234096ba2faf4886753e60d20064b3efc9030b2aa5420cd86655ad726d0fee1812f25be9f6ba5307bf654d76dc680d19fdce98b46f9e1a24aa526e1389b94e6df4130c3251a011d6d9c76c1f4b1b0e683a14d8cdbca056ec5c5a183de7bdf9b8a1bc76d5565ce73deb188b4f1536d72cf7f9c493a0a4e4992a55bed266ad309348dee4276eee77d4bf9ce444ce3f645e179002b32abe599a0b7c9eda53158571243f7d2199339af47aa6eb7d9ac2771adfcef4a8d3f01442d1ad7d0cb03cc17b16df4a98fe6a19e698d04a6286fff6fc5a2b100e8a856e962fae5fcb9e0afc494ddd43c44bc0425b9e78e3cbb335fa6ac704a69fef5e4dddaecad8367addfed1f096fd30a086749a73ad32b85469b3e401c8165ed8552c9e4bb7e85477906c599fba6622878864f1a1534cf6404ccf35c2b09fd40953c68920bf84446c479064e0bd5bcae86f3cf9f0db333c377e2af429b712042f6925d81ca100db4478af245d40613643d5b071ed881dd7d14a6bc0011d3103ca682b63a26d448f71a8450dc939f8e87c883b50d92ab9815830994d06f53da8c760fcbdfe4167a83f08b8696477e3551ef2b1a991edb53e7de75e4da87d102c3ff64ec3ac134e187f1ebb5c49bcb788185d25a5da3914e514796eb465b136d2b1648a2a265a958576444136da16d52e80888bd94957aae183137d774413de2c4181ddfdfb1a24c57d12ab67a0adf6ce8e31513a6c1e22eb132bad99fd95c802b6961ffa7f6173d2d72f39cfddbe5f30c1079211da1cd73393bc4e0e0ada14c428626105771a5d2a31ff8e68b392cc208e4af5b50f2ff9774bf73025584b2425e300393a426a1cc364bfc38b8d28246a39c0589e936b060fffbca1c6ba2cb831899bfc607fae0bf08d42a776c2d866a15d297c6e95864bec8da3a74bb47773e3ad096cf2aa22bd6d63d127195e85cf51ccd0a20d91b3174de373e3c574e5ef43532223fc76268afb387e9ff3577ee47c8b0c1d0528ed091c55a4dcb81d693820d571e5521863a92c035a427de03346780d88e5e27a189a27fc9b154cf094201f9d7326ba8c1512a74409830e5ec0d65f070f2b80f3a6246582807088952a821a34cd8801fbbc7da1b56dce4d5b4d892c21eca6a712919485c59eaf5100b2dcb6e26a124c57ec1555c8015449f3159a2fe5073a5cc1c0d4f0341860a58cbb66aa63d7be80213116acd1904e1ef5bea887782e47f06a7da40edae6312aacff81af0f7be3f33b47d7a11cc42e5744ca26b2153afbcf3ebb07e57cf5847c5e632eeae68af734a2b7dbda378ef819b19268acbdd706e824afa1e4fc12eff273c11bbe956f32c8a91e416c9083dcdf2c8ba0bee579969984e5a49820a65992a4734e254092dd9244172a42f5a1306ebbf1bbd04cdfc2864b36eadd9e5b66f0559467f30c6ec10f574da78aee8996f225695f7af2f317e64549ad104f32d5e4aa218d44925bc299ddf1d634f170a31dd26a18617a07839e16a6e139b764bdab9028e7c70119fa7601b82ec864b4a24ac439bc90e9f573e12a57462694869a74b9f27641253c849a85551ee7678a37ec8aee71d5859c43e57dc28d806f8d8a453ceb4c15089b17f18a03403cc213e6c71fdccf0fb6f02ccd2a25a10f94b263aa504d98dcce4be9290864f5a225bb0b84094b6ffc9bb15ad6022862bf01ac615f0d58612f8d157a0d5245fb85b9b08ae963fae1a9ab288b806beceec771ef77f38b9ecd99f469ceb35bf9b49f20acf2164b360766adbf6ab4d121ac73a5263db18527f64850978fffa64782a6440644b677fb777801b2cc8ad6e729c428f84be735eca4fb2e9f8068c3afd8feb725f140e983904422cbe1325b319254f943fccdc7a02ee759a307309af9bcb0aad2180024c185b9457df76ab9f353ca89099bd2f4478503cecb2b61d8c4b8341a322072968614c5fcdfacd702bc4b4a16577c083bfa8c7810d79a4f245d3baae331a32a941cbddc3681acc09a73a610347cefad8a6ef9e0ac800e26dd21556728ea46fe7bfa2da06252e6fd9f84bcca3e878d0266ed498e0adcf577325a77f4e4c10ef52b25f02ecfcf610f59a3b01d29865d40f2cf38371ce0172ef2cf952710c4de3f3f86c016866284280f43c0e16363c9b26c69d0f9dd004516f4ce5e0c31f08a3d05c81d94918577b2b30045d11679c8e03676c78a08b628cabe9aded32103f7b68d211d8dfd36bd881358c1f684a58acfd7dce682705d1f17395a6e1abffa9b453195826f177c191cb1bd39622e236d6fd39a1ed5bdd76622ef7d6de68d37a67d24585c1890677d409d38e9bbe271da0f192d1f972597d05f53e44cf5c48a13d5606fce8643e94afefa151af36182f62b7f689bd437480d227e606b5ba5588fa054bc6960e92fa2b410b08c24934975bf8f9e0c11808d441f0d647a690721587d124b739bf65ff970073e47499e9d89641119d88be79d0bed4a966123d83f3c05be1023b7cd35a1928f58f807b162abaae8233fe373f66d6f0dcf2942b293bda9b6374b62a5bc3d3be3d89718a98f4ca5c6aed801c3bdce4b2682ae2236256cffaee3e0eb739d6a16871e432962ed3016e3230e0a8d2625d8afa7b13ec5bcdc82280dce5d91e2dbe40a2191855a18b9afc2c549cb2c5626598d5345549c3e416ac9d946d066779d3048a566dbbaccdaea0d86c677ef0e350dc846dba5645f3260ca9aa1c76f2e37306c60d7c47c4db0949dc681ff3ccc07b47547c9f82b1d0eb96a7270bcdb931c10b4f2352563f494f11817b622b4c31f65e99cfb9739edb5babeaedff45946265156549f133fbb6dbafc7d23ac40c089bb4ba7f2165413da0f2f0fe63c750f4a7a9908e8bddda3f27f1251cbda52f08fb7ff8be71b4da22c1b93e71bed6234594ef574e78402e290e3c7f42a602d09408bedc6aa3388f6d4c9a5f62b166abb6eacc39e86160e901664cf3718776fa27e91caae5a23c25029ba09e46a5d2175255b5f508a0ca9688312ad82979aa749dde05e5651cb73859e47e2725f6b0ed40bd04f05ad9945bcc4437108ce7c3011a836913323a22e5db867bfb66292a9c7691e823308faeb488b907347f6e3ca650caec114be2de010a462cc784e0c3d95228baf2fd868ad99214e171d8db21d4cc101a6dc840d550ea62f9be37ad8d7d7858d80dab3b35b2f8165d947041beab45ec178bab402fcf49052fb1044ee80f2cc75189231f358e46e0aefa90a3a6752998352d4fd2c19f9574d6c78a3393df65e6bf0a48462609614a0778d1905fe184c246fcde61e4927c799ee0498e95b4d0fd88d5f42ce25ad06392a069cfb747c695a27c9e564fed375cd74e786c70654e1c88a7567993f5fd67b6731c4b67933a5d5c4d3e65858fe20aa8e9c1f67456ef4791c14f3c34ebe8b549cb41fe5af34117650a410349993f3b7e69d40a02f75fca7d80323abbd524464c6d846d3296dc5d98d4357a1a4fb7777633552ef1167f118cbf77102fd52adc141f753ac77a4be5a670284a8470c3e3e0cbfa0bbf1edef3c22a253ec268f736759e1b590fe91b3774c8bc1b1aae57c632fdcec31eb879b478fe626325e80167f7abe7a5bdd26e2dc291497087e40127dc06ce43d4d197ae2331c3875caa461136890535806f0e75642e4280d7111d3b8de8403cd0c4d88c3cc0dae34ad348cf7a4bd5a1f6d5dcd6926f7460a62cb89788f8cb3cc0f7868bc1b0bef7cc444200c0fbca1627dd4983eff129fd9487fb1d1c87557f27d52ba21c4e3fae4ebae9ff248dc8e66cb30a8c2be8d551ab44bdc2d6b28a14536979d433aec84feff3ba5036d2e6229fd41f60fe7fcaa619fbea7de95b100ff81c84e5720770b2622a49a9e697180749bf7e8afeae340dae6a0414e358bacec68969dcc8c4207f6891ed91f8202301bd8f78f6be10ecc321eabef7f769a3ab41b4b42e17539f8c8c7f280624f8ad94b9f2c35c4f35e2dc18f9c03e2a98dd671de09277385f40656ffa2e4fb31cf669b536be965f5ab39b24844e548c2242a1a754279715acbf14acd021eb25a1119da07173c79c71f03810d2981d3e956fea001b6d2c24f03616f316ffbfbb71b267cb8651a19a8bb01d25c6502a48814f5f1da584a34fd9080e3692fdb74e92e56519437a7490b882ee899a1684907eb9ed3dbd9a9232f4f999168517f69cfdd493a9c2d5e075f6b187556c77c5d9961b69c300f961f2ac1d513d73d096153aa5ff03e55b988b0629b0b14f5dd6d6b271aba76841a37eefbd866d606b99416ff1295bfc54b30f125015a9133a2eecad4af848cd1b6406ff054b16e24efcda9a89a46a8a1d05176409558b491a685688399dd7b8f1dbd5e3f193c4db7d538838f3659830ad9956763592bcc7a14ff56820b635e8c36ae752117e3272a5614eb2cdd07724c1dbcbe814cc143a16764c3b298cdbb07fda1cd6ee1186bdffbc8ee629e2c0751bf494db7f4f0243c7e77370137cbefab82b89338cfcc01323490f2b66f5db8125b76801a565d4aecbd5415fc0d2b771fbee3e7ff50f7923be8e56fbce4455cc017df6555eed02c8330ddb1c3bd280261fac1051aa32f97c5c57855752715f9f2e74339422cce87cf8023675ea438d62c7481a8609146ae82b55e2f1926b900fb41a0a0a13aa9b7b4573e848c7b98c31ff59fe5f57e37bc736f65d2ccb20cf2cbb185f3552d32bf728909b3c7cd63f98dd77a70d35090400c35a18c87d43b95d060a7a50784c319f97afda44012108f28cdf671f2760f1d282957ab592a914627ea744b65fb0085a0cd97572660f9a6a702962c89b5c8237e4a4fed0d05a46008bc7088ef967488db9d8e9168844ff1cdb59f2aa924f8dfcb690396032380eead315a63396386cf6d265e5ef5a418dc5ef1830cfa77534b5060d83d70536e967fcfc2b3fe696ecef41294564afcd703b83d21e49c3173f298b3b6e8329f80024299acd51857da861969caf5bd2dd6b08b58e65e0dd9ff98b62a6637b1b089766af177b7ce66659e324fee9a86c4c9b938c362a145736955f2c1a8a6bbd78f417b9e558a2b02ed965ab819bf9a991016efb97f0d5a8b7adbe5ae621911cd045e37999c0029cbebaf32d961b2aad27bc76932a27d5c090064cb2d0bfa6a3b41cd40b5fd044a454afd064fa95174d67a57ff2e188667241a3fee0de3a3dfe41f05e1b8048ca68ae9b5929bf35375e29efb284e898393e54bcd5d3d74b53194b35dc10c9cded3f5329e4c80075cc33edc0c3c5d0e708f7301a263dc695de16c2793327e8c149f39bbbc8eb6e196e60213b9e27c545ae853d01d1aed18e5bbec7086bd31da2459914bd0b6945d54d625555c334e96dd5f7fea7f26feb239c7c2bac2dbc427072c0f91502d0cf80f98a2aff6b406eef6fa659a7c239fbce451ad7d72289af06baf3a624b8998ad574b69a23f07e89f2f6dd9bebeb52d062e37fc31ee32d3dd1cec5719ffff9971f22aeaed2dac0b42d6741bba353452ea2eed17ebdca64bd0454aab17f22b01188a3dcd613ff1067c374b5842da2390c29fda1b3b9457f1514c9d7d46a16a6a628c7adde59b5b8757f577ced2d47680af1b1b0030e776dd72e2542e751c0a796afc9f04a4d6ac99a89a573c8cf6e11a24885603aa4334a459d1ed1d4f2bb361fa70f3ea98f96ccfe527fb2302b8ee5b0d912ecff9e0d44fd44258733b2bded493497be6917b1bb5df7a6dc41c1f5d8c02790de561b95c53e5fbebfa4766c13806f8e527cba84e1066b81cb60e69608c6b59b19e5d291e2797aa0eaaceda8d62e49bbf67d6766b59bf14c522ee84dd076bbf7a3a6805a22e69bc4ff86a8f07037194bee095f4a83bdb6a87d9e1e11c26ad17a74c8ca827bf78ea7b2caf24eec26014f6bbcf359f590cca1724330009f1d6c0b9689574d58f3eb26a84b83693e4ec59600d6c8c8da2a27ffcc6cec38cbae581c35705fa9448d4cc55038166d752490f2301498d55837af57ac204d93f884dab05551063b855700a074bd0b9d083f9e975e3b3900387fc39f4eaeea04d8f06a74cb179639c18af2c293c414413f1318a4e99affaa160a4ae05afff605e8c42bef7ccedee24c12a646e6b9602e035649012e3a78bd429033d3be44a3b02dae67e5ab6b104d7639501d8ea40aa26c40b3dba8444547698b63bea415fa28b95074a0983a99865ad1c7549da3979584561050c76316f212ac2fcf8db5b08e389d3d9eda66992ea5b0890d2657394967f3da4e80e68de789d95d57cc4801c13d8464e40ddc0f6d59f60a2986fa1553a37deda6c59200a939a9cd72bb145ed73e0d7871a06674f06e815211c58369133e2a7cf3597f9d780997eab40a9b8012a1f91b1c1a43d25c22b83f1c60f01253addf1ffcf6067484ea3bbf17b823a01ae0c199c77b7bdf2bc217a7b21d502ae8ecbc891bb9790816f0556470ef1b39f8dde8aff98867609de628673034fbd8f5cc328d88052c0fa69a36c26464ec1ea8f57071860894a9030442326e5d87b718fe45dba07f55948a7597f1da14b84b70b627486e612b8697bb8a70fb2b3972eaf9a7210e374ed2cd385287806b545a6f43900ce157c12e7f6488a43a394f01cfdd739dc342056777e24d7967971d91c252482dae4829de1f761607dfc8fbecfe1de5340aed47d3aedbb97f79b706c3baf9b05955e6eaf75d36915767eb84441704005c2c436055d1e76d985c996351b042f3e607bb4e65ac83a9a73cb53aa7aeaef02f3b3fc8c67bd5080f04550b22933b961d8cdb763469b9d29f5fbf802df0d55ce0d95ed7ee52b9c5cc6a9426f161f7c87753f8c90584b939ac0d3d8a3ab0d5adeb7f2cbe1fe132c3fde2ff16b854a164933e26118a5f19a79c091304ad3896bee6e7bf851e447f33a8f8846d385b02212ee5b79a2a1c72204aeebf720b7cd40221e082f724a6235fd32c66bd067a59a98c6d83893b23ee95d0a96e05304c400dda3fe04f77abd3b2b0ab6e1a7d4f6f35aa983e4b0c2d4d7c2ad7f21a578c8396d01a1de70e637977cd79efe507621c76065fb424363079826bcb1022e3f6e0c03248026b54b1ded44d96914b7467cc0d5ac3ca5f755c800b6d00d039d0d70fd9ecb3071df747be6efce34fb53bd1a3784a4a95dbd04ffd792d317e7e8514531963e1da0370f4970294571eb5aa97df34813879fa87e4fab369ed0685578be9b64fffcf498b948be86b213595f4b92373246458f91828c917b8ae79388048be4da194fb7806dff707fa33c345135cdca7c3c2bf1a006be1dc1a5a14bf23b175b7129b415bd41a10cac9d2332f2f2b2a51ccbd8a42b50993d790e207b8ce82757340db1c2588b6d8e27891ef9c9487ad6dd6f1904bfb04f3f7bfd949aa71af4e5717b35352039aaff500b4b75843e11eaf526fd6e9b42d3e6e6ebd60f215b47bd4ee01e0b54730eda72415c16e853007f9c96040f8022780b22995532dc323882e6e2cba32247b031c09dc55b16758f1db5d78ec717553199fc73961a7d22eca951c3afc0906ce8b9113c77726a106989af44f2a98b3ef56fce62008741b3834f45945557fc6087a3674ba1b448fe9d33563a11730ddd8c7311bd515d8c4f1ed73f5226c74fc93bcbc1e759613276c906bfe597b79d62dd2fd4c614c886cd890a27c54306b91b8ba68392f7e15366a6bbfe0f8c232a57de32fe45a43d619ffa6791f666e1c31f9d31325d07e4a61aaa373338cee4ba831b3be1d04a28a88ad299654e96af2552021d9235c6501ee959c01c4a51d34e52f4ce6af43d2be19c3d87df4f577726c658444f4996c30d957a2275556ae8cf04b44479ca41686c23adce2ceda20438e78558fc159013ec2bb3c503748ee42ea4ccdd442949351084598fed6db202894c1eb69e9a271f50471018d791dc888accd04789e0aca5b993ac50ae9c2b089544778e888db6c25dd1ba4e2e9e1beb7060905270f12e0264f83568f6842904a96c49c6811acb76d79a1b5a48f0339462c92a406974ec3b21bb31d37840bb4b3d2ece999028c5e2b71d1b8252dfcd09547e2b431cffb6548ed8a4279f2dfd7a21f1852f1e499f326322d228814f4d5a12e20572e499b96ebc23a3d5c21e26647f2a74720f77e1368dc9aabaf621ef99108970dd9bbba13c9273c63bfc3100e524ccf093b9006c95a6b822300495921a8c201f3fb816208a026efe1960ed059a26cdc72bd8808f9a1df68313b5fda58c391d307e7cb5637b6b8960be32d78a14ecbea9f8776fc73805a062367736a723878899e8107c5f494eac0c4b89568a6d11dab04782ee1a17dc6d569b1b3c0b5c4272ef4d9eb359f0a2d92443d973a95ae26918bef651a1b87cd2339747c1cb61576b5200e8024451b9965eb27505a5e58afd81ede29db0c7718f51412de75c1f71b3de9bc6180014aca45b678ff2206d86570c1044129b2e36c6fdad97feea4731d11b751e878d48737a34d10adec157b4225c3d0dcd77daf6c93aca0b220e5227f45a7b2d5d79fca6317a754cdf72b09382e459ec7a0c1a778396e013df5335f1c808a4a8998cffa53ff7752e61d111778b85f097a1c6141b7f3810f01eb2674107c3d00381c812327acc0fc9119147ed1f2c44989c297a96fc9435cb8a5baabee17069e81a6fa65b3567c762ce3fbfc099eba2d452feaf9c3b146a9fd246c33ac6705129f860f4bff112ce10b8bb0594d40e66d4e6529cf737f9201ad7e9b344c9bff1d13d726bd41a5c05d7f8638788ab48d7f316faed72a1f9873242988d9d568803c707a1f92525048c457d182998e090299b7138c59956afda0ebca1b8cd709ef2c53f2442e9a4b8cfb8c679f8f4f06f6f1c1d843095a7b6a420cebfcf6aa4dc948cc01c8325c2bda52237813fe76c97224b521558f1938be08e9b2f5f870c996b09471092177689b7f0debfacc93634992383577fadad1a9652a2da2567898603267219ef077f80d8b23059ffc51e50282fc6127ab0e0038b90e809541efe545fac98ff4f6c390b55c5b974d80a0dc0347a1584cd7594dbcda0ede873c63a571d634077c6cf3ef0ccf931a1187fd583d4875e4ae5707ff8c12baeb79d7a4beed92e6b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
