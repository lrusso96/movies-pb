<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"adf13fe0359a2aa286688c06ddc000c3ba98d3c9e4c9d77af498e76de90f61547095e05179762826bcd4487fe2c9f6bd6cef4d653583094107d993b116cc798d963ce4bbe6b4c53f7efe027a68d171479463c8b8aef220675f66036530b24788186f608928021b093b5071ccb59b9ef7c777d5fecc251315880261489ef22b6ffd86b5cda903f9744daeef5ff3e9045c5416f91f90d0f8512e392b15e61e49b65cbe1e2f4b798bc01c83cb13598d4fe0d6cdc1f3fc06d645f11d6ea5c1473474009f75cdf1b7fcbf2b4237285ee79468a72e998176bd37bd2e71e143a66ca4e397d4e807e2a33dbb63cec70d4d43b2bac7c361bfa622b6fafa0f7558aae8cbe62859a3d6255a53e4bc62edf0728bb782ab185c2e8286e00de14158a464d2b0c971d61e0067380e7f63448d51fd6dcb51f4b02a026f456ce9edd531fa2fe84ee70b7b5fdfd0eeb0de07c457b376b71910ecdf19403899b847ec8ecc1378b33375e309fd15c3ab1829b22f8bf0aa247b20d78cc6ae5ba1d374fcb174044a11e95f57f66be36e8c8c9da2e2df5d2428456c11125b63fb3db3da5c7476387714eb193ceb2d63f320a85f9dcf1690f26de372e0d4cff9fc41f90b27f51b9181359d0190867cedae1b231ffca1eb13fa64a5ab9f0dc23b48e2b5b5ed5b625f5f68f5fa6c6d6df03e469a6a4461267c4dfb5f0716cfe3d891e49a3e1965aeee6b0d1f0be99abb36d60f62c75c8c00496c5d7bfefdc7f204dfe65388fd62a6db69f2e2592f21c7327991ff00e4899560cf73434d63aca5af5a349848e421bf915dd8ec24fd4c9f17a3aead03a331ed76b2e6e0ecdd1012dc52d99a40ea8f6914e4d89050b501b5866d6aad614aea48d00a0ade0f17c08474e8c7f83f524ac307d57976ed539895c81b7a13e7a36fc5fea5a9739aef7de99662f86731001c0e8cc7a3bbb11dcf09169ccf1cc071b23bbcf43acaaf0c67b30c870c1db0617a8082e37af72dae6c31b65c169b8c308a0cc0ae30bfd8ab1412263914bc859aadf8473a4fe6eb73cb2fee7262258fa2500ef1aa65f79e91d442eab902dd1a794759cf8088a97a6f63b1401405d9230843f56b091d0965dcf81433a9991ee04e948d4d8525960ac3a3a902ab9998f15aca0da52767ed5805cba264ab1c132a46d792e0b067b41717f73b58fd6611ed5b0a15522b5126563e98734444557b6a1b4984a5d0a3f5db2f4e8331075a5d7ada4ff27dfb729911543f5b04c892375bd1027de492d27be4e03ba84e8c362faf60068bf107ff209c5be46105c747cda8da4c3a2bdf754b218e4a27e29b9ca04ab39e5074eb12dac863fbcde2c1ac54dabb2f0832c6ceb72de7d097680d5feef8955c4c7fb0aad9dc489b17da6e7322d897bacbdc339c3036d0309bb4f848141ef0f85e3558c5cd7375db3e3efbddd62516617c30b227feded08ca2a589b4c0bcabd02d45622b58e53379ce71f995f22acca7564b38919dcc0f95f8f7ef376b94895e9c30f571aad67933ddfae62992bb822115ad972928f0cfae00c54c69c066139addd1b55de5179a18f046c581cc3e2b40863159f7f3424d20c6a57d185a803ac65eac4dea9d37b8e10ef6128c7680555d3a34c1655b505067e28440cfb6455b6f3dcdfb6e3435dda162954dc7740b6936897d4017871b52d7634e96b6bf199e710ee4b7538097278c17bbda8f0a883b7458dc5c7781ebf3cf8a1c4f0167c37855024e6cf14baaa3b99919cf491d6ea1f0254c45aabeb39d9d75f3e3d1f9fa1fc62d9b852c6c018aa510caea2337f61e582e4eb40a4434f71e39874413599509d2aabfcaa723cf873e059e856cd3161fa308e7ca1f66fefcdde3e187b69eaeb6d468939fa215d67d91212e1b5062be06ca417a95845c85cf44da71bcd24aa2c2a3a88880144bf33ddb9702300ff0e471f333370204cff3ce6ba162f0974f81216eaf6c4eca1871146763eb9a126bff26411295bd0452b537273ee14bde55b45ee33add3da28480358232bd1f31fea3bb32f8afeb9743d7ef4d55febe7ff7f225ad241f58485e9c31d9c28ce221dd67acc7379b2e3120ff372ce66882bcd63e38e8e5be9a21d8226dfd27f43080445f4cae96fee98229019c2dc48d3e85130c13789e77efaeb559c4a517af4136ace46a376a96ce6522ea5d9f1a1d4382b07d9b8a98bd87f2a65bfa2f26963e3d2282e7144e4f7f8f2db582657fe1f36494e752f986160cf93fd6f3b6c8e14adb9917ce71daf38938d8c43d75193f1c8ce221f6458846201e2d3e641ecf8f207eb9d484e12becbe47881090dc775fcc59e3b8c91e976e4b494303412e892c827176da3d1563824a507b8129674780293fb042c21e5aa0467df2d501c8934f2ba4332584880a1fa4ea2b757123344b2792cacc62240c602c6a6dec0940527165c2bc8cac2e546035f1e78253320c8b97dcb0423cdc5155e1198a5304fe8f419e29bbc7189a2d74d4da2b3659cdc35c55a0c8fb29e41aca34758c19ba04e0602d8c26d68dec1d6eeb4d44b72214bdfccc09ea0c94420a5bfd83f9ac60cb8ab3b95954499d41d6f6d4a5f44f74e0fa7e3d20a177106779bac0eaedb9dea778f057f2dbac99c016e7f3be239d6f6209822ff9431abc0e9e75f95db43f8a518f9e985670ce38ea66c72b8219d405989276cb35f721eaa8dd7296e0868380ee05f17c7bed4873dc4d6bf5c558ab67d8990bb4f5f04a04680e5527b434810ac7033b2fd1a64b54e13e7027d41a735ade9111c9b107ef36eefc14637b2a3d8dcbc06f4886dc5ec4ddc2d7a70074fa0641c0589adfd4cf0d2c5c49363cab0f3fb8d1f28f9f09a73e61733e85627e586f99a93322030f11b501dca691ec5712a054d9d7a3f77f6b3461c14d7ccdeca0d42ea3b3259079e72e2cc3862f2174fc4377a09147a8bc9c8d9deaf99c8cb7d3c02ac939b8865d4935bb7173c02ee12bbdefba04f90138bfa31b81e93f913a2ce57f4ecfbb4e155a71d42fec4df6cffb92ce2c4eb24221c2d083ff1c701b4df7324c31ddf31c330042b94e62b7095f340fbedfbac2308b23fdc7a6cae2a7b7f0131cda6b6e9df1fb9ade8760f98fc1347a405d54fcc6330ef7bc3688ea96940cd053a66e730b19598fabc86fdfb88ed2ec6fb82b775e646a34dae03a495407b96198e669344e1fac47ef74e1730b1197a99828cdcd14bd8c7860dda77ec5cecae82d62f172768b74a58677cbcea910acc99dd087a6ff03419fef3c7fb000bb268470e6cff6fa02b942f6882d526a039fc0f33b64bdac1bd92cf8a147434779363d895a53c2bb4ab89bd35ea067a09fb518e23c4c4cbd9b317e0a91c0d5ffef266bd693739bf3dc602acf281810310bafcc50e687600ac65de655b4ce1d4bd4cf50bf2074b11dca3602b0a3b1a1f26c593303101645f1c980546f81d76f10e294c9741467d11802d91feafe22e5a5a31fb0904909b1186a2a9c405efbe0d063075faf28250bef0e4b9dcf9e6fc8be379a096cc138000a73be612d7a8ab48fa729f429a783313c386f18b6b776e5a1f8ec86eb367a1ef12d077578c68f8ca058573d95c713a49b6f3d6722e6fa0c381c5e8dd9c76d1c45e02784eb804cb8d12e7a5c95b67ef6c4c7fbc1fdf8d60092dc4763a7a874dcc4ad437962b32e1e5f884ea6d15cf0383a9c032b1cb008c73e40538f7c0a64fceacb7f2dd91f833daca2cdedd64fb68a0932a90449030b37e9f154d36d9fa12fe4cf13d184be186457fd53d52a563b56ee4b164d7424d38f9b893ce353e721ec6bc8dbde6a3307d6f924824c3a194719c11aafbfc933ab2fbce8e303f4e2f0d1291c5ea433071e2e1899f64e9c11bd642cf4d8a37c689011ffeeafd0aa7afe72042199287fa8317ab06c5319943c988f8e3c51572a5ba18f55aa2cd9b53938495bad43fe97e63ec28f5760c2d40b2ee7505b204ee17820d530346b2d1f2a4531ccaa6e4bfe58e5880399b1d6d9f3bd9d42386c53d08d482e0ad3820386239fb59dd882bbafb3bacd66ec78df4bf6fadff0c2a6d94074d2d7b74e8902e3d514d889c3e4a9a3d56e60f3abf67f4fbf82a0012774b5318c6b1a0397e616ecc6be106ff2b46efb78ed179a1400bb0bcf7e363dae40f2ad5b5a47ab053dabc4e823630df49b7a94b952c4a121cd91bf49ff49e0115ce222265d3bfc5645006595062c5bf7ed261e443233da9c48bf7aae03da1f5e9b88bf377f3b695d8597c2c893c178755abfc53a9c8d62977ab1c6d54e6b04ef22e9ece661fdd9cb61a4593a48dc0350119f39d94a730f2b6378659788c39824b3aa65fa813fba6972c303b1a2818664603ff6ba034223a09927ed2e27cd05c88b657af08f0cdf1273244816c8863c2b306d3044764a335822de551e7e836634ad235b41b5de28891f69627e13ef5500992036dd3a669b687b9eb2d948577a60eafd7339496aa979b1a7d1e53dad9c52f96cf890382ccf30abd038bdae789b0e95bfdf4f7f6bde6e69aa754e3982074d0eccaa10067500d85e497d4ca723c20c82cdc88c1ffbb12dc71462f39d51368fa244166db93830b5f526b40bf0b1f4186a2aafb5ad4c9a30be0f8b8d804985ddf01be75f4262ddf77c2970718f51f30a5cbec8b4be690d2490c8548f01caba7c185afe671dc712525d9204caf6498c76f92448d582792ccdb82807905b480eff5bca56c908d8d026f999b7e939d1a1cb4cd03f41b6cebb8b5154af2ba7eba82eadb3137d5f62c0799e35c2f8d449087517024505019ba789ab33a8432530008890a0861d6aa0b73ba1cfaf5d32eac84d5fda4e53bcd131f5574465a9edf8986d057f74d88a90c6ddaa479c2535252fe17bd74c620cc655b61829a632cac6bc287652a5900e7a15708347a25aa14198861487f6e76b2bc62ecd13905b7f636db21c226a0c692888ddb3f7832727d2757a548b5a510ff6ca20b99956dc5ad20f9cfe1942b77e3dedc6b309ef0a1d4801a319e5738900b9091b80b52f6c5751f2e12ea38b59934184c46714e035c86ee1c022e828cd5406ed7c2b3e4c7a2c2c95c1bd3081404797425aa823646e42ccb7d998b42e33119ce77829dc36c96b5a1421b69c627c6dfc54d29e65f20006155fe4167f1635f658b6ee6eb12b36f9dd22516b93e7de7e1a84326673638d15335727b581a3b2052f49063634252a70839246336e98e568e480c5c6d6122f3a2a08deb7c6cfaf52be8a8c5fcc9e1e63e4ca3bda262106c5b6e91fd97bafee8afcbf65986ce849481f0479a567464e30dc9b95345e2270b56c82cae752fc7ff327f6fa7cf2e18b08d24c4aabbb4be679ee94b46e341381a334faea5d16b725b6073f6d0b9469654b8d8444b690ab396fd6f480cf036e161052178811e910c9dee75ec083dc8cb4fc3246068f7aaf0b6e00fbd0e7639af5eb89aaa0120e502e70e79c3c0cf94a394e7a1b45ad91005022e667c32e255d9320993cb5a9e83af2e69ee205c7aab966ddd673dc03396cc2e646a62f77253b8ebe363ad32a19f5bde8a0dc6c9b20130d879543a54655385450d7b2a6e1fd222b9619b1afc346230e84ecdecb97508d27c999b0fd22dcc9bb5387678290e0fb051b0cc8aa07444777f5e66c4decef2c66f47e71770c41de0a47af8afe96c27cbf80eeab8a972af22902070e6c3ff9f80bf98832b1241ee1777122574285fdee5beb88241808435c038f323922ca1390c57f3d47820623e44a4563b3db7c440d8be737f86fbc156fedecb42a473331875b8366751cce3b61c503bf840bd2ddef7f7746291a41904d3c3e02b8bdf74fd54f059b8adb5d2d9c3bc4d840600a780bc3e5d7825b6357325e749646ff8572802a9c015e165c0e246927548da4ee16eb24d81704dd7b7662844893d4bfc9309f6156acecd50d6579d2adad8b9f8f6e2f275131c215d4c0749d2dfe2dc621742ff969c08a20f80d9466477cd5ae5210dfbce1ae4b1c144dda618306c89530be4070517ff3b3029854e6f02915c4dcf07f0be5557c778ef4ec3fb4397077206afd2f1c2810312469c4ae98bed5abe057652ed2e30e7781bcc3d8daf6f13a9393f8689c852a07b688ec9f183cf56c48787758f4e7621817156a4b6ef960cf8f01621463d05f8ce1c59787d08df73219b85019eed05384374518485084d41c5df35e9ab613a479336d9e334777f14ff65cbc8ef77fb7582816bf0dd502bf81892cc2457c913a705ba27785859b0eae50aebc723338d35a8f9af627f7397208a91adfa1be51f2570f5a6e427d29071650d340b2bf4a96bd2da6d1801b2ff2852cf4ae0be5935a4d977fc06076aaea5d1d81f9ac5ed19e1b767aa4aece8f4e65d01568d6decf5d215973100d3c6ccbb0a9f8c746430ff81e1a2aed0117f4f3304103846103d6b804868c885bc9f1152c7112af7f3ef45236da02cf2e83402953e61dd7492b1545a19d5dab691e7ca9ac1b0bdf35e58a165e79b2db573f76271b11d83eb0c3759c59dfc3326bdd79c074498ead287adb07fc206080b3cd08b37ba1ed753c7ff8b12dff6019b5a83a215e6acc261dbe987e608c5b4890c743c66a660fc89d9179b10d56a4db165a0a6ca3fb06f00aaead9940e195f340dbe0e7fdb85beeca31d05e9e815eec7bedfc9b3464b2adb13117662d50de1152f4b74591bf43b031885f9aa91733811b2818c9c382c6b87e09a9153f384b880a1aad1e29905d307c2d90fe5063fc67d968535f16c254b5b15870851ceeb7fe4fb61fea2188d9651c2804df481e5b37bd5a44945016c3bbc78bbc06c2418b9a1b745988111c741615d2593035e10653ae68de392e1e205214476db07b0f7fcb76bdd437927c2df3d043b75d7202ea80fde23a7e09b1133e34f6b8f37d97268cefc41e8e0f0184734d59bb16aad9e9c2c5e27fe44b959ae56b4c829b84800a8e2f6f78055c768c454811df4707da8409fffc4bb9fd2c33eba067793c7a4fc0563b78612e54b9a35e36481d71d571bc6934b8deeeb0ac75ae88752f2928d4b24edaef3a7e58775f6acc42034bf5c11c87d1c9b678400bf1f96416d83ca344ca78b784d856d05a5633e3df39126ed66e270af3f0f8a905bee7da18a93198c9db6bb550015b52924351656fbb199f5f1182ae6114cf69587b34ccb334af5c17480b1554f3f77ac798ccc242cb7265e4ca00e55db3813c919ea0de6bdb1d43511a04c4ed3dba549b53289fc79388db154b60a2cf02cc7f712158b0aa854153de23eda41eb318e221354d74de73b6f0b7ba95dbecf5a948d5fd86f9d31345b47b0f476034b1544eb8d42c13096c4ebb17eade550f2fce282a03afb16c97f3ee37eb16d2730830b39a1d0df6769828741e8cc2e14962b1358d6c3072a6d9a3e40a90a64e2f62db1debb7281e09ea344968e05609a5dbc2ed4bc469799202bc001649b834adca7a871d68219940c58b14f6fb5c70a2e9a1860879f1cdb4ed5fe22ba7a2c03f17b941016b959b2bfa5c2b6e57a7836736797556bdeaf6198177512eedcd4a99884b1bf4a69d1eb7549a12f3a84c20627da85f613ad28ab818c2a8165d6d1acca22a15f8fbff21dc3dcd297d8e4c7b2058d02cc7ef40c90aaf59d31cd77069cfa4f19b9d14dee03bc1caafe229e14f2ee79eb3cd668a6c1094cf49b94f7f69059f9555a703bd7377549f30e31e79f6f7d8ac628a7d25d317f687283a1b00b9ec9dbe4df572799edbe37b236f4cff23ab2b2e4f7b3a8e50bff452a1da3c0fe1a0d5d1806cfdde915aaa444815834ed551ae92809d8a99ace8e6a42824d4c5df249bec344ba5838a32dafd876bfb12b17a97e42dde102d0d75e206229866c58187919117e62a759596c2d6843d3ad1e736b4ee5ba3c05dc8195ea25b17b8fede255ce0d665136e5e4050abc7be24b6a35af54c079691069e03d33fc6ab4f0a6c31d2241921dc1030f46d9c3553cb90d45c99d40219336c0ed49b69a092906b75bd5eab87bbddcc19ed80fea5443b88a8deec2497da73e127eb6d6f716a2764d009d6df3ede39e826167b069a1e10b8828bfc292f6e098be8b6ca0a73f76c548361a5c570f3990c1584d89ec1c7040533efa7692ba0847007c89b38e758661b5d6a703e3f24335b040ae4924d1df08d82660cac2715068d4c5a608994f3eea661f5154f572f4d90ded96bc925ed85a68a01acf0993f62e178844df665a1ba3cf272a76245ceaa58df9af2f60a514057149746ea560f9313a7af6723558122219f51368d7d8979250a860e456af6db17dd9a2e814bd6346f45f12e7aa78a63ebcd91f9c39b452ea6a9fe825b8d40e05590eba9a577ce7c1fcc603cbe2b6938c192faf2320be0cd3872f57a4a0eeeca13f76472a0eaa45e484e04fa4f450d4f3f3bef9e8bab90fdf537f43a15c2ec606b408053de7a1d0e1595bee903ed4de60d6841da6b4a4390c2b8ea1c7d06fc9e6924609408a2f94caaee17cc0246b8c4a07bd9e8200609cfa88da5c49f03c08e3f223085692cb240f985a6d044274073857365f95b260ca19aac3ff5d7d9fe8d21b9990927baa5aef80adc4e1382c419c681617b950c2401334d3be5903296a03e8a0e17403a3cdd6432c093c8d5b66315f0c08f44f938b3315916913186f2cd3c10a03b546ccb4824deaa1318745eeb8597d2955ea619d3a9eb37543ec97e4cc7dcb234a578a57cc8df8f39fdc8974ad599c50d40b8df2fb3189e3d27224e27a0fdb125964d8ffa3a8e11372a3e8a88961d89df76c2da4805b590755eefe5a40ba8d1fa0e5a8037f8b296867bf15039472012d9d410bcef98939cec04c9f423a34f76b9d6ffcf13f4bde59e39ca25957d65619e7c86a148247fec18a84ff8b87099a0328b30413f7542543c32418b572d5f47c5f2331d8e5f07fc238590764d79d816968b335735a6b79aa563f6f07f0205358694c1bb8fc02b06b6ac32416a067a9785bca29515d59e2e9be627c0e3c5003022526706efd70c80ec716225bc3f5db191c763656f85b8d6cc6ff29e9b7063c40c20c853f5b0101d070d957d0eb914181dc46ccfaca3e758c3617387da5877519f6ed520dab7b99dedf6f86fb5bd3a29f4b46326184b9f0438b408bdad8694781bc0448914e019c48efb96cf60e7de9f778d133245ac845b549030a1ff1ed7992fef210ce39760643fcd9575ec7bb79d119a02bf38c8b19a14c800f6287bcbbec2280eabd7aeb04e6c06cb2a29eceb50277890918731bb60bebd36c2eb797fa3e50be9b0c10a51acd7819dbff2a2cbe5cba33af577730e6824afc1b110d02568e1b1f1361f40aad0f1c00aacd46e19f07779fcb2bb1f784b119816a77d964e123720f16cb371e59dacbdcca722c135a65e141e26ebf7a9ac28c24cbfb2a3604198a1705f4e5c005ddc16932efb74ebf49dfa8c7490288b9cd44a8bbedbb65eefb6d2069bfa8d04cfd27769a1b24d6d2246991f62eb5678e33f549693e411f79e735ee5d2074257fd872b2aa5c006a9e4074cd022b24547adfc1b4702fd20186359f18c7f4c8b7d69ead804c5d7dd026189bc9bb2bf030b80b7374e5c7c142b61ed38df28fb83c3dd794e0b73290b091ff3ae1b60dd7e484d5d797edf191238e418c3e6b8386e6b3f44748a1388dd17c12fe4b47fc36794de19b23df60d53e8e821cc55dc07acdca816c46891b9df6f48b1db8089c20ed75dd76c13a336cd4ed9e69331a6d22888562cfb64f542b593254b66ca4933d51902369e9a4d33281d2ca38aca653a2d52f6a126f406b5009523cde1e63106bd38089bd18c77d36d94362e92ed852c1e938ae36d6cedcc8daef780c904c515d1777ac417d65368631bbe58b2924850dba33e1d6c046b7f0db78d9a77e8645cf8a1126d6218edac9ca7565c7948227c9abdbd5145cf8b9168cb7d1e16c180135691879ed331daf5bd7773748f6484f6cf64af60750ba4a2dd9f2bb9ead7351860e12582feb01bdbc015dfd11f97c81672bb32509f3fb496485d953bf3300b29263e11ffaa92b2ccde0410e250c35d83ef23935e3eb8a4779229c6f46396b591c32ac25a97dac44590aaa7822b96864ae43f58cac34c42e600ab184f922cbd386a2d21dc0187b2ee13782fcddc68f3145b979bb965688b0fb124628a9e614e4b215f712f7371d576feabc78878fda125deba93c90c55d4c511c6148450fc22cc6ae1c435a934226d807df7c234ef257636bd90746b8b91f67e1dc65c2746e2f0f54734581e5f0220a8324032fdd1bf4cc268c9ee71178ce4dbb4813ca882ecd305e5b6ccce14258f0614b4aea96bac01ab42b14f4b379f25be011036cc6a85dcd63f38623046eaaa2eb9235fda51b4e7be0b2eb2ec1b8985add597a3bd7bb9a4275657b675048bca9974df7afbdc72f7eec756b32d5cd212ce506e0ddbdd01c510ee7c3ff5ab8dd408c66a52d540419698b630ab81051fe913c613562b911f26fae716c91117f7415e8a86702059a84b5a626e442755c9fca38a7b0e764678e60fac76fe6c862c08240a9b1be6eee2f5d354c36d939e2e9aeba34f3d32edd0812744e16e60541c0a06e720bdfef200fe8c88be916abb231b79642d26bc6883d16bd6d84bffb17b728323d78463e38438f91655bc99e9ad483cf3d195d6a7328bce1b0c67fabb2770aae6056655e36a40881fabe6311444a44706b48f3c16cf28603520cb193191a0812f83ee2041d994b4bf243168ae2412143eb6b4eae1dd06cd41be8e2e84dcb5bc68e6703bbaae2a7956c035f4f0f7931b7c514af7adcd4d1ee7a7664feb44ae34ca509b1d648df8eb4fb7340a78093157ffeff2799eb26e2d6900fcafbf50dc0f701e18679673684d35e04d17794d106a7653d41e3c9665fec1e8a486c144753dd8832b5d14f257bc542909ddc12a833fe347bf932bc7a0c1f9c47d5a597b016d7970fa2d918360cf39443be05bd80ac23a27d7e0cc1f715484c1c474110e962ea09e01486a37886407d04b36f8e16ce0b8f38d2be1208bd2c49e95794ffde98adab189159f04c04cf57d30d38d5a821296c1adfc36241c0f59ad0ebf476311421fb9ae26d19225061c39cec2e39f725fd600408d90b9ebfb7669c9136767edcc5e6b5ca764137ac171d85b0ade864d360b16f46ffb34717bd8e566f0fed8f7073332b0fd8d6a98c0ac803a9aa2ef1ac0955713dbba5c50c8d017ff0a440f5c7bf21715d4650cf221a93f0998e95893746a136aec33706d8a95994f0cbcd90887e47d906ca60eaa8d4ce474dd0ca28eaab2299261ba84b38730d7b6690710456833b85ddaffa5cf468b97f3ef2160a1f147095e86177cce4921f1fcbd24ac9a7ce190fad4e557cc27f6d967766299618da938e46e4bc7327b9fa5200c220a540ef3e8ff5d0582ca24f77c09378811b73bb43409f075ffa85a4a96c6a65e81dfedb069be9425f15533ed09f6d2df723e0f2a896d38d29dbcf5e99bf4754d207d323439f352ff3969ae8883e9f771f2caeed9ad16243268ff3c09b67f028049ce6791dcdec5c4b0b275759e0be935c13a139a538faf7d8ff1cb8a280bc64b40265f5ee2a86015064ac3f36b419db51dcb15c2f0e0b798a4dd84205af3612b0c10845a3fb72eff5f793a8b4eb8b80153acbf3a7272065b8979e2c879fe6bd6aad4aab87c9631c1a935fddc2a2161c3ce39c79318497ca063ef22340538242231eee52bb909de16cfe55c96ad6a96be0b1f03dbf83c045ffee3cea738ccd4ed6934346ac970c5882d3127e1163524a3c2f137644e832a7c7b7be247e6c08b646a23572952be3bf7f57b03c1aaa666e409c5cf8a2314e3168755b1e593f7b2f5a943e6449c909fbf37772f346ccd3b895c626112851e119f0cd3f2099828b0410f10af0cd42f8ff4fe1eb834994cb35715af0ec7175f8e73bcb6ab18bd14875529635db4cc0d99282956c266ffe5fcd7d9e500dfffd6c27046e9e2a60b2057c2cc30d502637a001a49c7b244442799aaf0b4eb7a61eec912f198c8e52bb0aa136b7881727829b6a93b24973a8425797381d169e48db2fee4df8cf99db5140ee0b86ed5e8d0a73e4ff9e0f893857da526e37c7c799e39021b009075b38dbb590fb1e21def858bc3af09e64bbaa8d6fa151f5c695b8152c0ba8a2ad28af734b843d3ed172a510885470035489c9d128285245745236b425c515919f41f21e346c02907e8c059b12ac4fb5ac0032a36fb2e587cc589d1d56e3270d61b44fda22f8fa596d3381f3fa02a1dde2e909409ed032ec9194b0d67a5c88c2e4b8e6ca4d4a319dd43424003965b2723440993822f72bbc35178fa439bb54b9079443f3ef730f4f7237408c9f25e5158b04a30e3acc7de2e33aaaad6356a7806a91988d4feff04620a29d70aa4b6f27e7eded64c3015db01a6e15026de3e1b3b755df67aa6f059c75932f5f7d66990d62c827a0f37bfabd17cdcce67bb7a04f3ee6e39d7b4187fc1eb3fd3d29561a3223c5e62fc25b86f84ca6a1423bc749852223a615b6e244ed687768c71cf2f380e9b0aa839ee3f23f08274fa2b20cf8e7b68f4506f6818567ae33029463f1a90eecf53c3bcc6400c306cb90a36b19dad2596945663ccf3ce4b3769b807ddd8092cc9c6458eb0df6f4e2542f73637a42d4c958174a5fb7a829733cc232d48af25c1e6e4cc41054dca608c67a22b2cc3104e8ce05510f5c8dc00334b1f0477d99d097259cf035585cbbcf652543239bfbcf7fd6c44730ceeb030bdaee0659e25afd4e3a095d56e42b7a5d7920da813120ebf6ee3427831cf8038588dd273daa94bd87270d7dfad2e0a132a4c76e9ae729e0a275668f13f674e20710a61870e5f6c1ef9c4d23f8c6ba8e910862d4b611346233e8ff3976cd2724c42d4cfc94b7b893b3ee0eb52a573fa3ecc255cee5896602379bc68b9c34980a30ac26f3d8a3d941d93cd74c9d56691","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
