<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2a61de40fae4e0ffe3763db5a198396adc24c00aaa83301fd17d91e27fd79fa5b9d0a3a3947c043ee36682ea1bd1903b201f9b63486a0cedee2c476e27ad28baa9f102ff4d3b94aea78dbb7c42d2dc487867fb5ea41b759c54eb667d3eca699a729817c77fcdf5d6aba729219ef9c4701d207eb4b1d44cfeb28670ed3b7d92a0158a5b2ecd4fb42c61d6309a1ae5c84e08c3fd23cdb27cb673d4b0a1a799d00709a20e923f33f6bc6fc6d1049bff2a5ff39d54b2f48e963bb101d461cb9841046079775ac8114b17c9133347928ee7f7914a1fbd503bd18171dbd5c62982b7592bbecf83b5acaa972127e66830c1df278b070003e9582b2828264d26951a4db7108172dea75fabffe458a9867c7ede9f5e78fb393987d3b214941037d59ab2b1b8d1ba82023713d899c74b169d6d1625f324472f5b9095df9a36b3289a030fd852251530aafc82272a3f79f15bdbf742aec29c0803a9a4803ef98fa08e35a91a255aab3f4d6728d98a96f2d6ace0958497a1d4b7c1f5d204070a71ced65113a2a46e4f4a00f4971231b5781e6bbc4db63f31806c845e09ebca2c7d68d27c91ecaebe4ec814869e5efbc08b81fbc2779ad55a0886649dacbe234146f95341a6f4ed0fb773a6547f58b756bf6eb5a579881950a93534a3a93c75a2b7488e84393a28a72cceda73ed9265212521875f38f0c27d4f26f47a0509aa561f1a1dcab943afae4dfab22c94f1f9ac39958095ae78f52543af74f3fd0be1ad4a02237d956ac2d7206da41ff30beb46884b912e71b7c4dbe91432ed2d8ff4b51029fc0fef3eb208fea5122111c344c3d201238dc1d6f6ce89081a40df87e8a578ae99a152c54a947030c037d7b9fb93d79ce25f455d2d10222cbbde410afc70e774bbd296682c9ba5e9326d50a38f4d8eb5d5557ced12cc5107a63f304e67adbbfccf9b4b6fb839890a6c3a263d23d365e810f7c2630f6c2c804462d8a5f9187f48fe92718d559bfb577396114f40de78c72e466e988c978cd167759d68a8969099205fea1d3a2b6000522fe6f3b12ac927a3526f874afbd235837f67d3380be1030a9362cae395875cc6a0d2bbf91fce6e6f8bddf8816dadef84e56790dbab9cc6a5c9890323e055832ce489e88e05712576ca4eb9dccaad929969bb306d72d4226d2df54f07849795a815be8ab6b73c2a6e2e43005a121063aa46f8d864f40ddab055591d7ba514eb6e164d8db1600d223990a780ceccd988410bfb615b5f2a5af015e2a3c3bcfd322bc0cad58e16e7514b9ec54ba1328ac47bc5fc6b2486a3a0ae52d998e5e88c638aa2b75acccf09c79bb2ca8e1c994958c225db17d2e7f319ce286ce071d2fb35ce5b13dca44e7e19699ff888a2d5ec223530ecea10c698abf15b355596c397358184c4cde0b97f76854b1569b83b0da897f4f5f0fc293b4cbf2a61ddb394ee271823ca67ee872196e6707c0013291108deac23bdd6b21919225d351a47f68405c7f827cd8cc0c29b0377717a9d45090156689d8d4c580ed68d6aac0176054dd6b4890ac602b14b16d5647884729e14e8ca2507f1679550ce653132997b790400ee1d107e2524c940adc8adf918da88ee8e4c78bc5f8603c3088e293003a7d691620c1f8823a6bd72754eb6f028800b22d6198554f4ba9eab2fd783a743dd2a61b52895f7c2ab1b968d5a0072c1189df9a6ef1c3108821b99a34a359f1c88202fce55fd3b620be0030ca8ca65819226647bdf6501b83821d5e61bb4051ee62f2b54f3ca5633c0b4c55698e4b55606285001f54e19946f34e8aa07f54766c81215053b5f5f213d375e8918877b93be9d38f5b0957f379fd97cf71461b95328b27452659d1667893410197f5c775ec70a604d94358f3a02bd2e4ff95145e5d56b9958960b69d649d074f9289dc7fb8872c3a3e528256ed113ccce57e5f4eda2ccca2eff8bfac8c4ca9b5fac9e472a422a7c18fed4fc8c47f35a8b90d55d738f63c5e1a178f6f814b4645b77a446a38cb1b52e9a4a5ef5b5f76556865a02a18469e63d6fc4671e154dea7742a0fb765554c0272d94df47e60f2e67f5869edd5861a122ca75856bb361f267c023dd0cd568d980da8339fe4162c2b6e00f846abf18c797bc08e25f455410c7d1473f7fad930efab570bde03674dca87f0f2e7742360107829f2a4e1dc1562cc42f39f7551c8c3570d6c21744fa923914b82dfcbfd1aae26fc1627f93a7e7e47d0315ccfb13e7dc0f66e45ad377b46e6107b5180463e6e1e0176a776602d570e0a8c8ce71142c9ef9599498043d563c9b4011b2db0304484f5f6d02293b311499e3dac741f732c14f1c90bcba71f22888893fead973648940b78d1ddbf60eea6475d789271b40c9bc371f975987a730be5604b9f9dfdb8d6834546632123d04bc4361b49fe1f8f539f24d99aa2e57fb98d210073bf17e00a006dbc126b0dd559761ee2b7be72ca9847bc522874116f8b5022ffea25cacb236a904efc8c23afb91461bd4465ccf2ede8688cf95df032be127435a3c07c8a8dde59657d6c79a10c69df069037e1afe5c401b23a189c5011a3ef5fe99a112498ec3c71107950f27bd4afed44a828f44ec54e18f0c40e02f9ebc64d6c3c8efe6c72e89a37f0ed7c34eb06ec8dafed7d981da82004b7a0eb1c07175f8c41adefa43d337116265416f4f1dfb9d22b0ed26bd93eb5c5251a236386514f5b573436d087b5d079910481acb433b89822ebbf06e516119c5d98eaf0b65a526b4bbf94e9c818e93f5fb8207ea2aa2acd4f816efb0c8aaffb794113f4ca5937382deea47fdcacb14187c2f3cd9266909a447e61c6e3fe900ea004030fcf6b41bd1cff64c96d4d166941c57fea0620926d329a6713cfe2b053f8e87bf7b0f7106631b6d88f795facc47e5d3ef345e115450d11d09aa154b3f642dd0ff7d9a3d3a1c151bdd10382c81872109fdfe3f35078c3b1af9472bde5f2c12bc96779373248ea9a294e61774ffd0de44091d324f98293042a5ba529be482009525710af2cc5f2287453f8a31a9808a876de63752468a89925e00da10300d7c9b5bf89e8db568f83b5e4e0ba659e0d11d03580dfcbc0aa335a3a9efbd4fe029d282caa12a5bfdc078e6c10b6962059202d01192276fb47f5d2fd2df2dd60e9ccd433905eb0fdf2bf1c509b29668c25d8b03b85fae98bda614d352472e01471a9efe22f5cbef21ad552b13b9ae732699f652639effa05afd12cbb1a8800c757f5f56613ea49067380030918a37521e9534beaf7a1c5aa6c0ccc15e8531913274f836bb2dbaa778b598c073c32d364c718a5bef2125a9af64fcde86cbe5b635e6a921366f98909b492bf7a948bc134980da29f0dda848495f7c679154efbbc2e881d7ff3593b9df185e335602231067276830b6f8b1dcdbd260b6d935619b100ccdc27fc8388fa1c46f2c9c4bc5f621ac27f3891be4771b6d0f017579e6f85f48e67c4c8315a1eb65c579f589571b357402eabf2f3d3ff03fa805638c4349e07e42f18e03ac0e5d62ef5fc99bdb1102ec147d74ab6c72987ed68a4fcc0b63d908e9cd1f3cb97255cfb47f54ec7f5def82384373d4e5ef8820bf0d44629f99d9ca929969fa5659b7710c33100f27e75ca16a2b8a93c046d3383691d9ff90fa7b3f0a6aa85dca52b118491b45d9974a1a93e4e076af365dbdf607a4ebea5aa029dafc0ece3e6e4c4ee9c57685d96e26b6635aa627e3f5dc0bda1b6c206c699cb3a1e1db6b4a6c10a47de2ceaea42aa76d321ef25a9a4078eccaa67964f8779e2397bba001a3d5d9330e0e19431a09363455bd9b20342498cdb5311721e76f3fcda1b8f9d872267c03b698e8cd773b293639c6ab45af7a70a3ee7fcd8b56c8c76ab68b41d95dc359db939ef6df690a98fa08d255bf78336df3cc5302559c082433d066359d6c8a28e58f164c10f3d81aa7e489bbd49142b8f01e7f86fde213735032a1f22683878da9390096bf27343cbe406a009ec7df793ec9c57de8cbbc38c7982d15a24bf84d188e7be2b17a583b4e8360f95d3399c76f4785474bedb076837b60b5b62a0595503df9557b502f79f6f6d027925e0bda392ee8e34ec76f994c1edb6a8cdd527fb9b04082419462b714d3c1cc584cb7372fc606309bf4c67624ef23a27daaa0d990293df0103e60bd96c18b0c9a156de63c71f3479330bc91ef5103d9e9ae00def53fa3380c89e94873c24e14f0a284d2d9b3f3e60d9c355cfb73d2ecbd6efd1da6cc273bc05589ac59af6135e2919ae514143ceff960eb1541e0b134cb84eb205a0ea5b7f5362f64f2b6ebb08453fa14cd24e6b5f13d12d29dc87c1aac862aa22281e6371f7a1b127bef54fe14ec8b6b92ca23114fe5aa3b7776a0f54e11a1e7ab24788a7192aa987ff0ab3f9ab7a85beecfd12aa1e1082712f61b6a99db2f4c9d2e89bad1a2da61f3f4269e69fa43e24d374a5fad1259cd52e7a5d58287752e0bbf65e3d427aa7165675551d2ae3b487f68c9635362e986543683b12229859f91f5c1f5992071791b84ca5bc878ff31ac25d4a7208766fb8f6b512c19230e4017c7feb6fa7d1e5f6d3ef39ef30aa788786053455a409531d60d8923cf98296ffee12fa70d7fa559d8622e115c191c603b280371553e6a8b1144a38617f5ec4be6fce35ee3ba6edb80547ec94400cdc8c7ec9d8e14e63ca2f78b9a488e2ca47b22126384174ed4e18c3b3a8caadebe64f994a04154e0c8ae049c09281dcb89a2c5fc0634c3f3efadb378414a74af9bdd73f4263ed65864c22ed03533f3d3675a8c4ee0a4e2acf6236ae351f865449136288e7c196dcfb6d78aafaeb812de9aba9ab6d593f885fd5ac5ed93376a983ac10f20a59fb226ec5c6bc8ad2bda53f95eb625e2e166bee52ea785798b8e2648f15cda39d914fe42cfa8ffbceaa014c49ca0462df5a669320424f7ee1ae820cb515857fb3e2255135979b6c961965785ba4fb143c9562d233441775ff08e8d2cb5505872b013f54cfa03f9a05da41565df5a3b6c8c962ddc1a0963610f7136e7942056d2212b5f4c7adf8be77c354c0b8990831395c31d06b0b0dc64524b2e46b8e121670866e968e8cc59005c6e47fe8aef594387b68a7649995fe802a2f1f0c8ee7078eb055d08a12db62c7d6efb7f57cec3463c3ed12805ed419b72420b9bfb5a52999d3638f7dcaff116dd2ddfd38daccff753a15f03111846be9a7f409a25bc310496f1d8c87227385161b744a3361184f8f07e78b9b35ff52afacf049d5d0c424d64ea07a05a0c3e425d02d89ee4702f54a1633cf853c6e773799a3aeca603172b730343a63ac9c7dbcf7ead3f0b5ec7d4542aab651cfb1e502d99974356fc21649de10eda22be071dc5ff56714a4538cb30b1621ca017ad25e83b4864557baa59034ca1aa99cf4ee0d3541af5afd25fb9fb5b2281e57a0075a1dce6a0abc46c9166b00fc2c43535a18a07aa8a30afa9aeb370cbfb3fa6e24e300f35053a5b9eb76bf58b671af79c3eaa35d140c0b39804680c395b5a29f4dd4b860e85475358e922aa2c97872c32cfbfe8cf73a8028133b0f2084d3b8bcf1c9fd452567aa3c15ba253a685cb97aa14f539a257d19113f318c0180431ef38e06cee22ade62b8db85a7f810562cf2d8d5aae1b9d35cd1b96dacfa2d67fc6e9882ed748579ccc6be3b30353fbde4687b7e735e23fcc9039478b2c49872d709b245885ec7a14cf13dbba7e4e38606e921b5532a4db571ef72881a645d34decce51645a58864e6bd7214b91e025bb6117153e67c2c5bd8061f904c22b99bc086e656123e23fbd7d7277687781928b669fbd164109a976254d78217079216264164d91743ff156c2a01b219ee68a7af4fa5d7ea8f36bda3df583cd62022fe2a064fd30f1c979713bf7c51439c581a275571cb41f54adc37da7017759a8b09a0906e512125dcf7d81b29a881d818d509c8e7cd0be650a4935bd88d2260ed53f5bc212308897879aedfd2de8b61506935290ea33681a7da3b8d6c959ce45a9f224c051084b8c7b9c841d575ff14b81e25ce120b7f9b966c00c48080374381cc42fd6db13dbf5032af5cdb199d4faa98b9d1cde830724240c989e23facd7bbe42d1b063b54638f50ee216f02dd8c46a458fc9161496c90c8a08032584adfff3e2d085f47c929c1114f7b460028f41b805a6a11f3948c4030d81d420298aa3ffd21f834e6e052ecb4fb826f9637f82b8778b925c0687fa70f97ed823c8eb2fd70397d0c1e4f28f739e3918852146b139d916fa5350e86a0049f4793dbdfd1f7e7c3fdb1cec3fd7a4953de112713340823c460cdace05ce23a72de4af74ac218a0eb394de5f9f603a25121417508c3992071c27b3f002c69be5500b4d6011a0463447e64ab618bc0e121baeb8ff4a0b222e15f9d12365cd5cc606d57d91554cb8ff57374a035df80f44069b686938ac50eb6d9ea9a5c32254c473d1a4ed4523ccafc526569690d373e6e9696ef2fb9fbd7151f27145d7f8e315bd13b8603e43bdc1acb89e98344f78e7abc6818efc6ec4e832de1c23dbc495ac7672732af608c43804a87b66d3b9a9f76d0638804dc16f7990728ff2632582f4f20fa705469116bdb2e2c60da3d2d23c9d17e0835fd98c6d94621d641a2a944113e35b21d79f4734baca02959c8ec4528695bcb12b620f553f42ba91edbae8ca250829360c4d6f3a3dc82d7fa16d416f20008384cfa4830b82389725dc7df8d41d515c09c79682ef4b0d2a877116128c9f8ef9490fb866a95af025473982d106e1d35859313766d453feeae0d5e786497e32020d2ffa117f87c874e7cfc698d6b492d199ddd5309a7858388ce9b272031a4bd206413a62d0a885b313bd70256fd1d5ba8ea03a12dc9e108e25415336ae0bff839631070b68c65a7d783e2b1f13b182e988240e37d3a30b796f49fb0590510c7508502b07a56cf8015e0eb8ebdbfe2144fcbdc9549e6b0eed53ecbc4e77f35f640a2087c07600fa88b1bffb57addaa8a811617d49c18f87f2eec350fefd828fce7427c717cc2a3fa77bc87b23dae4c44cf22a14de84a1b04a65df560cc1fb7182303f25741e7cee42b5a01c282a144913171f32506d68ded2d64e61d77675b704d885f12525009d1e7a692bbaed5b3dffc2ffd448f6db2425429b81305789259c3a35ded0eed51dc2acd447d786cb98d2e0e1dda10baf83ac66d23fa4c896e1edc7573be70068fa29c2d0f17b290cb9ae28b4adaaecafe18641716f629680102a7a2fb165334b7635f16324b9c62f3063e3f09a5e1ef5cfe156f329db578bb3d8017a7129cc3ed36d19252ac5f17044512e274393f38b44f3a7060bbf8cd922d4cfc5e08db0e4b333d969020aa2532f992cb55d74665eea5f6844d5890595763590047d35817a760729952fdb94b6b52e16e48aa5ac99963a4490a5a62355e6f3d7ca4da2e883ddd3b6ff7e9009b94864f041edeca445d4b38ba7ddb27b05b98d7d710a522e68c4c0478dbd4e7cf1bcdd7b6fdd1d6594aedc9d3480a3ccad2992d3492e7567880509dc44cae604106ad57a042ddfbd99208a026c2cfe0d663e61a5b42940ccc17b0931156e0248cf19a18ccc8ad760404f7099e5acf99c60cabd9c1eddda5127981cbb6f10bef248cedb4c654192c37b266cd7c5fb2d4b1b5bdd225bc1fb7920a502db33f178067684ee1b8d0e3903ebef46fd3a989b58b72b3717ca0155f4c01a23e7ddeaff7b1effc2537e9d22f359654c75ac817ffc502831e7998ed2f5a163abbf489e15b2ab4d000f6936402a42780541bf3cac1e6c6f18f54846dd0554f18df021da5d5149e31057ad2be07e2f67d81e785aaff4caf9b9d9288f24c4c7074875aaa540ee607512d6b8d25c51055884694b03ea92d8f00c000979f37bd188f67da0143b6b497275cba2040f8a5b53267efd61921bf432f4f84c7b9e56fa230886fb9f84f0d9df633d0e9318595488cb52974596af4ad5443989fec65c117a435415cb21718cddd31aa0e6935f5e10d65f5504d555356c2e20129e6a8d96af5781e0521156bddd650765d4513328d734d29f3d51921e4de34ce61f2e570e7193d5dbafc6b2a20162aca0dcf9b26137a5e3affe3ff51b2163ed99782a0b91449397158fe5d81748cfa43796422e96af9e3d2dc6a5d3f6bd6712c97e7a385daac3b0632aacc18766c93d65b7fddaf7d6e19bfcf4cacb40070c465749ab60139c0bcd62dcd38053692a6d037aee2cdb01db6a456bf2960e36c448a19d3e3dee298851d5aab275387bf12be7d7058813ad285feb934025a851202d7520dcc2d6ecbdc2976482a4d12091a3fa109f174d5fca5b82140cc44cd9a37cb360331c96c1e23eacf0aecbd91475ec7cec4c5d1bee909a0a3833367bc296f371966e40e9b4fda7a1d3af696c73b117c34db56cd6d968c80e6e8fd48a2ab1dfa2a7afde95a35a6adf475520f2cc41a273cbe4b764daaba9533280f621af91499dbacbabf4a9e4f0608098a56e5d9fffd817111952e6001208f58b460db815f491bb3e948fd1826e4c7e7dbf858d1eec4217d9f2bfbf774673e1141e93b6e53aeef569b4209de1b0aba6e9afd210d93b4829ac1ff39ca2cef32b4a4b4d67dac6fc0623e1816bb8f6c7bd21e142729043f9796b79a1185d1fc59d5a74b1cf725d27e22a62a1bb6cb505ed4f3037270f63852a4cbad502fa6ed2ce77794d52430d6ddb3f38c7ee3ca9f2105c94ff768c76d0fbb05d9e4ccb70dc2e3cc9bb4be4ffe33ad411ebd90c663821c875fa5fb9bb4885703a9e338baa35b2a8dbcd690dc33e420063a60a46556ef8a7d77f9f681c3fd3c41761af0813801bec8d7e48cddebca0def4196cb1ffa5080c3408a8ca8913da99a1a933acd2c3d629b80150872e8bd2b844c7a0a20d9ad1523d9be9af985f23d92df85623191673f31de199eefd4b5d2fab9e5a241f9e060a4bcbd9e590920b57074261e1118014e8cdb1d07a0a305d6b849230671318c6ff2e4728792fdc838a9d42a3ceab1586378284780836f3f761f04b26d7b38edfaf0c8370253e253094c76134b4101f375f7bd4e9188fb1d30797ffc0d10d9e5da8a31d14b5c7b3a873c4820797be759e2c52b81e6f5828258b542ae24c296998a6d3166bf687631daecc7d3850498d799e8dee79121f1410ae9d6b305f4fdb9511a626d62b9a74f2acc1c0f2e2741a42691f06aadb8204080e0bfb29eac0006268651566f9cb180ed3c3943a4497c650075d1dd8bab63443c264ac5471fde7aae22e926fa304a1e397e3aaa0ab083e441823c0d75803e35fed820f8fb7058af4c38fe5d2e2d45070aef6c1a6ef6be6a32ba4cb176d55a3fb692b1f3f7f7af7672bc35c0d951aaee968d4ab9d43bfcde73840f4d6315b3478564ec41d85ba4f745a0e3a4c3a05ca00667947fc9ba22e183c092048190f25c29fc27c63ac2a1e9dba48a16fe3625aaee9237adb0af3c16a03b4574c432b48aea273f65a41bf25877f3affcff72ae93a00b7f187207e1bb7d4baa9968e8875cbffb6b3e63c9c5d6f888e388bb1cdaf328577ade3df9927652759788c4b25c03a29c0d94dacc0516db9c47c9a9f65ff4848e16d90212504c50dc9d321a3992be275fa7fd51cd1176eed9dabf447bcfb1f5be93f1ea0b9e3d7d2a4ccab90ddfccaf7bb2040208fda2a033ed97a047c5b45c023668da54459dc258bdaf60efd9538f74cf4a8f80647f71cf1445f51d56aefd7d49a683c933016bac20cc1cbdeb788fcc6e1b1765527999ca7a3ef54d9d50758711ae7e360d6f8241db5a6e8eb750fee98bc627bdc7c66009c552da15aaf87875e9df49f3454a62b57fc3d36576e49655b513677a6821c192526ae561c01273b8c3987368f9ec0e16f6065170b3e37a63a2e15f7aace043081a77f7ed4e36ce629a838b22449c8b6096595680426dd8bee0f61248c6b79f7b9c45b46de6d16f907753f6c6e0502b5e1acc392774aeca6f73e53036676453023995c863e070fa330b699e50acafa14db1cf39a6f3010a8c9be128420cf409e6bea251df18b1de6e2e97f4c4bf0e2e975ad5bb539e6caf54195982a121f5b8efdf65dab9c38a24c69c93c51d17980708a6260fa739c385a8c35c224fb5204b28278a898d7dfe92c491a0f8b3fbe5fe9938428058aeef82b90957ae98189cb1f05f3d6a255d357ce61c645258718f1d47f017a6c847db53288029102ebabad210c3ff9694b874d23ad7ff7e7a846b2810bbe3ba8ec03ae71e3ef0e30cccce22836a45d86dc9961cb4bd6a1e66a7b6e3d7d5ada0cea91b864328bc4e450d19fbb46414178c1dfe7da0140d99826c7fcf7da7ed1ce9c9607fc29d373ae8e89fbd926c20befb3bd752f924c5d09678d47dc79580e2af13c5da22d5d1a12894c2cae3ec897d881ce470d5edb8eb4f7c63b2d28b5c5609b4db6553538ade18557ad9d2dedfeaa1b3bc1672cd042dc0b9c0b3af049cce7c89d3af9e64a2f431c6120728bdaf2b4f94668250b74f95edd28f6ea7fee8902caab5f26b0a947ae9a3866b2e4d0f613283ac18c63faadc4a0c8f88e538b20d2d0b0ce2dc5d09963d26da80f8ac61507468ce8e5fab321cb4085eb055b2146bd24d09279d2c030844f023c7bb049a9b0bc363054d83450e2ba061a963e24b84a8bef360fac8667489844c5ff42d547cddc5cf9f313518144c998607fb3bb7d8b2b1769ca0c5f5084de564e77299d640154f1186f3d56067945738a31309ec0726f1f1451bac72c528f82a18def407420b74acaf6cd01e11000818b2a62f543dc733b6d13c933366380dbe3e7da8cdff120bf8da960db04a2052a7b3d83b4a41a5b4c17196c8b519691a29463e12c23ac2d9036b583ffe891d33439fa5b9d2c397bd8ed0595f7a887c1542b4754f568022b9861f9c23af9cf48ccb65a83710a64da0d05de25ab7b6bea930d572fa7681ef4317fda0463f9a3a39c8a50de6aa25abcfec2988737d2c620f76e1f3eaac1047b8b95f72fcbb4ffb3c1828fa59f35927670336b3afc71d62723f5f211c7f2c01c740ed2be52e25001ab497cd476e60a975ab35de9b859cd8d482ba72c15f1ab9dcccb72cd88419ba5723088dc7ca795c1450e01ce9a5dcc2d7103cdc60786c7ca95e443c78f37bd2c5eb9191fd329da37aebdaacb73bf3800b151265b19b61fa694760e339440a41e3b9cd4e4998f1574077f858cd2f966f1477eb18877a93c607326dcc784dc547ae58851acc1bfbe6528a21bfa99dcb2d25ef6a8c373526a15b6f4d73ab9e7b6c83c3c158381f1310d2c76dd6edfab66101c6439b7d7b030f5c56b88331b9076fe6e14953edeafc3980c32d0cddab079a22fa9e61b09e7aae9aadedf4da7521faac99a590cfc9e2830f5ef7fb4acafa2a2c0ad66507e74ca3858d315d02e06803acf42615d0e3216b0f8b2cf90da09d43bd1439c8e80e247e6adb189b9a6cdcd4f16a714babdcbcebe917cd8191d8a9f6c11459e39a33eb5ae2b8d949acf79b63459c5ad889d15cef765ebc0ba6acc6936cb5982b1ecf4b7ae49f11385297d1867f51e1bb0c23de6fb535e34aa5e6c693b0db0dfd3f00c7424f88e4d9e916a567b9f712f226dbf94a8d40b9f5c9924e3377fee237aa0e08d6b5ba9f80f9c0d584b872d00b0aacf66e7878b3ae4cc993854c11c55b6cc1015fe13953c605824a67d71797dfdd786dc9005de078b1e9f6a826fda17818b2835c82f767f3048dd132692b48b48a31d82a0f18f66e337e45ecea6b55a99211b4a0969134aad77e3ff73d6e0ad3371a5ca8740250d09d90d7e21e504d9b9c5236fdac7d198d3f3bb40fccb14fe76e80c56e338fe46578307ea8b09ca4701a92a0519fb55da4161c71bda58d57f42c0138d787ab63cf4b3cbb6c2b31f5833af180332e0221bcf57afb076752872f28a62d1a58bd160a215aedc76711edf1516794df561db71059ac1e30bdc34adefae0a4ac09673a61744e54ca49d71ce616e61b8e21b8f371f46de2bd1244d6cee700c18a4916bf2086bb540dcda9573775d0fc015ce58e6813eec154ef4bb76e3982bff767ae637e5947b78da3074bec0b906d928197d4819cabd7854df39efdf3fa2522ba8bf23bcd1f20604983f9b05c3075722cfe19b185e544a7a1d3c2d8696c66ae0477bb447443819d0559e464153545181358c3b505d1c9e47beaf719e1ab78f02df1610376f5339bb7010b67a19114ffadbf9f7474983a998428ee7b8fd2a5b21e3cba0bf973efb197029832b43e5fdd3841a551bc6603a933fcffc3a4397e786725a88169fe8a4708d9943f14b915d789eecf64fd574c34e915824995eeeae5c78c3d8136791b2a2839bb2221cc76a195d5b7e4fa1c5d2dd72ca4f8ea7ecd101f303e3ba869dfce13bd619f1071e516ad26d7251daa8ce702b260ccc991f933ce0956900933fbaf9fe6a3c97d586282ef95c7328e8eb5553c2def0a1ea2824137dccd20c909e9069fdeef2091d9c012a13998dd0d8fd4d64c46e938e90c3fffb8d5ed00fc54648cd4109fec3f904939ae1b71697ebd8684e5be010d3280d1d456351c7ad3aca83882c8f6962c16fde493d9c7d6d5c97d5dd23fb037d1b6012067c90ee0ff6d853544ecd97bdd01f6e6d6debca1c2bdf8d2b5d16727aa52892bc97b00b8fe4924e8b5b645ceed899b8d02781c407bee31a604ab7f0c172dbc885e50da7aa7fa2edb4356bd2b5570d6c4362f5c89e09a710d93237da586658f816db0df147dbed581c2562df418f86ced16f7053046de13aa514b815d01022cdf57e114f29ca9e6b10522336087bee28e5c16e86690a00a635402c3a09969e8a53963759d87778e6bd67a756464efbac6ccb8e26909becc591eb6fd90352ff1894dace5c630b2d4266c8379c3cdca8bf31e3aa2a74187c2ea579a0a45111131d9289462efb918a306b085480","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
