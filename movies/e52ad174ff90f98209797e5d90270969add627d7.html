<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a564f28027fba2bca27e285af9583bcee770abe9316efba2ab176cbb4093434be05bd36e3a5b80f7bb054e4de964f9e40a516b2d171ce19004b270d51e5edc6566e209b984ec2199473b5c28b4c776a3ff7010053c48199bdbe28cbab50245c61c2a7bc0bb29dbc6b17a37bac2b4ce2eeb07270f54799572caeb0081ac68e6f32518ea53ea28229af561531d46a9880eed642fe71d2b761e2fe62a3419bc6df392dc218e3891585ac002da64567e3d333e731c4c0dbff4735b1b0be5b2de5431da5b1b77aa3731406d7674def4bd4db0bac364e351ff3a614782c090ee04bba29e0360cb71199fc49cc0e2418c31befe55d711ec6991558fbbdf06f0a4ee3a713b2ae86bc2a69ff1311625cbd356702cf654f4c5b391f3872418be86ee79af5a6090f0c1bb4fa2ca51d7494bbe9e8d9145e44f855501c6dcdf7c2b4c4e692fb13486d902b010e82b4e8b75ec17af26fd74bec175ede179da1244240c2821783a2fa5de02400a8665eb98412a6f02e9ab10c686e55b020b96b13a7eea192907caddfcd442641d487e7b7724bee303d544416f2a1357a39c535d7ca3d01f5e479990d2172ea7622147d3b3ad68f17e412ab81aecf4dfd0b987aa4305c5ccab9895af40908fe44e175740c7083a6fb623cda1e649e430a6012074faae3855bc95dba065108d8f0baf8f09c8616d20e456f49f32b167b723f5a6f418c03a3734e13325860f93a5cc842b5ccab4c9f363e46ed41074d3a5b1db264dc1a57f1acc6427927bfe3dc9b74595164f086129c6ce21d8298faa9f2813cc3b168024d826a497ca6482eb596a9ce4155d4d9930984fb6396f03676498c5b073a6a58d9fd66ac616b275fe0473a29ed199a18156dea3b604eeca9a7e8b12e3bedafaebb1be1d0a83e8ad8fb6c90703f1fca932b70fbc883ca68e57df002810d121115e4bd7a4478b3e9b3a74336a80b8cb0e5a86f1ae1aa1e4e6354ae9c0a01e938b2d64d9075aff50f5493eed51c49e8d83f032453ab9f1e9e826a3704129d6849ebdae6b1a9f3fd37f90dbeee311320443aa165b778e50651781f3e82e89f5a1c6ec4e18c9ca54b1c6f2fdd64bc69be6cf1b27805d531d01873781da57911c26424a08a56515f4d8042fbce4995fa3841a16ab7bd5f3e6adb6290f5ca036069399dd3f6bc0a2d8fcb748f01851f11456fc20aba0eaa1f3ca21ae3589be98edde58398f5294ca40b2d5a0a9178208ba182a796583faeb05f1798019f2e84a8d89528961a07037cfa21d08f7ccdd76eedb5e50cf9c78595bc41455eea1ec93cf24aa95760bab5fde720daf7ab707b730ff7da39acf1540491291c6256c677283c085d31233133683277d5bdd0e826cc56dce90313185834d03073fb80338d5091b5db824ed76288969bb0fe0d13fe0fbf4bc2dbb0ce80f9a878417d86802b3650f710cb4bf5768858f23dfb1721483a75fdb7bc09a7f128031f775dc40a3a8937fe61e0e1fca5f7ef59eaa7ea4d15d1cf8a87fb1215923c7075eae297cec6ec0cf133d368c942947aface9df7f390810e389b4eb0150a0d0d104bb7a8dd43dd62e0bb467a2abbdaa32fecf9632b35006dc0ebc54a96f0f9bcc04d1d57df322f3c82dade620922394544c9cc24108c2b003fdca8a77250b7383c3b870011036fc03a65059f94668a3bf48c34ebac70003aa5f0b982eabe2f5b7d35d3ea2299135172d25a6ae07a940235065f13a974293328ddfb286c608063eccf9fe519aa0551eac96e30ca71b7c2710998218fa3de1b6591f655ea9a219694afc7ca07db0cfd6c3ff4dac83897b72fdf8fb4428649f21f3317dbea2222f9179ad1522e35d3885aaf651e2de9928e160b370f9e630f924e27b989484f5ce57a0ecaa1bfa3d2fa59421843c1e2133cfe592e3eb14966904f482b03d6162497a746fb5c3ce1c54e10f5cc45ae42df091d8aa8fd7be656fe3ec4fc8b29a639d62012a4f3cbd93139fd752a7630401eaa733a71600d89f13daf807834d816fab6a31d4edbde02eb9d9159b85dbb3fbe3118855956cac8b44fd99eddada6801b79d1d02838c620303ce20bd306806e9b85343ff3e339e26e1345fb73021be68e45850427211d405648792c20a42f87bc27a89cd77a76bdbcd68e931a699f5cd4fb391bfebb404888a8e1faa54fd3387d09fd52a9ed31b974efe41088a3c7de99459b21a570c46b4285630f9e78735b88f5a5e53754ef3fc0c3f226cded8e11468461ca93d648ea24378ec14e9282e83aa05e1a102ed6e39b8834119e2394c3890b35ac77ef8e5483694ed45c04b28b612266ea16bd7fb114730d65d510fb07684271f52ce2700173e9395564870434c840a39e48ff0d87d466ad228bcb92985b91f06ce9f403efa03eab36dc7d916c2cec676476b71cf16dfa9054869283e7871e6aff985e48116e3a8cdd24daf5f897f2d6a192f5530f7dc7ad13f54516205ffe10eecaae0017bf26afdefe57738d2fd8b5434714c884b34a8f047ac183501bddff61692df21d846ad938c11063f0d515662e709ae468488597acc72d4c7a499464c80db8b8b41f5fd2bf03f492c4438e20f45df86b9d9b8deae75cd9e4950044e8dc9458c02fc45f2335f300f69172a6925e809581fa9e70e08591c0ab47124864666502010459ab399a34bd36ce9862aba301bb968089a18465bfd9e85227d915132ad44c9ca021586143e7c393e6441d2a8012d85e1aee301cda58153323d8ab88112dbe3ba56ef70066021de1a71b5e89f2f669fd3d50eb783be551a34d3be42b34f83d664f076b98918a78d5bb6132fd0e31114db213937c710b7f709881068bc5861071a9fe33f21705c6f1348d99dd0d124f8fe82bc52ee27c83bd0d2af80921663a350a10db8ffe293bc1ee6aed543407f6ea46120c6b86c12a15007c947f7eac1948a604cf20f0e9a137b42d64dc0be4a3d04f2ef3bfc6bb2ec7a7bdcb717e4f6edc82081db38fc78406bff968b17a6e7e79ebb40eea90e9040634a4735d41392088578bde6bb780e718c267e7eefc705b31a306d6f284fcc0bdea84a73f44ab03d041f715c472e7a25ef58d215598caaeeb598e0917abd2b7287e64539062ef3b12dce6773ec088ca7eedc9b7beef1fe7e79e536cc6b8cec8c9dce1d9ddf9d2cffb2eeffc79febaa8cb8cfaf5f4e9bcc40b11c3d1eb42386e3c9b944cd8a2b28f1adb2dcc2c9ef807fea5d34c72a3ba7c166012fec4704e8f56b7009c115a3ff1149d068e203ee765672f52e072ffcceff1adac29fc54c1039b5415d7a6b82b3557bc03f695381ea020c824272804a6882652df0066d9c3efcd8459acdb8a3186ea71ade5cc54a49d0d38e395bfc4260202f8635232e8888a1046b2799d2d6acac9a18875070f4da23eaacb69e34f1b4edae046dee9dbebd9ce9c851c60753f7c88312dbc7708dabfe720c8c9cc61f551282721865fa0e496e897257704ae63d66d7024163d67996b87ea4ae50c50a4aa3035f78aea7cfefab3d9be6c1aa73f3ce2f878bd7976dac5d9ec0477352c43bc51b2ac77751432aaf11f83cf10fde597b4d18a69c704b2fdf293ebe64dde48d50513db5bb07e43130f695385dd2474628a509e2ebbc1ced64f6c0c2dfc854e9affb38fd894f15cc9f44891ab0111af05e2cb765d9a262a62549a880a68cfad47c5429a39ba457ad4dd2edef551887fce47e9155165b9620b052035af4080bb8572bfaa60c84ac020e09a0abd3d312aa263b26dfb618a5a13c59feb1d6cf489399ed9948f84ea49c79fde8f8b1bda685ec64775c007ff2093f6d0de579572a82aba31476dd1830a5f119b092791669a591fd80d54ea9c60919a749d2d9e1badb76286feb658b31cd4dd12247da7526de645a2cc3a603156efa85a51a02b331d10389dae231ecb0e3bfdaf4479b990ae2027781dd7076cedf8eefd49464969ceed354ae53193a68595094330b35008ece0b2a792cbcbbe3d0afd5e9d0fdbc71c7d738ebafba89705be9c4f129e1359e2b1b1ae76a30cbc1c0370a6f31d93e860bbd108a5410f35a88ca873ae1def4563ba9d577f882c6415bdfba8487a298af31ae68056c52ca198ee539efb20135f197193ec2dfa21e29b0efad20ad9b289410900da4c797c44d4b58d4bb340336022b65df865480d78b8f82acd466ea6ff2bde0e70923cc47d7cbf40d2039092cbdbac9673c62f6a9eae69b6eef9402ba800a9f3c4d65ccc8391bb9a5172141eb8dcd325ab8f80025658876820ac503d6ea2aa9d51637faedae5bc913670e685da7397ff697944cd30f804ee7fbad1aabc9819e17c647e299fe0fca3c8d7f750e5ebd26d00491189677d9b08e40c8b2fe77d7baf3a1123eb6d4e3c0babe44fd6e2ac2906b3c336cb775c0dc53b3b607fc6761e0efd3bc785ca7bc94c4579f6fc704af2d8c73982313668d01a5a45c271208d0c6423056d1e3785d647b9cf9edc0f053f753f6d0338106dfc11b0d7c38a8c66df105b3981671cfa7e780b505bbcb3843814bcbcb6edea67743637b3249111b3dd8b6ce001c57cadabb5bd3e481c366e21a1272409573b2a1c5a9db692218515c6c53ceae21ec42f6a3159a6002b8387562563e13bb7ae820ac7c878eefa414339ca2f0bbb73bbace46fe4d41f5b47e155b03b7e9f1fdee88a4fd5f3326bec5ff9543f459159723c69b83d7846c4b4284839fa3d4e84e1c6c78c787f2e9a00508c4cc52644a07d4421b2c0d48dd0e5b8d4171028a2b1a94d1b7e360355dc74f79680e4426d9dbcb775dca5bcf241515af17ce1e520d4c07ab0fb275214344e51549db683f0f0d7f74243ebb0bff9ee4ba0d8770d6eb77eea1b6148a7c81d97fde4e507ddd713af1d4c77d4174cd1a235a81858e8c02286c38dede8df2c13006c8c674591bf2717352d6ee166c06729d42e1a67bbd035834270aec7b50e703b5a441324fd1603827ae26597f249f3b9e034e7fbcbeaba183960b5419c79c2f8090c652dd5749efa9491ac35d698c1b32a8cf41b8dacda86366346863381c318cc33830ef79159409f25430085f31e72324a35c8d12fe8d5b4add1c08f49d3f43d7010f75cf5670f9147a5061ac35a1a1c63124e6d93db6d51c4a2b1d82403949163012f8fa7db7d06205f6bca1773e21f91b5959e739d2a07f0afc996fa750a774e48fe0e761542a07408f0d6732a39031a05e3bba07e32997a70a36e44679ea0877ae053088ab574302c015d3eca5af75ebec38a74928eb9d5ee52f5ea723039da80f39c91bb57767d602d4f295678b58d52561938839f08ed2851e4f361a89b828e25df3d2c1434483287c0c15015018d3eb0d7ce7afec4be75ce7833ae958384760525ae93b715f213732137fa5be1143a550a318e1ca89b3106742bdab339e80b81db93f821076c329517aa73b168ec6a870c5bd562b8b283edaece279201d5b2cf1ca5c9eb5c90edf68a859931313ed58ec4745d7fe3c3cf9867e8ebba0f0debe7dd430b975ce2d691671de7afba0dd0f72a8c93c84e0f5f91c2d41a8eb8aaaee34b315f5abeeffccaea89ffc248d117f23539f07fb9e78d89413c8aa934113cf3394db50c97e7b9beb7715d48ef9f1590ef5d944967d58496c83ed2c461cf7245efacf02ded43e3cb1ed6bc13d68878bbe50747640fd10061af2774ba7ce18c673ae7714218d8154c143d4a3273ae02a23d9163fc278f3d441c9e409608a184b07d3b94cbfe0b3515e051cb254da06bbd1a00f6ab3d21b2ab528d8e2b44b1ba977eee9a9b067228a0c52b63b839c29b83943ad303dfdf89aa2b737a08ebae95d30842dd6e151988e02e4342897c6f94f7f01b92819a20e940aeee961b2cffb55c2603f5a7e1eaf56d1aa86c7ec53debee614eb3c66e8911070cda17fc5b8ed0ef3e3427c3e9d282e850e95325a39ebfd3d789eaace7e8beb36615b3a1653eedf801e28b7cd68cc2080270b72779e5970fec1d3549c26fc5b32c7ae422c0740e2f3f9fb312662b03b104e86b13317e5519d64644d2f1417d44e5ca09eb44d410979e0f6cf2ac05540006c01b0f0d016a5797f1364b0d7d084de247f8f1675b210f8bfda733b254abe3ab89b918301488528e7939e9c5d3d72f33ffd50ad278bbd6d599969871dd9bba6c5b91747ee081d907f7afed24a583b3e9e77560f37b0c200edb58b3c62ee5e7316cc2e0365f58730f7501b3f2e0a03d2cd5381d6f6bf381d76fadbb1ebc2e6f22c1de230253aa3b88a279ccec0e49827c4fac4a4c9ed7618b046dfdba26a47b059019376c767e34b08ca1826925be622c98d2c38b8e502c75e8dc2d8f9f0195bade38fd061682923bf00b109ccf3d6a1f3a71111967b81e8ce4e9ffa0b945c99a219818226c16646d84730ec01f4bd2ceb76e1e2df0640bb2cd7fb1e5cd59be853ba9b5f6b3783de47b7b147dc596b93cd2d595a7ce652420d0635746b460f28d2af6d489ad881c5604ba4ce6fc3a9c7e1d22959e33c6f60cf39948297838c38749061769863a77a6f0d3b3173aef8d71dbd86715298dfc9e4fa0063551deaa69f369464e5d969ab367c22d31ec921dddea6115838dab6f27d09230869d4bc3092eb69c61b08f9ce93b6ae3f82f7b0e6df00ad6abf21b9049e5052845ad898a1c5d6815a38bc92466aa7cbbcd0be2abed079267110bc4e7441ed7556d3fcfa1e69829dcd2aa34b386de7344b4d45e4599a953240c8908810008384d39cab91e1a3a8cccffa95fd038c06f5ac56c88cd7791345fdd48dddf5cb7d704f6fdbae931fe20e891408cacd0d908ae9e894adc2bec3747d77f1020f162b197a2b7f9c6374edd6f8f8ea8e50abc23839e2e8a464611d7925657f1969b20e19619e454555c64646be1db2bae9e0da997ef8469ad18fa0254775699f4f9f206252adf6e872dbd9c8dc49929feb2e48805ab076a1dcaf69a82c9346804e2cd53ff0ea81be7f9834371c23d398f9ccc68ce967d6cc4de009f7f749d471ea1555210ac2145fde8c41635f13b9fee5625c21ee02183bb08200ded0fd66066e203bd3f4de4c9f0ca561487de259d0116e3401959803e0a9f259d3122e81772d5ffa5efc9bb45af57ba77bcaaa35af281eb7ab02e09d770b50398ae3c30f182f1005c6ea38257582d1007797785938c28dcfd29e9b75d66a2f2a3e019e13daf485d7742cbced7afaf87e6ec6078627c574454df7c8f096d7e11cdbe0b1d4d89b34a57a31e8560e9a13bd6f948c5f62d3d3cc9901b8b7e981b05f7c2949e8a141cb375016e1d83c1998659bd04e07ac03bdedecebdc74cb8fd811d97856fa07b11fb95fd72355eb8c9e7fdf461a190c7a2088bef7ae4748e59bb414b545c33e9889b39cebe0c0588b28b6d8e22e6318ee8d76b69f12de8197d6fd6af5150fd966797f1c2803c5bcc8b572bf56fb00e92f67af3520f9a1dd78a01c11a3d04e81eb4a9f8912b709c88e18aa5600e3709234cca66f5d30ba3f3748d00672164e0b5edc475a64a8ae398d5243664422d466fb78868df97b29e1ddd1822bd9bc2e4108cc2e40ce06fefec3ab0b7df640ff76fc14823e2323794a3638b22d34763a943d8e8c2fbb19f797380d9322a048ef0c1eb24edea96730cdc9974d9f54bb2c088dea0b37bc92b1e958349e59f2f46850cae7cdd73e3c17fcf27e22e228bc18bace56aa7895cd80bb165c7f5fce2cb75f14ec52a4ced9c302b5e0a0a8730d10d735d883daf1e7c7fc0473b3b41c22f309d07aff5d085db22eb79aca95406146d0382c6bc7388519a8ec1a23dc05336a39a0e1349b2a1649e33ebf25f550edb14a3f76db02b95196a753dfdd415977aa9b0da69c804f8dea8a5627a03d43e9bc6754f83ca6b1af24ecd841295268b67ecf3958ba6fc11fc7898613a6583a5feafd2282c2d26dc4a579dbf512c32c5b47314b5667c91b25e76d02f8ed8484cbcdf6312764a53c1eb3001054c8d829103c42ca44eaacd3e410b8a2661379337d677844f4f9f255d175a80217d0f96e886b23f6c12cd42ad188a52bc4e2b835f71271d8aa15610f6d23e287f148b90a4751e0c708be7c6408600658e609dbc9ca287a3d67084eca5f76abb0ec97568ea35e3a66f1c2528b4d7604b03b75d70d36173dd72561112209c822039a01a37feaa481a6df0ff1f7438d053f7ecdd7a8a0af63871b7b5bb2ead92c8727d077648901922ff4dd3bbb626b641245add2683398a009a5cc348affc2285b1952304acf42694d015586ce6d0e1d9ab8dff3fc6bd6de75b99fa7ebbb3e2a13cca985e4c4782f39c89fa9a85cfcc75cf2b36a57e3049b243f4c1a56f457263773f83a43e76e8cc0e359a5477ebb12e66ee052a8dede279dafc1fdfdca152eae4f4b961c53d8f82ceaaafc6adf03a4bd194b74c97ae277527371fad443180b2280eaa0f74d7abfafb3194c0fa7de6db8fcc3a21b2ccb5960e6426ae0c1c66fb1fcc3269690da7c922e70c61b0b835cf631c0968ab9f3c83f6551569db45b0915f4d3656de5e3f86e52163da93ef16199d4e0be118714adfa8c4034cf1c6ed59811ddcecd19b66d54b4f61017e1ddd57b9921a452214247349af4dcadef223d9ade96cd56ddfbaf76506aa5700d6e65aa9ace6bcc68888d3834ba779f19bc0bdbd0ff8b838ef67674bb5e220dd02d8a2d8e5780f4bedd2048f1f40ce3f07f48b690b10a1f70b1c360876219ff2ea8866e2e21fd03e905960e602225c6eada281c61a0aa5590b3870840b685fcf1ad7632ae9be4e5a55bac1e816344fbc29b553f3c624c7938a6c261967b34c7181a966a1cea03ed107161c8bae929f6150ca808105540eb3c914ddac1979f09072be0e45bcf97ff35ed40166a30b064c9f1d144ae69eea3184a8bf375e0370e2a2556be895ca43b6d887adad77fcb7700a3e7997221c9feef9aa9daae5a063f6243960d1a68ad2e30882abc1a5b9f712a8891e9747351084a7d41697310373b1d7f5f62c6fe8d7a61cfd7f4f9d132e79f9b31b1272801b74be5e71910f042b335b08fb4ac343f4de199c1c96353672aa5d9b75ccede54cd33cfcd05c870265a01b7fa298f0239208439687290f4fe14460d0050ad536983ff2ce6d4902cfc4c4b82a09696e5118b3081751206dd57ad0c3fb7a05bb82ac363320b59e32b1707efb8d6bb87b43e437538627b36bed2b5491c2b1d53a2edd5bd9bf9360933ca611c75f7a5cd2d3ed4271bec2cf1255d06bf09e38e3d095675cacdc7946e4d68c0a83978f586e9cec8ca698c7447c8e8bab6e5e0866c3a24c4c3f2045f0288d58fd5b4c25130b09b88dc05046cd3f7d91f9d82732a838f4056b32b581f76cbce9c0e41184a81402c93c51f2282452cfb2cf9fb6d87c0654c0a9247314f5d23880c2dcccd21f7c8399e6d73f5e34a8be06336848c634ccce2fe4986244c7261a71bcc7c8beb27de3a49a9e04197b79f197a524ff8920d2a515565b6f3ed7d98a5d3dda07da8a849f5d6a740c79d63577d0b7afdacb3fdf888c8d7f72a6c973f415844b5a522573a91980cb20e4209a3249d182d51550c6a3d54f28f44fc459f4779dc106981470560ba264e697676fd2de707990bc3bf632729fc9e9e49d08f0e1aff5289058451d7c83c859031c2fa6d06498eb6c1ff26c71f58114d4c47b1a31794e0afe25cadf8f60ab2208ea1a5ba67ed4194c3434f7111eed62dfd8327b645f427b68b4dfe82ab1758c2ed730a10ee3f423f97e0c1724960ac1925f35acaec1ca4d935b8725ca096f1b0f2fbe0756f883ca0abc2d9509beaebe5bedd97ac0601eaeb10afd96394eb1ac54a6ecb2b62e684d3984d97a4f16c16b5fe26b7952cc08ff3166f3ac635dbf11954ed916665bf04cb6493272d5e1382fc0eeba72f2ee000b8f408241282cdb76f374604deff8e03857f510417a3e7c5065a1bfefa34889e4c5575550ebc7cfba1b4294a5c4bf9be1af5761975b6adc1c9a06c5a7c6afa106449563d6bbb46c5e835d7552994ab8822d0b59f94779849769c25f727b688c1156e357c4731f8a03b032d543ad59e4660c21c14c2a34d20a73bf652612df853f1deab785b8347b42b4579b0f7c587da05fff4257df9889c45f0492608b9f39bc5cd6aa79e7356ed2bb5bc97de604139622d2b73666169e8b04b9c147c8162625771ab796bc045827fbdb59f748ab9203569f8e04b5c7f4333eacfe394f34a8cf125f104cfd271d469873fbb3d5429b9a7f78e2332034d1d6855f7dd58cc9c5f5939ee4189604ee82b0004ce2ff5e20e2c01bd9b045a531295a397d604fd45b3e61f99c1829419ef91d5febb435f9525f8ca6dfcb1278cb490d56bcbd59452ac9df6e3bcfbcf596bd81b53bf221e4ab5e8c0d070fd53dc5f1a326c9aef52280e7d23fb091067cc888a28633d51df35e6eff6bd00c5241006090c747826979fdef0d06846b6876d8d97d521004888a9ade2157abf4df0b6bb52956979f9079392a4eed0cf7cb9750c59a23e3b5954bce18e26cb98b5821f1b182ed581bea02d3d4df7bded50241bd4262acd09586391b7c3c84e498fcd956bfc004c3d615dbaa88e981a71714d02e3d49dc0318c335798f973981c84b0bed7c40121bdd1082300de2eb7dbaf1fe0e9b6e85db27779f25de6c9bb2aece2aaa1c6c12c45045ca96612a5e42241df192712355dcff42fef3efed47c952ceea672ccbd5ea3d716b754a3561124947706e74acfae71b4a80807e34f52c1e70cf81f9d3fd6d84c8f8b10a62c0e606aae0c4f04efca80fd82cba8392f9f146f0b075f00928345861b32a40696c12b8061c7c9632dacacd5eaf4e14fa3e66eae74e636a412cc7bbd3517ed8edf5b992d30529dee124b02582c8c2ae59d74d0e09b317cd13d00b20ee9bec8c1e3c9e85f9381c6b8c7c4a74c353ab37c3545913a4ccb4581bb10dacdd1781c3f361522ed4d6d51bf976dbf5f86b60e1b6ed3ae787f1fb5f1707b7911f3e4c3e55c7180132a15bf6e753a0c5f96250420e8be2de369c71646f978c8b18d2dd0215ad2527b14f4667508e6e7228dd919c0132705c0ad3f314b4d27f4491e81be7957806a94468729909aa623d071acc0dc28a7a13fec275a67675f5f976309b574af84798e85c9f1944f43c6f62c50efb2b695f34ca2951d2bed60be3e870c8017169b522b438efca1debeef6b68152020067d1e1792e3f6a454ab426d79f8872e462fc932457213e2e42503535c7449e728de0f3c6a92294adfa1c8e7a29c20869c3f27d8228bfef8683c676080a190c1ab22c64b2ff841e1e4b9cb8a975cab86daa268833a6f830cb6aced78979a819b5175b299ff366c3d544258e883b53fffe78c38f0b8a18fd2a4fb9346e123ad7fe0b200b6fec68fd39e29ec88609e3463168cdeeccf1a94ad08e20da1b8bfbb0090f8d94374f2c6745dc348261102b305bce4cd5c2e99c3644aafde4f2bca7a86218636f0ae66d0e5f042d1087d94f3f0797148b83cdf731b9a0f67d0aa12fa1ded7b5c3a8b30b50dc22de9b168d944607b2fec33cef30037977ee11a553500e3784b2a3573d8dfdff7a00fbb282d86f31883d2353c76d5c0dacae84d7d376df801512e80102e28f6d2070a612a5840ac149804d11dc3e124b1ee87c58c3435c56343fd90fa1e22eacc3c29a164387969cc5f87b4210dfdc4d08f8c1e09b4f713323b34c7c111f2e864889d65791d2946cd556d320acc3eadc9ea8a8ed519e85dcda0d679049c7faab184ced2f7a328075e7f96838590dfdf5bc939d62f2edfb523b7d91a0c49561b50271de0a20b9b00b9d0fbe9d302697f871cbac7c7336dd8b1caefde7862feb21b317417eb89f92dc73aa79f549b1b722674bcb0a17d036e9d7c055915033a17d4907f349a50937f5e671e8b82558046f6e5bd18dce4ff8df97e48322affb695baa19191cea4abc8010635c68a2407f6b0491f6730ca18b006f5390bec1b70dfbfb80ce700941a5c1aaba2c6301e6302f5a4da07f2b4e0c9715fd41bda721df26efbb31d2dbf75a97c5ff76af93b24c74d43dbf7b3fa2547b6d215bd57a61b09547508d4907c69ccc1f8b26dbc3f6f9ce2c664b653fcb06b9ef91722979e22f38760d3bd5e56919af7fe14e0b9f5a74a6aa52c44de3f3519872936a9c2ddd3a70029964809595771bafb27478976cc1655b8121b8972ea58f8e748f18e47a327f80060a8892d9d1ad970d86d863232bb173ab9331e98359d1050f9aaa67b5749e81b56d0c9191f2c434ceb49ad656f803a25e35235a1ede118e02a08fc4eedf7e21cf6bf2c4d90ec4ebf0bfa1ec9ebf5b0591e7ed9754a375194b66c596bc2109a010f3b16a24c3fb3c50bc861eb1dd73067b553086fa6bf7502a0c6c1d944bf1e7089a360293d3efab297dbcb6e56e23be07de53c5a48735d9fa7126d29aeb3cb8201cdbd07ef0a11a42dd47a2cb0d24269c3af8225327314f1631d0c9b4395c88e3341dacb25eaf45678ebdaed2c59463ac209d89207f471c61d56bd65fa067ac4c2ac4f923ce9078dcb8d0ef929bda17d4acd100484a3fe8b57abbe5e819980583f4474979b72b923ca1f4be3be90cb1830f0be333dcbede5e4bb7b123a77c6ad13ac230ed2b134dbca5e146958e367901a88794ab6fe58c9495992da8acd526c3a3d2c1e1be2b0439b955bf71b3e4ce0f06c9a1d3b799efa719ff948416484d8a0ca79496fd940014f8a027ec53365287ef0901f28babdfdcb609ba5b462007e522b2b9f74754db1be6e3717de137518f0606367e0696b63b01634c863eb9185324af97a05f4d41a1dc2d4c3d91ed79172801f39e7fc0e1d99fd45bc0dae030d8c081cb780de19bf7f4d62c3aa0d727e86595c4b53fe208d6a5c2208e11a9781e5195f68b647009a4584a32f1f29d58e3897a95c16492f661202c6889715c4c405c7f9d87e43","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
