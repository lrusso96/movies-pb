<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b0ac4ff1d3b1c4ece75c3adec77f6a4b48525152b6201befdc7f3c676aa872c1eca6c346ddb5ad46d0bdf00ee81558726c5054819e6057d22fc30cafbede87a5b7bff491d3f2d88115a350930e250bfbcc305d0207276491c146c991df89c3c1d11d4af43c7a082bad61c244053ff079391393654d5fdc977c2d8e50ec7ce06ba16d435f59f0079a3d113cdf014bcd7157a9d41735aeb22f909942b8190967ebc38125a51bf28d0943aedd9fd7cb372730e02cbf550844c2491acd3fca3f4a6c69d4bb6c5a47ddfc428b347871bea8c6c5c66a49fce19164164394017f0ae02fc327ee93c9dfd64013be25179dc98d704f8ab20563d57c151aeb1854250e9a0d9371ed1e7c9ab03c2e1e79d665728cf299b49dfe09ddfa28d97a285949c44d3b22d0bcea60021d08dc927a8995ad038944da1cf9178c5430f971e00a56fbc156ec651cb9da94fa40bb6d3cef69da28e4f0800647b43637690bf815efa02b4e82f2ad542c84fe7502cd34e03df0a883683d80f41d0c0a7a275706d7cdf44351937205a1610a1bb99c45371b94685d6127d1ac4984fb69055823730e5b370f30377e899227565411f0a3087891979f3899777b1fa2ab70e453c8b33d29a6a896a92aa6f3fc6e8635564c518f857c13840203c3a89da8e2df5f4912b34827aa0faf4701c0262dbef4baabc201efe7b5f0a584edfb76f07def136ad63cb3d50f00776b08bc6a0b856afcf8fa6114245c9b1b21c55108d1b24c28310bffa6c239b90f160303bd1d9ed6d8fc35f8f2056d3df357b3b12199a211bc2c09ca2322acbcb4a830e5a90914e1907c45bf41e64e0e8ca89262a83dd43cacd135f098bf462b88165a5e47769ca94c7715ca8d51a5e3508625dc5adea1267329b90ea69953677c5f96626f4977f36114745cd9bc508d45ceb4b95e86c1d9e5b21e8d822b23c1509678df6e52cf603bec2c8adb10824c9db1d1207a42847693f964301fe63b113751f542d1523b761c2f1105f877da3df51e61e0b80cf3ea5b0e78ead5f5510527cb7d0ff74d8e8a8633fc99e400351f3a66c854d3582280cf027bdf5f35e6861e02b3b8e363dfc06b51a21da0120f5ac64979bcac5ebce9819b44d0ceedadd512c04e384c1c2f45b9748c404d9d5ec5bf13b498813bf34b79cb51296d040f560f5864c97d0fc8c1bf0f0ce22f6afb63e113fde99122cb636de7c97db26c5808bcf5e5dd30723523347d7b250dc1c0140878f5b9effaa7d8eb7a7ed25dfb65d8ef5b256b86a2d75551d02e0a5a9ce6f08a55d8ceff97b673ab618c4c8768c24a249b6de74a67524bd685662a328ebfb716a4ffff69c733103d796e1e147fa54693a3242208ad80f5df05d17f4394269b854ebdf487dca9e698bcac7d36746e25c091904478572bb4e1e34e35e1145857b68b7eeb2420c368b400019ae8551b51a5a9ec74a4fda61169fa29a4596c439430872f53f85407e9d986886a3d99c2bb10badc7a379339c36c4205a1e9cd40feccac6c80475b46fe1dab52ca87d3ddc1f75971db826606eb07637fae0c24c4e1475a9a9fd96ab2bfa78af051170c5628b3de9ec08920486f17777e52615dbe77360ee8af204c4ea2262b899cd1d40d3bf278df0a0bacb070c3116ce5193c856160847b2f0d82fdb530178ea7e9c0a87e44f884ac1ff19e343049d449171b3f04976239f667ed893ee524e1358dd460c14d96477e2b251fa10a55f2b568fe54fc7fa84474f467f35f787dae3507617772a95d9e2fe79e2c48787bcb14e6a1bf2a48737970533ff75d0a6cee7583da0f173a7627cf648acc7cd3276f6067dce4d6fa8922c770e6c2c448f17710a57a1d6ab8cae0afc563298c2a9f1fb7a489a00fec852799eb6c7283bb6444cb59131e86e89e70b2e2e84a8ff9e8e8f52e2731fecd527394b405749df27bb26e356fb8972e890a13bd301b000290f80e77683dfcf7347b87d4be8e7147f3abf0654da90e1e873a7ae44f6dc8186eacdf791ec68d92f071ede93f25dde6e4b5e1e1fe3bf62db80b47890ae83c5163d6bfbf551a171518a8af0245f51372076bddc4f3dffcd94250ac0a33cf5deceac5d1e191b0a0bc23f1b8e83ecfb0b6e9f6bd736bacda2d7d9284a9100e9f8470037479d5ee852c80be9621e76412f1f11935c9843f8b84dc6c00cbd84a0439686579d8c70ff5757c6fcc6d7ee9cc6ab5c59c473bfe4b7c9cc6d7dbdeb6f5277575131b248c7c4bc6cc1787d8fa2c0fd041bb5e5f2b8fcf0b6056d939dd2ddeec5bacc49e19fadaa3a71ada9c3aaa3fb76fed57b0fecf1bae825d182b7e5bb72d937e071035d3cf20ed00fbd74009efa90f0fa7ba2b75af1b2e6982d79570093f323135b3aa133f281bb02ec3fd5702ce63281e0767f32017f32770bd7a297da62a6dcaf972f72f5fabb15276d2834ca01ed5a4e87d9f22dafa69b7348be0ee918d8aae3e10c4203d87ceabac6204fa24a7d500e2ede4c4b4439f5570520079ce72c39acd2f278196bee3beed4a9c217dce93f9a9f2ed0f40530f179fa8cdaeb7bd1fb1193a36d80a4669c10a3599cdb9f4fd20348bb3f90f58b2abaeb7839b843b1287a7a1a6ab7b5f1d6cc7b81b54de1f4ee80b38e6aa05640cdeedd8f9563ef56e0ccd9878a5f9bf1370010ad6bbbb54bc1604aef3ebb9310d1f5098c284cf4c2f45c4443b0875d99e57b09d8b08dca8688fa942c669026c18ea655c16a36161df83a239ae485ddb48ca77b5818db87424bd1e7c1edf312cb60aedca418eb11b74dcf724222d6d50ebaa110626831bb437bf2e957dd03bd7f9e636aa20f3c022cd005c2657e6574216ad63e0bc0d9e8eb53c950265c1ddb71d2035a15a5148ab4898b1d4848b58ca41e9260221998f6e44a791bbf2458d22d636976c06acaa1d11af0186061835fe08f4d6b5ad39a207d92d0ad046eeba0f596538566b46f67c815a88ba02308de7e0ceafd89eb043c829104cdc329dfb36c2777dca74290fa3dd7d5a9b7aad7112b605fcce46d3ea77359dcbc508b347fe2b42e545b73e701e9b182e692924d2463bb3983c4682b13782cdc470b3d62a0245aaac55b19e51e07dd4710f06e3deb2ec7e2d2e993216b0cb1d36d5a02213f4806217a7c407057e4deadd3e27e85e6eb6b8a93c0f879292c3098c4f1dfb8e1b321ce3d78430d68cea8fe0b41b3c7d23e68819b879ba865fe4c63134818891fdbc9ba6b1dd821bf6dbd0020a25cb8268400e554a7ac99e1477fb46b01e2ed5fa467bdeb770b80919e5d8fb1d964e6f661010d78f6a174297b63ccad0a1e3deb1d2053030b7ba2cd0bad2fb3ab6b47cb7a0b55fc542a4dd14e4b0b20f6e2a92eb1a2b24df92f32e04011b9ea15ee4d9780ec0dfce208f508d883cb3a0b0e5e9ecdd33360e0327d68d670669f634c73bc650fd963a30635f99f35166cfc3b57d76a2ad48bf4b356d717359a47600b9ff54b73c470a88567829ec8021b422c2800d8a91bd136fd083649e9b2abfd8537f660c46bcb7b76bbe47fcc3fd471f0b6c65a1fec24bcba52c422cf8ddd3a0cfa71746e88ac889863b0d4fddfb0afbf7a308606f7dc4061e17e73f86eb9bedfad677572cd4d35b74dca43fd9cd4bdd1c0ace0e10db4fa278f400365cf9662b2112fc8e78020bc11e90cd5e2d86ccb71934306f34982ecd3fe2bfb7abab92f3d53e7a6ab0fbc6fd32361bcdb6845b528c1e9873b16c25ac516f356e0b82cf8781156874e150645414e37b960bc5bcb6265137d015e68ee1ecf7649f6989fbe658f77b4be300d1070c2d567de23ab72474c99f01a6744b0080654df34bf479fe8340357dd6f7ca6b8afd056b6f076b361c103755951fb13332a0aaca5a54e34405b923e393276774acc5df93632d29f2cced69c6bcde89ae55cd55e7959b05786e4ea30ac0f191b42f1ee4f866871d5a3524eb70f49f3d6697e3bffc995a130cf57d3c19dac199615497495e221a2d1064649fe1de969b0cb3336b88308688081bf1906ffc76c0c6f21d76cbf60d69e8d37708a3d7ca363d22e6be306a30896ded54da50ed3a577fe7fcfffc797b702b731dd8d26aece0d95dc14f95f7a9827f9dd6bb9406bb94abd5b851ca612a1a692a02c6f4094bfc2e2c11f896d779aea43dbe8fd7ef68b94fbf450281cf94839556cfc69d340212605514738a29368952f1f2a8eda8e9e247b3c023c2afc4c1368d5da737d255729395bec678156bf1f96415fb942cb2f323ebf7b2f20f311ee1dd2371da612da11bdacf50e217cb462cde19fd819849ac7e975ab201b68960c7b39155e710a13042a322b1118ceddf6074d0d7132f3f390fa526279945c96cb7dbb3e2bfa15100fafab91ded3f6a0f2333a931a873728c6b9fa1d302f5752e93551572a030df52437ca17fbaceae75e5bf095c182a3b7ad2cc2884c296d24f89f7ec300d7c30d1741482d6505b5658183c53b00fcff693bb0da27e4a79a5d4de53a8ff29c23246a1fcf572996f372bff750b49c83734d500bdcfb359048a9f1a1d389e43063e23fd471083e93c324ee8b1513728f3cd16c2b36189eb3c85f24253f36a32f4c53800fbf2ee3e12954512626912b6f2ddfd9d823f91598f3290506882aabdcb19c43f7f19557307a81c06a15dbefbd41bc123e49cfcafc8d28a17817e4fb30b6c9fd86db46ac1da531f7beaa5d847d9c405f5969eece7b09003ff7acd55c2d262f1912e3d5c93a8eb6bd8f85d89fea66b350583509aa16548fb1b4e54cf1818ae341e19870e3d8520e4bf4b692b6317563e6d7f0662e4bdddd5676505ca72f2006230aa69eed882dcca87842e5bd0e01cf5651b7278e854c2773bd10783696c43a410d940a965444ada7254dd6983cdec9c0511c7c672ed65308f5c9a42f5ba134cf16bc9ca36313badaaadce3106e4680a27c6d7c7a4cd7fb7f1598ebec51e97344ab290e7b73e2e36ff9ab87dd21dd773c6bf02c944412c2263f4acd5f9f77f971967ee99d357a05e89795551a2f525f266a1820d710c96f72c05df88379c6d98b69b6c16d9e918fbce4039110641cbd755fb4ae09b92bc5f875d669c8e5dd45450340d09f891c5da97f63ff881d35946408bb83955bfceda8796288be533aa30295ea9045dcfe3a735451504b25ed14c07336341c3beb3f4a794f87c8e387ea8880a4ddd6376ac38d01af3f6abb1e0004076b0c3ef2814e7960297d9faabee8285262efe3bc67572e485014e212ad08e908e38d1a667d92d96061c5805a50a2b395d0c08fceb4e398fd9af50b1df545bddfeb3b8ad733aa1626435af601b4cc8543fc37a062124584d49699c6ec93914ab85d1a69ca3e2dbc2f404d6ae8003e19f65d8c7e13fc436920d79ee0e9505311e1a9e15d3381954b2f3a0c3f75c896aaf55e2e5053a08cf87729d42d3e6eff8cbc8937e124143cc2e76be7bc019521f0265ec583d8c4e10aa5ec2600b15a82a47a2a9b7490f4c9bcd4a61a0862808963382d87a88915649a75ddc96537197de75d5e36dcd88e788c62929c33362b910e8117d9bc71ca032439326644f4d5ab908fbcf2bddc719eeefd39c1606c006d4ec59a4b8bdb5f96060ba45fe24b5bae878d519786576620cefc9d635537410bdcfe13c4e2051c60a252d5c53b28731a60afccb5b7852aa650c3857d5e33cad8c10827b1573413e9f7c11cb83521605bcd3fb039a061b712930e87d576d1eac825d1b59270462a34a5584065e196c111ad0bb84a0e6e72eaee37e52583dc1920ab878ec4067b838f3d7f19177e6b3fb8fd1b3cacfac2a500d7b0520eaf0e20a23df48af7d2263da640450a8ca1553258123532748fc0d98e9adf2f2797ea648e193a371243c94891a59368d05324be0f3db50a8d67941c8efae8bd74ce6510bd9d35a0bfaabb6dd27af9e62e43431c20e674293549d89539ad9d8118ecef69fc196aa61f8e88d7da5c0de15dc1ff27f4264a4253814b5b45a023b3172585b82135d6186039caa9f074505405fa7cc015c9019ef354dcc34663088d23ca7dbb38dc93b1b69bca5334c92b4142f924c8937f424c9d0e7f607e5da85f37985231a6c249e6ac69b1595c0c6638ef0a2bad22b6478f8febbc4bd6611e81308b9f7263073a027610c7f644221b5631b41795e50dbe3d77dea5e5c013d77e423fb51cb536ff4de52768f3635d77fd63bf06bd02a1df4c7e06c3339d66d118e19d6439fbfda549838299a4d17589784795a2a70a6f88940ab4baba6341d4f52f19aa0e4625ae562456d54760383df1f10698e384d7da23b14f3676408088a8b90070efeacde694116b50f1ebffb105b68ead72fa626a432d5fe8e99b41c8cd5db2d47ebf3c052f191dc05bd252f6811acf5e3d6becc4e288e5d778fc5fcb0c163c84f6c2c0962dd6a50b752246855abe6994651f2b0786db48d3020e2690dfc6fde2cccf89e07475fbff72918acebc9a80e032823ff57f2687556ab5a01053778766d914635bebea55617d117bc612ffd7096ac722c17f4a25ce76e58bdf35215a5dffe89dc31a86088fee95f9c71ff5f9efdf13b2c0b4fbab56288e1ed9e2f20ed47d51d56cc68b4c03243a4ee5d76130d9660a64fa3f1769623f9bd15b2ddbb31a8ff602316bb82419236e335c07be0130a2020bb84657a8fdb0bf8e9313cc8624a6ae9f3b12d2dfc09df01910e915369730f3012ab8d883eb3820da39b0bb0ec3578f16422a7d29b94d3c20a99f2d1b99d3b70d83eec82d9001e0ccf0025c7e5e4bf49f797c4441f10e00a8337662bfe3e456e72d4832b195420d06fe20a1d8cf5c5da58101bafdef50574c180455a3dc3897278470757b34f9014c26f288b87cebce8f656873214d2def268580537026dc8ccd7db3ab0ed2610a5ef22fede043182ab0536ecb65d6f669fccb2066a7f13c657f9673b347a3ef857349cb493bde5c7ce7d32eb2d309873b2be915d1acc10854a99de42ab37eeb64712b9f981b42a0520de409b07e15343b89fdbc34c4c89a5530f9d86974e157b6c3005a3c2597e46d2640f5c6c583126fab6d68e75d6b108dd1947b12bdb6a8c97b155c76446b996865b09893c0d0125ad85a665cbc54ad1e5f914155681c3853801bdb09c2643aa5ead5e2eaeef332b0b61e5d60fc973702f53381a6142396f6bfbfc689b0811c9effb2d8f5a5ad2f9268a8227869d1e90e3f68d4435866fcfdb5bd10489d6d940fc9683ae64802c179c99a628fbc1ff3309079a602d1f4b3cb333847dcf0b22c7eac156f4ff85673d62aa540de97db13c466e906fb63b4d0a314e141dd0bf46fb9484e217821248b3679b49473f8018534189f1c414a83367ec91aa9bb4986ef18e7cd18ce4173b3ab0bbf556d10cf140c3e7e3c9379b4e5426809b6e2c4af1d2c1945fff6ade2cdc3661b2d7a5b2d0f1d374a2f4e71de3c6874f584732d0de84fab5a4ebfef9930d7b1dc042221302dd07355bec4dc073a902104ac59516ed64920d0191b0896d2e415b8f2e741383b73641091af55e0d1cf0018c12fcf5d4f358e2e34c82741cee19f1dd24634fad415008678b428b3ed98f0f010da23e76b0b5a1a4dccb2eeff3703b3409995205674819b890fc212e6f0470f337005c2928d265553c63e9a90cb9365d4239025d3551fefe92db76f57b9d43fce89835047be989777acf416bbb69b00fcacfb31350db8b099383e0fa18d10f5b37b07135f0e9bbbc0888115387757bc1d667e4a38589a7fcbc5ee4d80c60e77676d6ccd7be198235ad7e4fbb5e593ecb16c579396c9cf87530f7e0a897d64aaa5067b6088257d8bf61e83b8dc9288662c7d4714284b9bf052349e75cc0b6dc529c14518362b9a92ea2edfa3b607dc60ceafac55c72d2f7d664fac79ec13581a8edad80e232184d8670529da36cd91f0092943e103877feafff7f35df0dde8c52d89998a0404a2be5c0a62c37edf9f6246b34bebd1557d076033a9cd3854895a3f6bc15b2910adcd4ceb3f0c7433970d684390229205fa11c3a258c95cdd9350b57122193d31eff19ec24bfc9949532fd604e66e7661254fcaf8a382e6a6ecc21bc510ec3f68cf02417c938d0fae79c8f9f1df94b6a420ab0007f71bb6e6770c559135267316078988a4d2576d00b6360125a9c9769d96a25179d8eee9ba27f13e4c81ca6db13cf6236aa938f53e8b070c3a8b5c8f2cc20426a743e5d8c30a67f96c5c27358e57d9f1ccfc3918dec9ced880e622c4f3b1223a52903c0fa1cf26eb5caa8f17af5a4689432cdf15fe986a653927e27445a7a7d72d1083d9bef993d9fb554f3d4745ec5d47b764c698414b52bd70128be85de601af1a64df874c4f36a2380ab1dc615657408ca9404c9924eca3ed693b3d9bf8563c2e345d7c01001fbefe7dfdc140d09f44186dafc5cdf0dc6c530735af41463c5712f4c03f4c967dadb7646087981c8b3b97da1520328f2b47c333c3cb4ff3c122d5b8e171e272b88c228faa65dd70bf9bbbcc8cee60f7b9e13aaa5c531f982ac62c3f2c2f03d888f2fdf1160a7035ddc1bf4eadddcbf0ba7f117bc3e8eaed688889613901d505312f370c2fd13d23eebab7ae89e9697f9413c4d1a09b297275a8154607baa00bceeef8da052e789c84b85e4aa7b38823845d52889c6c9817244b9ef24648020109752d07ccbaaed35e64c88f17e4150c4ff6318a6173e3fa8983a4b5381f852da21dbca11f2905ea1535fbec7935ce2b355bf4899cbe8017b11879918d5e18c6cef0055f548a0bb4d6f3cd2494152f01e1e9da9e78aa851cbcc57b7dcb823ed3d5cded35054f774c41c6c4c027754c26e47f8207f1c167fafd59540ca51e700b15cef4837853de31058b6a17dc03164c2f3d909b1a29256462b0bde45f18843fd3a6c8c747c0bc74af745f839845d3147428a5c02ebe354958057b1cae3eea3c03a49cc99d998592272394edc4bad4b64c002551480abf158baee78ee68492be3a9a4461ec72f5b8ca0e7cf9dddcb678a2a802d5ecd34e8f52fbb5d3ed7319e654c3c5fe1de4b9e4a37fa99421ca1beaa2971e4c95ef980f16a573fd42c6580bd1cf3f3f4772ece4b7115b36fd70d74d8ac1dfe43f7fe4d51b2a1bff7bb1692a10b9ae2bb4013130c87138bcf124d725569d838f3417e77d50ba2a96ed8b663354dd019ea26b080cc8b15014e230a0a3ef71f1b22db581476ee534e753c863f1b2b75e85e737628043c21956b1af003bb05fe3844df9443f705c884150a7f9737789a636ae3bfa00f8925cfdf737b49cdb29c6798495ffc78bc764953ae51eb4c25b44b70a4560b213f0ecdc0d114eef01862382635d050c245967341642a5079c24728f75475afc46935186278638c41d394327bf46e7ce7d326d979508261fdb696da9bb96cac9218f8c3f409e535c621189aab93323f3d59607ffa5094d839706d055b1c6ed9a0753652ae4c1e1d13ab831e2607cab84ab1809c4b52fd849788423d48ff806483290ddf805f9ba147401fe35790aa46332da304848ffb20dc474a094a15b485be81dc491f47c04553d9085d0cd865d66b6cdc7c11f36f0516bd0fe9ed544154b88740322b0717e9d840d3b5e007b2a09de5f2b2cebbaa5c14791d6fc2f93b568d26e866d3119291926ba79f5881175ce433fd9475796e09d67fbb019180bce5a40adf69e95343eb6b1bc57da1fc56e58d569894492390c00bd9eba910a50f0e081b58c12039c4725b141f62efd2bec181ccadb2e9d84e85e374861a69cd22eab2d786a1b044bc4def7babeff20ce1fd654dac4e5288033d2c19a8ed0c6c2aedbeee5429428315461d08baf77d6236faac889dcb99aed62488f88f836faae49266aadda18312cfec5a5c0f8b1a966af6885f7e6fabb0adb8e7b3949306105fd03b124e9b21f3f6db8a29206ac879dbf96aad7b27fc41cd22f61b50e6f5faf7a2d8376546ceeed6598b522db85814e468df5dafd82b891fb7e523437b1417aacc579775055065e27d263fe66e2603a5c3e725cdee57d038719174538a78c79e7c69746904c8351d6297f338a233c727b1bf282041a00ff32aab54583410ff24f8ca00329947eb84b923cd70c18c82a4944963fe9a2744ef9584be55acd28d96c03c8525af3421d0a944b82b3f21717cb8a98814e671181e33cfa3dd6cbe24bde1e709cb970d774da0578bb88b6c145776d77c39fffdd8b0f724e5e545fad440230fa695c1243514b3be49bfabc977883d40351839353a6f626e5a0fd5afc2096e404587bd9f818381beac30b4271160eb5c6a0ffe7ddd9f6854cbe09f4684911d8bbd342cdf909b3c6370484d98c62180ab3e9002851546227ea15dfdfad65c2e7e817459b75fef068249126b1563cab96051bd6d0d667dbb22c17b1cf93b201c0203822384cd564ad2750f11ea32af59adaf0b4e337d545f2f639c1ace1eb07ad2127526d352e26dc4a113ce28c2195360e67185976a06df6109181baf943dfca37509754827b12194eb685d9af1e3857ee8c961f2035a16ee150d7e958084adce08dedbdf5b24c8b9726171c4991e0192e6f076871ce395fecdd7308265c66559ab48eaf29283060cb888f9317b64a2af56de144f46d3d19eefce4e1917fe248c831aa505b80488503a48bba15acd80a55ac5318761bed925bcc8751256a813a910589ba6ae7fa02f2894c6177fe80ae9f2557d3326c1244758ce6da27580aabf4aa4c29f3087503a63f2465b2711c8ece9b1b76f1f53ad6c195400d8c05fd40b413ab36a930391b427f1ef6478cf896c984ad0b673e4b898b8343e124d5a60a1120391e2e89e9e774bb3186dc4f0fc94a2318725ccab75c6bc84e56106c61172e65f5cd3bafb5d029e4a9b5a08a89b59a59f24ef42a77bf133eb2d824626241845d84ffb8eb0588c53173e5c3e41e8bc084d4366ce146f3e88747b781b78ab8b478de9cb7ad10e5d663bbdd2e400ba9acf159f1ed4de3ac522d417aef9cf64f4f7eeaec0b365759d6f8d89f641ca24ec9b4c8c51675b3c9122ec668db6f8933b8a660cdbc4372ebc533c5cb366e4a68e67a7fb3df9a98a8e093601e8f3644efc817c1d83797f8ea716c232a0da4792aadaaa44c61fab18840d3a706ccfc3c9e7984ee9ac3591f5b5f534b5eef78c534ded42cbb3d4ed03a20fd1189e9ac041240f6cf6d9dcc60aa66f361bfc15a0d12730043efd09aac712c5e1bd93ae70b890c4c756a5843bc0b779b30323d9cd986cea8a6d63830e71af2bed68e146a571375761ad60b951c9d44492f26f3b23f673d5fcd38dba9ecc0164a47206b2b3a32c1c9468f25d907aea81c91203524efce0a2f05d8a70e719bb17e680589d8a1471c6a061fce0cea9dceb8b5a62e262dbd9e117514c67451dd7234e6e319ec0afdac5854583136c6da830484a516d1688c1c1cc212963e4cabd0ef15a2fab26f28bfc47f2e18023cef2eb8e0dd3d374acc3a870f86f97bb7adfcbfc2e82376ce0a0779f3a6de63f73d0743994854b4a1114d558d7146a1db678ebd3d17124c0e306a72c0afbe73f9d30f628048deb98a7d31a04382cd66859d19cbfc72210c961486907ffc0ba2739827e15a6f6328d4e51b5ab161f041897eb1c369bed33d89381cdebb9bac592bdbbba83216770414c258a51ad07ae3d716cf00e57ee7fe07ed8cc82d902c965fe73220c4fda4abbfb3ea3947f22de2745501cc73940cd918140e9c641dceeea45ec40a1387ffa76a09e063210ff9af61ee142b2ea70e64f8443b7da78f7c914961c14c114724365aae969906d20c8df740c93e656f15e24b5215fc1634a4c5ee6c7d0479c7b670d318e147557ab90c237146720274f5d3622a4be253614ee3ead8cac4335505fbfd708778b6a67c2912bb8285f58d31749b542f666437c31c0975a044242c06dc933f893390edc6ef6ca0a432cc23a2730065e403af980baa62dbfae24f363170abb4e803514e8e2d01eb3dff1374797352259e04dd7d4953c44e725a91ceff82607756e4444a741f1f5e697c52c1963c69dbb0ebbb9d6f9c286b7b7201f8736b2d8eed861c38354060dcd85a639d84466c177940803e710c5d6196804767d3235a8a3d8ead5d5515a989153b7e53dbfec38c1a82527ff565501523251022f7b956d76cc6ff78114a45cc72661995211cff777f969e792abef16cfb840ba7ecd221a4559ac9796b467905d5076bf5413639401492c7c147ec2ad816c59588ba7556a7d2843ac4a0729014e27d7791e4a7cd598b6a0c8763149f5f26a94c9cd402e372d228a86393aa54992192005c57c8802c2d0bc00fcb243905a78ca8774f1d04cfcc0b2d0347bb85678f43f25969b566e47e4c6a57eaca4f8e1b7b7c7e4e14fa6724837798291e027698334bc02e19dcacc0d46d77128012a87ade3f9a7145402628d02872f9625d3888dd317e4bc84ced18a63c47194def22a94f5fd75e31738ffddb3261ad64f4a339cd04351aa87e2253fc4966352e430e43b781c4af8f4d65371bfe9d816d07f623de5ee151c2d5928ff2fd87a5f449e3cb286de1aee39c7dc53c9d690cc200e9bd06954a5ae8625ae14094cd0f6748c969a45082a2645bb2a0127c49e00485eac1aabd1e5de9829323eff9234d2734f5b39dce87fc41b0de4519c4ce4a0262afde452bb3ad00b17ae18ba9071dfc54a25c4498032353c1081bd2059ccdbbe4d1c6afd8d97dc39e3a36aceeb5d2fea08f18b454cc8009ab94b8b6b3b88334152120aedc5e0ceeafe170b760960f8f835396332e0c6d93675158d8cbfa89ca245fc773a9a4a7498f215d1af4468a2d857a74bf9ded9c98524afc31b5e59ab8c8987a6495bed8205f00bffd6cae1e7a0b4f7e4ded14804cf93c0de613c555c88e648fda8b7234c2dfa1448618721dcf278f46a0d1ba126ddee0d3f5a3a097718d9afccba3f452cbec58edbae2450153c7eeb0220d6f792343aaae8a47c40619a53b1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
