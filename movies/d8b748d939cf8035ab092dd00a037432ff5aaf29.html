<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"22f2893f4191e1db14c49daa56ee2fda93b4d8f843b7c7b94f5e73f29fab37c2553a8b0b4a3da2ef9cc54e4ac437bf26fa6eb24720116b78e80845423cad27677e22c0274f3603dbb2edac309c2ff9ed8e4a18d1d9fd7c45419f7f83a5e5ec4884109b9118db75e83212f6bb06750ec4a8771666e2b7132598f232b013c88465825af8f5fa4b17aab490842abf2fe9ecba4d30e40e98a19d42460bd78607d2fab8456cdb80d667c13b013e64b100d13d05bdc0a087b5c61bec68eacffa522af62e80eabf6383c7dbebece3594ade4d0a22ae97d404c60bf987859e674273069ca5560bf7f86597868c9665b2f4bbabfe768afb1192180e94e79b24680237f7631b9bb7cf51c1af1c0c8c32fc9e5fcd804fcd9dcc2d6c4bd8e055b0e7c9d7c652840a9222395347b2c32253b2430cebb2e622774b5e9b51d2c9958ec602133fdc14be4e17fbdc8b89048d5ff97e992799ea69ab23c260d403d7ee92ceaef0fb74a38b0baaf4bb4e7ce6093a3f2a5cad83115bad7a2acd78e9096956df37f2c0c8b21e1c910718c5e9c2352a92e885682bb9351ea9854d4cbff8064e99ce6cf5a9636f763662018ae5f38797ade8e4372ccda841d931603adac39f5dd7ed4d45acc2470c3c36cd4f9b801e37411d7156a8326ba890cf7446f23df68d75bec5a73968bbbdfd4d0ef3b4c2fdaa65aca98b1f42b3b4e4b14f690f1fd0b8d1d4dbe5f3b1dd446a7ab881616fde91f1eeb49b0d33b794e67e70beacd548e73f9634d3f60ea5a9dc7db8940455cdeb141e598d02afb80f66b2a3bc7431ece575ddeae4f282fb8a9dd2330dd79e59910cfcb39c3a481e90c5ea898e7b85d398997d989ba7dbc6d8bda506b7c781b8d4283d07430b04b260492d1c312206d5a1b0846302ad83459eb8e3f28440ac7254ac621520e19dd999eacdad5d6d005c6acabacc8e0d928a5231361dbc7d6cfc4d5fb220985b179d5f8bb2c2f9da9d055fd44c2067af42c0c275926dd887fd7903f243c1ed2043ad74a51aae3d1b62d5feb419139b2808c2e4124bf11f8499f91083976e5627b9fa549307271666fe2a48aea3134b059773ded5286a6d17207163d165207391ea2a02bd7912dbd2636202ca88ac8232983ec43a9a393f8ad7198389c84d19ff24ddece001b14660ba8ced521af8dbca28594ce36c6aab9b1d7090757c162428ee34f2201c1587a5ef8dc94e9e30a15b9b99ca89bd40953080c2bca6c3864e76733e65e76d385a2cef5ce9edf4ebe73ba6ce0df793915803ba89c98633b421e1c671756e198c4a009156b9c626a8f496919d3361a48824086e0e7a027f9893357ad26b951464e73009c48bcb268d2cd411a6cdba9e3a72390d27641db1401f3cdb2a5d111c06f33fbd4a91e489077e101bd3315b23189e4ce19414fe63f398bf8db420cb793e2d291d0620391af74a27e2e532a54de55abbd8cb06575331c89d186ab496cd2047488832c6945c12aea35cfefe4c9d70249877607d7c6795b4c4cd3836cd0ff9dc1c9e37888b0f8369e6f02218d62572876d0e9e793799d756d7e917a3ba8a5e07d486bc1d0e850fd12033db981d9a315ee9b69cb95d2c4cec3822095e1ad2cf99c935bfb6e1556b82eb817e8f7ec4c183bb0385cbb4fa5ae0a6626dfaba937defa3fa6049be2663dbfff342a9bc7318343b9630c33a9567a649384384d3807258a51498f18407c841986241d3570b124d0ae041e7d7c455e49dfab2fa48bddc21a9383ce82a418baa47903f4cffbaca86655a622e8e3dc82ccef9ff08d7a3f2fc96480a1f742e7e694ff8c5c0993c7d3f78ae90d07761b5b47eaddd9014d405bd570dbf02c2549c7bacc07ad12671242677264a08417ce6ca060e8c88b295a173c1339938babc36a9bb6aa88b94b36a1326a4e35a5ea912f960ec7d67f42bf9d9e5ff56599b6ea05d68e348cad5985dfcc530bffffcfe51580198dc064fefedede827e5d45ca53b2435a6ddf04f56a81d8db74bbf7d5848d7643da248b49aba4f36c3e285c3b9dd4d2abd97dad0262e086dfca04a45595fd157a51d3f32bb51835cef8d89de0b4987fb82bc39e5a5302e0a44a7b0da6ce2da492d6158b9a556abb9bb884bdc3c25e9dda93a8623425a2b92edaed3f05f7877bba3e946b805a2b7ddde5955415f248697e0a8bedcfbae5f0ccb9de85cfe490111d206123b4c0b0f995e570b3e2ba1232bfbfdc291d86d6ba2164dfd8dd8551dce1d0ea06be71ce0931c041364251a22a4069cf190a1dd76b25d19aaf6d6231f6910199a6bfbe7acf3dd103afec100e97affdf10383a5c977b8a1d8c66f69eb7787e0b3e5946de4d9f619f0236ae67fc161d4dab64823a5cb04007d1f6e1324adba8ad92ce764de589b78ffb6f2f9f25ebdbe824a353d73f6408ffb080c7d12d9321df278b7f8cfb7966c7889ebed2a7621e4700aa73acc4745460421fa706e7177af9a4e79da9f9f2212ca6c24d5fcdcb08f266f54d9030196dd383d919357069f41759b1201b09e121978f44b8f06e1059f8b1d02175276a104f534e69d7b7b8a0f0416987f312e74f4ff6e6155c0a4361ee0b272be87b5c9d5c7961f8b1fbec196a74bd71ff782b270b9f159472889efbdd6d642597ba0fdd8102f4b5f2f5868a30dd0c48fa609c516d79c6e56a1dbcd9524ac9a9e5470b62f7495ef78965801dfc60d9b88d71a3fb8b05979b001690b5cca912c766d1f4a80a356187092952744a8ea9dea10fdc472ec22a895bb38192334872d120c6f3229ef20da71080e7c181d32f7c4f40210d21bb9e1886554747dc662f109ca2efd1bba5a86cb841d8a4a859d87ddd46c3989716d00d28045519fca9669b7916e014d9fbacece62b3c91a419c18f8578bb9f1246b227efadc082a1d1c980198afcf379b273873fe588af92cfb41a00c6748e95899a3756da7fcbda99b9db342ca5c283e8ebff42b8dc8d2e5ffea178b828df1307a7fdaa41980b219a73b8f738587051b6367b9f7905a72246c0e6d75d8166e2677d17b452591d8b2ac39b6e1f4ace775620226155e9380afa18077a2222a6c205522540de557ff5a44c6803f536a2699392825311cb863051a0255301a437cfbf11dc3f48890e19b2a66c03c1de028fd9f73a38105b2349291f95a326f13edbb7a5b565f8a414c7154e0c98f86c3b5ff3f9becdfbdac2238860099edfc3d97bfd43f458bb0ef3032a556ee1651f0b256f9fa76ca8f2466488ae1f14ba9dbe752e33887a95c39c885903e6c62260c3606472b024a522f74e7ab9a65a7e93557345e0bed86677cb6371e34aac7b2e788a3a99652a9ecfddffc8177348beefcedbfac12c223cddf3bd84cc7b669fd80da0ba2eda5ab3253fc15c6232f11ca6175e49eb50091b1a3662c311ef3540dcb59effd63cf9b9c869dd453a87b40afa9e9fd39c783945e9047c1d733aa02747f1a7f2d2ac1ec7a5b618ac97df0401774622d0bae99164b198b1acd3b40ec6c4e6f2d036a8b189de92ded9c1698c4a16ffcc4b8f00c2e1c9b2198e7dc7cb803062c1792f1c077f11bf67f184179062f007df288d56ae88b3bee7e1aa351d37855bc4a493870f5e1fa28615a08dbd212bd90823a2cb7f150fd8b066741a7958ce0980ce1dafb393daec341af78bf711b87cdf6af1cbc43370a2235b9331a9349873c74782856698598a9a9d7493f8c7caf338e209e1d8890ca4f13370b6c8bafd92eb8464260476f3b31d650f48a5ea94c3aad8cae481cf64eb45044505688293385cdd589037858ae5e5ba165080f2d1bcf55b73aeb73d5b24ddd813048c72e0c88c9188cc25d5d330d71eb7619fb9759d5c87f0a12a1d76d721096a8a9f0cde5726a65bb90f212e4c06333665b4cefade3a12f20295207645f5a39c3b3c9584ef71e1b1a0ae1aef3a927c41b951877de11621407eb7d3652e38b67a08572d417c7c9a2f548ca3a03b0826e937119eade773389454e1b38f7ad3c555c290ca2e74d86e0037f0a508e4b3e25a9fead6b634538b41989f7df2f9db802e051cd1a830e0a0d1322c6e1490cfb63bb8cf6ac33d4eb207967f7b833b05d0a993d72b7b6e25e2113119e1d0ce62bc8a3d2c8eb12d6ccf888467092412d1f36f3cb0740cd245d4f8262557eacc497242dc93c80ad69c255282cd9d23976a9c9931d0ebc21a28bd896a7c9a5959085712b7d136397e10c8169a446fcdc8bcc37888eafa6ed410202f08236b3ab344f1d8ed385da716499863c7b4f2446dc7025f5b7c5ed7f99aa3fea589df27b7a5930e185cab84ceda6e23df8cf1b78980dfbde5a09ac2995ea6f613b4c9d408790b86f855e7dfd70f9b4caaad810c6627e28691d07859a09706f92408dd2e640e23e21fcaef7ee703d1483a8d0ec45737c3c1537b58201f4fa67a952b7ddd29306121e9af142b33dc877ef03d56e7323ac62d7286dfde66dead97d63af64a3e81159f593bfc3732a241622fff7d7d99300a00f253ab9090a3dd65b4353ca81d9d2bf5da9a2402f8aff1ba52920d9f3a346ce24ee93ca6b3499182ae499e56b91a9ba4509ddec3a3d6fc56083e3db449b27540ed8c966a8a5aa9b0a53fb18fa5663194858db68f7a41a82afc99b2e07d5067d38c18d16f3b1bc2d5657543c9ec4b196ea191873da782214c3ba50c4050dbcaaccf9c9e6cb871588ff0aa1ebf53ccebd1550899de891f9fc1072c1673137e144f2a682994b0558d4406e1827698047535bccee247186bcfeec9dc36566c2c35a9bdcefb1410473f6f93b6fdbf8713c1f05e8f71c020f5c46dfb42ac321be1457b55d0e6f80403df9d188067d4630d88d1e74a4ec79db069c82bfa473daa865f8f2d00ec73f1efd0d154e0d1f1f699ab3e0af714844e0f7b2a5383c5b3b6ee011b30639ace512bbb6fafee0037ed2e742264807898fa52b2b5ae87ac688fd5dae0b6a31aaa5643fadc5c927710b34d8aee85a381e81cc4f3a382575fd6a9f50e2e57a28381d035bd08a567fb705f734967549e770d8b35679542df5042702d4bd79f0b4ecac42b765148ef7c95e3f321d779ee21fb8ddc7cb0d1ba160220a0a97eea9507a859e2274093f6699566d94c3b5ff32f5c496fc83fe4cddb8fb4bf96a884529eaa550c7d67c9e85e02118bbd02a0384c37797aa048529b213f40be273c0e7715b0bbb9eed892b780004ff303094c499179b77ef5b1bc100d37232ca58ccedb9b74d8279f47ce3b2272eaa148a733116dbb359730e673101d8a1309017873bf5a7e4364e5243ccb4d6b05f036f9df1a955683a8c0e79e7eff0bf602fa5b6d1bf1dc56f6fcb9d997b339de3f0b774f99ea55ce2c8c56fa9f815755f470d3f7fec8a97b0b59d891c05dff2024d07d6912e62d37a4f580dbd44ff7109d490d01f992888ba2632b90a319ab0248c4c31855b4ce273ce64cac691cc1169763ec9a4460948507360b940fa900945f1506eb7e2ea9035f156a743ee85af80ddf2d46b11a77d409405a97a9d1006d401674492a0e9f42420117581eb2c8bb63723a6a65f944fa89e8bd0a60f6ead76f887852a95da9827bf433fc5f133b013403d7bec8af867c6e74562ae4b7aa39152f736dd40a3b7bffc73f6694ec3f7df42f2f600d3f6592ad4bc967cbe02914c55aa1af92f2fb892b2debd2365e014a3be6f5ea672c8dbd6c7cbb9edeb6675341c29bb3e8abeff749ca14518172400d58a42ca5f0426281810dc2322ad31bda00f423daf930d132e34ffa9b40e1ae8a223ffd5f53521b1ba77e00a46b791b62666a6abc14e67eb1b7cf6dd7de3c854bd635aaac0db1f6e8bcb0de37c194facaa016b5efb440069ac07ce5745b9c2ab4c64f015ed093d4ef6fd1758a435d0a39881becb1911e3b717295bfabae0d7701f7cd829eacaf6062edf317c63c4ccb6637a2e6f48edbbd97bb39e249998ba5ae90b171694d563da8011fbdda9308a7f9e104398cfec160a6787dd2cf1e525b2401eabb914930c95c76a16d6f62bbc227ab0365138ad52b0c647086e9d35d2485ed2eb46f8a38d716595a50d83fb59da23ebeec4abc36e360cae4600924bd445361973b41c74c860c361aee7854b2bf17d942f8bb615926d559387a283a3e8cabfa51443c38192f13a884da338943a888b324354be56e7eb4a3e493ea3e8b880f489277207f85cfde82b2c2ba660fb309548794c8e74bc19c2fc0a949895beecf82e6ad07e2ec407278cfb980541f8fb4632586927cbf3d75cf44251e8d1cce584c0493de9ac54eb2eae867cd2876d1b94659fb985df8134eb5994675f2680582185f1e51a229e3f0bd5cbf7f92bcc7ad32d168df143c64b1c664497844f6c9d88ebc956224141b7d9040ce02a0ab2d3bcc4e1d1a7685dc3a3eed02e132f42dc8260614054510a66a0a53fd849892f4b5ffdc99399c03e9d2931fc93023c15208cbc834508cb5cf8c59357231cc1e902b512353bdf5da627fe4d95ccf25ef5f01ec78c57d65b08ec10d3680bba00ba1449674bee6c68aed364bf3338c5896cb8fe354e5a75ebf64a7a95c1a607952275c8f075e8ec1cd8b0a024e2c1eb6b9fb931668763c7b27e307fb21e88cf5bee9680d4fcf80df58c87db2976567753abffd63031de4a975ea2ea2b025d9c8ae1b899177bbc62480c32e44c14ef1cabff8dfd201467466a2401061d43ff4af15293192cdcdbad036442d28d6bc698b21d484f749d23d843e209f288fd7a6bacf68aa80593cea76d7d25ae522895450a6776757cc5e9805036845209eb4aa4acff13c7e21987ad3cf2fb00bff4b84ad89a71d7725ef5337b2a5a9a3980e811c621af95f7edc2fa2f9117da6a1331de9ba1f6c5455e31c3380030c516b7aae375ef1e65edc15623148c966f24f81bb56142d69c33b18ba879867cba905116f4b756cf20f0a84c81b4c0e7570da40db08c0cc0c58d27ceae598d3d9de77d2a2460848a35ae828e059c2e599be6c43b6452a453da2501d1cedff025ff85a83268ff1aebd0837cd655e9690bf0d4ee64b6f595fa99cd7987254370ddff461bb66b6ec83054029e73d7b549144e75d51454bbdcfc8eea1b53cf67edecb319971bdb8c5629bd8b9531572f9cfdb9261685380cca032719cf97dbf6ab9c487fc5999d4fc5b57bc28f13f5ae79cd19d6d13a1e19a38f6b4f03aecdcb46f868edf939a5f56bad269bbbddf81225af8694d71826befa0dc0b5f12daf147f0773fd6daf602176d2c4d8de01b4dd0e31522c5b655dcd4b5db7057072828a535dcd43c33ac71d1a0dd70888471916d04042f3ecfebae95f6ae2e43d6ee1fa59f281a97041d188cc78effa8e93f354db22b36fa9063accd9d26beb974197290457622f1ba735ad5d846b34bcbce6066f1decca7feba76082d5e94b1298478bcbcead143a07d8f87ef551c3d53b9b9b29d505be550cafc9dc5377ada02cbe9b31cb3203eec2370d47285fb887c7393c33b37089e678a23b55af8f89eec1cc98d9672e8742a8b401c0ff1d85a99e2361e40d232302383be9e2f9ba2c2c228a0dc6dbf6cbda730ac39aa1bdc9e6f4b90cb34226ff804132b04630aae8550328a1ce2ce83c2fa191d190cdf2418e475ae1777c07734586b0810ddf6dfe9f35ebe4e32c879c208151bce661a0d840776f8686ac30f9e2a393aa7b507b9b71065b2914c7984a77f8633201d95c5a7bd01e6230264acb15ac8be289e6682bb23ac267a379a4320a71eaade2d233afb36b7ffb5cf9a6263fe9214dbb3db5b3b9450fbe8e918984648ffe503bd842edea0fc87be72255ee1a9ff4cbb773fec76231d303d035622f2aa10006ffd133f8251cd75685cf5f777b1281ea2481a6653a25e40bd525aa89c797562aa4ea6940012ca385ab8b753cdcc798397fecf16ac17ace168d17a801ca53c078b473b5ad43e6f4beb04e3dbd484eae0478b003a40df7620f58183f15a96f481c9f4526881d3103b313c5997b13bc3fdfa605c65c6346c24972ba24297db63bf87510505381220f2588bcba52d49d2aa7ba5ab0cb6d16af5cebee86a9f44ef4cd2b25fe56933e5f9d0381a574504c3734587f153161e2574bb194fad0305eecb082dd7ae5ebb127bf3bf16501176250293285a2ba0d167f1e6b44a770fc97c0dcad60a96ef8cc7fa228235ad6dae003ffe697bfe021820cc448b7153e96d2c70e6bb5f7c184ed0c450e2b5c583314893fd8ec6493f827ea2e794c232f14b6908cd0871fc79e150a78108c0c40b5f78bba3574d4ecdb3a07148b0c7226006470bb855b62408d3f3e13531a2ef67efd63242f02d8e554df5b386e761987650278a4a23657ea1979bb76d4617327c0bc8e2ee312597bc9a44fa2c595799f3123bdbafd8ce9d30369a0e8672e121b8a1e7d9cb85469187359d4e7737b89bfcf2c9fdaa5bc400cdcc201acefc64deb67aa23fb299bebb32435075e11d60a4e0353317950ebbfc9d844ef863b93c0f63aebc77401008e63345b9c561b2c3d7437745addf1acc4686bc6b36480038517825e6350953e4102a3496eefab91bb87ff5979ea13d62599758adfb02275251157f1cc5f6260dc959790091e281411d3f15df1e386c447aede511bf98cfa4e407e9c184a2c6762e051c56ae31c379eae1f3b3f1bb10ce3986495feae3e948dfdbda1b6ec2be81e93a1642ef101be4825ee7eaaebf5fb7149e07822b22e338784ef4f9578d955451fcfbedddf2d00a4e22765f72a674665c0c95e76813105c0fb1d4c8745f10a8f5c82b807c751913c9806e4a819652da32bc28565272b67cdb88c011fcc3dff84af99d7e78db7ab9592fa0825d3e3f2268a601a0e5762d852fbd4178f0eafe1e5bcccefad9224677e0ed045b236e79244dcd421e7516dceb4a4420f6b5b134843b92704407084a42a87bbda2e0fbdefc10c1ff3eb138a6cfc839d916a7cf935ce7e823e7c4729b04b32a1b22841c4ab560aeaf5d00e4315d4d846cf5fa8bcbf77a9163edf3caff70d7e3b3810599b6fe15509af1d6582e1e66c9aa3ecfe8f9bda79bd716f4ca87225e3a559fd6becd5b495efda2f075d163fc6fac84b6f05dc1c0d42a35a1cdb6a76d51946121e8021f6cfe5a9be8d574285ade745cc8bc7c9c7cf8af77c5bf7935eb44a6d1c22c6cc3535be01a376a8d5ea1818c611825cd48ffc964f4afdb358c462665cc56c6279ab182f5d7dc8ea207a69efd3e25b40b222b23dd1c8b1e71a353611fae266d99f5f1993cb8d7b8be117cfed0ba3b5a5f6055384812d3ccf103e2a7a301403f37b06dc5cdfbbc4682dd48fbb68593ff5273ccd5c913a31af48b889478ef2038f6af1c93e8288e5c21086d26d8a9c6f5fad73121efc060436e47ff106e41828945ec00317e65f88a1c279bb0d2574660effdefc16e57037412f2f6d8698f44afc487d464635e31f387789f982090264e9758c9a26a941764fc5d5870f7b6d41e467588e953d7c22ee244b8e3c1bc7061a7f9ce421199695b2aad0b7992bd7944f77cbc5aa05075a3e29523ae2a847e62f8cb5a2188a79065af4f7f523de6f72040e73e9f138e9ffcaf278514b11ecd3bbbeb3f01c9a93688131be2330e2428bca9fc191e61aeebcf9b36a4a5d2d4fa288da00fbc93c0cd9e17bb23f33fc5f9c34aa4dcb687bf3c99470f6ae1e4e224cb6096dec3a5df20ff1f9dc7fba413c8c6a493c771858ca2d66ea7e50f4ae7ea7d208a588cca07854428528726985ca515fc81c5295efe9146188f69cbc35db3984de903f3c4a5a33decc07c7599e93b1657f7619d04bfc94a4abf16404562d927d7f69c63f60d174a6272c9cbe6946ae3c75651e9b031ccca06b26e315b3e08ca67e6f8fdc53c9052b1a076d2e82f7301e2357a0e3677c0d6c1bc3322c6df859db2d6798524cd13fd643dc906d7857fd490f29e7f2c2c90758d1ba18c77ed0bf02e3bc4c9f27fe14391700c9738719453ede67b7e61c1da12518963c1d805c499772c58531087535fa9becc71ca6e08af0e659773402e1d3bc41081309677923468b62f48fa0524e5bff838000bf7c20e3b09a4320c34e65b5ecfda9c0bbd346fba3ec55d3f7d9e591dd27a8017ba6405537ebe8e45a3b99ae705919022c542ac3dec552e0d90ab6d22a234069f2481c0a22e23ba1910d10a25bcb1e47ba5428919f9a3eca4574ddea789d1ad5682197c06c5b7597f2789ad766b78139c76dfb515a488cccdb8870e6f7e2ea808c871f22e15348e3bdeba84ea6046f1230bc5ac9c76133c23cac4e0ffb8dccc8dd44a88393510a8a90b0d4ba1c5157f53ad7f66561fe7a1faafb5a86a7c926e7b204a7ef89c8faed07a72f2fda45fda5dc438118bf2608c050761c1a8b38c017d7fd84830467a31621e5c3198c53c8953f2f55e8ffc1fc34b138bfb76ba4215add77c731aebd4139ecf20fde473ffa67d9319a6ec5c77d901f337acdee2f3a4ea53c391c8693dc1afc3bc9dafcb936f808f38026e25c77617e0d3a64a9682365fe56a096bb292f9cbb8a621366998face7da75530e2d4eb31bfa71c2a1c6ee63ef93b4641fb63f1404b8480d9f5cd92cf81c6f10a03e4aebba045f4bfd62a61d9311649367f76fe5c508f807f2ef073581fc943c55d96ce4dba8a962746208fd7b1108d31107c1469f50c64c05be46e0342e54127cf33f9e6723a296db654e740cda3681ab0fe2ce96a69ca05f66a9706100a69c22b9118d99825b9895007f17553d94736c6ad14a36eb046031b719d1bb2467a58e436291e2f3efcd107fc7ab585e3e3a5c2b90c26f929b74d1e79bdcf3fc7c494b9d9efe377f4edca7a5b541e72d23b4d307267a167274547c95db39059b7ed0026c847eca0c5cfe31a9810e355e1696b4910e0c15fc21f8a54bb15fe59370a321f6e94bafb63e69ca01693694f4f9b4cd587a08caf3da6c71d0e5b57ab7d3a1c47f0163ef1a1b07eba3f59185eeb4c88c2abd8b5e72037b0a00678d3dac9b3fade568d91a2c9bd99cbaccd319eda65c603ffe1eae26aa6e2cbbdac4d0e12949a2eebcd73a795584193ff84a70ead32ae830356ca4d93836299f75eb0f91be4859433245d63c3b4c6960579315ee75f1d8c9a8e55ad6879dd8207cd5c88e5f6a52e8feb8c04176fa98b0737b0766db9de0198c020d4ece4e085a365744193fe04da731a40b20f5b2ffdf80918a2190e6c9e6bc466c9d0464ea2bc008f774a7b34806799d9767857dab8b3b2ddcf847a00bba537cc34a17b811006d0fb54ed1fb2ed3ca8411e895435c57e0ef0f843ea6d12793474ab3f2bc54305cf5949f2788bb5f2b1c7a94a68503d68e3f9ca28d58fce308098436ac18405026a303fdfd8f24eee91edad57afab8009b4687a20f0b297846d3fb38954d04ecf0a58b7e375fab75b6763c5eff8668396461060736e349ef6a347fd5e99333dd28f4cbd89dbab43b9cbde28f340e01f358d81719dddd295238c3720eb068d7eb8f44a49260c806469db3d7fc6e58fc2c09cdc0cfc191f4c9765891f226149148f918175fe9d94a3a9e2378736512266b6aa8fb14caf5e91831858e337455d41bb22a9c4967a4b85ea33936a3ac0b24f056ead4136bc3bbed0e8f1e69a69b6665bbf82c8c3075198f05fe7363893f614ba17c659afb23e52b5fd86a28079d54ee17c168e63dcf00f4c6e8fb487e63551d57ae262f45af3d305e9a1254e9cef13afeb6788e0191a24e3732d0663b346c85a8ca981eafe215889237594d72798e0cca6311c7a36403d39aae8b3bcf4c98e63053adb46096a25913d0c0acc8beadb9e5b27520822a7b9807e7a50696961a9c0b175b5506e72cc4ba4ae9f25b62b80ad1a8c49151e81d71be5b3e8eaf2cf2eb465d85db4589863ddca25e1328c281295528e1305e069dc6fa888c068c5ffd2905f4db7bbf55bb65fe615aa107915bf583266afda91b320c9946c1dd45057d82521d3ae979791eaaa0c5fbca4591a84690fc9619ec03ee9afbe52414d4438e224bfef4390395af52a38333e4cdcc9b364ab04934a90ec40a3bb75f78d16aa4b5d693e17008bd26bb2769f3d4933f570ef22fbdab8f02ab1f6874c2159564f0debe601314228b3bf87a01e3948cbb96b8096dd82cc8bdf26789bd20f06edd05d09a1ad195d03a6fca6f6ff9dd9504b039f3badc84fe1f5cc7336c619f78e36fd8e04c83f2730f3bd43ab39f5167b473daa3e954ff0128136e1f230c21520174eaef977c1345891b05903e0cf38cf10fd19cf4932cfcd8c44b1bafac4bf76c90fbfd424b8038f5fdf8f54f7ef8de9eb082ab39f3c1be3a06fc797c09a39c60d3619b137b2cdc2c9e3b2c8be8e779ebbe210dfad143f046de82f25f4d8330e4b1994aff4cbc50ed6fc930dc1ff42c134543260e0b2b1ad6a4f988a0597d910ec6b9fc2b4bf68b6b604eda2ec78b7225a664418302af791381b7d19f24a23869399be4fd768bac64c94ded752fcfc8d2af5e90a4bd86b245fdf4e0756c4700763945e421abf6098f8abf66672a0517088c2daceba4da56d518b7a5e954f276f45b526e15802ca032d9a25f4bd22470d48eb37267bb31c392e59c1f0587de48d03c9485e737a4b097b92c81c9976f65e95e06911294fe8b6a03f53f8634c3578aff2f9b59ec558663303c2d7497d1856a6ebd646e3d7c19a6080d405787a0942d2cae6675a81513cf6650338eae985a7a4e2b76e48b8c5b1409e9b99bdf302cf49cc673bee819817d3de9e40a4d3e19b8366cefd3d589acebf2e6b0f68f0ba24f7175282f3fdb963747724be18abb95ea3729657f6a682acd3a3bf626edeff3478f2cf175e8a03b4597baf091ff3b6c276a9f2db52378b9b2d4357bc237ecd1f88b1ff47a2f6be2374dc003d563a88d0d4fe5d1851a2e0a712af13006c7368248733431af1e4556dacd9c13c88e182199cec3c0cc98a3811c3ae5e404c1909cb3aa5f2d463988facf6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
