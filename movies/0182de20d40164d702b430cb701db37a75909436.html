<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"05d43519ca6ad3500d133b439822d748c72e33cae774c63b9f624c39992d3af1399e8537966b21bacaa306b0efe0c2f8187625f9ff28d34f33daf2774773493fd0abd4766827d28a7cdedcd67546e62540b4c54268e0d86ec5295b925270bb47ecafd197b8629d97bdea9a0ca5c8e7b88e00e21a01b3eda61c01760eab34aa4ea19a22b408cf827ec23a2a38977a9f6be4eb2e31bf1a301aa537168034ad8dd2d56b65723c0de31cf3bbf36cd12e20efb9381f20525a044aa662a3d4b012004e916ae353b1d99dd45f2a3ad5b5ac82ed52066941a1e21a97006d8171f5cc897f96f9f9e076ac782e6e15145bd13ba7561a4c3c369372467379806b6c49524028be94898daafc9936783bb2b2629f3ddb07c1261d4a5c5bf3b8020c0eaa3df23d69f0eed6a081551f62c10093ce195ef4e858ab23c2116b0196044f09e10be3cbe373e7d38b8718442c7baed93e7df9adb4452f7a5d57b9de60bdeb4200f5bb61c5c4d280628178ec7469814656330ec66ed10306375ec8089fef11b340b1bfac20e48e5127a7b1a50f399c6c996945518d0b885ab0c314f79e03c448a8c2e61b8e88d4b6f72ca160f9444cbfb33c6bad61bde8a6ff0efaee6d69f415b33238b258ff0a4a7cebef0353461525cb706d9bbf423f86ac0f5477f32f237c06b2b55181ea681b25aa40bd6fde482b8626568620c719cc34a10902e2ab882996f2a4a7ab25850c2df7bf734149851004ec8bf0957df62c2a6e4b7adb7bda3703ac6c9aa7a7997a53ec001140d6c451a04d5cd077fbc8f8f33830f361ff00e6089d81099cf64d1d0cc1d779c574869bd841e80bd5317ca2af2b923c20b3d4d978149c6b16714357d673bc8c302ab60a133312168203a4d63ca85b76e758bb7d3e18180816e140f0d3208284e8cc73cfba1aa88271f94e873ebb985255676b1e7392660775ee9fb127f6630e71dc986db2d891c53be8fe5fd3f756216f23f1117723fe7c7ebed47884cd104ee87ba93bb5731b43a51aafa65322d988f1f1b0216e1506cacc60902282ab3c94711c697b1acd4b78d55e785cbc84b90375e6ceceb56429ce732184c702df7affdadc39c225b315f3c648496223c804a0da9c1eae0e0c5e43cb28f0e513be048e905aacfd42d8444e9da3d4b64353be97b1acae786342a24912c8fa69ad046e16bb32e648366ad271d6e43bd4d97555973eff42b8907b9479f0042359a8b538ae55e4631ca7eac3ccb9525cf20d5cd9e614f3859fca86fcf604f4b4bdb03dba4bd3d9e0a956b61dd9e4677ac25f1c206e486e20cabe805eabc3b9912f206efec6faa3f0ac51a0e774f5afa366cd71ef05c596f4be09cdae0488b5406a23b5f5aa9142b9404cc44dd4d93a6c3b0466dccc39ddc40b8cffdbcd99ff04d7d159c4fedbacaf05b56c28c4eb5584046eee3d5feeebfc984db40ee8cfd77297c1d2afb490c26bc372e32835fd3facbb4357ad6cd07b6bdaa36154aa490512b65c7909d801a2fab472141cec486d28d1d29ffb30903234b36d80450794e89571d5eb25eee335977ab2acd51ce96fcfafaac37398d8811ca2c31177754c5035373fefec810eb1c5eba35b73b80c7580193b9ff379f061b21f3eb3d43aba3dcf2bf27ee5dda982ebb18e09b48ea155fbf22e0712e9884649ca27fa153b54ffaab59a85f29a4ccee8faf50a480d1aa1fc983a0e818a7ba1f3dbbdf95a673077e16fe8b6a89428502060e9872a550035a048c1c86049edb656b06e4036d20dca4f49079fc00574c46335861d346c6fc09399262e87c2c716d5098395905c6504206c3520dfe3a99822b2a02fa483f9eb2178890ee8cc97fd4b4a6ffdd2a95601058a6631e9d2eb3f1c911aa21db6f5cb54d5e9ce02301480ac43b38edb5cfeb1bf31949b41b0c2616279c121ac7c2e73a3ff095884c7bb5a6b7454c39be424cba752600a511a9929802a5c25c5f584f02a3e1b15dc6c6d5ddd3b76a74621f848bca34a6263cd30d777b104420d69eda7be8bb51cf5f225fa70f1b949ab15f085d0a4c8d4af5e2ad8196ee06a54be064a948dab75577ebb65ba30e8063986aa74749811f92136fb873992a6c8dd6808b284d1816dd77b103cc2059f54b726dda2b0d20e2bf4315708ba4b137045dc7584bd4139c2e1c7f1b2201752350cb1483641570f55979f644472ecb43cbbce81952a13972daf9f8e8dedc57f88ad2a889f70ae0932e28437bd7fc3526d307f957f092ab9ac2ff92c073d51d7a60f49b73c3d74def4f4abcef7077ebb0fb1561e5a2753161bc29c4784ca331a855bfa20e338d9726cfba1bd19819511986618b602d400208657c38b77d00729628bbabf15a392a8bb8ee2efab2d5b7a805ed33dea9f44b90c41aeab2367d21b9e4d43e8046334566033ae47732e3e63d78ae4f2894f9d2e8db6e4609257cc49aae7e79e297f2fef11ca18991563da1bf9e85fc936f1a7c1539d0956e29f4c10660f550222d7432c054e4b42421a68c473522934548e20ac41966dd978debf97fff93ee558fae1ce289ef8479f26887c75ea0d19dea239d027d9ec3c06e7552b9d5a4edcc7ae5c3f5714da5721ea3e7a19ec92ce1971500e886c86a0d4968ec295a50d005308acc306a613d4626e01cf04484df4783f2430a078731b87b0b9313d8d6f651f1ca10ba1b653fa6b3f227405bc6e90a7e321d964532f07470dcfb8ef5be2a231bcd1c8e84bca6421f3d1f4798a9f06d33328446e23a10b7327f01a12a6fb7c6d4a8e12b428fd1439cd9f54137ca51f294c9a51d1486418e3030820f2ff72bbd0f849ea49034156d5f3ac6b7cceab9aa1169ab1a1a16e4d4d403996d0afa9ab0ba8307d2608d6567720b967abf994c26d04a2e96181187903241fcccf26d5ac219600953a8772cb323023c4a0e3616ff176c0511c29fb5dfeb75f8958ba71b027754e8d13b618b66237d1117c700f4474c85be4bdbfb81de9e966fe537c14c12d217b5f10de3979037d3eac509f05d6c6611240f9e6b54744fde666daeabc9dc56fa749a38e9c17714e55c337799abe11ae868e16286a5657518690ee9b1f6299b1e1c739fc34cbda520ac85fb1f22fe8c3ad84108ffadce62c0a466560b00cdf706928a4ea0d0f944460234d50810ff8200062a686177a5ae42f95be51b0040dc9c33c270630ecb5324256cfa5ca5f1d151bd1676f51df40ee04854ed7ff52b239809a57c99e25e90bcd33619b01cf2415f1654245f3af5ee335d9295fe5b9bfc6a1688b59c841c03a4ddefe6d66ff321875cb92c93b84cc70bb3c99c0138e203761b9e3dad28765ec7d282ed33fa6ca8202a807d3dd44823180510aefd4b56b6b1d8898fad7524db3808cb280f1340bea917c6efd235c5997d291d02e65dda1a6c7f00a1f5857f017494ba45f27576d4811c6a49a74e3aa9d9c790a8318028c04728f5eb2ab17c6d0beb9cddb479498f257f3e7c0a7aefa6cd845d92f16179fda1de2aa3db38e335d2f57847898cf0871541ed93c55fa1e60d8008435ea66758002ae9ba9892dbc8a202925233b1bd216685800fed1be1c7888e911bb7fec8122a38162e4103d753da683cd465be4c93979ec898de2e887b6940640c8a41b002cb6f6959d63343b511e16c5df98b23698cb97bdfa4b909b5ca1f4b6d60ecc732765d930acc1b699f667a443836f84edafe4deca0c2efa2d7b7f90c829849436c8355d84e528193472982e1fc148b9aefe63fc4b67cce109ca477e9d1c7952ea01727c32a0cbf892abcceaa26ffddf4f776cae5fe74ac8db4f0122da7b4aa90263093f3f87b64279272fddc5402406f18e382ff6d569fd31ed6dabbd192670ec0e700f882abec3c5a20bb6281eba79099d41ea782a314644ce71183b5a21a4b94be2bdaf22df50dd74ffe72538a96f11caeec6afee0a1603f22d1b3448843cb489d7582eae80929f61acd830d4eff1c6c944eb33bc7f52b7444f1146fb88fb95715c86d28d11e5addb86b384967546552c433cd0f39fc14267da3e39e2a4ed86fffc13a1876fc8761425477a8a87fda31449f0e8021740b1d3602f60e5c2243c284805d9b0b9ab447398ade716d9b2e5d760931867c15034c84148125209b6b85d2b6570982f444d9a6d551c0297c06dc8d7db1c42a2b6a5f78352d69070d8722436c225f1f0efbcb6a00744573f49d250f02b490e4c13273d366950371d1b4d859dd011edc7ff78b130a6946f18590f6c97ceee9d403a5f3787d576daee8b98a0f2276e05e65e76491d34a127c07b629db578715dad630a7133ab167d85d6c2497a288ad5153f2a3b6ed057474deb5b6ee0e68b5176792dc00a1824d8aba6c68935930a11506dcf6dd08d3ac3c3357404ed5ff0e353e4108a8ac7eef73199cfdaea903920d36524051e2d99082170f8d03351702e007fed3c23b966363f224f0313d214f46c1ab997d71fa218dbc9d592e0c2f3e2d060db23c1029058b3d648632ee87469b1952fa8c553eea23911057bc29ac20112550e11e0b8dcf97f529954416804a0a19be4e10e932b4658bfed117e779fa57669db7293be1518acbf44993ebf7dc632b110219c9b1e29ec083f5b8273fd5b7dc61f9236a956a04fda8588a863d5843e806088b28f0b0d5e015774db36b298948b8c4c853732a618c2adc0fdebbc1a41e8a571672858ceca5a7d53582ca72894046372773f66d896b05e310ddab0de74e8a27b97376505238538b19019051b6d017ab354bfe68a46202191859f73c285bada06956748781280c2411078563180a4d4552d4078e636edd92de3b1735c5e663aee1a6b6b9869722d802830d684bea013fc013e18ab392bc1c38cdb689ee40db65777a23857f47b6207a662056ea33db2bd83a0ebe77ee07540d30f30400e4bb064feee51e97316eff1985efa6bbce6914754013dd0da1cdb0c8baf45a2491a9ac75c03163d2d45006c2ff268a85db4f1617cd72ef2132102a560700ad1a2cfa49f858a20e023512ce7e3d9ec8c7d15c5ac0c3308422ff9687d0ef3796d8df121ca3d3004099d8ddac1995a83f70117804bf24fa644e3fe7a6a86ff55b057baced3a80edb262ce87d0a5f156c577f2c279e48b4346d6c031dd13cad1583a02aba629d2936281ebe50e6206a359f45474216b2f19ff9fc996eb6f4024cee20406c79f964ce69a5fdfb77847bee5aafd3acf20ada30059c5156a4699abb3b8a6f4d08596ac7522e2ee3626df605f7184687d6cacef7f80075667645393c52456f9611ddaa117b626e06492d5ead86d7f60a42bb89cf2979a04332998593ed6339fa2a7d488a1a4c2a9567af80efff68e06d2af83b7b97bc87cf533e5236c3beb43a1785641a4a9b58c0e8e9b5e866fd2c15cb24b0c673b8af3c7b89a268e6604c7b5a66de3445b4c5f443cfc7b4cae41af8d217881559b2faf10dea38767869dc592cacb97ea4c2862d7880fb87179113cf585ee5e8900915597160262f7d134ff989557e55ad76bc710198169c6bb7d28b545230c454a07f730be17564761e7d6c29c919b6e1eb0310e022c8f51643c5eec852ce2b67093a0e4fdb7090e8b594caf4c2063d6987df04468d19d5e1c76c8695cb26c8fe9a23264989699b0101984dc42b3597a827d2b358e0c7953b9b124887e6d2e856e35c3a0c710f2ca4bfec3ee8e19d13152eb31cda76966f160ce79289c3377807af3083e6e80d0ca628060f676b0db2fb2087bc2471e2ff84ffee49abe18b2cebab4e45603fbb62d6f83ac9b158bf310fe0456f4c2d283664cd195fa052792b491e39cadd26f479505e329f34b45c8da4997e0d9aca46e76afa82adc02d37a6f5130a3418e37029754715cc3cd7f4324c527e0ceeabe594fb7b82b49eaa56b12ae63820c7cf651b29789c79a07bd5b285f986b7c053499578ff005f9e906b57f0b7796a14bc3315a89e1944af24fde173b419704eff8faa87b4f021b5c9c5590a3388d227c6cba32fd7c0f52bb76ba5f32941509e077bfc04fdb8510f88fda853062d3b16e3284deb760cb5b14e67fd489fa4a1dbb40da35651b18558b6402e2c23c0bfe77c8fee407a3cf2faa799b7304e51ba43f342465a98972b74b6812541dc9271ce094088cf1572788d712b2ca7fd8c77b375d45b0922dc2d724e64575272d73227a65aa4c9ae8239d55445c0efdfbfd64cc2c4d9d76c5d991c8cfad28c0fa42caee80ea2eb10901788688054f9fed48890887b2c94c67e94260621c7e7765b3a408baf7c454495a5b4124277fbfebb537976877901d480d6db51b6cd073901300b05cc4ade0cc5cc77f30fd3c50161495a633bf313ae3ca8d1d322176ede6401c6e1e00e5c79238cec3d811ad755af8081503a04541935e539e4e0352b3b58a812da788c6d65618bf630e258c9b952a448ed4fa9929e9e5ced894997d31dac2bd67b0cc2d4893a80d1f2d25e0f67e4d8dad3b08db6b441d5863c0ad23945afc2239f0bddb69d1be50dc124b3b2bdccb02306efe8db3a8b7a451f4e8f2e90dbc8293c7fb8dff5601c6272d99514b18fa20fd01fc2982d3ec4bc33ff6b62ea48b2923a7d7ca1c4d8c0317db57c375eeec4acb94f894e6dafc846b8ffcccff65358269c2f5fe4ad2eebcdbef30fee7ff12b8145f523daecf160ca4a9e0678e2d5e10c900882aff44b57c518eda9b610ce9f805d80071fc5a2fe7c8cb1fbec507053813fbbd55c5ffef170cecd84d14232f6883f03b824918b68b9664dc266941da73c504d6c3cf7f0af2d028b6c17c96caa4750c8480b0ba41bf65ef7992d3088067b36bb7d544a28e50aad9cd6a5df39f724f686bb43b6b0c069aa3d1f847c49572ca62190a4ac87de7822a0100eb30ca541c9f044428292bed946ade4bc29f23fbb8aace8ee3e804a9520c91d76f3d3cbd743e1744ef604ba4a26be81f3242fee87046dcf098e077d30ef8bea3d4c5fdc76041c0bf8513bc857f5ca9c864f3d904bb4fcb23785d05057f3a262acd809ee6dc39fa02a5ad9beee2a14f0b9303150593fd0e830230fbcd35a74ed3babb5989d5bac2d2693d49647000e9d70b84a0ffda418f4b22539238854ff79568a85cc7c9925d0f2844252ca76997a095592829be572967b6cc46c7b492f6f74f7f875e7b99d83503e9fb25a2dc51c2583cec2b3855245419a57d97c1ec843b15a9e6eb96812dd8fb67e374728f3cf4983fadd8ca4c557e98c4f85de4f6da0fdb3e9cdabc0272633f51c1e70d6c029155202978390526de8b031e1bb215b0b6a06d6dc5f155deaa578223d5a730553609746835b762353c0df799bf22c68f7a67a3d253a21bc02126e0bc8c93600d37e42485cd598a1b856475b539b530ec2dfa6edeef55d1217f3e9e230a4e3e4c8269e6e4276c67f1c51e756df1abefb8cad3107b4c8bb25995217bb849d784d0a885e11b4a33ad3982e9b514e98e777bc2e6d6029e8203ba617dfc5cd3bd0d706e92a9823526cfd8f8407f60980d7f9a607d7df1d672f7e34bb958fe13e15b04340af4bb74b5004cf5f007e147ff026f3abbd4741054f0015615d0b0648734e2d8c7e8e97300c73719a07bbd79768ef018f907edbb2fb912849706b47c111df68c4aa291a044d4fe270ea478d71a97e2d84903dbae2b631ff8f5e48d82dd44defa6e68f4712839ca49e014a97fa788c4c81135f3cb4d2af03f8ec16d528383b753841290ec394ad544dbc6498e51a007c9e92d4cd4b0300a2fa421ec2ef34981b5365aac23f37da254641debfde78ad91a7f1b1b5923e0cfb9b91b5cfde7e81de6115cf9f56ccab761ef8e8d5997bea293463c361747e37da0bd55027658e09414724a0c349d1690faac2e609dea3120bd42bf4e658a1aff997fb2eefabb5475b8efcc81852ce0f3772808ce74c46aec79c2d30ebb9d0bafdeb3d636c28edf0d4668d94332fabef39fa07d426f6f9c928c66b3c4ae02b6351dd62ccb3ec33d4fb9f7a952fddb49a7342cfc41d551e14d0ff6ed952fda50a78bd465b2dffd2cedac46365438702e37c7222aa991e50c4cc89636b777dbf5ee67beb9e5101da1109f28e78427a1d1ca2c2626e33122599551efbdd26113c16add28932129a16bc5ed55064da69c9ba643fce7b31510010046ffa8ae382bac6fb71439d849513cb2642492ba50bd13d5cfbbceef31081d2a4733f449a6e683e0b989f1695d46839e837f10a00a0b8a8de6dfbf348d15db3b5cc82cd9b2ead2c158f7f67e208267435a3a6bb970e238a67bf8f306efb59c5be1b36b0e2a58e280d5787adebfe046fbc2559be5555e11323c6961d1a83e4c3f997bdbae00c3823f1876ac3402984075d02b16fb9bc6217ec341a6b025fc2ecea58490f77739b11375b4f46fe02a0e07b031fff1d8da464aa5a2a13c78a04b81301ccc04eed112a6c373b32da22323a97c2473a69af982d2f7ac84a4be640b35c85fe607097f59432304dabaa70655b9053c14ace85a6ae6df3c245944e2fd7939dca1af0810ecf518419df1a049ec8fbbd41a70fcd0950543b50e24b853d8359e494824796f1c80fdcdc4b582594bd6919f85d70e87a1c9b6315cf4f4160dbb8dc7835fafa8cdd4b7a64e1580b3687e61d945b16aa403e3ebf511acc8e139fe623b13878585e832a6d163f300d26bebd185cce5074c4dd98bb90659aeacfa301a34dc0c88a44ed8e0254824526418afb16a2b7c161e07d61d27ade175e4e92eae570a9f604aeb50e2a85958c00d8e94bfb22e4572dd356aec891848c4315f296e3f74205fea52c617621a0c768654b1d8e9e7c43370a92b411f5290be755dcd386b85f424bf2001f1ba797a7aff5fd727c8953c71dfe56f6c5da1dff5782417485431bdc644bdf26f806b7e7229a408dfe2b7fb4972adf2069488232c2084416c7433ca94e4dce0e664955f165ab7770d2248bb42de610c7836bab3b90d9ab9dfc53b2378b03e2324b32dcf9476b8bf1053ebd77423d563eda74adf85d20e83ee0a87a9545c0bd779bc9102007ebcece88a2976a98a61ad6dd7e9297ffb3ce74781b6fa84bb0f51c091ed4677ec10cdcc21735caa18a08feafb5ab0476336a47d294f79b81799e217a34b26780ab7a5cf3c3f63b9b0e0aa682d7f8549eb7e1f1458d64c1212edc8d95dc1b0a8ba1638e174c128f547049471e7daa1fca78b791a1ba0550e55dc57f305de24763faf74c2f7a1e20f1747506ea096487eda7281bef947f09c0b810921f600027d7262e7cb75fc8100af0bde1d37207f56c212a9f922600dd20d8fc5a5886d77ad3211d7597a6fdb4899609f84187d0d6bbe15f2528d955466eb3cb7c1258a07406b5dbd9ad344e244f03b731bcaa0e82324d49db83693f95d0bc8c75a0647b22adb17a06f3a40da935d10103845f61af10c2f29500eb9882009197dc974ddf99a74ed1f9e61a441cee83f6f85e3429d5ec1dd5fe84c39018fc28a5278fb2f39af5eb4c6d31203369f03312b871f8f1d9c8d33b0258b0d58b5d23d9c51fb3f2df66222f59989cf715bd84ddb76404db31590a57f203ebf109ca82497ce45c5f3c3fc2e5bec3ba99625cedad3e63c49c195eee71a3e4287e6a71ea5a3a582356ec2b4f4651f98a574c27b454f2caa9c859e720848cfc18f208f484db2423ea59b4533875760e0f2bd20825cc8da1bd0c3787ce3b8a22835715b028e1312716bb8404cf07b50edfd2eb16f3eac31565b221b83ca02bd810cfef2b1c902fa746294864d606246b18e49c77a90b7ffc74b13e0dbdf6396a86f252c13894f5e5788c29b2f69737f451e4dedcc756bd51a1605884028e36fe0a1005b6ea65559a97dd37b98f8634246e94a5071ca4ad5a816c4bb36d5f9cd56fda412185c0cbd4d1295aa2f15de73c1c4315e510a3c8b590282e9687aa33597925d42756b927983aef0c1303382ac1171f7b25dbe49b861b5987751a82bb7cad62a76c0577af4003775563d7d8aeecc762fbb42d64fa8b7d3992babfa857240836e9cd148269edc1e3bb9e4bdc84470b2fca33295c4574b698fe94605613a2e17d4fcd7cb56c5c80342eb22a9f7bcd80d56767da8300ad42095c2c69972af4859f8b68a89230ec71fcbee45030ff92aa1208f33ca8563dcbae9c2b5a46bcbaaf181a4c44767a88f8efa5f75e5e9fe81834fdd0bb50eb754aafb55ae128571df275f200d6c3fb118d8b32e7683e07a83cc386e57b5543f37a9475e4590e120c8b0f31e326bd7564295345366a930697b260aac3b920974b9742911b95b5ba1dbf4c3cbad75e6a62282ce981e56004aee307984bc95592b2eabf4604f78b07b9be9b2ca995714e6136e403ea3af0e36bc7e49620884fd40cf7bd8783b4416e38fe818fc88dacacf1be9be0e37f72d129f25be4a771aa765188e1f74769080cd9d6687ad4c1c2d27aeed1c0736fe34ac584fccc8fe53419a18f278e0b1a6487241d7eb0a0d92708377a2366dea5153f1f32ef286940735daab0b5521ae152ca0b93c6b673ab7ac69d5aee43f3030155fe65a8d75d412369c2a6a6823b7cb63a73692d37ee9316c6d26be040fb2f97a41e28e542d170062ebc212f1b4deb82f284ce7292dc7c965ef31b188352130315b2844cca36ceb89bdb849a868a1d734bd696c33396586333b04109402ad6b256180899213d68fb42453f4830567c5033a76d3aeecae1fcb92a8ab303ef2a2ba0bec3f55ba5342beaccd4b134761f133feb118af35c2dfcdddfead885c73b819dfc4f8c4cfbdb006089184fa10f379b4453a0eb62dcb967263fb288ca44717b7854ba942e3e79e579e54932efc89a239472f416712634dafa86f4f4f9d2de3642109e7231fa4e81e87eb3053efb9198f54c50369915a87dd17d1b4ca1f14ef2e373a9087f15746a2f04265e1f1028a5be360a86e46471ec79efad8c0b7e301955126690767d193bbe5a617792068684cf4c8a859f203fac7e9f93d0b35bd992fbb036187bdcc84716b96eac3588e0c0542149d56e84c0d0fa9ee69d910c08cafd2e8fd8ac5eb04c7d61f32de0f6c37ba08220ae7d76db9c954b2779a26f3d634a59acbe58a7501f801fb5e2021c050cc65c00b05150b9865e7d3b7bbca7b431004e3210be27ac16cbb1b0ef730d1088c9323342948f44d2903465d3b3de5e06b7bee649a4dc8e1fc84ec974ba8350c74ee4298cb3524fd70131a8dce12d7ae11f7e35df0f837a36defb6d29a965f07f8a530c18ed436373c6b85946c4d008ee228ec93a6969800fbbefd19f6acc3861935128be6988101c625c11e6252aecaf40ac066136c2edf9f237a38e91af69f8b165fae509e9287e1ab4afe259954247b8911634729d8af677f111009c776c20ddd5f8a9ac2481818fa77e69c6f957471c1673396434be40b91023d546db9756a3201c96f8c97cde264e701dd5bf4fc95af407a2ad68783e5df9aa28ecf3f421f4978c923abb9ca827af86fc050918dbd252fa680966f3de4a9558130027026ff2fea452bf19027c70ac46c366eabf4006aaf12bea8b1c4c30d305a8faef879ee8b398df0035afe7d7b27063ad11a550e1240da2dbe5971562a87c3ec1bfc082ba3e695442ec3474d8c31b7ba67c41baa63fc3ae189f571da32fbad312407e8a2d5519481b105ba7affc1c04c9e5c7635d2a90fdbd8b3526a7b637d016c90d11e0387e725588c2e9139b52d8013e04c15cde245a58a2ccf5eec3f33877b62138561a1c85099068c026782d26a3d4195c7771077f40214dc814e2afd0ba70b3a6c6e0e6e075ce2fa13f42bb3a7f0d60b010b48928a46a644b4870334db4e945a3d79512dceb9f4e9ba370e807edb89d9bd1bdcc44b4ebc5f6bce83bb802dc921269123b9b0053a2371281e93526240dcb70b2c3a0482184783b8d0d857e3753bd96ee2de403911bb6450b8723ff21bb1d72b6fa8c85e45e188ebd17e4f568a7e5e2c81447724849159dd628c59a41a55a9af4c7098f16b3a1b334db1edfb8ef7beb03ad6d1bed0a64189b8fdcd0dd8d2b9984c17efb5d005230525486f0d292f38cfb220aad0900f2f940d1d58350498a879bf773ab3c83e82933409ce09346bb5b210a1b35040de899a679009bcae2e841ea945be9846f70495a2be9a374e79f87f41d826b2b55dc784da0bfb03c81ac53579818bdd334683bb4d9a905d04b258e38eb6fdcb0d4017fe77f97810e38b8e4d8c31a7483f6a47794ef6fc9c844a14de94900e67e7cc4e237fa1c6fa312830b1730bf860d7154b02319eba31dfd3db505cb19c7b85aea14dd7a1d95b1638e0f0bb1c147bcfb10452d2fddb643a69b1c49ebe6159eecdbd2f5e4d16d5e3b55d1f7247fa222add94d117e41a71ce97c28e4f41c0675854c554f3c8e0996548956e888746d0b637cbc599a50c4b68fd2052d594725f06c612bcd434f94772bc0b441e540f516221723e5ee77cddb7ca2ce141e30fa0dc39ab82825801623991cb230b549ae60f673d3fdbbfe00d38fb2452e084be3916c1e675830145daa9a425bae6f78e2a15c463aeda892a6364b249ddb3cc2caece7284a8980c9e5000b6a1b12cf764369eeb6e4fe12ce3b37f2f25e9030363b5b84803293af81e63ce4bb20f7cffcdc93a4fb8947ba2e1f5b140edc5ac913c2124a1551b3861bc6fced4ce729eccc865b7baafcda7af9c6cf586e46163e9a92a64aad061896e2ab4a5186bd31e474a182f5e9a9ba9684c6828984e8cc5150e45baed996d05ec61ec7e2089137ae36d061846c4f793b50e327e29fd1965b861205c524489656c6625d8a6a5ca9a35d3d4a6d24120714711be5bbcb7903494f6c1e7acb03f26d17cc09c1ef21507a1401753136e250eb2e31bcd3ef328f4384e16755f6905409183c1299d7244a4ebd9e220bf8aabb40d68b4cf6401c6ab0e405c851a106c5335afa2d364bff096457427e7432c3fd57a0fb8b421800f944d0871347b7831e2808a080fbf1a0e417","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
