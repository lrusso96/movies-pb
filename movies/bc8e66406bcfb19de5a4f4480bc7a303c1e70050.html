<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"25a452ec0b897361dda26fade960ca45e0c389d8a9ee52f5cd898c35b2fd3b6b9aff63a84c314b69540853cb0c22b26cd2287a8b689e8900893af6252ec6bd2a0e4aee520fdb32920003cf28633f0b64c8a83580d1fe75f28b129914899c473d1af6bda632fe97ebb418e2c46ecaa50aa803f614ffb18d272053f523a377b9a6b10187fd41370cae16c8e1af8144d6e2afa38c63154413e522fa761dd22dd9ee9a84524c4382c33667fb39d616db2328d9576ce6e7e58603f84baf848c8f89f4b1e6ac1e344191bcefe08972a7a2f6ca9c05e83de8068e854842c642ce4496e81fee7a9298c6029d9bb0faa4108f9f5b02ee09407fa430d48043a8456a9800d2ac35726ca581a5fbd613e325bec332515bf2f7e3298e7bf164a1ab5fcec46432541fb1f3cb84e8714a107fb6fa767e54d39d5eb576a41baf63522d0b645c1b2b08f872dd5b03b52ddfe968651dd4d0e4330d726cf34fa418ff0afaf8eeb87eb01d8e327b5f91166c34f37ad533ac3ae3718b4cc1cdeaed473d8aa227fd932bdf3012f571ff4d898862fb21354d06953d77379b27c46730ccb8e35dd894cb24b2236241cca38fabaf09f26c4df637735213c1912e7e1d5f28e2a77178fb2f64f2740cbf2c1b6b56911246007da8a816254ac4808d1b198c77d6cfe77e284aeaf91ebcc39c04cd85a07871818e464589ae15adbf28c02bac1082e15f2d9abcb38a36d0e6fdbfb5d7380c9b140685ba222fa3d2a4cff84ff17392a2e83e8b501c5542f951b36b615e58c1d7c35660dc0c53497f1139b15e80ce70bbd57c11226cc5fe8055b095e612f714c66ebc96f1080ad62deba854ec1604ef51c7eb93d9e8f6fa62f24766b8f0aa40f48904f6565996a8f1c60360397a46b7dd37975f61a93500443a355b4dd1c4fe8f063bd13c1c016cb3669d454c8acfff49c940f20358173b6d1a0e9bc5a25d48761ce75bcd1cffecc469ff31f2d74313d546c095f4a6459c0722e812be0712fb1cabaa5f259ea329feef3f6efe4f947ba041deea312a61fd69f40f00026dfcf83fc96c0f0821ed62272fca6a9b356265d23685bb374c97ed2855394d337d688f51ef9db46f8f2d805d881483e95d391ba13616f3262ded8521f4aa82c3e61b5c97ff399376e203e8963f0f875dc2eb237170e141c7277dacd88401e3e12d02d31608840b03002882195850aebc0ac03d6730f66781a09dd76a18ad5e60cc444515040fa3d4236387b973bdfbf0ba4d2ce2d6c64ac369620a8d1715dbcbeaafc0dd292b0d2889c340e82bf40d15254a0794f97017d91341386b63d173665817907c3cc2a260de9735f650322900051f5e90e3aa6b569daf27db5b6b81629acd45d259cdb91b819c52a00fcca595f6129167d6a4ebd7b77d3d06bfa87eb6a5ce9ad78200f83145f46c2febe839427772fd3ecd78513c14514551c0f8550f4b6e9588d65be778ab080a3b5e53ba0f1912368d6e03253276cce7868186be72434e99f3dbedf471bb929f382a5567f9b8d517ea54c75606040ca901ccf4e6be5201884a3a24ca0b86875ab4d2d4affbc3350a30cbd1cbeb81784760dad27461a791e4d751743ca9d25930da9b4da18615f2bdb2d224c9bce5733a4e4d43246d85fb4878a9664d18be2dc04b938083f8d6b62f69b6406adcc7cd673afc5723238ea452ba71cad38557b2823daa926c2eeefe97e37c56bb3c44b025d5df1c2847572757eefbdd84fe8e7995ab244229bedb962d21f82486899df380052dd70ae14e292f497186239bd7181959f3e155e1455d4bc2990875815fe4f7a989142aa0175896d11f48a3bfe5e5831f9fe4a24e268ae0ff9aa4c37f9ad22f2de7cd89a6525da2627eed6f096aa8c37d0aeeb3b47785195ef8cc089625c4b254e467645ff86d40479048c7f16a9603b1b244eee5373c376dbb356056bdd13768b24ff1583bb64b3c39945f03ce9d2341931e023b740f6093cdec470faa332345ae29816f08d45678bf54695ffb05b768a191ab0b810ce1db300bbc7021e752594a45ba98eb0e050dbcb9b74284356ca2b12e944e2fc414c36950d1289e74317acbe436b2599d534c937976e7e4d94dd9d1f2fab7e870dee5fe54bee7e5ff186ef7bfac7a07522ad6c0ee8d3975b20b8db774b66a624d04a4bcca5903850f745baff11e9773c9b366956b91cab1daff88a4a2c8b3303266065ba3db71cd2982415befb390c360e63cfe0bccdddc8293f20736c069b865daaaca80b57cd993d34ccb8c2107a7b4929d96c54c5f38192cbbb6228c32ec91744c4d5f85b237e51a7a3100fad8ff250717b1e4b2808d074e85d9ac871fab62de71467855d30ca8cb91a2ae2c33e634cb5e057a6a5773ec9b7972b14195be8496e71cfcd36cac763e04a12018fc92d0eafbc7597f7a4d09155e48595234d7d55349c75504de035001899e220e559fbe43f969efa4bc5c05fe421a4b0b6ac52140b64e9f08b85431cc59183ae5f9afeeb7d9084219ef59c26f15203d94cfd4855391f6278e6323660c2f68d58f507f4424100c558865021f90f9398959217c5b5e0ee59690ae9658d67055efb4bb91afcf9552ae8325c82aef019a83589c8d4b2a12a37e3491e677205071faf9943a44d35bf9876c4bc1c1bbad820b023de085da91a79c1c0599923358e20e037c5c819ccdd0ce029f18a1cf9d1003d61391dadcc768a012b4e7b311f000f7cda9acb3415a33cd14461883746725cdd9aef9324a427de8c0739bfd0a0f49890dc90405dd16e9ae1bbda8caf3cc28210487f51b388bad73413b94ab0ddba780fb8542193422512a7d7118c8d8cfbd7a1a70d6c8f82c6e2c4d474c601b51071ddfa5333c1428bf98ffded7b8002cad7ac9228fb794ec719ff34bc250964836d23aff3fa2a89818121d9e2bc33ba9dd48136ccf3c24b53d0773b91db15442a03f619d4de067c61faf1e7ed866d83bfb8c7a0ec5f887dffd1a19fc0f3f6675dbecc4a48f3c3d8ffd13b8a1090e4cfd256c8222dcd9ef78eb746e5f64add14d17975a73547df5e34e518ca97498f0d9f0b5b0a1a0cb53965d563caef6e29d8d12750516eac215f68998f6c432e02ad74f22798624849d079bedcf564709435b9507a7533c396cc2a461dd6c2fd316625800d1d243b7b11864d07a3ad26fdd08641b8940771cbabea9085b8f0f7545f0754cc5a41c9296d63de57b6c85ef5ae67754ed4739b4694b2987b724881df09b274a255fa9b1b30cff025c80688ae13a7b7f15aa69405c9f09eed8f832980287b89e3063a825a14e65b36df478dc9a03005f20bd3784372ae725fdee7c923f950c99293169b4166ab68419f04af3a244c52477443d58dc8f02a4233a231c94a5b9f63c160a930e4041429c287076280041e98243be10fd8ac5f1e277c9e33d8d5d0245e5b93adfdd16ffd4bb9be55f5497648ac65b6fc3bc8818d9e3bdaedb18bfd69017d3d751042b6a995a797dbe839877d8aa97aaab54391eeb66a2e0da52a43f06c9721c5e1f0e2a15ab68b56b72cdc5f76bb6e253db943d8fd5781ffb35e6250f24b75a33e675bc780cb70a34fee20c192403c47646f4d56bf25777e7cbe3c1ed928f3a29ef9e0c48823995563e473f3fd9e32ead31e2b374ff4bfc86f7d16a164cad2601e7fe51041e97d231a0b284c5823f4e4cb5214f9e429680a4f3d4200dfe1c718977b29ec6c2fbe30090d7a9068dcb661d07866f8037a861aec4ba29926ed185e46984b38f56bec7c9063a56a9e41140ab5b53e71f5cd2c62cbfb7a2e965fc4680352bca6af49a0fc5f70b8f2a62bb30f3a0706b6e6961e0ea3883245f521b948225bc53cd277d432dd000828e6fb310e8677d2f884102eb04a74213d565c19cecc0c569a87ba3a71a873d0694fe6863f793d6760e1871b40d8c2431d98de3c5eac71430e64e15a123d537492cf06fb57439e8f439077c96f9628215cd90fda53868c943f08cf6465a5cce6f0089a8c439117f4187a70e9fc5da9496b33e10e6f885fe8fb8a0b9f98937313647414341e0a8f1b31e062810af3cd89033bf4efe8611876cc34291e08349d2959b0d2e237f453ab3325a2bcf38a115f157ef5170ba9956bf52a2d4ca0482953555019ac20a3f8f716105feab7b4db99fc3fa3cc04876ee01c16ea13c9a072ea0d76f8e0c57f7cfbe25a7636342645158b74e0243182430fc06e89dced5279780552a3d5b7868e7c40c08f0ce91ee7d46f499b2fe0521aa5a09515ebcccf1941ccdbfaba586b2331b537c9eadf44ffb4c289c8c3f3f7666a3bababc906e9f5bb5129a510b65cba1ee3691f11841bbb45470527f414702012d11de6947c602b51526261f6d7a2c58bd23ac69bcdbbe977257e30d5b431ae7f3a00c1ea47596078807aa173e541189aa866b87e5ba394e42992f42c9b20e8640ffe9e31d133bc6645c630cd05e40dc2b65943afe31f41cc5674d886ccf0ca84fe95ab3870235d01e2cb7e11a5698372e8616b11220ca3ed625e4ef387ab95f3e33b79920ac514560a22ebb191799add2ecd1dd903141c7b8943394d943a9ff2dc9f6a70ad274dd5b3684a6285220ae16ffa6f2917ec619f5a117d44bc38604356065e74224a5bc430dda0b103e17751722a56d78c8ddbd15c2af0f169c4ebbcfc99e59c27a65498aa700378fd9b9d35c54fbcaf3385bfb0fa4e18c62ed9b8b3b5a104c4cfadd20fb3b7b87aa2a387ee768453459b9688fc0b4c44c0b51ec79b2b3510d44beb9ae7660fad1c81042cfc23db295393b918aef202cf15a4b0d2169258c2058fdec6cab80735f180d79ae1f0dc2a2e23073551784aec840a5b87f7e5f2fc3f93b8a136fe1f390ae940facf4a9aeaae6019eea11a79cab531ecd8ce06357d0526df83074fb64755b24064753a0a58576913c71b16b2286ac8e5a6d35041fb6f8e36b4bfefb84101da770aa0ceb80b849759c4977a30e269730367ff8dd961b947e5319065ad586e29f325c70c544b81608cb833298c72cb694e21e72af0c8344fa63d639b9f9de980a6586dc2ad2ee1bb2498687b1f702775c924974fc41bdf3afabdc1131ff4b827bf83e2de493dfc1091a17cdcd05315a3a9e6c774b37f905894ab7743f1f6126505aaa5c4d0f37fad70bcd401f4f99341860f46ed7eb8957dcdcbe113cdd7493ac4b141106ab845156e4dbd0508adad7fc098d4175cb92e5b891c5866312d0a4459a6af88535328868da4ae3f1eaf7ac395f4d2ad0048e868e01c15bde58b929820d0b20ba3a045328ce3b7fac77c458bfa5f7ba30aa1ee5b76105bdc956dabee7c3a3916106c197b08e2f15d47e70bf62de579a284ee2434d993fe2aacf913a2dd31445e1e9f0d9bf9eb79532ddb9d40cb127626169f5d4507ee605e273fad24fe434aa6f9770c5eec0a0d43cfec49002f88604d6482f19195c251bc249c182c708df116ca08c949457560e584d112fa1538b71f982772604db8c7f48052a307376092dec781168f0d89fd398b28de3334fbb845dd0c1b1d4b6249c341a37f8b462505a651040cf0febd254ffeb6a63d87adbdd30662ca4d8430bac65c7981b243f943f2a67375b21df2c8486266e6f9d057cdc02d02793aa7c3be34eb4ceeb5aef9847f8d6adc8261cad65929b8cd7ddb1d1b24e34cb81e063238978799ca8edbe0d9f7976fbdf07b5f5026091da74cad8b2c3aad909465005c2abbda0f8ce736e44b70c2944bb7de9a2ead637470e89e9a0abda97c5dc7b040fb1da512b08c07360c49b76e4105c55bcffdc7642cdd4fe56d743c41fd148f6e1053831218d4ae78884132c79f7ac61881ceb065ee3cda916213adf95b3ab977447ee9fb3fce5809e3054421fec9dc128a7bcce5bc3919165dfcc71667f41c4ffcf821be871e2412e7b798073bd5115d8ddd057890d9d8f4a9a5c693c3981885394209464bf3c56dcc2d63f1b48acdf9a08b40a6ec7135da648bcf31f1dad4d86ab1dbb33a886bbdbbf3920bd982ffe5a895bbe8742c7b38fd6d5c223230350a9fcf9764c33d9b692aa3fdbafd81c3a1f85f668b3259d18f260f28b4329074024eba9b6b4d6c2ceb46e3627f4c9a5c183755c5ef9438223043e80d308413eaec6d199ef2ab3f2da9e2a04be55713f22c700047c72779c5b8259fd578926708ed0655e5a483e2b43e5bd8256251f51ea41b792a0f57f669daa8be90f1b680f363ea374c2a9b54641bf2e80dceb84e9eabc5fa6e9767f3b19e65b659c44ba7183b8eea369d6f5999bcfd756ffd0d2d3f522f162d4647b3d72c63d2aa475eb95a48da9a182a5a0c5992ba0c660573b4731512e17ec4a46aa686c5e115c82f81ec2b85b42185e8a4fd9b40065ad4b6f143ebbb025b495d1db214c4801ff39e7defdc6133e572a80071acaa31c7867366757ec2fd7cbf09735f47b0cff4734b6fcb05d32e7dc020f3208e7dccdc5f9b954ec2bc4673a8345f95cd41d113fd39f672f469921e249a4dd11dacd800e8a0b7938073e58642c5006c4172653431c80ff9cc6c939ecfdde7cd6988e56950e10d4a76ab4bd7cf75e0d75f4b7c740f7f5c29073f1d7e54f5db32a75a3f55d024209063ce76bab3c1eeace09c02f6ce31df18a6ffd268b14d4f0c9818e7364f43505c3fc48a16731bf9fe56d155c37bcb5454ece5a763f98d1fe8a6fa60fbcac64a9ec6fcb49d839d26dfa2e10a15f83f08802d4937d6debd160353698ee131af96862befc95c76d065bab50ad7511360ad655e84a702d35a3b8969911cd09329bd5b24e4b2f970ba1044b432b9b838ea23fc50e133d5d68bcf8056ef9825118a9b8717cbcbbc6692e6bd80f206613924a3040b6c239f50f846f85874908e5cd2d823c5551cf9c9560645f7f0e4e1baa214d553cb19729fdfc71921c25049cb83bff9366c1f15fa2347a624ac3c906d75c32bdf68c7d93902d770ede3cc39f3f5aea15d893bb6d8064374e4f94a2b3a6a86fb08bc1b104ccd0e26e7e1cb2fe5d70d08f9394d49ae4003b8b3f13441dc8cab4d62b856718cf3aadc193c30af131bb0cb9da15a1cfec6f1c3323025fc890bd5998c824a08f166a57cac8da11f6350bca48a4d41d6a871ee0b68cf94ab4e195a349b1bb58733a28c90376fc7d25e0818657e6393395becb58ca7db1883a33b1d296ef120892ad757dcf4bdf97d229de6bc792704191a167503be397115743d4d85dbd04bd60e6ba703cb5ac7cc07e9949fec72449e71a0f520d291237ec1fd14c13792078daf5048f9b0f552b170128caae69b73a692a66a76162af1a565543582ecb9c3420bf3718f6f2ad07d59237277db776cf0ef9b78db6a22f59e3bee6c0553af07fc7b251a22f6490c01e6a7903889eebd60de128a78435f1746bc41eb75058c12351cb4fb8f7927dbd1216496b407044f742d4bc79377f6d45de0751af68c5307a27c34ed1a40894fb6e94d9305e67f4d11c5c8684826f28f0888765323dba58a79d517ce101266a0162cc610544351cf4f718d9032df1f22fec4618251edb6fc30c55115955698fc091ec99d1ad1c8cb7f4343a6870f0b6ff53cbdbbf04c31e9f370382336a554891099d4bae6955932c3e30d70b5aeee9cd294b87810c31467846556cfc70176735318b75520ff1c59e7c9e311287a10190a3e39448dbd70444c41a82f2f3ee8c6b00e634048fbeb4743de2f3c58d4d6d5651492171da3f5c6069a256f1b431e0c74f189761559bddf5746c6aed738c1a42a2cd2ebed341ed0380d60e13f211a9fb652ce05d06bc8ae230b7c4df20e9c8d92d1aee7ad11decaca978982fced427b26f6a86ee8fb6eeee5ba753a506a10c5389ed26485d28868439f21b2123ba484cb4b56515e860f55340efe62781373dfd6ef14c77b3ccca097b49eafbcdd7a9b9cd0af5af4d76b36fb5011bc3cfbe957f1ac1284d89d9e8657b710db21671b1b19ad0e3744b636c7ae8da079b537dcf10a7f9f0664a1a8e0988acae1f23e843f226d515be160399cfc5a400f2949ccdd01618b92dac9d18f6194d0a9ac5e245da1f0d32fa9bbd6630147d438e1a5960dcf147ba8e80001e0934f9a44d080c67634f6e5097eb9b09b6fe54aaddd503eabf0867f9ab5327e32bc61083ab047213c66859a27ae7547c6eb117132b5a0e3da222a751b962b16736ecbd4d53e0292bb69c4890ec84ec2bd76c202329885c56f0d84ed682aecd7ce694418cc84d6f25a0486a2675b1462801c4bf271718797a2dc512c4f2b2eff5af540c8e94c08bc5bd163fa7f380038c732167be48d4232e6201bbb41a87d510f50d410122b2bda71caa99e1b32841a5d2423d4f5555d99fd408a9c4355d98ded10df26b1aa3c5b53bb9be08ff11f322dcadcd638eea15902c39511acaec0fc29b358a37f1397e632a50a8756753f6b720ce3be07282b21a093bb1eb3a55a18a7c7b61e37de64011d73931e2b5a0d3d485d86bcbc589987695ecf0aa7cb4154d185deb85c0388c8c5b531f1720e75c411b1903dbbee6273f5fc6340d12a4dde32ab8bc860dd4c69976b0288b75ab102285522d9d68813d217ae754dd6fbbb2a812e4e28c32c9949ef0125573b8395c71b20f6f6ca8f24146edd76f92dd4889bce1bb2096abc95046b09728e72f00f06c401617028bd07556f3bddc9bd170332fa4c003c69ccbc4532655ce3e77f4bb74f72aa3c4778605d9c0b11f2b774c335a7cd8b2aa13d306431350df0cbd6947df191d31e069841d3e4651bb8741de58a5aa878856a40aa4e3e289dd8a19e0b71eb60de74e04b4e2d7af7738fa61845286ecf83df0ad064b313ded28f58611aebffee68c3712ea2de22cbee6a941c28feec0dfad0f8e022cd8387e7ab27e808a39e5f01262a643ff027039814bd62920d9d3177db50daf9db9cc077b89662f03e93c4a435ecd4bc8f22a819a454cb5908e1d320cb265ac25237579ca2cbc8fa6f54149f33a9f1da25ff768dffc1f25c2248f11c85bfcdc8ec879784ae7c91a534278222d07e65ac295d411d8f579d52b98519fcd808ece14bd146050d23d7fc91c863d65b1700fdd7daf19f2283978825cb4d89fc8ecf2ba9c48f6f9dc521ff770af613102077fed4db5646ddcca33545cd843e9a3e9ced83bb195d467887aadd1c8ed3d849f57797e2f2982c579870d0272ec5f856b5c0bc930271c375db698396b953cfaf7d5e3e8681e98b7b0a2d978e6826908a9ae68775e43d6e622bef44387c483966246a0c7b1e19c39a2a05ac5310ebfa59a880f82cef749c7fcc6aa478fb09ac115f0771d225b2b7a1515ba76e09a493c171d051444303fc1703474d0cf2b9a0217d307e95a796b947c9ed6b90dac47a3c7123135e7904c95b573016c126a2f00a25eaf11e0f525f7652565d02c4f313af3ac8e78cee43f086ca154463e093b8114582417838ae43f9b5bc0c2196a2a6dd4b9d3253e4a047162113e717d865d27f687b2170bded6844938b2271a6c95d2d6ec28cf35e7832aed7fe01284c4f3cb18cbf5b008cbdd00df9d083b0ce5cb2fc1dcae6ca23cbcd83526bd5149cf5708e6a778146a56cb6a350ba65eedfa9355c87e154013152009fc8229f9dd690fb3f626e314e187155ff902818ad649b1af1168ae1773b672302d1018c9ae71ffb809a8db7cafb62c2edca81143da4b8349b4d5940a552fd06abacda17bef2dab0820c4a45722711211144f725a31739fe6968edf71d3e8c04126972fd83d077937f1114e02aa205cf8bddaead211fcb097889b93f2d9948c2444c7e1048a3b675a978f49e52857bdd00aebbd32c90a7a3da49a937698a3e86a0db78274f7ab6add3267d421bd2e6f92f0f622ac0bf4f16ec389b3f02059bd234c0600922c7316b6b4d82c460eb287a8e1aeca572c5d74e7eb0d2300525a6d452b9288a9231e77fd939f7b71806f673bfd1cd138f5f361d1238d9e8dee806cddda9f522657254ba1279b2e674e634b96f127d3bfa4d929bf794c3b3ef8b0bfc1584fad79f6831056f84e7dd7f93c0742a867ec19cd6cecdd1a286b58348af4a46e4e3699f73f9c5167529e67c815d72f9287b03f48c77d3c5c655ac985825c1386ebeb96a5c4d8525bb5c82b527ee01947d0bf8dfee795b2fbb6f55c53e979a40ab4b37979de7194e77d899f36b2d38d562848c4e5ed44c9f52f5cc84147c2ec4758ef5c8da42a24a00cd4da763cd1e7072e62bde179c80f5bcd4f0df62657d0bfbf3fbeb2b6622980e4144b03dc2c7e56bc2c997ebe3ea43423ad595bfed90384eaae82e6ac4aa34e7c28c05d901c2da9c018c9d4a8de6cc1ceade0a926132bd2c9850af70bcc613668d557025be54ab7e6d26b64ff0dba4972c5b01f3f1fd00551dce771a477adcca0f3b1b6cf1c1e88f7e4a7d4b77eab483aca402b9dc3ee2187f09039974263cc269c230ae46ac8453b3976c6706040a5ec307988a9141f658d9cba3213e61b1c7e20929947fd8a6cab5c81b7fd26bd05b5dd32b98cddb071f209f5a58c435c5a7f8eccd1d640cf33748ac169eb952fdd48f7f2ab111a67b8a633a1ff1432bfb843f0bda7f2fe4d17f387f8f7eb702916c5493246ac0eb7924f22257630d651f3c60144a3061f931d5e0fa35bf78da017daab296dae79ac96db61922598bd6fafddca0032f125fc375a30d69a286ebacd840ad28a972d37cfc0c347e9f1f9b082b8761dbfc5be0deff91a89504048e3e4b3e01223d49459448cd4764b721fc9d3cb79525e112d7d39582500200d775d5864dd0a667217684f110607fa7fa265ee0c1fe059c546aa1d709dfb97eba4fb874400d4b736049afc2443e88447132a5da5e5f02a08878b288be9132e961d64808b82f675ba99183f48ee97dc26101ec456ca250dcacdbb60e3743a8c2e4db28a3614d65396092c880a6e73047bc2d1b54ea9c421b70a80227d2fcb23530d910bdd8dae97bb8b9e47d3fe1fda5ef49a32961bd96f71ed82ac68a9ea8d362ccab57559f15be2da7f09614c914fbf6a83e251f64ee427ec7ebc633c0629072e3d963a661bf55d56c41b25c5ca5687b24ec862cee233edfe2979b8e153c94ad6765311856cc2f24ba9f905bed5eb44c7b0906881272dfa1ca7ae36197629e3b0f4bc1c65370a8c980c1c4841837ea37e84fd755085378827fa5c90db0232dcd676ca3b447778fbdcada3a57cb1e18c6996167f090b7474a3b6dd72324dee2ba5860ccdcd4b6bd351754ee148907a9b337915de9d130dfe5e489fa68cb9aeec80395cd7d88a4d339f5210b013fc004b622293df3d24c346fdba2e6984514d80387590bf5941e5ca03597f3475a3cf3f317f3c8239572d4590396556e45184d529da1ab69fadf452daf6f1f961270ef3e138fccd279a62077ef25b4f1dea42a35486161658e379c17dd90553058577f6f40ddd77cd8432efec70af5df8967c1fdec05228225c8dd3cce8ec19c9da18f9c72ea747809af540269b390adb2c4c063c466a57df01eff542ae562fd457fe62664e1bdf7ec042fd8e9682cb519e87ed91581b0ddf6a935881e3872a66b6b90e5b71dcde53344d7e80e99830f81af306c4f3dc136bf4d9c53a5420208ed2e488453653ca843ee0d4c34ccbeb2f955946fd685a7ed8ec00dd22d5baf0bc2541fa9862d91d164a88ea1fa0cfbb4b2eed135814897daf52d2761d6d48bb2d7b1e82458c32092f0a38fbd1cd354abfaf5ff40ecafe8d424a1c5d97e3b79add0d8356d54f116b756c841355b4edf151eb59bae1cc7d5e516a60b7c3e17a7dc35f39c27c7cc8e140523145c6a5b5e80f84461583fc34bb67189b402b1ef46868ba20093a37a480cc0791d74ffab1d4822d1d6925c4db1ff6c5577040f53792ce5c06eb216aaa9fe93947fc5723027eeae0237026ded2341e20c10d148a70eb640e1ab5627303871aba31b820e021c9b909d8e2339e1654157fe17a8e80c1548ad4c20dd618a76358afe8d01c6dae57a9d9bb05b45ea1451927f1fdccb99bc0aa9a4f37c107ffa3fc23c7b66753e873fc303d3b73868c27f3e60a4856ea16737eed124d55d57252a63a37f46f8b4f6f2bfafd09d4693e02a21349c79d1ee461c93c6ded89bd99693d0c172e79cf39d60ec62f0b6c50bde85f9b07bf2231ae78f276f5e531638a1ec21972c4b390f8bbc52588bfc0a168d891a99043a289bf4da6ad3f69b324791f3c3da682448fd960a5bc546a5ca1ad680bc8a89bd2e104caab81415d08c0fa51e92a799bf702575e60394814923cb4a1990915bcafbfa5cf594adbaba780297e3cba299101584473d4fe3f3ffb3d2415898745f54ef5d8af69f375a233aeaea9edba82615fb737de26d78ca99a80ffea842d3afd8884f4f60dff864e20ac99061422f38679fff714b16a7be78aa72ee52006cac321577da2d6f5e082db4ee0499a3ce14c413b208fa5d2b705f7328e75e44120d8641d46f011e60bc0c427af8c9a453efd5030c1d202bbf6d919e428964a909659c62bf88667c7b7f3380bfe3bdbebe55f655ce4fccbe21070527895b1414c6082169734c1dc95c35464398e91bd63cf50784d492b1c3103ddfa31537a929bfe42a86fb1a57c5b3b9438a48c0d3aee159b19c0d84f2cc15b79a7ab4a2afae56bf51675c7906e8803cf9890c8839f11f4af6d401dfb716469bed380fb88c3366c3425b0f606f31ea54512f4ca9e2239225b38d540ebd0089858afb2166e74cc0ef13f904af7944da53d4820695d3d5636df6b5e032889be478b21b6c8f32cfd4e49b75b7ade6c9e738054403f614e68bfa58862de197651469bd80b86668e7805267e6b706ed31f3e64507831302471496d61ab2f3682edc5bd72cd929b76c88443fd27a448fec86ea34d581033ddb975bdd683314b0aeeff0b463a48b7246b43075b741d20a86b44a1f7d1d7b125b6e5ab4d9939ec61b8ef2fc344e2bf4ef0b3e42ee1b31fb91ebbb8eec86a470ebf884ef87b2e5722958988863d9bf7724b1fb2b9696edb9712b7b84da92f07cd610892726a26ac8ce782a7aad022a1429ae0267287b7c1e29efdce032e2b96f546de30c4bb3e46449ccb519859a94680b18b15079bc96af2b9bee0c7d77a3db4955678b815e1965384bda7cbc9782caa4323c9fb8a95176cd0239233ca486ebc8f3ff3e9f957b5468dc438c3bba2ff5ad58d119dbe57a8a0e239a0b246be4fc4de858e6b9a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
