<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8ccad10510ab5c1bdde45dbcbb6a51f7ee85cbac92e7f2c5edc063b2c7d8f95deef3a0b8d34559cf1ecdfadd26a30c384f57694d64aa4ed69e6a952f2cb38d00ec1fcab328062f9bd0413d4f3687009fd9fa5746eb2f98fb8b2d3b1100674a37ad508f21c79e56bc2accb3cd2acba1ee4c3a3869c6438bbbf80b9f7eae863e0bf1ffa148c880ac810547f3ce83bec2cbf4345a2ac20f0488b740c56b657f90c223cbfea34c79b06592c9cda704774f733a6154bbd8fd50efd0ce80e917ffc564666af70ee56cdd33ee505a7a338057594d0791457835206df3e8362373c6344eb9206971f591c9c1fab3767c41cd8579c05c639b50741b09cc0fa0f4971e9441d86caedad0961481caa794f62cd7625d28adcd88e0bad90e728156e3d650551479352b32cad06ba839ca9402f209f092bb17ec1bec872c67fbbeb3d269d19fa481bf80f82d014eb41aebc14bc37820fb241bbc5f47cd04d105b9c6d20f03f6e38e584a5acd8b8c37ef65eaed6b1a51d80102acd0cb82b4b1aec950931857f2a1e2b304ac560fc5af31cca0f6f08d8caa1d2c6eeb24b832441160f03fcf8730d93a5001a9c92b140009a7bd047993d4e93b3ad5caf715806ee47cb75ca2691c5b1ca8f9ceac0b78536bbb9e296a5de7468d517687acd16479f6ec4b164b61cbc39140e14821cee98c06e84f780330cfd5f7855a85f2435ab7cd195a1e525236ade400195861e79d2d61e7845b60508fe630c9f206300122314f424134e5c2c95f1c9f0f1a886436b294ca28d0a011e4159d200ba9419a651cdab9f37f790f249b4be47bdd9f16ceb13be5ce4915de2c60964bcbce5584f47477253e8b1946ad2dfde682887030b643f29329e96805e62e26af41254fa4db50c229eebd41fee8298b8dbe9c39d5f0dcfdd45dcd33ee79c743f1971a44f032a8b4d81719a293a3bd783aa314ed4f5b8fa1aa8d0943a68b2af2b3200f573343b992d160b51ba48398264382ffb00d618377235f2370118e874fc0b0a1c741adf7e922338fd99ebbaa6dad4c5b944debb24d8ca341ea833fa2b130652d1823a898fe11bf22e3b78b6379e0b39a1be50950c72881cbde0c505c9d43116f1c4241ca0101ca01f5e33f6d0ad16ad0e1229b92ce1c9323ff87548b2ed0d4443b91d7ebd0a4e63101e081c23086364031ba5742168eef2dbdc5022db1b9cca6063f720e96230229dc9a111b36ee7df4b3a37b674202e28d8546d8ab4d8f662fc73611e62942bb958ccb8b2945daf2799ec32abb953027e9b830fe51f864f692d7347067d44fa39888e9894f1b76a16207fa4637620a7c4c168c3138d658fc8faff054261488fbeeea81bd6b5d37583b92c80e18b76c88f472c4b8a2d9286d78856d7f91c92e499da7db6004d47082819f70e1961dcc91308fb581ce17f1734ba9082683bbd63c467e3a23cc14ad2f604e4adcfc731a5832e94d68712ebaa97c3ce258663222d267526566c58d2129bc0666c058509c639a1d1b05b2f70c8aac199b2d498880b163d038a270bd1831bbb1638087e643f4f38ab82364bba0ba369b0984be237cbb63efe1b0ca8ae2b19cdf1c954ecb295e2795bb8c46ba6ad41cf137d7a3e7890bab0974550fa10bd0e6defea64ad58af697f4dbf4a35efd00385e8c154d3baaa1ab1e65126e398b011d8ef6a768de94fa4c6a282c4006288a638d5a12819a54d0ca511626818dafbc3570bfbce6b3f6a66ed2ffe579803b41c1b1c930e880ce13791b2cb73cbb2dea546416e6595c2e3e38b9ced3b0a6dd779a98884abe5588a8c19abd94a4219917becae9b8e8cc3de9df83c90b199948f8c16f2f827289acbb7fa174e56d90f24b76ee2ac908c1236d064da8155cd886a77e46f40a82913d058d7c3dda227e9fd7c262b029be52cf060e5da2c4ec8b2c55e54a29dd5ef4e1a10693b0536ebd24ff20ca90838b5fd6b0194a2216cf1d1235ada51b2e1db4a2df03eb6c701bcb53fdec78def5383d7627d119d68b1a6026159646ce54420c657822bc1aac017bef272fb88feee761e11c5cd8b5f511262c3ece34e5a0d6178a0408dc0bc0bfa8acc6ab085e4376def5daced3044a624bc2f0fe2aa5ad84aed0ab70b0dd51f444b5bd2dfbf0f8948e4c38c95139132a2f959363ba3dc0fa196ac0571737467a4eafce62687800c0d9311a808505c6de981a6db1c19b1278f41d1f24e6ff59bf2da85443517dd9ce8ecba38b6c2acafbd92246e86a31d3d67c92b0e06ee524a7221b9fb0a381844102461cec20096951135161125e54849664eca6743d84ce66bbb7348b49e545f43a95501a607c066f6eaf14eb3a10eb0976e9267334dbd3130450c21473a4a81296f57b273dffb5cb03411a484f67a64a65cb14bf5e580fb248f17869894233b1d58fab82488927056cbe0ecb80a1dda7de98b57c07d662f716d6beb2c872d9e10d1636da58103d6664899431ca595d82923131f56e1d112e30cd987e6779229b28cb0d2a4e00ed4418792558ef49c72c831c94d714bdd0c3cb944801ed5ae8af98e0dcde5b2ff74a6f7e5c5ea3b9c420757ef8c37257d381358e5964c2757751804d7a6b7044ae3a0b0a16856b14b8bce8f73b43a8fa08945f833def415cbe1b7bfc9d32ef2f900ae54ba6261dfe8812c2c1d893c4ba97f637c336ccd1e8d6a457f9ac910acddf954ec14ea4239248c5d1aeadd9c2831d95762d5483816d30dab3b7ca3c7649d28093205527c8442a6fcf3497e1dbbcd9ea483e7d7043825a530855aab5af613cf0b40f0a1a408a9f3d118bdf36e1ea729adc7b981b29d7a84bb18a4b9ff6c28e84acdc913e43a06f54fad572a0b19c5d3f764ed9740bb3a8d66fd89c41e79bb828be29c54479d1bdc26904a823782572bf30adef0e7cbb6c1db778149411367d314ff8a867bedde69579360546e1c91d8ad0ecab05a5f16fa82adf3fbc0d22da4e7695259443f3714d1a3615f2de006d10c8ade6bb796167d3af605920507dd632a216ed23eea492afd351a60725ece042a5ffdb9965d3ab3b5e72b6fc25683fa163d5bd5cb2e8758653d7f0106730749fd7e6e636665797023c9a617d220b0bdba34ae7d96e8de510aee2e52defe5555cf9102f29680b33810ff2a1bbde355bc48f482bc6199c6554cacfe0579b9049dcb1e22b0be9175884518756fe1432f532a597bbabd16a9b65ce99784218eeb0f58208a289fae9a0bbeb2fdfd0293aa69cec7908249a34feb6237508ec8ab15b5d03a4cd7d2749f7fbf51b721a9a7fe1dae4dc0a154ef647a180be40981a79d389aa22e572b84d161b011afd43d1fcea567204b276da541c86268bd227df670c76dc18fcb6720ef923bc7021c771a83ed7e2690f665ea9a7e4167c58c18bdcd8c484fbe3960b5858bbf7ef8c4bb4daa885af83743952e4691d7c40df4e3c17d325626269b4d2fc549943140ad73a3894276b972f60c68c0273e214a9424b5a897c0d2cd1aae299d088d1a5177e7a47c4749f8c5c425904563e49ee902622c6eb1ca7f7d88f3fc4c296b0258f69b32eb4b47e2914f26db3fb967bf6a68c06b6e061d6231502a8d5772a6b379bd6f6247ddd3d47386a233d65c4c05fa1f64b90d072121ed88a10f3b0994366cf0230f804559ff87fbd36aaabacea62a9f625f4e3fbade7dd9f7a6974b9b12e00d3c853b72e625fa8adefad2a71d938a3231f2516f45b7af5ebf55385ca9836c4ee3839f30e5b6c164624433c5f1e2b77e2dc4594f0cb67a55133da70e1ef77cfc706e5a1e9b84a0597f1594403040dd268cef7fcf869a9e00208269b1d7f17b0556ec78acd8e869d49325b445858b362ebbb73c5e69005db0a1adfb2ebe0bbf3c4119d0db0dbd7fe8bd95623af7cda9a0e2d8117280d4839503d48a3f0917c4ee209f004a57d143fd7471609eab3ebf6b1444c1a814dedc38fe3a50a99355b7fc008e9be0b8c7fdb35c76f3db039daadc6176c1a7aa03f36c02d87befc199b5e93590dff14dc89b03fb30b8535dc5d86947984aaf3cb93c19380270e0290c11ecaa3f693182e5e9d41a1fc01ef787583fd0147e75ab3b9e0b852f0f63fca448ec2e36a42225a79bfe8530527eb6aa15a0aeb357fc90c4c67bfebcfc40dd2fba41aae7449d8cf8bb16f8ce1d84d822bbaad1782f4bc86c4fcca5cb53a85feefcbfc1928b6005a7a06a7bd43ee542cc317f53b4f8e9274f0a6d080f46c047e41fbf802a39cd88f324b46db701ca72ef04b997719b07f40d2be91a9ea3adcae30fe19d427b53bb2b8510be16cececb4445dd8fb8a2fc5ee867c08567330c9186b9888f2db17141bd6897d4edea7c3dc158de6f115f190b40087a4b3910c4e306a2334f6d74828a6ec4ea19ffe1cf623a280da5d4dc56f57f4f6f336ae3c3df8a5917c71192989cc9f5a390377d422aafe00264de8eb7e17dfa447b31806b92baf9f8e25297df91abbd0639b299b6d4bdad2536357d2ffe791be713727cd05bf5d7328ac20595461b35dc04438062aabc126364aa8e2bd29bd7465b09c9f278cb51c0181e92098fd925f794c749c99ef411f60389612436d54933330fa593496a58e229b3ecee323f628ec10f13738f691ee82591ed1453a9349b15f82a24b96dcf4758f58fe905839c2fa1b39aa13242322dcb44dc066e335c730e5e2c022ea757f18e4e4cb763db97080b9d818c1add69a2b857d1c5c626c978c21801ba3c7c757f2659fa23b3bc2a4b312341876aa84acf90572d71a7bc345db22985e0fd02db6f1b20e4c142abe7705f4b29b7af21a16b0582f1a3e53be1d091477e14e00d3afaa73204ca7d4a2037e2f3ad416e492700863aa6400a212877e495590e63cbd5902d482f7d55e0c1558d6c9fae5682fa27485578383c3424dc747b88f3460123233a5c2c2e80ec7048fe6a84916b9fca88a5ed0bfc4e86d18b13f6b80b7ff0048238da1c7b5ee956a27b7a3ab2f037478e88812948ead0e493d7b504c0d4a0095313e1181e75dd93bb16e3d5ea7533d7680338361dc652365bee48527109785dd7e564798cc9f14f9ccabbd22e317a2796839b91522a8c6d3cceaa766ccbee26e08d6c855876cc115b23f52104890f1fadd786ab31e449a2d1aa64e27c899de0e0d5d688b06498be2df7224d17609299c6e9bbcf05a4b0e359093b57553c29ac1fd64a0168bd4a9dfb8d8a85a576712483b4b06ead7d15a0c74cc6557999097dc6a89842d89efe254403fecd3c84a7259d7df480daccf80226ae8283f647ede0a58058575d7613874a0060e4a194327807cd441efd96ce7ccdba14eace2bf97311e4da5416e5356612df1dba3d6966b513704b8fcf0082e148e4fc9734179a49fa1596332deeaa08f71b9ea73234b4e556aa3f6bb967f7dc78c667a9d35eb3bb6a202ee96df004795165d345adb3e72bb5b4e4c402b279d51c8d99873a7782a26443d13fb5d69c867529b2bb63c129f0628456af4b841a2dd0c7d87debc7a1a9d7f51822c4fd9170d61e9809833dab4b31dd80d761535508f7af7edb7fa94cef58c4f62770b395e5d39738370d437e23cddd3e53d83b616c1f79d5f6fe9da60c5f63ec22a6f1bc657ac5b44357d80f693ace04d307e3c6849af543ac5b2140e71b3e4a3a70039b0fad005762d0e4bfdec1ff0f8984828951c3674cb56e09a9ce2ea6518fd272041b16b9357a12f7db93e38e77d1d891b1c87eac433280c6378c2fdf33fe66dc306a37a471912c9fd3389378c54fb36c952e510fcadaa111b4273f9693aa70fa60263fc3148179666122b01c536b2a0de17c6c78620182395cc844444088a17caa49110d887bc6c73705f0cda62acd8136ef14e4115cbe9bca322ff8f101e4cafb9b7f58b8969e58ef1bcaa98d7886f001eaac8070bea9080604c276c850783dbbdb0d88ffdea692e467717f635082333a6f4cb1d1fbe92d00716e0a09041d3536facd597a5f5807ea8600425f556b1327f5c2400acd1f30b044ca6733cac6bc53d88adde313a44f42925ebccfe9e84ba7a728966a7ec016ecc791691fd0922fbe494a9076bcbf607fa6e04cc66f18954b438290195c9eacdd80e57be8cd987f63ad516064cc66cbc89855a29f8a001415f591284cf41b32621d76249bd2b30d9805ebae0bb50bc87d6eb536b0adabeefdc8efe1eb7c78835218f0b3942ee2d2362b7bed5403fbfe417d4d67dde16719e965e823d98311af9b281eca242d9afd0ee64284acb8a47552ba90611047f9649abcfbd74793b4504efae1a87b4a78dfa1712e224b24bcf3b26f3d41a37d917e6ffd34212818cd470e92023a32da7cf74d75a981fce9a6742e3b736b13bee302e8dffd19db3d8227c9fe96b8eb2432811c08e8aa9e2ece6235e19ea7e542b2a7271c8a183cc6322946c85acce5f4316244163bbbb9339682a9986c46496d6b40a5499b8212d4cf66dddd6ae574ad48daab91f1c258e647fb5d1a6e2e00eb32b0dc0a9ec801c0c3f1dfa3f297f674d8886308d3b5964e956ed0752055f0ea4f00297113bf1e6c02f8f62435b5e6ba2370a3320c75373ee67ad0644c32be5e8040cd619acc3ef0b74a26673dd956d2596cd4b6d1397bc91cfbea616e258f6bf01494692e96205972aa96fb6a8b5a5974f59f3c4f0e9717cbe743c4548e1fce71307221e9b23d6dc060dff0044041a17696d1a7d6eec4902a283bd8a3a3a0614d43af09e8fef1197b8595b25fe01530b5b040980675e6a6315f3d84331cd5d1a429e2246489ec0fd2d35ff5509a3e96042b9712a43ca49fbbe178505656e78f9f42c6d8ca8a22db85023999376b378da7ffdc6b218278d8873126af4e32aa5c4898efcd3aa799c70431a8e4123ad38086970ddcb23f760006d0d7ba224d20bb7d7cc0a60b875809bb5f9a8d708e6c29aa0a151ea45aa2f50c8723953d380c168a9f2a955da0052c2904944a3a764259b81136e384eb2c697adc5ad0c1ac84d3354b5a3dddf84aa30c563a3d8083b7e023bd879afc4f47b24ff8294864a17ddc0db03aead50707758fc8ee3b1ce072727f6349cc90294641aa49c48162e08ab6eddac2531adf443abadd6efdc79323e3dad1fdf48f83616fc5013ee5625c18a6f86d0d7a41103a9253ab75d142f095c52e266d521217069bb670fb148bd2bd610f477ca2e4260768cc2b64f16112d411eddee7d0027cf951ce4724725a76f30c43ccef277293ed979cad00c03c2479470f5d7f15ab98b3a1a576c60a58ddf28943964da9496760e7b420759ff753cf95db809c64163e82c50b5792ee73ee8a45fb3a647ecd14bd4079cb482f650e78c61e0025a947b720c8e32fbca67ab5dbbed63b4dfe6b064f547a2d4f92c0e4b677be00fca81b5b36b7994ff154e10740b51aab2c921152058a1b09f31ad3fee813fc746427b208db1e90a0f438f2707f0ddf713f1800f6425663cc75d35249e91318d6519ed121286820ee33ef14a82e1e67e0b4e673c2f73462024f9f4d6b9a20ce5ece4bfe7f9297ad5e10cdd4bda46362885d7e4979821de787aacb38d3db5a65b1cf2d4df98ec132bcd2c421db889a2f5ef10066c553a9a99f28569545fa6a0ef34831e282c763146c9ff3c0deb248a88becb2e5e3772d49696862b698a13157b0ed87246d4a54caf73238fc4f8951f07da8842cbc73d44d681ec4019c0fa0409a5544bc4b65398b5e62037679dce38fd5aca87a532e4467703019d47b434e2d47b779823a3b3793a2f817d81faa47db7235f4856165a6a9b3e8aae8cf402e2f7a19320592fa1cef46b5cfb61bdd33ee19a8398df026376a80d235171e3cc4c4c65a69af23194fc443ee8318421fe6ca6723675035a5e4c71d9b403b2d5e563efb590cf017cf5fab4f4702e0c2b16cd9d71a51246d2e3bbe1a9bafdc7f169e151080afbb163c77ee5457ca6befd2169348ddf30b28ee02301efb4cf10782351371063941db4a24b335d7e87036cf93350e1744aba427f7025b7bf0371216fc35e10c0cd75e581466b09b3946e296c80e1079e78964dc9e8644175f65ba5d96b6f5618176f2a6efd2cee20cc4e9b5019701c24aa343f766115bd681321cc94152ff79971b29ee0cd3de1346380c5a75fb37ac6f9be09d91106b55c4db13df42ce3b9e3a33c87ba8764e72f3f84291f893eef3814d407e888c2fc0908fd77a980179127c53dc2b251e33ea0ad2775877a78f114de76cc0b66641eaeeefac33d96249f140e49bc2b4ee8b3b183ad078c550fb37b684da96b6caa600eb412c5f2a14d36bdd7b752105559620c7eb9a926167672e38e1899696287932cf8acaf2f1cc548ed2f6327547da485aa5d026d23ddd6131115b921fea0841bb19039afd99a5b9b88c949896a1b302a283afc72f6807eb0c1e9d9c6596bdde3e6687c695cd6c29f907a908081ef26462670585c2d81603e0b72d7b2e3cc7230d8d874a49c9c987a73d6cea44a93dea3acb8e690813e06ae88e6e76b8558446a794e806271e11a6ba7575e1d2b43556b803c24cd9ff9a02e7f0626e51129bb18b6050cc236e0c6e937d42aeee5036d93909a25891756deb57e5a8e9db1b3b749c2f62b8873c20d4e13b5f79533055b3b1e1b0e599f552e608998681b93675fefb0aa11c61b312a753cad2fc8183d8a9bce01faa0761a4f3bccb129dff70ab914a99ddfea705398cf6e19a0d5524c3691d228f2a6912e5d4d28d01ca1cec8691f26156fce3598fd17939d68c6d0b740b1b79e5e41222ad899d54c426a48e809aaf9c97de6bacb7cf3ac21f582780801af31a1aeddfdc3ce5efe0a5ec6121debc2fba0dff64f2f926678edd50048e896f60e5b486b98d6c9c96d15c9ba87345bc08205770e06113b87c434651fe074658007c6227ee596ee854695b4a26b3372d77e20abbee2e62fe3be22b2fe0784298ebfda4fe26cd68e1886a5de5a027d1551ef31621d6a66b9b0df38dca624c4774af47d7525efbcbb705c1c7f82b15c34ed4cb35da89f3f8173e2a46fe1b07ea37c9a7efcd6eb00e5d3d0a633b2c5af84b8ce6f5e1d830bd93c59b3a48b5be3a0a718bb96b925f8e9fd7733d79555c2fa4184519c3ecb54edd59400e75f495b002becfe40b71a09b68464e405bc29f9a115f176cad661b12efa662bcb745c93d38ea6c2b884daf371611dd88dab5413be6679bd626678b7d610a5452574d42d29613c97cc9f6dfc897b42d9c5fdac02ab08ae5e85dfd7a43ffa61e49a0049f99cfd76fa6ce0522409cf017185134b6317503c961838223de610a9a292db855defb905a1f66ae74eaa2fbf02a9b650116a9f9f0c705d941449ff2b4c9953784981a71e626ffe685705245c9e4918a12a8201634edc41b40cf66bb38f24f2c631d5ca1ff607fc32f887af983e88960c51a8c9e802d8160dc57d6519989ad1cc2fac894c94718979e800d0daef187e918451fef00bfe281e54a3772e11c36118b069e3f0b192552cbc3c6a5e0385fb45cb8ce5f0d40fe3c44cd4205a0f4cc8da837d696361072c5eedb540f129db8d793ef2b41c4e13d2727068bddc6fa30346d81f7fd5f1fa29560020f3cc8be7c28255ae4d9e0ae3f45cb0e4b07fd01213d4b0dfce74d05053609fcc9f64b326504ebb0d67e6fe5398d925fe85f2e056f37991a930490fc13acffee8159572e60ab0465c7f4500c82e21a9106602b54f35e2dbbf8d7c82dc21cb92a65d13fd406b427e634d4907a5c61d8db0ed8969ff19c2e26e9ffd05f1812e9665690fe0427f2e05f6f3ec88ec4d27def10f446a12ffff69607505039ce2770774872fbadf2b02d54d721126ad9df42b759794236c275318350ee0795bf6ca3940daf32ceeef5a0a76d7cd1b81658974230dee528ed6066be5acff279dd4e7563c6c55f4825fee3a1133715301eb7a5c09f2e7609d6180488984dcfaac57c7ee44bf154cf21b3251b7b2b79fa17e9dfec49a9b868e4c1f41b3e2643b2163b0eb80d44992be235b2a6b8f00987433b8ae8d3019aad9264edffa4a8cc38bd7aabc81775803a021c6bc4197834198fa92593513f6638932ca6e101932e0254879885b1a1b99f830eb9d82cc1cd2adca0a00c2225a68cde9f803c7698061c00a2b271f3b398c6c84c329063d9e27b3ecd06a63ad7452276af8fb9a235baaf59e60ddc636222ba0e14b06d1f2a754f653052af440bf6833de3ae1e18964b6d912ae547828137c1608380d8e6af5dd4eb5b946db2ff8aa783d19820f21ecbb399ef60a3ef0fd0425898d88c223fa1b7ec109092168589667208e516663a46c197318d3ff12a3a19ea7ba3858caab5c2f6311f1f5b6a17ab60052257558a945f3c04f51533584c364bdb9542f1d018fbd507e54fed0bebf59bf428740ed4c8f9e0c98c91027edb47701f99219871b07d4b7ea7cd2f17d5f5acc365d64e904598db0acd7576b238a29d10bb8c84cdcc1074f3a353283ffb39bce0f1f5e4423dc03fd19aed04fc191ab7d85582609e45b684d07f3903985404268b3d0e0be2e82e23b453948b40b4d99d731886e502141dc30810ed60dc8e4d2d7fe4380852be34b964a854fdcb6b449b2ee6e4b5160fb897e4722430cb570a3c075c1074a01b229b12e1229de4ee94e215fde2f52b0c17bc173f2e1ff311a1b3b9d73b38386232b4ed2b00c013271e3a8ff06f7396e2f1d896ac0b628d44eab07d0a5a2317a4ef4918c65613465772ad657cb79520031c67906bd61efb6e6f721ad30337d8836c238479f67d6bd4beb1361731a72a8dc41d4193339fc91f7ded5c9f629f1e03c51ccf4f5df24367b9fca3fb9bb42872e3b2c3f61e2b57275c2399a029e51c54484132566a6ee29c996ea936b2ee1f345f8b71310dc44b78b3eafb5b2a8d6a325d26877f46fb6786ae5de9935469c8cf39b74b7d2cef5cb62cee3ad86e280d018ac76b544ea0573453ca0169047385aadeb3375a036d66a3a000ecd038327bef0983d914ff0aa4c8aa42b7796e26a25be7aaca1022f71cf0f77529d42158497be6e64f9c2222a9ad3ca4ef9a02b29407f16f0a4798640e33cf71c3f557ec8aea386c049998493d5215b76129109ade481b79c370871601ddc06ce69481a23223d0e815b590f1ec3a0c8312a90d7bdd85cd504484573396c2a6a81c20b1247a70291c0be835aaf26b6bc507328f96bddbde57115127332c8c91bfc24c95beb75bf0a22e9809d0a8cdf0a72cce9f1d11074fed0bea9945c071db67fbeed90c6392c9ec1e2ed6e22b75f91ab8035f59cead9491adf7cc5ddcb082b5dfe495a9bf7037f13745a2dc8c9b81dc5bf4dd26c2cb950f31deecb9cb3a8cfbf2b553674f8c9198d8e4d678957cda14aeac87a2e7755daa24015b42b20b5b276e3c2c69e714736fbab63fbdd756d142c31fbec534f0510d97df0bac3c0d7b6e55e4d411e0a6e1f0489c9cd9e8f1f872f7b6171cbcb52e36d5f1c22f01a74dcafce61c7e6434c898023ea1df174b5f54b4e34c621080b93c3d45e39c3ba43bc3c3bec558c012a52ee64843349d1ca0a1083b7c778ea495449fd5fefa14ac167815659f6074c47e26891469da5cae97d87c0e097b7b4e2deeaf07d5dad97625dc98d7073c6f081f5972a78b896f72242f1a51209b10735d6fe602f0f04f5bb8b60f736bf61d817e7eff07f731ade2b85ae372406e7363f3eeb1e292fb15f38e0824bf24b248be0906d5eb1c8f8055ab5ecdbc0f88d5514e71391fc05d3acf696a049032c64422087f9c03811013df81329c1608841866f2163a0a898d0675b56bbe60d7939273461e6137e0e9f9e62e693da2cf8a5c67192a3e439c9b03050834f9b2d63af4ddf8e3c91c2d07c95f99830c32bb05fcad9bb3ce530eb5d4f2da5b18cfae7ac2dc33b8611abcbad461f0d9978b62d181cd9c52e78636394c19f347069a0f4f38ff768b7825f8324a09da0817e4c9c95366994c790027ff7f493a1ecdd966c85231374e61c42cfe785386278df60fc08abc786c735838d1f0a4f33ab8f65e387cd8185b27ed06ace0db456a432dfce8649da23352fa5e86c48d66bdadbfeac914bf8bbd9447037ad53792506134af2de3e5c83563e6393917ee7d6cd1d34c81699671c08b8b43c969cae77bfee4da16c2ea18d0ca99d3f1e4a7e840e5474d3ee21107e9466f13298459c093de88f6d0ca818b2a0b3486f7afffb5edd63b8ff6fc6bdfedee4ad8239bf46d56b8ab075c7aace34d6c0f1ba96e0c1066d06c708243077f124325388911911acee3260ea689b28ccb102f08aa629fe9dd22cb5818f3e02d9dc4a3f3be9ac8cda9c62a5115838eec11925caa1fa2543b62965e263b78f3ad93cac885a816aef75885a2701d957155f860a9c0b21dad20f2cfc95dea9dd7c88b8efebe8aa1188f8719ff9622e35fab56c3b6e437286022b94a9af2bc6d2c40a591017e353a64b579a5d5642345ea4e43b4fc7cecf401d398377304412e8f64af0d358afdd69bcd63c9f60b3331712df690c34def7a74c3b4bd3fc849faa1f0d01112a8f14b67f7c0ed1761cf75e2e79c581b31084132c2ce7e09bbe34b5368154aa055d310688c185c0d7427aba80e7d68c5295065519b0181af9a61025f66c96ac5d72c51b2ea2df3cde45cb05741f11a3b71b41af46571ad27415b0f2b8faa8a04136eb2a6bfbf13466896b15eab6c3e77010141d693bca0fec4831351e0b5e513331e9be778e003b3f513fc13c5bcdd9f9ec7e61657a026d38fbc74ecac003c49e1b97446b3fc028203a6378768fcb54f1157a018fd7602f6405b38bb7f58eb421e838efa0f703e5952525f5abb74efb6bd314d335d97913f3ac7c4511f4ef8f320d8d5afb54d664c8308efa67d1c13908e04b14dfc879324eedf0f0d349d5b536bb530ff65bf14ba7fdc3d0193abb7c06154fd261349e2308c259c87511ac61f5eac4d4c3d7d482dcf387461217d359e56c3b57452a846405d0c0353fc14b4696f5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
