<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bffea8ce4cff5f103cdcbc9168b7357be914a984d39fc49d52d600dd71761e3765cb83ab1909742b5f2fecec8878d42be095d345493477949ffdc4698801ab42bcbfdfa9b3417fd95b2fd7755df43b52f6ef14d08b45f5aab555b807e66f9a24ef7b547d5992d0167c666736e4119d176516feadefb432489bafe66fd0d317e973296ebfc95f635fa1d36f2352be823894ce81526835b5de2239367ed7d8002169243c7837c358f0320e3c1c59b0835b139cf2173993ed5d6ea57cde8eb6454f0905becaee4238a6ab3cd6db7dc0de2f42c4870c3124b86c9992aee3007326b6da075160878a422017779c73da897a7e7e0f63191f87a221f67a41f9ed27ca21fa23da689dfdeedd7dc06cd9d1064705a4df0e268055570aa1651288ee2a3bddddf6b186da7a0ed7cda0c048608cc22ca5d493292b30397ce62ad9e9ddef09f06f4de9a4812847a48309cdc5eb8f568b3875fb3898f4deba26100af10d42f4f1a0fa6b9c0c702de14fa0f43121063d7776a19eed4b26a7ddc3438ba2b4840821cc1b344f67f96910b91519c241b5fca8a97b703733a493672c59c04d41c1475026cdb0b8b4ea759ed06ff3af01edce2c1e951c4a51550690b4069821bb101fe954fe157a5103787f3ab089e49f0962d3744205a497b535544694436d7ed22ae55b7b0d628fbcf8bedcf05b64629ce4addbf04af057de7cbbc7969c0e594f63dba5c9cd55204997a131fd8a00c3d251a6410a33e80bbfbb53b9b1ae1d31db0d32d68e12f05cde6abc532a9caa5786cdc9dbe1017bc6470c6ec8bcf395b6bc1031eba189d1d94c6b77fa269f19a9f95e35043be12b2e1a13343739eebcc92e6d4c87b20ddb48f73b38d051381bbd654bbd8aacee25fca5c902efe68c8c3bfda3586346b6b88f21a554231e2db41d22c323a6758703634ee5aed336cc66f93a788b9e6d60f2d8d2b551cf765365a07f31372406c349d06371d5fd1d47020f9b6b23ea2ad79573e4dfb0a5af959817a9abcf81a9724052f909e21dab2b3340f7915f0d389d1d04c93810e7944bc72931f1757e607fe42a0fdd92838b71a787a7e1b99bad8a402189cc92149ea1390dbcabbf86f43531613c93e4593312d444811bda5a1b0bc4ba350b6f2877c42676877e8aa09b037a96068c409b7dae05d49e9cd1583d80c7e3530868eacdf1ba2153ffcb02ed0893c25403b13918ced90365fafbef7d8920d55db9e4a05ec8e437b01ffc4c2c3a45a5674d519939dad4463e0c29795b77894a38a8d4d04422034b9a809468637cf268596f312182fb3a7d5e4ee0629b4968dabbf3fe2d670acb31c191e291219f8ad0e41b13713d524b6b7813fe97a47713500ab67513ddf805c1b423ec0fc0ceddf94338be3b105873a256215c9f555a1aab41ed588e6325a02ba7eb350debb78fcf3e49b11e1f9c23d0152b9ff7deba964a70df07925f1e6e069a85fe41d66dedca2f9d45ed967021fa8d75861cbbe3a5ce7b77f9a5c3e542611891c4b3f33ad3f5a550ba6e8162b03c44814881b23671c9c5320279e8cf178d643f0f1cea75544b0cd5c7944f65cc107c6b1969935956a400eeb485ef6d40880232d54d681dc84ab8840b8ea6e1705d283f93290ad2f7d87f78654ec90d07d4d8fe23acf23845acc4ce73c6e19f66ac8a5651c67885d8695ad576c3a396c033d813850d2fa1716de04732e3ec20c46f2ffda0ab689da28fd30f4b4d3bdd66ed3e15de0a9a17365bcaa0be962e15721c70e33d1ab9dcc095df729782cf9ae6c6910558a1c9b86675c05a5e2d4360f32299aee1eb9ca43dc721e12ffb3e306f9431b33a6d2d06037ba55a8b8fb59cd764d81749c19b4bcf76fc8a9b54efe6e7ae6c73364293e2632316fac984f506fd6394cefc18a5102dc556b0d41c52056c1b5bf6efd55ba16dc6a119e1810b4d9167e249affb9a994992e65779442d64e2e242102a835f9b961e349fb66893e1249c7ce596f9ec54d47ccf00895b032bb915dbb76c498f9782c6c06ad950421e9fc916d34ebb7686e08ade58ce09091de9045f52818d7a960b61c1a4355a0bba3a6872332fc6176e383debe36e6a1a903d6178503d51f70f068d5797646799b129c119b1e2aee6301b41103140d93568a989725b3667b137c3393329a3ba18198ac1a6e57e2a182e4c89a28ccf64ae3fad1902ec8ea76e0b1491bc5e10fa26ab905953a02221f8b8c45724bbc8e03c186671e9fa624edd66ffb4c653f1726fc05366cf9f5ef2cb440f0b22b57fd6f5ee81647d0f18662a95380a8dc442906948fc8295a7a47ce9efb1bc26ccace99cb97de0b929da696001849588bb98d7fbe6df583d4da9d6e4f0a158ff16e431b4558da2d2d435feebf14dd4fef596734fc0cb103dbf2598f030f0ac96166d1e6501a687b0417991a56f7b0663d2d30116e9c6cb3bd2a5075df8c9d6f0a2d3432a01386dbbf2382e1c5bb4c05040a5d80cb7a2dcf12249b2f419d91c85bfa9a01721f648644783030a638e029c6ac7475df969752f250e01a10a3361df3658f6b5177a42c540c5725018ba748937b72680470c24c4f01a4f0268252a3f39d810cce6e03859aca6e38e32764e0acef97995afaf0c07ad99421032c97a61bf37592b87e6dd0ad39a5364722499bc6c4c3eab31240d566a40e8b0d406052b1339a6c86da86c8041352d3b3c1dded878675e4ebca3bc626e7639ac4b5465c743ebc58d98e64dea3fbb481d56e7cc319b3f8e9a7bcec278610a6ea91426044e0ad773855a4bd47f6171cb47ad93be999de861abcaf8b2905063700c954dbc472e62d1ff45240dabbf0e68d5ea02fdb5dc22ff941a5e259b0a2ceb7e1649f1f32c60f410e6aeec1010d047d4373d58864a579ea8f72fc5f3e60aad4a435de833344be4ad9a91cd5d9dad3591b7235e0b3cba3fb80a4ffc15425ec3c3bdb2984659a72278a99e78bb9da8b8193e84c5b0db6fb76f5f64f01edfd90745ab8f2e35e239821d2749b76078c8279fcc027b1b4126988f87430a809baada301ff619f93622083188697e3f8e5ea6cea306f8aec193a7bbbc580f09875b74d7878514f35e6d7e01a14918c3b7a93585c0e2675e6679f37ed815eb56690fe6a4ae67903baf4c7316a9f1c1a21c10301245859a45727fd5e973e3ca7c69d60ef008b0767b598503363692301be1550de8afeb3d6dbbe2b30aa80d2638bf93102584bfefaa1d64a9e8992b2e2e69d62b386df38bc90b30fc614a6ab5d7234b927ae39347738e292adc78c4e98932f1bc856da2fbf5267a1b6dc43e3b51c7b2c590fc5712ab6eb97a8aee1eaeef024924dadbdb5a8472c2fbd1c4becea4d821b17c6988d6daad8f816331c33673659af1896557b94fe464a617c9ad13a8355411313181bbe5a11786a2881e4cd25a8a47b09bcfb6c3fbd10e5615e4c237495b7314de41a7f08c13159334e2134562c987cf9bfd2c9cdce62d3fa4a58e2577e64b4fc6a020c9c35325939639d067548a2d2dcd32c293a4c5eb29fbf33019e0318d4c21e4e322e3d378803a944bf3c81dfa6958d1bb968498e1761dd4d53e80b7a5f30ec7426c01e00d0d1212455232ce3986c248d612c90447f5937c3d8fd04a6d23c2cbb05d3ffeba757f825660bdb6aebc33a1cfb3a63f98aff4c2d4a1c0df2de7ce7e9a4782865e5ea6aa3a28bcf78c6853c464e8da1224fe7b1f9ece900e75e224e469cb8b786f5d402acf6a5cd2355f104f165cf96943b254feef19fb495bd2570591a245e22a77ba1a217469254d589b7f90da2392f4bcfbfb0cfdd17c93cfdc82fc7c67c1b3a7644d1bd037c7375944442cd39da88cb78dcaf974c703e7a89a64b6b8ee7c6694704ac15680d40aab0434c88c4ff32b82cecad1f6ddfc5e09c6f6476cf4c8fb5c4c8028505e9b257190430d1d6ade78b2aa2e460259ee46c0088a1f23055509f68ba0070b4d66746652278d1232507bee3122a30397257d710a3d4c61fa5b2671ddf963ec59d4995c9e38c3f80836483ae66bce926b6c3b7fd04d6ec6a58edda1b9582797ae59785c0778274e1b6b16d368725db81f957749c94db401170e9d9a764f68f370b72f54c19c482e284641b34ef11ece4ea59fa45db08cc21b7c7e36ceaf5aa7bd6e2075c148ff893cac88166a559cc01cfdc18e1302c0d62e753ef13b4ffc8260ac3ca38ea0dcc522007430398366ffe7dba8ad0f01523950a4ec09411b7a64ef690696e44916a1b48f75f7f6e27133c755f2423f8e00ee683f3cbbf71bae7acb52e1904bf7dad554a30a8323b2bbbf164cc9b51990dceae42ac84e6bc425394d54388185b5a899e3cce4b670bda26275a28a6a386df9deb52f01550e63c491bab60f437be572513ed1047eed688cf777eb592cc2fd6970c3b13ef07e1946d9bd87a3baade0ca01b550c1dd6e0c8bd2dbfc1eb50b10bac90b4b351d991ba618ad02ca101769b264b38db88a931bac5c830b3d8adde9e656c857dc647dc99445271e46b2bc31eeab0b193b21cb576fd6ee5aeaa4c68be365fec54af608c3aeb71c517712254ea33fdbe019b758d5a6744a89e9924f9068e844c196343d433c4566105eab2bc2b955160e9f6f1a169e1a1d3a8f9be70462ccb302d31d4fb8eb1e895e206e011a6aa9058f94fb830d9f533825b2f510970d89edfe9bb3b01ca3da6c0cfcf113292fe2745e4d8e909a28a9c3e786e280b0d83b14c40864b17b2c6f47b213559c5b2c36d28635e8b40359becb5813172c45d6300b16738de49d02557fb884a5f46bd7e3890a4fe5d184a761ee95fa43afbddac4d164d8a6938d67b5f11ed7a06d53cca76f2b2aac77a8b931cdfe27490f92203a686486784805cdf52041dfffb4642d9b59963c12b932fa281ff4e7cd2d44bbd2ab3ebf58d062e1f4cd0511bb525927d218671aca63cdf33afdb7fbb903af82c5749028c9edf5456fc3ed221d1a2575119490e67bd0e319b346abbf3a858ab68d2e2156fa76cc8a58c077b387076872f79a6f5d87d4054fc1382546cfc36ba33e2dfe5fac72a0d0292bb51ed6326000c0383b9d5da1dd7ca434bc7d48567c0b3f76ad1b35d6e892c1f2439ac3e989616feff162d11161148fdde792824bbe5c6437d4dd300eaaf70240860f87dd818e95b0592f5484c274ff8043de383caad4fba3c998a9d70f9f3384d468449e84224ba1ca2c0e074869f2d28dd7cfa4e1e7c6e9db3fdce808cf1902ad7978ebdacf959cd1bf9d7cfff23f36a214d86f4e3c6d60f4b00c2913f16801e8eb685240b39602618a1fd8fe279b38de75568d9bb1a0abbe6def1578a5927932226bceebd7a96f71a6e9b2034c08b45ef600edb901d96dc039c11a2a01dd59888b6b245cf4ed82e5525d0ba0bfadb217de84f29f5023319d983a38730166b5edc617c4dd24322d1987fb361ccd2cb48fcddf9d4f69773ea8b92f7171a0f324f627a286598ca870b1b197cb973b4dcb2c6686678a0bf81c6b8743483fd8b4beca325adfe400cc9f90bdc815e5c2babc1ea4e1f34f14b53b7cffc6830657c151ef86221ab1ff8b74ebeffb958b5841c496906279365cd48a78776efe58e310c7adfafd6cf361dad76954405e58a73f2fd685e0980747b316e780e7131799acfb651c98a655fa5987f141b471521d32cfbbd2cfc5d96d9e83d85fe2975f818595769d56e4202ab6c0c2fa9eae400b99b6ac2c6c79460eda4ac497f7f240f3dccee0b7277fb3322b07ca5e5288ba16a897d567f43145d3347d1d3f82c17f2fac5c7c1e438c693ecb059c3d67d0c72bacf2a2fa36a18a9a9b1fd212ff258862dffb531df2fde68228acd4785d6a0efe8af2840bbe3dbd96cc9a780b92a3f401ef7bab37af39d2c11f5546f52a8320e4c0a7af4b3ecc57911e378ba4b188001d18ac169c1d33379623eda34439e1deacd9da3aa664484d1c898b76d8e7d59e73e716de271035f2b54d2616d84bbb6bf622bb1de84668ebd50a882e8d64c463f5e4b7039566f10d1c8191fa110db4517b0884920b6afd17583c05384099253a471680ceba7cd426a5be8e514b50108c19e8d98802e861bd933f4442bdc8d555d8e0fc76284c3e73e6dad801ee6f628eca6c7c9ff1f1695fe8ddf0f434e5685cafeb105aff92360123e2c8d606bf16ce96cd13745f501d58eaafc09bf551c24eab0cc79514ef276dbbbfe28040e6ed0e0b35f6269a3efffaa88b948178a6ee22c22034e53c3026c2bda276576c416b41af676f2f81cc671b4018d4a9989d7852d2747e9c5f8d5581c8b8a1efc4cc6eb7d9105bf72d30f324cf03aa10183411549419bd7c11824fca0f8ef80c80130a291d6ccd1a3761b8222576411f8bf162b180a475ae114016c8f8f897f0edeaa8fc05ea7cb5a4c798968f3f8b79d5c11a43d3143684d11d849e31edc6d790744aa39d81a0cc54b7e2ad9855111135aaef764010a6a658c1f040339dcc20f0ee4c4c912e23de17f6379745aa6e7525a30bd36394586f7e1e50adccdc39c449c7915d1b9f91e533bec839c05cea6b5a9c507c09b4f634d9fce0901cf5edeeb7c359b32f0a2b2422e404c49256593b55841cf722fcc13238a1f90df0dfe240c1033b5d621ad9f3e9b69a9cf09788fdeb66f5a07c80e1653da63363853024c7a627d8339deb2485c16ca64561157129c4dce207dbfd9ad92120005e17b827fcfc3e46fa50c998e1db121efbdbe1619b65edaac4650b6e5e1124c1ed7b46ba847b5626feeba575d142df70d72e616bbb98e017b8794248c088309dd1a96d1a3f02d31455bafaeec21c814c983a8629a79b478a3aa7cd2d67ecddf1e824b18d068a5203150bd1f6309cef8b3327297cea2fe2527835fd8537ca0da4e6755a2d71702d6feebc1c8b98916fc78de5defede6089a7aa5500973c8023b85566482a2ed4936daf50d38e3856002e211333ba5249e496f2b27b56e52fd02c2aa8fa8434549c498b86728082564fbe1349abda4fec4d401421af538e3aa712d911485f860f7dee26944c06b8f220f3ed0d638667c9cae76d408c85b98f948caba3571bae2b15ed7d29ab68ed59a6f122465d51651bcead3313d6fe499c392b2e595319b80c0cda42b80b44b1464ec8178bb4333924e55a4ad33fe12386267bae2bd2ffab347b89d04451007752c026fa98ef9ffe4ff336d4b219a8b319a031e9016bbc86db4616cd278b7a9988741709b38bf6c3ed1258d333b71515587b9404401212527755cfd54cee05f6c3c9cabea9ea5c9e77c354d1b77cc6a4e656566b0017f21f116254ace4c5c1b89b3eaad927a8ddb546edb95d12321ecec54a052f6c6a29f200a31278b97828ac884411688695f3d3b898aa23006770f87e145444103ff3bba876133361735e36f8b887a65022191d4897495aa727a2968e0061d1ecb1e3cb8ee594bfd01116cda3e2604b164078c502d86a923b5d6212d6cc6e55689f2627bb54b73e96f1204a082df53e832b8efc34fd6055bb0bab0ab667f7de22a60deacf8a76f70348295822d39fc37e4c916241ea27b450601e58325c44ddf559b480760c7d7a010010425b1bdab4124514fe5121bc8048161b5f6c4cf552196232373eb7cf98355850e9237c1d68e214fb71c56d24d8b9915c55ff9000e72725fba89266e8167ef1c6df839d782b7a4d49d6b1af23e4119abc7fab01c02359e61da5d2ba4e92f812b86be986aad8bd9c9f52b176043b2f95dff6f7b47ce25c33e3a0b27f4178aa4343e3b5ce13e5fa44b92ec5265554885bbc313220be57a0d9d00474e15dd6a42214b8e48ddd637b59dd0cfa2a127d94b3239b432b6288d7e04917f4ab379f65250614a413852705ed1a993e44c78b8ce43399a1f16c5ff8c1188506fab3a61c1856c362263d209d0271a5d3716be9171e1aeacd46cc14b8cdcd8696cb09f85fd8778ae6625491afe33863c6b77460ca30620b24bb22d5796878769a01603e26ff70973de3e979ddad86fc7ddaca9b6e4fd1205fd14a762bff7c08173ce6b2bef80cdd78936730b0f340e95c49a44e3c3af73a3dfde23acaa796a887d0dea25ee026480752a374d337cd83ccb60dd04f663d2d891cc7112d110da93f3b6d813c2c658e6648af52a07afbc5680aa06ffb4cae9ea5a8e664ccf1094e6b71173e5e1f4bad18ce71fb46b2f31c0146d2c6df72a4ba13d52edc6239a67a163eb8ac383f7fd18d3b29b9b53ab5b1dcca9d04b7629f315260601747a5312a95aa2a929d311e0e3a76aed3045116ff1cd75e6b21f877977e2ea45b15cbd227e35b4be351f6064e7a25fdacc71f34262aaba4d322155e605081f3849530c509e323f3de84965b4a018f75ffd95b55e8ff000276c531e976693fe21be392d905afd3232179657bbcfb290d2cf0c8b41016366ac03775826df4136cbe7376ec30a7d5d190913239a2e2d680517953d90db8b4bfb61dcc5fe28b6a06a21946444de2ab16ffe2de8934e001eca1dd91c821e7531f0e4f104311ff5b36071b6134270183ca64fc19adc4e33a36b98350bc6b32115fa5f40000bd5a799819698a3e4963c9a115ff5785d506d7b85b892d61a2edbfc449fec00d98b18017ccf2557e76a694bac5d85c3b8907817182f798292a407283a14b8a6638e146717923c18f493d8dd5b4ee8db4bd4a81124af27abfd8deacff97f1d50468e8710e5a2ac926a34e402f449813337efb3aaf2c17b40541b59a89271067fe3f0d553fab8b4b80f1e080f5d507cb6dd8d5829b58cf53c5a1b72a50ecab16a8f6dd0d8ebc631372534074bbe65d61f9509962cf6179eff89140ef95327ae05dcdd992e792fd451472123f787be6acd46d238cd6ab57381fc5c8dacc75ca8d208b2c79f2edf56546f40003ed21b9d7d3018b828eaa2cbaf03807bbd53f4cd80426ce31baebd4e98221fabd02e4445869c6fd99aac5ee6d84e57fe05912f4ad84caa5afb148348e3f7b1399c9d685522aa0c32b984daba263d4b19b84cebd275cff198d46f5e6bb5a369a309bb6ccb2932942b3398633d634f443dd904009440143d90f8be01c491e0e0536551aea6794b283f80a3876e7bf38ed56d3ceae79a90e14628d8efcae5aaa928351f0c34cd15b790924d073b4ead2f6f109c507a57e671ff8a4864404d52a00ede5c26685be84e6af23e844a0feca0f4394aadcb6e7c114dc8bef8392d8c7ce3ed089c62d5051f94c140c0d51db31325fb85a20d504039fd3369264a06036e8450c6e01d21fca8b623b919eda7835e8f9122ab453bd32973a1f23890b788f4e42a60c7152be144e0f949b8ba3d4d0c576e242af3b1806ccf99ddcdb44c880e62b1ca79c77f083cd69116e52a5d90e79855fee1b66e8bd221d73fc8611033c1a792a29ebfe50407c08be02d280ad1fe3fe8af5711765712e5438f3372d4a194b909ee6d64ae9af5a19183e522ca5e3d5877081cf8a9dfd748cd74256e927e023aa1621aa709f0e2b20786ee2963be9257a759bf71eb6fd2b5ae10b01653d7f4875783af91e6f641d941c7f68b5a22d2eabdeff6625c8710e0ec446d6b6c886ba7bbb9ec838267aeb29632fece6eef76b8002d4f1a3862345d3b61ea8f7d7ec5bda102b0f9c6c210d3da09b58e079c9739ec8ec43bffadae842a34d5c519ac6727f7ff2178c24f435d8d3ad8761d397eb4c48e467c27b49573f059e67dc2a873fe7589661488aae3df8f006cd1c4f403e51d81680b9d67b8a2665ecf47be529f5b758ff9afcddedc44bc71e58874a9337d28d9e723895812509cc52503f869773fd2d6861f8b23d27afe71b09f194f0c18daf25584c778a465650f0536ce75209a50171481b2d7afd7359d04c0ed3f9c357b7b946831b7260a19d71a2c568351fcf968eca43506ea3e6647e1c3fda3b7325ec2c0998f41f922ff201f214a4d0bed22872a942540319237803da76700c070081d4b6a4c603be86a7d7bc860f305d43f73709940603dd37ee0da2cb94f99c6c772fe3a2749e87ca88f7fb2728bec8b0f12d643cb8071be5c185d5298b46f5c20453edaa43519aaed6e707fc2633dc123f31f91301df1513aa5289ece40ee31e6f780061b94d203bda7d393923ea854567667bf710ac5e5f9c6d709291b9b0ea988752b58c157bcddf87d7c32ae30e1fe118723b88153295387e811a7d69e492eabb050004ae8a2396d7630fcb0b32b4b302a727cb17b91af3b41d2e14db7fc1f55b1cd15c30e1d78e4c7238637dc3a4653b0a9704fe08f9fc4508ec55a3e782a5b543fb5921a0be36d185eb69dbd2c9545e09e51c4904eabc864e0e2c8e4773df7c290bb951ad56faef14220577cf93a55721de637c9ed1734fcc5d37174e224e87ef0e537c3ecb6fc1dd2c2e5615f2005907aca137184783e1cdade498e89865fab020c8cd909e633c74d7db56f7477adbf8d9eb3e6b91581726ffb14c47fbedc6dacff0700df579e1ebbccf958c8a19669ca6db05938180ee0a6a41377d469f2dff4685e452ca9b22a5379052398a3ef49fe518f4c83e8ee18da6c262d8086f61fa4398d8041fe990a753cbaab1426395740e29d041247d523804fb7fb11532ff404561bc78b469f2bb7db7cb59dda2d98c17a2a378ea309d2011d2ff06dd42f06d204d6f53d00c75a586433a7009721dac27f48c71012e660d1801f7d062f366994462edd5e192204bf72461e6daed532609d88ced402ec2eb2b46418bc340e0c2d24f670dadf506c98823fe89f3515b07bfb50aed024d8a7260e51bcf83bc22e5b5b6b76192c8810f8c3083a1b530ad557c01acfee66ba321026dd0f8921075cf3a8cd54e5e496263ceda87f184f462e6d8f261879aeb2d1c40a99846367b63ec234bcd51368e1a8a020c1ba01b465ab113106846163e74bbb6f415dbe5ff8209df0872111c7191585de4526ebf77fb5f72c9fa176c41e2350dab1716a01f81eb4f20adcfe63d6bb5e847012265a61b6033b04f744cfbcf822f5ba7b91625b815ad182d0e85083f53100346794d084562556018bc4f41b6b6731472048017dbb9b3081b256385c146e65e3bea0d0625e3aacbdce818c59427887d20d66c512cfe91abe646f2c034678eb9af23019a94175f44771ffd4661ba481058525b4baf609d16d423f367ae38f756493f87b328451d77d203c38d15bc0921c28396a704d2426de17c7e09d7250fe0670e169660d0876f722a3854d6ab4e6021a92adf6c6aa2f3f2b30fad0194c3e7dc05c7fd188d52b1813a378d0b032c762ffe63aaa299583c36316b4f0f0fa767d7176cdfd120ace0cf06d46e731541ebc0cd1f8516036763867ff00a8a9a4074a40a2c52db6f24dacd23b5c284c27481d2261f52893e60e0815ef1bc86edc42c77d2a58c19c36ace1c953c6c489070b232a2de42a1f21ae9705a6a01b2610681472e3d0105c2c5e99465d465e9b3880b9c0c6e203000dec72aa02b0350ba6d91290459035f760d7d874c77c1b5fcebbb3b4d05e988da18e9100e8ef84b07c3c1ba7eea7b39fcc6a53b1b35d396a0027a8283d914710b62b00b3ae0a79aac1d64856420befd59c2148b42b043eb64b89219690abcb0bc29410015cb998c9058fc7a96d3636353d62d755122cca63ae7a4adcd32a49cb1bd689d170bdfeb6ee38f8dbcb2c05a30c23ba41b0dc00ac15dc8220c47a3a321091563a479d09c3b55b063cc4e128fff4d74d657513b3f7d0d30bdf7fab574a937f3b3e0dd227545be919a6c789bf82186b0654c7a04c1fc425a675a7f542de40eee25a20415135bec4fef84b5af9c1e97b3b0bd2c546e52e99c4022ae9750b799627af8b785ac8198154fc07d166d6b01eeaa584813eda18f444a0e34d8d84c5d5ff98d7d6415f5a43bd67157de1e718cd46c728127e8227602b887339d8b94725c4045cc21fa569fc742fc6fe6b87854f6a99a8012d73a52845e037d961afd79a02c8c3af5bc5d1ec0b2c9a7e27037aa68d4d3215eeee73d63d5702056d5197b2eb77670dee40d4e3543dacaaf1dbbcb29a5e78f7ad0f8d1a7fd2a312f8a30b7f7b7ba64b8247dfd6a10eaffca7a748ad67452bcb7439b9bf7e7cc3689028e1ccd0fe6d541a757dc09a98c6423c55bcf7b6e6d57719257f25f97fd97f0836e345c4bce905be5de97133a0cdf8a2ba64b25384b0359bcb165f3de962bdc7e5707d21ca58479cb0893f936195d13ee46c795206d926cc58b1acc34512d018001a9af3eb68019fca35b19c26222b3e6f3c003cd52ad206f996e9a4ead266a80e8c2b4ef1c9dea3b73d2eb3f9705a94e2ab518d23941ec4e32d6afdac8a6f2b1eec28d4e08a3a1c1dae392a83af09b48a03425918502a9e05d2e796754bb6658854d8935ce7d67a45c0d8e40847de41a1dc9c15eae8983209c09101ee6638a2d35f4b11a3e91e7bbaa6e3503a2eeebb73f582e15b39f4394f8a18b2f3ff3e9c3b7c050fed31c3957aa6103505cda80043a0c521a8883dd1b9f5f56417266321354ffbfce92d0202dc5877ca4f40d21d8fec1e146972f3648f53f63f7d52d408efb89476732af547a04296244701f035fca3c3af6e141f1f28ff1cbe881786ab1c16e99c91538f41d4cc1eebd2a5f4ba18fc92f1d426d9e337aa62bd694b3edc2d36215dda4cf71277fbc1c44150eff91959f7060dc8eff7aaab200551ae51ddceb373d96620b1c655947d934e675a142c46d71f6208528eac245fc394ea47880f81c4f66b63e692416e5585946ad512a7631611d6a47aad52fa4d66131150bb80eb63ae16a9ba31844b78b9c9ec326fbb52540b35b8ca883ec60d1008913c12c7a30add0910e5dfb290a89b4fdfe54b79ec7582059c6712a6b6cd48fbab7c356c214782c81dc895fa41396e77ea3401f29431e4a6277f230ac2be927fcc89787b291be473277a5c2dca524d3ce7abed0cc4f2d81f478f6f8568c3027e5b16ee2b034a7a6e01351f9607b2f48523aae9c36de9f08cedbc4aa14612c83cdd42ee7a4a465d3f2b802ddb4e3feeb8d7f5cf4701225a11e83fc1062406068cc1fb94af5a23664","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
