<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"20a08f6a7e933e1826d0f7138191f4094ba76368429c0a1e6a40f15990c4556f2959d6e57eff999b02fa6fb8d143079a2b69a65de3877a7b08a9c32a4cb2e151fdfdd025bbb21779b44b473ea3670297f4234e6feed8cdfbe2672d3d43becdf677d993ac11eaba46ff47950e04f9cfafb6bc882bc4c86eb029fcda066c5e05db3b1f51d633c592d0976ded1e1ed355b68a597477c0f045619efb332c0178331302c92e6f0bd7481fc3338c209c41490f1cbfa155b85a9559ff1eb068d9b5af65ff26a076f283e19e26a8c94a618e49f10f4c6b84d266926bdea0c49255c006eeb739bd541ff24b8dd36770d55d5a3d8fedcca83baeffbcffac53a4d9ee4268b1277c22a771ff4cd4a248a07fde0a3776394d845c7c86872f6a13fe12c79ef019c44fbb06ec08427193b2a46f111f6844ef349e938476078e5f9e232aef11ad58f25466d1223311b2c94104178105f1673e886e7d9d42b6917b7e4343f9df701170f68ba4644eebbd1e4470aeca56224dcf1cc0a8dc9abd451f6e7a425730532997b3e95322cc594c110cebc44039c2625492b5f081e0f5b30c617fcdb99949d3e542d10adc135ddc406cbc85625b5a8cef81f11e82a0c5781c8b67eb0aeb59cf7b38d0dd4878af793e7a97d873645041852a97f0bac7adf320ddc2d1fdf3dfcee30ae7bff50111596695f4c15141511f9752c0fd0c5d248564aab12012929142a0ea54e599551acc76fb36546fc516b1a4d6213e08391c1b8f0453af236895a89f0fccbd1e482f199681fda56a7418b8581bd8867abf3d3219a33022291f2d169abaed4800ec35fcebdfb45466dc5444d8fcd2509e2959bb72246cb53befd0e6fbdd16a6fd9a319e12ba77b5c2b26229f60230c13df40936cd8463aecf77d23a5c720109c4c7677b399114fb24c8c0f9307a263bd110aea74112e3b5357a84dc5c8a0137febcea9aba1418a2a8759d44184bfeab8af6f80da36566184735859d8f2a108d86f603c701de85bc12bf75ef62479c601b4eb60676e4cba48edea58cf5d63f8508b9feb96374208a2703218559637b244f528539f2f52ce794dc5e842eee3010492ecbb4d27330978571558d0de6e19a7f64bf8283b10d948baad3733576d06dd3e9aadb02519bb35f36ab730f4ee2b5af41241149200d32ea49b0fc1e1c6938156a48878fca041781800bf1b9fcb5b9c6dd5356cd83fc71644e9f569b5b1e19e2b3028a00a5632bcf93bcca20d88e9afd91fe4196e47b9fb7819c86df4d495173a796d4302b6b2979aefa9b0f4a17928caa46fcfcbf2e64630199dceb2525a7b0d056f72b20065eb0098b0475019ea25bb1cbc58397609a5c1364be86649a08d1894cfad60452c6b2b1ef61e6db9904a59c8dac59c03a2732cf941abe70c86400ed3ff4b23d4af510ef7cd155a0d81edbb6f833583ba52fbf5656487d52d2616c563595284e0c7e54bae0d4bcbd92b8d3a5b76910f679086457a98e57eb8e86f79d7275bd3f1d33eb78c28b311973ef73c74bdeb2a7128112ec6a12871fd2905aad4afb42d384a963fe818bc82e58cf5e1e335232577707292d66ba1fc66518bfaab0f66100d9efb13c1a626d9c80c1d6f33ca92fbbd54646a3ad057627c80058edb4bf8a831828553baa0f68c99389d4d1e9a7ffc89db8fb4427131885f0a98885690a69ea7304a4404793273592b2d2eef2ba4a89d46532117b3f439844f57fe751732434d0c04c41c266a26c250daff0f8eb24f71b559c2af3097342ba0fcf2395249a8db210c800ff607f2edfdce3c5246468593a139bc83c753873a8e1f23f74337c36a4dfccf0ac83d7eff9ee7b6de47686669859801da5bc47c62f56a486e0f98f4fbb76df80d7a23b09922944d3b3a2d53ebfebeb6397b0da6bd321de2f34f37a1087893e5bd24457ff76def9e992ecbfcf3d79cfe4c8369dde85ed69c64c66e4ed620dd88c2196d1f09855388e95eeaae0e16d6f4d4f621f7b887ad201f0a942ab45f18b7d2cc1a5f08a768463b514f5957b74a72350b885b073e9a3af2f74a18c2be346b0310d0bc7a5220e87267ac1dce28f4947634656e9568420310fc141d95af671d69cf6fe2f5d0e6e4b253cdae2b71f72cc5cbde10e88252e2e98c2105d8805856d7a541d86f7fb5eccc527717958910efa856f87d778fa9e319c125e8f969c66003f20d59139f36486479db5678e5a8d7f38580ea35efbf20384ffff7af067bd21f880cb361a4257034b24ff6e24f4889e8fb3a084dbcbf669a4831fdb7bc45741ef9d4397f7c5b50862e22dbdac5004aadc21c1ae523928ae6439810a306a0945d8c2b0f098b3ee57b19242eae45813aaf1996d1c45c441d06905dacf6e6711d9d20e41179db5e718607f456a56fb7c5dd6c084f053ed0ce7a56e177ef7eda32db868efa1143b0b1808e4cd379363159efe199e658eb859f1220a540e2231d1754ad319eea20cdbfbc3e4067407c864d41e9ec5cebc4d340eabdbe8b60314ebef4982abec73bb8291bab11692933c4a471a658f6cab9dd8705440c3894fa34dae70bfb5ccdc47d623befec10841bab6e64ba773484f20fee0b38bdaaf39cc7c3ee91da74359dc382f1d11854de0953d171d2027d82f47db5bc52ebc04376c173c8c3c2744f124e22ca662111d61b03513ad0986c4d03ea82f0c0ad57ee836c95f3e44a9c3214149d6ab1d578a7917a440f7b296ce4c7dfe775fc418b99ef3a93db3bb2ca64af466d221f907f06adc8abdfa0900844a62eed0b26ec6d214d6a5d125766d2c118a26a8d4472e8916abd16558206dc279bb67b4d1d56141c66057f39634acdb01a0ac32aa6a23b20fc0297e4bdba4a81916f015313b4597d916540e8a2768fdfa5b830038edc13f2cdd3a6b8e2bf5012a6fe6533367ba1f1ea516a2696cd5c8acde4db14a46a019690fd3f76f46c3238049412a7287e53eaa7498846ccc7c022e3510a4a39aff79282dcffba8ff6499aa9890751aba058973e1c8a8f0b0ce7bfb0c1560318276a98f902a8cad76e7ef5cccd10e6bb6acd32682640a444d812f7f76c43f5bd64d5650e89d2062ff90e94d49f12700f4ee0572ef678ac4b17c79a7d2c2329b5938d1f21459c25a9c5c46900dcf69e9f7a836d411c0a954a771da8ceb81fad6cb47cbf8baeae23e9cce07ae574f776ce3e611dcfdb4686d8ac2041421c63feecd9abc028745a51debc2d9e58d48b867dd891b5f76549f52116d8010b65b66912172f7c34b1f6abbbb748a5fcab08f9dba2e0ca0b1c30f74b157586f8d3c7a924574af40d001901fe5c08f1500ef01cfede23f4d8349e244de332a45bf39dd8bc1d7a839d8c3208d01dbc671a2e5badf5790cae4088e75e8971b212e5899121f838a0c1b6f1fbc345a08af63916ae6edeb75786ba21e6466d727a9c37b9ac418cb84d8f81ade1b83dbf1aa2d8623b44980a082316a15ab90e205ff1afc7b90ac4e13abe2b3ea90c4b8ca2b3c76558b61ebcdb60212872d25930299aafcf242ad9267108915e6572ca2356fadf97cf6fe30ea1a69f75d8dda71b8cf9eb3d66697250e51895b5733e4f25c72d3ede127a5850d85bb5dfbd764a8a1befb7e769dd33c1340383a6e9040ff44a7c6e8ec550ad970ab2a265ce76a63cbb3472599281d0c6ddcb397328bcf33ef4cc6c1323354c64b60a8d6137e2abd961e5ca66b86e1de36089e21877f7389e77ac407be209f8254394c7b13d3983ef239edddede633f5ba205a258da4e52d560ed1ff8cf7bf77cb4bb883091808df7f630d92260c05988fb03ecfb73a29356881686f2be4729ae8ecd7ad72be81675388e2b82ca5d540893e8faaba2c9b3c42ca96c722281f6dfc7bdf25fb043c40a6b07344f0dedb27a95148815250e5987d7ac864fef74b557b671a3f23b5aebe9d255aaf3e50dc383707ffd65246010ddf285e0dce5308389da39295df73619b84923847cb39672155d8cf3cabf41420e4ae47f2a883f7e40b8c0e4a9c7ce513d10c02b2ca9f7b877be7904cab46f3078b6c945f404a423c0fc4150737b469bbffcac0a59b8fc0f8b46b6298e340142f6eb9edd51746aa323a2fa2321a9ca40e083fab8821787713160e3352c5d1fe022f2a8fee54b4280c5f066378659f4426030db570def92ec9a88d4eadd23e8cddb5654e9057e9fd5e739f23b89add4b3850322f08707dabde028e748ee3bda5c62a2fb79c69acbaf5729e8c553bf85651d7902c13ce9dd86f76a2c8cb58177622d374c07953fae84ef0c4a2c651ef89198f6ee388b6edf50a7208ae117177d1de8128c09039c32823e67f0d02b3ffed7422cd9367477433065ad465913e544a2cb66132e63846206bff687287452321ab54b1320aa5ce2336f4a3b0a9028ffe540c44e72eb27db15f8ccb01ccc6e48d686e6f6a9b3b3bf93c449e0e002e0eb5ed9c512cdcad19a545991a57f5433b609aaad7587358a992f5a90f0e3a3fbeba3dcf2563c12b3e16b13559d0ce753b7b2fd5b135a57ee394815f2fff4d8bb8eaa970de3f94e27a15923dd43da08dca5bcd83fa189d51a07e93b43d95271d7bac1b1bdd0a5c10ee2f23dca88495b652d6059f5e4d87863d4fd3d676c68f7606b7cb2157a5be48238ddeab80b07d6dbaa1708428a1f6ed10f1ddd4599e19d14d469b4f4d4adaf9f03369308661b0d60bd8f05f9e584f4cb52869f2fe00caf2fab35d1c41cac81a716cf271f560bd097a773dfa7c606eeecee750fc03a488d58dd2fb3d21ec7c96f4c8438b5af5bb0af1c243de94ae890e6cc1b760ca87e271fcd5042fbf8f79d0876dbfe689263881831e340a6a61c57331b380d809fe7b8b5e12422ae73f60c20252764d48803b4137908cac68cb5177fd12e077a3588c0d06cb870c2c2dbf5e5ff18718e51cc0ccea90f562aa254702cee9452e50ee3118eafb890ea4e52ee009e56f75f8d5137adcf712547bea3e9a430f44fecb58a6f72939fbcf3d72316d9dbce12ec5ec4d177f56cdee18d8bc75da286260c54c9ab7f4a7163ab8dc0584d212eaa07ea6ecd890832f6e8f92879858f88b4d799bd0cd92fdd174419927d69bd6789bbc2773fdfea163d3679d984116840bfb38d3b8330535b5125d14c2b090c05277987d21a88050165987d11f6797b845c831a7517149ac35fbe13be995b0c1872fdc4efbd58be3fed4b593b666072d2b8ae13857b8ede58dd8a48cc6582f00288b8a5fef3ea1b6455eb352bf144e9a7937d9e25537e5552103fd62c14343830e9c827de7c3b10ace57159c3100ae1c75e072c4efcc4b9c67b3ee4b1fe9737fa8f0e0a434e5d68d0017b98a40b4cdedca97d82f2a724c1d24501ef6949a69ca85077a8e6b662b43e3dc3852879422afe778cbbda9f044ce105a2170b12d3c35d5e96db0ba1a0960eb783110a51c375a3b99657ecb806df224bda04e90dc6be9f4d3a267d182cadae50a73d7775ee1a6f3329d8318c54170e3914ebed3b2fe51c4f2412663bce876397feba3058ce10ab28b370093901f95ac4050536ee7d4a29d1e7c365dae953b8ad1f68d3a0247263995640fbcc76c88b3cbb5a8476fde7a8ba5f6220fe8c3211875b32f7e3df621216cddbb791a5bf146fc4c0693fe6bdb4db43feda8ae7371358cc46e3ba1288fb7a4970df0bb9c31247a211eed9f008054b869d5384da481d1b6f79d41a4cbe8b88ed9b072e2c14d1943552641acdf33d79d8c968429c7ba43c0c209a9536bb26627cc33e9f1dd47119679e99944291883eb851c38bfb1e326681745c9ccf429d1c1e1664bcee4b27a4dfc4447e5805c9b48918bd3d8866ac9ef1942362809a4581701bc12ded2548302c6226aa74a7c33cc1f5570b15c784914e28c0bb1cefc78c14a0edf272eb4d55885910a4b85a0d083035742205bfdcca21e90bd46cbd18e3a34d091c1fd0fa3e38d002d52c01a02d9311787b810dc052c56cdc5a9694c1c8b1799ea079a724b05faaddf038c41b787275110dcc049f72c621e16e2ee9e1b3bc870fba162e8b1da0d914e6fa69498106718b14e6edf7caa16615a89f4e3d43131ef7a83ea65e4f33d28fbffd96e619d4bd018f7b97151f5ed285ca46bcaf29857a60421d72e78c2c527ee40ee082b5dfb8ecac48a9e4ea551805fa70239e68b1274718968790a10fc449a4ff39ca188d8e941a374355b3a87fbfc4c472f13cbb492f158e37a9a427692e232e5c3a8ebbd093d74bc50a23be7be2b47daaa6cc47dbdc8046f0d5f76a553f780d7076624453130a959eb219bae7f4e78910fac4926817b280e9fafe1fc2a9984c3ab610edfa77b7f85ee461b6b2c1246d6aea3d2d6f8f9dc2056036d10ccea8b30395dfaa684152c74ff882013963b47ec335e61feb39adb1641a9175d996152dba43b9efb0c9fa4f340cae6bc6ac2a00f7445d03d45e3c51e3b9743e172e0199ccf54fe6e9feb0d22c6b0d2bcfe19253ab561d3e141f404545c558b30bf8553f92e709809d464ae7499a904115396908cfee11b534c5df5f1b0169a8cee673214b34b615330b76df386231be872d5ca9d3d1f783a0e396f4b94b355ddf2108a2abb87f0f136241f9c9ece284da9c68001d72f69891be3bc7cc470e8ae99982d14fc885522688b3e6418c479a1270b41220e0003a087e31940303f496ecd6c14c7d1c81742d879f12f749b040c757abfa0ce0b6583af5ba57876350e326b081db3c988ae2ebe0f59d763e2a59a6cf7ac0bb9f5301416d90c04b76ea48707baddae873e5a5f76688320ad371aaccd1ddf03f8ba3521706c9402ac534755bae108a4aed55af2cd4973656f1e30db763198a32909bf09abe858e9cf107c911be890a374ebdf9e183003c987a86b31a1daf2b574ee66b21ebcddebfc290088a5030c9e582d58576a571ea94ec033cf9f7d7fdbb07f15aaa0dbf8166266a16adf4115df9502bda52980785f82b3db5e903adb92bb6af23be221159fba8920c102e8d50da731f9de2e794425daede3be0c5142bbe9683df03d02c5447586f57feecfe44c304221635aaacc46fbddcce409a1ba85e3e0c27032efa9fd586ecada2d1f132ab5ad46035fbc3b63295d6d7dea522cf1bfab10605e98e9b6019f78cfdf9227f0131715d624dfd7523182d14fed84d351809922d1cf6cc65ee67216af2f5f8000dc789ce6eb587d9de708289c91045fe97b85b156c9d9ce4725e1273def17dcdf9b5121fc3301090fd2687eab25ed3039e2d0498dcfbff2b5f71be53dd74f8f4aefcb847640bd08dd86b0945185a0ed9b386436effc06314ddca028ba75394fc14ba4a5d0c0ffbf89c671c96238e1d43c9b960b1b022cf10d5cf7e511a395216d134cfb0b7cc28b8ca334a57d409776c5209e863027e728f91eb0e11563ca1d66799cf858910362872d13868e30fd6d575c489e604c4d23e6bbae715830e5cdbee8f322c49c41445e431a1ca1f18d95911f8b49e7c3615a13ba02ad4a74a2841363bc6a56ba3b68d80654f4968dfe7ae1c1b84395cdbce6525a079a211eef1e856d8f1d9894120a259468b293056883b2e2b0bf7adc947f5a166f1d89903d35a022dacc6e54c08703d1e3c39ab5ec1ca1790b31e09e40e1e4443dbc0c996b8dfa09c3a5dafbd178ed181ea882cf81e927c56d3fc9d5d44861b3bb27d6c3b4aba4785bf558d2a07467b1bed6ca414b6e699a03366945024320f04afde119bb346521b68698c0c2e44699a2ba3840a628d642a6665159031decce90594262a8804552a9714c06abd29ed52bcff341cf5427625a2def399ca7b76f0eca7204c3776099cf710222d1086e9fef7393e259335893dd9790aeecbe0f81d5a01aad1948a3a3e748f8c22011079327187db023592ff428d0d327d9abf5edcf8aeda6ab1a5842142dcc901236ad9ed87cbe713428f6ca8b35467608a38109cfbcfc2a5e28ef2501a4a27796e9bea8c46e34b3463dca07fffde13e282374247b8838710c025be02446e1608db22a5a35507d28dd349d6cbcb0ef257b2addcb58017543bece42716c40145a6762bd7222c97219ff1d584d22e2e0642674e532d626ed1e5c8f9ce162fb61f7361b09020a25253c88a09cca123004ab44559a1730e7742309e31d3dfae7df66f7041a7e180160d990239067eeed6f5e6698d3ae9d5f27b862f32483d8df8416f727055d543c3cce03fe1c1789366dd2e2ded4fdae8f08af289963605c8f27e6ddca076d13d5d6070a365a0af2dd4e3d9788e1a2c1adf253c617238946f1c732a76140af66165f4b6b62a2fd0878e379b7debc0fd9fdde8316d931c14232b5d28ff963026b556152fdefe2c95d75ff45e33b61b3d1f4dd42ac93d4028da2a6da70e2d98a3669ad708ee0b15917bb47cb6c8e5af7322f97ab3f2782381730f7b45a46aed9ff587df503cdbddecec09c0a69212ae6874c1778b3308045e8d5f31ca34596e883d4c200bdf6e2599688473b1cc9fd529d559318a95a7a59e0e20a6353ce0e143accc72444bc97b01193300d7fc7185ead8b30c3a78e64a2ff87d4129ae20eb8129f10f70d80e367d49f4dc9a6545fe3016cfb9d8453bf5034792119e40ea0e6e26371cc3cf21179df8068f67d1061456ad081f809b3a80ae2cc5b4ec0c7ece17c464d1b6ff2356f87ebc33a375e529cbe4e2388ef9133285f9978af5666e84a602b1fdbbe2c43a21b50a90a2ebc96bde2e9bb460fa25b8dc76cb7646f2c8907b41d7216d6e3faef076ca64d30ceddf52833eecac6ebc45628df8a47054d14d1a5ce9396993ac883123db37bda364b7de3310f9fa7f8d7cd69ef9706b6f30a01499f0216b9d34432d8f26460a3d78675d0a013159acd4a5f4c0a2bfb3cb2431cd694992fae3f3a82218a2db9983a5fd757470609d3c5d580b14c73f6cc23ae49890b923f3a78a3605c9295a72ba025a425dbd6305ed49e4aa67375d472f558e137994afc176c1967a1dd802905a5d321fa63a7b90115c17c33e65ecb0ec9c7ee902110a46d0a50bd0820683043341c1fbf52fdf3b96df0c770e4ef92495b8d26d4d052cfc3c68b36aaddc2041d005086121486070d4f282bde77aad46014198e5e90b20b4f2f0d8e55fe5b62a5c015a10e891d9f0a047d539a7748d34c2232d846f682709b18e4c2f18e0bf931572c6c8de5b979e35121e4f242165e5f2913cd2d5bfef6dea1f9691ca0a96410ccaae24a48f67af4cdc9c27d75157404eb6cbd981d41fa499d4739c621afee3d8c43cee123d27cf808f8fe9af51347e6859e0eb34247a0ea66ae16e9208531ffb01e17e9c84044c2cdb1f818276ccb11c281f4891d36dea817e541751187865d1402485e32979faf84a9367dab44c68e8f8d1dc8a3e59e31a8cd2b14323fad8fd47171d5c23409ee1e6f4275be8951d8f52b18ae9ee5f2cad46513fa6a9942cfe2dfa3bf8612deef47c70274b21a5fe0fa2fc7b48a36ae17bac8fd538ec535eb7226f325840f3b3472332da24c8894fa99273ad24b0385f379dc986eb1a7f2d53b60746d486b5a96326791078e7a8a84a2edc189dc4354f5c01032ff10de98f3e5f97f79a9119638c2545e34bf84054bf6a2a83cd6a7e3349a1fdcd915e41d14ac3fb3337bd6aa9b2bbea049e0e9ea28148d559f415ec8ba460f54127ebfff6686b8d45a2ffffdebb50f7f4bdae42dd9a4901cac0ebfe61cc41dbe43e3cd9e6e4d6464e42da9134979866a11724c19d64fbb73e67994decf1082b12ff6b30f593dee0741ff3cb7e819173c326bbae4b643b0880d2588efd03595e71e22a9e49a84c52f4f618f48505f75ddd5c7817722162928a3fcd16468036aa56c9dccb86b4c5051908a043a601ead672f98ca1165d356fbe2f708635a7667cc77e75597316f35c574002ece08208a289d7fdc90b77ff4e1f90720177c0c34163d190f5f6f6cce9f9223f74c2bb5d835228782ed3eb4a05c804c754994d50d28525a22f6ec91e4472eb51855abf882ec126181fe93ced95056fe1d7317a27649615ce3fae76e0f4e6a9c6e783c901dc940ead9a0bf9577f92a9688873dd5c10077e83dff5c674aecb8c4d1526cb003a57763056d0ad0efbac798636349d7bbb7c828676fc36ee43b30f6f18999a478045e0073e4f6c4fd0afac0887f255ba0d1809346b564f9bb886723e91e70f1ee2e0d387a8fb2e7faa8a1635d7adfba7dc17683147f5388c9dc331c56c8178f96afb443814cd2254bfac3a2553c6266e0bf90eab15fd30ba7072cc05b981c251b78a06fa29e38e041fccb1eda4594bc84f5feb5f66e570add38d2ecf46d807351e564c2fdf42ea820ed931a66e0fdc51ce9b1dfa915f34b3d309aff3d8336d15db1115c4a825be5b6edbb6c186273013583f9080977b9cadb933ccd9e96cde1255e981c0fb863ea131cde0d1dd1468481b402e6642b47455657102b9d0ffea0a52e9bafcaef11f4c282b952f9a1c28713c0b4914def223331ec571093f31277df20bdd2de6d5939de36ee6134d3f645352be1576dea3c929449b9c052f51a07fc254e7c3561f24ca2b8c3a3adadccf4621e6733dc5d2f6886d4ecd56ac87c750bfecc3e498e97a207131f342cf201efc898760f7b217c8e1ecf1beedbee38775e6092b96b23826d245c3029dce68272bff272949e4b2bdb3570afc5e5e487f3f86030bfdbbcecce3c500a15a651e601e7de5225447205bd5c4c348ef4f2943c9fc8ccb572aa330550b9f6769d45082df9ba64ca3461aa98dcee1067f60a350baf3de6bc412c7497702a80b5d9fed5e62d96f1047248b1eeca100c71134305c25c2b972f8f753cc81ac7c6713b2b5d95c6575cff9cf8c0ed451aa70e57806f4f2ca4516513fa52d5fd7a17b39ac7a2a8425dadb4ab1af08b8525f58c79665ff682abf3670d11a2e941d960f4f59886e28ae28986e0da6d79c4af984f1966975d27dd5f81eda1ccbfd2aca9fdc99e5253fe4ac46ca2f5c5c4d72cbde7e8a347584c4b2c242f0d3116b8fd7ba5642d0d87617a15ee9790d3a240f5ab63a7865aec2fd10829ab3aed89d72c426d4eb10f8936b907c06cab2de11d476de32b361941ddc546c194b5b519408962a717914dc0373f2f05fabcaa8d173a2ac7ad1ff553c07fc3e67a61ce0d36d4d847051abc1f2e63a93f797d7fa195b1af77704637f9965ecc9ecb93f9e740b9c69c90000e6de8ed1c49490c1c6a0db97499a5db89c0dbdb262a876db2890429a1245d4fb840c45b8e54236c2726509b6c2a8bfe2567aa12135662dea54b72116d1674047dc187b9851d1dc9f720c75d5bb86309ac7931d2df4e229d15d79490928cdf95d6241386e19b835d79b38a221c1c8ea24c3ea55ac6177fa0e7648d55c6c0764a5d8ee0cc3aeb581605b958826945d0aa2b731377e601e7a0849524204966616221ffcc439575985f07d0c7883b14ae5e77e24528ccb3234ca793e2f9997fe1a48bb991a64e35c834020c7e05abda805b03c9863ad2f03c916aea24f33ef3d2429e6446cba0c10a47c80a6252de736c3e25f1b0cab816fd9259947529fc6a40c6a784b43a5b57d53989af4d396f92c9376a3f0feee1848c2d571bcf91d23d77d15f663ea58365bc32802fb6b41ad4a2a31392339cb0e71cf87b4b95de20104a7051a4218c513242d3486c904099a790fc75253d8a3d7be660865e2e0bd93f11d16e692ee3b95d7df5b7da6a5e13343528659faa55eb0fbbefa1530dd62a6e3ad390532b07d45c1372e20000e35c0da0df10d7d29dd8e18da29b870fc9ad15c8cef6d6b3c5389b6832f712f4a9fda5c043f3f62bb4e2df8984404d64bf2b4191c3b0ad946160617ffd2b81140792bd12f8fa5df4cea5776bb2ef1d28873cef7c95d4ae3c7f3c37d7050343a2097d686acc369c0c7aac6936b6c4fe78aed2eb1c693b8da453c72cfab6d988396ce46e103ddc80416e87562f40bf61b91a795e6574d0ca7610017b008a7e3b06dd27a1353faf1405cda014365c8d3cb6777d3b425feeb7b449af754208be4ce7af3e944193d60f53ea133fec34887adc0407a67b7a90feebcb108a6750b5264fe639cd7b7f8ba0c73477af2b7847e5f9c37efc994871914bc2e07f843c5c1436a17a29070361a19472c05962376a6bc3399a4d8c15c37f5ba77fc3fe2e37c7d46d14be30b9c69879ad08d52dd9deff733ab3bc1e3fe192efc88be5972fb38f7aac0ae1652754d27d5a4255e5df0c277b4db7bc22c4e85da0e72ae69e8c61b883965ae470be5426f81ae2d51b37013a48f5afb1aacc3fbf05d028188d36c2b89d752edb96d29f6095a3cd2304a0f901e4690cd47377448dab9a574ca245eb9c54389fe6d99f25424af65bb195994e94d1a38621ccd44bba0d2d573d233f1589f5a041c4ff44187ff79aebd8532042430a10755fed22b5b346e1cc434e5aeb6276f02ce0db1ecbaddd75470d04c0e34df15723201db7f74bb6bc7733cf2ff71b41c8fa815d1a32b0d539fc95e5f1c198c9146fdda0c8351463407a7adc92e126c22e0b3790e026160eeb54a32e2bbb0f42b2f6992d0ecd7fcb86002838f05e9658191e4b5cfca0f0501b963f6d03e756e65dc6545609ba9500b5058b157fcfda164935bd6a4de50dec753e2accae42909879647b4ff07de9a1dbc9886d85d68c24de746d8e63ba8f3937eea4868a6d12e14febc96f11c984fafc3d61a0a3e28a43382bb169c4cc4ac3ebc317d8ee6eab2de67a1dc6e0f06eda7ca27db4042e202e517c45f3fead1c2faa81ce0270c73ac2dbf7a6b4121f99758c4e7ccbc582f9380a033b8faa269152e42908048d9bc1d6248c04429af41f4e2df4fc4ff9f993fae73bb10f97d5324e804f55cd52332f2942ea3903d34ed5a53cd5fc0de9004860813fda8b3e1df04fdd54ce8a83a6a0d3858fa75dcf2bb15f2f9fe97cd000e44466ae","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
