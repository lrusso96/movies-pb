<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2551d87c1968786c97b65be3d841d5eea39027411dd4f20b7f7fdc1f877189c8247e9a854b5d4c63699e0523c9dd7f706e5795dd0f0b583001d466e131186589a70dc517c3f756edb68452521aac8c2fef68426c2279df7ec4125f88172db3a7c76c639d11756cd4066b0cb9a88886bb048d44037b1683814c6bbad52bf3c5f99ef36ac63aad15b9e9ff7c3733000f5e79c45b12daf6aae10f64206e4bb9a58ebbb7d6be0f64baa1f9bc81a440dd0ad33d645671aecd6b7e9bed24eced23afb1514bbe244e480e42ec7aca3f2673d9505c107c2d6ff2d937f79e4be3a42fffb06557752f2bc1abebea4e3db7df4ba382ab390ef9c630d85b9cf9dd1ce2ebc56d465c2973759b020848500419de3ca78bc57463227d2fc46b048088aca2d614abab0a0387900d1fcbe39e88cda17226917ae6b265f668c7d71dade3c28f5e7b56529265d53bca62e14fca34319482b18f51aa2056bb1001f6097b08752e30cbc33f47010b073819198a000b14c13694461645f4914629419e84994800582bb77b20bb102da3c72ed262682f97d3531b123decad822031ce9db757504782b4b115f5cff2b303232476bc09c9875f8085f865fad4652813214e8a5dfb65976d17e9b3f7e457efa6c4c1a4d3a52ca79ac03da0fd32c653c636666f18374140664720ea64f2e4bbbe24bdf66881c1170a06ab969509c77eabe6f41a7729e12d0cfd59b6ca23bc4abcb69cff1127f6b463d5f5c532cc302480d62327c5805a661cf55ae8efeb07d72c878818b77be9358321a582de91086572717387e75dbfbefb3422b25fff3d9dc7103b22c2aa2c2fb86bdf817f9b301e317cc911456a79206cef22e3889e4b068d7c12b018fd4044d84dfe8c7a76b2d9a416380b9a08d5672e3fcf194b31f5affa4028959f89af89f8cf844c51e63568ba17ddf8778d43aba2c380546326f7db156c94117d1ecc7292c833c2858454efc59d3aa3a9128d05fb75e12ab67262a7f1a7485a9e7a76357ed19a28fe278656a007188e5b560de0cbbea958fbe990a9117673c8b4400357fe2db759b8e4a8f14e2c24a86875524cec4320e4831883a83f4103e84ada22b68d1f296f18a5d2912bc1579b690b3a776f75969418df55e2fccb71597712b81fc7fd8fc7546c9f5852b496e72dc001e7216ce13ae14cc7923a9627978b6dd07723a71a8e61b5e095b920984092710da2ee6f83994bc53314e8981b970a817dc6aea3f7ea1845b7b3d0315c1eaf2af33372117e389b2cee84391bcc6598b2965a2bbacea5e92583dcb5eee6af576233078ab186e86ed559348ffa540c5f6f627d8ff0af926d0c5a62efe73f50d3e71ab9ec44b1856547a86b9b2f3bb0c1528169ae94a2c2d913112ea7afe6e1bb2fdac04432d27080f8eda6779d4d16584d0bde84160dfe109b695be9d05a4377e99a591312cf1b62ab8ffc8631fcb5be08b746f7c94a080766e2140c4aefc742d78784998f28f1d5d1c2102fa9a0685ca11a17d16abce816d804b5b0969ffd80c15e4cc526a4fc818405d2101627fe0f6ceb74e9789610bfbf3ef7ce9af7944a432ae2c3267bb4301486950e28f0b79e7f0c80a291c4e4fd68d9338847c6f2eb5e4fbf3d3ebc74c2e296e949750dcc679a950757209d4f637b24a795ff83bd5f63b70948aefafbb261d2119a0e597efcdd1116aaae72462ddff21846a3d5a755d7064b9c7b41b2447692d6a5ffa9509607b2ea00c208016c264cb2b180cb1f2798e40477cbc2d83206abe2447129393f20e960caece5e54ff86dda77b6855f7ea3b09e3d5aad1bf899503d38e08e70b2d3a34311df7ad93e10fc2271ac0db678fa3a977a9d3e63e6ec1b1d945e9742aeb26f18969ab20ca41e3573f801ff6e04c66d1804a701f3f233e5c2cd50811bde758462fb60bbbf182935e9029c991511293b87f153b313eca5a581bd9174f08db28dfc330e11d011b5ec9b8d8bcb5a5c82e9ed97e61ffa76ac275929cbebdca87beab84969e7b023a70d2333d016fb989210ebc94dc8484bd0cfdf96ed29c647f00ca90f47189eeea19653737ebbc8e9f3674e288d1c0349c2bed24b5cc76e884888b6e7b0f8f2d71c2fc36fd62ad5b841007e7d7955d31ea53e4d8d88fd19e7d3af8e0a1d68ec8e17e673b2743dcd3742e2af76ee58658345a49428c5b3a4be99f9012b384a92a4b77deb95f3982ef72b66218dde60daf1c8d27d3920ac74af0fe3d42c904383dddbc8973d6b22eaca2561907999ac2ac906a677086464d9adb87a76e78040a3f50cdf12270c992bb6b2b12354e225d70f3e0ce2f0e67c48af909d86cb5c486ce3bd8786b537300829707b1d1ef71e6e7e450fdc4cca62384606d30e0011cfa295a71b881ae552bde27ab73b58c0ce63abea0e2db68d064323540d082806e07653420c1cbc86f5905799886234ab253a89467072b5e40bc11dd3067fc91d7af1791f50a826432dadbc91751ae923576bc327a24cd8b455820b88b8ed63a03bd598ad6f0741491179fea37f85c7e713b096c6cc768eb037041e411fc1fc141a128feef0f367a6b34ab3a6b9c1cc78c95f1a78a42e90043244a596bfdf6dcca2476ffb78b1dcf65bf4ce9bade38013f5a19860b72f55009abb961ad4cbc4ca926006b0e8903fe2a67dc98d4b9c3a2c4e5d3f2fcc7c495942e68fa65bc3313ba4d91b6fa7e34334430baae6fc285d68103ac22a7a749184e5d98d9700ff9dc125cec3bfdf518af084d5bd1a7b5c2cec439d698caafdd86a648a1e336b4a3ff420a6832acd97e7ab844691a7e1814d4a898e4632929af75afb45988b93eacfd6e5aabb4b25a951d0410eeed74ee6b33f6be2b7c5e62770b1cbe2327cf589c88f1a07052c75729d9bb3878088269fc3114ed686891600062d882f98ca0916d59d5be3c9005fa7cb6181a22f230c1f7bdae5dd18ed8931747cd4b63943fa390abd7348c4c15854ac262e0dbe0b4c74c10530f3b19875ee4ac7af6576981c461480e39917e8c2a87ce92e458a38707ed912d6f4bb7ea19553cfc3d5ebe320b6cc3d1e103d8f907e5bdb6d292d039ea29dd24b36d4c2aaea78f359efc3519c17a725690e3b43eaccf985d32afef4bbc2069f19cdc33088c4b10c23abbb408c229ee20a4ca0c6c31052fc44219ba083f44cf843cb483ca762b41d51f18ae79b7cf98e90bb370462c57d7e8fa90b714742c37dbae7aa9861787376114115eb2b9097d8f705da7bc4674c4172a2128630dd8731f0292a49a931bdcd36a95787ff70aad2a394e56ebaa499ed8f44077e572bcf5724868e7622b5d9d819dbd1daeea0d459602bcb0f20d88a8679d25165a04101f6bc0c12059a6d318c36a6c9e9846948db1442bd029059053926e4bd219948b58ff25959b052da413701da400cb7c8ad038787c70752da792e7bdaa335523f76801aef05cbb51acfb12fe66d78030f6c8c3ca961157bbab9b52b839469dd0337c4880e4543d42ad076f873af55ec86fe0b277c8fe56c54998d8f2c945e882b73af571fedc2a237fe2353c5fc7d4a85338339748a4d3746b400d65eb8252fe0ce38d2018d43b16ecc4b175efa25c59f10d8d282108cec47afc7120acec10ef808638cab55032d885d88260577e8ea773c6faef9967f4b42ae887061d7181320395eee401ec49336fda47b0adbd41f7b0439c1737b6400f343402f2a7eebae501e7fabb5061cc6b6fac9dfe6226817d97dd68c8d586dcc06f526ac21e6175db712490ee92631770085ef98fdcaf4ab15ee52c41a1b42c4fa5d1c7d779a2a3a1f7187248b38bf19fd8c5c64517e6e86c4da8c748cbba547520f63f98e11437d06e96f1a78f9851ea177a2e35d97b19a36c21c3c48f59271cba6cbf78ea1a7aaada19a4ea92966ffdc677f3aef187d18b57cfb4608f03218340b4c64bb5bbbba21fc84c2b41dbec251bb89cf56920b2e2e96a9bb065f11e499ad9b0325abe54f69d13f319587938e594e2c889b0769490e462fe41ba89435920f66b124916162114076728c69b5083b199f13b9718828c5ab401fd3e8fbc9b3debd0f3d3dc0db89cef72808f510b8224a2a43d52094dd2db3c2989f515c2bd25fcad2927080034112169bb53f177be1b2438921d438ee6c920c64fdca48cd4352dafbf4e9d8f4204ee6c0b01640e4ce43603e8c1f1fd0f54f52df6482cd8572aaad54fffd7709c7fd02fb1df62648bb5baed3e6de68d2eb0cddf34c58e4ea8824d7b3a168e78c3bc7443f475da4a07a737e8f8bfacf1afd7d718fc33b349c1f487de0bf28bc77234c518b5254a6eb7157457bf6b8b7fbc53aae9f99edeef07938c765330247bcf455de7b9824de41c9327e164a27be4b58e71742461243015d4d7cb57713ebecc5ea261cd8f4a0d53460b164e499471828545ae8d8d46c8b5dc94d23058032f163cc90dd5210f8a8574d8541d5e54b2dbe023c8ae6c64a2ed7e7ee0550fef389137b43a80c3209711879e5cf85418a876ffa082c852204dfe39c646b1acb12ae6e11d2e40d8caf1dcd01f8357298181dbc28979aba0bc118b8d1edfa0ea4e548307980e68b6c3d9d1f115b7c90d10011af216e3e433da60e2e2c04c00d3d1df287b7d8d5108c83b41ae8181c2a1c230a3984a40c06d2b1b255de4d16abfbc26f30a1e13e008e25e74990152c6c916ad2ec9255c20c0314e7cdfad384c2a61de05b1366a4dbe422a7758da8cd31abbcd9affa045ca7c98b6ccc26759f1246deb6631e5fca5153afaff1b4a158446519e9e258fd9db3f0d7ff7f3efe074576d55d431f86cbf9a5f793dab3df177e97cb50877165659cd352ea651b723923e9961a31e94834e0b69f1a38bbffa78e58c015b33df42ccec04c6606649ecb01d5412f0d642658cd1df7f8be35f7a39c192f5eb4cf4c71c38502ee01d2bb1c8e12c2f1df9efcafef43519465f05cf6c4428a6772a4087ca0300daa5820361dfbfa839e382d66374a40d34d65e4cde409d73a8a134bf1778693c7f0b19f31b947c96a985f83a25a213512370cf9d4e1e88e29eaf49538e7adeada3c11a04867c7a27a9d4bba72287f6354ab27fc41c87db5c4e09378e52382fecd00974719643a3f03c9765b884c375cd339ce139a2c0d0d9fe5353b387c2fae6b8271d586e4571fbfdf90f736ba032d7285b449546922aaa32588d2e68951cbf4dea6ec3f9705fa26978d6c2bbeb26c051cecd477b972c20b8f757290c0ab168187fc30fc78095563ce8fef008ebc46404c21233bef07cd0b808dff7cc2d98521de8e673085025b4a6bb14cd99ccf91745e1a80963b9bdd24b85c2a7b408781df3039ed319474b668d599f6df6e9113dcc1e30a6cfb53e55b398f0b24c680bac27436842e766e7aeaf1a3eeeb3b4e82bc1c3c282920583ae37447cf6c36a7bd7d6737d06c28d31fe26edf8278b2f91979869192e2132cd28819b7772694bbc6fd200232b041f852651759d28525a43f347d5dc987b7af3a4841d786a4fc43794442c5d7bcd04bc72c130f3c7470f173495cced53d6485e46779c0bcb7f4fab284972630392129353c51df62f7335e3aa9230f942605b25e5e20227e04b7abc0f018afe8e15e3ac98bd83809c12bfc3f7a2c8c35312ed1454d14a9c3a7210222cfd89c2efc6028459184d9206978fd0c205ae9dfbbe3afc4abc21aef42c8b92f49961dbefecae99bd552d7550da3d4f0250609d1999687f0c95341c8b402fd2a43d597e5815130a287a04fd764f9355a09257d79a54fbb7d9aad20373bd767ad837af32c917728fdc08152b31a3af8cb0d8d3a74c087e124f28ff17f3018d62049dca49d065ab8eb2f004366fe69a5ea26b93904c016148050a1d56b0828db9d70740ee8519c3aa15ee8bc7678e16df5d0b43fd2bdb41bf9765d8d7e7e49757b5e86a56270b52cbabaa8545e3e31677058eeb8998a8f9d2a72842c7ba9388f42fa267cacca8247b687e8938c1cad37cf2d62f4902f6af4f3f4f8e5ee9214b212b442b6154d477d2f9e4aac5d54c0e08d179cbba108bac6cc9c95308612b539a9a365e2db74ad9ea9e6c26f4f5913d95e10bd1d2b6fe2091c9594fefc3a981a7134fe23bb9f49f2d45aed7d50477db63ef292aca185ca91eeb9defd680ee64a14828fbec2948f11f7ff552724bfaeb9de16910eda676f42f22a144dbebe895a67faf50bbe895af73e2626f6702528e9f31ba16fc976d01c1fa377b8510a199ee33e0e894581d3bf912aa3e4351225deca4308872f04ad1031b95fee07b35f9b662c56eb8fc00432af322083c0f3f36021d73af4c5ed3041d4ea1555f7d1900157bdd5eff6da2b3069241c059cea0bb0b4680683086820f1e5cada2d3a2023e3abd163c1a7377348194a01584deaddfeee7faf9f9c4578c9a6fa44052ac4e6d742388e31a664fb2f4fb0ef50a6ed6b4c12060673c312e80defc5d8cab9348a1e2706e9ad2017356da8f5babd12bf8a1f453ea1a496a2057ed283215295f0266ec50d0e8d3a04e8a3bd0ef2c9ddf2980173e5c4d502cd45d3384ed709139fc930009863e48be45bccae947cbd248c0a1ad794cb0c123036b464f1b8c97c6a43fdefe10b9bc9e235e23b11d2296bec3c0a3add54f38cda22dca151e858e0183f42904d4bd57f0895dc855ee501427fec56cc771fef1999ec9f66c7145a2a7a77ad76f72174cd8ba8058bbcd28eae7176ece730dbff8ed10109d58b5c6854d2be35be819980ff5ccdef95b108bfdecbbf51d7a3c5d0ffb950738632aae59459a6a0e743c5c1e2ea42434b05f7252ffebfb8288802bf11c71c40402578b7d1adf8182a6afd369576df690c1f9efdb8f82dc52a370ebe67042596ed26fc155370f2e6bcd44478df8b9de649213e58bc98938d8faf083d000b2d02f197e0834ceec25ab7e2067cd6082e8a6f30be895abdc2be81617b224e9350978ef3ba9a0bc29e0c05d1e015fcab71d20c8892127978e719a99c41ac5ee11887b043f7fc481ac71a93214274f209f12dd0c48e697ba007e8e070732f65d20aa8af64fa905f1ccb92a6110767fd4d2d32db4c1a396225c60424c9874196f7315339d2d00e33274fb133098cbd4cb71aff29ad0100aac7ebce65bc17e065d86ae5bcfc039514ab2fbf2420125696fe572e61c99661a476c1f31104983334392fddf6f012986ca2487ea74e74870fb564953f1daf7ee0ad7364e386a0c32692135eaeeee88c802b95bd249528625b61d5cb75c6117ba5e3a8771401439e6a6c36352c4592d596e61d5223a679ba182d20b4249b02db43942dd6869d6294775fc49eac21d849efce5adbac0099f36773c57eedbb123c7cc19643b940912817f0a1e0b85a690642c6a2636fd4224b2a4fb795fd3b5b95d220f24860fa9583fe792d95349e750cd3a158d4bcda3587ff9cc83fdbc443f203fc428e558ae45eb386eb3b9c6b0b54d888c6da28f427511ba303eca5e0f9f5ba5ce64a165fbece512c6a6e5a7b27b2fe730d22a0efe67f7182c6a55c0df4e76e81b2c39d8f0d4f56b83df041f56ae22dfaa1aac2cabbd42802b5cb1ae3c8bd99458ac4a67a8660509ec0b65f713a28967e60e402e98579f874d50f0ae1077dd3a80ce99ffb1040abbb779cf616be4c7b858dba13d6dd2a54a36bbaf0bb8ae698f6e50a9c9eafdbdb6db8230961ec5c19613ed5baa07d2fc56e8f57ef063b264f3ee0cced766057bfc8bcc6146132f2c010c8cf805bc36f252044ebfd702b415548e3338d347f27098bd303ac4f57433c7e4724c0077d23f464a9f7f7620d5561c4bf459b9b06408e67c31d34f9b8c1ed838ab160ab7236271e7d50f83c070d21dedc376f7c6f4ea99ae1f33432985c4c9324fa98799c979647795c5b65d013483a27c9f1f3ee07eba5f26c4c0c52503b1eff5e5c1fec94d86779102e01b634593b5ab190aeab319a624d021d80428ce180cfcfc67821a6abd4a097df06a99a5345f640babeb67c50e180cc85b345846541793ec29b8f7471ab2c314aef2ad9f7983427f3478f23e472436be966109e2a9475472c56ca367b617f19310b7369974499691074908bd1359d0048acc9e36d22b8da1308d6c5817871e93390ab217613d11a0ca6cf173f5681b5aecc6c09847c93d5cd1ed46512c9ebf3dec1f01d924300fafa38ad65b9bd853238009efe08048a93393c2da11d7692bf4f85eadeed3979fab4a6c3f715df45134840f8075135ed4773119c82d8211716d8380b07ecfeafa62495d2c188164eded6d4cc264c11fe7c27252be637389322b44098950504bbea16076f3c175c74b1003415f3deff38154681cefcd6b0a9fe3b6d7c994b2653725fb54c0199d93e089baedf744b19ffd301706a1774379e386777cae7b4e4984c7a98b40eabfe40003f8b11579f04398d9eedefb89a101f562a7285d5c0f4fe558eb0d21a6912ff633bd0375f04a1881aad53f5f73cb366879c47d5edc4b2a1d42355f77b9af6dcd6aba980e6fcdb4cc4b9843a58e26dc7bb8cf54eb584057096d69f3bc3114cce2cfc8f73bef1f6aecaa7fb08f3bb33378b7d356700ca6e7181ec10826e70338cd05971d33a485866448446c19595080f169d2efcb69a910cf5e0606e69cae32384d1c94611ca5f3031e4c6d86fb0aae0bf0bdcd6099a46bf2f4a42f11eccfe1be9a6ab52c5c88791e050874c01e80438bf6f4c6f9ca208b9d979cc174fee9b721f5071befadf61300427be2fc673aa40782a2b52d1a98a7595dceee9653d1eff04249d839385a9604ea12d5ffa1447fe3073635bbd061e41c509f87f4cf69ddf3fbf01bbbb8cdb0c145195ca64fdd944229ffcf1fc5a17f4a0503eb22e7a049abd3bb4ef1111e515714ac25e6d53938a967ff3a4340dff7faa8efc7332580cde4c69cde3c67d9a59167bdf2b55e548a36b1c2cdde09eb025d6e676ff938ae7a143e5548f7423f202d2357c8ba1d8886fd98cc00435f77439c1a01e48dc8edf05d71e20b355e65a2162cfc5650e5a1dec33a3e874ec70583b5dafd36bf6fb0ef1f4d43d0887dfc13517a4e40d32282cf27d9347e54872b58f0eeb9f230ba574af3391b4adf1bc57c0a784527d152c33e91fa6080a4867c5fe99d6f69ad5912f3f5c668948b3a1ba93ebe8814b1d5d64fbd83573649c7410e4c70bdf75d01ad15fa61e6b8fc05f58fed3c019e8f20eeec322f3e10ee764aba9b0672141de1a87ab6da75f51566394bee17ed81aebde7256e93328dbd7261332cfb20f66aa4d751faf6a172bc1a02694631d4da3fe0c9a3740a7a13eaa88ce95e74ef8747c2c7c4d970cf93d28863e9a7706c72eb36b61e009651eef440e3522de97e89ce668cdab2e7b0c136fb6e7d4ac9f47356c2cc5519b8de937ff39d9e093cca408ff7f169de6d405bada28f781cebdf39b8b5fc2d7503849c1b43482f093c937fd695fd3ce6a06f80f7e92d0c7c79d6bb7bf4ded66517921ce0ad0633e8af654feeb710348f7e25a137dd513c6d5b32402e267e3ff7442645ec9cef3d590a5889ef043216afaa9917caabecbd859769ae1633dffd5a4552368e311c259634c5aaeae51de8b0be7195e45114b21b58b2957ed4f8545cbeb325e3973da72fa9463cd6707789645445f93a80eccea836008503e44237fe2541d86b46ad1f348376817e9c33e1936cd8d1f597094695c256697d0d72a3c23a5db4d685d556222bfbc9a12f6efcd8099abc32423f2b1e3441b08b75eb3eae462a493b281aef4c31453defbbc221f590af77d7a2f92e56236ed1be72cf5a55bd28574c7e8fbf865a6aa16612fb0e874da90d785bdc49bd83073f54c7915f2d9c900a182d5aa37a7a900bc4548fe989085c913a1531d7f08cd6be03d9ab2af5224c0e731fa1e4ea16564a893246427e3e3bf0575724981e3fb49dbfda9eaeff4cd39d106c6bcc1ac4b1e5b2f6f8079a93258f9b9d6d82a556e48df6e1b0ac89b0b25572772e745eb664126fc9f9315ba822182bea79ba2e7d58349cf748783cc3cc39de32829c3c0a14f0a199c7a8395ebb279c02df05a0f61c2459c43f42be3ebf133056aa0c97d6162a57a03ea22235e6f23e8677affcb7b52aa519cc4cb35871f51f2fc52517a17ad60fda15a05ed2ba676f3e4d16c6f8efadcf85beefba764bcd6c1bffb159d2867dc04f5d7b2cfdb8ad714d6d58fcddab7198c958e5b4ac20f32d20c4e35b4fdca7aa3a6e6f024fa9c607ce41d4132561fb21fa6fccf6ca5cad94409649146999c74dce4ec2fdb25ee5efadc9733aeb0647d7bfbdfc8c9a79d154dba5fcecb9ea162665824f3cfcdb47bf584d05bac5aa956d7925b182c4105846b1a8935639d55c0d8f726266811e60327f64965f8f9d7b67876295501b1aa9710a07021da404cdba5ddf94b07f2f8486215714f55a744b00073bf24fcf8b2c93e3a74ac23a748e8fb606ec52690855565a907497caa5286a6837bd62687838e42628b3763f004d8d374502ee1de095216ae123054aec494fe90ad961244743bcecb5fff4fb3377614c0816acbc485c95cabeda59dbcabc5809c673473be45c921b221a08885161ab952b0a966e274d8c1bd3ef018e92bd0911a900d96009dce27bb63305612b3540db1fe53ba08d0e3c23cad611a5dacea7559493db201d8039b24bc804df87d4287d7c44cba81ea8baab717d80c71aaa0acbca7e36293b630b8e6ac34ad8a539b18bcde96337a9634137f783b7a4db9f1fe0478b0fec658cea24aedb0a2adaf78edc07ca4d5a53ee802ea8e5e6130f57036ec7b632462de010243c3e657b50798b2d861909c85d8b249103c0750ace5907e5c053453febf3bd1796f900993c8b5f811ca4ac01b6321fe015c5b205c82a48277cb19104256be78edcc29af039bea1fc3965dd8cc47e3fccf9687690cace20ea749ceb3dd6c651aa020bd9a020830d6be36ab6c44e9e6e4f3ce0f32180e492b99d80c2564fdc48cab4e9bead16df407d8661307814f85e2d770b402bc6ad73094321dbb2c7473b97c1057d800d88a97904a3597807c465bf338de84cf8ff1f76ba9b38237742123a504d9ccb87635c66cdfc04c55854705fa18127a1c7f96478b68a98c97eba0b10c7a82e8f9da77d8f3e79156a4b915728c77e927cc1ac56df8ec15830866b687aa9573ced125212a4d1d7a7b5f0ed4f7d6d90a50efadd3261efc30b96e2128399f5b11224d7f88e5565324f68c9b5f2e3bdfa27a4fe51a443dd19df24037f49cc79cf8ae38e11a6f901dcbbc12c1c0860bb8aff30f98386ee486070a0ad1ee9173b07e99b2e0796fac55765508a6ed42de37b58fe36fe81f135b9c18e2d5af97babdf2823ad5459fcf7c922a0753cd5874b88431e6a3806d1492f34ec6b8cf585c61456dbd92448f63cc96fca4bb28060333877434e4588d907c736770d82ef239bffdf3511200be3edb43d0636d30953505b9cc54a480c0e4969e4aa9859c66f7f460335aaa0aca5c82028a11589f904c4590a04f65f129e0f4ebe1bbeb38b2f219856ffdd9989d8f5fcd53dda84ab279b724ec7c12455fa31a95e0b4dc3e32cd05ea7408e5acf197f2f3019c5aeab14e67932c5a03d550f31461fbde42aa6e650078551b3def58895161638661fd31b3be842013cef7d91283404bde7b100d155ca155d1c30a137393625defa6f77da48b00147562748ab95e23488d7c1047f6016708883f16b523f5abf27406893ade95382487193659586152af44a54e1e06cecd49d7d5575c65ce2d453203f1d6696f77c68a60bfcf630e9c4b6a437126319be72ee812627972eb38b79c34247d4919f255a130db1b71481e173841f7b0e214a7ea87173b6779ed36d60b8d5e0b50ad478a8b4cb01752477013dbcf695a1af98c5fc1159563c605a2111c0e47d74074152383c5fc9d917e4ae9658a7bc8b8e8754b15e72ba4fa35ed7cc502e0f0284d7e5f486c19d1107f04dc78237dac55f7e343de94f8a2de921626d1b2e52ce604ece5086d4c0779b1a89c81c28c617ba6886beb4f4e019b381202302f492c325c2c01271d46b697700f9c4fe7b98050cae7a1ca077586421474a72731812f987077c190612b9db33ebf44f596b6da605be559ca1000b4de0073116b2bc6806df89c8dc1f16982f672766e6f3cf9e39b7555b138cb2d99fb15573accebecb13831efa051d599173f35d5283a454ea233fc7d6f68ba3dd2c37959c51889c70dc4c1dea6cf286f554fc500701737b341a0555077553f02c06f058f8fefda44fa72d2131f2dfc5f82754143472537378d170a099f9ae5ff636fb2568c3872de81d44141fc5b1f5e9105935dcc1801f70f70a17760283ed10efd4f8cc7b2cc1094cc159fc9ef36c8078608e35989851cc4362a1a5308385022251be50b8989892b99ead62a186f4ede9d115493836b2b734b8283cbc8a5ea06ce2cf157615f81ea5cc10ebd4c087d1499e3a8f000601ca142a4bb8034f80466a0431f4aedf9972a74bb53ddb294085a1a0149ef713f62282ba29ab60d13711fc12ef1e587cf15f7318efb63d7a28efed5a4788feec10d4b5c32746da5894844fa16982bdfaae70e203ac28bcee1c325241dc42a073196ff529804581fee1cca29b78e12973d95a643a1d62125778877a8e2c2f0a7f522811c262f5b1d107e2b3e027ba7f61c4bbe6975ebf9b0155056523bdd1506e4d9aee1135944269ba160bbff66986aad6c44d77a391c4115667850a7069d09a65c852a6c6fd54d339ae084e054e458baf7bc54eb01e3f4a4e310ecb68b189fd16faa88eb9677e6eefb5933420313123c7a69122dc8654b0e11468edd16758c96e352f7ae362a54b6cea1e915dd71c33550d3fedfd4a5c8966402f320b166dfbe2f0732646aca9fd18a6fd54a8c8397b631dab5bba6a1aa7dd04ee12269d920e9417428a66eb6525f33eab7c29421c0e688de1b5ae8d40b75b3284fb0abbd82993176925bd280c6a33c86519502e960a8ce4877b2ba","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
