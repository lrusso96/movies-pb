<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"67e7ff1b5eb4fef8a24c87a8ea3328885b887ff7247f1ea850386ca2877fe15c5686dfe46f3b3fad9a81226bf5371c313c686cab6c659aa4844247b6d9cabfb2f8e87c0f9289a8394d683b8d30727daa6692e343b9c044ed9512b7366f160fb21ca203ac5e19b709df2bd3447d69e658407b59e8066718d706ef709952f33ac061beec573f66b463f043cde87c3f66f46cb8d41c47229c16ec6665338a4bd058acfabd0c8f8af14cbbb8b512ca28bb2b1a2dc8f9dc8d5ae9142d03f34c011ce73fc75fbf78769cf0d6226e9a7064d7a7f68f0a96b422046c476fae8064a9489bb4c4530dfd4faa868ab085271c7e7073078a25c30cb4210d430289fdcdff353633642347a6126f01d49cd2d388e9dc0aa974c5739b24a0b63c8b248b5e1f637f13401672f04a2d4c1084c2c8beccbe17778eb1a87679c3f81768fc19a8d64d174b8e8ff133d3b597c8a137bab6e63398648292b0fc0cad0e76a3d1b5e2cd300681a3b5f8b226a5c80beff83ec52b5d5e2e3d845b8d88c6d9749468b26c546969156bd95108d80b2db1935de5519be557f6472c44aa9d89a48c6e5ced134fd0d7cfa05cb3ef2c3f54aa1924ebc5fcd2a5b3e6c24da02a6bce7c0621e3927dadce56ae5e5f90b80a228e5439d1361a21fe935b13db16abcc7a0b16902ce743e5370594bd1b20078e09d7ff788af82b8af93eef8ba2116297a89ee3b6fc82e8a770217ada26da6df61c36094061e4b209891437ae23be2bcb5a37269acc99416fa2d299121e4c1c7844b455585560dbeedf498c9a9944fd9813ceed381f8ec8d28907b95a31c275e64db55da626662798eb3c25bba0b21fc19929861f4471eafb6a56ac547530247057c1d1d1116afbe3b0e62a94f832a2d21e381f6a5597ff992828b3083428f270038f3545dd1bdca54128d9cd5e34478619ec357fb01fb408368f7d4a9dc850fea23b17cf7043f60c6b32ccb4087f54607a0326b0b7bbca630b40a42871dda2c3922872455d3b9b729a5d3d9980e2c6d5c082b9f48d27b18cb5e4dce1532a1ec1ef54b5cf52031f65e1e80c29db53a60c12fa8a3fd88c1f9d8895fdf2a4d01b3fc234c6297db48361f3d73eca29ef430f1e72818bc5a69be40449c37fb4227ccc225168e31b6a1678fb5bd29dce9e6ed3b4702979732b54d30ea20f1accb8d23864f642757e80197bef43e617eac92df039b18f5aee9f644496422ce9cbd087671c0876ab59f03b998f6cdab71f8f6d17a46da0af50ea83e243090ae5fa0e6cf5969c7f59dd0db5b82ef66ebf33fc548890a67a2ba79f7e2cc0a71619922e35fd5da3fa6f60caa521335cda58e7c5b31feb1b9d12872077c2e6ae0f1d5ae2c280bc3cc72600f9de12e476346e2a530fee466defb926d85be55ffddb2050cecb35878f7791d73a2a5099ef5b1d4385246416e0f897b3de4279b5d703f91e15215b514fe404ba677eb71b9ab4ce84ceb39c16b87caaa03398c9ddfb9f06aa92c9086dfb9324ab230064dac03d231ee5bd75baf2621df1a0b649591f0ee56d3191d858421b2195d0a38bf5a6b36251c9b65a24036aab3ef815dff2fb6a97ef321418f4ed8df8e03071df6679976c229bd7e6c7f7299cb650fd0fa3d5f5cea595a82191467a96ef65eb35bdf9c6636f1bc06f78f60dbafe4de4ee7735af288987daade6a9091b6cf0a637a9e5e827b2f8ad4ba0395582d6771055b325bc4e2724f3ed3e43bf1d257ed3a41bd17d2098c115f9b2ad9803b3e9dafa01988295d59e9716f77189eef2704fdd0ebef485770e6786dde61d77d97cc4c8d5f5d9f62f3d3883aac9e9247218e23ca8a07417dafe31701d8139aaf8992c6de10da95d8bbdad134d2f35b52c46f0e9343048450cade787567008010dd2d7c16fdf60db3ac6fbdda1ad8e9d9653868c7d23d4b88cff85a862f97008cd4bda03b00c6ecc97c2bce996dc8d3d823480c4fc3cfd912e04c71e66642f000e023c469c7d0804bb73fa4c33a08328d692fdc788d280f9e605d19e48dda91fe5b8d6ac48192e39bb6066cffa2055f4f5946eb3ade35018c1ee70708f17c47540c3368b781eb26a76817757360f134e317f6d0d0781218ae84af28a923e11738a7ccb81654711533722fba387a20181981f4157b3349690bf88e0221378fb9cd33e79e2441fa9226c94154a934fddd1af784168ed6ba581d5c9ed9ed879beba71c16d11ef79b699da28b516e8d02f1a76d2b1bf00ab6f77ced4c9ea875b79a394cbd7171dba855ca5afcc9dae2b9b64ec8e05c8404d25052c238054388995e747aa6d7beea0b74703ded00a9078721780755c6e08331720e30d16b68a0d17050518b753517e40f25441ae3dfa1776c48703198ac7f3c10ec1cd005cd13fd2d5a9613ad29483a503e405f5a9986bf6704f23afd710b1936f5870dc79d8d4920257678000c749d272571f5c16ff5aec840461c14856618deea305cb25f169bd403ea463ff3837f1ae93125f24cc050964945906ba9613f97e369223fe9c465456df084b8aa5e59ae1a946cf982be963dfad9548f3079f058a4eb1c37edeaf2dc357a13217ff275ad3a7d3ed064532e0e50d0aaeb24bbc0450b7711855bd5e779feebe5f0c99234d6dfe49e27e147fba456e43f163daa9095f8e50a3331a6ecbdbc261884e4e89d3d448150492f9f75c0d54a6cb2b961ddf6a5cf2ffd21bfac2d89407c887917022d9261df63fbad2989d36978736236d3e25b4e7d9527f4989fd6201d33d6f284efd40513cae9c6a5b985362666b9f47ea9a0c43fa040c25c3190af393a8dc0b6ba4860f162e43d456129a54a46f6ead9d5e23b5893436a842f3c5c4dab22dec54e0952a16641feb765af301f6eb717e48bd4570fd3e04f39e926ce3206473b75e89944f6caffb6ba34afa8464efcd27be446087b736654c4b9e985686b1088e9932d582e7599e732d48951f709c8867645f0448d7292ab19371b089f6ec71a6b7fb1ab7f9696c2cfa436f7e23060af877ed8021b32894173d92221a2e661aeb3ede5d4cc2084a7685cb921da2b7dbc858e39290d5d5d75cbc0b85b819c83a2718e279c42a11fe9bd439f4aff762a9f2268342e0a5136487bec849e7d9bb5bce7adcc9b8f9a715ded104f039fa3742610b2666bcd230a3a6f36bb3625c21a6a936c64a65ceb556540ab704693a9e62a0c7ec457ea0b397537c28778b5b1373112fa67ba51af1e294e0ab3361c8cf76e8d11d91626db46a77d5746a8e942f1a7db0b0b3d95602f9dbdf0bf4247dd5f84e793038aa5324983c07104b4343edb94203fef2d488aa7fcaec65744200d27e680a2847fa60f83b6fe2c82ede9d10fbd58df3f42a0d72ad96c9a724de2f7b7dfcb41b01814d1677726a01c3e42e0d9f6c09c7610ea0b904724f84c829874aef64f4cdbf472737ffa6d6335dea2137b004569f9a69c0c6ba87459741a057dcd5f545d5fe533b82e8f67575429502e1e0038289da8286d8bda85f31646baede74459ff39d892bee5bab70bf807873b8d6639d517fbf0ebf6ebbf035bbd8f2dce84a62e38dbb71b762fb9317c2004de4b7722f6d3dd9fa060aca7ffc9ad96515dc7d24b65f33955dc1034e51083efd5f30577ed271b0827d3cc2efa244b08aeef0b56761f708a104a6c9056d7a9de1a5444916284beca4a2a7ab18a23c605eb7cab97d96384182e2df32bed80ace86c0a7ab0d26d0b915c8dbaf0708d236df2172758fb6951e64906533096778b6d3155455358361972e8e4d8a4dbb0a795e147f4d8b6bc1d3e9265438dc5eb8b6f2a2ac2df4edd5746c270892242f76b8e46c4e18e8505aaa367a0ff1cacd9f8835621da71a3080caa39bbec4f5c4af585f3fa6f0d32a11a615d383ebc33d2c94ed24bb4188ff3a8edd76fb5034e647bbbf3c5a2a433aaef6174d4f2c7ee1bc1a8cdc19134a5120259d8fcc9f9d4d7f1a30ace30d9720d9177eb395e7b2d51c08a26425ddb174476a258d1f13b1fcd7708841c6d9435c9c9221ba925c5ee4db49897c28d06d9f518a4477c27dbe14d33c6454d6a2dc825221251ce73cb9a745d90c440ca4ea0316d31ac55ba16d7e1b88374d8c7cddf93cc920bf46754b5b4464c8323396c08500c92deaa5eec5d80af06e1ea2a2c1d9f5b448007e69f3fafaf476e7c1cded21c9be63abcc0d16fecdf9dcf7a52284f480b2b0c0e28c2f5ab7cab610e326e325b4a0cd800e1fd27d986922cedee2aa1af1a1c8c69dc465a2fe727d69f7a59e2481c984cfce1e0d66beca76bd4ccefd6b6a6ca69d8fe52b9e6045857ea6faf886de93b86d1106a4ba9deee4b8fdaea121e290eb2328f95964e61c59972243b1939ca9559acb246b2e6f98f54160ea74aa8fbe571fc8a4036de1de790928c9a86e42e73b91da93948bd48f8f91c020c97133970ebf26200141f2c4acb2521bdd1eab59a984094d92c857168a52c245d9b9c8c889b44c9f8a77db09e1b7550dfb370017fc4c2a63eb2f36245ed1c009f31a21356bd00ddcb466838cef80e609446dc15e9eae17467eaa0acf66e1ad7d50d97355790e56de5183278d1de9c892f9d2df10afbb97a4f032e52812388a71a16cf81f9d47634f7249a5431e65872001fac20d6e210f5948f009a0d037e2a51c7bf4a24344fa4a600f77facb23ed7d1002e93cb1f393bcb136fe3e0adc787d31f4748ad2cbf7cf79f634e9cded93415b04f3aa2e909649d2fd6ea302bca15c23aa3d111844955bbbdc2c39f5e3fd6a6820448a7f9f42559307c9dc33a8261ec3ede2738c519ddda02395f96cfb3116558ac45d0cbca38a9b4721bcb0a107e7db63efd942381da7531ec1539b195e0e64e193cc3c0f07c1fb35aac658b0b1dbd88c7015373c906ae715e877f3e3229e6fcfafdb2d98a3e069879a79c201368153d2259a11eb5381cdf453ea195778bee249b1b172e1f32ed5893fecd20ddf8e3c71d19d5ff0f13a8e6a4158a2f1d451b34a266d574fee398befd7743f2da1422053fe94630cc9784c407e6aa81193b72e28be46e5f0cd301a00a2b3eb2c67c099fcdffb19e98bfe36f6fe5223f8889a44608ab96a8bd50aa777c539eb51dc5d1bcdfb496f396e5215d06e3a55cd82873307c6537cb9fefce183aa00db0c7ad9776c80c390b90403587f6aa3b2ca7322c3ed8d1b9beeaff2a1aa1055caf30e9d9e47dcfa04fae0f7f3621308bbfd2e0f260dab11e058c08a326d28e860883b674ce48e8bdbffff3147885e79e092fc600613e3ab77479d5c86a63dfd7c7493d086db1c91cd543914c0d2f002ac334fb5ba519218d14a8805679146cf648cebea660e8f2ccb3fe2483c814fd320907e4b6b9a12cf8d40b0e0caed58d0db7d3aba07231494f805135c222b0e441b75e1aba970d0bdf7db633ea47a0b71108b3398c5e7f2775efcaf9c6756c6fc6657f4e4fb5777607e219c0a2ac6310c8dffac8bf2170989e9646dfadea4173772d8fadccc7314ed71fc95cef0dbc3c93ddf62eac35032c8f52345e978d1ef2b779022a67cef406348a2b41dac6c3c88a654b7dad7e5441cddf5fb427391e1df698f92221703aed53d3beb937540b0ff1bdf2c6fc030b7aa730baeb8d42839fd233875edb4f4d500246c887b3a9ee57f55304163f6ee244e91206ab5ccc2620b6f76dc88b9e50a0e6f467a1767d8d5d63fb103b9880693b390d7b5d5fde4d6ba0504eb59f7eb1a0d4384f13d08754df0921d85de2a2c242adc73f846cc04600cdcfe2d4cabfc5fde8156f4b6a1c73e03a237e7a2d0c3728976b02d8923401923b3ee8c3fe2875487b1c85028f6dec8f88abfe378145f65e5027488d7818496a9339fe5f7bb16b6eb72b2858c6ace9bee16919f78667419027203aec64d7ccb075b1158060e54f77f7bcb301940ca51d53df9db822e82e1939bf7175652781c9ac0fd207bde8708fb5e71d9fe8fbf5d7de35b802311cb9f2b4f8c797c8c8e0005c68d83e703b4f9806318bdff7704bd8719b358f852d9a342108710b7ff271edc7b2dbb5c82ee4adcbed7b15ad703b50b9294900179ac9259fdfa6797b89eb7e3ef5d84b996a2ee6dfd60eca9a7721b454e83c9b0be4ba0703c3aa9d4284d69ca42a9559062403c88bda3e7966db6e47123f81e996819bf1970959c023795430d4e154a543ab686e73ba7279a55320122c18f56c20ac50fdec5c265b1a177b6facd8339bdc4fe40746dcb2cf748981a05011ffbc840abf1477ba365d73b766c380b5569266c2e1f17ee44a376f92fa94ed7791265c89d795278f6c26e2ac05857355ebe3c619593e12d46a9b0c2c5638112aeb6e5a92a9b47640b51ede32dd02695f341534be11d65baf3d0fc19855fb8c200e5072e7cb15e5b46e38f8fdc5d3e268ddd872f13d8dc295023b31822b9be6b935b617b503daa54542d33c6de81a83a6fdebd7a06d6432146ad3a16255301bd42ff8d0697cf4f493e77f6685d9865d60e585ca52a64887aaa6c8dd72f177263a5922486b7e328db28a6162c42aa3e34a7336df0485dd56b33ddf130d044c6b884386d42a0cea75ba74b653b68ca55dacae477b439aed5c3d5c13244768675d13c1c84e27c939d4692234d925834ae8d7197f7680b93b8ec6426ed102f871cc027f72a5e724baf95d3ede3432d8f5663672a7794cd40f0484a535c31171696c032cbf8c2b2d49e6e8c550479f0f0eb0fa17352c8e54b0891167b930abddc39134c4e17ca84639e1fd09b25e1b309d3fb43b41a173568b1ec9e8429f1bcccf227bd424eb44b890148b17613c954a5ca16d05069685fd2063e1b1296ac7c2d1fc88ca58f7264aa52ae2fdedbd347046350babafca8694562f013cb07ec3f685160ea6818459a917380d4044e4f66d49aea9cd2e7b191f1ff798891f6b4bb8b4b2c041773b955a73a7bc119f928fefa22e7fe007a8824b90351c0028bf65e44907ec492502f1f10914778dd8500e282569c1a557cbcd6f9f072f23e7c746b58fbd70841f30e37f9df724997d6773b857143e2f34fc0c542420c2058c76a8fc9d3dfe36889816dba814420cecc4df933daf47ece3e182186ed94feb25b24acd4b867549a76e9867f67e41ba7c702d37e94cf5433ea303201498973c7269a020ad3301b09f60f77fda84f29462435668bba79b5ffe2351f72cfde35c4f3b0543e9893bbf5c22e37c16a01bcb9f1ea7244b397c888e6947e2925c54bd04a06261082cdc92a10cce1bd4db6b29fe197522466edab380acb54bcb1fc3ee901f4c1fe66a0555d1cb5c6c25bf05e5ec6af020ef8bf9341a6f0e25718b69456900d623c3446f12e76e29b3344a0601478b1af417fbdefddefec15bdaf178ed21de24bcab99a807842bcd8d5b5f0859e42847c6f70e6495bbba0465dc752df74fa0e79eaafde384e8c61f1f3437e813ac452ff20755c4fecb51f2e2142829f947cb4a3bc0e6a1a622f2a9c995ec6efc63db0c70971fb1ad12691a79ddee188ad377e958e544b4a1f6a009d302db168c4ec1c6af441b1e9b921eb18091a3dc8200e8b404637e09910d4c0abaea077dc793d704bc0c6c1a0acff2d5f59021edd0ed700a8de1ec463b4cb8cab1a31d35b92f1b9dd92d96b57faa73a58cfed95fe3b71f60bc746b4250387fe669f64c6b25097593c86c995e0b7a988f0f9c27d57369d6c30c22ccd0cb4add43d5ccfb35cea3615d57e7524bb8997f0f438078df04ef71c9ab9c82f4867a6d666fdef5f44cc48f012a5fc00c5cc837b91b2881a203ec4eb458945580dfebe68da4bab01af5b772169567188bc90e1ee23e4a4706015f6c8002b8f7889f957e0fb5860f9c672fd779ec44ba36f4f16a62fcce2c8eff3445bfa096e27f65b1d3f54fa8c7603738c80aff1c813abf1cadba1ecda8983c1afdc9560638f56af3afc5a96768e5012b91bba417788621c340f3d9d41d9611ed773f78173e2d80e307feae1f8e1673c2beb1869eff6e740aba010c9553de00e943f352f8b7846e7fa038a146873c91b53c3960f714e879450f056c0e1390c14ea7a97edf2e04e89befe8962b15eddea108c1651f7cb93421688e6b375ac329dd7fb8b9f41a816acf22523bbc8402a704938f7b2e697aaccb2ec4194acd9554adf259a6b585078750c49d69d46859beb2daf152bef5420512a8690b0284f42a585b2f726813c46e5fd676ff12ab3bc4f85d057fd5d5794ac18f9982655cb4c7513b6fe275f491813e1bb89b6652325b6cc5eb03d7c46f8dddb6c999b38e45e746dca9757151520e0521f689f050962a1c0e0a7a9220e19a99cc99fe3b865f3f13dd7c53d39150d950b9229b782669915bfc43db45efe3946fc5fbbbb5bdae333af4f483a6d9e0b34f72e100a3902e1427b2190ad90a427b9c6ca324304492d52ca9cc7fba75af3cd3cd93b77c1aebe4909908636c2251202addb4138917c37385df6d32d955b3b2bd09f501d0665146dff48984662612438e5b07d31fac1908c4cc9396c86ac96c9c30c8ab8a7cebfae78e2fc977e6d7c6ce176a27cad195b2f0b6e9119c4480e1e7bba9c1b67b4680f01461e40e2f7c06560cd9eed205dce544c87a2db0b05616cc20254ffb82871ba4deadda1ec9a22fa5c13d4335be69a29638f9f0a21803f879da8408ce293623e65e3518f4b67cd69136abc09698ba490282726f87764e80693dc9c77807b6e80298e56a96604aba226cf562876305dc925ae9a6070da551f563095f6024958c08554a6125d03de9835ca35f7e65aca947b8338b594c837c415681b0c09affe9e3b2e8fe7629f2c5588586d9018be8d25517e72c07dff679ddae2ab412c5ce54cfb0e2e1e10d81fe83dea97ea38d9190ac3f76f0bb651edfd11b296b6779a65713738e04c0e641236315b5e1bb362e761e5395565f86b27a869881d8a9dab7d98f159439281e1c1b31f454480e76997602ab1b6946a56b67b2e3a1e9c4968bee1456d5c8ad4a6c37e52f3183f5fc54bef2fa4653eec0b35a90fe5b67057f45fd3055f1dfe9b6f2e7c4abd0a79b4607b3f96e4bf4bea827c6ecd983717ceced8848a89a4b2e51889428da438623300383a53f290e0debac07ca3398429fbfae5d5f2be55fff2932312a238c643efc1390945de08dcdd610ab5002cd658c51569d674faf078219b7e102daf116343768d84dbfc5105eda5c10eaa6fc798b4b560cdd8adcd2d160155b9526ff845006370c19a94d37c3f1b2c0294e0a5353f6c8125c57ad98ed55fef5318ba4df5c7aa964182a9ffbd584630dc5a1c77714363b6db704820ad15f69821a2aa92202f605b0cd8cf190a7247cd966c6f247b756461cbbfb5bf0bfa86ed551c0b2c7ac91eab614f28ebb9450f4a6d3e5aaa91abf2f9c7aea5d1adec88835aa6cdd04e3c8d707152b72555f19ab2af108dde5330f3abe00cc9b0cbdb8c8287275e94de2d084c4e0d202f68090cbb434eebb323a30c7eb39efa99408465e44055fd6b6d5e96e7a877afa1c6a71476e7403687318ad8e56d29a6d68c3928f556ad8cf58b4aebae8e1445be92dcf2ed22fa048321ab833b84794ba867c7d13704bfdc0996b7b1cc720fd7e789d214ca813b3c0545c90dedffdc46137f8c75acb73c3de57420f612d2b889afaf068dfe2286b9ddf7fc2132ee4ea84b0d459bee96e31c28fc27ba99cabbe6caae8f4476bff7c2e8d8fe609ea8dbf7ac3dc2f4625e6ec54f47486d907b4c315d212595796571998a575f4fb6652120b0a1888b2748868f8bc4b758d91af059522dd006225cbd89790c80cab64b42d357fc6d83896e40ea06654f6ae7b397ef0b3e5209fa011341e8484735a753470139bb0ddf93957abd513c9dce356ab95d97717a0f7058010b2ca1f6ea530eb0b5f40a7b5f2d73a531e609381711ff4a8e5f8510f7de1514907433db4d2a739303285a9baaefcb1f232b17077a793722da7033ad1028610447435796f1fa7786f7d46c870e542d247272231202a67db4e156b61c495f23df7c027077af56cdc547c0e6748ef648c468ba3fc3823e1a5b20dceb3cab1e67a6749745e1c27c37e1b38e6fdd7f3c1f747b340de33b0e5101679116e3020553072b1da0a19742d1b86f1bc1d7380413aff8ba0bb26d9491fc4df45eb948253ea8cbeac58f56da6323c4dafb82d43ac133b5a96bc669b9508d1de6a7cd8eca873eb6e92f5f8f15b928ca34adcc00457f42f3289d41e104cbd87534f547b675a7307bac6e4238b1030a3b823664f9447093073d6b7a697b8f4b7b87a7fa9f030ceffb02e27bfc86072f4162dd7ffe5648e42a0d36cd58e6e85f730788e0237a4d9d11c21df35d5f93f45ba96dc3a82d18842479d299da7d5a5d699b999542e6c2a18c284659f864e305456d7fb78ff65e78abae01b58eaf444bb53c4433c6c948f6094d472e3f2b0c61ccd23d5802aff5730d4f147e25aaa844136a2e6025446666b50c862efb8aae25e79070f8497ffbd1008696d639a4e0d4ea47bb0d0677e6a6bf5352e5becc94f4de18886df53de0a9b6cc05a7c85256c9e5da1ecf105b0f2c303d7a4e40177d60d14005555077cb5bd7a42934d447c279fb8b5dbec5699fd07e004a4903608e9d018026ca9780c5098b7e3f9542de373de6954aae410c0c121423b92dc1595ec06ead056eb07762ead7a94d00994455cac73c98c60e0e106299ff1219d651e8aa8beb71276f2fbd91e686dc833270be53dcc091f48fce748442da75a2b4952105f159452ae6cd98b7961be5db1ba897f7fa2d6e9f86d12fa310ad17ab67c1392615e1698b53bd232f01a5bfd10440c2dbe7209119dae0dce361baf92a45ecdc17455117d1fdaca82d99da04aa90639f56ab3df77de0109dd66e33026acd76623cc913a476b568cecd1f3c42dad14fb6471b7d6522c19acd5d166af277f0ea23099f274f1aaac928936488446ce99137929c2ee57ab399234cfef3e68d06fa1280af2a3e4177f42973e75d6d65c76fa04d6062f469aff892d4bf4565201150778face55373fe895bd4bcc4c017986acbda3e3fd94235fabea96d2b55535fef4a1b31bfe2ab93ee1aeabd3c2dbd3b3abd0df9dcf43ca83975dcbebbc05576d528b48af7f3a63332030ce5694d5b426b813d56fd7199c9860c5428c6956197c981622fd67ec669a9be2d78bbf7990061f21e65cfa9df84e3e7a526320780b0d434d024a994624dd64289f70393b4138bd104eb21d616bd4bc798dff7fe821d6b99fecbdbdcb99c7aa0764283cdad7de0b91d761e3c064697496ad02d79e00c2de502c6a4a333ec8deea0b694221f99782f7f7b1efab5c2ae0758d3d2f9d0b684ce138c51f76186773ca3956962785aa91bfa2482e2224693d08b7d1c3933ea73d2d12643a9c57130ea48acacc424908e7c1074b4ca8052c776e8423a3ad741ab9714a7fbb4649993cbad8fc8260b39d1c3165f1c0a11f0021d8947522fcc880b59f4f9ca9bcb157cd2fed8ed018e1529839073d97793bc41eafdaaa8aa796f30637f5dfd3df56ffa4c5c65f217264050d38d54369471bce4f4dc0a38fa24c3311c8b9096e2d61258685860044cec1434ae5e5491e8e6677ff15621aed868629c451e1cb775d224f10901e9a4e220ab1710c2a7a35faf2fff1762b08fba67d18e16b9984d05285668e1cef43c0422904c27744346ee9cfdd5e49f6741f3b226f1803e42dd2fe7be5127ca32a34ba60c8d991d3cc851e5826f3f0d9c7733e1dd1f337773d89f0254e12d817b2b330fd793522931155bfcfed1e66e14a7d902468df26b7015271716e943a93e536eef6cbbdffa30f647ba7c9978eaf24273bd11092e13ccf98264ede4660bfec855bfcb88fe325fc5ac74d405b6710bb29e3aecf2bd752ffc70ea2e861de15eb9f3c9a17bb09e149991ca41688d3ba04b94e3f87cb8eace1f0cca4e2881f7463ef12e692631b43b6de0448d6ed509ab054d9ee62fdd37e9ef70adfaee1cc0f594759ee8411ea7772c7fe0eef77bbd00b9e040b6a47ec4ba38eab91929a2a3f35da8154adefc7cdfde3119294472a12122cecc4153f3f098a10ad8effe43196e69e404a83c7e3e999afbf5193c3ffe015f92274ac18c70f48d68d6355807297b018936d898140f68e15838db8233393bf71246da7f9ebee59284b783b8220f66a3e09d4f32e4439ebc2b8ec29f45092d3c44255999029e3656b998d0aab30e7e6eb7b592eea46da6ff9ee3bc3b9053fbdd83c1f66f60347a1253eb6a763300e230eff78e7294e1e727d6a6f003820f3d70c96a8127cf3df4112fedc31c3cdb3e064860cf95adb6af28834d860da4d15dbec3dca1ee36c791cf16cf165b64fbe0a8f8951c94de0b013aff6e8087c33106101ccc4eb00267230d8a8189158aee78399bf9b890ed82dd034515af62b8219d79effeff2ce2f0e6142bef19a3aae97e8228584f3c2f7f18e740818b667bde6ef6f596a8708bc73651c5e81ddd0936f48a856a20e4c019f19c93cd1c5282ebe7a05a6540e4d81e27e21dd4a05c4f84a254b4807a3e8636718572df36252e6aa3811959e6c64e53316a2f9a9605c4a49155e8e98d3e924b2e24d3fc2bbf72f37cdad4d065a8e1cc3df8576810ea3fb5add9d3cfef450cc782c6374e013ca594e5068ff2b8cb7f86a71da7409d07cd281a67da313292670d2fce6bee4ccc171eb0ea2f44316d917e9275ac5a89b2bc913716a70917c247447d0fb0efe1c57ce661691fdd57021f12b4a499d75d229647304f5c61e2e5c43d075d0ad5ca85cbd468a8786b0856392638b0f0a763cfb047f30d44a6bbb914ff6a1f5c6a1712ca047c009dae88e1ab8c405874197a728bd9513ebf1d59840b3716b9b69f14759218c3ed8bbab6c5d8c9a4b65c5fb893001694108032903be7e707d71aef793290048aa778f599581b9296ce69f251d3c444f9eaaf073cb02fbf87a02721e70ab5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
