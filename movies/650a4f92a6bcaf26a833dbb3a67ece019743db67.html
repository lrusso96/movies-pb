<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d34093148d6f77a2410a32c01c01b67a637a612d483edafc10860fc5e0bda333ca45c71fd5a23a9145a3e289fdf48de7df7e75853a11fe1efae1abe4fdcab15fdc61e42c20b0457a2d3f1955e2f3dc1d47a3e50091dd8e1d0da32e78ca8a3f62da474e94e16cd29ef020e276722e0b8b358fa16ad8d60c59e1aa1855bbf076e1418057e454743a9b3f354ba5b058e1af53d0d37d52b6f6e68aacbae28800875bf8ef9b91097411182a4540666e65000536a888e7c666540381c8629082fc8dfd7d2b916019c44e38838d8db2610574600b0e54da606b5305b97990437ba07a48ad5834aa8625e4aa58b8891c031d252ab40ee12bf72d33b709169bfb7b361f73938ffe0fb6ef6bb90b206b3142fcecb228877802b5c48ff0e73dd1575f1d949bdb5b8caa2d3084ff48e6573710b043bb0490f40e79700e5391d31eb9b09165aaf398fba04ffb2ea49818c24fc73a1225dada6512b9a01bd73556abedcf646ba88c05f2818dc06120e5d800b2f33ad66ece4709eb3c9c2c406478f78e7fad0245f367b18305184a8dd6427fccbbdc53ec7da42b4b5ac72a4e6eae9e447ffaa90e33c66415d47a83504ac16a79fd38ec65607a78e34845ba123ff638d80ace70ffbe8b396b8a0c235f936f2bd416ce89e7fdc2f4c5e259c022faa6273f55ea0c383d1120dd2d9f3882a8c43efba74a215aeb301921371ba7ecddcba686f533a78eeddd50724c2a754abc86cbf9c28e9d88143eeef0ebbc7e5e581b1726f8006e35f73074b4451395fff78d669cd120119401af99ab8e3f2e7c8cc473766bfdbe8070d60f4abe1d707544bc7d509d20405f87209dfec4ff3eceb38edb45037c18f4869942d28a7e3d5f1e2033024094a7fa673852505582bf4c7e12916907b4563da07412224a65fce5cfc425f9e244ee1bfcd030c117fb925bcddfb946d40290a12997ba31a2d55b81f22326ea93203c9ab604b2e51493c89975508daa877353cc86fc47bba7b687a2d6b81e279798e35c61c5b7632b279d2e8328bef6e96535d3b20ee3818e71f79c1d214e1d2a2c44b4448b112abbf067df7353c51164c82fec1740daf12aba648dcc51c3447d934082a16e65624f84e89f4c069f2e0b26f73a484b209907549e861f65c92947ea70dc9a0009fcb58336cbe0f4336cb69e8fd3408b86c0df737fa257f17bbb815c534daa7268f91bc621081bc690073faf290edee174370d382a52adfabbbd625901230e6fa572580fdc6f58b611ba3e6400cb837ad3009a2a739c4829f39cb4f374534aa9ff411952f795105b83e3fb86617450a0cb8ddfd80faf24ff39c59f1ad74c09f4e70c6aafc1bbbe56dee94905733ab1affcb699e9db7ee5c6f4760ab8a78fe9d4ad823b9ed65547afbc49416879454be51f4323a8d3d83bd38804dda22d095d83d87c592f4765aded7ca8ca25488db7e9b144576a178f7320332284d3dd17e98860d49794cdc25ae73c9fffc701b7a443488f31ba05ffa989b5356d9a5f0136c17781cb3763847730604a023bf3e0664185eb9c2030742031708885b5161cb3f71b20bac75a7948ac201c004ef48987e814bb2e1ee220a04a5dafdf9def9c6fe1de4170a767c38f7276c1e46edaf90cd6fb5881ccc494de605af6b742641f2b74c882dbf93eb29868e8d653c450fb147a3e25cc9b9417d2366a6d0b275c1c8488f7639342f588ef4c8b85a59e3f061f453cb64b864a3c4caed0419830a5e73f836b3ec63879952fbf8d11a8473f6b58c50dcf5d4e9062c68f46d4a277e495e4458a7d58b7b64b3ae50e1ab96beb3ed494d9fbaac05438683bc4b4fea42003e220e49146d3e498212c8eaca0ec95ab0e1a9e759e685186638ecfd2a0d97b652430425324805e9dc7c61b3d64aea8040ce5346bac7486507cb76701d373b0ec84ffa4b7e5335111a7befcca1c970a8918f4491d92145030830426f23b4d8726d9aa93e278caf89f7c25ddd194c13e5ad89fe89abf407fddadcdf393c6311c5eb990d570765ae058c7075f6597df4210ed9dfa0ef4d58b1156f47146e617f06d4ff3949c2c0925299124608c8827c5d9ab06deb8b10c2ef154b4c2ae65022381a6df477ea6119f3bdc421fa21a17b708b9f03e05a0c89b3a3b86c1539957e15a15221a60ad32a41ac5f2dbd31b0889c02234878a58eab206bd1b96fdc62a72ec6096de9ccd4967dea5c7f08bd1fcc3ea21de94b11328b870a1f87b332eca3c8da02c7d2792175d60103c14b37a8441dc94a056169dae7606d05f0a6e66269dc3ea2b6f95eff267d297e4ac62b5c3d6c47ae59fabfd93dba2808a6d5ec5539421f770e43cf704875dcd122afe99a11c69cf475b9b31988e5e7880ded89d9fbb30a70280d112b53b28a6e8839333ccda0eec7c6d21bafa141b31a9cb5067f281a023bb46d0da7f58ef3584461f36b6764d172585bab350c1682ad5b5e997bca54a5a128935f60603c1a0ff795f5199a8575efbf7ed8a464960d5c7247187c6cedf6ca7ced91119cd18a66e426aee8e887ebb2b6989d1b553b567c87ed1d52c0ea62b3bb369fac2d49639c1bc6ddf0c98c18a562396ad2ee8f8812870632243c29a765fec63b0021b11a53c1a4f9a6a76d3438fc5f02c1ab568765605234618a151878d7aec480025d9393a5cfb02cbbba408be651127d675562454ec21220dd6477f84ece87dd77549600543bc22464495a0a1375254e11720129554902fb2b62be1c82c097c7e2d34c09fbba3366d25ba53084815e3c4b297184fb9ed2fa68b3b3f3e4edaab37b9541c80e08c5f52fd12aa99e1d3f3a8588b86553b3cab8f160e7e63cba9dc587abee5cf2642084a058f75a6e1d649ea1c627929d140aa56d94d1fc2f7e37bad0db5b3205f8849e6a349a1369bf4b98109b0940ae9b47234dbf9b8dc9cab4f13c59d9b679803c6e58c7b304a593720b348d0c15ada4d641b832e545c93291e0c7ea160d8c4f134c38aab503af550b28afbb1622a95a01a8dec1c4afb64dc40a401c365f75c4c2ecd838076c9a454fba688498c0c93a40cb7003c121d317fd624b0d2c472077144544e3182b5c0f7de03c0aa3b356e58cc526ba86031f3230c580e597c252c49b4e34dbf21c580623699553bf44ce236800d36f0110b2f1e4b302b7572c3d3828c1c6b3485b722c56225fd97665216fd493d6f572f1d07051abeefb31c1b0b78b7bc04cf7954f3cb50617e48fe3b191f78ed71955d7d053d031fa66c1a51ae3388a89eb0530a64ed0efe14e15b492ab9127fc95167107748a463828b0829a901dcc5793f14a63601e49b61db91810199e0a52000e82c93ab89f9da7366372f550446c58f896de031bdf25285e59bc2067a8c3924ffa235b731ef3e1d0b8db28355ee2fb53ba77f2d52eba8ad21d4785534844b3025c88c37d2b971b9235ce3aa8cdd613ac79754ff71a79c25f34e35bc607ec6e90c277a11206e46b442c57050737b3da38bae45c1b1c3d384492bd1b241eca689afab9c4fa35fd0d06da67dfff288ef397249243cf5335af5f84e34453a5065f74388674eace544618e3135ea36140182e545024214e132421d73fd6371b17b4775acde8f5ca47a051f474532840039c76977db65e7a5db59eb8fde78f1712188a05fe3761fec1339bff2cac2889c91efee5f56864fc58dfbd13fcc561ee75a08bf4fc1136495f4e88604b045870c3f7ec94f7dbbe5b66da461a919c58446aaeb6304b3c271dcf6a583402bb7bf20cc42326556f1090d0ac18e96ee587d3c3f1bd622884028b33374e6e44f57f7f3b8840c5d2e2b49796d9be4ff08c7864b90e9a7f59cfbfc1e46a05e6637fe017fda4838a985b4ac16d073c893fc738ef13a2d90ad3f6d9cb5a4717ae362a04c63aa6373283542416eabfe88ff6714b7f623cba46a10fae4e2ee2bc51929fb88166ac69efdafe3bad24efe0aa91f3a6ec6cbb6aac9776da0740d6d7c574eb233bbcb1b7ab3c3a32a667ca9af2ebb400aa77ff0e2cf5001be229a34d89fd5f8bfcf2739a4824d1e867ca915be07e4e28d83d1dcbec2d720272b562402fc144cfed122b06669d51d531eb2a6f45348d5e5990b846f4be001b0003d1477e10e9a0830305030a9d6236703d20706d9b0c161d5a5950f031fd5115a84d5a5d2d132cb664e49b1992e62f280b06cd1f10582d39f48b0c0527972fe6baa67ee7116a38f9d4e08d146ff76feeb372e3bd6e817ca4ca8b8e815c229da557442712e4b026448a9170816746b8e1912ca34d7412ae539842c2cb58da58479be2c8b874b67dcc087c62b3f50f0dc0d811961d3376d7fd2743792392d920b7eea3b47f687b1f5a3377742a2f4676f78d02a0e40332b66904b8c2aae1a4d67fa4fd331b5d28c1ef15605c137b000a7b1b2e538b35967100777481bd6ab508462454dbe20e0fa9005137286242adc53380012945d2e6a21a9153dc827e70e3aa23b97f20cb90f78358e996b763589aeb3a387dc555915cb09c5f982d9cd56b4ab3dbff0eb2d5d8aa3fec23b2d022df4c5a15c36676ce4ee0543c26d03f3fbd0784fb9c50d802ca3eca6ab371561bd6a3eee7c8dc13007ed1de143e1db25b19bfda99064df92ed87be5b2b27b66045d6bc6f08483985c2d8c45821ddce679f0632eba430309954c22a45e33c23b73a68c407b0d93fe7e9a4a4da5c4249191adac60f0c7d0df265148ddf580e69b13d531a1515ea153f2f59b71aaeb3f4de78fbb2b96ae7b5c8747af57bad126be0ee545332e672e7a43c76b99da2e2aa8d1e2340c33fa5885805dd1a7875c8f40370a21bd607005f142cb714086cb2cf09f9487177d537866e927d65afc0d18904c25a90da097f7b5e906a6591e21361281674ffebbefee06687c5f424ec96d23481f55eddf50aa7a4c045b7c843a4a5dc0d093156d1bce74c7cafb7624f63eabd4c1d31b79852bb04277081fa6d02b765d98aa0c3c0fd6fbc6403d410333e3c64fefd08a1acab9f7b8d1ad29592805d0d6cc9bdaf75a8af238477a56c639c62a45dc381beeb1fba21880954b98ef3749a65a4bcc21208bfad56d8cae61ce749101e19d1488d0cdd8b16b070f4e5b3e4f7a4cd3a7990916a8380e28e00e322ff979dbd2035781a886847c075df760a98afe199335e24d206c53e8544c90e28be8c3e9f5ae0891ac3c91a20e380b545c3dbda61450d8c4b3c8b63bdf37160725992e2334c91df359ddd0768a55b551ddb2984e39a3e4718c779c1b9cbfe69db14f1e2283cfbdc0deec48028b84d00ec7bc430e41c88c71aa317c7d5757eeb83b5ecfcd6f0f84e9cd289fca8360d8c7b4386db8c25df0bfc0c25a1248b319530d4011ea4392789879de199dbd9a6886fb6de0fd244cd484a9fbc2bd0a630e80360db0133a64c8c0c449b66cb67908398f6e90f018b0e5f243fa26923de81dd7919c57a71a7204447115b56197bff5ac632db6c241d10c2479d7bac484976ce277dd724eb0007bce0451721916d8e644209620a1de13ac9b02bc649ef391ca55b13b54ef80361ef44fadb1c798e0a9c269b0e1a85ef19b885e02144c87f0bb5708907a0283ad2e80afea5bd889cf34fed8251139331cddfaeac120a20f3ccfa8db3bfb65aa23d530ef67fe79cab28c1717763a213b8e5b999beb0dc459e49b850fe977ae63468d75accf4acb4e378c425dfa8d738797e720d1b45fe66c4306847b2051b4c544947d29bd095f885468eb55604bad1f9bc2a3d402e6fa26cea1836b358738f416c87a91e0335c24af630f0d9e5711e2e1ee724e748801f4b1ba69aa482ea9244021aad7c863d7b29306886e67721b1dfe51e6217f2a3f3d60c04f7d5146ce7477fac1f3b0ab7525900e08fa57e089e4ba48b35e3cce575406aa20c74d2e7a6ca4de097c1a92d59375fd08ae3f3a639d357355a0cd73a0105b28e1c0720f7597ad12932d44798f019d2e4eb3cd9c4a3541d68bd15b009d4945d4851a7e7cb8bacb01215bfa2c1ebe68c2796c8ccf27303d7ae622eefa49f75ce607e416a5fde56f6910976de7fd57a0e36af7c306464cc7d2f37ec0f40154bf73878b61cbb1cfdbe7a3caf3802948587b219a61114a8026ee4abaa48e5e30ad03ccf6d3cdd632f97ed7f6ea01e35f7551e71051337a843c463195fc1771ca20ba2769ba394491af8fdcdfb141e4fd5995d3daaabdf75b7b428e8972e3f95f6f45061f563eb58eea2845ab642b0e515eb406d0899adc34d11cf21bf1634574fc80a2ae28c506030d3c653954d82ec89ddc9f1b395a9018e108474482fb3f19987713969a444b8060ebb2e4e2ae7c73a06df2ca4a124cca5981fff8de9a3a3246648ef02664929cd93758c2cd82dbf761e65129ddef2f78a1ab6aea56d1a49b56d0c3609bba6b756de05e32bf26cae4a9177541be3a300604f234ffd856fb0e5bc330063c27b2a222ff95fd50b79dd1c07defaca8b94584b8f66f315b75834a0471783d6e8560b97c3b24acc5c95fca047ae992abddfdc0346980361a420a18afb36f837e17d9bf2dfe2685199de5f6883d64015c32510ab3d3b45d69de62a4a24c1a8502293e1a2b7d82b0187ea910be0c07e68b9a5b446fcfe8eaf93de0293bd8d093e1613f869be77a5a22c8cbfe38190dfe81b7b4c210574244ae9f5dcf4570be0e0cd39ab13857ac365743a1f522d0df11fb560b8ed51a91d1b1e2c3d990ffbd5198a65535e51d73e0829bd1f722e4d6c70c4377c69fb16e714263e2aeb609427ce73cc71dea9c5648f199c588a446c185888c5fc52c7e7e1e7a10734eb4dcaefce5282cba4e5004b1e91d25a624c20abab56884f628e9556aa4b1371653fae1e2017039bea8826010e0fa49f985244bbc255390a005b20c54c51b22e19ca316952df5fbe1def54fa0f248848975f64048ce47e2d9d7410da103b7c9583d6720712d78320e73c0234d13bf2c4303ca10fc323b182553defdc81403d9aef5e473f3341c186b6f851a469b463bb44656d2e93f2781f5c9811610e9520a3ec62778416afb6978f831baccb5588d26f73c39c5a0b16c2bd7288ad992dd839ab2ce861eef451f1b45b0f2d1051dc21a75602179fa5d1bc4d2336eb00a3e11f0c454a1136181bd0ae7b1489c498c35cd047edf77353deaf6763876f14ffa11f40dedb7ac261698d3cf7eba675ca2f6cd5a143b750c6c11b63f3a9f51bd10aa634cfe9f3d5d08eb153924e836add037f679efb25974ed76f1b6faac36759067d2dcdcf7ac3eadc272f73a62a08cb07d7b684d343801aa2bf2ed4e914a24bfc9b0180c7d76b9b2209effe8672e49888c43b1650dd8cf9cab76ab8ccceb27b5829305e83e4da08585ab78719312075a89a945c6dd02f02294435031c1dd43d04d260a897a0199651cd0e04f8fe96256dabf6851c1404e8f6f8f1ef96e4b3bc3e3afb1d246c60e859bb5241cf6246402309ea17a2de0a5e710aad88443cc88cf320d9ee843d4e6ac7e2d03502c7588fba15d206fbb8aa46c68ca2b44689c8ecef45acaf02558598e68d8528a2504de6e5513a118a64150840fa0aa0717fb65f5a89f4a5271f339f77e6b02c160fdfc07340a9ef934d8b3336a46985742cd16548d50dbe371cb4de09a573d476ef2be156f78b1f431f039496953ab6682809866d5ce6953f27631eeb2d497a588776ecf21860b89f71be63166ae1272d1cf2e447322d882c6c8fc74f9170ab3354170a0e6c81ec676a8477deff804843590cafd51771a2c585fd49277cc1a743114973fe38eb421f7ec8f945d1a6fa4a0e6daceba8af486056cc3d12ce7f8a0aa542a52a660bddc91fdfeb1686c31f2580bf40e07d55adcc6d1d8b98df49a593e851dc3504a07680fac1e5c0d27013a34d0f8a1715a9b486dc6407f522ed42a3bd24a06cb1f43d7535b7a502bed1985d6c2e077aa5e8020cd3917a89a9556aed266432d8b314e4b3a9e8dde731e5a48ba244c14b49b52d1a71aa07cbc697c0fce87a893ab436bc12d51d3841c63d374147ce62239eb6811ddffdbccba8b4a12a091ec98e9a57e1093f6383758fa69e5acd8b0a5d8a6779dd0f01972ae2e9f71541cde241857ba92b6d61c38356509815336272772b311211e16881a9f764ed4fd8e241e3ff6f9a5967247e719709a4bc76786abf185bce2479088ba91e154a8c6742f6403f64a6a28e28a538de282a967d54c87dbe9cdae3810073285f9f6d4459d7579611e8d95164bc53bca1f1bf7da86fddf83024dc88e56b81ae78015a64b02fd5a088705cc7b19d92b17db6a4d4c64ac91c82f1007481c850183dc29d160f2cb2b76007307c1be28fcd4c4949678ff34211fe4e01bfe3d6400def4ea6e81b317accfb1ea655d3f005c88bbf481bff63959d6626bc088f1ef2148eab1dfbba58588f812d25c318e3964aeec5cca37555904abfd75d38943c412c879bb1539d5907ef6fa9ec74f21bef441b92be788989f2d9b6e4b5c24c94048ee08ef61771e1993a4aafafaa12d8a6f02b552694e23026d22ac854079ce2dc832f38bc111aadc5067f36177e56ffcb5c8e44f6df317fe84c32dcf794273e78fee0dcb4aaa0c9c004ad64bd885338a16a019e9c442892bb1c054a310ba52e91f25ae344833dd84e940dc869b9fedb30b4d99c110c9a48b39da151249f2d1ed05a937b43312d13c762f91f6a1cc69a59b0497110056de9d942a89bd4f03465fd2449fcc7f972b4e03f7b2c4a780c5a55f97dcf9958193a993453014bcdb804b35e29304621a7ef3b74d6f36e222097bfee506352a524f5567dc3e1923dab6db5c8ac0cb378c5b8cebad244ee69901f3f96918ffad4c70b7b64da370cb21cb98e5115addee3fc6e0dde1955fd12be9782700cd35ad5c5e00dfc7e81c9c738b964ecac032b1e57043d8523b3e88fb57a9799abfbfd3b68406ee3e32dfab8d9c958824b959af17675a91e8fbf0499df33797b466452175d86c265589e35bcd3e60aee0787a179bb15501aa8f1554faba3369959ae905f7f4e304f172a7c5b8dd799c8802a9f571f9e9191e9345589880c5f9f50779d5ff7a5b1da1aee5e30d55412aaab4d5d2d6067a716ead80c9482f0359b5ff8fdccbb9f11dce31d952e9a45527186f6f65f8a31181a25e4a2882c48ed6505583e12aba00ea2f463f4893b345d999412541814ef2147c00120e82c396b577ba12fed23ea986a81f7da58313dc23e79ebd76f4740a50a1dc718b8abef6ad35eceeaccde3ccfd806151515a051a1a9d0fdd50d62a58ada1a521948c39e341fa38b4d9431d115d60859be3a08dcaac60e867debd340386e3f0135db51d630a504bfb0a02211e41196587c6fb10315cdfa78e0274a6dfd18082a50d78984caf27311f0995d23893faedfc52f876b85c122077e579fda9b525d29423a8ba0117a58ec299f7e7bc87b1373572c4ef465995720c9ff654fd4487f800c4c7cc8c3db9ca8455dfe5f8d16a3e3fe66c111259a9c2efc9fdb30a1d823fd21d3ea67318e1e048ace5bd279887cd45e93eeec245144abd50c74158bd95374f21fe41bbafdc150eb90dcf88585ddf0035bf6c33a82760455e123307282ae0228344db70e95a44f06d89d0ad838d03711968e1a5f32ee8f354ca999a289c628a747afde4d0d630c4b029f6fed811866e04448de527abf6e14661654983f9fe22e7688e927697bcfbd648f8ba772857c933f7269df4d4b5d9b2570831fff24867e9c27c07add7ae76e1aa7f1e9b8837230ef8a647b4e2d5e49a53063ebfb127161999327249cab176b86da78fac1608ac9db2a42604045e2c4cb2d9fabbcddf87b6baab523a918c11de24c9157a59baed675b126ddc3d302b2095c0d0e7f3ed972ab60482056f6fd72586787070964bbe56a3a605a1e580b6807a2654f907eb61769de5a5b91577d671bcadc1a80d6edf180bb14274f506b1fb4264527381cc3cecab26e02243b3fbe0a20a75cbcfd4e13bc2160b76f14ea23a046a7f0b40a0a436f07e23817d961b9f609a3d8131b29cd7480392bb6fc08728728e0e773909700f7eaf91c4714ac0001f77cf876c440dd8c6dc3c1b7c92a36d88bc793888c227677a768dfbc52fc3d71813c3ac128a8ce7b44ec8fb2f7e5685dabaf8ac816236365351c67b2d44427f01f09201a50a3bb33667ebb1a757457380a51a396a5a549e8979c778bc9f324e2bcd74a095a617259f15819c88c85a95f14a7ade4ffd293735eaabcd4eb7bdca61066705f82a35cfb194b12d4dda27ffbc812ddba43294550a5d753c207080d8d961ad2a1172ad3f51f8ad72bbff68bb3944f9db8b020a4e52b1736c8f4ad912442ea905f980bd555a1a4483dc2619974811931b6ea7293c7a0b0faabf261145add8b7af66adea426e6d725c3cfb1bceb6aacfe37fb7d19fed6cecc340841dde23b1b67d45194a07d7b5c0028ab79996ffeff5e1b6e947674196056891fe363b80706e88a5d7db0214c3d80e9ba1635a365cac33bdbb401ad1dc9ecb3a2990eb5a27b08f72e05b46437b15972c9b691a690c9cc722fb8c148385a0045a47df79d309b309ae81842c548642519651ee6954a5b24d7f140698253e7a81669581e51a5b99aaaa9d359aa4eeb1f826fc152f9aa524a0cb6c80174b4b57e62291b7b0c0d1a99b5f81b2c6586638cacfd936f8c79aa2dbec8a092ee4b9f44600858e6c9af4dce22853b0cacc622f6a8d4816d66c321617c2938aa6fdb02e250abab08bbf87fdcaf19c2a31aa4cecce8987836da00c25eb4332667ab3b82ed4c6aa5b3520d78a4c11d171d946b690958a53c397ecad134fed62f64a0a4669494e997c64dd0e1ea23ce75c0b6bd7cd37bd82e60db2e6630e39ea6cb9c21d6901c68d5b29d13e8a8afaae9d77753fd5060dfc0d6c610d7f65a65881385b8bee2949175c3ae912c92315b752e99cddef85e9367d68fb70cabdd378b8e9b8faa0348a31797bec14767ab1ee730634da4bca9938339d24d155522fd7aff7e181d07d8ecf32831880c8e058c93eef38a64ba6a94b0a16c10893c242efccf79456ed09ddd7d13028f7e349875b756fd59be00dbfcfc1f2148af1af677d8e4ac44f7952a30c04b87aed244a37fbfb41525cac0d976c75bb2f3cdc76418fdc5d6b36ca9eeed400a8e07606759361a4b253120d5ef4c92a329a871c3239ef3e3454c152d78d0646b39ab98e1f2d0d43f1311e3cb580c77b3d64c4bd6701c84ca5a8cb545c539a1dc1165cdb4bd21beb86f383322b8cca1b9d153813939c1ccf8678c58b4ad15c07ba3b9af4b31bd3ab4b73b5a0e65df83e63da796293d177b35f387f4b68450e37ef77e591a90066b2c046daf22af9abd49a83c9bf58122f2228c5f9849d05e5e721789a6f229cdbd8c671424dab40d71d57ceb17d35417943f864cf33d70ea6ae8cf1f6b0a7e393182bdaff2d67d012da9121b4595f6a632cbad0d7bba4441e0419fe3646d7a8c2c5e5e1fe9be867cc2b245c4a1f10979449c57e952e6f357f57838663bb7cacf92ec01b6d9d1d01cfddd5802bbb10cf6a6216c3cc0e43aad03cbe8dfb7cefde95ec9cd855de0d76dc9ad425430f41bc85ec8b5d757650c28020728fde6fd5a211e0ec3ade254cfd98dc71ab5af59467e36d19cb81ce2c31024d53d79cb4c152d24d08bbe4480a6ad4eca05484684d4a563be3f64339b726afd3e93419d0618c17c85bdcef6a04b5ec237e3d830efea66487f510b0c71ca64d696402c7753e432f459260cf1bfc2461319c2540234b93404caae2061e5eedfee6f6f599838a0a255130a456170cba824fcbe09b049f4688a413584a85b6f2179342e0f46ff1abf056a1c7d1cfc9109a535407063ed0324d1a90de13939f03afdf0abf19c866574e2ddbe85f6d95b30de4dfe62a859e1c913e9965b6500dfcd8fc3219e4fc2542331f36e30647fbc1348dc573002c77a3350678c219b66968c91b9f36cee84ca792959d7f9dd33ba43eda9a4919751fb925db0708286bf19a4f754af3544f8b5211baa466aed4406e4912586a5806c5b2a01951dc916c23e9c40cbcdc86d095614592cac02862208e74cb6d8bf18ccda91627131fdfbe7319c8a2ef33289e49c9a87d0565e85d58c63b2f08142853ab1e0ded6d817a9ff29cb962d7db31d9fb38dcc558a5d41efb3e93447d3b7e1ccd646b67ab77fb45eb270aac2f07ccbca9eac66aa645c84a723070118e25589b02b827d063456d74503ebc404515185f64e78666c1daecdba246de60fbefa53331e2785c84565b22ec4b850f4604ed40b31b93cc94557410bdac0f9a62745fb3ed93755dc6fdaa3e909fe1d6d3101ac44b482a988c26c18ea81bf34c7489d915b4ab738831471d37506d1d6eede43839bceed3da44298b9e904414eb179656a78090ec901fa3f86943133b0d6b45891267662a660fe5b28592272e25a192435c3c725423a3fc4afe1375ff4fff315988566d6d442bdc62e5cc08cff45884ec3ad4f872827b87125673beeabc3c472e69dd08a27627829ade027a290d7659b22a2f70ea9dcbf825d32633c77aea9edfa0a1facad97f53d2eb7e3ac3bc2b61791e897a41dbdf35ebacb134b9d3cf20fd3aa94cb1427998cb2338dbafa1126edf9e2b2afbbc7cbe2b8a7bf556e8e7f22f9a34d20070df68a3b5ee04d8077d551a9be4b87d73a3ed5d3b10cc5931e31f2f1fc3bfa7bee9a810d06d4400ef7b08937e8cd55b821569e59bfacc3296aa53e2ba742d8aa6d6975633db1ee9895ee829789b615d4f9a0fadc022bdc2b049d1ad53bf38a5c3e97732456f29610f9f2582b7f534af173e95b1c3731d7efd5ef796f9770b53953057c1d9b241da16eaab4e31b8dcf0c0dff6f640cc0310c4f10abfbfda515cbdfec6fb54f5b44d0b4bc6622ac8a42e5e3dd09fd88c7c73854cc7d1c3ecb3a9944c1a065c7eab7165c0d133f74e13a99addc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
