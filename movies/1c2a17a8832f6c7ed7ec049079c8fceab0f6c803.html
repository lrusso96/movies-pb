<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"81c423bfe7919f625d63e3ab4c122b56cfb78da9b5f25a0c29704492dad1fb95c8644510879218e2e04d56c9cc12d5cbd74dfaf835db006a567c91374a851bd6ce4f0c2c6a0b3b1d7f4b7e5de19c2dc04a090796559c51b1a64e5f1c37e8d8ab74666e2be46e7f561f6478f27aefe94ae00dd0e67dfce84369e4fa664520085a51e3299a6bd5dc8b993ce0a4b8e5e4d594a863a4e43488229700c2999af16feff88f81d34d994e7ef242bf7c80eae7fc61f01e088fcc41b45795656d1be3c3deaf156a93b8381d35e9b4190cf7cc8d28d0014298120af5c4c591d3080d5c5318c74d7b1c821642d0e0b0e82838f54033909f11dd50f55d619c9538ba094af5fd9cc81a4f912867072e37c64669994c08fb92192dac3eef88cc56b667880d5ffd1f88223f2cbfd2b9b1da28f090ab8ee08c43d81efddf36dbd344deaff09120e0969a51274041e186031fb086d8ac05dc30c624afe84b217b092b2a31d3d3e39707b46f1bb21c96d278197646f2d7620b5ba6672034720934301707b3a9520b81087b1a5a57db0652b2b72d08a29b5f82efcc60b48500330bff5b9c52f7b5afb89992bd078803a1d0312e6195c0004fe6673990eb96a7a65dab97d886dad88cb58f78ce94dea733d3d42c4dc96cd83c5a01f5d7b6515fe67af349c95c0d559a254b07a352481ec16aeb6250d0dec5e16edf42091a336f0f674f68b8822fffd58e6da3dc45e9da126ddd20448c2345c7df198998c2de2e210022d3d20b790ef4641ab9994785804f9f54aed8e8c7d4de3d90f2c5f7dad4c1b294f7b185d0e715162602ac4f962d4534ec837bbcd9e8857cd9be2f5b5ed3a77b44a5097f2c2a0185eec05a581e5218423732ec3e5b8214ccbd40da2c88fed5c1300629a801f7497ff7a31833385d1fecd00a0621a4203b00a426ab257fb5c488fd981fa4e308febb77bfd5c26713f3439cdb7aa1b3ec85f42e06ad69908d4aa45a2e7a58dab628f72421e04156639f7fc8b91521f62499d5b9db082579f72d253ef5d07a6750080c74b7369c82155ca1d3c8f2d783ef2f3808179865f7b237ed2be8d9e8f2510f0a2e58d17cad9361373790438de12d578998fea672000135331a51547f776834659708dee4d50c00a4d553ce1f655fea7e6e5907081d512eae4ca03b295ba72ad3cb241a3ae3f0d91b8be103c3154846b0605b4602793d1f8ecf566a3baadad09558509fefc678530eadcc004f6ee432a14ed08058af413fa0ac30f4f2b30839e6ad3add3f5fdaf2adefee45724e3755085c4ae61cd6556e450d929371a92aa4d701d27a07b1faa38b4b2d4bba1520e4e081f1eed8e7541adb6e1fb70107550890d27779c56c52d23876508891f360c6a9e9bc0668e3d13a6b367e86c5b81de567ec40d83f09c13dbef72b8418bafa46c3aa4c137346e8063cb13553faeb5d35b7e01e9621126840eb1a00aaa4cf0394765b8dcb1624ebb457abf1ec887e488491f8aef4c189b509e6df50438e10d7607866a3a81cb16e4b332fae9479b75709707369c14f1b85fa533e4bb6b0009133b174844ffa9a9babb1eeaa7366b10c13f1ecdcbfcc2d79faeea481a22a72366958db13bfa4df7cd4d3d2472e9bebb76fc833d16b0c8be689fb3e93efb6692666db2762d0dfaa3c9e5fca959ae59eb94b29b1c80483540a357e26b7f9e3a29687569443de20b6575e58d7cd09f223cc613412ac7f608b8d11462b3690533a4b13a12173c48b4cf668040a6d435fe602bddf24a00079fe44a778324ae60fcc9bd96be41bb4de86431f774b205aeb55ed72242afb1f5ab719017d0f391bb1740d55c8e22f08d722f312be75a93b2cd44fe70ac6b8ba98c63a6d2bf69875e6add8552dc3e51699095bd33978475c48cdd92eb49a2dfac3c335adc9b3d13c1f70dbae7e86842ac7d2388ac49c93fd7b7b7ff7d47f423cd95e52f033de8cb76658e17df4b28cfb5ec386bf57d15206657c47e8bcff1e949166f23b4f6e2230af3f344ab39ffed7655b17906cfdbe0e7edbc1186877af69288f37b802ca5503a82df84a30eaa6e62997656f91487b7bfa0c4eb3ff97b88abc3b62f6ad363c62997a692b4c356bafe1cf84f51e23dcec85116dde2072997dee1b775921db36bc1362e26553f25d90fc052cddba606d9735b2b9886e7186984ad1b680a25d6de6aad4b9f41995f235a25adc3f893570e9e73fe52fc3f6bc609046dfeb4ee6d7f50d26c337270d9152134869e1bac39efb5bee1a695e4240f58771d926c926fcbcfa3a9751f9c6d552dcb03aafd28cd94585ba78db8859c4d2ad102c1f07f66ec8a5402f043361e7a8e3db23db2c8865ad271c37ef0620e0287b9bdc685a7d7e78bf7b44eff958d787f0062d581df9f92a812abf0a8cd3fa71ffd84a02927311074e0b219af70f21229a29910bbb460addb8fed7c2da793efdd1734e24cf6f4a26ec1f7940ccde4d419d6a5fcfec07d6c8701e0b722b4f23c9fe6cf1d9eb754550c8fceeb50952edfb8784d47de4888a46f278e53a06f5e6c3892037738a4558c63c1d51aa5649930c5f587cef428a067b00e81dba081f988b8ee570e4244f63d2778c6e123b609574fb0e62cdad4a45e3acfb408329ea682af0f306594153fa7f05ac45bc011003c85263fb2d7d7d716970df4eb04cfa4982a55aeac0d0d0969f9d6f86f8ac28b140a8090dd17c81cf7e66c3bc53d285aaf82c3220c8c45b14eadb52a95b52321760b878157b61e31ee33da3a035e220765ebd424f4b10d2b703990e7971cc8c3c8c57beebf1564ebfc06db1b2b56a4fb434324cd27709396dff25e05d81e489293306ca75f91b4ea522dddbb7658b4d621c8c312f88679a0091a05e3f1f5e1d524323d0e3de148bacb86826159890b5befa0b9d3bec9849dd14202777f15c98200e31c4d2112e149122066491ced70fda6a695eca5217e6ba444d78d8172444d28f6f96e8c240ccc5015a9974461d1ca3210ae3c1345f2b4ffa305616633a70e61f0f10296a953cfb3971236904ece3104f3d4c96ba4b091ba35238a8f999811be2b967d0c3508913371cdb142d14579ab59286375e42efb4909829f15f9fae924316e4eee9c1e1a38542260af86e8085df77d8d191ad3723b7f0e5b2c793649f47891f3608ffa43ea1993c1b7984f9b928891d539ce8c27b00f47a916c293ec3795513d3ff81526808b446c5840c9fd21d5dcea60ad328eec7a14073fd0a3f722effd2c4a1ae5e8b7a0be337e8a5c1dc3cd8540f0ed34087bfe0e1ef2a1ab03ceef592832d839fb6ca9a226b86af61cec2e793a3954c38d796ba71d93b01668fcf723e2d6e4dc7d8d94bf500ee00d419086e75503af69e27227f606a1be1051c9407d6cd6bb5d7a336ac579cb1b54139c08e8bcb572eee235b91a0c370b2c39310629fd969cc1e4e987d3544358db8d5145ac0905b4c9644400e2371fe894eaddfe294792d57bb6f234bec1721d3547973983121d366b6d2c2c819403ce7fb3ff046f62869e89ff619174474a2bfc0a525da8536b56437cc0846091babbccaf2cfd8bc99bdb7ee18115a49e6f6b16d1657af43c42e421e2f449de8ba7cefe728bd73f6966d57378c6c3189c49c1830edd98f874623a57675ffd8c39fc9886e27045ee56251371699e914a63a7b314a49effa9893b21e65aa4f2c1e94a1d36ee02ba13d2f3719921306067e99496e99844b9b6e052199735d35a9aea05ce7c2cdd5978ecdd1fdb77d35025e3a9b545fbb65642b19379c993fcb3230baf504a11b268233011f0e548061dca0bc8a823760f948754b542275e6f841a464794af58d8ef555cc05f910410a1f8dcf9eeecb398a00a897c2770f09853e2cd7bb50d9d43bc0c284da8dcdf150f1a8adc6a5aee34218a30fcc49a215833d98cd200380ab355232bf5efbea2a4578d7defee6336ddc3f23e51899c2cf097d5cacca2d2939825d5548415ee2798fbf78efecb0269ca766eaebe16a0b45eef82f86097fdb9fdc06cb9b597b6df8fe2ba815f20adcce8b88f667db32649a9e0c8f96b857d46e4d56e1d46735b87a48dd0094502f3bec418548ce66f8d7aadfddab9b9d7b7bd35a726f065d0f032adef6ab327186b947dfdfb1eb8f5855d57e983cea42439c6cda30b2252fc1d294c1db7bba811742e47bedc8593266f468c817e79ea6456a0d322c0e70be03472e7ad24721ef962f158f70f611aff4ef964aa9d94e7d87bb3b26bc18f907c9d7bde2248eb5667b69978e30759a2134fa10f319ab4ff67c18bc7b488456aeca19d83cc3764541e0cd9e54b1c1cd82e2b112976f226171ee8ff09c4b16f6aafdeabd54bb4eedd1feda6d9a4eb84d31f61f35273945d635170cd910120c363eeb93b9f38d50a100491b4ca88477a0a35daca36aeddc81e2cb2a2a29bd0d1f386f55913d7ea579e66153105f4cd79ee2e321b40f6761ef9d782a9fa950955fe681c59415ea9accbb73a020f36bd8791e344c76358f8f4b1994492b15a7c413dbd9bec9eea72e595a644ff59db4f51f00125dcf250cf64acfe96f1943c8c0859151ed8c3275935fb37381a919bbcb92d5f95637656a6acc3bf6669ee1afa5ff26fce2b6d7085df4fc3508433e50132b24b4002c980f7e41a72d6f76b587c20cd8727d24b112315a7ac2a931c6ed2d373632d81da88e05588a95daf6437baf58d11faaee15b88509b4a267afe7969a39751ef2d626c4ec62c0471f1fdf5b9d0babc3df756cbf8694d03bc9a8350200b251baa4720c94c6579cf4b9cd34d83e1ab75b4c72f5d05a549bf8ed58f3b45a33be8c40e359566e18e6d5db3906c2f1b69c298c254a117598d63a10243ed7e0eee1734571ed15685e6baf8b662dd557069a538db996193d3f680e954c36cd9b785284a2167d8f9147f6b13951fb93a786427544ea33eb8c64d4a9d7240abe3248310519c15431a759d9e55265ae6c3a3c6c80b7213378faac16b2cb859f93f7d2733ff3e08a3d1f005bd5375bc6f28cab0a93d999e5b7bbc29f63fb38f81a9ea152fdf4a25a00454bf943b9067f5321f40f07b35fc87bae05a67d6710ced8cd6a2ff7cf3be98f2cc6931d5cc3aaac79ef4c757f29624f783ea54c29a85a38081ec2d23bfd516c9ef46ad6287185ed9191064c5f6f57a0f8d781281aa739f84e57cc96e036804877a4ab07505e4f9b5984499df72fcfa01e783d9c2ecfbee3943372247d4fe0f2a6edd37000616c22971272f9c606b8b69aa2b7256804716ef8d10c5b74a56044f9e58021ddda3ffd0e731261843ddd8054f39a301bf01ea5c01791a3f6a46e3b3c716a4549a33aa3fb9455e72536dec34094ecf632c8f5b4c64c9618422ef728fe57dfdd6a803e4d94983e5f69eeaf6dc03d35d89922301c8483016bc03f381566adf0eb1a255eaad822861fe753872ad7d461403551c1d80c0b356fd79e3d768d4c8713a1b479fce649e2d67c965cc47311f16a672864d89ee1c81d47772f373b0df6df76d84debbfa36d2ebb6df2f45d5662dc951223a4747e18327aa7695baf4af455bbadaa1a0cf26a236424028142331a9084e1265f5fd61b504d40f28121714d8858160bbdd8186a7c04e56aea5dd9a7ec59ba41182e4322b713ed23d86ebbc743066d8d874cb239b5ece344776de0182bb479a9956e09227d8273d0c92f5131325071b23e6e8e487b3197e36d153fac04449ed12eae96180119b769a6174bf8788ec2a048637e7f9950c29aca2404e025ca32091cad1079a6eeae87a7c095931e0ea056ea7dc5485c4b3fed4d66c47ac02bea0615832f4842d3d32319696e00d7ff34c424a49f0eb6135b40687fec5cab9069d2b6f8dc8790c033d937711672e59dfcbf00ad55d6cdcbf909c32381f19b60fc08a0981ce5e9c1cc5d4151a4e73a53ebfe97f72a8bbd492d036b3ebec448f065e66802fb387139c7881f0473bed33562e231759ca1265a1e4fe58ffcd6a47e4423e66535f1f92bcdf4d8daa28d7ec6f83bed6fdcb15e0bcb7ea5535b373b7bc0aad4f3dc4601ccd7cfa4a4153fd345a0e9d9024049dcca47141565b1e83829b36ed04b9353f1cd5d945fa39c04c299a91157f24f9df94c07b3b5c4462b6bb9df547a84263c7bb1c3f9420869958e36f9bae55df15a87ab16d7fc102018bc0bcab1f50629387aacfe23a8a04d8f4773de7d18361291e8376cffb8e9b1a0215636d8a9616300be684f63ed441ee198370388c153c6f71c5240ac67df756e9d3e34e40532da54f370e1105d5a8a4a0fb9db7521f1b1045084535f2f0f66d3b1f49290c99e35fb123532dd597d9b22d898cf1afdddd164a893e236131a2dbc83db457954231640ad4978b4f566c45ed10e8ed4e8e49a3fe7b729b1b61632b6fbb3fb44b123d90143a0a0a2676c4796c16b15481b865a260e4881b8f2a48d76bf89fc1c3a5947a6683c4e0ce60ed4aa81dfa4808e408f8efce214475298f73716ee48c43a358804a724427286e93e0b5f8a087fba31fda0825d1fc29dc07ef29b7e33b3e7084e4ed9df0d28b8b6c1e2996f63a9effa93eaa0dffd33a4ac89bfb2f6a081c2bd66e931d1b3bba7eefe318a48647deb459b6144de4a15204f7fb0b14a908e4f4de27ea86b1aa796a854fb85cc81977a495d6fe81f2fb4dd10096ed621c6d820a9987d29e4d67ff8b304b2dc10148f942b992778189d7b93d2f0c37c0083b77373ccf1e0a76875c19d17cf6649392d9572c5865293b1380b31ad5df3fc33de21cc029d5b32583b041f8344ca21e0ebd9c628af1e1d2c3bb76be1928e5ae3ab86d2605426b5dd2e0a34f7f4edc389dea5766fec5ec04de139ebd558f1a6f22b8a6a49e2da83daf487f66daa68bbaba0012468f7294705ab211be1e87222ee03e46f21cab1a06cd99f8a0c8207664422e1f43b96776334805f4a1eab3659664ddb7b6938b96f143293774e9b646e851d6b5fdf72fe2b4736487d7fc61f75acb606ccdd50320836d1419c21e028a162c3f48bf3d24680016500e4fad2802110ee65d86cc43f35adde9f5bc016179b7f251ba649c7a381fbb17c4cede519c28b4df188cc41dbaaa3bf75edf2a1485ddf3d36a8343e2e571d9f87700179a058abbb01d2332d803689d54757d4df778bf1e2ea62145a3a3833df71acc9ad9bb05d286e7c76192defbdc2c2ceee5d63fca0da24282ed1b0ae91f4fbcfa6761063cbfb420a95dd28f34cd66ca2a9b290074441bd7d518c9186d0a6c3e9b4e6ae980e9b68516f48fe50dad3df2b2a7be3d4fd92f196057fe29b5303c88c544a0bbec7daec732710511e04c15df848d6abb19fb52e28aa1c8eca824bd63277d5b18cf86abeaae6bc8496e4cbf1a5460c4975a4af43de92780ce58ddc8defee34cb1901a13dc577d4427744b2e06a26eaeaf4ebd2522caae144a758c0fd80efe17830f27e599a350f975f5b095116bb430a68d2b1c47e114b100153317d71a9c54f721d97e6eee1de5ca016c0ba1cfe45c9dcfcc80a9dd0f13a75e19edbe68079bf29835d05c4c4e79e0151fe80b3ff35431271c950f3d495d364167bc97a254ff613a97117608283bbabecf36105a5f1ff40ed98674556f44a7fed0bcd7fecca87e98b23fe3e56367b6f5a5d73d983e71b19525560f752a7edce852c8bf4d8a3daf1a12c98bceb03032493e1ef6907883273839e971ca338d7b2b79a5a00e7ae260f92dde60e54b5fd747e7fe95804782d7ad04d54b9c21dc98573c84e7036d42e6145322619edba150eb5df682bb488060a1c6baf30930b3a2a873cd2b5b01649f4669af2c6169f2098e6dbd4c31a5869e4837a695e50893fee1cbfcbaef527051567c0d734dc35d1ef8f6473685160efaf1912600bd430ac1c50169d2b73e22e4d1cc57c7538e5bfe6770eee60a221dfdb94793d9791d88b40d4fd7e2762ca9d9dcd2b43245006520ce7a6964abca70584600e2b9652933b357e14b34ace0f5e5f51aae88827a6de90b32644e44e12dbab750cdc664c363ef5711479619213ebb9426354f5b0756dd2c66de4e5937310a2a78ef9b01566ebc1700be60146156cb3db9c3c45dbf09df6bf287e79f6019432915277bbac58a60c07ad7b6ef3823e78641ce5f5b431103b94a639e8072443ce65b2877b238317ce12319ffc62e9a9963ee3dd7ee6335e48847a62ab95d52211091e7e819837943686e192aeea65d26d6beeecee1c990a75d87b0af9aba47c443e40ab2ee87addc34921dae62973efcf25a16be3f01a64e1a0499b98d6407f73c1fda69a8058da6235ee321b5bb735fa1572eecb6ae6dc6eccec0b5652691ae866450919840d2d855f27fb6b7d0934f87cf26866f22e28952d6dc6de01f0f51cbe35e9a61328ac21c0dce22b10b8d7f2ce4c7cd1755ef5288586650194f8eca00f48277bd2bec88b8c5a030b1909aab34451cf664905e4cb9118dbdf483a8eae1721cdb5bd4ef5e220e6052f4a2253807a409149abf4fb8ac816889eed5ec946427966ba0b8a6f06a6680ffd62e839083cbfc5eb7c32e561b3fd220efff49b085b5a9c261a570c90b8029d677fffc0090f4b51804df64f71289b326418dfcd1ccbf15b97cd71074561e517dd9b6bfa05739a92d8012af186d33b6a296f03cd6bae0964e03c3aac60d36ade3ebd23799dee197b6096a56fd0dcc4c9ad9abc2fbd6fe8f77c91c9a65ca9f2551ee46f037a9dee9676020a5db5b47082d2135c8c6ff01351dcb33c8e99423cc6cc446eac3c7622a901902208ea394cfbd602ffa9cd5768e4a6e9ee75343eb4f9f910a8947a3ad6ee0b1d14ce961bd5bcf85d792c082e07bad1fbcd16f2e5f0b388a3aab89c1f6f135d341a23c782ab4bdab2a2335d6c8a346569c6821e8357a06e86b14a34581f42ffdc087776769a6e9e28c5c4d477842a5ee41c7eb77545a3d4acea5e2c2acf025545a2fa300b377489bde758c897141268b65352c6b2d833ce6b2d7436d7ecba66cb5d0d031ad77871fc3483a614bb78d76d509b936b960b4f50a6610c8c6484fb11758337dc09eda56e3648856ccad57e757d2258a2515f3f8f1efbc853797f7463129a2d01cd3fb8e513e5c43bf8c57ac21867c94202fc540003c441fc4d41672196c34b0c790880b7a9762e64c6b4c026d8b54367e1d18f046c3de0b80bbb14f916b02c412b94323dbc03751662d6a83486dc19ca3ece1a09376440ef5cbb1a35efdd98d65f62bdb703ec50460fa80f3f4c8e5aac4e98f11fc49c96cc0244abd0e5ee80f28e4add81fde2bb64739c872a1483331cfd1afa5d3fc4092bfdc5d2b7a3eb46a7132d5916da9c2f1426ffd879e3e32d5b45a22461550e18c4502f251e9bbe5a15274e688c3a627052f29ef2130aa9bd2d45e5dd2654dc6282a4847f0325b6f00bc9ba5a9c91336f5805bcd2552bb7e14eb90e3e959734e10c64a7a808b580f57fa3daaca793d484a0de29cd54207313a147a51035fc1e18c23abf009326fc257b6401a08bff196513128e04c163606145ebb1202099857b319b422effe35c7777d3db9b90de4ce23b2ad270a2bb0a1e32c3732953d0d5a2a328155701174b4635087cd4fdc2700c539e4a33b7322545f9325aa8cc72694235697e0307bd93e5db14e29cc54e955d4ed219fce5c160d5de32320dc14b59a6e6b04c0f06363a6b11d756a7250eef0745a918364e4dc358850f93d96b828d65cf90bcac25dd501fca631377d2663d050d55fddbe0d3a443f38d1d999aef1ea6caf3538a8a9428f1a1521214230e5e4022dc4207aebad4fcaa6907b86b13fc8c2fd6bd5635353ed9da3abb3a69db7e4af070e60e5fae9950d146c59263e379fcb9306bf40cfbee211b80394f724b17535ac60313191292f3e2b1628d26ffbefd4a088c80d26f9aecabf1b3386a9911a9f54991ad402070c22c338582ea5ca2dc05004b74706c09e33a06baa960b9ddc5fe6b393028b3109f49215eb3b71405d524a221585d9df3dd83ad7148614368a15d4f17e68d5e9793d404540b6573325f43c7e8d3c69962500f8e993c39a7f3ad1b3ecc545422cfafccabd7f59c9683bac679110756c7b7c8e4d6f1b8feab7f4595b8fdf203f6847f7503b798eb20ad966edf82254cf6362d3d8ba82cd4fe2eecb3b4926c475f361a248583a49f178ee815caa2bc5bac75fa10b5de847f41a0cd9997682fd1e987f6d2af2ff458a69d1e718f6fd6c20bc985abcbc7be174067b9641bbb91ea3b5316e9e4d0b7fee6ea2a25bd65108f2f96d537ec0ce7cf1ab61b01dd00ea5fc9ef60a313b3d0957039fc695deb73ffef51543ba2929604126e0f5e27643def2c9f569e701df6c0f50735b5a4aea3534b737c14ad38feda8b6f7f57a7dda64a3b5a923fc4e8200e6b1b603e77bab738aa54254836b6f0d83a032b020cff1327ecc102cdd0eaadc3016fefda7488b0b915bcc883923fc359209e06b130e8d61a79cef36dd018defefcbe86af242292e5a2d0ee94abac251fb282694dc7bfce9448a4875f0c996aecbfa811c95c06069cb6d7662150726ce0e1ea34c17a173642002816c67efbeef1edd9dc58393080950f75924039b4ad3e919203560ae26f32e484bca06fde91a0a176a06cc44d58dbaa624183d39e8daec0195d438d353ff2b63326e81333377ed3e6e07ccfdc7846528d8d579248b6be5b280de45d3ff3b6a5a07aaec2cabeee82b09d0b79bb89d07b5f3689d5165bac9d6b35fc06cea62806e704bc0683c09f00d22b05a31309c942be4292ee7179b9aa37d5476e9dbeec50d772f6dbfda1a26a8e3bec3680d3e9969105575498a249162dde255a930251b7cdf9118c4ac3d687e1c9dd9c834bd08fd1d42178870717fe93cbd7762bb84e3e8816698d35dc7f17029999bf11ed081e1ef33e9961dfdd269f6e580c1089434fedebd6ca41930b1c353b4601823fe0d63d67786113aac39c30a37f997f48c9ef884435941dc74ea894cb1b4d2a3797bf2c1a2f4df34197edbf62ef9025276d3799f3878509b1e8ff654bdd9010f028d01196d9adfb77e81b61d6f984e117bbdab9977c09144a0dd0bfeb6d702e81dfb9935009282df7cb49afeabc5f015fd0f9c9b728afebedf1be8cf003ba8de8c428622e26290b1c50ffc60287882783db956fc190729d1db9656ae2c51c3f1be6b34d2b63712ace8542ab0ed0439f034e3ec2044c15eb5e5e4e33a4d311ade028c6e08a00147613dbbf114c6e9aed3b49326c8ea5384936c2994b14a1e8f2039b407de1918b9f31386d4c394ec0edb9cdd9660da995478242da2202895ba2e99b27bbcfa03cef8a9a0cd66a4d4d45fe3d8ee985dc662b2f2f15c6fad221d38ddbef5ea43e27d5c479e166fd5ae25bf9d7e59ca8b5615cfb36c3307ce60882a6d932d176ef5595e9b2e65e13c239aa731e89f9c9fd91d01575e258c4c9c30c5be8a003abbdcf7a4ad37ba9bbdd3ebf595d060952a5f0f32615bc5eda77acf812c0a328ed2bd62fb83e26de113f360007728be0b176b6be774b28244a2dd213e5eac429780355bfb3c9a33a3ac6e67cb0c2a77b604924bcd8f50d222986020f37877b416ca3e9ce0c955a01d5e901f4b50f1b0a58667b3f6edc0ff261e3a37ae40b9c4fb78250bc2dcd15d12868d345f4552a0cd75c6ba5fad135b12e6ca48a3a4d83539b19bc92a413f1e1bc2803856ce7cc9eef0931c7a46224cda1435e426fa9dbea3a09f3233b5be7b6fb1c130b17dc9568503251431d48041b0bdd5b2e87d9035c9f0532b5b48b0c723e6ba34cc6848d3004e5893f979da42975efaac57af1559b04bb526f4712c401e6289beb308a86511979c4d704bf811fcf2e4db340d11b0d076a5b46413e7c504e12fb8c07ed497fb9e75e639356d4a56d9caa2c50af2363f551a988494d8df4a836fec10658358042e2a660c7c12a274569bb91a3a22eb6fb21ddb6374adb3a80f149c1d7f7bd35dd3e1d628cf3e6d5bc7912eb528ba0123e21d2c5adc05eeda24bd16b6478c6855069ce30565fd4987dc332bbcce4b95e2184a5bd45386832dad8d873897ad6733654664dbcaa0fbc0719d94bc65b013dbf1a44be2428c60c0f727d9b07244e267d58d3458ee1575fc4c3b22e6bf88e8e6b339fc1c8079a8f87eb216907a565012fdfa541904e87e6f1ed03e27814cbc2fd51b33833241ce5f9a97c43da144b569e7d9fc8dfa41602633c83609f7235403ac773420f44ce1af2cb1abe2da18593279f8c19133000ef4d59163bcf757a5c581902ddc18feba9edd4fc71ad8359da6d4b9bd1c6b1e6c876c8ed458dbc5e4913f07e8777c197fb70af747dc67718fb9ab64b7fda0ebda60d7106dc759cc3736165b24ee3cccd0fe30155766f466b31a2db64891a22a642ced9d1113a7f1624a4d1f7fef197994c539ca88f34d0e8751fa6d4120c677d59a73ef4ceec56f1da92cc1a332c9437bac398146e653c88e2786f4cb7acb0eb6ca6f83eb2d875c95b410a9e47de901232b4b539dd16cc1774b694e204763dccbfa6512fdf123f3dbc6843c821e31f31513c7d15649ad0e636f7bea46dff96d7a3bc4eaa4157475465c532fe5cedad75967a789399f4accf45410dd341c14ba033dcfe7163922e5cf00b6be83ec1e33a05c45eea37e7cd873e3e2d7e4a63f5276b0bae36673c486e3be2108ae04d9144edd327d70366a6eea20ea9e177840934ca249e481df4bf62cc20d747275693cf5f6485e3d6423c76e5e22a6aa111876c966da5668ad1aaf14a95baa01746ce40921bed3f65a0cf857c1f1319c0951d817dfa4e70d36aabba0e729d6390450509f8a3ae9ddbe5a56ffcb7c72562251748f3892ab9f83bb0ade624e7ea846390a32d572489a13e9630910191ba6d047b0a4f8ce7a643f03751aed8c9e66b7113f17cf2bea6179333f9c1d8827e767901a17f7c29889691419a8aacbf1ec1cd2e9df62f2c001079ba112fb12515d8a88d9bff0f8c4c3dc81402cc66df2482fe99bfe8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
