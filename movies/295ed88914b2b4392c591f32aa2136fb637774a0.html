<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7110245c889b540cadd2033b612bd1138e6a3022e0cab40c3f8798aa60b4ad4794b2e9110177336a6051fdc0060296b26805c2429b4c53383b4a20ebd851a188ec53399ea9899210a9d97543c1b1372214f56cbabfafd8450df6f9da91857aa23ead92c4251b0070be2c48e9c3fecf6962ad85ac56de7b3b557067a12e2503cae2d56118c95d027ffbfc271fb755c3f0a191d9bc068db8d411bfafebbe82def802a40aa43304c08ed3d618d23cf1f510ac295299165dad331516425f9d3421d45a985a75495faeac12e22fb076fa7955ad63171eb5062b7b76b34143d2459cbbdd113b86cf3b91a9e0c06bc8698637038b538d849219a4de9c7157ee3c896127c7e2908a699b5e4b24870b6f838db30a84a626e5a847487541944c966edfe8a89ac69aafff2b4590076ba04652df031f528241f50b42f251c99102f026b71be8c4927b58770a625b7599dc9872ca9b32b0bf4344544afc51aeaf8cdf3fb652da10c9e8a2e7985b1c8432f6f5b8327a93c5924278e30f7be10b9eeb70409a6a26eb3f17de721399836faebf94014f4b21257922d70bf04c9863e4a64586ae211f9eeef809e6d43c16e0d5c93b972e485228dd04ef7158f99ea8a652939815a571cc3d065e75f275e0a56fb2603f3a8a69dcb98b2cf28ed0ea23d61c3b8f868c1062bbf0352c7ec83481fda166eaa4313f1949fcf4ffcc9616c8332e95322ebb96ad6506ada06b316ab6428bbbbb838bec87237adaac5ca19abc5521af20911c6807809b22f4340a5b3ce244acf48955ef90575218effcd671b917642d74287a93cf473c19bed0b7c6ed2aa5a4213d6f226f055b40c8f68a3f19a96b19caef910d2d5e03910ce08024d509d72fd3bb0b1ef76b7c288d2776821360adfd39808c31b13942aea76fcd32e27d751a516ab7e54e2476ce72cace681be1749fa2fe0c9ccc4229570793cd9c1ebfe023549a90a2d5d28a2617b3341bbfd9ee06828001026c5a6df83e4936e131ff5c8439cd39b37e136d1f1b713d805d4a138ef1ef0eff9eb52f94c99f4b48f84730a2c52b659112044948b19dd5fb82fc22bd5f1648f989cd09c0cae748f4959764b4b484ad835d0af30ad025a3fb046b5ffed643bbd0e5f4de94d381d95fed7a56b69a44c8abef66bc881b5fd6f0d511bfc582565489d3db176a295188178ba6dcbd369d00d68587ea53b10481fe85ec10f2659d30958f4073df4f8f97aa87277875e52f56c714523aed3cd5c61aacb9d6f07d0f1d2e6d9834fd2494733337e2abc5008a3f0d50c15c0729b556a7c414cafd904260bf7e250c862ca31c6e07252e00ceaba538e987ddbdfd097041f0339d1c21f554db0f0eb85f07fd23d3da6d2e0c5ef4989aed32233aed2f32658ec47474ceb8f3a15629db70eaf412fc6dd31d52f2f94f29eb4a4a316b942e7ea883b53609f2fc667900b21b1779ef7fa696a747588e898634b8ca7faec8ed7b08fe5cff5d0130d8f58d784a2b7c23138d4e31d90f1ec5fd4d8a7739b865915ba8a9f5166891b0fad3d7a815cd886579e0d7fd2b45237feabb5731ab9ac3b81515c4e0f67c4b519cf3e7f6f47b27c8cdc2286c5f2a3cf4e66b11b226be4ebc8ed185c87e2ad6616254d8f4dda69c89049049bb4dfe5723cff614b276cda30cd6ba074d7d071665b92197eb74833251a137ad57e987218ff7ef660ffdfcba77d1ce488fbc01297225b3bd83a79a15a77c2ba07bd1494fda0fb697d08c8a412ee84edb70d8d1c6928c0e78111de2ec43045c0ab17bd1807a8588e7b782ccd3e11996e91cff7de3f490b56453ef0baace1aa262ef9eadeacb747099961a1c06df682d7a1d45893f2e3ab6d9358a7f9adc948da5e73206399f128649661bc76b24705b2f530c678c6ca89bd15cb511e166c66b4348208a0a628e01234f04c4abf9e0d1948f20a9da11610120eb67a9dde2e9e7790860733e3a2617ca25e20a5c06be054b1f5c15cdeb516a2b01b255ba9aa9766a74af70275d093e4ebaa38c9e32394a123669e5f8c296220e7c67270e3414b40fa52cf62e1d544ee2aed48f681ebbb4358a991302f7fa0bf94118e8d34a84274bd8d24559e1aded0556176a704e292e7a535e761c087df3ca5976a0b375cb1887cba09146ed9337dbd4f64dc5eb1142be10c892adb0bc479318635f69d4b27e5c92c9d9ec8ce4c5b4fbb2b00ae30353ca38c458970bfb339b2b3a9e69b42511afdbbb118c647e2ff173adacd735dfc9060dee70036e85fe913d458a6208aa0202b117ea581183de9b5e090220e97f24b6bb4ccbfba9405ee641949f8a0409854eebaf1fed14d69d943e2756d06c7e3c6bff37acae71db162392fa09c92a64879fbb3f126deb27747ec7cd36a0d5eec5d54cbfffb9bb6802bc3662a29eb851f28bffdb0f3d778e8c162079d918a3a609f96197b68fa968284cda4ecf6ed7fcb1f1e98a546d0ed65233836c8d7399a25e06e36567c42416971ee0b342d3cba6d1b7e6a87ba7f32345464af84d28dd5519a33185f1881fef0a07576bd7a96cdd363197f7b244ae586da48ab05883e8abcb5728ae638c02b350c953fc119fc0ba9c8eec53e2d8ef26f6db1227a55cf27ffb43252c0ce082a4624cf5acd33ef28a8a5b839dadc0687ae51ba9b8311bc4c50e66f6711c99f0b9f0fba17c7bc5a2e52e1733df98ef2937e05f442a8bdc42167d2aa9ba78680fd89cd41969a2fc1595e499981cf0b274e13216388d7ff6bda511bfcb3b8daba12e5a6a35171249cd1faef7990c5384f2b0a01a62222d41b4ba40e4f478e83abb79d118c8600810e7f2f16544f2afb3cf71b8ad411570128effc070d0726cd9789d616a9d2c1879239e1f644a3bb645a0f61d51c34419a2f2677a4b2931259367b1ed9a3dbefb66ba4b3173b786432b2e66c114b62bc963eac76b81e4b7a558881a6bf4f6bd9ad6fb73b135c7ff154f058d2fd2e6a543b79d7e5c78d54966cff21005c101915e20971f043aff22cd6d04b0043712a9f7bee2fbe0f15c580867f037ce5e1af30c50742534a5477fe232885bba14f51b9c4e86c4226f963f6001a0bab2c0673ac40cc48581a179a05047c0faedfec5ba4a163769d2329b9a72a3aa8db263d3a9fde3f9c3cb813c71ab0259a10b50ff4268159104d26db516337668240c95836895674927d5d5a324118a97445cd5ab37683891ffb3883fc077eaeab3c8e4ac058e2e8211a4ad39aede578877bf5e7779315336887226301408854ec02beb078bf1ac77f093433d3c54f60afb4f2e50b5c4b35d1cb0e6bfb8edad5b82380482d0905386b632b6d3962a0d9999e4ea257a04f246c33348edd827333a5c2e4c7f0e2d0f9bbfb2474c9bd3e253db6de3d3feb49581a1264290643b1cd24c4340f185baf263057ec0c2714993d911018f5c2f7d8228260b4cf4bcb754721628063f0a86cb6204158ed814189c95cdc783a7aebba6d4d26cc44ce10f16f6c6666bb0debf884bd88748b45de6baf1bb3b93d35f717eca6f9da6e258c06bd311a0dd1c51a53d7e0d7b72bbfb95c75681fa5801b2f2329ded790bfb3109d6bce856bb1edad63db9427fedacb40971d5ea18e3b23687c4750b59f193eb7bb2540538e45c26372a0ee05757defc1ff1fae7661c9e23b5d5ca7a0215c4c2f1c31ba74cfa07d42ac6764fa3ed72c2460582fe7feea7a4fd5c7a33e622eb42b8516b745a8b059a034c31569837c4d21ab290d7b5536a96c7541d7cb2de41d25c68d608d8b3748e6eaf6b25f14b8623226bfd1a70ed180f8645a33ea970902ad9a73e24cdffee339379867a1de8843a5c9b945b309ef726271ce56eca41544cac24649f5eaacc95f23419097380dd4c4073511a95e9a4ec262445a732667e35700b7bf5092c08ec26247662063ff1477b507003198209c1acb9758dda787db2e9d18f4100c09ae120af28922102487540042f0ce9fb0e53c173b890f13afbef625d6acd50d35016c20bc7b767fb181bfbde98e746b86047bb5df4295a89af23f6bee459400fc9b07517df5e677b0127218c04b6119f3b3cf24f33466bbae481a1c751af43fb948be4fc2facc6f3a4c5737bf478bfd02b5eb1c4d5642531635be5eaa43ecbaea6876d13e255c60bbd11e22a87c6aeb04259e3dc964a27fd79f08ce25d9314aa189e7b3b5b52883ecb040ecf4b1eb6842c9ccf99144af4c2875bb525c55f5cfb07028869450a28bea2edd8cd7f089f65ac71968a42b63404a95d50780ea77a88f96365dad235b31348136a3810d0f6ec9c9b123a89dc9e9fd4c00c4c300110a2b309644f90ce7ff1497b15cde74a478565652aa719b9badb91957d4064ef34d26c6dbf8767afd77961258652992782d0d10436d0f8a05e6a707853f9de7760faf8e2dcf2b4d85b7590380c6f52dece6daa9105737508b8acbddc2eec9e8e3866ce4790bdc13a4970c9476c8caf8be354270d41900a32ddd255c46b63d1c10de4a7508722753ae39e286d516b13ed1432afd48c92567bb8f55417f57561346736ef8e6b225e97baa607abba8c41539ba16270f3ad3641e73d64f7d2332c69affad6323a17cf2c4cd731d857223f9da101a577e881fcdbe6145d471c98abfe14e732675f6d7b7116d69ee03bc9f67d33507ee30e19af0a5660184515c5e5bcdc511e2dfe55d4c9d0a8abbce07faab09fc5fc1d7771604edaf81539c84f397f1cd0fc1a50c9895994d2eededf31248df62623e8c2b9e0b289360a3daf3f192144e29636bbb01ba81daceba49c5528d286f80f34ef546e9d8858a0a5644585e1442a171b7b6c5925a7c32d83f83990d7ef4119ff667bfd4d25d1edb949aa0efc139af8f689c66e51e671ca38839ff56203df448407b47d1be440f13f80dcf5a3c282bcb755f0a36cd8c6db57426d5293937a4f5dc5b1731759694362527b7238c729c49fd8c6a849478489eae8e00bbb0066a9ca50cebf7730b813536039fa066870a15de2f01011de4c499064eb2c6776342558740c863bd613e6ad562c68e038a59480eb9f11569be48622d13eacf9d283113b81a202a9919be4ed7d4b1a7613df246e57cf2690f6799726752d5b4f7e9e5e92a0aaf9b0ed91a50dda4e51db532f0554e39829d06b40bf3353bea1182d633c7f25bc921a79b6634edc91c007fa4034aec7effba5790077dc5018d6ed0bafe316ed1e913dd9cc6669b1ee95bbc839f05cfafc216d81289c3c74d50ba254e93fe2ceea6e3c79c8e8dcfc16bbe22824fcd87397a7acd6da0cbedf940a8d3c54795bbedf0e6dd5abc0cc6d2ce6ea628a6bc652c7dfb5cf3b9542a9dbafa0a86da01c36e5468e9ebf829ae4b1a0e0af4c22d43ac07dc5e2b4c11f3ac35faa1a306a131b1521739bcb2c4eb3632f4b794d49b0059152d74f42399778fb8fb81415526c2af216565a0ab83d684df53c34e0e07e59362cbc54e6aa1f0680c7c80e1bb911c2b8ab5db59216f833158ea36b258093806060789fce68e1ae276ca6a36238ef222355ecd5555f969e055ca786521d3982cd289f82ab5b6e91e0ddc1aff90f79b24a0a150c105eb7194e9281bd1fd1f7af82b5b402148097c12b8f125fadb3f352c2282bfb18b80bdfa7fa36a241730ed6e40dac559b304c5f51c8ee692d982806a98e86123371bea2ffdc0fa1acadcb69313894a05ba51b24e5493141f7b20de918488bcfbcf4d75d83cf5e7e80205b3faafa1eecad73aee812c3bca706f5c87d60f4d885085cf8084bf39e4b20a72732190996afc3d7b28ea74ad88e93d6ddc29168494cdb946554a3f3461cc2bc37bab581fb77ef7edf60826a485bfd8b8a211b118cdf9cf15591766fd2ea4cdb86ae6dd828d84957c9df6514e55165abacdcffba7fb4462cf78a23740d5aaed350b04edd4526db91d9be0fe1e47465b621ef3df60e917ef7264655391d98e21f8922d58b966442dba8dfa2a82a5f334cd50d8e03104a94fce098a07079169fb6ffc4847fd49ff5ee638329ba745e8cdd851e7b103f196dc5d9ee9f2b5ebdcc9f1725a4b3d80d17d9ee6dd517bdbbf4190a23037ebf5ff3ff20170fe862a6a40cdb8fdae8b0c4a0a997e6e63bde56073c0b52634ec1128664fc8518d4149c3e71c213e41bf34134aae655c42df61596382c8dac5bee6aafb9ef7e4c885a7dc9fb67de154fed0c6f5bff673bd7841132334fdf12d3e1ba806ec0288b10e5e764a279cca55c2749d1360efeb518f76b2db1ba3458224b4acb5e7ef6257a4b45027b14ad0e2e342079cc739b90d7a8144a5f32be4f8308d856f1eab91be1948c07dc71947a091a6b9b7277ed52a3ffadf4ae8cf031b1dfbb712f0a8682390bff1d48b6815ae55a8e4af41baa38870849023dbde5a2c36ba37afd88845261eec3caecb32cffe1925ab744fbba66d402773193a5fdbb0c7c7cb77361353f02c1c56f87100c90db92b269141071a53f0465cfb7f58d49cd0cb798aa523f977cf5ffe7455a5b4715e0eb0dbb4a4ee0afbc66316f19213b7b3eef1fb3e7c6342b5cd940ce727d882f64bc6c850454e2ce68edb24efa9202f3df40f0b6d16e39e7159c836bbca799fe1fa35b6215dedf1feceda5c8b8f3097ea800a1883c181bb2f20043ebb2db2520e1c3a280b3b4ad7716278cf2d96c45fb1c7854b14318067ef7ad8052e1111589295cc56acf82452b0b05918b42bd54499d1a1bc7d0074a1ec23dac7a9c8429d429b72a36b57c77913c0cc151b47857e3d9a125f575efde065d3336683d46972d2ed9c716c79ec6abc6679000767cf877186757a020d2d083aa508eaa879232b951ba5ff7be66647e263da8adc4d7f9e350fe409efcfcb865f3d4b002312b9deabda55a3604ecc28bca85f35d337313779ef0b1e70742a5e0bf9c84a0eac938faef24c20906e0a2015669ccd80d034aac5f310841cc95b02c15930e56a11aeba79d541b3ca9c78b8eafc3020bbb56a56383dfa9d2d44230dd63db6d540665a0f07bbc8ccb57b48d5c245f455488a3f962ab2c9e7e8ab036163a5e34cb8ada62ad4227a65de82551fcbb82260d2ac2d30215955db2abd98f6e270fbf716ec6b748da1affb91ece49b57c8d2031c51c6a379c3d4eeee90ee849186d323af5a469d4c23abf408774487d1b24d089fc86de62de1c72ffe0d6d37f13b2eb162573bf89fcfdb354c02963cd77596491492a6dae141b72ec3c3d406b6d8ee3c52686161fb99b1c56668045d77d9394b4f057e165dff05206285fddeeac8561bb44f9c5e44a2d3c1204698d217e1217b68cbe3814533c32cd169b4f62d7e598cc601c7748d78fdf38464bd2d0db1031fc7538c8c6c6274e00149b128cdae2a1264c773329073e3c7d73a514e8b531a3831e5157e24b2b65860f1826266ecaa2a2c6549ebd52ad0c0b78aaf1982f998d6b216b5e0a6de02dbb662664a9d37f5346dab8ab95d57d9d5509c6e58a3c0f3935ff7cd6edd6bfa56b94c5583a157a312310423606b9d6a8177861b126476eaec6c56947cbc29eac7b8936da9945acdd74fa5122c1079f8cf8224a82132984f60d9fca479f04e2a32de34f2ec2531e16582eb788fc62f4d8637a889c10340995cee76fb766f0e2b5e98ba1e704025906322cc6293c212b6d78e2f67b3528fe7e1ec3507358bdb5433f1f87aacbda99c2642dbfcfd856e9ec66957d1a4e8fc127165b0d606ca4ff0b3618752772dea0dbb2b4f104ca71a8064f62a9ff4b068868126653449bf9c1b2b4887595b9dc189f3e9b033b9260388b3df5fa8cdbb367a4f7e3a49ffd013fd3cbf0fff62af2bf212e79a51a1a50c140b088cbb7c2ea2a08cb11d3cdd506f5b15342e97cd3b71fc2f0a8c8f3872adaab00a57d1428d396103dfaa78e13db35ac9d67883451b3595ccf2213732a04743fd2c56fdc52ba6497912e88a91a3f30cdbccbf7325e399593d336c4ed9a0df848227b43d44821cfc2c618840d603362db4921314997835a1c7fb11d5817a6b176c7a34b61dd75c24f2f1e912f7daf148eda2a21d88bfee7874ad0e8f86446727f979a52faf0574ab44c9908d6f896d9460ea2ddebb234b64eec766b74a0bf3442d115635a96d6130d2bfcbe8e3dd8ebb12e4ad381f55d9bc7f0978826bd72963651009d8a28d5bded2da6d60dce13d8a40ffe94385a6dddfd2841c1a197172dc0d947b2914283dd2d114808c7ad32b34d417f4764ad6667061be3c48e97e9c90520d6d368304d5e383f2b1ecf953b30fa490f6378c0d775e6e7ac97bbbc93b46750ceeb73c6987d5d52b9457a0d8b9b81e6d51869c7153feeece0e3e757a7b350cc203c54c88cec25f13dc704c8e8bc10e12f006b3554edc06dca555f71fc7136991a6852819632889848881d4ee24cb6c9ee2af8383fb0adc6b0c487e58dd20a536a198844703985cdc1ac58642271766eea3b7fb4ea3ba7d895747f64ac33f54b834af975b26ed06fee4e0d5b99ec3fee564da4f06b83fc4a8971dcb2354f4d525725098999ae99bb5042dd7e48e85cc8c73a5ec5c4a849c6001170a0f1bacd867c2b0343146a62c2dce6dd4095ceaf8f6de9bc15528b5c9cb9279873765e9f0625b3230aeb395df31a39c8dfbb3ffe45516fe251318182fe8b176deda65e95b80f124e13a0ddf9673697a300b80d901b8250349fa262188864b6fd1e453452449cd2c67c0671cb301731fd197e5489367cb225b322f43f559663e32e82c8d951d4520cc79318918221c1cfd5cb9ad1a588a419f72ea73564a0e07d9185fec63726ae15f643ebcb29952b0bb29e65c34102e9f3c8d884e7569bb325b690ddc6440259575aefa85d04832a09e3b4f911521c9f2d9b80f2a9684424f782c1b1835063bc2c6cff34446991f018cc893f0479d1a76cb5ed73318d49f2f3c89d2e1e4390ffc6ec586702cd4290edbdcfc6c0e17089809457e9e0fff6c7958bff04a8ea5a655b97f029097672edaf5f57906b663e20cecefdc702d04bbbd6832a6ffa874c2cd565624d5764a8d787f0da313b2f4a682475c4017f5905b7dd5905f5e5663c7341fc1f2be00b0d840acbdbf091646395755f56fd00fa47c9965a5c57342d97289f6cf6f32fef55b97bbfca9a55437c415b2f95aca42f827a195a95d2f2ca9c26261649c02083d3aec6be788945f356309cfb9f9ef9f9cd810f6eb0bd3b872aa6cbb695d224c43ccec90dc7f6e98e885abfe9efe49f8798d4fcb2fb545f2aa4d20e05dfcdcc276835afa941a88430aba5ba8fbcdfe922c13b8d5d76f5f1cf815c776599557507cde08c466a441636c0f21c008d2f22ee0b178fb74a6400c326dc120c9918bc47c27fcf0eac8dfe03bfb79acc882464d4f64d5d97083c484d6267bfa8da3e172f4d0e2efd115bded84f4a7db9f33ce9123bf878dc7b2b972bf6676d71474e26b396eb9cd482f8dd25c003ff423e460b2c0c802763e3c85e57f4f40975097a7ec0d97542fd5be858146cbf19587206fffe642136ee8726eb039403e74ecba182c6f0e354291fa0e1e620cb787bdf3fcaae30d678ee238b486fa5bc24348f23153441c883d6454869a5e6e0cf3e7aaf8efca065e5c5b825597a2b1e01d4ce40a343e6e0c3ea5a1a9eaaff6b5196d9365446bf54fef0bf6033696d3514c8269a54543c407741cfcde62906d8a60d1271b53a8175f4e7c336e91310c6b86fb6a8fd021ecba597fec57e9a5e57c795aac9f18c54314cf8f5c17a2a04c13123e88c9a8d840d01882e62551614a2e23aa786e73950e9bbba5a07f01e5d71d5ad86d0d5537c94cf9ce6454a3e6f64209188e886c032b931e3b8e678018d542e2c9c5d0d979a4e7dbe6579cc90d7ba449c55f9af660834e6fa4e8cf303cc9329eb1049ee7052e31e350cace2d89c0f5658dc0cb17f6daba3f4afa4978acafb5a281242c9c1bc8c0353ce71cf06fc674f3f6c0a3ce6f1dbf753da9d49c0094474b917d8323550307df98798e79b6e9eb6fc200eb4403594eeaf179c99e3cd047c43c994993cc6b9f785be723c5e5e3b0b259ee35860476bf9efd590e48f8d442ba9ee987e936d546fcd1dfa53a4eb4f9afb08234f858e076f2dd75e33ce1625d12d583dff8740c4fe62f9073fab28d9621a8829f1db1e89ed1ccf57cdff4b4825f963e520d4e34b8eeb0edb99da39f604a9bec2f1c677ff8c8f6b4d30bd24eeaa224393ada7b55d51c36c806cad27b5b7d78a23822dabda3c066c44057c4cc583a05acb03fa24d3d23ee91d9490f5c12db55d6dc6bf7715d15d323b78b2df0b5e8a001a4ec88e54c5786cacd641b5ab104749efb7e783605238412fef282d809b875562c1ff350e8b605ca4656e6dec63acd80a1aac117e14d5e528d5f3ea25dfdd7c96eef969dbdd6b7657674a8275e79378727944547efc01837d028726ba5c5a475079b463cf89e20499a394fb5b872798763abe4ce7cd4aea12f6f32d2bebbeab80cfb8a1505ccbdd2cbee8a3150144f0f2c5ab91230b7f18d8e90319c7eb361c2f15a788f6b821d4ca03e1f0c464878f44384cf27b71ddb274c3abc8b1e02c3ccd0daf72dda6fddd0c7ffb9c0cda27afdf344d55bfd3407d83bf4558f2e620478aae19413c80c56f15fe80b8bf3d0ee4764d873e769b99c495e6d8efbfca16d52dc5c72c4ef33362dab42c85ddc465ad2bc4970b2301f22ce7c78efddaa20ab3cf47b91494392d853b111ae9278c1a5eebd560e708b35ebad3101dc9e5154d13918cf15bca817f5b0606cb109b0ea2e79a8199d7d8809c11b6d330043d471b0303987a726f54e653c6018c8f4083771d7a3bf5522008103762fb1825c3e8dcec7fd5423aeced2fe814848140536a840ce076053850da34af5dd15b408fb05e4cc54fd281123f4551bc6f13524c16ef16c522147f52bb3ccff2395dce9decdd9c616135cc6f310b34652c145ff925d2155b700ad5772214f67dd11a7f36eaac7fc277d5a748c2686145719c341c1974ff6a06308f9b45b9fe8380a34d901fc4e3df8061c647e6d118c1b5f5648f4bd2db189fc15ce34cf0826e78b2fea65ed4013865aa60832f55f8c323f27f73b6a9d78dfd526dabfdfb17f4183c809de5fa95cf1a57d0493bd37b1dd5ddaaaa89851c1931a708023cf0710cdeb65b814a85671062270f78cdc23c589f6d765a1d7b1a2796a78435d0c24f4eb08b250ed17fd956b5912aaaba7bc9b7ec8d6a7e50f32339f13a510e29890bb9310d4a45dd2ddddead888d8b20e837654f7ff6a41e706cc9c582ee239f116532f19de0925ac862f0018ff8098b5a548b82217bd9321d2713523b016236ec469381b1d25e31b50927a8f5af265c4eec46e2dc2b45407d0a0c602cc0375a3a80370ddb61338e875cc55abcbe11d9502b4023ed2b6f092ee109e5fcc2381e09a50f03a0ba77365eab56f5460072724127ed455adcaa4314945707cdbda856972ec6828ed70f30d71f9625557fc1a5a83fae35e522178a43070497e202a688019d6e5cc23c0d483f845772c8c05718b457f71413dc6f359613f51fc385e3a4b34fbb6b250094bddfd10bfddde9745adeacff93ed156034883f5bbf35c2f3b85558f6f9f97078eb8dc338e57160390dbf67a0d8b8d26da91fe819e95b4faf54789a0d5334ca82f784c6cdb2346ca558e8b0fe4945ec821fcacd3f75c5e980c8414b462f39f89dd0b68661b47ed2ae1d902c4776faf671d734b136efbf784f0f728325fee0ec8bb4303103344d56984693dbc7102c95458b43a58f4e5bbb2be380ae71822dad74c4ce77034911b6541f7da224913e831a054333dea0e314961eee1cfaf0118b179ca34a67f84cce28c409fe0d1171e670f46ef2735921f674d18801465c945c3bf19b07cefe49b53d88d7428bb0d9c40e3c6abac4b0b9d5445568db3647909fb9775844303ed4c72f96b4a20cf92917a6f430b86e86abb441eb6717d9e8d6e822519658a895be92f44ba44b7b27d5636540f83a8b461145bfebf06fa456df97a1e67d61cf57b10420ca440118161bf9152ccfbc5f5fe831789496ecac507f05190f626fe800c8512a910619b09f72e45696be55da90889b013f85d41ef33173bbc226e9c43f66d1018d85dc07f332354e68b563f3997fbf6c79124e13895f32f214689dd2ef23a22f28dc136a18470601d4699129dcd921aa5891dd3c2a7182ee955b025fcdc5db7364d2a0a0b9e82d5d7b1c4c1c318e57141e4e9ed3c834394fc0668c4aa51424cc2eca71049d9b86404fa819513299d1023cce4191deef65b7827d8c849f3894de10c55c0266930579d5fb2ab60eaba3911f1e264c504ee7ad8f6149fe6a078d3f38e9d7761447cdd3731290cb819e13de9445708682340dfedff936dc2d9d5b6fa267e88f00854dcba1964df883eedfeeee2f8655a645fa9b6033120478746e48fb6d74e8d81d8152505e7a581a687520d244caa47efb4f1efac95644700534ec1792c61fb5e02e180e31947fbece8a77a44ea2c7c377972aef5530c38af7b91837731d3a37eb1a510c36c45cd3792109794dd90ff5b3f09479edded41e4c3d33c9c299098f02f96d2f76addbc13cf48dd4da6ed01556ccad95e252931f8d18eb025a2480e37c320741ad9616931f98065fe763a3605b705fedcf6ff74e28c0d2e420b47ed5a42fef92592a101f0514dd55053978602f7b05a18c685cc4d6f0f9f87800d91d2b9efae16951b93b866861839779ca260edfd22c11332b3da9d3da51091653542fc4783f4fb431b18bb3260590b9666d738114965e1d8cce222e81aacf4cd6d622db6594a240f0d0b012f41357254895bab6fef16fae2a0f1224ac5b9c44b344c2146843f06d78d6808204108615ffb49a525c321575ed5b567a0ddd2e22ec8f745fcd6dad11da982bdb89d60f82104283adfa60a53ef656f0aa8eb7f45731e317370558ffc2eed4e268f928582095b4ab2b9b2db913cfbaaceea3084cd169d5e3f487e6d5a0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
