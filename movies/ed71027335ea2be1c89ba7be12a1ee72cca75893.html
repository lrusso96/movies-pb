<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9c3707c8996e07212ba939c936cf2f92325c7c8f1488bb50a483ea91c172de6b1b6150cda76158474625194bec87557ee6e960a3d9d9098c355c497be837b1492c29ad4afde3e6f1f5dc8e033e753283dd8ce96931e89b2c146188a3ad5a0d05b3fac0e57ee22eabb152e69750dbf77ba1108de3bb602bffdf6cb872fa033a129f7fc8ea3bf357344236de612a60a738d88777d043d8c53e36b13230d20e37337d4e4919a19e79bcbf46cb8edb66e27727f74c61809ebf7d8e499f97751130bf5488cd2c6cf4a5f22c5efb340b05fd3ed731a475e52c9277b622f5cf5367bd66e87a734b83b837dbd8b29df2c4d0730ef97ae7442ed060233340a43ad8dfcf48d0b113b73118e162e8aed7f7ff0c7bdd31427c5e03791dde54ee93278fba78d4b97db9b6cebd60577f3866ac2376ad9e5cdc7fc78bcb3bb2a3fbe24d1bde0ec7c72b3fb3249e247f05b540fb5cb003bfdb6f6eccfc97af6bb3e884a94cb00216b4274645746514187c91863beef9d1b56b00b495254792c72b398515e7e88f1fac97990691ea1f3d99f8201da1278619933e5b45fae7e526391527c9c054a445da5417877f5a249d8e490186bd24815e085b2f61d08a5b615f8fa02a486f6bb83c6a1065a8f756da066ae75f5b4e7990cbc40ae13cdb2be351cb209def5ccc9b5f456b1d0084bd68babd53a7da3de78d5dabf81c7fc71c516948148a35981a99923d18a6d3dfebc1e9d881e0eced6bd96a036972a2b8df6a980a8bd6075d7e9c5b814dd5e754028a50923b5a8567a7fb815bad0ef7b1511e97f6a55d785ee5468de9c71379ef440ca8ce85769a9669bd5edc5f891728a3bc3b0af64b5aa385cc7926a7230376d6aa0c64e20c18b878b3ead175f438baf04a34c2479d43e79903e4b2b5532ed947baf9108c99361e5c1c5b9b1d1f92847cabff05e5b7f19c05e8814d53b8b4b0b46856753c038aef6e3b4573e741f12f44d7798c44c641da849e049a59205e83b33fc8ce72844e7f07d6b65f164284c3f8985278df9f553b43d94afdf1b20a7d0b79a72db6ad8b12801050b39228a2ea3b79be2fddc09b328e9e1172105e4a5041660dc9fb9f0d8eeff5eadd55cb6eaca8b3e670d2861ecbd6c13c08861410890485fffb3d650d745798e92c957616b6b480d155291b1a03465923fa27f7fc68bea793713d2fe52a42961ee5c4eb92ba6f5a0cb47d3e4842ab095c5e699caa02a32e1a6cccda02210171266f9cfc25da3286fdb141fafac3dfef6dbd75493660c8ebd0e877b3dca0a19cd0f6adc77e51c279034b2179f50947a1fe74c4f8b773127a087ef23781ffb159896a7e9c7d21496108564e3e14acfef1a01460e749368ffaee400788230b7c29bd3bfd1994a6662bbd92e72ec74b0f19cc149bffbbfcfec0c04975b88d076fef973d36915bf19e7dd2138b69b97ca331058ce2373f05c98cc9ac757690a8f7af2fe419f499b42dad5c272ed451396a29e4857cc1612a74d34ff1c84bde5ec51008677f3b6a23c7801f9065a45bdf7ab5624a1d16c495d5da1e44a10e76a76b8eccb776f95b072ff24d56ca25d1008e1e35c7381db9fead6b13d3736a7e25f775473f41ee3fcf4a18c4627d67e84d41d48b9a9b8859d84b2ffc3aab283af94ee922b86cbf133f6320f890d9378e88c2f484ec70415a567dd259820591d0952a42d10a955d6cc93c2217e8c00ab7247dd3b2b3906206bcf5522130934450f1715dfbb1b83fb00cc0dda562ec8edb293d42026c6dcea9fa33ce300381ef52e76b22b39342f0628ef1afab82e5e279b5cb4a7935f0ceee2cde61e2a2fd9ab569617d941bb7ae816c9d6e718270918ed3a83c2ae90323015e0d848378706370df391e520048151697c8449045f0b6b69a47b22d70f90f9ff2fe7484e5d482f58069a5074eab520a40023c55942fec66df7b55be812bfa079f438bb5d9b7d3c8b47c667c089a16b2ca85a231bec5fb6caa80f4ad2129211bb4716b83ffca427d1f732ef43cb9b1b7a5c6bf29853cd63c7b114f28743054dcf369baaff93b92bb4faeb387e21dcc3e26eb8b9baf7ed825016d7061080e465e9b608afbcf47692e0d127ad12fcc95730c18314c7c4e7699cf6dca771db3e2da72349d852cbdc33a619cae515209afb8374fa6683364f21e1d10c271a2143ffec7907122b74465f9ba8f23470e48b200c4416dbb7d991c5ac52e20c2fa5e99a187f6614830a24963878f68c781c217f179e643bc8e6e8a30bba3100109e580699b524c0262895d163225acf4c369ff6ad1dfa41366d5638ae7737fc0c327dec8913f7fe02efd1db904c4b2af2296613f3ac164eb2803aea5cc82d2e62cb5b6c3eb7196ff71bd4381f905c54235ec446ebbc4e8462a8e89807d5c19757bdcb1245f6af5878ef441ed54a195af601eb7f7ebb01ed6fe003ea0cc33a0e69684ab7cebdf225dbd78bf0e8adbd4a57231b91354a8991932c1e8f964d877c75fae227c2e4d7fdf5f77ab50ff6cffb3e409d7d0e473d83358ca90b0ca1c16c5fdfa925fcef11516e97499d5d9d71414ebea56dc83b17d9dbad5880b5f330dba5be8165428ac23baca27c01edb4742b01ab2ea37aed0e5442cd39c50effcc933212b6cd617140c38a7f052e6c7c851be4c1f40b7a397993dc83a9bf99e8bbcb04dee577f9daf83ffb06d3ebb56299d15ff7f7cd2de6a3416d3018cc02e23b2c4a87371d5918f9c7dfd5f0cb912e7deba687b39748825a028fcddf03bb8d453e5edffc459cb45b94076d2b8b77eb49db260ad2b176ea509c255748ad80176b0902a56b9b65e71fe38b5c1ceca1aab34bb614020bda9b0e42bba7392384de1732e484f6d80ca3e35e58dcb89a1742f5ccd96b61f49859604986e9498e2c4c9c0c1f5c121cf6ef9dcadab11f2d829123a869e9d7fff0a4b28b5b277c9255b897a08a298928f4d41d3975b8e86fe36ffd22e5e1a57a6e058b46dec98907cf811aa5be8bf6530d4426dfbc95ed6dcff293094f9749307efbc86de5d8b8bad5206336ffbf46560dd5e34b9c08b9584a534a133f6b8d7065333e0f6d2732ca6f0ecc5a019d6617a7d671b01587f35462e25418c92f34ef68250c94c01ab3e08dcf69785fafad26254089db6312467392394609cc9e0abde312335f35986adee526b9244aafeeaf92b705e9df669e4fc9d59061b501245f8909c2497c85d487f4af8b93b2583161bd9c0367026bd2a3773bffc38d7f28e28b786fdd54dbd320662ed6729ac96fc9b08d2f72b57b82d2b8624d2bd192e08beb28d94655c2c953d9e37653c018dddec1404028ad9c15482a8a5de1bf6536312d2f213d87cbb884943046df60b6b54c259f51ed927f1204ff45b0f1b159fc1cbf9c3c44c98f76ca28aa49a496509dd82b4195b1c724b5348bc77797074e714d5554b81ffd121d5b6600fdecfabe8ec21e16e26b1075409fe394e21ac6ffd6dfb5ccbf33b1df72bb1f94639a98cb9142a369c80e1dc9195d234f806c3370be3aa64e0ab980aa4694a8df6597f2a672b052e88d6d2306d9595469fe213e1b8983a4f6b06d927fd1fe57af4ba24fa112e47788e1e2c4db8ab4db4ea236267ff346c65ff36049f16a8c07773ed0959ca2064b62659d6d70dc9daa817e01909b03e8b3278d33b12109af313ab3ce208187d8fdda751d7fd2cc9fd9bfc25268503616fa4a1d79f12faa34393e15a0d1fb099d7b54ed7d2287eee90c9f8a49f429dbf5a51b688ec512db3d522cd3806ca99f7bcd32414adb945504643b45fcd2a77940977593b738ef08a74d3ff854167f15d7e3264531dd201f8197012e01ae44c284dd6c8049d42882b7cc17cc8654f6c6fea08c6597cc5b9fa4c28a64a3cc938cb1682192f0c2f8b23e347725dfe09e83bf417f89b78b52f713419496c9659778bf9c636468eab171ed678a46c320b4c13ae4087d8cfdb2e38fd964a1700a5bec5c82be6a677cab52f3d7a0f5a531f00b33f88a95e83490ee93a26aa3a3cf90a097722f7b6cc120a04d429244fdec08a8e9065e981944b6a05e08c77089b13576ab614f73edd1a5f8117822eed23db57d69496d093cde69eb370423a9d6ba679b582967ddb908849c56a3b7533eb6f0c3db8a7d0ffcb74598a2fcb04a8242fb9ee8058c8f57a6ac8ffe2b9d3c42031d636e0d5503896969ccea51b2451c8ba5312cc114225c2ed65c76370962bceaf3a4babca914be1c2c15e0a9660e53e1fab19cb821ddf2a550537d416aad5a8a32b2b8b8db33ebba877d1d4c84a9f5f99576bb0bb9a1c9cb881dfc503920467e503e46fae04ab758c37ba4b6d761160d984a14a44a6087d0cc921de265aa2419e3f446080d0c600cda3e5d3e599bca150675a3fedfb9b8bb78884a287ad29d4abb3a410e202626aec1ab7ad1fc99fd1506c288581e2035d41eadbb05c1b6d550a3e605fcab3b7d5ceb998b893d40bad4af966432a119bb6600005c461eda466aa99ed33b5a7ce41f80168f24f8366222218c6cb3a659ce5806a88d6abee3323b5f238ff28370a995f62f4617fb8d586b4ca6fea9e75375c5a20205005392b54609d8897506a914aeb5a56a1a2b9d686f72969fc38a9309de244443ed299096c8ffccc9b4be9aa6b2fa30b173dbd5b828d00669b4d0bf8051a9c66545444601865542dc2f2c900138572a0ec841de89a6cb6eb0f2a2996c9db56e455294ebc74f55a57675b6e819de9bf19cccdf1665bcbac9c54ed1613c5f2a1f52d44cfd2bf52a0a185c6b8bbdc61b5cac94e552c5522d45ec15ac26e74281be4f464c15c6807f174a870dfe8cbd9d776610c502f99f9e837517e680916318c4429ede63b0c91282081a733f4027d60aef9a682da1f52e5712861a77b97b29c97ed591af62a3ecf3de7abf11c4f9b941b3ce4c4dc6280a10cc822bf220c87f94a0a2bad983d4f7266aefed16c914506acaafce9d05e07190e35ff4e3c95c83c191aa17d27648c801f3567bafb74f0de26e02088af29c5b903d82b6fcd3605fd67606daea3c0283b3962d0370ccb5b72f9f813f0e8d37953c4fdd6b829b3c1fb80096826b9cb815fdb7b67019b970143a0e8d2cefd206f290b384253436609e7b0ea5321ad780be0abe06cf6d74b2ab05689e363eec30ca36833d8bb1911cb46f1af8de1e174c50a4454c78b011f5fac8c37cd4095ed6b97ec3fd700a8585f591e64024e3391e2cb085da5986712772d899100923b6a48a574fcb87673c458ad2a01276cdac2d1c69021dd49d0226dff11a6b326312b8f771c0be41048cf0a171742539be7523546ddfdc33ef552376ebec8ce1004e0305d50920f4a3920f67b1d1871ad7dff1f76e91035a09d4424ce985e5334814779ddb0c6025a54096c26d358df0c04c267d097bc92c78f696a93ba2140c4a2e0ca0dfcc3f9477a81d6b2dcbc05403aee52f6d7a4df5cc2730caff22f11d9df0840776b6bbbc110c796da2b2939052d0829a6a37065038da32e3d2e4a99e2d6a5be5876019fd03f2abb1f6b87fc065684814fc904006fbe896568aff0bfe42d2785095ee93b9e350ffc5206be8a28e161b6e1fabdac7e96af02233babbfe84865b43e9a0f0dc2cb2f4df74e8461e1d27a2068e95ba1f0437ac8dfdb3665603a51248eba7e5ea1acabe5f3e0c02c7f673acbaa9e1fea9f640c7950470b5ae354743d8f9026cf11766e5cd062ec3c5329b2fb6468e2dc4ef213ae355f3f36949ad092c0fe356031bb2e78b1575721c01a21480abf53ebca7ec6843172dfee54449e03e7db8d204a6a01176bf6ecd4a7674cbb3607f125a79233fec880fc02afc8f49d63377825cc47628e76c10eb9033c501777e107bc26dcef50ef4f0cc3f6ebf772e13b09dfb3a743a390c4a1abfb03d03d9f4f836af3dfc9ad41ef31ac32d1a9583196ede6ef0569c902bda9615b5bb9b9375a4b5bb4e8772780b4468f06716f5537610ef886e3de682a599fc17a85c2c85315be555e3a733029aeb4e8d9e778411108abefc53df6bc3dede50763aa331991a72a9ccfac3c4ba273400a8431695c13dc1da6062f1cf290671609553a8c71fcb6abc2b46a6c26faeb4a65dc615aeb5b4942aa18e4a70eec1efc042a5b7051b7ae11a39ed32ff0fd00846d9f7272ea3782cd7574d106318b37dd2419ddc48d3885f946871af38bddcca53eb77a83a575398fca9a4e0dac0f5d710ae5313b4dad24ec4b3f2790f1eb0ff4c1db2d4608c028336851e5608e3700cc9720840fdf61aa4d0c495412684129bae5bc6ad1f67188d9da53387233f07cca81fc9365f41751f5cf9b7d89efb401fc8f91c5ee9c71d30f14e89a1cfae5c35c96814fe0e81bb14bfe7feaefe82677db0f7d091945cd159d6004df00ec7116254df528c1fe72a4b98f68bc3d4b3ff0cb93065ea8965a03e7aa2962c2b847b5bd5e1ec8c43597e16dc1e346a2dd1fa961c52d2c2d73fd8632c5749c6cb48fa9584f042bdf3debb99261a7777891db785d1fbd1e5b47361100c94c3f1f1393c4a2406135753fe48652e733dbb080948d306d65b762381f61c1677afc3723eade6e09a996c6da96451561e7c13e09dc76ea6278a52c54674f73004eb31b3e249eaf15f21106740e02f7f3fd3d3de719b48cbfc3847d73f1a74ec33bd54950e943d816cfd5367dc1e10f5c0177a9b5bbec23fcfc9bf5d34adfd8abcc7e5dd106b6f189b2857ebe89eee1809f21d955037a4b17f01516b5c8470e1cbd2bfb0685d69a9887a11713da210f5582a350d352aa18d63175a651441e1ced2dd57eb1279755cf918cc56cab86d0d77f69822e698f01fbbb724956086f7e150455571b1f65783a8b7ccd6d42088ed9a4c6381cc3f2427f48c461626d78d0d8cf22571b18d4c675fdbc8d601dcec0905dfc95e853fbc0741d38835ff69482832e9d46c28704b953e9d992c4219b7acbd20177d5eacb59121f0d95e7f7d60b44bb4315cf27d9280d3a0f493d15343115259c741c64193172ba222c324cf02d4502d73774d3f492a294ba407afc2ced674687b141e76d9872e4b89ea415f8dbfe163dad93211f1fb6c00f1f1f6f438e4069cdc8040db37300aeb4fa0108c9498d33761f3974a71daf6ac80cb4c52920f3a4ef2fc23d04d381339dff1c2159fc73781a0860c642cea8a8033d86df1ed8e832c0c3def4dd54cb16ecaed7ca01dc429375dbaab013e31346d56326a90da22c1fda009896df54cfd9c730e05bf71124dd76511ae2440503afabb64e610848f0ca730e9f7c5a72f91e1c902a8bf5ed6aff09c18fe0cead8cf07bfde14ac02e427c73dc142bd3a754ec1fae20cc3800dce7f606910a14566b002033fb8bd28fe421713e1315681b6090fecd599176afcb430e5629b436d0beac8b6733602cf2ad66a48944213be546832277e93f7b1b10782ae1a6e23864460b789371e483b6b7e55a181bf9e915f185bfb1070a2162aa25d94cf1fe34c678f0d1725f566001a20a919705a2eb8e6b96da15cd468c127cbe0bcbf213eb478cee9ce68201ff48263e0d6b245dbdfbf2657207819646052431b0331b0ca4b380288e6fe9e09a59061fa0540a366cd6dd4f96497da0e5d1822a075ce6a7c609b3dd16329ff31e71a9ac4bf91550b424d2b5725798b02c42a09c8000fdc0d91aeba4eb48253a9ab70f45dd500f029fa8849d8ca8c362300e05e451660aaac66a1ea656c9f09d800a4d7f9eaa5043cbc173341ce49b166d3ed48b364466b3d19ffe0fb076076d62ad0bd024a12f96dab7b235e0d0aea02d239587262742e50f797b1ce3d50d30ddebab849cb664a3f087041d7bcef82ae4ed79abf517d75ff38be910b7143bb47f9f2e18c88751aa6840863bcbb968d1b88b79eb3480b38eb6afa8b338ed567d91d6b10ea4fb1af1141cd5d1d321bd1a20ccb338f1e785103d4d6f0c6b0e1540f9ad98e58aca7b24e1f77ce577adec35e69d96a31a91842688f319f034d0face7d9384a1d0db22098d3a97bb940f2871d75538b3706ba229cb27a108f68bf115650b65e5f969b475bb48486f898940906927dfc1fc0a5095ef319e109d9de172a3c852c059e7347f621ea92a3c5d683e03a5e4e75cf967abdccc99d9e278adaedeef692fee364da7cd478e7b2a2793bc76a65b018f9323b274c83088d0bbf6c7170c3dcaecebfaa1a9ce94a2f82f10357fb969ad028fabb4af99f0398b834184b896df91ba09aceb6cb644ee3f36d384ac1b9f4fa72dd0819e71891c9e0ac21ce72715c3f3715f7aed60c33457a84fa20dcf5836c9e8166b839b73909d8234be32a584a85736e802cd75d39a21a4b33b2fc4704c871065e7dcc95dbdebdf785d27515e465e7d94587203162054a3acb4ed557846a33b6ecae690a8f6deec0b9a86188508823abf116261eed3e62b389068108d7058ebb0ee6eb51e4ae49d486a29ca5accdcf2f06e3a9d1e17cee8827e4fd15b8a02613427643e34fe3d1fcf9bb8a9f2cff21a6b4507fdddb732862f85489a8b0bf8b3097c865ce4dcdbb52d146318dc66cbd6096f0e2fd8005daadab6bcf5b86a439691f755feb09471a57288b6932a27b4cb65d6d98baca1ec1ab0f6ae7e81847e733d6359e04cffe305917531a9e3d8f32f11b2cb705ae0c9228cd7b1ec243198d932355753189f53ba8b6a5aa6537527de7ded17be663ddc67487a8cac9ba434effa7d381376c80af76cfa7a2650c82c4f999c9b0580453c98215e7376fc851d1ffcc34fd863175a790bcfcaca762d5f01c435836e68e84d0064dee36927de971e88a62686d6dd4c46b2f6b066c691856c2949319f33e8bfcc43f944b81399bf2f7c24b8a66fad9a09290ce9db2dff2475da5a9c21cb5ad4335141c05added4e08c5400856d5378285c416baa1cf70f9928360740d6d202e773dce9aa7b6cbc24461317a786010fdd71f1c639903b46cfe7924a19008922780bd6a53cb9de425e6c1fafdb9ce8565f166a4e2ab8c3f684fb59dedf896bda783eff96aef1344bb11b9ba26182ae690deb306336439d6169158f7c19699de2d1cda5cab460b530b421428e444701c37b53cf913c8344930345d9f7b4a18fbe8702583c470009994f6e8aaeb7e234cdab9b954396160b3ad2daacabc51b4808e987f595d59162de2a55ef29ec918c3cbb2c026e1f586d8b05c4e360ac3d15d44b140563e180321e8f3ec1953978e8d81e22a0e0badb43da0ed6853c4aafc7677e5a46d35ac4102f460c57cd3a0055344a3961c76995386e3da5fce4c464daacb41f5639c0e8e2efafaeab0704060e6d036fa2621b792d0ac9256e50de19b4d4bacd1b74eb9ffe3dca9beb4b575c2ef46149d355f34694f4e21b83d73813aa794b62a489fdf372aad1924d9a0241cfab06107c2567e0b857792990638d9d09b11e6822e8fb853c729241da179f2ae50eff8fb59482aeccade5771d4ee44f28cdb1ce0d34193d394fa7c25f04731b2d0e289d189e637a38d1c76ae7beffaaf8b4a63a2dfac8b2a84cbb31680b88a1cefd69dc77dc1c512a3485628c0a94f3151827d6e4c55af04b958c5ed68ec448455c5e34b188b506d13acd182e65e42eb1dd3d6679816ded20c1759b60fc03a5b6b714051715aa845171e51c1672e5dbc44ad88b8dca6605c293c2addff59f816cfdc67e566e2ea902477c635882f7bb852167934315258b04e1f57189765a88852fe2ae03c3e5057c439fd2399c88cdbc97223d46cdc0fae5e5d66a89297066962015675654b755dfd88913ae3b6786367b274b655ca8573b73ca3de9a3da315d6b1c0e8b3c6d6b1713f48839cf0f767ecdb709e20bb6901c5b83d2891dd36ff8cfc0538b20b31b8798fb33a453f8001aec1c5c023c072cab69e66a256d50547e8d5f446e7eeb26dca31c7d582fcb37a4cabc57af01fb004330a240924839e8dd438e975c081e77a3a2a4afad1099700161ef7cc315a19d731cf760a61044d22dbb36e650f667299ca6e8c94ce506a405336578324dee7507339c745e70b4db369fe571dde6575c0b484958b284c733d1bab0dc359eb11e50ed1893b4e75f98bef616e62627aa3cdfc7ee4b8551fe7351a871cbe0dd82b45c78cd6b6be7f8b3caf8428d3823e742aa765307266237c6a5da24cbc4cee620aae233ddadc1cfda313133882226ae5e956fc1f5780846be0730b6c1e5c3839cd5ae572fc5fc0fc6b2ede32dc8268c616f78df40132edaf72f4a89cb802e17e24e4e5627bb8cfcdb026970d02b3403ea3ae08eebf12d2ec37070c7c6c28b59a3bb6e9723cd50b07268245d84bdc704d7f63d347198cc7e9230b0b7501efdfcf7e0918149f420607ed4bad70d897515009af4d4dbea1948d6a36479b2873625b2ad3ea147800b5201b1f7726ed7c8b5a97f44a9b9190fd8d040845f453523873f7c51883f41e0ff74acdcf9651ae24262313a748728770caf1a4d58bf4e29bb64844438881ee7a9f3a1a89e61e08a983f6d6b11e48ab87cee61445eeca5bb97ed66fa688fb3c6a5692446747cbc3fb8ba34a8172446c9d8ad60d1c552a04d2315e762c0617322803075f5b1324d8ff305e3eaa07a20f6cf133ae8ab87cb10338ba052b6277ceb0cdb78e677648bde861c10034a23bef65387e10012ad3e50b56bcf47e0d2ff8a4931f9ce398fc3eb8ebc49904a32099fe3ac6131868e4d79ddd272ab23fd1d345251ecf150a766422bab8b16d4024121bac8b1d99cb77872f611e2047575b757be0549fadce0fa02e4d0b9fc76dbcb6b59abb34ddda770d950fb0a13f6e42519aa040169655204456d18ce38f761d15436ee5a5c5af5e18dd34cd6ca3e2f1c721f7c4b66762880b6aeeef92f37a923b3b6b73729de135775a2eead0b9d6c156826b0972eb8a82d5275c7bae3178c2be60c0569e5d187b2d9a2f94f0a23f44efd81361e5d886c6439dcf7dd6dcc46233f35ed41ff9882b7d56de997e8af185f1bd812da7472464a10456efe9649a8e0ba69cf3847e59d936c7cb36c6fe0de0b37a99b2403deb0dcd4f73843c18c32c91ffccaac29fa75a3b061a006a6c071092c80c83ccd1c654ebadccf74cd52573e37bb73545a585b7afe81d8e66bc59b7a10186849db94e8d409b23adb1f96764951f6cac278dde83a0775afd18b9f2fa44d420258b6fe4aa33012e6269820d9440dd08328fe7893f939cc115cc8f5d805461ab494e5c50c5807a66dbd1f2305f0859ac5f2ac8d9160581a29aedc0b74c362be6e4eaacd1d4a93963b442884588a33139e3779d6cb243ff6a9939dcd0f7878a201d6baff78938a6ac465e6b812d667ba6067e6c67e5ba2bdc7566b4b743fea5492c4b50b67c51d7cc35f18b09ce597f60ea9e8d04376fda81028caf5355fd36959e05a1bf556b93ba6a7e6b1d063c24d7d05a8647fc491a87ce120fae0aedf677cdc29fbb73a0ad56138629b31671d88ce73bcc724bb2cc9fc11a47fa35f9b1f93b7b7fffa5de8b98cc06d1d5a13514a7179753e65bdef9c035dbdc6706075a788a17e4382516aee19240a6757da9556fb9f1f151d898274aadae575cc59e4ee1d7471bca1d41470218aaa0ebfd5b186be2f08c5cf26fe9050a3431bbd91bfde143eb751489412a176fbfcaca6013598c4476894b8577330e9c187eb4b3ffd72db3af95e2f310ea5555afde6dd678a4c60feb5898c1ba1a40ea2276484e237a0f283e5808c5a2b294d9d2a5da930bcacf9e8719075706d6ebb042c56dbce72d7d3c6fdac62c86d5572257548f3d55ee21eec3d6c4e37a6c968b0cbe81c1ff514ffa2ead5771006e06c926d491c1076606ef80a327bb8a9ed73a5d54b48142273bdeead8004a14076e6b0245f6815ed13bac61c4e9f12d338785c873fab61e56d82237038fbcac1a30d1f0fbdb96ec53915d51267cce2204212be8878e9766086ed363727abfc53ed8005cee3ac07ec4c34b614405cb2f5fb9e3a321c4f15904e8bfcb3161c3fdb0c8e19a8df21df5c15dc2a70c8a23a7cba93f4b0c04c8ea75d903c2c901ae2d9457264140fca6e38bdba08e7305e4a68fc84f54425b7f7faf1ee8892982e2e25b9f2be9cb5b4027f22b6475fb1bd54bb70e1de5c46c985524295d7ed65c751895c01143daac0b3a7428e648d7957c6511f31696c8bdbfb0e9ca81de922e12e3fcb852b500dc2a554d8f04c07d8b1ba9f95c3801eb146e88e2d9b9610fbf4345bbd60478e958e7efe27c11a2c885116c1fbd601c7c3306bbad961d0285f1baefe8ec741aa91ea9e0c1526acd75e7937849f45487205d6a5d4b1f09fdb776c2c267d5360f431560a0aa930b2d3a1f0ffda1bb088bdd0240101a7d4a4781a105249a9a10f93cd0904571b7963d54eb6db4f64d9385677b26b95c64c8e739c193b262fb646ad6de2d2fa76340c6405eb9ea187d3b37e775192b237fbfb985c9a4ce24eb218d0918591b12772841f65072811a079a9049ff3d246b9a0fdf4d174d704ad90c40f5b8745ce64ebc432d7f1f6077dce470da3c993a85d0e3066bd5d8c41e0f3bd043080e77a2d0f97c619f7254c2ac9924594f019c81b77ce65f2fd6421b8edfe2e8add4f5c3ecb02667885aa26011663e342e1b88c4b35652aa9fce023c7b025537656737f683a57fce80e666eace527c208e8d6b093589453d951ac88ee36b29ef35cc4af275ea53aa0acb74163993e2decaf6d9692368b0767084e3a66458b91dbea42cf9fbb97155244b35db62dcc776406974f7a3e7f7fbfec667f4104c0aa9275110245a533927be6cc7fb01e262918eeafe228afb23d70deaaf199fd822cd432d8f81476dbfac6f4d58eabf90ef3f57f0e6c7d23011dfe5e106eb179a02a561a09b5147abdf83ab3bc7632ecc2aa1778c1bf2782e3d47821c656d9bb90b1ed9b4333617190e9302de4121a2c4c9a98f33eb5c7c0ffe85c50eadfdb07ba7d081f841e9c184b648","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
