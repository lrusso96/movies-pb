<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3295f7510c01bb384dd27f9474bb56f6327f257aa6a402c265127a7a150d83de8648dd130c66e7597bf12022d4a09da7ce7371db813f3856f5e4d56ab317c6b43e6916c60a300ab085644d5b34995baccd7c50d73d13cbe40adc52a6b34524a4ec87b65992a9abb90859e597e799b9240026a3cf90c9c79d3e6623a331226f3314e4f6dca010d547d8f1f27ea0eefc23a93b564b31410116525eea42388f8cea645297e176e5ec8c4c83f455b6c301be33f6c15c3ef19486b4d700a7cb9a7c7c7dd29b82360a1878bc2c3398c52e50260dd0b2de07f15b5b4fa7000c56eea1b1e7a84012ef600471d7128942871b49445e4d5819f4811904e69e2559dc465e82ce0342c89c67691b888d31d1c4d11b92941bb89ee67505bd1d77492c37a86d9881369e2499bfe45126a15b87287c91fee4ca13864fd897b13c82446bf3dd29803318947229b3e8911d5296612b7474a25004b97194f67d18ead78a02cfd125693ede0b4de0e168f063ba5f5435a8870910b8897bd2c51a46e545a6111e3803e4d436d505f0a3a27c9536d5a1c0daaf4a4e2c3b332b32374987074957f2920ffa2cd5e0c384989a69a42f3f666a9bba6928e497a4026384f1f720e674097fef69ef5dc8641dc3f70118d39a70deb6cebacef3b7ad170171752721c96a48c60b2f74d89fe81d44f65ad58267b5fa7b0934686c6fdf2a36c7d9b1809435c53769b27740921c4201496fa4d3348011592ed37dfe04d9951ff7e85e02de2fafb9597152c31fcfbf03670fdc60fe715240ec8c2f8edf545080455fe3e224b8bbd48f4570d0e76b25a56b2c0bcace693fd584d40ec8bbdc44d5dd5e070e56ae5b7526a9e7fc826a2b631f46fc999a95310242eed364462cd131f5a65135464946a97cb339df89044769c563db0ca1547c52707851b303d20e800d69b6f1cb778ba445fa5672d1be2bba8a53acda7f6beca176fbc303df06b870e917910fd7ee1e7a5e8f2adc2899bba78be101ccc0280cb638feac96659d0469c28b55796a41ce9c0cc21483c2667d27ca0a2f73e2c69883945101fe18aaaa2daabdbf4f89b11cbe2af394fcee25134e518aead308e455a258283e4e53995faafcb4d53d336ad87c798bfe0e23d89b85c0e4321a9c91ccbf658b226775d0dab43966fd962c7c76c060fab0c0852d333de143276b13b4f7e7868263ed2c0253f7baa9a03936b56a46faaf774a766b133506104633f249ccaa9d9c7fa723469314f9faed4fbd8a84269c0715a17efcbdaeb259509493727a79c4985433ec8923a42c828d4aea5103fe5e830babb81610bfc72f23c0feec95afd4f01c9a970d5dd12a0697b43e60930eef8dc7787afdc1404c7bc874c6b7a5572250753f0f8c38400677450894c66b887f4d24e356abc181e3f24bcc33417652a0dea222a4baa276768d4768bb77c5d0d92a579e9f1aaed0b5a46f669f8d1dc7d9691f4959c1f1f3d097f04693aab33999fb4db76157602b7f5cedbf0e2860292752c850d701afb4b0456a5b62794602f25b929eaf0b562c379fdf2a1af3f903fca8fc96924e3dda646592040307c9020d3f6a1c620e158369c08d77efd81fdead9f4fefff12f8d829afbfc73bf72d9d52b1a17d1dc3cd889a73e886c0a448179525354ee11749994214b75b17008391a49dc003b0a239204086a59ffc53813038fd042032852e5a1581b41cdd7e33b1bba1c9ee585d81e61031f8ca3ccafe74a1ea7cc51c775d4f63231d81e0763fe923e3034177c084c103ebd555feae6b3147a0fb169cc1437284041842d21fa379d479ae30e4ea0a068cbacd4e8b60adbaa5b50b02f1e28394e5d9042711ebb7a677e27f2808ccceb410dc9108cc48b8c33fbbffbccce781ebb8afb48923a8d3dce921d3e788735929ce88aac209e012560981cbd26b22e909af6b59e796ad1154d544bf55ff8f4b171de42ad9a0db7cf28ea57da91f53c79a99248af0d57448eff26e1866d2000e0fe9329ccfecdacb947d06a1d05db005e28fa72aeffe87587f5b48515e3f4bfc92637c07259814966e1fb19145e950c0618b35bb1260bb6704f4898c54f245cf80e32b9d86ea8b2410e8747a9bf59cc02140728bd6be349370a1a7b32a22302a4751849a3b3281f663b9f641a05e0fbb4be536a794729a849bea6b9a3efe32b6b2dd726dfe20192f014558463262024a9b720d46eb48c032edd154f62b9e142904c8075770a7cd17319a8f7ea64677fef14aae7c088f4dee6d01063b473ffc5c30dd92aa8c15ee23afa5bad2753f45d801d7e98acca61ddf9660e9cd30a44da4bf5e5e575d7bbe94d22749a5fa6f88a9524c7423a430d7298d302be6addc8b00145262163a3fe2484597adb1b0a30c7affd1ea972b6ad05e6c31b4067a4fec4f5eee5eec36bae5c7f840275af3b13ca7d8a948f0666d77285cb3c370752cd58430b3c1f81c8fc997ca35c5d4091c85fc78338d97d4d9a0ae3828a054834bd75a085e2e52fb8c7f36e1efdcefab13b7d573164c8f468085c08f2082e73b4302573074e99fe9efc92454d42ed83107c199001e3396850fc34ebf38a05c5e4fd96343904fc5a082491f85a291ef461273f3b055f15f0c16acd261446ddcd11857b9f825411bc53cecd4c13cb062513e0dafc170881d493234f65691cb9033d7763110403fab39f38b2314052f18cf3af391edca7cec2776dca8e9dbfc1874481dd943065925bebb66f6f3a330cd92033de6bc37ff0b6aa7e9cc71268ceaeb8593f3993f7a9b5ea97aae36431465bcc998b021fe5e3d2cff27fd0c57f4302a2aeba536e90704f21763843244f66eca699084de21703dbf526e2b3c963c2ee910782d07aa42ba7f2910d6c290fe18933bfde3a1ff2d7d8afc999ddb9875c7b03253971f24952a1fa56bd9470d6bfa6b75b6caf5daa2caf9cd094f45693decb8e561d567caeb11d1882d0895fccaa3463704c23aab304c5b7b421d686474836576470db444f8e3d5760a6ef2c61dc95dbd593a123bad9a5e848daceb901feaf8236633a2db4b51282f601bb82f9ee0bd9bc584d1e6955d19c8a7c0cd7ff25608b26210c752976b8ca1e96e02ec1e610ea39666e556630b0c7971864c7ac261a5ce5c5771caa77bf8eaf4533e0e68c451063183c0a021a30a19977f1c69245ca27767edf40bafea99d8e7914476976e170a7917ba11ce3b4e74cdf16643b64d090ea0130687c1eb9e61faf2745006a252a4199453538f03b2a9b7ec743ecdd2b86805e534ec2eb6ed0edf9163d9c2df0f300c00f62cbd84b3361b3d64c3aaddaeefe72baf42ebfda9efbead57eb99c840a7f476ca73322e6e23ff4dbd53877f127119210097663a9c3fba8f38a30c842ed18e9b26f20b121acde4736698744e06dd98764ec0021b4d10667f012575aae726e71c87fad1b5ed25530ae4b6a8117e4bfdefec0b8d722fdc5dfc6eec2b475c15970f3457b84893d967a344d547fa92b0cd24163ae190e9449300680287329d0052518581c74c1123c4c5140cbef7aef63c8dffa4791b8e6f570180f0dc6ba5fa5ef0161f18e8bb6ba8ccf35a76b517511530c575d48979551fd6bb3d3914d735fdc1721769f7e1bffc75dca5c7493b3fc9f76ebfc8ffaee99e8ff8397122a59bf0197f25c70a2472fc88ce24890bd713a5a8a4cffc7f0348eb22a16fa16b9359ddd5d35cbd37ec4ed3df90192680c1576f7a328a220f74cab6088d25d2283d482d2a69711453361de3550d26fea9c6a9bec25118bfd649e5b624c11052ded50e5b0fc168a3b0f6d997d1be2f18d4ea8ec27f16f0e51fe2f544b1418d3effd2faaa44e21010bb1095b1fec3ac1d96843cc2a2b6cf5e473c07d9605fc587e5200577445fa160b4c93848ffdca0d8bdaecaaa3f2db740cf9f408db64433f3f727cbcdcccaa46dc81a58fdd0feef6680f422e89be3328584b5a721117fdc3765755757ba740f0bb6a7d307909193528bc05a77bf3b0bb9a01f24359dbf164de4a97dacf828aa68f9126a485518e6144d9f14b7da26eac4fbe944dc4b5d9f32d207f88b0aec022feabf1e9ed8d6f258a58212cb2b0baa73b35d4dcdbcc6b5049a085cc692f45c9214f7fb62bd01dc14e1d21de423580908e0911b45ddbd3b91f579cf1195c1b73c80212807eef2a8ff2972f80576796ba8ee0a449e9016bd938bc3cc2f60d3a73773358a1cc55901cd81f07feaae532e57b5a5249f5cbf9b1fb3d223ed8213026ffaf5b826cf2ecf084b41d6f23f3fc4f159ff7420f91b2e3141aa5b54ac96d180779df07f15d16120f8c8a02b86f817f90c8bdaf0b648373bbeeff6538a19c56b1f1a4a0600768788847e67575dfbe6c1ac09d811494703938b2c01b89237d172155f74936e40f010c9ba310f7832a94e40234db8435276b0f5c82aa4b3399d13016163889249add86980dc3aea1f10d5775dd512fd110b9558297eafe4a809e6605843016d257f60510d9a384f5977d9547c2fcaaf295bfcfbf6785199c1b41e83b9d25420d5691cc7b26aa18f2304b7fb12a78e30d246bf17630bcc2c377200e432c0ad8a1b5c6b34b87e14592f463d5124a0765251044ee9f482b67be25abc8acba1d4d23a915e6c7f34c509d0450167d77947d10a0d4bc22e6ae52e530ec9db05364046d55e3978a6666e3f098e37640f5b1845b43f975e9f31385cb4a5b6e213d12b20f79b6b0f6ccc6fdbb7691f688eceae26ae566482c33eb34cb38c9274d240382e0bf8d710fd96c93122d030bfcf6a3ef2d82d8a220a17e56fe78ecb475370ffd5c1aa1125bbb6ead4cf3ec15f867489590e8478ed86fb1b1c311fa279546149bb687b5b68cd7f8d87d03aa4963f7560a83e35b7472bf54d21f6ec8b2b04df782774bc200911553262a5a21eecfd50a38e65dfbfe1bf093bbf4ab8872df4633d1fe22767ca7840e93f5483f371a9f3cdad9a2fab3babd7880f62c6fbe1f2810333712255fd45ff16c5d116f4dc42836f946c9d78886ee29509e261f7d23df69a2431726ccb8a50b366f1a1854da6566a90fa6ec91f85d6dc574b4a918a7478255104ed25fd97557f76cc71922c3276c4ef00b1257d4c9d0ad476a722251dd30f444b499688affbed6fbde0eb259102a1335ecef128bd3496df668db2d3aa8cc8aeaa32b1b1f54ec8b4b92d30b3afd49179274c46c0c3d1ae6205fcfdf3f53b6d79dad039a8688c7013718aa3e2d81ca066762e27909e58c7d91cfcd0ca4350c57d36ba0be2ebf3a0cb8171e32390a0f32ccb1831eb785f3df800b9d5f89f13a59ee371e84319de76904bd1ec151e00e7c05dd31964e1649aa69145eeb34d9190308cb6b1b1f89e1a3eb3919301faaa106bba441d68201ffeeb7fb44a4654e5e2adc6d58ec97b992f7c6667bc49732da73775c0bab42015f66ea6e9168b9c7441ed41f115ba0ee18b4db3317cf1f362404c7d3c0c38bac35244ebec0471628f1ad4922af7d0348a259335bcd71896bc631b1d460d3dfe1f3f596a7e54d8b6f802eba417074866a16763f567bc5fcf6b2efe5f930827898a46ab6580f43949e19879259b83648ff82753bdc52ed5b2f9e06bc34b17ab055dea6f35e87af75c00bd606abf602d62683401f0d3bf7449e68d3f0d00b179e48f5799dea09e1a9afa35a20caffe1a5b3ce7d7c40355a72982cd9a089b407b2750cd3f96f36e9cdfd8f07b57273d940e4d7368c9804f3106ec599207ea2d9c7aae8409d3106086f22a9dade76dedcb5d7c0cba01cc81402bc09586baea1171634da80abbda515f3d1aa27cacbc5a5f4a29df7c6e4b57900b9a6a13bab5c13241bd983d6c1ee7c17c3e344482d350fcdd2fea422cc348738fea32c948cd3e201540db092ab762a7ad90f0dba8ffa596ffb809e702720dc5503a249d0eedfa00ad42c81d7d44b372bfa4ad8dbeb4a24572378fc2144a601a69bdd263bcc40c9f28461fb98638c7386565aada58a0713387c6c009e337250b1d4d6903426d83c908240a169570eef6b44f7a996d8e3d8fa2d9137b8df855653d13a0cbe0c32a5cc9154b1d28b136a6c204d5f0fee3b0975192692fea8ac5348b0365611e61595a71776c6c9d61fab4a361a9205090dddba5c9f576ea23d2b4895f4b5abb39d40c92991f410a71de99966c9b8c223aec960bf12698a4f4c65dfe0a39c4d25c049885c341a16b8969abf943c279c2ad31266b09a173fd8cfd66178d345ad478cfc380be5522b952852adbb19f0186e3ad8f35b7ef4d7b3229fb6ecc5b68e56c0eeb8b6a5a426957cd317c2444a8a439826388608dc47fcf17ac038045f0867aa6cfd1ca468f78973faa88f62d35b05db5c529cbc09c8479a57e95ec2fe3444068d5a2e3d987a7ecb2888a71dcc905a44c828b526a040944881f96d714b0117d482a618e5f4a37a2abd30786e749256aaa11d0cf0eb501aecb4ffd8ba146de5980e271d8bbb40bfa33c3a8dcca384fa3537abb43f651e49544db7d9bff8bc6d4cf1b8c42075005faedd5a099993988729be0105f3714e87a2e4f909236b1446e7f5ea3db393205a27f9e91d99a8f439a61b5ea80ef199b211b5fb2e61ffe1ee1d0481827b0853ce5beb12021397291452f9fb8fd6cd2efeee60af57e0f7ae3ecea25db429b1c314d2aa858914f0fefd7b32178857457c3ff14d1b4678f8fa60a282d68f1caf0a3d8d82b3a929b6bffc2d59d7decfb21e8b2e26ed8bdf6b25c9d05094bb5f409789ec12fbfc43ca892c8f2ad85ac8f8c1e1ea90766aaba80fc20e30ab550c4467fe373478d8d903d46f56c125a4a59046815ee9f27e6f404868af17483877bcc4c40410d696ede5f7911cf8572570dd01104c5161a54154b9946cf64d493ef1065fc0f9e37c9a82989191bb02d64cbff99276b17d89fd5cc5cdc84211ce7f7ff5be26304af2794aa253608918d2ce397106940cd096e89e6cf16731be16d5390eccb517e1a2c85faea44d77e2e0ad51bb189a1b58f6624faba817806811d664adf847243c80dbe6012b3e3201d41c577c718d8b2df721e36b3b8e356feb89816b9c674626da4464997ba6d649f256ceab0cbab156d75fdfc4556a267a9f8b2282e0983e83546f4454f5fed0b86d62bc3c2b74d5ed563237f4de6479b383b604f410629b25570b50f179f68bbed38b1144a84ad516b62f624dfb77c192bbafca2cfbdb46dd4a103905ed6df6ed41bb6129e8190b2955109de38bd7dfa970ae51c653751d5dc53478586119872845086c612e4c3547b5cc8a483351c76308ced3ec6cd3a4b59f7af1b3d11bdcbb831cd19ff5bb09b7642debc2cc91ea7c83fb3802d573a1244330c0dae3e6b39b1d37c3c3addf142957951ab939372ac84880724504134ec86954c833a2b36ad056f4970cdd192b767a12334d15d005233faffbe60bf50ea0e5a6500c37385f98f32eaa32fbfc5e094cc6b23b7c83780bf338eb70ba221a0bb0f667e65be09a4e943f760ecbd13f4658096ff9d66522066c293607645bb52188cdd53faa6b9d47b702e3e8e7286a4e8a3f9c91e51c4aaf1a0a82d59a09544f347192b2b4aea545e59aee868f3695c48819c291daef4ab2db32d1d96c9457c203b0b57f77d87522b75cacc5e64ba6d0e7384cc207fad3d480b94ef5a4ee29e77ac147a2f43980665e273cccf0c212b3d0754d4436e11858f19c989b42cf42a623b13069c2562a8d0e50f25241f917475b5b02f73c25cf6481ee2519c4b7f18e2e5814dc589f12e3dc497a2c3eee9b4468da0fb65308013c88b54570fc45ead5ff6914636f7804e9efcf45d4f031b9cc6b5ed1c576bac3ee454d67e963e024d28a9e77bfb2a29f8e6e164ab600feed26dd88a88a460c145e70c4561eb0049eb246a91c4eeb5a63d37c055fc3d6bbb4db77601139e41a5f1bcff8a6200ab125ec71a3bd8c999849fd5f6df20c344c59cbe2ba1c3fffd417185f1124e3cf7fbf8e1dfd023ae0381884ac39ea843fe34f859cddf3e051ff2ba4d948e672073d00c6cb9c6767489ad09d199f9903861fffb7ede14504cd4ae92b131ea8bef89cb41acedf5af95802d7ccbc0c00f72e4c7d4804184dc846f335cb2335c8c25e328731941a4dd29c14ee3b08ab7b66857fa1f20bafb1c1226f3b40259a89ff41182df9db9a836536452000d686107ad576ac45a93ed30e9abd9318b127f0fa954470d35101897d5e38968a6e6d272c35dd9cdcdfc8e9c71a86ae2a19110b0c325880dce8e10e23088afd02399155d281f42eca93f3a26de845f1d5f8e1337f9338e5f20e2328f39e41c999c2fd7feadd730d1fcea4a0f6970a2bb456ada24d1d73a1acf68aba812f0b805f61977c205403d4a39f5130d4f9c2753ce20097e813f21a4db37cb99af189e2667c331f297f43efc2f9ff95f32a030a3263d8e890512eaf2b5d23b8f31468dc5318cdb003e4e04ea6138114bf7cb6fbe20769865227487ae193272d1dfa609f8febe4deffef77d2f7cdab907546a3021810fa2022f63dc6357c6b775a4a94cdd4de394f911570c41e20bc4a88cc53a30b001700da00c6c20aafde9464fae651bf2d5c24d36ae1bfa2c03d22f7bad94c9872b64c62d27165ed1851aa94cbe66ac7b50e684ed4697aeeac4a6d3b6322ec52ce7ce63f2bacf881b646305c90cbd73707963e547682244956beb8350e3b8d3c0bf7f181515923c17b43a0daa8c74a1b326555c9194511c2af27d6118221e0044093dc0851415f33b053ec7f902bf6e5590021c33179024490c5c7e226ce090acc5159829f37b62b79d497a1b5157b693a6da12f65cb680ea30ea7ff0c50d24bd912061ef003335b73ad80240aca804e838bd7fcfbcae160a22b1b65393ae9d9eca6448d4e50ea0256fb8b1fe78161eeca65aad8e41462f3dc1cc5adfb8220f0833e3ce047d56fc73cf3f4fa5594ce146b7986ff476958d9de8c056953734917d3befbe51b8efc13933b0c1b1fd44f525b7062859fd195ca80d472cbd0cf616372bd65c0753f9600ba8c2f954a93601889f5090e8d4bacbe5ec378368b9e39fb68e5fcbc88d9c580074e9ae8942b3d6beee154d15662d412a21e2c12c614c36bdae49f47987a388859228beb768fccf9f5b379d135609278a487a46f520980cb16a4345cbe0ee4ee4d88b1c42ed966f1de6497601915734692ef4640a1c61ebd213ab183782ebbbe6040429c116264a8a42f17b4427fb8f0a7ede453b8d461670f660e4ad025af94af6127174a987bea9e0e1340929434bead66b8132d2a1c860a085f92fdfdb507127a0c4aab60dca1ad65c8d34b9c5646a0e50ac60116dc0609cb09ed61fc88bfe8217fa1e0415d9d4a9dd96cbff53acc91ee4a6b283843e6148fb05685db77d40aedf43f50f6fe071175bae797ad2c6d2dd1165590aaab4c7a18a76fc65e021ba382055968083292035f05c3b968bc057a07acf1d48841c438c33555ca8a101a02e46cac1871f1b357fc64339f2692b10e0f52ccfc526f0164d4e772de5d13a4a06a48fa2752d8af09bfa350efdc2b114421e5c14faafe6e978923b27bbc851c178580d809de4768ef5a3c2a8d63f08e1b50231cd483efbff29528b63b8cb26c1fdef932dd83e961276bab7c828cce30fef9995b7bcf7533a4b8e1cb4b1247accde52b6462d9eb358f9e892593026df4d3a09de6046872670e2cdf049608bb75eeb60f93ece79e47aaebeb389c581a61ca9ea454f4b57350e7f970b452ca28ac5a5ad95216b8f7c256a245c14764916cb038371c7074c798c8819e0f38af67acf810eafb12a5cf17806a18013a9738081766e274a2599ddfcfdd037b42182b05abe192e8a1cc71e6b69535499bf7be9c51ed055e8cd6bf9df16e68fad5d8de362b68256d8aae2f4e86396d1feab361947a0d505c4a1e57153cce5615031b38b53484a5eed3377ac2a1ff7e03096dfcf57f68b900108cc9a9855b4c2af4c61abc9c492a2942d73f5aed333c2caf0c1f47a05c7f5e5b0e74119a29a120fb49be166c121a79707077bbb2a353f1d8ced4ab4f999028a9762c91f7a3831bd28a692f2c35a2216b8de4c9ee0fabffcde99469f52c5096b63b0c4b85af2b40959487da362b0b4f2ce9e4813e86d0729d1323d0ea970ed013be8e0b91f5bb1e847b48372636d90096843831686cdde7c0fe2afd89c823dd3c538dab2f962f830c21b9ffe8f16e753140bbe4e447809a3ddb658a7f736a6aa61d7936b6b08652e4ac4194855001408a466eda0289230d94e61998ee640686da114e70cc428811a9ea173dadacc51abcb46cf63dc25b6e949b196534616f26b564c4315afe884f2353ac8f20d787e748b5a777b4f8234e1e4b562fc58d30a87464d95da021381d594fce5698343741d65b7ea043d93411d18d78c60f2c2942668640b06aba67b1325857668990afd1c1c600fdb621c36e4179d24ee41f4da4a51a7eb7f51f6410e20a42aac1d03d2a33cf1971ac3961940433db9d85e1a3eb543399759ba60beeb5250cb5b6e148b249d487aafced82201dffcac5326067a8fde9ffadda4ea04c3a642dca09c69a940018e86c69e582297122ed6e552495e4b13ed34a326ec28d0936841c214d321dfc5cbaebd5788e843993dbd35cee38ed3cff1c5b716c69b74066780312fde0c7191696624a10655443e0f78021fe2dd332fe61988aadf56e606d20c9030307ecf93f16659a069af4d727d9bba5b3a5112284fe8ab6935fdf527276db51b9450fbfa6e1b24cf7849d41d0f766325156469192cb4afdf577f5f546e3fa804dbc55e27c6e6f50cbdc708bf8f9ddd745b0ce6e4a04a564a8b0fafd6cfd4e566cebbb7b26df32f64a5cf6bd4ed74f8e9eeeab3cc9dfb7c0f72c738d52257e1e8429187db57a2adf3b722b0b6d4390a0757969e5a996ba585053e74ab7774ec92e3fc2923da35c5dff05c1b1930980a857fdd154c278ff39733a315604259dbe310049079986f6882dcf57938aa881986654044daa9de5115b802fc26d45e79a597c19339b176576df665aabab17085c2e01740076877fc70c2e58275c9b8323f32c28ea4005cd6fb4dac7688a04820301365d29f6209bff3bb6b09b4711670ee5ca0ab6e59dfa78f340509f416227a61a44d01468bc56f01b53b75d009459698ded08f0534b8f9701beb046bd878e709af325d4fc3c61078d69114544b6ef67803909205e186c2f4a73fc778d3d052ca0f57c1c63a428d4a44e2e8e7a926de73554322d035ccb43fc6146e122f180242023f1aa414c22e7e98e7fdba4648653aa03e17ad7df5134c2840e8aaa1acda7be28ee4511cdf725c8d29ae244bf4091de255ed8856d410be5b247d06a5ccaa5484df4c982ecb4982484c1c0b3d52473726cc557cbfb0af5ae23e4e81b3a6beb7d2e8fc710fff2db15656b82927221c733b50c672cddb3e9109e34384cc88e6ba58870af2512a92f735602475d6af49c34e5e608cd01051a41d8dc414b3d62cd4b5562d73cf423083cafe7547ce7e9a07106f50ff53a56256279ecf5f9fed254ca5d03a49984439db2a33d59888eb5ab79429d322184cc87d476a5dfd80104363a54e17ed33b0ae32893247c773cd004d98f8d3148597c426bd483deaad18823fbb84d1978c4e18feefc832f40d9ab231d1cf9cefe57d0b78751d0273e0abf3579d4a5734b608e763d3804e77ee4643a8880d248c7fbeaad9784cbaca715790ef7eed2760205a9ed6e9d0d7c72f8131cff47232a9c43d701ddee2017d5e81ab96e14a885c8b531ee76373cc0aa3f0bda6537c430206dc9cee24d856e603e754969d72a935becbaee5a6d737e4f60012710eb062222156293ce00c3b086275f1e927be7d64908495797a59e5c3f489e7942af470f8ef1526346774c136833831a4c90e90123c3d024c7caf6305fa177a003cd856385672e31ae3b7d857796465a0724f3a8df546803cac20d10a54540ab93e3282ce7ef5593f2597abf86e375f9a3284bb2e81eaad43a3e2cf474c03770fc42bbeb85fb2d4b44f30c31ff99f331b7527c514b466eb9aef2411dc84bf19702099f922c05bbb7a44b9bb3d2f73350c4599a7a25f8054fbe6c47b8ca8a3f55d61bc085e5fd4d212bf7c4dd0cf14ff972e90494b0bec380416b54c53da6dc5f3a02df1f8675ee40996a5b1aaa21a85bbe04e1a99ae916ca1b641d2d8c7b887c93df14e1540b2cb6b436ae99f3d23ae4c2520d4238b531d30dcf17f3ddfe11e73350c88b7ae8074ab36c744eacb69e2e91f5ef4d0c0fa88facf4c4b0205bf6faa306a3b2be349c85ed696afbc4d37ad9a9bbe10808376703cb84c9ae2f896a9aa712cc712cef4e338f7452058633ef8da3f6cffb336990d4d85f5655f61d9646c9ebaef7cb2fdf01cca2f65d09235aca183cb768c0ee3f110a1728e8b1d6eed52cd81fc4785df570ba569a4a527e7d8d9b14fa766fa61877caec918908eee61f5128578b973101c997adc40f0cc106fba61e18f2bd6fad2dcdf0172242cfbb77e7a026a89ac353ecc00e9a4a060940068b787b93b675881dece9ce52dae8c88514d39d4ff3b891075f5be7bcd011e76bcd5681890e10e6475bf9f0a543d641685be6ac64c629182ef8ba8331ae058e3e4537067bae2c982cd3146f59463a1459a4949e8997d8feb1a41590d9c1ad075451e2068ca02d635d321d1b365b55e324ccc2d44258b5378e767c51e516e3aae70af077ea8ac048e01503a58bb67ab7173a7e4440b76cb11d7f0215e52c549612ad1cab453babf0001d0b5e641989e90aa414ca2163bd48f86c9433abc966339ba69810feff11d1bec1c356ae37037faa18c41c51da5328e07c47e3b15f58dce63759ae08589f2f5996ebc32fa5478c56ba82d343e8fd276520169cc88d7f87a2658fbf56b7dff4ed20985140b25b8e05de26cbdd6de727f75f7c4e861569172b21b07cff41fb47817f898d18373b92dbe4313d4724584ac5d0e1be7e534fad8da414697959d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ab2beec4f19cdcf7b5c909265e03bcab"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
